{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.6.12;\n\n\n\n// Part: GTCErc20\n\n/** \n * @title - A retroactive ERC20 token distribution contract \n * @author - zk@WolfDefi\n * @notice - Provided an EIP712 compliant signed message & token claim, distributes GTC tokens \n **/\n\n/**\n* @notice interface for interacting with GTCToken delegate function\n*/\ninterface GTCErc20 {\n    function delegateOnDist(address, address) external;\n}\n\n// Part: OpenZeppelin/openzeppelin-contracts@3.2.0/ECDSA\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Check the signature length\n        if (signature.length != 65) {\n            revert(\"ECDSA: invalid signature length\");\n        }\n\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n\n        if (v != 27 && v != 28) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), \"ECDSA: invalid signature\");\n\n        return signer;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * replicates the behavior of the\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\n     * JSON-RPC method.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n}\n\n// Part: OpenZeppelin/openzeppelin-contracts@3.2.0/IERC20\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// Part: OpenZeppelin/openzeppelin-contracts@3.2.0/MerkleProof\n\n/**\n * @dev These functions deal with verification of Merkle trees (hash trees),\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        bytes32 computedHash = leaf;\n\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n        }\n\n        // Check if the computed hash (root) is equal to the provided root\n        return computedHash == root;\n    }\n}\n\n// File: TokenDistributor.sol\n\ncontract TokenDistributor{ \n    \n    address immutable public signer;\n    address immutable public token; \n    uint immutable public deployTime;\n    address immutable public timeLockContract;\n    bytes32 immutable public merkleRoot;\n\n    // hash of the domain separator\n    bytes32 DOMAIN_SEPARATOR;\n\n    // This is a packed array of booleans.\n    mapping(uint256 => uint256) private claimedBitMap;\n    \n    // EIP712 domain struct \n    struct EIP712Domain {\n        string  name;\n        string  version;\n        uint256 chainId;\n        address verifyingContract;\n    }\n\n    // How long will this contract process token claims? 30 days\n    uint public constant CONTRACT_ACTIVE = 30 days;\n\n    // as required by EIP712, we create type hash that will be rolled up into the final signed message\n    bytes32 constant EIP712DOMAIN_TYPEHASH = keccak256(\n        \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n    );\n\n    // typehash for our token claim - matches the Claim struct  \n    bytes32 constant GTC_TOKEN_CLAIM_TYPEHASH = keccak256(\n        \"Claim(uint32 user_id,address user_address,uint256 user_amount,address delegate_address,bytes32 leaf)\"\n    );\n    \n    // This event is triggered when a call to ClaimTokens succeeds.\n    event Claimed(uint256 user_id, address account, uint256 amount, bytes32 leaf);\n\n    // This event is triggered when unclaimed drops are moved to Timelock after CONTRACT_ACTIVE period \n    event TransferUnclaimed(uint256 amount);\n\n    /**\n     * @notice Construct a new TokenDistribution contract \n     * @param _signer - public key matching the private key that will be signing claims\n     * @param _token - address of ERC20 that claims will be distributed from\n     * @param _timeLock - address of the timelock contract where unclaimed funds will be swept   \n     **/\n    constructor(address _token, address _signer, address _timeLock, bytes32 _merkleRoot) public {\n        signer = _signer;\n        token = _token;\n        merkleRoot = _merkleRoot;\n        timeLockContract = _timeLock;\n        deployTime = block.timestamp; \n        \n        DOMAIN_SEPARATOR = hash(EIP712Domain({\n            name: \"GTC\",\n            version: '1.0.0',\n            chainId: 1,\n            verifyingContract: address(this)\n        }));\n\n    }\n    \n    /**\n    * @notice process incoming token claims, must be signed by <signer>  \n    * @param user_id - serves as nonce - only one claim per user_id\n    * @param user_address - ethereum account token claim will be transfered too\n    * @param user_amount - amount user will receive, in wei\n    * @param delegate_address - address token claim will be deletaged too \n    * @param eth_signed_message_hash_hex - EIP712 pre-signed message hash payload\n    * @param eth_signed_signature_hex = eth_sign style, EIP712 compliant, signed message\n    * @param merkleProof - proof hashes for leaf\n    * @param leaf - leaf hash for user claim in merkle tree    \n    **/\n    function claimTokens(\n        uint32 user_id, \n        address user_address, \n        uint256 user_amount,\n        address delegate_address, \n        bytes32 eth_signed_message_hash_hex, \n        bytes memory eth_signed_signature_hex,\n        bytes32[] calldata merkleProof,\n        bytes32 leaf\n\n        ) external {\n\n        // only accept claim if msg.sender address is in signed claim   \n        require(msg.sender == user_address, 'TokenDistributor: Must be msg sender.');\n\n        // one claim per user  \n        require(!isClaimed(user_id), 'TokenDistributor: Tokens already claimed.');\n        \n        // claim must provide a message signed by defined <signer>  \n        require(isSigned(eth_signed_message_hash_hex, eth_signed_signature_hex), 'TokenDistributor: Valid Signature Required.');\n        \n        bytes32 hashed_base_claim = keccak256(abi.encode( \n            GTC_TOKEN_CLAIM_TYPEHASH,\n            user_id,\n            user_address,\n            user_amount, \n            delegate_address, \n            leaf\n        ));\n\n        bytes32 digest = keccak256(abi.encodePacked(\n            \"\\x19\\x01\",\n            DOMAIN_SEPARATOR,\n            hashed_base_claim\n        ));\n\n        // can we reproduce the same hash from the raw claim metadata? \n        require(digest == eth_signed_message_hash_hex, 'TokenDistributor: Claim Hash Mismatch.');\n        \n        // can we repoduce leaf hash included in the claim?\n        bytes32 leaf_hash = keccak256(abi.encode(keccak256(abi.encode(user_id, user_amount))));\n        require(leaf == leaf_hash, 'TokenDistributor: Leaf Hash Mismatch.');\n\n        // does the leaf exist on our tree? \n        require(MerkleProof.verify(merkleProof, merkleRoot, leaf), 'TokenDistributor: Valid Proof Required.');\n        \n        // process token claim !! \n        _delegateTokens(user_address, delegate_address); \n        _setClaimed(user_id);\n   \n        require(IERC20(token).transfer(user_address, user_amount), 'TokenDistributor: Transfer failed.');\n        emit Claimed(user_id, user_address, user_amount, leaf);\n    }\n    \n    /**\n    * @notice checks claimedBitMap to see if if user_id is 0/1\n    * @dev fork from uniswap merkle distributor, unmodified\n    * @return - boolean  \n    **/\n    function isClaimed(uint256 index) public view returns (bool) {\n        uint256 claimedWordIndex = index / 256;\n        uint256 claimedBitIndex = index % 256;\n        uint256 claimedWord = claimedBitMap[claimedWordIndex];\n        uint256 mask = (1 << claimedBitIndex);\n        return claimedWord & mask == mask;\n    }\n    \n    /**\n    * @notice used to move any remaining tokens out of the contract after expiration   \n    **/\n    function transferUnclaimed() public {\n        require(block.timestamp >= deployTime + CONTRACT_ACTIVE, 'TokenDistributor: Contract is still active.');\n        // transfer all GTC to TimeLock\n        uint remainingBalance = IERC20(token).balanceOf(address(this));\n        require(IERC20(token).transfer(timeLockContract, remainingBalance), 'TokenDistributor: Transfer unclaimed failed.');\n        emit TransferUnclaimed(remainingBalance);\n    }\n\n    /**\n    * @notice verify that a message was signed by the holder of the private keys of a given address\n    * @return true if message was signed by signer designated on contstruction, else false \n    **/\n    function isSigned(bytes32 eth_signed_message_hash_hex, bytes memory eth_signed_signature_hex) internal view returns (bool) {\n        address untrusted_signer = ECDSA.recover(eth_signed_message_hash_hex, eth_signed_signature_hex);\n        return untrusted_signer == signer;\n    }\n\n    /**\n    * @notice - function can be used to create DOMAIN_SEPARATORs\n    * @dev - from EIP712 spec, unmodified \n    **/\n    function hash(EIP712Domain memory eip712Domain) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            EIP712DOMAIN_TYPEHASH,\n            keccak256(bytes(eip712Domain.name)),\n            keccak256(bytes(eip712Domain.version)),\n            eip712Domain.chainId,\n            eip712Domain.verifyingContract\n        ));\n    }\n\n    /**\n    * @notice Sets a given user_id to claimed \n    * @dev taken from uniswap merkle distributor, unmodified\n    **/\n    function _setClaimed(uint256 index) private {\n        uint256 claimedWordIndex = index / 256;\n        uint256 claimedBitIndex = index % 256;\n        claimedBitMap[claimedWordIndex] = claimedBitMap[claimedWordIndex] | (1 << claimedBitIndex);\n    }\n\n    /**\n    * @notice execute call on token contract to delegate tokens   \n    */\n    function _delegateTokens(address delegator, address delegatee) private {\n         GTCErc20  GTCToken = GTCErc20(token);\n         GTCToken.delegateOnDist(delegator, delegatee);\n    } \n}\n","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_timeLock\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"user_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferUnclaimed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CONTRACT_ACTIVE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"user_id\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"user_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"user_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"delegate_address\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"eth_signed_message_hash_hex\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"eth_signed_signature_hex\",\"type\":\"bytes\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"}],\"name\":\"claimTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deployTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"isClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"merkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"signer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeLockContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferUnclaimed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"TokenDistributor","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000de30da39c46104798bb5aa3fe8b9e0e1f348163f0000000000000000000000002a864f9b07c51480c62fe09601d4469dc95296f700000000000000000000000057a8865cfb1ecef7253c27da6b4bc3daee5be518adbd1f4ac8653b35d3e4e3383beeea3a616b3efaa94932a654035a03c49313e6","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}