{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity ^0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/*\r\n    a0 a1 a2 a3\r\n\r\n    ---Rank 4-----------------------------------\r\n    a0 a1 a2 a3 => 60%\r\n\r\n    ---Rank 3-----------------------------------\r\n    (a0 a1 a2 !a3) => 25%\r\n\r\n    ---Rank 2-----------------------------------\r\n    a0a1 or a1a2 or a2a3 => 10%\r\n\r\n    ---Rank 1-----------------------------------\r\n    a0 or a1 or a2 or a3 => 4%\r\n    \r\n    1% -> dev\r\n    --------------------------------------------\r\n    \r\n    If nobody won anything (not even 1 number):\r\n\r\n    1% -> dev\r\n    4% -> burned\r\n    95% -> next pot\r\n\r\n*/\r\n\r\ncontract Lottery {\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => mapping(uint256 => uint256[])) private tickets;\r\n    mapping(address => uint256) private numOfTickets;\r\n    mapping(address => bool) private isPlayer;\r\n    address[] public players;\r\n\r\n    uint256 public numPlayers;\r\n    uint256 public numTickets;\r\n    uint256 public previousPot;\r\n    uint256 public lotoID;\r\n\r\n    uint256 public rank1Num = 0;\r\n    uint256 public rank2Num = 0;\r\n    uint256 public rank3Num = 0;\r\n    uint256 public rank4Num = 0;\r\n\r\n    mapping(address => bool) private winningPlayersPushed;\r\n    mapping(address => uint256) private winningTicketNum;\r\n    mapping(address => mapping(uint256 => uint256[])) private winningTickets;\r\n    address[] public winningPlayers;\r\n\r\n    uint256[] public winningNumbers;\r\n\r\n    IERC20 public inu;\r\n    address public devX;\r\n    uint256 public ticketPrice;\r\n    bool public lotoEnabled;\r\n    bool public buyingEnabled;\r\n\r\n    event BoughtTicket(address player, uint256[] numbers);\r\n\r\n    constructor(\r\n        address inu_,\r\n        address devX_,\r\n        uint256 ticketPrice_\r\n    ) public {\r\n        inu = IERC20(inu_);\r\n        devX = devX_;\r\n        ticketPrice = ticketPrice_;\r\n    }\r\n\r\n    modifier onlyDev() {\r\n        require(msg.sender == devX, \"Dev Only\");\r\n        _;\r\n    }\r\n\r\n    function append(string memory a, string memory b)\r\n        internal\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        return string(abi.encodePacked(a, b));\r\n    }\r\n\r\n    function toString(uint256 num) internal pure returns (string memory) {\r\n        if (num == 0) {\r\n            return \"0\";\r\n        } else if (num == 1) {\r\n            return \"1\";\r\n        } else if (num == 2) {\r\n            return \"2\";\r\n        } else if (num == 3) {\r\n            return \"3\";\r\n        } else if (num == 4) {\r\n            return \"4\";\r\n        } else if (num == 5) {\r\n            return \"5\";\r\n        } else if (num == 6) {\r\n            return \"6\";\r\n        } else if (num == 7) {\r\n            return \"7\";\r\n        } else if (num == 8) {\r\n            return \"8\";\r\n        } else if (num == 9) {\r\n            return \"9\";\r\n        }\r\n    }\r\n\r\n    function getTickets(address address_) public view returns (string memory) {\r\n        string memory result = \"\";\r\n        uint256 numTicket = numOfTickets[address_];\r\n        for (uint256 i = 0; i < numTicket; i++) {\r\n            for (uint256 j = 0; j < 4; j++) {\r\n                result = append(result, toString(tickets[address_][i][j]));\r\n            }\r\n            result = append(result, \"-\");\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function getWinningNumber() public view returns (string memory) {\r\n        string memory result = \"\";\r\n        for (uint256 i = 0; i < winningNumbers.length; i++) {\r\n            result = append(result, toString(winningNumbers[i]));\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function getWinningTickets(address address_)\r\n        public\r\n        view\r\n        returns (string memory)\r\n    {\r\n        string memory result = \"\";\r\n        uint256 numTicket = winningTicketNum[address_];\r\n        for (uint256 i = 0; i < numTicket; i++) {\r\n            for (uint256 j = 0; j < 4; j++) {\r\n                result = append(\r\n                    result,\r\n                    toString(winningTickets[address_][i][j])\r\n                );\r\n            }\r\n            result = append(result, \"-\");\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function getPot() external view returns (uint256) {\r\n        return inu.balanceOf(address(this));\r\n    }\r\n\r\n    function setTicketPrice(uint256 price) external onlyDev() {\r\n        ticketPrice = price;\r\n    }\r\n\r\n    function startLoto() external onlyDev() {\r\n        // Reset everything\r\n        for (uint256 i = 0; i < players.length; i++) {\r\n            numOfTickets[players[i]] = 0;\r\n            isPlayer[players[i]] = false;\r\n        }\r\n\r\n        for (uint256 i = 0; i < winningPlayers.length; i++) {\r\n            winningTicketNum[winningPlayers[i]] = 0;\r\n            winningPlayersPushed[winningPlayers[i]] = false;\r\n        }\r\n\r\n        delete players;\r\n        delete winningPlayers;\r\n\r\n        numTickets = 0;\r\n        numPlayers = 0;\r\n\r\n        lotoEnabled = true;\r\n        buyingEnabled = true;\r\n    }\r\n\r\n    function disableBuying() external onlyDev() {\r\n        buyingEnabled = false;\r\n    }\r\n\r\n    function endLoto(uint256[] memory winningN) external onlyDev() {\r\n        lotoEnabled = false;\r\n        buyingEnabled = false;\r\n        lotoID += 1;\r\n        winningNumbers = winningN;\r\n        determineWinners();\r\n        if (winningPlayers.length > 0) {\r\n            payoutRewards();\r\n        } else {\r\n            if (inu.balanceOf(address(this)) > 0) {\r\n                previousPot = inu.balanceOf(address(this));\r\n                uint256 devR = inu.balanceOf(address(this)).div(100);\r\n                uint256 burnR = inu.balanceOf(address(this)).mul(4).div(100);\r\n                inu.transfer(devX, devR);\r\n\r\n                if (inu.balanceOf(address(this)) < burnR) {\r\n                    burnR = inu.balanceOf(address(this));\r\n                }\r\n                inu.transfer(\r\n                    address(0x000000000000000000000000000000000000dEaD),\r\n                    burnR\r\n                );\r\n            } else {\r\n                previousPot = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    function determineWinners() internal {\r\n        for (uint256 i = 0; i < players.length; i++) {\r\n            uint256 numTicket = numOfTickets[players[i]];\r\n            uint256 numOfWinningTickets = 0;\r\n            for (uint256 j = 0; j < numTicket; j++) {\r\n                uint256[] memory currentTicket = tickets[players[i]][j];\r\n                uint256 rank = scanTicket(currentTicket, false);\r\n                if (rank != 0) {\r\n                    if (!winningPlayersPushed[players[i]]) {\r\n                        winningPlayers.push(players[i]);\r\n                        winningPlayersPushed[players[i]] = true;\r\n                    }\r\n                    winningTickets[players[i]][\r\n                        numOfWinningTickets\r\n                    ] = currentTicket;\r\n                    numOfWinningTickets = numOfWinningTickets + 1;\r\n                }\r\n            }\r\n            winningTicketNum[players[i]] = numOfWinningTickets;\r\n        }\r\n    }\r\n\r\n    function payoutRewards() internal onlyDev() {\r\n        uint256 rank1 = 0;\r\n        uint256 rank2 = 0;\r\n        uint256 rank3 = 0;\r\n        uint256 rank4 = 0;\r\n\r\n        for (uint256 i = 0; i < winningPlayers.length; i++) {\r\n            uint256 numTickets_ = winningTicketNum[winningPlayers[i]];\r\n            for (uint256 j = 0; j < numTickets_; j++) {\r\n                uint256 rank = scanTicket(\r\n                    winningTickets[winningPlayers[i]][j],\r\n                    false\r\n                );\r\n                if (rank == 1) {\r\n                    rank1 += 1;\r\n                } else if (rank == 2) {\r\n                    rank2 += 1;\r\n                } else if (rank == 3) {\r\n                    rank3 += 1;\r\n                } else if (rank == 4) {\r\n                    rank4 += 1;\r\n                }\r\n            }\r\n        }\r\n\r\n        rank1Num = rank1;\r\n        rank2Num = rank2;\r\n        rank3Num = rank3;\r\n        rank4Num = rank4;\r\n\r\n        uint256 rewardRank4 = inu.balanceOf(address(this)).mul(60).div(100);\r\n        uint256 rewardRank3 = inu.balanceOf(address(this)).mul(25).div(100);\r\n        uint256 rewardRank2 = inu.balanceOf(address(this)).mul(10).div(100);\r\n        uint256 rewardRank1 = inu.balanceOf(address(this)).mul(4).div(100);\r\n        uint256 rewardDev = inu\r\n        .balanceOf(address(this))\r\n        .sub(rewardRank1)\r\n        .sub(rewardRank2)\r\n        .sub(rewardRank3)\r\n        .sub(rewardRank4);\r\n\r\n        if (rank1 != 0) {\r\n            rewardRank1 = rewardRank1.div(rank1);\r\n        }\r\n        if (rank2 != 0) {\r\n            rewardRank2 = rewardRank2.div(rank2);\r\n        }\r\n        if (rank3 != 0) {\r\n            rewardRank3 = rewardRank3.div(rank3);\r\n        }\r\n        if (rank4 != 0) {\r\n            rewardRank4 = rewardRank4.div(rank4);\r\n        }\r\n        uint256 help = 0;\r\n        for (uint256 i = 0; i < winningPlayers.length; i++) {\r\n            uint256 numTickets_ = winningTicketNum[winningPlayers[i]];\r\n            for (uint256 j = 0; j < numTickets_; j++) {\r\n                uint256 rank = scanTicket(\r\n                    winningTickets[winningPlayers[i]][j],\r\n                    false\r\n                );\r\n\r\n                if (rank == 1 && rank1 != 0) {\r\n                    if (rewardRank1 > inu.balanceOf(address(this))) {\r\n                        rewardRank1 = inu.balanceOf(address(this));\r\n                    }\r\n                    inu.transfer(winningPlayers[i], rewardRank1);\r\n                    help += rewardRank1;\r\n                } else if (rank == 2 && rank2 != 0) {\r\n                    if (rewardRank2 > inu.balanceOf(address(this))) {\r\n                        rewardRank2 = inu.balanceOf(address(this));\r\n                    }\r\n                    inu.transfer(winningPlayers[i], rewardRank2);\r\n                    help += rewardRank2;\r\n                } else if (rank == 3 && rank3 != 0) {\r\n                    if (rewardRank3 > inu.balanceOf(address(this))) {\r\n                        rewardRank3 = inu.balanceOf(address(this));\r\n                    }\r\n                    inu.transfer(winningPlayers[i], rewardRank3);\r\n                    help += rewardRank3;\r\n                } else if (rank == 4 && rank4 != 0) {\r\n                    if (rewardRank4 > inu.balanceOf(address(this))) {\r\n                        rewardRank4 = inu.balanceOf(address(this));\r\n                    }\r\n                    inu.transfer(winningPlayers[i], rewardRank4);\r\n                    help += rewardRank4;\r\n                }\r\n            }\r\n        }\r\n        if (rewardDev > inu.balanceOf(address(this))) {\r\n            rewardDev = inu.balanceOf(address(this));\r\n        }\r\n        inu.transfer(devX, rewardDev);\r\n        help += rewardDev;\r\n\r\n        previousPot = help;\r\n    }\r\n\r\n    function scanTicket(uint256[] memory ticket, bool ext)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (ext && lotoEnabled) {\r\n            return 0;\r\n        }\r\n        uint256 toNum = 1000 *\r\n            ticket[0] +\r\n            100 *\r\n            ticket[1] +\r\n            10 *\r\n            ticket[2] +\r\n            ticket[3];\r\n        uint256 winningtoNum = 1000 *\r\n            winningNumbers[0] +\r\n            100 *\r\n            winningNumbers[1] +\r\n            10 *\r\n            winningNumbers[2] +\r\n            winningNumbers[3];\r\n\r\n        if (toNum == winningtoNum) {\r\n            return 4;\r\n        } else if (\r\n            (ticket[0] == winningNumbers[0] &&\r\n                ticket[1] == winningNumbers[1] &&\r\n                ticket[2] == winningNumbers[2])\r\n        ) {\r\n            return 3;\r\n        } else if (\r\n            (ticket[0] == winningNumbers[0] &&\r\n                ticket[1] == winningNumbers[1]) ||\r\n            (ticket[1] == winningNumbers[1] &&\r\n                ticket[2] == winningNumbers[2]) ||\r\n            (ticket[2] == winningNumbers[2] && ticket[3] == winningNumbers[3])\r\n        ) {\r\n            return 2;\r\n        } else if (\r\n            (ticket[0] == winningNumbers[0]) ||\r\n            (ticket[1] == winningNumbers[1]) ||\r\n            (ticket[2] == winningNumbers[2]) ||\r\n            (ticket[3] == winningNumbers[3])\r\n        ) {\r\n            return 1;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function buyTicket(uint256[] memory numbers) internal {\r\n        require(lotoEnabled, \"Loto Disabled\");\r\n        require(buyingEnabled, \"Buying Disabled\");\r\n        require(inu.balanceOf(msg.sender) >= ticketPrice, \"Low Balance\");\r\n        for (uint256 i = 0; i < 4; i++) {\r\n            require(numbers[i] <= 9);\r\n            require(numbers[i] >= 0);\r\n        }\r\n\r\n        if (!isPlayer[msg.sender]) {\r\n            players.push(msg.sender);\r\n            isPlayer[msg.sender] = true;\r\n            numPlayers += 1;\r\n        }\r\n\r\n        tickets[msg.sender][numOfTickets[msg.sender]] = numbers;\r\n        numOfTickets[msg.sender] = numOfTickets[msg.sender] + 1;\r\n        numTickets += 1;\r\n\r\n        emit BoughtTicket(msg.sender, numbers);\r\n    }\r\n\r\n    function buyMultipleTicket(uint256[][] memory tickets_) external {\r\n        require(\r\n            inu.balanceOf(msg.sender) >= ticketPrice.mul(tickets_.length),\r\n            \"Low Balance\"\r\n        );\r\n\r\n        inu.transferFrom(\r\n            msg.sender,\r\n            address(this),\r\n            ticketPrice.mul(tickets_.length)\r\n        );\r\n\r\n        for (uint256 i = 0; i < tickets_.length; i++) {\r\n            buyTicket(tickets_[i]);\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"inu_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"devX_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ticketPrice_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"numbers\",\"type\":\"uint256[]\"}],\"name\":\"BoughtTicket\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256[][]\",\"name\":\"tickets_\",\"type\":\"uint256[][]\"}],\"name\":\"buyMultipleTicket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devX\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableBuying\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"winningN\",\"type\":\"uint256[]\"}],\"name\":\"endLoto\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"getTickets\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWinningNumber\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"getWinningTickets\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inu\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lotoEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lotoID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numPlayers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numTickets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"players\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"previousPot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rank1Num\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rank2Num\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rank3Num\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rank4Num\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ticket\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"ext\",\"type\":\"bool\"}],\"name\":\"scanTicket\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"setTicketPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startLoto\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ticketPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"winningNumbers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"winningPlayers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Lottery","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000f29171d7bcdc464a0758cf3217fe83173772b900000000000000000000000028a782553c4b3f78991b41cb47ab4d78716ef738000000000000000000000000000000000000000000000000000000e8d4a51000","EVMVersion":"Default","Library":"","LicenseType":"Unlicense","Proxy":"0","Implementation":"","SwarmSource":"ipfs://4e208893cba7b9d89fcc57a72273d8e5e464f206ebe3b979e745921e945ad75d"}]}