{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/rita/Documents/less-staking/contracts/Staking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract Staking is Ownable, ReentrancyGuard {\\n    //STRUCTURES:--------------------------------------------------------\\n    struct AccountInfo {\\n        uint256 lessBalance;\\n        uint256 lpBalance;\\n        uint256 overallBalance;\\n    }\\n\\n    struct StakeItem {\\n        uint256 startTime;\\n        uint256 stakedLp;\\n        uint256 stakedLess;\\n    }\\n\\n    struct UserStakes {\\n        uint256[] ids;\\n        mapping(uint256 => uint256) indexes;\\n    }\\n\\n    struct DepositReward {\\n        uint256 day;\\n        uint256 lpShares;\\n        uint256 lessShares;\\n        uint256 lpReward;\\n        uint256 lessReward;\\n    }\\n\\n    //FIELDS:----------------------------------------------------\\n    ERC20 public lessToken;\\n    ERC20 public lpToken;\\n\\n    uint256 public contractStart;\\n    uint256 public minStakeTime;\\n    uint256 public dayDuration;\\n    uint256 public participants;\\n    uint16 public penaltyDistributed = 25; //100% = PERCENT_FACTOR\\n    uint16 public penaltyBurned = 25; //100% = PERCENT_FACTOR\\n    uint256 private constant PERCENT_FACTOR = 1000;\\n    uint256 public lessPerLp = 300; //1 LP = 300 LESS\\n\\n    uint256 public stakeIdLast;\\n\\n    uint256 public allLp;\\n    uint256 public allLess;\\n    uint256 public totalLpRewards;\\n    uint256 public totalLessRewards;\\n\\n    mapping(address => AccountInfo) private accountInfos;\\n    mapping(address => UserStakes) private userStakes;\\n    mapping(uint256 => StakeItem) public stakes;\\n    mapping(uint256 => DepositReward) public rewardDeposits;\\n    mapping(uint256 => uint256) private _dayIndexies;\\n    mapping(uint256 => bool) private _firstTransactionPerDay;\\n\\n    uint8[4] public poolPercentages;\\n    uint256[5] public stakingTiers;\\n\\n    uint256 private _todayPenaltyLp;\\n    uint256 private _todayPenaltyLess;\\n    uint256 private _lastDayPenalty;\\n    uint256 private _lastDayIndex;\\n    uint256[] private _depositDays;\\n\\n    //CONSTRUCTOR-------------------------------------------------------\\n    constructor(\\n        ERC20 _lp,\\n        ERC20 _less,\\n        uint256 _dayDuration,\\n        uint256 _startTime\\n    ) {\\n        require(_dayDuration > 0 && _startTime > 0, \\\"Error: wrong params\\\");\\n        lessToken = _less;\\n        lpToken = _lp;\\n\\n        dayDuration = _dayDuration;\\n        minStakeTime = _dayDuration * 30;\\n        contractStart = _startTime;\\n\\n        poolPercentages[0] = 30; //tier 5\\n        poolPercentages[1] = 20; //tier 4\\n        poolPercentages[2] = 15; //tier 3\\n        poolPercentages[3] = 25; //tier 2\\n\\n        stakingTiers[0] = 200000 ether; //tier 5\\n        stakingTiers[1] = 50000 ether; //tier 4\\n        stakingTiers[2] = 20000 ether; //tier 3\\n        stakingTiers[3] = 5000 ether; //tier 2\\n        stakingTiers[4] = 1000 ether; //tier 1\\n\\n        _firstTransactionPerDay[0] = true;\\n    }\\n\\n    //EVENTS:-----------------------------------------------------------------\\n    event Staked(\\n        address staker,\\n        uint256 stakeId,\\n        uint256 startTime,\\n        uint256 stakedLp,\\n        uint256 stakedLess\\n    );\\n\\n    event Unstaked(\\n        address staker,\\n        uint256 stakeId,\\n        uint256 unstakeTime,\\n        bool isUnstakedEarlier\\n    );\\n\\n    //MODIFIERS:---------------------------------------------------\\n\\n    modifier onlyWhenOpen() {\\n        require(block.timestamp > contractStart, \\\"Error: early\\\");\\n        _;\\n    }\\n\\n    //EXTERNAL AND PUBLIC WRITE FUNCTIONS:---------------------------------------------------\\n\\n    /**\\n     * @dev stake tokens\\n     * @param lpAmount Amount of staked LP tokens\\n     * @param lessAmount Amount of staked Less tokens\\n     */\\n\\n    function stake(uint256 lpAmount, uint256 lessAmount)\\n        external\\n        nonReentrant\\n        onlyWhenOpen\\n    {\\n        address sender = _msgSender();\\n        uint256 today = _currentDay();\\n        if(participants == 0 && totalLessRewards + totalLpRewards > 0){\\n            _todayPenaltyLp = totalLpRewards;\\n            _todayPenaltyLess = totalLessRewards;\\n            _lastDayPenalty = today;\\n        }\\n        _rewriteTodayVars();\\n        if (userStakes[sender].ids.length == 0) {\\n            participants++;\\n        }\\n        require(lpAmount > 0 || lessAmount > 0, \\\"Error: zero staked tokens\\\");\\n\\n        if (lpAmount > 0) {\\n            require(\\n                lpToken.transferFrom(sender, address(this), lpAmount),\\n                \\\"Error: LP token tranfer failed\\\"\\n            );\\n            allLp += lpAmount;\\n        }\\n        if (lessAmount > 0) {\\n            require(\\n                lessToken.transferFrom(sender, address(this), lessAmount),\\n                \\\"Error: Less token tranfer failed\\\"\\n            );\\n            allLess += lessAmount;\\n        }\\n\\n        AccountInfo storage account = accountInfos[sender];\\n\\n        account.lpBalance += lpAmount;\\n        account.lessBalance += lessAmount;\\n        account.overallBalance += lessAmount + getLpInLess(lpAmount);\\n\\n        StakeItem memory newStake = StakeItem(today, lpAmount, lessAmount);\\n        stakes[stakeIdLast] = newStake;\\n        userStakes[sender].ids.push(stakeIdLast);\\n        userStakes[sender].indexes[stakeIdLast] = userStakes[sender].ids.length;\\n\\n        emit Staked(sender, stakeIdLast++, today, lpAmount, lessAmount);\\n    }\\n\\n    /**\\n     * @dev unstake all tokens and rewards\\n     * @param _stakeId id of the unstaked pool\\n     */\\n\\n    function unstake(uint256 _stakeId) public onlyWhenOpen {\\n        _unstake(_stakeId, false);\\n    }\\n\\n    /**\\n     * @dev unstake all tokens and rewards without penalty. Only for owner\\n     * @param _stakeId id of the unstaked pool\\n     */\\n\\n    function unstakeWithoutPenalty(uint256 _stakeId)\\n        external\\n        onlyOwner\\n        onlyWhenOpen\\n    {\\n        _unstake(_stakeId, true);\\n    }\\n\\n    /**\\n     * @dev withdraw all of unsold reward tokens. Only for owner\\n     */\\n    \\n    function emergencyWithdraw() external onlyOwner onlyWhenOpen nonReentrant {\\n        require(participants == 0 && totalLpRewards + totalLessRewards > 0, \\\"Error: owner's emergency rewards withdraw is not available\\\");\\n        uint256 lessToTransfer = totalLessRewards;\\n        uint256 lpToTransfer = totalLpRewards;\\n        if(totalLessRewards > 0){\\n            totalLessRewards = 0;\\n            require(lessToken.transfer(owner(), lessToTransfer), \\\"Error: can't send tokens\\\");\\n        }\\n        if(totalLpRewards > 0){\\n            totalLpRewards = 0;\\n            require(lpToken.transfer(owner(), lpToTransfer), \\\"Error: can't send tokens\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev set num of Less per one LP\\n     */\\n\\n    function setLessInLP(uint256 amount) public onlyOwner {\\n        lessPerLp = amount;\\n    }\\n\\n    /**\\n     * @dev set minimum days of stake for unstake without penalty\\n     */\\n\\n    function setMinTimeToStake(uint256 _minTimeInDays) public onlyOwner {\\n        require(_minTimeInDays > 0, \\\"Error: zero time\\\");\\n        minStakeTime = _minTimeInDays * dayDuration;\\n    }\\n\\n    /**\\n     * @dev set penalty percent\\n     */\\n    function setPenalty(uint16 distributed, uint16 burned) public onlyOwner {\\n        penaltyDistributed = distributed;\\n        penaltyBurned = burned;\\n    }\\n\\n    function setLp(address _lp) external onlyOwner {\\n        lpToken = ERC20(_lp);\\n    }\\n\\n    function setLess(address _less) external onlyOwner {\\n        lessToken = ERC20(_less);\\n    }\\n\\n    function setStakingTiresSums(\\n        uint256 tier1,\\n        uint256 tier2,\\n        uint256 tier3,\\n        uint256 tier4,\\n        uint256 tier5\\n    ) external onlyOwner {\\n        stakingTiers[0] = tier5; //tier 5\\n        stakingTiers[1] = tier4; //tier 4\\n        stakingTiers[2] = tier3; //tier 3\\n        stakingTiers[3] = tier2; //tier 2\\n        stakingTiers[4] = tier1; //tier 1\\n    }\\n\\n    function setPoolPercentages(\\n        uint8 tier2,\\n        uint8 tier3,\\n        uint8 tier4,\\n        uint8 tier5\\n    ) external onlyOwner {\\n        require(\\n            tier2 + tier3 + tier4 + tier5 < 100,\\n            \\\"Percents sum should be less 100\\\"\\n        );\\n\\n        poolPercentages[0] = tier5; //tier 5\\n        poolPercentages[1] = tier4; //tier 4\\n        poolPercentages[2] = tier3; //tier 3\\n        poolPercentages[3] = tier2; //tier 2\\n    }\\n\\n    function addRewards(uint256 lpAmount, uint256 lessAmount)\\n        external\\n        onlyOwner\\n        nonReentrant\\n    {\\n        _rewriteTodayVars();\\n        address sender = _msgSender();\\n        require(lpAmount + lessAmount > 0, \\\"Error: add non zero amount\\\");\\n        if (lpAmount > 0) {\\n            require(\\n                lpToken.transferFrom(sender, address(this), lpAmount),\\n                \\\"Error: can't get your lp tokens\\\"\\n            );\\n            totalLpRewards += lpAmount;\\n            _todayPenaltyLp += lpAmount;\\n        }\\n        if (lessAmount > 0) {\\n            require(\\n                lessToken.transferFrom(sender, address(this), lessAmount),\\n                \\\"Error: can't get your less tokens\\\"\\n            );\\n            totalLessRewards += lessAmount;\\n            _todayPenaltyLess += lessAmount;\\n        }\\n        _lastDayPenalty = _currentDay();\\n    }\\n\\n    //EXTERNAL AND PUBLIC READ FUNCTIONS:--------------------------------------------------\\n\\n    function getUserTier(address user) external view returns (uint8) {\\n        uint256 balance = accountInfos[user].overallBalance;\\n        for (uint8 i = 0; i < stakingTiers.length; i++) {\\n            if (balance >= stakingTiers[i])\\n                return uint8(stakingTiers.length - i);\\n        }\\n        return 0;\\n    }\\n\\n    function getLpRewradsAmount(uint256 id)\\n        external\\n        view\\n        returns (uint256 lpRewards)\\n    {\\n        (lpRewards, ) = _rewards(id);\\n    }\\n\\n    function getLessRewradsAmount(uint256 id)\\n        external\\n        view\\n        returns (uint256 lessRewards)\\n    {\\n        (, lessRewards) = _rewards(id);\\n    }\\n\\n    function getLpBalanceByAddress(address user)\\n        external\\n        view\\n        returns (uint256 lp)\\n    {\\n        lp = accountInfos[user].lpBalance;\\n    }\\n\\n    function getLessBalanceByAddress(address user)\\n        external\\n        view\\n        returns (uint256 less)\\n    {\\n        less = accountInfos[user].lessBalance;\\n    }\\n\\n    function getOverallBalanceInLessByAddress(address user)\\n        external\\n        view\\n        returns (uint256 overall)\\n    {\\n        overall = accountInfos[user].overallBalance;\\n    }\\n\\n    /**\\n     * @dev return sum of LP converted in Less\\n     * @param _amount amount of converted LP\\n     */\\n    function getLpInLess(uint256 _amount) private view returns (uint256) {\\n        return _amount * lessPerLp;\\n    }\\n\\n    /**\\n     * @dev return full contract balance converted in Less\\n     */\\n    function getOverallBalanceInLess() public view returns (uint256) {\\n        return allLess + allLp * lessPerLp;\\n    }\\n\\n    function getAmountOfUsersStakes(address user)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return userStakes[user].ids.length;\\n    }\\n\\n    function getUserStakeIds(address user)\\n        external\\n        view\\n        returns (uint256[] memory)\\n    {\\n        return userStakes[user].ids;\\n    }\\n\\n    function currentDay() external view onlyWhenOpen returns (uint256) {\\n        return _currentDay();\\n    }\\n\\n    //INTERNAL AND PRIVATE FUNCTIONS-------------------------------------------------------\\n    function _unstake(uint256 id, bool isWithoutPenalty) internal nonReentrant {\\n        address staker = _msgSender();\\n        uint256 today = _currentDay();\\n        _rewriteTodayVars();\\n        require(userStakes[staker].ids.length > 0, \\\"Error: you haven't stakes\\\");\\n        require(userStakes[staker].indexes[id] != 0, \\\"Not ur stake\\\");\\n\\n        bool isUnstakedEarlier = (today - stakes[id].startTime) * dayDuration <\\n            minStakeTime;\\n\\n        uint256 lpRewards;\\n        uint256 lessRewards;\\n        if (!isUnstakedEarlier) (lpRewards, lessRewards) = _rewards(id);\\n\\n        uint256 lpAmount = stakes[id].stakedLp;\\n        uint256 lessAmount = stakes[id].stakedLess;\\n\\n        allLp -= lpAmount;\\n        allLess -= lessAmount;\\n        AccountInfo storage account = accountInfos[staker];\\n\\n        account.lpBalance -= lpAmount;\\n        account.lessBalance -= lessAmount;\\n        account.overallBalance -= lessAmount + getLpInLess(lpAmount);\\n\\n        if (isUnstakedEarlier && !isWithoutPenalty) {\\n            (lpAmount, lessAmount) = payPenalty(lpAmount, lessAmount);\\n            (uint256 freeLp, uint256 freeLess) = _rewards(id);\\n            if (freeLp > 0) _todayPenaltyLp += freeLp;\\n            if (freeLess > 0) _todayPenaltyLess += freeLess;\\n            _lastDayPenalty = today;\\n        }\\n\\n        if (lpAmount + lpRewards > 0) {\\n            require(\\n                lpToken.transfer(staker, lpAmount + lpRewards),\\n                \\\"Error: LP transfer failed\\\"\\n            );\\n        }\\n        if (lessAmount + lessRewards > 0) {\\n            require(\\n                lessToken.transfer(staker, lessAmount + lessRewards),\\n                \\\"Error: Less transfer failed\\\"\\n            );\\n        }\\n\\n        totalLessRewards -= lessRewards;\\n        totalLpRewards -= lpRewards;\\n        if (userStakes[staker].ids.length == 1) {\\n            participants--;\\n        }\\n\\n        removeStake(staker, id);\\n\\n        emit Unstaked(staker, id, today, isUnstakedEarlier);\\n    }\\n\\n    function payPenalty(uint256 lpAmount, uint256 lessAmount)\\n        private\\n        returns (uint256, uint256)\\n    {\\n        uint256 lpToBurn = (lpAmount * penaltyBurned) / PERCENT_FACTOR;\\n        uint256 lessToBurn = (lessAmount * penaltyBurned) / PERCENT_FACTOR;\\n        uint256 lpToDist = (lpAmount * penaltyDistributed) / PERCENT_FACTOR;\\n        uint256 lessToDist = (lessAmount * penaltyDistributed) / PERCENT_FACTOR;\\n\\n        burnPenalty(lpToBurn, lessToBurn);\\n        distributePenalty(lpToDist, lessToDist);\\n\\n        uint256 lpDecrease = lpToBurn + lpToDist;\\n        uint256 lessDecrease = lessToBurn + lessToDist;\\n\\n        return (lpAmount - lpDecrease, lessAmount - lessDecrease);\\n    }\\n\\n    function _rewards(uint256 id)\\n        private\\n        view\\n        returns (uint256 lpRewards, uint256 lessRewards)\\n    {\\n        StakeItem storage deposit = stakes[id];\\n\\n        uint256 countStartIndex;\\n        uint256 countEndIndex = _depositDays.length;\\n\\n        uint256 i;\\n        for (i = 0; i < _depositDays.length; i++) {\\n            if (deposit.startTime <= _depositDays[i]) {\\n                countStartIndex = i;\\n                break;\\n            }\\n        }\\n        if (countStartIndex == 0 && i == _depositDays.length) {\\n            return (0, 0);\\n        }\\n        uint256 curDay;\\n        for (i = countStartIndex; i < countEndIndex; i++) {\\n            curDay = _dayIndexies[i];\\n            if (rewardDeposits[curDay].lpShares > 0) {\\n                lpRewards +=\\n                    (deposit.stakedLp * rewardDeposits[curDay].lpReward) /\\n                    rewardDeposits[curDay].lpShares;\\n            }\\n            if (rewardDeposits[curDay].lessShares > 0) {\\n                lessRewards +=\\n                    (deposit.stakedLess * rewardDeposits[curDay].lessReward) /\\n                    rewardDeposits[curDay].lessShares;\\n            }\\n        }\\n\\n        return (lpRewards, lessRewards);\\n    }\\n\\n    /**\\n     * @dev destribute penalty among all stakers proportional their stake sum.\\n     * @param lp LP token penalty\\n     * @param less Less token penalty\\n     */\\n\\n    function distributePenalty(uint256 lp, uint256 less) internal {\\n        _todayPenaltyLess += less;\\n        _todayPenaltyLp += lp;\\n        _lastDayPenalty = _currentDay();\\n        totalLpRewards += lp;\\n        totalLessRewards += less;\\n    }\\n\\n    /**\\n     * @dev burn penalty.\\n     * @param lp LP token penalty\\n     * @param less Less token penalty\\n     */\\n\\n    function burnPenalty(uint256 lp, uint256 less) internal {\\n        if (lp > 0) {\\n            require(lpToken.transfer(owner(), lp), \\\"con't get ur tkns\\\");\\n        }\\n        if (less > 0) {\\n            require(lessToken.transfer(owner(), less), \\\"cont get ur tkns\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev remove stake from stakeList by index\\n     * @param staker staker address\\n     * @param id id of stake pool\\n     */\\n\\n    function removeStake(address staker, uint256 id) internal {\\n        delete stakes[id];\\n\\n        require(\\n            userStakes[staker].ids.length != 0,\\n            \\\"Error: whitelist is empty\\\"\\n        );\\n\\n        if (userStakes[staker].ids.length > 1) {\\n            uint256 stakeIndex = userStakes[staker].indexes[id] - 1;\\n            uint256 lastIndex = userStakes[staker].ids.length - 1;\\n            uint256 lastStake = userStakes[staker].ids[lastIndex];\\n            userStakes[staker].ids[stakeIndex] = lastStake;\\n            userStakes[staker].indexes[lastStake] = stakeIndex + 1;\\n        }\\n        userStakes[staker].ids.pop();\\n        userStakes[staker].indexes[id] = 0;\\n    }\\n\\n    function _currentDay() private view returns (uint256) {\\n        return (block.timestamp - contractStart) / dayDuration;\\n    }\\n\\n    function _rewriteTodayVars() private {\\n        uint256 today = _currentDay();\\n        if (\\n            !_firstTransactionPerDay[today] &&\\n            _todayPenaltyLess + _todayPenaltyLp > 0 &&\\n            participants > 0\\n        ) {\\n            rewardDeposits[_lastDayPenalty] = DepositReward(\\n                _lastDayPenalty,\\n                allLp,\\n                allLess,\\n                _todayPenaltyLp,\\n                _todayPenaltyLess\\n            );\\n            _todayPenaltyLp = 0;\\n            _todayPenaltyLess = 0;\\n            _depositDays.push(_lastDayPenalty);\\n            _dayIndexies[_depositDays.length - 1] = _lastDayPenalty;\\n            _firstTransactionPerDay[today] = true;\\n        }\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n        unchecked {\\n            _approve(sender, _msgSender(), currentAllowance - amount);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[sender] = senderBalance - amount;\\n        }\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n\\n        _afterTokenTransfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1\r\n    },\r\n    \"evmVersion\": \"berlin\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"_lp\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"_less\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_dayDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakedLp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakedLess\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unstakeTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isUnstakedEarlier\",\"type\":\"bool\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lpAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lessAmount\",\"type\":\"uint256\"}],\"name\":\"addRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allLess\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allLp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dayDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getAmountOfUsersStakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getLessBalanceByAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"less\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getLessRewradsAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lessRewards\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getLpBalanceByAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getLpRewradsAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lpRewards\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOverallBalanceInLess\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getOverallBalanceInLessByAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"overall\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserStakeIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserTier\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lessPerLp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lessToken\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpToken\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minStakeTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"participants\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"penaltyBurned\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"penaltyDistributed\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolPercentages\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lessShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lessReward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_less\",\"type\":\"address\"}],\"name\":\"setLess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setLessInLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lp\",\"type\":\"address\"}],\"name\":\"setLp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minTimeInDays\",\"type\":\"uint256\"}],\"name\":\"setMinTimeToStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"distributed\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"burned\",\"type\":\"uint16\"}],\"name\":\"setPenalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"tier2\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"tier3\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"tier4\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"tier5\",\"type\":\"uint8\"}],\"name\":\"setPoolPercentages\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tier1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tier2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tier3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tier4\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tier5\",\"type\":\"uint256\"}],\"name\":\"setStakingTiresSums\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lpAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lessAmount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeIdLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakedLp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakedLess\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakingTiers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLessRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLpRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakeId\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakeId\",\"type\":\"uint256\"}],\"name\":\"unstakeWithoutPenalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Staking","CompilerVersion":"v0.8.5+commit.a4f2e591","OptimizationUsed":"1","Runs":"1","ConstructorArguments":"000000000000000000000000432dbbd09fee1dfb2cae40c5abc1a301a2ef76ee00000000000000000000000062786eeacc9246b4018e0146cb7a3efeacd9459d000000000000000000000000000000000000000000000000000000000001518000000000000000000000000000000000000000000000000000000000610d60e2","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}