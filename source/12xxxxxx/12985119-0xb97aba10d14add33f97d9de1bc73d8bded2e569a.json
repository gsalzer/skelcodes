{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: AGPL-3.0\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n/**\r\n * @dev Define interface verifier\r\n */\r\ninterface VerifierRollupInterface {\r\n    function verifyProof(\r\n        uint256[2] calldata proofA,\r\n        uint256[2][2] calldata proofB,\r\n        uint256[2] calldata proofC,\r\n        uint256[1] calldata input\r\n    ) external view returns (bool);\r\n}\r\n\r\n\r\n/**\r\n * @dev Define interface verifier\r\n */\r\ninterface VerifierWithdrawInterface {\r\n    function verifyProof(\r\n        uint256[2] calldata proofA,\r\n        uint256[2][2] calldata proofB,\r\n        uint256[2] calldata proofC,\r\n        uint256[1] calldata input\r\n    ) external view returns (bool);\r\n}\r\n\r\n/**\r\n * @dev Litex will run an auction to incentivise efficiency in coordinators,\r\n * meaning that they need to be very effective and include as many transactions\r\n * as they can in the slots in order to compensate for their bidding costs, gas\r\n * costs and operations costs.The general porpouse of this smartcontract is to\r\n * define the rules to coordinate this auction where the bids will be placed\r\n * only in LXT utility token.\r\n */\r\ninterface ILitexAuctionProtocol {\r\n    /**\r\n     * @notice Getter of the current `_slotDeadline`\r\n     * @return The `_slotDeadline` value\r\n     */\r\n    function getSlotDeadline() external view returns (uint8);\r\n\r\n    /**\r\n     * @notice Allows to change the `_slotDeadline` if it's called by the owner\r\n     * @param newDeadline new `_slotDeadline`\r\n     * Events: `NewSlotDeadline`\r\n     */\r\n    function setSlotDeadline(uint8 newDeadline) external;\r\n\r\n    /**\r\n     * @notice Getter of the current `_openAuctionSlots`\r\n     * @return The `_openAuctionSlots` value\r\n     */\r\n    function getOpenAuctionSlots() external view returns (uint16);\r\n\r\n    /**\r\n     * @notice Allows to change the `_openAuctionSlots` if it's called by the owner\r\n     * @dev Max newOpenAuctionSlots = 65536 slots\r\n     * @param newOpenAuctionSlots new `_openAuctionSlots`\r\n     * Events: `NewOpenAuctionSlots`\r\n     * Note: the governance could set this parameter equal to `ClosedAuctionSlots`, this means that it can prevent bids\r\n     * from being made and that only the boot coordinator can forge\r\n     */\r\n    function setOpenAuctionSlots(uint16 newOpenAuctionSlots) external;\r\n\r\n    /**\r\n     * @notice Getter of the current `_closedAuctionSlots`\r\n     * @return The `_closedAuctionSlots` value\r\n     */\r\n    function getClosedAuctionSlots() external view returns (uint16);\r\n\r\n    /**\r\n     * @notice Allows to change the `_closedAuctionSlots` if it's called by the owner\r\n     * @dev Max newClosedAuctionSlots = 65536 slots\r\n     * @param newClosedAuctionSlots new `_closedAuctionSlots`\r\n     * Events: `NewClosedAuctionSlots`\r\n     * Note: the governance could set this parameter equal to `OpenAuctionSlots`, this means that it can prevent bids\r\n     * from being made and that only the boot coordinator can forge\r\n     */\r\n    function setClosedAuctionSlots(uint16 newClosedAuctionSlots) external;\r\n\r\n    /**\r\n     * @notice Getter of the current `_outbidding`\r\n     * @return The `_outbidding` value\r\n     */\r\n    function getOutbidding() external view returns (uint16);\r\n\r\n    /**\r\n     * @notice Allows to change the `_outbidding` if it's called by the owner\r\n     * @dev newOutbidding between 0.00% and 655.36%\r\n     * @param newOutbidding new `_outbidding`\r\n     * Events: `NewOutbidding`\r\n     */\r\n    function setOutbidding(uint16 newOutbidding) external;\r\n\r\n    /**\r\n     * @notice Getter of the current `_allocationRatio`\r\n     * @return The `_allocationRatio` array\r\n     */\r\n    function getAllocationRatio() external view returns (uint16[3] memory);\r\n\r\n    /**\r\n     * @notice Allows to change the `_allocationRatio` array if it's called by the owner\r\n     * @param newAllocationRatio new `_allocationRatio` uint8[3] array\r\n     * Events: `NewAllocationRatio`\r\n     */\r\n    function setAllocationRatio(uint16[3] memory newAllocationRatio) external;\r\n\r\n    /**\r\n     * @notice Getter of the current `_donationAddress`\r\n     * @return The `_donationAddress`\r\n     */\r\n    function getDonationAddress() external view returns (address);\r\n\r\n    /**\r\n     * @notice Allows to change the `_donationAddress` if it's called by the owner\r\n     * @param newDonationAddress new `_donationAddress`\r\n     * Events: `NewDonationAddress`\r\n     */\r\n    function setDonationAddress(address newDonationAddress) external;\r\n\r\n    /**\r\n     * @notice Getter of the current `_bootCoordinator`\r\n     * @return The `_bootCoordinator`\r\n     */\r\n    function getBootCoordinator() external view returns (address);\r\n\r\n    /**\r\n     * @notice Allows to change the `_bootCoordinator` if it's called by the owner\r\n     * @param newBootCoordinator new `_bootCoordinator` uint8[3] array\r\n     * Events: `NewBootCoordinator`\r\n     */\r\n    function setBootCoordinator(\r\n        address newBootCoordinator,\r\n        string memory newBootCoordinatorURL\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Allows to change the change the min bid for an slotSet if it's called by the owner.\r\n     * @dev If an slotSet has the value of 0 it's considered decentralized, so the minbid cannot be modified\r\n     * @param slotSet the slotSet to update\r\n     * @param newInitialMinBid the minBid\r\n     * Events: `NewDefaultSlotSetBid`\r\n     */\r\n    function changeDefaultSlotSetBid(uint128 slotSet, uint128 newInitialMinBid)\r\n        external;\r\n\r\n    /**\r\n     * @notice Allows to register a new coordinator\r\n     * @dev The `msg.sender` will be considered the `bidder`, who can change the forger address and the url\r\n     * @param forger the address allowed to forger batches\r\n     * @param coordinatorURL endopoint for this coordinator\r\n     * Events: `NewCoordinator`\r\n     */\r\n    function setCoordinator(address forger, string memory coordinatorURL)\r\n        external;\r\n\r\n    /**\r\n     * @notice Function to process a single bid\r\n     * @dev If the bytes calldata permit parameter is empty the smart contract assume that it has enough allowance to\r\n     * make the transferFrom. In case you want to use permit, you need to send the data of the permit call in bytes\r\n     * @param amount the amount of tokens that have been sent\r\n     * @param slot the slot for which the caller is bidding\r\n     * @param bidAmount the amount of the bidding\r\n     */\r\n    function processBid(\r\n        uint128 amount,\r\n        uint128 slot,\r\n        uint128 bidAmount,\r\n        bytes calldata permit\r\n    ) external;\r\n\r\n    /**\r\n     * @notice function to process a multi bid\r\n     * @dev If the bytes calldata permit parameter is empty the smart contract assume that it has enough allowance to\r\n     * make the transferFrom. In case you want to use permit, you need to send the data of the permit call in bytes\r\n     * @param amount the amount of tokens that have been sent\r\n     * @param startingSlot the first slot to bid\r\n     * @param endingSlot the last slot to bid\r\n     * @param slotSets the set of slots to which the coordinator wants to bid\r\n     * @param maxBid the maximum bid that is allowed\r\n     * @param minBid the minimum that you want to bid\r\n     */\r\n    function processMultiBid(\r\n        uint128 amount,\r\n        uint128 startingSlot,\r\n        uint128 endingSlot,\r\n        bool[6] memory slotSets,\r\n        uint128 maxBid,\r\n        uint128 minBid,\r\n        bytes calldata permit\r\n    ) external;\r\n\r\n    /**\r\n     * @notice function to process the forging\r\n     * @param forger the address of the coodirnator's forger\r\n     * Events: `NewForgeAllocated` and `NewForge`\r\n     */\r\n    function forge(address forger) external;\r\n\r\n    /**\r\n     * @notice function to know if a certain address can forge into a certain block\r\n     * @param forger the address of the coodirnator's forger\r\n     * @param blockNumber block number to check\r\n     * @return a bool true in case it can forge, false otherwise\r\n     */\r\n    function canForge(address forger, uint256 blockNumber)\r\n        external\r\n        view\r\n        returns (bool);\r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\r\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\r\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\r\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\r\n * \r\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\r\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\r\n * \r\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\r\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\r\n */\r\nabstract contract Initializable {\r\n\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     */\r\n    bool private _initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private _initializing;\r\n\r\n    /**\r\n     * @dev Modifier to protect an initializer function from being invoked twice.\r\n     */\r\n    modifier initializer() {\r\n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is already initialized\");\r\n\r\n        bool isTopLevelCall = !_initializing;\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n            _initialized = true;\r\n        }\r\n\r\n        _;\r\n\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n        }\r\n    }\r\n\r\n    /// @dev Returns true if and only if the function is running in the constructor\r\n    function _isConstructor() private view returns (bool) {\r\n        // extcodesize checks the size of the code stored in an address, and\r\n        // address returns the current address. Since the code is still not\r\n        // deployed when running a constructor, any checks on its code size will\r\n        // yield zero, making it an effective way to detect if a contract is\r\n        // under construction or not.\r\n        address self = address(this);\r\n        uint256 cs;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { cs := extcodesize(self) }\r\n        return cs == 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Interface poseidon hash function 2 elements\r\n */\r\ncontract PoseidonUnit2 {\r\n    function poseidon(uint256[2] memory) public pure returns (uint256) {}\r\n}\r\n\r\n/**\r\n * @dev Interface poseidon hash function 3 elements\r\n */\r\ncontract PoseidonUnit3 {\r\n    function poseidon(uint256[3] memory) public pure returns (uint256) {}\r\n}\r\n\r\n/**\r\n * @dev Interface poseidon hash function 4 elements\r\n */\r\ncontract PoseidonUnit4 {\r\n    function poseidon(uint256[4] memory) public pure returns (uint256) {}\r\n}\r\n\r\n/**\r\n * @dev Rollup helper functions\r\n */\r\ncontract LitexHelpers is Initializable {\r\n    PoseidonUnit2 _insPoseidonUnit2;\r\n    PoseidonUnit3 _insPoseidonUnit3;\r\n    PoseidonUnit4 _insPoseidonUnit4;\r\n\r\n    uint256 private constant _WORD_SIZE = 32;\r\n\r\n    // bytes32 public constant EIP712DOMAIN_HASH =\r\n    //      keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")\r\n    bytes32 public constant EIP712DOMAIN_HASH =\r\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\r\n    // bytes32 public constant NAME_HASH =\r\n    //      keccak256(\"Litex Network\")\r\n    bytes32 public constant NAME_HASH =\r\n        0xbe287413178bfeddef8d9753ad4be825ae998706a6dabff23978b59dccaea0ad;\r\n    // bytes32 public constant VERSION_HASH =\r\n    //      keccak256(\"1\")\r\n    bytes32 public constant VERSION_HASH =\r\n        0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\r\n    // bytes32 public constant AUTHORISE_TYPEHASH =\r\n    //      keccak256(\"Authorise(string Provider,string Authorisation,bytes32 BJJKey)\");\r\n    bytes32 public constant AUTHORISE_TYPEHASH =\r\n        0xafd642c6a37a2e6887dc4ad5142f84197828a904e53d3204ecb1100329231eaa;\r\n    // bytes32 public constant LITEX_NETWORK_HASH = keccak256(bytes(\"Litex Network\")),\r\n    bytes32 public constant LITEX_NETWORK_HASH =\r\n        0xbe287413178bfeddef8d9753ad4be825ae998706a6dabff23978b59dccaea0ad;\r\n    // bytes32 public constant ACCOUNT_CREATION_HASH = keccak256(bytes(\"Account creation\")),\r\n    bytes32 public constant ACCOUNT_CREATION_HASH =\r\n        0xff946cf82975b1a2b6e6d28c9a76a4b8d7a1fd0592b785cb92771933310f9ee7;\r\n\r\n    /**\r\n     * @dev Load poseidon smart contract\r\n     * @param _poseidon2Elements Poseidon contract address for 2 elements\r\n     * @param _poseidon3Elements Poseidon contract address for 3 elements\r\n     * @param _poseidon4Elements Poseidon contract address for 4 elements\r\n     */\r\n    function _initializeHelpers(\r\n        address _poseidon2Elements,\r\n        address _poseidon3Elements,\r\n        address _poseidon4Elements\r\n    ) internal initializer {\r\n        _insPoseidonUnit2 = PoseidonUnit2(_poseidon2Elements);\r\n        _insPoseidonUnit3 = PoseidonUnit3(_poseidon3Elements);\r\n        _insPoseidonUnit4 = PoseidonUnit4(_poseidon4Elements);\r\n    }\r\n\r\n    /**\r\n     * @dev Hash poseidon for 2 elements\r\n     * @param inputs Poseidon input array of 2 elements\r\n     * @return Poseidon hash\r\n     */\r\n    function _hash2Elements(uint256[2] memory inputs)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _insPoseidonUnit2.poseidon(inputs);\r\n    }\r\n\r\n    /**\r\n     * @dev Hash poseidon for 3 elements\r\n     * @param inputs Poseidon input array of 3 elements\r\n     * @return Poseidon hash\r\n     */\r\n    function _hash3Elements(uint256[3] memory inputs)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _insPoseidonUnit3.poseidon(inputs);\r\n    }\r\n\r\n    /**\r\n     * @dev Hash poseidon for 4 elements\r\n     * @param inputs Poseidon input array of 4 elements\r\n     * @return Poseidon hash\r\n     */\r\n    function _hash4Elements(uint256[4] memory inputs)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _insPoseidonUnit4.poseidon(inputs);\r\n    }\r\n\r\n    /**\r\n     * @dev Hash poseidon for sparse merkle tree nodes\r\n     * @param left Input element array\r\n     * @param right Input element array\r\n     * @return Poseidon hash\r\n     */\r\n    function _hashNode(uint256 left, uint256 right)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256[2] memory inputs;\r\n        inputs[0] = left;\r\n        inputs[1] = right;\r\n        return _hash2Elements(inputs);\r\n    }\r\n\r\n    /**\r\n     * @dev Hash poseidon for sparse merkle tree final nodes\r\n     * @param key Input element array\r\n     * @param value Input element array\r\n     * @return Poseidon hash1\r\n     */\r\n    function _hashFinalNode(uint256 key, uint256 value)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256[3] memory inputs;\r\n        inputs[0] = key;\r\n        inputs[1] = value;\r\n        inputs[2] = 1;\r\n        return _hash3Elements(inputs);\r\n    }\r\n\r\n    /**\r\n     * @dev Verify sparse merkle tree proof\r\n     * @param root Root to verify\r\n     * @param siblings Siblings necessary to compute the merkle proof\r\n     * @param key Key to verify\r\n     * @param value Value to verify\r\n     * @return True if verification is correct, false otherwise\r\n     */\r\n    function _smtVerifier(\r\n        uint256 root,\r\n        uint256[] memory siblings,\r\n        uint256 key,\r\n        uint256 value\r\n    ) internal view returns (bool) {\r\n        // Step 2: Calcuate root\r\n        uint256 nextHash = _hashFinalNode(key, value);\r\n        uint256 siblingTmp;\r\n        for (int256 i = int256(siblings.length) - 1; i >= 0; i--) {\r\n            siblingTmp = siblings[uint256(i)];\r\n            bool leftRight = (uint8(key >> i) & 0x01) == 1;\r\n            nextHash = leftRight\r\n                ? _hashNode(siblingTmp, nextHash)\r\n                : _hashNode(nextHash, siblingTmp);\r\n        }\r\n\r\n        // Step 3: Check root\r\n        return root == nextHash;\r\n    }\r\n\r\n    /**\r\n     * @dev Build entry for the exit tree leaf\r\n     * @param token Token identifier\r\n     * @param nonce nonce parameter, only use 40 bits instead of 48\r\n     * @param balance Balance of the account\r\n     * @param ay Public key babyjubjub represented as point: sign + (Ay)\r\n     * @param ethAddress Ethereum address\r\n     * @return uint256 array with the state variables\r\n     */\r\n    function _buildTreeState(\r\n        uint32 token,\r\n        uint48 nonce,\r\n        uint256 balance,\r\n        uint256 ay,\r\n        address ethAddress\r\n    ) internal pure returns (uint256[4] memory) {\r\n        uint256[4] memory stateArray;\r\n\r\n        stateArray[0] = token;\r\n        stateArray[0] |= nonce << 32;\r\n        stateArray[0] |= (ay >> 255) << (32 + 40);\r\n        // build element 2\r\n        stateArray[1] = balance;\r\n        // build element 4\r\n        stateArray[2] = (ay << 1) >> 1; // last bit set to 0\r\n        // build element 5\r\n        stateArray[3] = uint256(ethAddress);\r\n        return stateArray;\r\n    }\r\n\r\n    /**\r\n     * @dev Decode half floating precision.\r\n     * Max value encoded with this codification: 0x1f8def8800cca870c773f6eb4d980000000 (aprox 137 bits)\r\n     * @param float Float half precision encode number\r\n     * @return Decoded floating half precision\r\n     */\r\n    function _float2Fix(uint40 float) internal pure returns (uint256) {\r\n        uint256 m = float & 0x7FFFFFFFF;\r\n        uint256 e = float >> 35;\r\n\r\n        // never overflow, max \"e\" value is 32\r\n        uint256 exp = 10**e;\r\n\r\n        // never overflow, max \"fix\" value is 1023 * 10^32\r\n        uint256 fix = m * exp;\r\n\r\n        return fix;\r\n    }\r\n\r\n    /**\r\n     * @dev Retrieve the DOMAIN_SEPARATOR hash\r\n     * @return domainSeparator hash used for sign messages\r\n     */\r\n    function DOMAIN_SEPARATOR() public view returns (bytes32 domainSeparator) {\r\n        return\r\n            keccak256(\r\n                abi.encode(\r\n                    EIP712DOMAIN_HASH,\r\n                    NAME_HASH,\r\n                    VERSION_HASH,\r\n                    getChainId(),\r\n                    address(this)\r\n                )\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @return chainId The current chainId where the smarctoncract is executed\r\n     */\r\n    function getChainId() public pure returns (uint256 chainId) {\r\n        assembly {\r\n            chainId := chainid()\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Retrieve ethereum address from a (defaultMessage + babyjub) signature\r\n     * @param babyjub Public key babyjubjub represented as point: sign + (Ay)\r\n     * @param r Signature parameter\r\n     * @param s Signature parameter\r\n     * @param v Signature parameter\r\n     * @return Ethereum address recovered from the signature\r\n     */\r\n    function _checkSig(\r\n        bytes32 babyjub,\r\n        bytes32 r,\r\n        bytes32 s,\r\n        uint8 v\r\n    ) internal view returns (address) {\r\n        // from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/cryptography/ECDSA.sol#L46\r\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\r\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n        //\r\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n        // these malleable signatures as well.\r\n        require(\r\n            uint256(s) <=\r\n                0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\r\n            \"LitexHelpers::_checkSig: INVALID_S_VALUE\"\r\n        );\r\n\r\n        bytes32 encodeData =\r\n            keccak256(\r\n                abi.encode(\r\n                    AUTHORISE_TYPEHASH,\r\n                    LITEX_NETWORK_HASH,\r\n                    ACCOUNT_CREATION_HASH,\r\n                    babyjub\r\n                )\r\n            );\r\n\r\n        bytes32 messageDigest =\r\n            keccak256(\r\n                abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR(), encodeData)\r\n            );\r\n\r\n        address ethAddress = ecrecover(messageDigest, v, r, s);\r\n\r\n        require(\r\n            ethAddress != address(0),\r\n            \"LitexHelpers::_checkSig: INVALID_SIGNATURE\"\r\n        );\r\n\r\n        return ethAddress;\r\n    }\r\n\r\n    /**\r\n     * @dev return information from specific call data info\r\n     * @param posParam parameter number relative to 0 to extract the info\r\n     * @return ptr ptr to the call data position where the actual data starts\r\n     * @return len Length of the data\r\n     */\r\n    function _getCallData(uint256 posParam)\r\n        internal\r\n        pure\r\n        returns (uint256 ptr, uint256 len)\r\n    {\r\n        assembly {\r\n            let pos := add(4, mul(posParam, 32))\r\n            ptr := add(calldataload(pos), 4)\r\n            len := calldataload(ptr)\r\n            ptr := add(ptr, 32)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev This package fills at least len zeros in memory and a maximum of len+31\r\n     * @param ptr The position where it starts to fill zeros\r\n     * @param len The minimum quantity of zeros it's added\r\n     */\r\n    function _fillZeros(uint256 ptr, uint256 len) internal pure {\r\n        assembly {\r\n            let ptrTo := ptr\r\n            ptr := add(ptr, len)\r\n            for {\r\n\r\n            } lt(ptrTo, ptr) {\r\n                ptrTo := add(ptrTo, 32)\r\n            } {\r\n                mstore(ptrTo, 0)\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Copy 'len' bytes from memory address 'src', to address 'dest'.\r\n     * From https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\r\n     * @param _preBytes bytes storage\r\n     * @param _postBytes Bytes array memory\r\n     */\r\n    function _concatStorage(bytes storage _preBytes, bytes memory _postBytes)\r\n        internal\r\n    {\r\n        assembly {\r\n            // Read the first 32 bytes of _preBytes storage, which is the length\r\n            // of the array. (We don't need to use the offset into the slot\r\n            // because arrays use the entire slot.)\r\n            let fslot := sload(_preBytes_slot)\r\n            // Arrays of 31 bytes or less have an even value in their slot,\r\n            // while longer arrays have an odd value. The actual length is\r\n            // the slot divided by two for odd values, and the lowest order\r\n            // byte divided by two for even values.\r\n            // If the slot is even, bitwise and the slot with 255 and divide by\r\n            // two to get the length. If the slot is odd, bitwise and the slot\r\n            // with -1 and divide by two.\r\n            let slength := div(\r\n                and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)),\r\n                2\r\n            )\r\n            let mlength := mload(_postBytes)\r\n            let newlength := add(slength, mlength)\r\n            // slength can contain both the length and contents of the array\r\n            // if length < 32 bytes so let's prepare for that\r\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\r\n            switch add(lt(slength, 32), lt(newlength, 32))\r\n                case 2 {\r\n                    // Since the new array still fits in the slot, we just need to\r\n                    // update the contents of the slot.\r\n                    // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\r\n                    sstore(\r\n                        _preBytes_slot,\r\n                        // all the modifications to the slot are inside this\r\n                        // next block\r\n                        add(\r\n                            // we can just add to the slot contents because the\r\n                            // bytes we want to change are the LSBs\r\n                            fslot,\r\n                            add(\r\n                                mul(\r\n                                    div(\r\n                                        // load the bytes from memory\r\n                                        mload(add(_postBytes, 0x20)),\r\n                                        // zero all bytes to the right\r\n                                        exp(0x100, sub(32, mlength))\r\n                                    ),\r\n                                    // and now shift left the number of bytes to\r\n                                    // leave space for the length in the slot\r\n                                    exp(0x100, sub(32, newlength))\r\n                                ),\r\n                                // increase length by the double of the memory\r\n                                // bytes length\r\n                                mul(mlength, 2)\r\n                            )\r\n                        )\r\n                    )\r\n                }\r\n                case 1 {\r\n                    // The stored value fits in the slot, but the combined value\r\n                    // will exceed it.\r\n                    // get the keccak hash to get the contents of the array\r\n                    mstore(0x0, _preBytes_slot)\r\n                    let sc := add(keccak256(0x0, 0x20), div(slength, 32))\r\n\r\n                    // save new length\r\n                    sstore(_preBytes_slot, add(mul(newlength, 2), 1))\r\n\r\n                    // The contents of the _postBytes array start 32 bytes into\r\n                    // the structure. Our first read should obtain the `submod`\r\n                    // bytes that can fit into the unused space in the last word\r\n                    // of the stored array. To get this, we read 32 bytes starting\r\n                    // from `submod`, so the data we read overlaps with the array\r\n                    // contents by `submod` bytes. Masking the lowest-order\r\n                    // `submod` bytes allows us to add that value directly to the\r\n                    // stored value.\r\n\r\n                    let submod := sub(32, slength)\r\n                    let mc := add(_postBytes, submod)\r\n                    let end := add(_postBytes, mlength)\r\n                    let mask := sub(exp(0x100, submod), 1)\r\n\r\n                    sstore(\r\n                        sc,\r\n                        add(\r\n                            and(\r\n                                fslot,\r\n                                0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\r\n                            ),\r\n                            and(mload(mc), mask)\r\n                        )\r\n                    )\r\n\r\n                    for {\r\n                        mc := add(mc, 0x20)\r\n                        sc := add(sc, 1)\r\n                    } lt(mc, end) {\r\n                        sc := add(sc, 1)\r\n                        mc := add(mc, 0x20)\r\n                    } {\r\n                        sstore(sc, mload(mc))\r\n                    }\r\n\r\n                    mask := exp(0x100, sub(mc, end))\r\n\r\n                    sstore(sc, mul(div(mload(mc), mask), mask))\r\n                }\r\n                default {\r\n                    // get the keccak hash to get the contents of the array\r\n                    mstore(0x0, _preBytes_slot)\r\n                    // Start copying to the last used word of the stored array.\r\n                    let sc := add(keccak256(0x0, 0x20), div(slength, 32))\r\n\r\n                    // save new length\r\n                    sstore(_preBytes_slot, add(mul(newlength, 2), 1))\r\n\r\n                    // Copy over the first `submod` bytes of the new data as in\r\n                    // case 1 above.\r\n                    let slengthmod := mod(slength, 32)\r\n                    let mlengthmod := mod(mlength, 32)\r\n                    let submod := sub(32, slengthmod)\r\n                    let mc := add(_postBytes, submod)\r\n                    let end := add(_postBytes, mlength)\r\n                    let mask := sub(exp(0x100, submod), 1)\r\n\r\n                    sstore(sc, add(sload(sc), and(mload(mc), mask)))\r\n\r\n                    for {\r\n                        sc := add(sc, 1)\r\n                        mc := add(mc, 0x20)\r\n                    } lt(mc, end) {\r\n                        sc := add(sc, 1)\r\n                        mc := add(mc, 0x20)\r\n                    } {\r\n                        sstore(sc, mload(mc))\r\n                    }\r\n\r\n                    mask := exp(0x100, sub(mc, end))\r\n\r\n                    sstore(sc, mul(div(mload(mc), mask), mask))\r\n                }\r\n        }\r\n    }\r\n}\r\n\r\n\r\ninterface IWithdrawalDelayer {\r\n    /**\r\n     * @notice Getter of the current `_litexGovernanceAddress`\r\n     * @return The `_litexGovernanceAddress` value\r\n     */\r\n    function getLitexGovernanceAddress() external view returns (address);\r\n\r\n    /**\r\n     * @dev Allows the current governance to set the pendingGovernance address.\r\n     * @param newGovernance The address to transfer governance to.\r\n     */\r\n    function transferGovernance(address newGovernance) external;\r\n\r\n    /**\r\n     * @dev Allows the pendingGovernance address to finalize the transfer.\r\n     */\r\n    function claimGovernance() external;\r\n\r\n    /**\r\n     * @notice Getter of the current `_emergencyCouncil`\r\n     * @return The `_emergencyCouncil` value\r\n     */\r\n    function getEmergencyCouncil() external view returns (address);\r\n\r\n    /**\r\n     * @dev Allows the current governance to set the pendingGovernance address.\r\n     * @param newEmergencyCouncil The address to transfer governance to.\r\n     */\r\n    function transferEmergencyCouncil(address payable newEmergencyCouncil)\r\n        external;\r\n\r\n    /**\r\n     * @dev Allows the pendingGovernance address to finalize the transfer.\r\n     */\r\n    function claimEmergencyCouncil() external;\r\n\r\n    /**\r\n     * @notice Getter of the current `_emergencyMode` status to know if the emergency mode is enable or disable\r\n     * @return The `_emergencyMode` value\r\n     */\r\n    function isEmergencyMode() external view returns (bool);\r\n\r\n    /**\r\n     * @notice Getter to obtain the current withdrawal delay\r\n     * @return the current withdrawal delay time in seconds: `_withdrawalDelay`\r\n     */\r\n    function getWithdrawalDelay() external view returns (uint64);\r\n\r\n    /**\r\n     * @notice Getter to obtain when emergency mode started\r\n     * @return the emergency mode starting time in seconds: `_emergencyModeStartingTime`\r\n     */\r\n    function getEmergencyModeStartingTime() external view returns (uint64);\r\n\r\n    /**\r\n     * @notice This function enables the emergency mode. Only the keeper of the system can enable this mode. This cannot\r\n     * be deactivated in any case so it will be irreversible.\r\n     * @dev The activation time is saved in `_emergencyModeStartingTime` and this function can only be called\r\n     * once if it has not been previously activated.\r\n     * Events: `EmergencyModeEnabled` event.\r\n     */\r\n    function enableEmergencyMode() external;\r\n\r\n    /**\r\n     * @notice This function allows the LitexKeeperAddress to change the withdrawal delay time, this is the time that\r\n     * anyone needs to wait until a withdrawal of the funds is allowed. Since this time is calculated at the time of\r\n     * withdrawal, this change affects existing deposits. Can never exceed `MAX_WITHDRAWAL_DELAY`\r\n     * @dev It changes `_withdrawalDelay` if `_newWithdrawalDelay` it is less than or equal to MAX_WITHDRAWAL_DELAY\r\n     * @param _newWithdrawalDelay new delay time in seconds\r\n     * Events: `NewWithdrawalDelay` event.\r\n     */\r\n    function changeWithdrawalDelay(uint64 _newWithdrawalDelay) external;\r\n\r\n    /**\r\n     * Returns the balance and the timestamp for a specific owner and token\r\n     * @param _owner who can claim the deposit once the delay time has expired (if not in emergency mode)\r\n     * @param _token address of the token to withdrawal (0x0 in case of Ether)\r\n     * @return `amount` Total amount withdrawable (if not in emergency mode)\r\n     * @return `depositTimestamp` Moment at which funds were deposited\r\n     */\r\n    function depositInfo(address payable _owner, address _token)\r\n        external\r\n        view\r\n        returns (uint192, uint64);\r\n\r\n    /**\r\n     * Function to make a deposit in the WithdrawalDelayer smartcontract, only the Litex rollup smartcontract can do it\r\n     * @dev In case of an Ether deposit, the address `0x0` will be used and the corresponding amount must be sent in the\r\n     * `msg.value`. In case of an ERC20 this smartcontract must have the approval to expend the token to\r\n     * deposit to be able to make a transferFrom to itself.\r\n     * @param _owner is who can claim the deposit once the withdrawal delay time has been exceeded\r\n     * @param _token address of the token deposited (`0x0` in case of Ether)\r\n     * @param _amount deposit amount\r\n     * Events: `Deposit`\r\n     */\r\n    function deposit(\r\n        address _owner,\r\n        address _token,\r\n        uint192 _amount\r\n    ) external payable;\r\n\r\n    /**\r\n     * This function allows the owner to withdawal the funds. Emergency mode cannot be enabled and it must have exceeded\r\n     * the withdrawal delay time\r\n     * @dev `NonReentrant` modifier is used as a protection despite the state is being previously updated\r\n     * @param _owner can claim the deposit once the delay time has expired\r\n     * @param _token address of the token to withdrawal (0x0 in case of Ether)\r\n     * Events: `Withdraw`\r\n     */\r\n    function withdrawal(address payable _owner, address _token) external;\r\n\r\n    /**\r\n     * Allows the Litex Governance to withdawal the funds in the event that emergency mode was enable.\r\n     * Note: An Aragon Court will have the right to veto over the call to this method\r\n     * @dev `NonReentrant` modifier is used as a protection despite the state is being previously updated and this is\r\n     * a security mechanism\r\n     * @param _to where the funds will be sent\r\n     * @param _token address of the token withdraw (0x0 in case of Ether)\r\n     * @param _amount the amount to send\r\n     * Events: `EscapeHatchWithdrawal`\r\n     */\r\n    function escapeHatchWithdrawal(\r\n        address _to,\r\n        address _token,\r\n        uint256 _amount\r\n    ) external;\r\n}\r\n\r\ncontract InstantWithdrawManager is LitexHelpers {\r\n    using SafeMath for uint256;\r\n\r\n\r\n    // Number of buckets\r\n    uint256 private constant _MAX_BUCKETS = 5;\r\n\r\n    // Bucket array\r\n    uint256 public nBuckets;\r\n    mapping (int256 => uint256) public buckets;\r\n\r\n    // Governance address\r\n    address public litexGovernanceAddress;\r\n\r\n    // Withdraw delay in seconds\r\n    uint64 public withdrawalDelay;\r\n\r\n    // ERC20 decimals signature\r\n    //  bytes4(keccak256(bytes(\"decimals()\")))\r\n    bytes4 private constant _ERC20_DECIMALS = 0x313ce567;\r\n\r\n    uint256 private constant _MAX_WITHDRAWAL_DELAY = 2 weeks;\r\n\r\n    // Withdraw delayer interface\r\n    IWithdrawalDelayer public withdrawDelayerContract;\r\n\r\n    // Mapping tokenAddress --> (USD value)/token , default 0, means that token does not worth\r\n    // 2^64 = 1.8446744e+19\r\n    // fixed point codification is used, 9 digits for integer part, 10 digits for decimal\r\n    // In other words, the USD value of a token base unit is multiplied by 1e10\r\n    // MaxUSD value for a base unit token: 1844674407,3709551616$\r\n    // MinUSD value for a base unit token: 1e-10$\r\n    mapping(address => uint64) public tokenExchange;\r\n\r\n    uint256 private constant _EXCHANGE_MULTIPLIER = 1e10;\r\n\r\n    event UpdateBucketWithdraw(\r\n        uint8 indexed numBucket,\r\n        uint256 indexed blockStamp,\r\n        uint256 withdrawals\r\n    );\r\n\r\n    event UpdateWithdrawalDelay(uint64 newWithdrawalDelay);\r\n    event UpdateBucketsParameters(uint256[] arrayBuckets);\r\n    event UpdateTokenExchange(address[] addressArray, uint64[] valueArray);\r\n    event SafeMode();\r\n\r\n    function _initializeWithdraw(\r\n        address _litexGovernanceAddress,\r\n        uint64 _withdrawalDelay,\r\n        address _withdrawDelayerContract\r\n    ) internal initializer {\r\n        litexGovernanceAddress = _litexGovernanceAddress;\r\n        withdrawalDelay = _withdrawalDelay;\r\n        withdrawDelayerContract = IWithdrawalDelayer(_withdrawDelayerContract);\r\n    }\r\n\r\n    modifier onlyGovernance {\r\n        require(\r\n            msg.sender == litexGovernanceAddress,\r\n            \"InstantWithdrawManager::onlyGovernance: ONLY_GOVERNANCE_ADDRESS\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Attempt to use instant withdraw\r\n     * @param tokenAddress Token address\r\n     * @param amount Amount to withdraw\r\n     */\r\n    function _processInstantWithdrawal(address tokenAddress, uint192 amount)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        // find amount in USD and then the corresponding bucketIdx\r\n        uint256 amountUSD = _token2USD(tokenAddress, amount);\r\n\r\n        if (amountUSD == 0) {\r\n            return true;\r\n        }\r\n\r\n        // find the appropiate bucketId\r\n        int256 bucketIdx = _findBucketIdx(amountUSD);\r\n        if (bucketIdx == -1) return true;\r\n\r\n        (uint256 ceilUSD, uint256 blockStamp, uint256 withdrawals, uint256 rateBlocks, uint256 rateWithdrawals, uint256 maxWithdrawals) = unpackBucket(buckets[bucketIdx]);\r\n\r\n        // update the bucket and check again if are withdrawals available\r\n        uint256 differenceBlocks = block.number.sub(blockStamp);\r\n        uint256 periods = differenceBlocks.div(rateBlocks);\r\n\r\n        // add the withdrawals available\r\n        withdrawals = withdrawals.add(periods.mul(rateWithdrawals));\r\n        if (withdrawals >= maxWithdrawals) {\r\n            withdrawals = maxWithdrawals;\r\n            blockStamp = block.number;\r\n        } else {\r\n            blockStamp = blockStamp.add(periods.mul(rateBlocks));\r\n        }\r\n\r\n        if (withdrawals == 0) return false;\r\n\r\n        withdrawals = withdrawals.sub(1);\r\n\r\n        // update the bucket with the new values\r\n        buckets[bucketIdx] = packBucket(ceilUSD, blockStamp, withdrawals, rateBlocks, rateWithdrawals, maxWithdrawals);\r\n\r\n        emit UpdateBucketWithdraw(uint8(bucketIdx), blockStamp, withdrawals);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Update bucket parameters\r\n     * @param newBuckets Array of buckets to replace the current ones, this array includes the\r\n     * following parameters: [ceilUSD, withdrawals, rateBlocks, rateWithdrawals, maxWithdrawals]\r\n     */\r\n    function updateBucketsParameters(\r\n        uint256[] memory newBuckets\r\n    ) external onlyGovernance {\r\n        uint256 n = newBuckets.length;\r\n        require(\r\n            n <= _MAX_BUCKETS,\r\n            \"InstantWithdrawManager::updateBucketsParameters: MAX_NUM_BUCKETS\"\r\n        );\r\n\r\n        nBuckets = n;\r\n        for (uint256 i = 0; i < n; i++) {\r\n            (uint256 ceilUSD, , uint256 withdrawals, uint256 rateBlocks, uint256 rateWithdrawals, uint256 maxWithdrawals) = unpackBucket(newBuckets[i]);\r\n            require(\r\n                withdrawals <= maxWithdrawals,\r\n                \"InstantWithdrawManager::updateBucketsParameters: WITHDRAWALS_MUST_BE_LESS_THAN_MAXWITHDRAWALS\"\r\n            );\r\n            require(\r\n                rateBlocks > 0,\r\n                \"InstantWithdrawManager::updateBucketsParameters: RATE_BLOCKS_MUST_BE_MORE_THAN_0\"\r\n            );\r\n            buckets[int256(i)] = packBucket(\r\n                ceilUSD,\r\n                block.number,\r\n                withdrawals,\r\n                rateBlocks,\r\n                rateWithdrawals,\r\n                maxWithdrawals\r\n            );\r\n        }\r\n        emit UpdateBucketsParameters(newBuckets);\r\n    }\r\n\r\n    /**\r\n     * @dev Update token USD value\r\n     * @param addressArray Array of the token address\r\n     * @param valueArray Array of USD values\r\n     */\r\n    function updateTokenExchange(\r\n        address[] memory addressArray,\r\n        uint64[] memory valueArray\r\n    ) external onlyGovernance {\r\n        require(\r\n            addressArray.length == valueArray.length,\r\n            \"InstantWithdrawManager::updateTokenExchange: INVALID_ARRAY_LENGTH\"\r\n        );\r\n        for (uint256 i = 0; i < addressArray.length; i++) {\r\n            tokenExchange[addressArray[i]] = valueArray[i];\r\n        }\r\n        emit UpdateTokenExchange(addressArray, valueArray);\r\n    }\r\n\r\n    /**\r\n     * @dev Update WithdrawalDelay\r\n     * @param newWithdrawalDelay New WithdrawalDelay\r\n     * Events: `UpdateWithdrawalDelay`\r\n     */\r\n    function updateWithdrawalDelay(uint64 newWithdrawalDelay)\r\n        external\r\n        onlyGovernance\r\n    {\r\n        require(\r\n            newWithdrawalDelay <= _MAX_WITHDRAWAL_DELAY,\r\n            \"InstantWithdrawManager::updateWithdrawalDelay: EXCEED_MAX_WITHDRAWAL_DELAY\"\r\n        );\r\n        withdrawalDelay = newWithdrawalDelay;\r\n        emit UpdateWithdrawalDelay(newWithdrawalDelay);\r\n    }\r\n\r\n    /**\r\n     * @dev Put the smartcontract in safe mode, only delayed withdrawals allowed,\r\n     * also update the 'withdrawalDelay' of the 'withdrawDelayer' contract\r\n     */\r\n    function safeMode() external onlyGovernance {\r\n        // only 1 bucket that does not allow any instant withdraw\r\n        nBuckets = 1;\r\n        buckets[0] = packBucket(\r\n            0xFFFFFFFF_FFFFFFFF_FFFFFFFF,\r\n            0,\r\n            0,\r\n            1,\r\n            0,\r\n            0\r\n        );\r\n        withdrawDelayerContract.changeWithdrawalDelay(withdrawalDelay);\r\n        emit SafeMode();\r\n    }\r\n\r\n    /**\r\n     * @dev Return true if a instant withdraw could be done with that 'tokenAddress' and 'amount'\r\n     * @param tokenAddress Token address\r\n     * @param amount Amount to withdraw\r\n     * @return true if the instant withdrawal is allowed\r\n     */\r\n    function instantWithdrawalViewer(address tokenAddress, uint192 amount)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        // find amount in USD and then the corresponding bucketIdx\r\n        uint256 amountUSD = _token2USD(tokenAddress, amount);\r\n        if (amountUSD == 0) return true;\r\n\r\n        int256 bucketIdx = _findBucketIdx(amountUSD);\r\n        if (bucketIdx == -1) return true;\r\n\r\n\r\n        (, uint256 blockStamp, uint256 withdrawals, uint256 rateBlocks, uint256 rateWithdrawals, uint256 maxWithdrawals) = unpackBucket(buckets[bucketIdx]);\r\n\r\n        uint256 differenceBlocks = block.number.sub(blockStamp);\r\n        uint256 periods = differenceBlocks.div(rateBlocks);\r\n\r\n        withdrawals = withdrawals.add(periods.mul(rateWithdrawals));\r\n        if (withdrawals>maxWithdrawals) withdrawals = maxWithdrawals;\r\n\r\n        if (withdrawals == 0) return false;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Converts tokens to USD\r\n     * @param tokenAddress Token address\r\n     * @param amount Token amount\r\n     * @return Total USD amount\r\n     */\r\n    function _token2USD(address tokenAddress, uint192 amount)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (tokenExchange[tokenAddress] == 0) return 0;\r\n\r\n        // this multiplication never overflows 192bits * 64 bits\r\n        uint256 baseUnitTokenUSD = (uint256(amount) *\r\n            uint256(tokenExchange[tokenAddress])) / _EXCHANGE_MULTIPLIER;\r\n\r\n        uint8 decimals;\r\n        // in case of ether, set 18 decimals\r\n        if (tokenAddress == address(0)) {\r\n            decimals = 18;\r\n        } else {\r\n            // if decimals() is not implemented 0 decimals are assumed\r\n            (bool success, bytes memory data) = tokenAddress.staticcall(\r\n                abi.encodeWithSelector(_ERC20_DECIMALS)\r\n            );\r\n            if (success) {\r\n                decimals = abi.decode(data, (uint8));\r\n            }\r\n        }\r\n        require(\r\n            decimals < 77,\r\n            \"InstantWithdrawManager::_token2USD: TOKEN_DECIMALS_OVERFLOW\"\r\n        );\r\n        return baseUnitTokenUSD / (10**uint256(decimals));\r\n    }\r\n\r\n    /**\r\n     * @dev Find the corresponding bucket for the input amount\r\n     * @param amountUSD USD amount\r\n     * @return Bucket index, -1 in case there is no match\r\n     */\r\n    function _findBucketIdx(uint256 amountUSD) internal view returns (int256) {\r\n        for (int256 i = 0; i < int256(nBuckets); i++) {\r\n            uint256 ceilUSD = buckets[i] & 0xFFFFFFFF_FFFFFFFF_FFFFFFFF;\r\n            if ((amountUSD <= ceilUSD) ||\r\n                (ceilUSD == 0xFFFFFFFF_FFFFFFFF_FFFFFFFF))\r\n            {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n     /**\r\n     * @dev Unpack a packed uint256 into the bucket parameters\r\n     * @param bucket Token address\r\n     * @return ceilUSD max USD value that bucket holds\r\n     * @return blockStamp block number of the last bucket update\r\n     * @return withdrawals available withdrawals of the bucket\r\n     * @return rateBlocks every `rateBlocks` blocks add `rateWithdrawals` withdrawal\r\n     * @return rateWithdrawals add `rateWithdrawals` every `rateBlocks`\r\n     * @return maxWithdrawals max withdrawals the bucket can hold\r\n     */\r\n    function unpackBucket(uint256 bucket) public pure returns(\r\n        uint256 ceilUSD,\r\n        uint256 blockStamp,\r\n        uint256 withdrawals,\r\n        uint256 rateBlocks,\r\n        uint256 rateWithdrawals,\r\n        uint256 maxWithdrawals\r\n    ) {\r\n        ceilUSD = bucket & 0xFFFFFFFF_FFFFFFFF_FFFFFFFF;\r\n        blockStamp = (bucket >> 96) & 0xFFFFFFFF;\r\n        withdrawals = (bucket >> 128) & 0xFFFFFFFF;\r\n        rateBlocks = (bucket >> 160) & 0xFFFFFFFF;\r\n        rateWithdrawals = (bucket >> 192) & 0xFFFFFFFF;\r\n        maxWithdrawals = (bucket >> 224) & 0xFFFFFFFF;\r\n    }\r\n\r\n     /**\r\n     * @dev Pack all the bucket parameters into a uint256\r\n     * @param ceilUSD max USD value that bucket holds\r\n     * @param blockStamp block number of the last bucket update\r\n     * @param withdrawals available withdrawals of the bucket\r\n     * @param rateBlocks every `rateBlocks` blocks add `rateWithdrawals` withdrawal\r\n     * @param rateWithdrawals add `rateWithdrawals` every `rateBlocks`\r\n     * @param maxWithdrawals max withdrawals the bucket can hold\r\n     * @return ret all bucket varaibles packed [ceilUSD, blockStamp, withdrawals, rateBlocks, rateWithdrawals, maxWithdrawals]\r\n     */\r\n    function packBucket(\r\n        uint256 ceilUSD,\r\n        uint256 blockStamp,\r\n        uint256 withdrawals,\r\n        uint256 rateBlocks,\r\n        uint256 rateWithdrawals,\r\n        uint256 maxWithdrawals\r\n    ) public pure returns(uint256 ret) {\r\n        ret = ceilUSD |\r\n              (blockStamp << 96) |\r\n              (withdrawals << 128) |\r\n              (rateBlocks << 160) |\r\n              (rateWithdrawals << 192) |\r\n              (maxWithdrawals << 224);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\ncontract LitexRollup is InstantWithdrawManager {\r\n    struct VerifierRollup {\r\n        VerifierRollupInterface verifierInterface;\r\n        uint256 maxTx; // maximum rollup transactions in a batch: L2-tx + L1-tx transactions\r\n        uint256 nLevels; // number of levels of the circuit\r\n    }\r\n\r\n    // ERC20 signatures:\r\n\r\n    // bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\r\n    bytes4 constant _TRANSFER_SIGNATURE = 0xa9059cbb;\r\n\r\n    // bytes4(keccak256(bytes(\"transferFrom(address,address,uint256)\")));\r\n    bytes4 constant _TRANSFER_FROM_SIGNATURE = 0x23b872dd;\r\n\r\n    // bytes4(keccak256(bytes(\"approve(address,uint256)\")));\r\n    bytes4 constant _APPROVE_SIGNATURE = 0x095ea7b3;\r\n\r\n    // ERC20 extensions:\r\n\r\n    // bytes4(keccak256(bytes(\"permit(address,address,uint256,uint256,uint8,bytes32,bytes32)\")));\r\n    bytes4 constant _PERMIT_SIGNATURE = 0xd505accf;\r\n\r\n    // First 256 indexes reserved, first user index will be the 256\r\n    uint48 constant _RESERVED_IDX = 255;\r\n\r\n    // IDX 1 is reserved for exits\r\n    uint48 constant _EXIT_IDX = 1;\r\n\r\n    // Max load amount allowed (loadAmount: L1 --> L2)\r\n    uint256 constant _LIMIT_LOAD_AMOUNT = (1 << 128);\r\n\r\n    // Max amount allowed (amount L2 --> L2)\r\n    uint256 constant _LIMIT_L2TRANSFER_AMOUNT = (1 << 192);\r\n\r\n    // Max number of tokens allowed to be registered inside the rollup\r\n    uint256 constant _LIMIT_TOKENS = (1 << 32);\r\n\r\n    // [65 bytes] compressedSignature + [32 bytes] fromBjj-compressed + [4 bytes] tokenId\r\n    uint256 constant _L1_COORDINATOR_TOTALBYTES = 101;\r\n\r\n    // [20 bytes] fromEthAddr + [32 bytes] fromBjj-compressed + [6 bytes] fromIdx +\r\n    // [5 bytes] loadAmountFloat40 + [5 bytes] amountFloat40 + [4 bytes] tokenId + [6 bytes] toIdx\r\n    uint256 constant _L1_USER_TOTALBYTES = 78;\r\n\r\n    // User TXs are the TX made by the user with a L1 TX\r\n    // Coordinator TXs are the L2 account creation made by the coordinator whose signature\r\n    // needs to be verified in L1.\r\n    // The maximum number of L1-user TXs and L1-coordinartor-TX is limited by the _MAX_L1_TX\r\n    // And the maximum User TX is _MAX_L1_USER_TX\r\n\r\n    // Maximum L1-user transactions allowed to be queued in a batch\r\n    uint256 constant _MAX_L1_USER_TX = 128;\r\n\r\n    // Maximum L1 transactions allowed to be queued in a batch\r\n    uint256 constant _MAX_L1_TX = 256;\r\n\r\n    // Modulus zkSNARK\r\n    uint256 constant _RFIELD = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\r\n\r\n    // [6 bytes] lastIdx + [6 bytes] newLastIdx  + [32 bytes] stateRoot  + [32 bytes] newStRoot  + [32 bytes] newExitRoot +\r\n    // [_MAX_L1_TX * _L1_USER_TOTALBYTES bytes] l1TxsData + totall1L2TxsDataLength + feeIdxCoordinatorLength + [2 bytes] chainID + [4 bytes] batchNum =\r\n    // 18546 bytes + totall1L2TxsDataLength + feeIdxCoordinatorLength\r\n\r\n    uint256 constant _INPUT_SHA_CONSTANT_BYTES = 20082;\r\n\r\n    uint8 public constant ABSOLUTE_MAX_L1L2BATCHTIMEOUT = 240;\r\n\r\n    // This ethereum address is used internally for rollup accounts that don't have ethereum address, only Babyjubjub\r\n    // This non-ethereum accounts can be created by the coordinator and allow users to have a rollup\r\n    // account without needing an ethereum address\r\n    address constant _ETH_ADDRESS_INTERNAL_ONLY = address(\r\n        0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF\r\n    );\r\n\r\n    // Verifiers array\r\n    VerifierRollup[] public rollupVerifiers;\r\n\r\n    // Withdraw verifier interface\r\n    VerifierWithdrawInterface public withdrawVerifier;\r\n\r\n    // Last account index created inside the rollup\r\n    uint48 public lastIdx;\r\n\r\n    // Last batch forged\r\n    uint32 public lastForgedBatch;\r\n\r\n    // Each batch forged will have a correlated 'state root'\r\n    mapping(uint32 => uint256) public stateRootMap;\r\n\r\n    // Each batch forged will have a correlated 'exit tree' represented by the exit root\r\n    mapping(uint32 => uint256) public exitRootsMap;\r\n\r\n    // Each batch forged will have a correlated 'l1L2TxDataHash'\r\n    mapping(uint32 => bytes32) public l1L2TxsDataHashMap;\r\n\r\n    // Mapping of exit nullifiers, only allowing each withdrawal to be made once\r\n    // rootId => (Idx => true/false)\r\n    mapping(uint32 => mapping(uint48 => bool)) public exitNullifierMap;\r\n\r\n    // List of ERC20 tokens that can be used in rollup\r\n    // ID = 0 will be reserved for ether\r\n    address[] public tokenList;\r\n\r\n    // Mapping addres of the token, with the tokenID associated\r\n    mapping(address => uint256) public tokenMap;\r\n\r\n    // Fee for adding a new token to the rollup in LXT tokens\r\n    uint256 public feeAddToken;\r\n\r\n    // Contract interface of the litex auction\r\n    ILitexAuctionProtocol public litexAuctionContract;\r\n\r\n    // Map of queues of L1-user-tx transactions, the transactions are stored in bytes32 sequentially\r\n    // The coordinator is forced to forge the next queue in the next L1-L2-batch\r\n    mapping(uint32 => bytes) public mapL1TxQueue;\r\n\r\n    // Ethereum block where the last L1-L2-batch was forged\r\n    uint64 public lastL1L2Batch;\r\n\r\n    // Queue index that will be forged in the next L1-L2-batch\r\n    uint32 public nextL1ToForgeQueue;\r\n\r\n    // Queue index wich will be filled with the following L1-User-Tx\r\n    uint32 public nextL1FillingQueue;\r\n\r\n    // Max ethereum blocks after the last L1-L2-batch, when exceeds the timeout only L1-L2-batch are allowed\r\n    uint8 public forgeL1L2BatchTimeout;\r\n\r\n    // LXT token address\r\n    address public tokenLXT;\r\n\r\n    // Event emitted when a L1-user transaction is called and added to the nextL1FillingQueue queue\r\n    event L1UserTxEvent(\r\n        uint32 indexed queueIndex,\r\n        uint8 indexed position, // Position inside the queue where the TX resides\r\n        bytes l1UserTx\r\n    );\r\n\r\n    // Event emitted when a new token is added\r\n    event AddToken(address indexed tokenAddress, uint32 tokenID);\r\n\r\n    // Event emitted every time a batch is forged\r\n    event ForgeBatch(uint32 indexed batchNum, uint16 l1UserTxsLen);\r\n\r\n    // Event emitted when the governance update the `forgeL1L2BatchTimeout`\r\n    event UpdateForgeL1L2BatchTimeout(uint8 newForgeL1L2BatchTimeout);\r\n\r\n    // Event emitted when the governance update the `feeAddToken`\r\n    event UpdateFeeAddToken(uint256 newFeeAddToken);\r\n\r\n    // Event emitted when a withdrawal is done\r\n    event WithdrawEvent(\r\n        uint48 indexed idx,\r\n        uint32 indexed numExitRoot,\r\n        bool indexed instantWithdraw\r\n    );\r\n\r\n    // Event emitted when the contract is initialized\r\n    event InitializeLitexEvent(\r\n        uint8 forgeL1L2BatchTimeout,\r\n        uint256 feeAddToken,\r\n        uint64 withdrawalDelay\r\n    );\r\n\r\n    // Event emitted when the contract is updated to the new version\r\n    event litexV2();\r\n\r\n    function updateVerifiers() external {\r\n        require(\r\n            msg.sender == address(0xb6D3f1056c015962fA66A4020E50522B58292D1E),\r\n            \"Litex::updateVerifiers ONLY_DEPLOYER\"\r\n        );\r\n        require(\r\n            rollupVerifiers[0].maxTx == 344, // Old verifier 344 tx\r\n            \"Litex::updateVerifiers VERIFIERS_ALREADY_UPDATED\"\r\n        );\r\n        rollupVerifiers[0] = VerifierRollup({\r\n            verifierInterface: VerifierRollupInterface(\r\n                address(0x3DAa0B2a994b1BC60dB9e312aD0a8d87a1Bb16D2) // New verifier 400 tx\r\n            ),\r\n            maxTx: 400,\r\n            nLevels: 32\r\n        });\r\n\r\n        rollupVerifiers[1] = VerifierRollup({\r\n            verifierInterface: VerifierRollupInterface(\r\n                address(0x1DC4b451DFcD0e848881eDE8c7A99978F00b1342) // New verifier 2048 tx\r\n            ),\r\n            maxTx: 2048,\r\n            nLevels: 32\r\n        });\r\n\r\n        withdrawVerifier = VerifierWithdrawInterface(\r\n            0x4464A1E499cf5443541da6728871af1D5C4920ca\r\n        );\r\n        emit litexV2();\r\n    }\r\n\r\n    /**\r\n     * @dev Initializer function (equivalent to the constructor). Since we use\r\n     * upgradeable smartcontracts the state vars have to be initialized here.\r\n     */\r\n    function initializeLitex(\r\n        address[] memory _verifiers,\r\n        uint256[] memory _verifiersParams,\r\n        address _withdrawVerifier,\r\n        address _litexAuctionContract,\r\n        address _tokenLXT,\r\n        uint8 _forgeL1L2BatchTimeout,\r\n        uint256 _feeAddToken,\r\n        address _poseidon2Elements,\r\n        address _poseidon3Elements,\r\n        address _poseidon4Elements,\r\n        address _litexGovernanceAddress,\r\n        uint64 _withdrawalDelay,\r\n        address _withdrawDelayerContract\r\n    ) external initializer {\r\n        require(\r\n            _litexAuctionContract != address(0) &&\r\n                _withdrawDelayerContract != address(0),\r\n            \"Litex::initializeLitex ADDRESS_0_NOT_VALID\"\r\n        );\r\n\r\n        // set state variables\r\n        _initializeVerifiers(_verifiers, _verifiersParams);\r\n        withdrawVerifier = VerifierWithdrawInterface(_withdrawVerifier);\r\n        litexAuctionContract = ILitexAuctionProtocol(_litexAuctionContract);\r\n        tokenLXT = _tokenLXT;\r\n        forgeL1L2BatchTimeout = _forgeL1L2BatchTimeout;\r\n        feeAddToken = _feeAddToken;\r\n\r\n        // set default state variables\r\n        lastIdx = _RESERVED_IDX;\r\n        // lastL1L2Batch = 0 --> first batch forced to be L1Batch\r\n        // nextL1ToForgeQueue = 0 --> First queue will be forged\r\n        nextL1FillingQueue = 1;\r\n        // stateRootMap[0] = 0 --> genesis batch will have root = 0\r\n        tokenList.push(address(0)); // Token 0 is ETH\r\n\r\n        // initialize libs\r\n        _initializeHelpers(\r\n            _poseidon2Elements,\r\n            _poseidon3Elements,\r\n            _poseidon4Elements\r\n        );\r\n        _initializeWithdraw(\r\n            _litexGovernanceAddress,\r\n            _withdrawalDelay,\r\n            _withdrawDelayerContract\r\n        );\r\n        emit InitializeLitexEvent(\r\n            _forgeL1L2BatchTimeout,\r\n            _feeAddToken,\r\n            _withdrawalDelay\r\n        );\r\n    }\r\n\r\n    //////////////\r\n    // Coordinator operations\r\n    /////////////\r\n\r\n    /**\r\n     * @dev Forge a new batch providing the L2 Transactions, L1Corrdinator transactions and the proof.\r\n     * If the proof is succesfully verified, update the current state, adding a new state and exit root.\r\n     * In order to optimize the gas consumption the parameters `encodedL1CoordinatorTx`, `l1L2TxsData` and `feeIdxCoordinator`\r\n     * are read directly from the calldata using assembly with the instruction `calldatacopy`\r\n     * @param newLastIdx New total rollup accounts\r\n     * @param newStRoot New state root\r\n     * @param newExitRoot New exit root\r\n     * @param encodedL1CoordinatorTx Encoded L1-coordinator transactions\r\n     * @param l1L2TxsData Encoded l2 data\r\n     * @param feeIdxCoordinator Encoded idx accounts of the coordinator where the fees will be payed\r\n     * @param verifierIdx Verifier index\r\n     * @param l1Batch Indicates if this batch will be L2 or L1-L2\r\n     * @param proofA zk-snark input\r\n     * @param proofB zk-snark input\r\n     * @param proofC zk-snark input\r\n     * Events: `ForgeBatch`\r\n     */\r\n    function forgeBatch(\r\n        uint48 newLastIdx,\r\n        uint256 newStRoot,\r\n        uint256 newExitRoot,\r\n        bytes calldata encodedL1CoordinatorTx,\r\n        bytes calldata l1L2TxsData,\r\n        bytes calldata feeIdxCoordinator,\r\n        uint8 verifierIdx,\r\n        bool l1Batch,\r\n        uint256[2] calldata proofA,\r\n        uint256[2][2] calldata proofB,\r\n        uint256[2] calldata proofC\r\n    ) external virtual {\r\n        // Assure data availability from regular ethereum nodes\r\n        // We include this line because it's easier to track the transaction data, as it will never be in an internal TX.\r\n        // In general this makes no sense, as callling this function from another smart contract will have to pay the calldata twice.\r\n        // But forcing, it avoids having to check.\r\n        require(\r\n            msg.sender == tx.origin,\r\n            \"Litex::forgeBatch: INTENAL_TX_NOT_ALLOWED\"\r\n        );\r\n\r\n        // ask the auction if this coordinator is allow to forge\r\n        require(\r\n            litexAuctionContract.canForge(msg.sender, block.number) == true,\r\n            \"Litex::forgeBatch: AUCTION_DENIED\"\r\n        );\r\n\r\n        if (!l1Batch) {\r\n            require(\r\n                block.number < (lastL1L2Batch + forgeL1L2BatchTimeout), // No overflow since forgeL1L2BatchTimeout is an uint8\r\n                \"Litex::forgeBatch: L1L2BATCH_REQUIRED\"\r\n            );\r\n        }\r\n\r\n        // calculate input\r\n        uint256 input = _constructCircuitInput(\r\n            newLastIdx,\r\n            newStRoot,\r\n            newExitRoot,\r\n            l1Batch,\r\n            verifierIdx\r\n        );\r\n\r\n        // verify proof\r\n        require(\r\n            rollupVerifiers[verifierIdx].verifierInterface.verifyProof(\r\n                proofA,\r\n                proofB,\r\n                proofC,\r\n                [input]\r\n            ),\r\n            \"Litex::forgeBatch: INVALID_PROOF\"\r\n        );\r\n\r\n        // update state\r\n        lastForgedBatch++;\r\n        lastIdx = newLastIdx;\r\n        stateRootMap[lastForgedBatch] = newStRoot;\r\n        exitRootsMap[lastForgedBatch] = newExitRoot;\r\n        l1L2TxsDataHashMap[lastForgedBatch] = sha256(l1L2TxsData);\r\n\r\n        uint16 l1UserTxsLen;\r\n        if (l1Batch) {\r\n            // restart the timeout\r\n            lastL1L2Batch = uint64(block.number);\r\n            // clear current queue\r\n            l1UserTxsLen = _clearQueue();\r\n        }\r\n\r\n        // auction must be aware that a batch is being forged\r\n        litexAuctionContract.forge(msg.sender);\r\n\r\n        emit ForgeBatch(lastForgedBatch, l1UserTxsLen);\r\n    }\r\n\r\n    //////////////\r\n    // User L1 rollup tx\r\n    /////////////\r\n\r\n    // This are all the possible L1-User transactions:\r\n    // | fromIdx | toIdx | loadAmountF | amountF | tokenID(SC) | babyPubKey |           l1-user-TX            |\r\n    // |:-------:|:-----:|:-----------:|:-------:|:-----------:|:----------:|:-------------------------------:|\r\n    // |    0    |   0   |      0      |  0(SC)  |      X      |  !=0(SC)   |          createAccount          |\r\n    // |    0    |   0   |     !=0     |  0(SC)  |      X      |  !=0(SC)   |      createAccountDeposit       |\r\n    // |    0    | 255+  |      X      |    X    |      X      |  !=0(SC)   | createAccountDepositAndTransfer |\r\n    // |  255+   |   0   |      X      |  0(SC)  |      X      |   0(SC)    |             Deposit             |\r\n    // |  255+   |   1   |      0      |    X    |      X      |   0(SC)    |              Exit               |\r\n    // |  255+   | 255+  |      0      |    X    |      X      |   0(SC)    |            Transfer             |\r\n    // |  255+   | 255+  |     !=0     |    X    |      X      |   0(SC)    |       DepositAndTransfer        |\r\n    // As can be seen in the table the type of transaction is determined basically by the \"fromIdx\" and \"toIdx\"\r\n    // The 'X' means that can be any valid value and does not change the l1-user-tx type\r\n    // Other parameters must be consistent, for example, if toIdx is 0, amountF must be 0, because there's no L2 transfer\r\n\r\n    /**\r\n     * @dev Create a new rollup l1 user transaction\r\n     * @param babyPubKey Public key babyjubjub represented as point: sign + (Ay)\r\n     * @param fromIdx Index leaf of sender account or 0 if create new account\r\n     * @param loadAmountF Amount from L1 to L2 to sender account or new account\r\n     * @param amountF Amount transfered between L2 accounts\r\n     * @param tokenID Token identifier\r\n     * @param toIdx Index leaf of recipient account, or _EXIT_IDX if exit, or 0 if not transfer\r\n     * Events: `L1UserTxEvent`\r\n     */\r\n    function addL1Transaction(\r\n        uint256 babyPubKey,\r\n        uint48 fromIdx,\r\n        uint40 loadAmountF,\r\n        uint40 amountF,\r\n        uint32 tokenID,\r\n        uint48 toIdx,\r\n        bytes calldata permit\r\n    ) external payable {\r\n        // check tokenID\r\n        require(\r\n            tokenID < tokenList.length,\r\n            \"Litex::addL1Transaction: TOKEN_NOT_REGISTERED\"\r\n        );\r\n\r\n        // check loadAmount\r\n        uint256 loadAmount = _float2Fix(loadAmountF);\r\n        require(\r\n            loadAmount < _LIMIT_LOAD_AMOUNT,\r\n            \"Litex::addL1Transaction: LOADAMOUNT_EXCEED_LIMIT\"\r\n        );\r\n\r\n        // deposit token or ether\r\n        if (loadAmount > 0) {\r\n            if (tokenID == 0) {\r\n                require(\r\n                    loadAmount == msg.value,\r\n                    \"Litex::addL1Transaction: LOADAMOUNT_ETH_DOES_NOT_MATCH\"\r\n                );\r\n            } else {\r\n                require(\r\n                    msg.value == 0,\r\n                    \"Litex::addL1Transaction: MSG_VALUE_NOT_EQUAL_0\"\r\n                );\r\n                if (permit.length != 0) {\r\n                    _permit(tokenList[tokenID], loadAmount, permit);\r\n                }\r\n                uint256 prevBalance = IERC20(tokenList[tokenID]).balanceOf(\r\n                    address(this)\r\n                );\r\n                _safeTransferFrom(\r\n                    tokenList[tokenID],\r\n                    msg.sender,\r\n                    address(this),\r\n                    loadAmount\r\n                );\r\n                uint256 postBalance = IERC20(tokenList[tokenID]).balanceOf(\r\n                    address(this)\r\n                );\r\n                require(\r\n                    postBalance - prevBalance == loadAmount,\r\n                    \"Litex::addL1Transaction: LOADAMOUNT_ERC20_DOES_NOT_MATCH\"\r\n                );\r\n            }\r\n        }\r\n\r\n        // perform L1 User Tx\r\n        _addL1Transaction(\r\n            msg.sender,\r\n            babyPubKey,\r\n            fromIdx,\r\n            loadAmountF,\r\n            amountF,\r\n            tokenID,\r\n            toIdx\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Create a new rollup l1 user transaction\r\n     * @param ethAddress Ethereum addres of the sender account or new account\r\n     * @param babyPubKey Public key babyjubjub represented as point: sign + (Ay)\r\n     * @param fromIdx Index leaf of sender account or 0 if create new account\r\n     * @param loadAmountF Amount from L1 to L2 to sender account or new account\r\n     * @param amountF Amount transfered between L2 accounts\r\n     * @param tokenID Token identifier\r\n     * @param toIdx Index leaf of recipient account, or _EXIT_IDX if exit, or 0 if not transfer\r\n     * Events: `L1UserTxEvent`\r\n     */\r\n    function _addL1Transaction(\r\n        address ethAddress,\r\n        uint256 babyPubKey,\r\n        uint48 fromIdx,\r\n        uint40 loadAmountF,\r\n        uint40 amountF,\r\n        uint32 tokenID,\r\n        uint48 toIdx\r\n    ) internal {\r\n        uint256 amount = _float2Fix(amountF);\r\n        require(\r\n            amount < _LIMIT_L2TRANSFER_AMOUNT,\r\n            \"Litex::_addL1Transaction: AMOUNT_EXCEED_LIMIT\"\r\n        );\r\n\r\n        // toIdx can be: 0, _EXIT_IDX or (toIdx > _RESERVED_IDX)\r\n        if (toIdx == 0) {\r\n            require(\r\n                (amount == 0),\r\n                \"Litex::_addL1Transaction: AMOUNT_MUST_BE_0_IF_NOT_TRANSFER\"\r\n            );\r\n        } else {\r\n            if ((toIdx == _EXIT_IDX)) {\r\n                require(\r\n                    (loadAmountF == 0),\r\n                    \"Litex::_addL1Transaction: LOADAMOUNT_MUST_BE_0_IF_EXIT\"\r\n                );\r\n            } else {\r\n                require(\r\n                    ((toIdx > _RESERVED_IDX) && (toIdx <= lastIdx)),\r\n                    \"Litex::_addL1Transaction: INVALID_TOIDX\"\r\n                );\r\n            }\r\n        }\r\n        // fromIdx can be: 0 if create account or (fromIdx > _RESERVED_IDX)\r\n        if (fromIdx == 0) {\r\n            require(\r\n                babyPubKey != 0,\r\n                \"Litex::_addL1Transaction: INVALID_CREATE_ACCOUNT_WITH_NO_BABYJUB\"\r\n            );\r\n        } else {\r\n            require(\r\n                (fromIdx > _RESERVED_IDX) && (fromIdx <= lastIdx),\r\n                \"Litex::_addL1Transaction: INVALID_FROMIDX\"\r\n            );\r\n            require(\r\n                babyPubKey == 0,\r\n                \"Litex::_addL1Transaction: BABYJUB_MUST_BE_0_IF_NOT_CREATE_ACCOUNT\"\r\n            );\r\n        }\r\n\r\n        _l1QueueAddTx(\r\n            ethAddress,\r\n            babyPubKey,\r\n            fromIdx,\r\n            loadAmountF,\r\n            amountF,\r\n            tokenID,\r\n            toIdx\r\n        );\r\n    }\r\n\r\n    //////////////\r\n    // User operations\r\n    /////////////\r\n\r\n    /**\r\n     * @dev Withdraw to retrieve the tokens from the exit tree to the owner account\r\n     * Before this call an exit transaction must be done\r\n     * @param tokenID Token identifier\r\n     * @param amount Amount to retrieve\r\n     * @param babyPubKey Public key babyjubjub represented as point: sign + (Ay)\r\n     * @param numExitRoot Batch number where the exit transaction has been done\r\n     * @param siblings Siblings to demonstrate merkle tree proof\r\n     * @param idx Index of the exit tree account\r\n     * @param instantWithdraw true if is an instant withdraw\r\n     * Events: `WithdrawEvent`\r\n     */\r\n    function withdrawMerkleProof(\r\n        uint32 tokenID,\r\n        uint192 amount,\r\n        uint256 babyPubKey,\r\n        uint32 numExitRoot,\r\n        uint256[] memory siblings,\r\n        uint48 idx,\r\n        bool instantWithdraw\r\n    ) external {\r\n        // numExitRoot is not checked because an invalid numExitRoot will bring to a 0 root\r\n        // and this is an empty tree.\r\n        // in case of instant withdraw assure that is available\r\n        if (instantWithdraw) {\r\n            require(\r\n                _processInstantWithdrawal(tokenList[tokenID], amount),\r\n                \"Litex::withdrawMerkleProof: INSTANT_WITHDRAW_WASTED_FOR_THIS_USD_RANGE\"\r\n            );\r\n        }\r\n\r\n        // build 'key' and 'value' for exit tree\r\n        uint256[4] memory arrayState = _buildTreeState(\r\n            tokenID,\r\n            0,\r\n            amount,\r\n            babyPubKey,\r\n            msg.sender\r\n        );\r\n        uint256 stateHash = _hash4Elements(arrayState);\r\n        // get exit root given its index depth\r\n        uint256 exitRoot = exitRootsMap[numExitRoot];\r\n        // check exit tree nullifier\r\n        require(\r\n            exitNullifierMap[numExitRoot][idx] == false,\r\n            \"Litex::withdrawMerkleProof: WITHDRAW_ALREADY_DONE\"\r\n        );\r\n        // check sparse merkle tree proof\r\n        require(\r\n            _smtVerifier(exitRoot, siblings, idx, stateHash) == true,\r\n            \"Litex::withdrawMerkleProof: SMT_PROOF_INVALID\"\r\n        );\r\n\r\n        // set nullifier\r\n        exitNullifierMap[numExitRoot][idx] = true;\r\n\r\n        _withdrawFunds(amount, tokenID, instantWithdraw);\r\n\r\n        emit WithdrawEvent(idx, numExitRoot, instantWithdraw);\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw to retrieve the tokens from the exit tree to the owner account\r\n     * Before this call an exit transaction must be done\r\n     * @param proofA zk-snark input\r\n     * @param proofB zk-snark input\r\n     * @param proofC zk-snark input\r\n     * @param tokenID Token identifier\r\n     * @param amount Amount to retrieve\r\n     * @param numExitRoot Batch number where the exit transaction has been done\r\n     * @param idx Index of the exit tree account\r\n     * @param instantWithdraw true if is an instant withdraw\r\n     * Events: `WithdrawEvent`\r\n     */\r\n    function withdrawCircuit(\r\n        uint256[2] calldata proofA,\r\n        uint256[2][2] calldata proofB,\r\n        uint256[2] calldata proofC,\r\n        uint32 tokenID,\r\n        uint192 amount,\r\n        uint32 numExitRoot,\r\n        uint48 idx,\r\n        bool instantWithdraw\r\n    ) external {\r\n        // in case of instant withdraw assure that is available\r\n        if (instantWithdraw) {\r\n            require(\r\n                _processInstantWithdrawal(tokenList[tokenID], amount),\r\n                \"Litex::withdrawCircuit: INSTANT_WITHDRAW_WASTED_FOR_THIS_USD_RANGE\"\r\n            );\r\n        }\r\n        require(\r\n            exitNullifierMap[numExitRoot][idx] == false,\r\n            \"Litex::withdrawCircuit: WITHDRAW_ALREADY_DONE\"\r\n        );\r\n\r\n        // get exit root given its index depth\r\n        uint256 exitRoot = exitRootsMap[numExitRoot];\r\n\r\n        uint256 input = uint256(\r\n            sha256(abi.encodePacked(exitRoot, msg.sender, tokenID, amount, idx))\r\n        ) % _RFIELD;\r\n        // verify zk-snark circuit\r\n        require(\r\n            withdrawVerifier.verifyProof(proofA, proofB, proofC, [input]) ==\r\n                true,\r\n            \"Litex::withdrawCircuit: INVALID_ZK_PROOF\"\r\n        );\r\n\r\n        // set nullifier\r\n        exitNullifierMap[numExitRoot][idx] = true;\r\n\r\n        _withdrawFunds(amount, tokenID, instantWithdraw);\r\n\r\n        emit WithdrawEvent(idx, numExitRoot, instantWithdraw);\r\n    }\r\n\r\n    //////////////\r\n    // Governance methods\r\n    /////////////\r\n    /**\r\n     * @dev Update ForgeL1L2BatchTimeout\r\n     * @param newForgeL1L2BatchTimeout New ForgeL1L2BatchTimeout\r\n     * Events: `UpdateForgeL1L2BatchTimeout`\r\n     */\r\n    function updateForgeL1L2BatchTimeout(uint8 newForgeL1L2BatchTimeout)\r\n        external\r\n        onlyGovernance\r\n    {\r\n        require(\r\n            newForgeL1L2BatchTimeout <= ABSOLUTE_MAX_L1L2BATCHTIMEOUT,\r\n            \"Litex::updateForgeL1L2BatchTimeout: MAX_FORGETIMEOUT_EXCEED\"\r\n        );\r\n        forgeL1L2BatchTimeout = newForgeL1L2BatchTimeout;\r\n        emit UpdateForgeL1L2BatchTimeout(newForgeL1L2BatchTimeout);\r\n    }\r\n\r\n    /**\r\n     * @dev Update feeAddToken\r\n     * @param newFeeAddToken New feeAddToken\r\n     * Events: `UpdateFeeAddToken`\r\n     */\r\n    function updateFeeAddToken(uint256 newFeeAddToken) external onlyGovernance {\r\n        feeAddToken = newFeeAddToken;\r\n        emit UpdateFeeAddToken(newFeeAddToken);\r\n    }\r\n\r\n    //////////////\r\n    // Viewers\r\n    /////////////\r\n\r\n    /**\r\n     * @dev Retrieve the number of tokens added in rollup\r\n     * @return Number of tokens added in rollup\r\n     */\r\n    function registerTokensCount() public view returns (uint256) {\r\n        return tokenList.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Retrieve the number of rollup verifiers\r\n     * @return Number of verifiers\r\n     */\r\n    function rollupVerifiersLength() public view returns (uint256) {\r\n        return rollupVerifiers.length;\r\n    }\r\n\r\n    //////////////\r\n    // Internal/private methods\r\n    /////////////\r\n\r\n    /**\r\n     * @dev Inclusion of a new token to the rollup\r\n     * @param tokenAddress Smart contract token address\r\n     * Events: `AddToken`\r\n     */\r\n    function addToken(address tokenAddress, bytes calldata permit) public {\r\n        require(\r\n            IERC20(tokenAddress).totalSupply() > 0,\r\n            \"Litex::addToken: TOTAL_SUPPLY_ZERO\"\r\n        );\r\n        uint256 currentTokens = tokenList.length;\r\n        require(\r\n            currentTokens < _LIMIT_TOKENS,\r\n            \"Litex::addToken: TOKEN_LIST_FULL\"\r\n        );\r\n        require(\r\n            tokenAddress != address(0),\r\n            \"Litex::addToken: ADDRESS_0_INVALID\"\r\n        );\r\n        require(tokenMap[tokenAddress] == 0, \"Litex::addToken: ALREADY_ADDED\");\r\n\r\n        if (msg.sender != litexGovernanceAddress) {\r\n            // permit and transfer LXT tokens\r\n            if (permit.length != 0) {\r\n                _permit(tokenLXT, feeAddToken, permit);\r\n            }\r\n            _safeTransferFrom(\r\n                tokenLXT,\r\n                msg.sender,\r\n                litexGovernanceAddress,\r\n                feeAddToken\r\n            );\r\n        }\r\n\r\n        tokenList.push(tokenAddress);\r\n        tokenMap[tokenAddress] = currentTokens;\r\n\r\n        emit AddToken(tokenAddress, uint32(currentTokens));\r\n    }\r\n\r\n    /**\r\n     * @dev Initialize verifiers\r\n     * @param _verifiers verifiers address array\r\n     * @param _verifiersParams encoeded maxTx and nlevels of the verifier as follows:\r\n     * [8 bits]nLevels || [248 bits] maxTx\r\n     */\r\n    function _initializeVerifiers(\r\n        address[] memory _verifiers,\r\n        uint256[] memory _verifiersParams\r\n    ) internal {\r\n        for (uint256 i = 0; i < _verifiers.length; i++) {\r\n            rollupVerifiers.push(\r\n                VerifierRollup({\r\n                    verifierInterface: VerifierRollupInterface(_verifiers[i]),\r\n                    maxTx: (_verifiersParams[i] << 8) >> 8,\r\n                    nLevels: _verifiersParams[i] >> (256 - 8)\r\n                })\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Add L1-user-tx, add it to the correspoding queue\r\n     * l1Tx L1-user-tx encoded in bytes as follows: [20 bytes] fromEthAddr || [32 bytes] fromBjj-compressed || [4 bytes] fromIdx ||\r\n     * [5 bytes] loadAmountFloat40 || [5 bytes] amountFloat40 || [4 bytes] tokenId || [4 bytes] toIdx\r\n     * @param ethAddress Ethereum address of the rollup account\r\n     * @param babyPubKey Public key babyjubjub represented as point: sign + (Ay)\r\n     * @param fromIdx Index account of the sender account\r\n     * @param loadAmountF Amount from L1 to L2\r\n     * @param amountF  Amount transfered between L2 accounts\r\n     * @param tokenID  Token identifier\r\n     * @param toIdx Index leaf of recipient account\r\n     * Events: `L1UserTxEvent`\r\n     */\r\n    function _l1QueueAddTx(\r\n        address ethAddress,\r\n        uint256 babyPubKey,\r\n        uint48 fromIdx,\r\n        uint40 loadAmountF,\r\n        uint40 amountF,\r\n        uint32 tokenID,\r\n        uint48 toIdx\r\n    ) internal {\r\n        bytes memory l1Tx = abi.encodePacked(\r\n            ethAddress,\r\n            babyPubKey,\r\n            fromIdx,\r\n            loadAmountF,\r\n            amountF,\r\n            tokenID,\r\n            toIdx\r\n        );\r\n\r\n        uint256 currentPosition = mapL1TxQueue[nextL1FillingQueue].length /\r\n            _L1_USER_TOTALBYTES;\r\n\r\n        // concatenate storage byte array with the new l1Tx\r\n        _concatStorage(mapL1TxQueue[nextL1FillingQueue], l1Tx);\r\n\r\n        emit L1UserTxEvent(nextL1FillingQueue, uint8(currentPosition), l1Tx);\r\n        if (currentPosition + 1 >= _MAX_L1_USER_TX) {\r\n            nextL1FillingQueue++;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev return the current L1-user-tx queue adding the L1-coordinator-tx\r\n     * @param ptr Ptr where L1 data is set\r\n     * @param l1Batch if true, the include l1TXs from the queue\r\n     * [1 byte] V(ecdsa signature) || [32 bytes] S(ecdsa signature) ||\r\n     * [32 bytes] R(ecdsa signature) || [32 bytes] fromBjj-compressed || [4 bytes] tokenId\r\n     */\r\n    function _buildL1Data(uint256 ptr, bool l1Batch) internal view {\r\n        uint256 dPtr;\r\n        uint256 dLen;\r\n\r\n        (dPtr, dLen) = _getCallData(3);\r\n        uint256 l1CoordinatorLength = dLen / _L1_COORDINATOR_TOTALBYTES;\r\n\r\n        uint256 l1UserLength;\r\n        bytes memory l1UserTxQueue;\r\n        if (l1Batch) {\r\n            l1UserTxQueue = mapL1TxQueue[nextL1ToForgeQueue];\r\n            l1UserLength = l1UserTxQueue.length / _L1_USER_TOTALBYTES;\r\n        } else {\r\n            l1UserLength = 0;\r\n        }\r\n\r\n        require(\r\n            l1UserLength + l1CoordinatorLength <= _MAX_L1_TX,\r\n            \"Litex::_buildL1Data: L1_TX_OVERFLOW\"\r\n        );\r\n\r\n        if (l1UserLength > 0) {\r\n            // Copy the queue to the ptr and update ptr\r\n            assembly {\r\n                let ptrFrom := add(l1UserTxQueue, 0x20)\r\n                let ptrTo := ptr\r\n                ptr := add(ptr, mul(l1UserLength, _L1_USER_TOTALBYTES))\r\n                for {\r\n\r\n                } lt(ptrTo, ptr) {\r\n                    ptrTo := add(ptrTo, 32)\r\n                    ptrFrom := add(ptrFrom, 32)\r\n                } {\r\n                    mstore(ptrTo, mload(ptrFrom))\r\n                }\r\n            }\r\n        }\r\n\r\n        for (uint256 i = 0; i < l1CoordinatorLength; i++) {\r\n            uint8 v; // L1-Coordinator-Tx bytes[0]\r\n            bytes32 s; // L1-Coordinator-Tx bytes[1:32]\r\n            bytes32 r; // L1-Coordinator-Tx bytes[33:64]\r\n            bytes32 babyPubKey; // L1-Coordinator-Tx bytes[65:96]\r\n            uint256 tokenID; // L1-Coordinator-Tx bytes[97:100]\r\n\r\n            assembly {\r\n                v := byte(0, calldataload(dPtr))\r\n                dPtr := add(dPtr, 1)\r\n\r\n                s := calldataload(dPtr)\r\n                dPtr := add(dPtr, 32)\r\n\r\n                r := calldataload(dPtr)\r\n                dPtr := add(dPtr, 32)\r\n\r\n                babyPubKey := calldataload(dPtr)\r\n                dPtr := add(dPtr, 32)\r\n\r\n                tokenID := shr(224, calldataload(dPtr)) // 256-32 = 224\r\n                dPtr := add(dPtr, 4)\r\n            }\r\n\r\n            require(\r\n                tokenID < tokenList.length,\r\n                \"Litex::_buildL1Data: TOKEN_NOT_REGISTERED\"\r\n            );\r\n\r\n            address ethAddress = _ETH_ADDRESS_INTERNAL_ONLY;\r\n\r\n            // v must be >=27 --> EIP-155, v == 0 means no signature\r\n            if (v != 0) {\r\n                ethAddress = _checkSig(babyPubKey, r, s, v);\r\n            }\r\n\r\n            // add L1-Coordinator-Tx to the L1-tx queue\r\n            assembly {\r\n                mstore(ptr, shl(96, ethAddress)) // 256 - 160 = 96, write ethAddress: bytes[0:19]\r\n                ptr := add(ptr, 20)\r\n\r\n                mstore(ptr, babyPubKey) // write babyPubKey: bytes[20:51]\r\n                ptr := add(ptr, 32)\r\n\r\n                mstore(ptr, 0) // write zeros\r\n                // [6 Bytes] fromIdx ,\r\n                // [5 bytes] loadAmountFloat40 .\r\n                // [5 bytes] amountFloat40\r\n                ptr := add(ptr, 16)\r\n\r\n                mstore(ptr, shl(224, tokenID)) // 256 - 32 = 224 write tokenID: bytes[62:65]\r\n                ptr := add(ptr, 4)\r\n\r\n                mstore(ptr, 0) // write [6 Bytes] toIdx\r\n                ptr := add(ptr, 6)\r\n            }\r\n        }\r\n\r\n        _fillZeros(\r\n            ptr,\r\n            (_MAX_L1_TX - l1UserLength - l1CoordinatorLength) *\r\n                _L1_USER_TOTALBYTES\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate the circuit input hashing all the elements\r\n     * @param newLastIdx New total rollup accounts\r\n     * @param newStRoot New state root\r\n     * @param newExitRoot New exit root\r\n     * @param l1Batch Indicates if this forge will be L2 or L1-L2\r\n     * @param verifierIdx Verifier index\r\n     */\r\n    function _constructCircuitInput(\r\n        uint48 newLastIdx,\r\n        uint256 newStRoot,\r\n        uint256 newExitRoot,\r\n        bool l1Batch,\r\n        uint8 verifierIdx\r\n    ) internal view returns (uint256) {\r\n        uint256 oldStRoot = stateRootMap[lastForgedBatch];\r\n        uint256 oldLastIdx = lastIdx;\r\n        uint256 dPtr; // Pointer to the calldata parameter data\r\n        uint256 dLen; // Length of the calldata parameter\r\n\r\n        // l1L2TxsData = l2Bytes * maxTx =\r\n        // ([(nLevels / 8) bytes] fromIdx + [(nLevels / 8) bytes] toIdx + [5 bytes] amountFloat40 + [1 bytes] fee) * maxTx =\r\n        // ((nLevels / 4) bytes + 3 bytes) * maxTx\r\n        uint256 l1L2TxsDataLength = ((rollupVerifiers[verifierIdx].nLevels /\r\n            8) *\r\n            2 +\r\n            5 +\r\n            1) * rollupVerifiers[verifierIdx].maxTx;\r\n\r\n        // [(nLevels / 8) bytes]\r\n        uint256 feeIdxCoordinatorLength = (rollupVerifiers[verifierIdx]\r\n            .nLevels / 8) * 64;\r\n\r\n        // the concatenation of all arguments could be done with abi.encodePacked(args), but is suboptimal, especially with a large bytes arrays\r\n        // [6 bytes] lastIdx +\r\n        // [6 bytes] newLastIdx  +\r\n        // [32 bytes] stateRoot  +\r\n        // [32 bytes] newStRoot  +\r\n        // [32 bytes] newExitRoot +\r\n        // [_MAX_L1_TX * _L1_USER_TOTALBYTES bytes] l1TxsData +\r\n        // totall1L2TxsDataLength +\r\n        // feeIdxCoordinatorLength +\r\n        // [2 bytes] chainID +\r\n        // [4 bytes] batchNum =\r\n        // _INPUT_SHA_CONSTANT_BYTES bytes +  totall1L2TxsDataLength + feeIdxCoordinatorLength\r\n        bytes memory inputBytes;\r\n\r\n        uint256 ptr; // Position for writing the bufftr\r\n\r\n        assembly {\r\n            let inputBytesLength := add(\r\n                add(_INPUT_SHA_CONSTANT_BYTES, l1L2TxsDataLength),\r\n                feeIdxCoordinatorLength\r\n            )\r\n\r\n            // Set inputBytes to the next free memory space\r\n            inputBytes := mload(0x40)\r\n            // Reserve the memory. 32 for the length , the input bytes and 32\r\n            // extra bytes at the end for word manipulation\r\n            mstore(0x40, add(add(inputBytes, 0x40), inputBytesLength))\r\n\r\n            // Set the actua length of the input bytes\r\n            mstore(inputBytes, inputBytesLength)\r\n\r\n            // Set The Ptr at the begining of the inputPubber\r\n            ptr := add(inputBytes, 32)\r\n\r\n            mstore(ptr, shl(208, oldLastIdx)) // 256-48 = 208\r\n            ptr := add(ptr, 6)\r\n\r\n            mstore(ptr, shl(208, newLastIdx)) // 256-48 = 208\r\n            ptr := add(ptr, 6)\r\n\r\n            mstore(ptr, oldStRoot)\r\n            ptr := add(ptr, 32)\r\n\r\n            mstore(ptr, newStRoot)\r\n            ptr := add(ptr, 32)\r\n\r\n            mstore(ptr, newExitRoot)\r\n            ptr := add(ptr, 32)\r\n        }\r\n\r\n        // Copy the L1TX Data\r\n        _buildL1Data(ptr, l1Batch);\r\n        ptr += _MAX_L1_TX * _L1_USER_TOTALBYTES;\r\n\r\n        // Copy the L2 TX Data from calldata\r\n        (dPtr, dLen) = _getCallData(4);\r\n        require(\r\n            dLen <= l1L2TxsDataLength,\r\n            \"Litex::_constructCircuitInput: L2_TX_OVERFLOW\"\r\n        );\r\n        assembly {\r\n            calldatacopy(ptr, dPtr, dLen)\r\n        }\r\n        ptr += dLen;\r\n\r\n        // L2 TX unused data is padded with 0 at the end\r\n        _fillZeros(ptr, l1L2TxsDataLength - dLen);\r\n        ptr += l1L2TxsDataLength - dLen;\r\n\r\n        // Copy the FeeIdxCoordinator from the calldata\r\n        (dPtr, dLen) = _getCallData(5);\r\n        require(\r\n            dLen <= feeIdxCoordinatorLength,\r\n            \"Litex::_constructCircuitInput: INVALID_FEEIDXCOORDINATOR_LENGTH\"\r\n        );\r\n        assembly {\r\n            calldatacopy(ptr, dPtr, dLen)\r\n        }\r\n        ptr += dLen;\r\n        _fillZeros(ptr, feeIdxCoordinatorLength - dLen);\r\n        ptr += feeIdxCoordinatorLength - dLen;\r\n\r\n        // store 2 bytes of chainID at the end of the inputBytes\r\n        assembly {\r\n            mstore(ptr, shl(240, chainid())) // 256 - 16 = 240\r\n        }\r\n        ptr += 2;\r\n\r\n        uint256 batchNum = lastForgedBatch + 1;\r\n\r\n        // store 4 bytes of batch number at the end of the inputBytes\r\n        assembly {\r\n            mstore(ptr, shl(224, batchNum)) // 256 - 32 = 224\r\n        }\r\n\r\n        return uint256(sha256(inputBytes)) % _RFIELD;\r\n    }\r\n\r\n    /**\r\n     * @dev Clear the current queue, and update the `nextL1ToForgeQueue` and `nextL1FillingQueue` if needed\r\n     */\r\n    function _clearQueue() internal returns (uint16) {\r\n        uint16 l1UserTxsLen = uint16(\r\n            mapL1TxQueue[nextL1ToForgeQueue].length / _L1_USER_TOTALBYTES\r\n        );\r\n        delete mapL1TxQueue[nextL1ToForgeQueue];\r\n        nextL1ToForgeQueue++;\r\n        if (nextL1ToForgeQueue == nextL1FillingQueue) {\r\n            nextL1FillingQueue++;\r\n        }\r\n        return l1UserTxsLen;\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw the funds to the msg.sender if instant withdraw or to the withdraw delayer if delayed\r\n     * @param amount Amount to retrieve\r\n     * @param tokenID Token identifier\r\n     * @param instantWithdraw true if is an instant withdraw\r\n     */\r\n    function _withdrawFunds(\r\n        uint192 amount,\r\n        uint32 tokenID,\r\n        bool instantWithdraw\r\n    ) internal {\r\n        if (instantWithdraw) {\r\n            _safeTransfer(tokenList[tokenID], msg.sender, amount);\r\n        } else {\r\n            if (tokenID == 0) {\r\n                withdrawDelayerContract.deposit{value: amount}(\r\n                    msg.sender,\r\n                    address(0),\r\n                    amount\r\n                );\r\n            } else {\r\n                address tokenAddress = tokenList[tokenID];\r\n\r\n                _safeApprove(\r\n                    tokenAddress,\r\n                    address(withdrawDelayerContract),\r\n                    amount\r\n                );\r\n\r\n                withdrawDelayerContract.deposit(\r\n                    msg.sender,\r\n                    tokenAddress,\r\n                    amount\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    ///////////\r\n    // helpers ERC20 functions\r\n    ///////////\r\n\r\n    /**\r\n     * @dev Approve ERC20\r\n     * @param token Token address\r\n     * @param to Recievers\r\n     * @param value Quantity of tokens to approve\r\n     */\r\n    function _safeApprove(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        /* solhint-disable avoid-low-level-calls */\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(_APPROVE_SIGNATURE, to, value)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"Litex::_safeApprove: ERC20_APPROVE_FAILED\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens or ether from the smart contract\r\n     * @param token Token address\r\n     * @param to Address to recieve the tokens\r\n     * @param value Quantity to transfer\r\n     */\r\n    function _safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // address 0 is reserved for eth\r\n        if (token == address(0)) {\r\n            /* solhint-disable avoid-low-level-calls */\r\n            (bool success, ) = msg.sender.call{value: value}(new bytes(0));\r\n            require(success, \"Litex::_safeTransfer: ETH_TRANSFER_FAILED\");\r\n        } else {\r\n            /* solhint-disable avoid-low-level-calls */\r\n            (bool success, bytes memory data) = token.call(\r\n                abi.encodeWithSelector(_TRANSFER_SIGNATURE, to, value)\r\n            );\r\n            require(\r\n                success && (data.length == 0 || abi.decode(data, (bool))),\r\n                \"Litex::_safeTransfer: ERC20_TRANSFER_FAILED\"\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev transferFrom ERC20\r\n     * Require approve tokens for this contract previously\r\n     * @param token Token address\r\n     * @param from Sender\r\n     * @param to Reciever\r\n     * @param value Quantity of tokens to send\r\n     */\r\n    function _safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(_TRANSFER_FROM_SIGNATURE, from, to, value)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"Litex::_safeTransferFrom: ERC20_TRANSFERFROM_FAILED\"\r\n        );\r\n    }\r\n\r\n    ///////////\r\n    // helpers ERC20 extension functions\r\n    ///////////\r\n\r\n    /**\r\n     * @notice Function to call token permit method of extended ERC20\r\n     * @param _amount Quantity that is expected to be allowed\r\n     * @param _permitData Raw data of the call `permit` of the token\r\n     */\r\n    function _permit(\r\n        address token,\r\n        uint256 _amount,\r\n        bytes calldata _permitData\r\n    ) internal {\r\n        bytes4 sig = abi.decode(_permitData, (bytes4));\r\n        require(\r\n            sig == _PERMIT_SIGNATURE,\r\n            \"LitexAuctionProtocol::_permit: NOT_VALID_CALL\"\r\n        );\r\n        (\r\n            address owner,\r\n            address spender,\r\n            uint256 value,\r\n            uint256 deadline,\r\n            uint8 v,\r\n            bytes32 r,\r\n            bytes32 s\r\n        ) = abi.decode(\r\n            _permitData[4:],\r\n            (address, address, uint256, uint256, uint8, bytes32, bytes32)\r\n        );\r\n        require(\r\n            owner == msg.sender,\r\n            \"Litex::_permit: PERMIT_OWNER_MUST_BE_THE_SENDER\"\r\n        );\r\n        require(\r\n            spender == address(this),\r\n            \"Litex::_permit: SPENDER_MUST_BE_THIS\"\r\n        );\r\n        require(\r\n            value == _amount,\r\n            \"Litex::_permit: PERMIT_AMOUNT_DOES_NOT_MATCH\"\r\n        );\r\n\r\n        // we call without checking the result, in case it fails and he doesn't have enough balance\r\n        // the following transferFrom should be fail. This prevents DoS attacks from using a signature\r\n        // before the smartcontract call\r\n        /* solhint-disable avoid-low-level-calls */\r\n        address(token).call(\r\n            abi.encodeWithSelector(\r\n                _PERMIT_SIGNATURE,\r\n                owner,\r\n                spender,\r\n                value,\r\n                deadline,\r\n                v,\r\n                r,\r\n                s\r\n            )\r\n        );\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"tokenID\",\"type\":\"uint32\"}],\"name\":\"AddToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"batchNum\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"l1UserTxsLen\",\"type\":\"uint16\"}],\"name\":\"ForgeBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"forgeL1L2BatchTimeout\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeAddToken\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"withdrawalDelay\",\"type\":\"uint64\"}],\"name\":\"InitializeLitexEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"queueIndex\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"position\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"l1UserTx\",\"type\":\"bytes\"}],\"name\":\"L1UserTxEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"SafeMode\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"numBucket\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"blockStamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawals\",\"type\":\"uint256\"}],\"name\":\"UpdateBucketWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"arrayBuckets\",\"type\":\"uint256[]\"}],\"name\":\"UpdateBucketsParameters\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFeeAddToken\",\"type\":\"uint256\"}],\"name\":\"UpdateFeeAddToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"newForgeL1L2BatchTimeout\",\"type\":\"uint8\"}],\"name\":\"UpdateForgeL1L2BatchTimeout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"addressArray\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint64[]\",\"name\":\"valueArray\",\"type\":\"uint64[]\"}],\"name\":\"UpdateTokenExchange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"newWithdrawalDelay\",\"type\":\"uint64\"}],\"name\":\"UpdateWithdrawalDelay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint48\",\"name\":\"idx\",\"type\":\"uint48\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"numExitRoot\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"instantWithdraw\",\"type\":\"bool\"}],\"name\":\"WithdrawEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"litexV2\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ABSOLUTE_MAX_L1L2BATCHTIMEOUT\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ACCOUNT_CREATION_HASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"AUTHORISE_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"domainSeparator\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EIP712DOMAIN_HASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LITEX_NETWORK_HASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NAME_HASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERSION_HASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"babyPubKey\",\"type\":\"uint256\"},{\"internalType\":\"uint48\",\"name\":\"fromIdx\",\"type\":\"uint48\"},{\"internalType\":\"uint40\",\"name\":\"loadAmountF\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"amountF\",\"type\":\"uint40\"},{\"internalType\":\"uint32\",\"name\":\"tokenID\",\"type\":\"uint32\"},{\"internalType\":\"uint48\",\"name\":\"toIdx\",\"type\":\"uint48\"},{\"internalType\":\"bytes\",\"name\":\"permit\",\"type\":\"bytes\"}],\"name\":\"addL1Transaction\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"permit\",\"type\":\"bytes\"}],\"name\":\"addToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"name\":\"buckets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"uint48\",\"name\":\"\",\"type\":\"uint48\"}],\"name\":\"exitNullifierMap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"exitRootsMap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeAddToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint48\",\"name\":\"newLastIdx\",\"type\":\"uint48\"},{\"internalType\":\"uint256\",\"name\":\"newStRoot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newExitRoot\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"encodedL1CoordinatorTx\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"l1L2TxsData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"feeIdxCoordinator\",\"type\":\"bytes\"},{\"internalType\":\"uint8\",\"name\":\"verifierIdx\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"l1Batch\",\"type\":\"bool\"},{\"internalType\":\"uint256[2]\",\"name\":\"proofA\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"proofB\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"proofC\",\"type\":\"uint256[2]\"}],\"name\":\"forgeBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"forgeL1L2BatchTimeout\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_verifiers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_verifiersParams\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_withdrawVerifier\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_litexAuctionContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenLXT\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_forgeL1L2BatchTimeout\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_feeAddToken\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_poseidon2Elements\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_poseidon3Elements\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_poseidon4Elements\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_litexGovernanceAddress\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_withdrawalDelay\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_withdrawDelayerContract\",\"type\":\"address\"}],\"name\":\"initializeLitex\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint192\",\"name\":\"amount\",\"type\":\"uint192\"}],\"name\":\"instantWithdrawalViewer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"l1L2TxsDataHashMap\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastForgedBatch\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastIdx\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastL1L2Batch\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"litexAuctionContract\",\"outputs\":[{\"internalType\":\"contract ILitexAuctionProtocol\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"litexGovernanceAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"mapL1TxQueue\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nBuckets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextL1FillingQueue\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextL1ToForgeQueue\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ceilUSD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockStamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rateBlocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rateWithdrawals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxWithdrawals\",\"type\":\"uint256\"}],\"name\":\"packBucket\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ret\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registerTokensCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rollupVerifiers\",\"outputs\":[{\"internalType\":\"contract VerifierRollupInterface\",\"name\":\"verifierInterface\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxTx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nLevels\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rollupVerifiersLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safeMode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"stateRootMap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenExchange\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenLXT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenMap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bucket\",\"type\":\"uint256\"}],\"name\":\"unpackBucket\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ceilUSD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockStamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rateBlocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rateWithdrawals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxWithdrawals\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"newBuckets\",\"type\":\"uint256[]\"}],\"name\":\"updateBucketsParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFeeAddToken\",\"type\":\"uint256\"}],\"name\":\"updateFeeAddToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"newForgeL1L2BatchTimeout\",\"type\":\"uint8\"}],\"name\":\"updateForgeL1L2BatchTimeout\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addressArray\",\"type\":\"address[]\"},{\"internalType\":\"uint64[]\",\"name\":\"valueArray\",\"type\":\"uint64[]\"}],\"name\":\"updateTokenExchange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateVerifiers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"newWithdrawalDelay\",\"type\":\"uint64\"}],\"name\":\"updateWithdrawalDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"proofA\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"proofB\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"proofC\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint32\",\"name\":\"tokenID\",\"type\":\"uint32\"},{\"internalType\":\"uint192\",\"name\":\"amount\",\"type\":\"uint192\"},{\"internalType\":\"uint32\",\"name\":\"numExitRoot\",\"type\":\"uint32\"},{\"internalType\":\"uint48\",\"name\":\"idx\",\"type\":\"uint48\"},{\"internalType\":\"bool\",\"name\":\"instantWithdraw\",\"type\":\"bool\"}],\"name\":\"withdrawCircuit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawDelayerContract\",\"outputs\":[{\"internalType\":\"contract IWithdrawalDelayer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"tokenID\",\"type\":\"uint32\"},{\"internalType\":\"uint192\",\"name\":\"amount\",\"type\":\"uint192\"},{\"internalType\":\"uint256\",\"name\":\"babyPubKey\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"numExitRoot\",\"type\":\"uint32\"},{\"internalType\":\"uint256[]\",\"name\":\"siblings\",\"type\":\"uint256[]\"},{\"internalType\":\"uint48\",\"name\":\"idx\",\"type\":\"uint48\"},{\"internalType\":\"bool\",\"name\":\"instantWithdraw\",\"type\":\"bool\"}],\"name\":\"withdrawMerkleProof\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawVerifier\",\"outputs\":[{\"internalType\":\"contract VerifierWithdrawInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawalDelay\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"LitexRollup","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://d0e3f5ace5b697203773598a2fa58e27f0250233ac01be0d32502c40e20e5a1b"}]}