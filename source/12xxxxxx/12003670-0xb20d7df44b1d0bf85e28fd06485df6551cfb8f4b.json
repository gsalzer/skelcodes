{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.7.1;\r\npragma experimental ABIEncoderV2;\r\n\r\n// File: contracts/BondToken_and_GDOTC/util/TransferETHInterface.sol\r\n\r\n\r\n\r\n\r\ninterface TransferETHInterface {\r\n    receive() external payable;\r\n\r\n    event LogTransferETH(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/BondToken_and_GDOTC/bondToken/BondTokenInterface.sol\r\n\r\n\r\n\r\n\r\n\r\n\r\ninterface BondTokenInterface is IERC20 {\r\n    event LogExpire(uint128 rateNumerator, uint128 rateDenominator, bool firstTime);\r\n\r\n    function mint(address account, uint256 amount) external returns (bool success);\r\n\r\n    function expire(uint128 rateNumerator, uint128 rateDenominator)\r\n        external\r\n        returns (bool firstTime);\r\n\r\n    function simpleBurn(address account, uint256 amount) external returns (bool success);\r\n\r\n    function burn(uint256 amount) external returns (bool success);\r\n\r\n    function burnAll() external returns (uint256 amount);\r\n\r\n    function getRate() external view returns (uint128 rateNumerator, uint128 rateDenominator);\r\n}\r\n\r\n// File: contracts/BondToken_and_GDOTC/oracle/LatestPriceOracleInterface.sol\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the price oracle.\r\n */\r\ninterface LatestPriceOracleInterface {\r\n    /**\r\n     * @dev Returns `true`if oracle is working.\r\n     */\r\n    function isWorking() external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the last updated price. Decimals is 8.\r\n     **/\r\n    function latestPrice() external returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the timestamp of the last updated price.\r\n     */\r\n    function latestTimestamp() external returns (uint256);\r\n}\r\n\r\n// File: contracts/BondToken_and_GDOTC/oracle/PriceOracleInterface.sol\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the price oracle.\r\n */\r\ninterface PriceOracleInterface is LatestPriceOracleInterface {\r\n    /**\r\n     * @dev Returns the latest id. The id start from 1 and increments by 1.\r\n     */\r\n    function latestId() external returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the historical price specified by `id`. Decimals is 8.\r\n     */\r\n    function getPrice(uint256 id) external returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the timestamp of historical price specified by `id`.\r\n     */\r\n    function getTimestamp(uint256 id) external returns (uint256);\r\n}\r\n\r\n// File: contracts/BondToken_and_GDOTC/bondMaker/BondMakerInterface.sol\r\n\r\n\r\n\r\n\r\n\r\n\r\ninterface BondMakerInterface {\r\n    event LogNewBond(\r\n        bytes32 indexed bondID,\r\n        address indexed bondTokenAddress,\r\n        uint256 indexed maturity,\r\n        bytes32 fnMapID\r\n    );\r\n\r\n    event LogNewBondGroup(\r\n        uint256 indexed bondGroupID,\r\n        uint256 indexed maturity,\r\n        uint64 indexed sbtStrikePrice,\r\n        bytes32[] bondIDs\r\n    );\r\n\r\n    event LogIssueNewBonds(uint256 indexed bondGroupID, address indexed issuer, uint256 amount);\r\n\r\n    event LogReverseBondGroupToCollateral(\r\n        uint256 indexed bondGroupID,\r\n        address indexed owner,\r\n        uint256 amount\r\n    );\r\n\r\n    event LogExchangeEquivalentBonds(\r\n        address indexed owner,\r\n        uint256 indexed inputBondGroupID,\r\n        uint256 indexed outputBondGroupID,\r\n        uint256 amount\r\n    );\r\n\r\n    event LogLiquidateBond(bytes32 indexed bondID, uint128 rateNumerator, uint128 rateDenominator);\r\n\r\n    function registerNewBond(uint256 maturity, bytes calldata fnMap)\r\n        external\r\n        returns (\r\n            bytes32 bondID,\r\n            address bondTokenAddress,\r\n            bytes32 fnMapID\r\n        );\r\n\r\n    function registerNewBondGroup(bytes32[] calldata bondIDList, uint256 maturity)\r\n        external\r\n        returns (uint256 bondGroupID);\r\n\r\n    function reverseBondGroupToCollateral(uint256 bondGroupID, uint256 amount)\r\n        external\r\n        returns (bool success);\r\n\r\n    function exchangeEquivalentBonds(\r\n        uint256 inputBondGroupID,\r\n        uint256 outputBondGroupID,\r\n        uint256 amount,\r\n        bytes32[] calldata exceptionBonds\r\n    ) external returns (bool);\r\n\r\n    function liquidateBond(uint256 bondGroupID, uint256 oracleHintID)\r\n        external\r\n        returns (uint256 totalPayment);\r\n\r\n    function collateralAddress() external view returns (address);\r\n\r\n    function oracleAddress() external view returns (PriceOracleInterface);\r\n\r\n    function feeTaker() external view returns (address);\r\n\r\n    function decimalsOfBond() external view returns (uint8);\r\n\r\n    function decimalsOfOraclePrice() external view returns (uint8);\r\n\r\n    function maturityScale() external view returns (uint256);\r\n\r\n    function nextBondGroupID() external view returns (uint256);\r\n\r\n    function getBond(bytes32 bondID)\r\n        external\r\n        view\r\n        returns (\r\n            address bondAddress,\r\n            uint256 maturity,\r\n            uint64 solidStrikePrice,\r\n            bytes32 fnMapID\r\n        );\r\n\r\n    function getFnMap(bytes32 fnMapID) external view returns (bytes memory fnMap);\r\n\r\n    function getBondGroup(uint256 bondGroupID)\r\n        external\r\n        view\r\n        returns (bytes32[] memory bondIDs, uint256 maturity);\r\n\r\n    function generateFnMapID(bytes calldata fnMap) external view returns (bytes32 fnMapID);\r\n\r\n    function generateBondID(uint256 maturity, bytes calldata fnMap)\r\n        external\r\n        view\r\n        returns (bytes32 bondID);\r\n}\r\n\r\n// File: contracts/Interfaces/BondRegistratorInterface.sol\r\n\r\n\r\n\r\n\r\n\r\n\r\ninterface BondRegistratorInterface {\r\n    struct Points {\r\n        uint64 x1;\r\n        uint64 y1;\r\n        uint64 x2;\r\n        uint64 y2;\r\n    }\r\n\r\n    function getFnMap(Points[] memory points) external pure returns (bytes memory fnMap);\r\n\r\n    function registerSBT(\r\n        BondMakerInterface bondMaker,\r\n        uint64 sbtStrikePrice,\r\n        uint64 maturity\r\n    ) external returns (bytes32);\r\n\r\n    function registerBondGroup(\r\n        BondMakerInterface bondMaker,\r\n        uint256 callStrikePrice,\r\n        uint64 sbtStrikePrice,\r\n        uint64 maturity,\r\n        bytes32 SBTId\r\n    ) external returns (uint256 bondGroupId);\r\n\r\n    function registerBond(\r\n        BondMakerInterface bondMaker,\r\n        Points[] memory points,\r\n        uint256 maturity\r\n    ) external returns (bytes32);\r\n}\r\n\r\n// File: contracts/SimpleAggregator/BondRegistrator.sol\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract BondRegistrator is BondRegistratorInterface {\r\n    function getFnMap(Points[] memory points) public pure override returns (bytes memory) {\r\n        uint256[] memory polyline = _zipLines(points);\r\n        return abi.encode(polyline);\r\n    }\r\n\r\n    function _zipLines(Points[] memory points) internal pure returns (uint256[] memory lines) {\r\n        lines = new uint256[](points.length);\r\n        for (uint256 i = 0; i < points.length; i++) {\r\n            uint256 x1U256 = uint256(points[i].x1) << (64 + 64 + 64); // uint64\r\n            uint256 y1U256 = uint256(points[i].y1) << (64 + 64); // uint64\r\n            uint256 x2U256 = uint256(points[i].x2) << 64; // uint64\r\n            uint256 y2U256 = uint256(points[i].y2); // uint64\r\n            uint256 zip = x1U256 | y1U256 | x2U256 | y2U256;\r\n            lines[i] = zip;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Create SBT function mapping and register new SBT\r\n     */\r\n    function registerSBT(\r\n        BondMakerInterface bondMaker,\r\n        uint64 sbtStrikePrice,\r\n        uint64 maturity\r\n    ) public override returns (bytes32) {\r\n        Points[] memory SBTPoints = new Points[](2);\r\n        SBTPoints[0] = Points(0, 0, sbtStrikePrice, sbtStrikePrice);\r\n        SBTPoints[1] = Points(sbtStrikePrice, sbtStrikePrice, sbtStrikePrice * 2, sbtStrikePrice);\r\n        return registerBond(bondMaker, SBTPoints, maturity);\r\n    }\r\n\r\n    /**\r\n     * @notice Create exotic option function mappings and register bonds, then register new bond group\r\n     * @param SBTId SBT should be already registered and use SBT bond ID\r\n     */\r\n    function registerBondGroup(\r\n        BondMakerInterface bondMaker,\r\n        uint256 callStrikePrice,\r\n        uint64 sbtStrikePrice,\r\n        uint64 maturity,\r\n        bytes32 SBTId\r\n    ) public override returns (uint256 bondGroupId) {\r\n        bytes32[] memory bondIds = new bytes32[](4);\r\n        uint64 lev2EndPoint = uint64(callStrikePrice * 2) - sbtStrikePrice;\r\n        uint64 maxProfitVolShort = uint64((callStrikePrice - sbtStrikePrice) / 2);\r\n        bondIds[0] = SBTId;\r\n        {\r\n            Points[] memory CallPoints = new Points[](2);\r\n            CallPoints[0] = Points(0, 0, uint64(callStrikePrice), 0);\r\n            CallPoints[1] = Points(\r\n                uint64(callStrikePrice),\r\n                0,\r\n                uint64(callStrikePrice * 2),\r\n                uint64(callStrikePrice)\r\n            );\r\n            bondIds[1] = registerBond(bondMaker, CallPoints, maturity);\r\n        }\r\n        {\r\n            Points[] memory Lev2Points = new Points[](3);\r\n            Lev2Points[0] = Points(0, 0, sbtStrikePrice, 0);\r\n            Lev2Points[1] = Points(\r\n                sbtStrikePrice,\r\n                0,\r\n                lev2EndPoint,\r\n                uint64(callStrikePrice - sbtStrikePrice)\r\n            );\r\n            Lev2Points[2] = Points(\r\n                lev2EndPoint,\r\n                uint64(callStrikePrice - sbtStrikePrice),\r\n                lev2EndPoint + sbtStrikePrice,\r\n                uint64(callStrikePrice - sbtStrikePrice)\r\n            );\r\n            bondIds[2] = registerBond(bondMaker, Lev2Points, maturity);\r\n        }\r\n\r\n        {\r\n            Points[] memory VolShortPoints = new Points[](4);\r\n            VolShortPoints[0] = Points(0, 0, sbtStrikePrice, 0);\r\n            VolShortPoints[1] = Points(\r\n                sbtStrikePrice,\r\n                0,\r\n                uint64(callStrikePrice),\r\n                maxProfitVolShort\r\n            );\r\n            VolShortPoints[2] = Points(uint64(callStrikePrice), maxProfitVolShort, lev2EndPoint, 0);\r\n            VolShortPoints[3] = Points(lev2EndPoint, 0, lev2EndPoint + sbtStrikePrice, 0);\r\n\r\n            bondIds[3] = registerBond(bondMaker, VolShortPoints, maturity);\r\n        }\r\n        return bondMaker.registerNewBondGroup(bondIds, uint256(maturity));\r\n    }\r\n\r\n    /**\r\n     * @notice Register bond token if same bond does not exist. If exists, return bondID\r\n     */\r\n    function registerBond(\r\n        BondMakerInterface bondMaker,\r\n        Points[] memory points,\r\n        uint256 maturity\r\n    ) public override returns (bytes32) {\r\n        bytes memory fnMap = getFnMap(points);\r\n        bytes32 bondId = bondMaker.generateBondID(maturity, fnMap);\r\n        (address bondAddress, , , ) = bondMaker.getBond(bondId);\r\n        if (bondAddress != address(0)) {\r\n            return bondId;\r\n        }\r\n        bondMaker.registerNewBond(maturity, fnMap);\r\n        return bondId;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"x1\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"y1\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"x2\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"y2\",\"type\":\"uint64\"}],\"internalType\":\"struct BondRegistratorInterface.Points[]\",\"name\":\"points\",\"type\":\"tuple[]\"}],\"name\":\"getFnMap\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract BondMakerInterface\",\"name\":\"bondMaker\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"x1\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"y1\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"x2\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"y2\",\"type\":\"uint64\"}],\"internalType\":\"struct BondRegistratorInterface.Points[]\",\"name\":\"points\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"}],\"name\":\"registerBond\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract BondMakerInterface\",\"name\":\"bondMaker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"callStrikePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"sbtStrikePrice\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"maturity\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"SBTId\",\"type\":\"bytes32\"}],\"name\":\"registerBondGroup\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bondGroupId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract BondMakerInterface\",\"name\":\"bondMaker\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"sbtStrikePrice\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"maturity\",\"type\":\"uint64\"}],\"name\":\"registerSBT\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"BondRegistrator","CompilerVersion":"v0.7.1+commit.f4a555be","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"constantinople","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://7dc318a75f30490df2ada61aa3f333beb3ff02d662e2339e01de36fad1c8ef61"}]}