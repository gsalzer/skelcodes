{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2021-04-14\r\n*/\r\n\r\n// File contracts/swappers/SushiSwapMultiSwapper.sol\r\n// SPDX-License-Identifier: GPL-3.0\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\n// solhint-disable avoid-low-level-calls\r\n\r\n// File @boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol@v1.2.1\r\n// License-Identifier: MIT\r\ninterface IERC20 {\r\n}\r\n\r\n// File @boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol@v1.2.1\r\n// License-Identifier: MIT\r\n\r\nlibrary BoringERC20 {\r\n    bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)\r\n\r\n    /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.\r\n    /// Reverts on a failed transfer.\r\n    /// @param token The address of the ERC-20 token.\r\n    /// @param to Transfer tokens to.\r\n    /// @param amount The token amount.\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: Transfer failed\");\r\n    }\r\n}\r\n\r\n// File @boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol@v1.2.1\r\n// License-Identifier: MIT\r\n\r\n/// @notice A library for performing overflow-/underflow-safe math,\r\n/// updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math).\r\nlibrary BoringMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require(b == 0 || (c = a * b) / b == a, \"BoringMath: Mul Overflow\");\r\n    }\r\n}\r\n\r\n// File @sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol@v1.4.2\r\n// License-Identifier: GPL-3.0\r\n\r\ninterface IUniswapV2Pair {\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n}\r\n\r\n// File contracts/libraries/UniswapV2Library.sol\r\n// License-Identifier: GPL-3.0\r\n\r\nlibrary UniswapV2Library {\r\n    using BoringMath for uint;\r\n\r\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\r\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\r\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\r\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\r\n    }\r\n\r\n    // calculates the CREATE2 address for a pair without making any external calls\r\n    function pairFor(address factory, address tokenA, address tokenB, bytes32 pairCodeHash) internal pure returns (address pair) {\r\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\r\n        pair = address(uint(keccak256(abi.encodePacked(\r\n                hex'ff',\r\n                factory,\r\n                keccak256(abi.encodePacked(token0, token1)),\r\n                pairCodeHash // init code hash\r\n            ))));\r\n    }\r\n\r\n    // fetches and sorts the reserves for a pair\r\n    function getReserves(address factory, address tokenA, address tokenB, bytes32 pairCodeHash) internal view returns (uint reserveA, uint reserveB) {\r\n        (address token0,) = sortTokens(tokenA, tokenB);\r\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB, pairCodeHash)).getReserves();\r\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n    }\r\n\r\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\r\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\r\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\r\n        uint amountInWithFee = amountIn.mul(997);\r\n        uint numerator = amountInWithFee.mul(reserveOut);\r\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\r\n        amountOut = numerator / denominator;\r\n    }\r\n\r\n    // performs chained getAmountOut calculations on any number of pairs\r\n    function getAmountsOut(address factory, uint amountIn, address[] memory path, bytes32 pairCodeHash) internal view returns (uint[] memory amounts) {\r\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\r\n        amounts = new uint[](path.length);\r\n        amounts[0] = amountIn;\r\n        for (uint i; i < path.length - 1; i++) {\r\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1], pairCodeHash);\r\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\r\n        }\r\n    }\r\n}\r\n\r\n// File @sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol@v1.0.2\r\n// License-Identifier: MIT\r\n\r\ninterface IBentoBoxV1 {\r\n    function deposit(IERC20 token_, address from, address to, uint256 amount, uint256 share) external payable returns (uint256 amountOut, uint256 shareOut);\r\n    function toAmount(IERC20 token, uint256 share, bool roundUp) external view returns (uint256 amount);\r\n    function withdraw(IERC20 token_, address from, address to, uint256 amount, uint256 share) external returns (uint256 amountOut, uint256 shareOut);\r\n}\r\n\r\n// File contracts/swappers/SushiSwapMultiSwapper.sol\r\n// License-Identifier: GPL-3.0\r\n\r\ncontract SushiSwapMultiSwapper {\r\n    using BoringERC20 for IERC20;\r\n    using BoringMath for uint256;\r\n\r\n    address private immutable factory;\r\n    IBentoBoxV1 private immutable bentoBox;\r\n    bytes32 private immutable pairCodeHash;\r\n\r\n    constructor (address _factory, IBentoBoxV1 _bentoBox, bytes32 _pairCodeHash) public {\r\n        factory = _factory;\r\n        bentoBox = _bentoBox;\r\n        pairCodeHash = _pairCodeHash;\r\n    }\r\n\r\n    function getOutputAmount (IERC20 tokenIn, address[] calldata path, uint256 shareIn) external view returns (uint256 amountOut){\r\n        uint256 amountIn = bentoBox.toAmount(tokenIn, shareIn, false);\r\n        uint256[] memory amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path, pairCodeHash);\r\n        amountOut = amounts[amounts.length - 1];\r\n    }\r\n\r\n    function swap (IERC20 tokenIn, IERC20 tokenOut, uint256 amountMinOut, address path1, address path2, address to, uint256 baseShare, uint256 shareIn) external returns (uint256) {\r\n        address[] memory path;\r\n        if (path2 == address(0)) {\r\n            if (path1 == address(0)) {\r\n                path = new address[](2);\r\n                path[1] = address(tokenOut);\r\n            } else {\r\n                path = new address[](3);\r\n                path[1] = path1;\r\n                path[2] = address(tokenOut);\r\n            }\r\n        } else {\r\n            path = new address[](4);\r\n            path[1] = path1;\r\n            path[2] = path2;\r\n            path[3] = address(tokenOut);\r\n        }\r\n        path[0] = address(tokenIn);\r\n        (uint256 amountIn, ) = bentoBox.withdraw(tokenIn, address(this), address(this), 0, shareIn);\r\n        uint256 amount = _swapExactTokensForTokens(amountIn, amountMinOut, path, address(bentoBox));\r\n        (, uint256 share) = bentoBox.deposit(tokenOut, address(bentoBox), to, amount, 0);\r\n        return baseShare.add(share);\r\n    }\r\n\r\n    // Swaps an exact amount of tokens for another token through the path passed as an argument\r\n    // Returns the amount of the final token\r\n    function _swapExactTokensForTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] memory path,\r\n        address to\r\n    ) internal returns (uint256 amountOut) {\r\n        uint256[] memory amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path, pairCodeHash);\r\n        amountOut = amounts[amounts.length - 1];\r\n        require(amountOut >= amountOutMin, \"insufficient-amount-out\");\r\n        IERC20(path[0]).safeTransfer(UniswapV2Library.pairFor(factory, path[0], path[1], pairCodeHash), amountIn);\r\n        _swap(amounts, path, to);\r\n    }\r\n\r\n    // requires the initial amount to have already been sent to the first pair\r\n    function _swap(\r\n        uint256[] memory amounts,\r\n        address[] memory path,\r\n        address _to\r\n    ) internal virtual {\r\n        for (uint256 i; i < path.length - 1; i++) {\r\n            (address input, address output) = (path[i], path[i + 1]);\r\n            (address token0, ) = UniswapV2Library.sortTokens(input, output);\r\n            uint256 amountOut = amounts[i + 1];\r\n            (uint256 amount0Out, uint256 amount1Out) = input == token0\r\n                ? (uint256(0), amountOut)\r\n                : (amountOut, uint256(0));\r\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2], pairCodeHash) : _to;\r\n            IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output, pairCodeHash)).swap(\r\n                amount0Out,\r\n                amount1Out,\r\n                to,\r\n                new bytes(0)\r\n            );\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"contract IBentoBoxV1\",\"name\":\"_bentoBox\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_pairCodeHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"shareIn\",\"type\":\"uint256\"}],\"name\":\"getOutputAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountMinOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"path1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"path2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"baseShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shareIn\",\"type\":\"uint256\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"SushiSwapMultiSwapper","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000c0aee478e3658e2610c5f7a4a2e1777ce9e4f2ac000000000000000000000000f5bce5077908a1b7370b9ae04adc565ebd643966e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://d96231cff205e5bd9cac2df235b5870a57a5c5ca55f3374122acb1627c0d0c12"}]}