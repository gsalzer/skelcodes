{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/home/stack/work/d0xhegex/contracts/OptionChef.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.6.12;\\n\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./interfaces/IOptions.sol\\\";\\nimport \\\"./interfaces/IHegexoption.sol\\\";\\nimport \\\"./interfaces/IChefData.sol\\\";\\n\\n/**\\n * @author ivan@district0x\\n * @title Option factory aka Mighty Option Chef\\n * @notice Option Chef has the monopoly to mint and destroy NFT Hegexoptions\\n */\\ncontract OptionChef is Ownable {\\n\\n    //storage\\n\\n    IHegicOptions public hegicOptionETH;\\n    IHegicOptions public hegicOptionBTC;\\n    IHegexoption public hegexoption;\\n    IOptionChefData public chefData;\\n\\n    //ideally this should've been a mapping/arr of id->Struct {owner, id}\\n    //there are a few EVM gotchas for this (afaik one can't peek into\\n    //mapped structs from another contracts, happy to restructure if I'm wrong though)\\n    // mapping (uint => uint) uIds;\\n    // mapping (uint => uint) ids;\\n\\n    //events\\n\\n    event Wrapped(address account, uint optionId);\\n    event Unwrapped(address account, uint tokenId);\\n    event Exercised(uint _tokenId, uint profit);\\n    event CreatedHegic(uint optionId, uint hegexId);\\n\\n\\n    //utility functions\\n\\n    function updateHegicOption(IHegicOptions _hegicOptionETH,\\n                               IHegicOptions _hegicOptionBTC)\\n        external\\n        onlyOwner {\\n        hegicOptionETH = _hegicOptionETH;\\n        hegicOptionBTC = _hegicOptionBTC;\\n    }\\n\\n    function updateHegexoption(IHegexoption _hegexoption)\\n        external\\n        onlyOwner {\\n        hegexoption = _hegexoption;\\n    }\\n\\n    constructor(IHegicOptions _hegicOptionETH,\\n                IHegicOptions _hegicOptionBTC,\\n                IOptionChefData  _chefData) public {\\n        hegicOptionETH = _hegicOptionETH;\\n        hegicOptionBTC = _hegicOptionBTC;\\n        chefData = _chefData;\\n    }\\n\\n    // direct user to a right contract\\n    // NOTE: optimize to bool if gas savings are substantial\\n    function getHegic(uint8 _optionType) public view returns (IHegicOptions) {\\n        if (_optionType == 0) {\\n            return hegicOptionETH;\\n        } else  {\\n            return hegicOptionBTC;\\n        }\\n    }\\n\\n    //core (un)wrap functionality\\n\\n\\n    /**\\n     * @notice Hegexoption wrapper adapter for Hegic\\n     */\\n    function wrapHegic(uint _uId, uint8 _optionType) public returns (uint newTokenId) {\\n        require(chefData.ids(_uId) == 0 , \\\"UOPT:exists\\\");\\n        IHegicOptions hegicOption = getHegic(_optionType);\\n        (, address holder, , , , , , ) = hegicOption.options(_uId);\\n        //auth is a bit unintuitive for wrapping, see NFT.sol:isApprovedOrOwner()\\n        require(holder == msg.sender || holder == address(this), \\\"UOPT:ownership\\\");\\n        newTokenId = hegexoption.mintHegexoption(msg.sender);\\n        chefData.setuid(newTokenId, _uId);\\n        chefData.setid(_uId, newTokenId);\\n        chefData.setoptiontype(_uId, _optionType);\\n        emit Wrapped(msg.sender, _uId);\\n    }\\n\\n    /**\\n     * @notice Hegexoption unwrapper adapter for Hegic\\n     * @notice check burning logic, do we really want to burn it (vs meta)\\n     * @notice TODO recheck escrow mechanism on 0x relay to prevent unwrapping when locked\\n     */\\n    function unwrapHegic(uint8 _optionType, uint _tokenId) external onlyTokenOwner(_tokenId) {\\n        // checks if hegicOption will allow to transfer option ownership\\n        IHegicOptions hegicOption = getHegic(_optionType);\\n        (IHegicOptions.State state, , , , , , uint expiration ,) = getUnderlyingOptionParams(_optionType, _tokenId);\\n        if (state == IHegicOptions.State.Active || expiration >= block.timestamp) {\\n            hegicOption.transfer(chefData.uIds(_tokenId), msg.sender);\\n        }\\n        //burns anyway if token is expired\\n        hegexoption.burnHegexoption(_tokenId);\\n        uint utokenid = chefData.uIds(_tokenId);\\n        chefData.setid(utokenid, 0);\\n        chefData.setuid(_tokenId, 0);\\n        emit Unwrapped(msg.sender, _tokenId);\\n    }\\n\\n    function exerciseHegic(uint8 _optionType, uint _tokenId) external onlyTokenOwner(_tokenId) {\\n        IHegicOptions hegicOption = getHegic(_optionType);\\n        hegicOption.exercise(getUnderlyingOptionId(_tokenId));\\n        uint profit = address(this).balance;\\n        payable(msg.sender).transfer(profit);\\n        emit Exercised(_tokenId, profit);\\n    }\\n\\n    uint256 public migrationLock = 0;\\n    address payable public newChef;\\n\\n    /**\\n     * @notice  Migrate chef (effective after 72 hours)\\n     * @param _newChef chef address\\n     */\\n    function migrateChefWithTimelock(address payable _newChef) public onlyOwner {\\n        if (migrationLock != 0 && (block.timestamp > migrationLock + 72 hours)) {\\n            chefData.transferOwnership(newChef);\\n            hegexoption.migrateChef(newChef);\\n            migrationLock = 0;\\n        } else {\\n            migrationLock = block.timestamp;\\n            newChef = _newChef;\\n        }\\n    }\\n\\n    function getUnderlyingOptionId(uint _tokenId) public view returns (uint) {\\n        return chefData.uIds(_tokenId);\\n    }\\n\\n    function getUnderlyingOptionParams(uint8 _optionType, uint _tokenId)\\n        public\\n        view\\n        returns (\\n        IHegicOptions.State state,\\n        address payable holder,\\n        uint256 strike,\\n        uint256 amount,\\n        uint256 lockedAmount,\\n        uint256 premium,\\n        uint256 expiration,\\n        IHegicOptions.OptionType optionType)\\n    {\\n        (state,\\n         holder,\\n         strike,\\n         amount,\\n         lockedAmount,\\n         premium,\\n         expiration,\\n         optionType) = getHegic(_optionType).options(chefData.uIds(_tokenId));\\n    }\\n\\n    /**\\n     * @notice check whether Chef has underlying option locked\\n     */\\n    function isDelegated(uint _tokenId) public view returns (bool) {\\n        uint8 optionType = chefData.optionType(chefData.uIds(_tokenId));\\n        IHegicOptions hegicOption = getHegic(optionType);\\n        ( , address holder, , , , , , ) = hegicOption.options(chefData.uIds(_tokenId));\\n        return holder == address(this);\\n    }\\n\\n    function createHegic(\\n        uint8 _hegicOptionType,\\n        uint _period,\\n        uint _amount,\\n        uint _strike,\\n        IHegicOptions.OptionType _optionType\\n    )\\n        payable\\n        external\\n        returns (uint)\\n    {\\n        IHegicOptions hegicOption = getHegic(_hegicOptionType);\\n        uint optionId = hegicOption.create{value: msg.value}(_period, _amount, _strike, _optionType);\\n        // return eth excess\\n        payable(msg.sender).transfer(address(this).balance);\\n        uint hegexId = wrapHegic(optionId, _hegicOptionType);\\n        emit CreatedHegic(optionId, hegexId);\\n        return hegexId;\\n    }\\n\\n    modifier onlyTokenOwner(uint _itemId) {\\n        require(msg.sender == hegexoption.ownerOf(_itemId), \\\"UOPT:ownership/exchange\\\");\\n        _;\\n    }\\n\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"/home/stack/work/d0xhegex/contracts/interfaces/IChefData.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.6.12;\\n\\ninterface IOptionChefData {\\n    function uIds(uint k) external view returns (uint);\\n    function ids(uint k) external view returns (uint);\\n    function optionType(uint k) external view returns (uint8);\\n\\n    function setuid(uint k, uint v) external;\\n    function setid(uint k, uint v) external;\\n    function setoptiontype(uint k, uint8 v) external;\\n    function transferOwnership(address newOwner) external;\\n}\\n\"\r\n    },\r\n    \"/home/stack/work/d0xhegex/contracts/interfaces/IHegexoption.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.6.12;\\n\\ninterface IHegexoption {\\n    //custom functions in use\\n    function burnHegexoption(uint _id) external;\\n    function mintHegexoption(address _to) external returns (uint256);\\n    function migrateChef(address payable _optionChef) external;\\n    //IERC721 functions in use\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n    function transferOwnership(address newOwner) external;\\n}\\n\"\r\n    },\r\n    \"/home/stack/work/d0xhegex/contracts/interfaces/IOptions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.6.12;\\n\\ninterface IHegicOptions {\\n    event Create(\\n        uint256 indexed id,\\n        address indexed account,\\n        uint256 settlementFee,\\n        uint256 totalFee\\n    );\\n\\n    event Exercise(uint256 indexed id, uint256 profit);\\n    event Expire(uint256 indexed id, uint256 premium);\\n    enum State {Inactive, Active, Exercised, Expired}\\n    enum OptionType {Invalid, Put, Call}\\n\\n    struct Option {\\n        State state;\\n        address payable holder;\\n        uint256 strike;\\n        uint256 amount;\\n        uint256 lockedAmount;\\n        uint256 premium;\\n        uint256 expiration;\\n        OptionType optionType;\\n    }\\n\\n    function create(\\n        uint256 period,\\n        uint256 amount,\\n        uint256 strike,\\n        OptionType optionType\\n    )\\n        external\\n        payable\\n        returns (uint256 optionID);\\n\\n    function transfer(uint256 optionID, address payable newHolder) external;\\n\\n    function exercise(uint256 optionID) external;\\n\\n    function options(uint) external view returns (\\n        State state,\\n        address payable holder,\\n        uint256 strike,\\n        uint256 amount,\\n        uint256 lockedAmount,\\n        uint256 premium,\\n        uint256 expiration,\\n        OptionType optionType\\n    );\\n\\n    function unlock(uint256 optionID) external;\\n}\\n\\ninterface IHegicETHOptions is IHegicOptions {\\n        function fees(\\n        uint256 period,\\n        uint256 amount,\\n        uint256 strike,\\n        OptionType optionType\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 total,\\n            uint256 settlementFee,\\n            uint256 strikeFee,\\n            uint256 periodFee\\n        );\\n}\\n\\ninterface IHegicERC20Options is IHegicOptions {\\n    function fees(\\n        uint256 period,\\n        uint256 amount,\\n        uint256 strike,\\n        OptionType optionType\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 total,\\n            uint256 totalETH,\\n            uint256 settlementFee,\\n            uint256 strikeFee,\\n            uint256 periodFee\\n        );\\n}\\n\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IHegicOptions\",\"name\":\"_hegicOptionETH\",\"type\":\"address\"},{\"internalType\":\"contract IHegicOptions\",\"name\":\"_hegicOptionBTC\",\"type\":\"address\"},{\"internalType\":\"contract IOptionChefData\",\"name\":\"_chefData\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"optionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"hegexId\",\"type\":\"uint256\"}],\"name\":\"CreatedHegic\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"profit\",\"type\":\"uint256\"}],\"name\":\"Exercised\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Unwrapped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"optionId\",\"type\":\"uint256\"}],\"name\":\"Wrapped\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"chefData\",\"outputs\":[{\"internalType\":\"contract IOptionChefData\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_hegicOptionType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_period\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_strike\",\"type\":\"uint256\"},{\"internalType\":\"enum IHegicOptions.OptionType\",\"name\":\"_optionType\",\"type\":\"uint8\"}],\"name\":\"createHegic\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_optionType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"exerciseHegic\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_optionType\",\"type\":\"uint8\"}],\"name\":\"getHegic\",\"outputs\":[{\"internalType\":\"contract IHegicOptions\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getUnderlyingOptionId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_optionType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getUnderlyingOptionParams\",\"outputs\":[{\"internalType\":\"enum IHegicOptions.State\",\"name\":\"state\",\"type\":\"uint8\"},{\"internalType\":\"address payable\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"strike\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"premium\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"enum IHegicOptions.OptionType\",\"name\":\"optionType\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hegexoption\",\"outputs\":[{\"internalType\":\"contract IHegexoption\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hegicOptionBTC\",\"outputs\":[{\"internalType\":\"contract IHegicOptions\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hegicOptionETH\",\"outputs\":[{\"internalType\":\"contract IHegicOptions\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"isDelegated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newChef\",\"type\":\"address\"}],\"name\":\"migrateChefWithTimelock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrationLock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newChef\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_optionType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"unwrapHegic\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IHegexoption\",\"name\":\"_hegexoption\",\"type\":\"address\"}],\"name\":\"updateHegexoption\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IHegicOptions\",\"name\":\"_hegicOptionETH\",\"type\":\"address\"},{\"internalType\":\"contract IHegicOptions\",\"name\":\"_hegicOptionBTC\",\"type\":\"address\"}],\"name\":\"updateHegicOption\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_uId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_optionType\",\"type\":\"uint8\"}],\"name\":\"wrapHegic\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"newTokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"OptionChef","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000efc0eeadc1132a12c9487d800112693bf49ecfa20000000000000000000000003961245db602ed7c03eeccda33ea3846bd8723bd0000000000000000000000004238d64e26c45b87c29aa134dd50b5c7b9e213c2","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}