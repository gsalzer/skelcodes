{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2021-06-09\r\n*/\r\n\r\n// Sources flattened with hardhat v2.3.0 https://hardhat.org\r\n\r\n// File @openzeppelin/contracts/math/SafeMath.sol@v3.4.0-solc-0.7\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        uint256 c = a + b;\r\n        if (c < a) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b > a) return (false, 0);\r\n        return (true, a - b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) return (true, 0);\r\n        uint256 c = a * b;\r\n        if (c / a != b) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a / b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a % b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/InstaVestingResolver.sol\r\n\r\ninterface TokenInterface {\r\n    function balanceOf(address account) external view returns (uint);\r\n    function delegate(address delegatee) external;\r\n    function transfer(address dst, uint rawAmount) external returns (bool);\r\n}\r\n\r\ninterface InstaVestingInferface {\r\n    function owner() external view returns(address);\r\n    function recipient() external view returns(address);\r\n    function vestingAmount() external view returns(uint256);\r\n    function vestingBegin() external view returns(uint32);\r\n    function vestingCliff() external view returns(uint32);\r\n    function vestingEnd() external view returns(uint32);\r\n    function lastUpdate() external view returns(uint32);\r\n    function terminateTime() external view returns(uint32);\r\n}\r\n\r\ninterface InstaVestingFactoryInterface {\r\n    function recipients(address) external view returns(address);\r\n}\r\n\r\ncontract InstaTokenVestingResolver  {\r\n    using SafeMath for uint256;\r\n\r\n    TokenInterface public constant token = TokenInterface(0x6f40d4A6237C257fff2dB00FA0510DeEECd303eb);\r\n    // InstaVestingFactoryInterface public constant factory = InstaVestingFactoryInterface(0x3730D9b06bc23fd2E2F84f1202a7e80815dd054a);\r\n    InstaVestingFactoryInterface public immutable factory;\r\n\r\n    constructor(address factory_) {\r\n        factory = InstaVestingFactoryInterface(factory_);\r\n    }\r\n    struct VestingData {\r\n        address recipient;\r\n        address vesting;\r\n        address owner;\r\n        uint256 vestingAmount;\r\n        uint256 vestingBegin;\r\n        uint256 vestingCliff;\r\n        uint256 vestingEnd;\r\n        uint256 lastClaimed;\r\n        uint256 terminatedTime;\r\n        uint256 vestedAmount;\r\n        uint256 unvestedAmount;\r\n        uint256 claimedAmount;\r\n        uint256 claimableAmount;\r\n    }\r\n\r\n    function getVestingByRecipient(address recipient) external view returns(VestingData memory vestingData) {\r\n        address vestingAddr = factory.recipients(recipient);\r\n        return getVesting(vestingAddr);\r\n    }\r\n\r\n    function getVesting(address vesting) public view returns(VestingData memory vestingData) {\r\n        if (vesting == address(0)) return vestingData;\r\n        InstaVestingInferface VestingContract = InstaVestingInferface(vesting);\r\n        uint256 vestingBegin = uint256(VestingContract.vestingBegin());\r\n        uint256 vestingEnd = uint256(VestingContract.vestingEnd());\r\n        uint256 vestingCliff = uint256(VestingContract.vestingCliff());\r\n        uint256 vestingAmount = VestingContract.vestingAmount();\r\n        uint256 lastUpdate = uint256(VestingContract.lastUpdate());\r\n        uint256 terminatedTime = uint256(VestingContract.terminateTime());\r\n\r\n        \r\n        uint256 claimedAmount;\r\n        uint256 claimableAmount;\r\n        uint256 vestedAmount;\r\n        uint256 unvestedAmount;\r\n        if (block.timestamp > vestingCliff) {\r\n            uint256 time = terminatedTime == 0 ? block.timestamp : terminatedTime;\r\n            if (time > vestingEnd) {\r\n                vestedAmount = vestingAmount;\r\n                if (lastUpdate > vestingEnd) {\r\n                    claimableAmount = 0;\r\n                    claimedAmount = vestedAmount;\r\n                } else {\r\n                    claimableAmount = vestingAmount.mul(time - lastUpdate).div(vestingEnd - vestingBegin);\r\n                    claimedAmount = vestedAmount.mul(time - vestingBegin).div(vestingEnd - vestingBegin);\r\n                }\r\n            } else {\r\n                vestedAmount = vestingAmount.mul(time - vestingBegin).div(vestingEnd - vestingBegin);\r\n                claimableAmount = vestingAmount.mul(time - lastUpdate).div(vestingEnd - vestingBegin);\r\n                claimedAmount = vestedAmount.mul(time - vestingBegin).div(vestingEnd - vestingBegin);\r\n            }\r\n            unvestedAmount = vestingAmount.sub(vestedAmount);\r\n        }\r\n\r\n        vestingData = VestingData({\r\n            recipient: VestingContract.recipient(),\r\n            owner: VestingContract.owner(),\r\n            vesting: vesting,\r\n            vestingAmount: vestingAmount,\r\n            vestingBegin: vestingBegin,\r\n            vestingCliff: vestingCliff,\r\n            vestingEnd: vestingEnd,\r\n            lastClaimed: lastUpdate,\r\n            terminatedTime: terminatedTime,\r\n            vestedAmount: vestedAmount,\r\n            unvestedAmount: unvestedAmount,\r\n            claimedAmount: claimedAmount,\r\n            claimableAmount: claimableAmount\r\n        });\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"factory_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"contract InstaVestingFactoryInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vesting\",\"type\":\"address\"}],\"name\":\"getVesting\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vesting\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vestingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestingBegin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestingCliff\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestingEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastClaimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"terminatedTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unvestedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimableAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct InstaTokenVestingResolver.VestingData\",\"name\":\"vestingData\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"getVestingByRecipient\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vesting\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vestingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestingBegin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestingCliff\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestingEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastClaimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"terminatedTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unvestedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimableAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct InstaTokenVestingResolver.VestingData\",\"name\":\"vestingData\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract TokenInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"InstaTokenVestingResolver","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000003b05a5295aa749d78858e33ece3b97bb3ef4f029","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://deb09c78bbf627dafcc3836eaf55d98a6a413b09356db84c736475ecd0f1ebae"}]}