{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/Elena/Source/argent-contracts/contracts/infrastructure/IAuthoriser.sol\": {\r\n      \"content\": \"// Copyright (C) 2021  Argent Labs Ltd. <https://argent.xyz>\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.3;\\n\\ninterface IAuthoriser {\\n    function isAuthorised(address _sender, address _spender, address _to, bytes calldata _data) external view returns (bool);\\n    function areAuthorised(\\n        address _spender,\\n        address[] calldata _spenders,\\n        address[] calldata _to,\\n        bytes[] calldata _data\\n    )\\n        external\\n        view\\n        returns (bool);\\n}\"\r\n    },\r\n    \"/Users/Elena/Source/argent-contracts/contracts/infrastructure/IModuleRegistry.sol\": {\r\n      \"content\": \"// Copyright (C) 2020  Argent Labs Ltd. <https://argent.xyz>\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity >=0.5.4 <0.9.0;\\n\\n/**\\n * @title IModuleRegistry\\n * @notice Interface for the registry of authorised modules.\\n */\\ninterface IModuleRegistry {\\n    function registerModule(address _module, bytes32 _name) external;\\n\\n    function deregisterModule(address _module) external;\\n\\n    function registerUpgrader(address _upgrader, bytes32 _name) external;\\n\\n    function deregisterUpgrader(address _upgrader) external;\\n\\n    function recoverToken(address _token) external;\\n\\n    function moduleInfo(address _module) external view returns (bytes32);\\n\\n    function upgraderInfo(address _upgrader) external view returns (bytes32);\\n\\n    function isRegisteredModule(address _module) external view returns (bool);\\n\\n    function isRegisteredModule(address[] calldata _modules) external view returns (bool);\\n\\n    function isRegisteredUpgrader(address _upgrader) external view returns (bool);\\n}\"\r\n    },\r\n    \"/Users/Elena/Source/argent-contracts/contracts/infrastructure/storage/IGuardianStorage.sol\": {\r\n      \"content\": \"// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity >=0.5.4 <0.9.0;\\n\\ninterface IGuardianStorage {\\n\\n    /**\\n     * @notice Lets an authorised module add a guardian to a wallet.\\n     * @param _wallet The target wallet.\\n     * @param _guardian The guardian to add.\\n     */\\n    function addGuardian(address _wallet, address _guardian) external;\\n\\n    /**\\n     * @notice Lets an authorised module revoke a guardian from a wallet.\\n     * @param _wallet The target wallet.\\n     * @param _guardian The guardian to revoke.\\n     */\\n    function revokeGuardian(address _wallet, address _guardian) external;\\n\\n    /**\\n     * @notice Checks if an account is a guardian for a wallet.\\n     * @param _wallet The target wallet.\\n     * @param _guardian The account.\\n     * @return true if the account is a guardian for a wallet.\\n     */\\n    function isGuardian(address _wallet, address _guardian) external view returns (bool);\\n\\n    function isLocked(address _wallet) external view returns (bool);\\n\\n    function getLock(address _wallet) external view returns (uint256);\\n\\n    function getLocker(address _wallet) external view returns (address);\\n\\n    function setLock(address _wallet, uint256 _releaseAfter) external;\\n\\n    function getGuardians(address _wallet) external view returns (address[] memory);\\n\\n    function guardianCount(address _wallet) external view returns (uint256);\\n}\"\r\n    },\r\n    \"/Users/Elena/Source/argent-contracts/contracts/infrastructure/storage/ITransferStorage.sol\": {\r\n      \"content\": \"// Copyright (C) 2020  Argent Labs Ltd. <https://argent.xyz>\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity >=0.5.4 <0.9.0;\\n\\n/**\\n * @title ITransferStorage\\n * @notice TransferStorage interface\\n */\\ninterface ITransferStorage {\\n    function setWhitelist(address _wallet, address _target, uint256 _value) external;\\n\\n    function getWhitelist(address _wallet, address _target) external view returns (uint256);\\n}\"\r\n    },\r\n    \"/Users/Elena/Source/argent-contracts/contracts/modules/ArgentModule.sol\": {\r\n      \"content\": \"// Copyright (C) 2021  Argent Labs Ltd. <https://argent.xyz>\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.3;\\n\\nimport \\\"./common/Utils.sol\\\";\\nimport \\\"./common/BaseModule.sol\\\";\\nimport \\\"./RelayerManager.sol\\\";\\nimport \\\"./SecurityManager.sol\\\";\\nimport \\\"./TransactionManager.sol\\\";\\n\\n/**\\n * @title ArgentModule\\n * @notice Single module for the Argent wallet.\\n * @author Julien Niset - <julien@argent.xyz>\\n */\\ncontract ArgentModule is BaseModule, RelayerManager, SecurityManager, TransactionManager {\\n\\n    bytes32 constant public NAME = \\\"ArgentModule\\\";\\n\\n    constructor (\\n        IModuleRegistry _registry,\\n        IGuardianStorage _guardianStorage,\\n        ITransferStorage _userWhitelist,\\n        IAuthoriser _authoriser,\\n        address _uniswapRouter,\\n        uint256 _securityPeriod,\\n        uint256 _securityWindow,\\n        uint256 _recoveryPeriod,\\n        uint256 _lockPeriod\\n    )\\n        BaseModule(_registry, _guardianStorage, _userWhitelist, _authoriser, NAME)\\n        SecurityManager(_recoveryPeriod, _securityPeriod, _securityWindow, _lockPeriod)\\n        TransactionManager(_securityPeriod)\\n        RelayerManager(_uniswapRouter)\\n    {\\n        \\n    }\\n\\n    /**\\n     * @inheritdoc IModule\\n     */\\n    function init(address _wallet) external override onlyWallet(_wallet) {\\n        enableDefaultStaticCalls(_wallet);\\n    }\\n\\n    /**\\n    * @inheritdoc IModule\\n    */\\n    function addModule(address _wallet, address _module) external override onlyWalletOwnerOrSelf(_wallet) onlyWhenUnlocked(_wallet) {\\n        require(registry.isRegisteredModule(_module), \\\"AM: module is not registered\\\");\\n        IWallet(_wallet).authoriseModule(_module, true);\\n    }\\n    \\n    /**\\n     * @inheritdoc RelayerManager\\n     */\\n    function getRequiredSignatures(address _wallet, bytes calldata _data) public view override returns (uint256, OwnerSignature) {\\n        bytes4 methodId = Utils.functionPrefix(_data);\\n\\n        if (methodId == TransactionManager.multiCall.selector ||\\n            methodId == TransactionManager.addToWhitelist.selector ||\\n            methodId == TransactionManager.removeFromWhitelist.selector ||\\n            methodId == TransactionManager.enableERC1155TokenReceiver.selector ||\\n            methodId == TransactionManager.clearSession.selector ||\\n            methodId == ArgentModule.addModule.selector ||\\n            methodId == SecurityManager.addGuardian.selector ||\\n            methodId == SecurityManager.revokeGuardian.selector ||\\n            methodId == SecurityManager.cancelGuardianAddition.selector ||\\n            methodId == SecurityManager.cancelGuardianRevokation.selector)\\n        {\\n            // owner\\n            return (1, OwnerSignature.Required);\\n        }\\n        if (methodId == TransactionManager.multiCallWithSession.selector) {\\n            return (1, OwnerSignature.Session);\\n        }\\n        if (methodId == SecurityManager.executeRecovery.selector) {\\n            // majority of guardians\\n            uint numberOfSignaturesRequired = _majorityOfGuardians(_wallet);\\n            require(numberOfSignaturesRequired > 0, \\\"AM: no guardians set on wallet\\\");\\n            return (numberOfSignaturesRequired, OwnerSignature.Disallowed);\\n        }\\n        if (methodId == SecurityManager.cancelRecovery.selector) {\\n            // majority of (owner + guardians)\\n            uint numberOfSignaturesRequired = Utils.ceil(recoveryConfigs[_wallet].guardianCount + 1, 2);\\n            return (numberOfSignaturesRequired, OwnerSignature.Optional);\\n        }\\n        if (methodId == TransactionManager.multiCallWithGuardians.selector ||\\n            methodId == TransactionManager.multiCallWithGuardiansAndStartSession.selector ||\\n            methodId == SecurityManager.transferOwnership.selector)\\n        {\\n            // owner + majority of guardians\\n            uint majorityGuardians = _majorityOfGuardians(_wallet);\\n            uint numberOfSignaturesRequired = majorityGuardians + 1;\\n            return (numberOfSignaturesRequired, OwnerSignature.Required);\\n        }\\n        if (methodId == SecurityManager.finalizeRecovery.selector ||\\n            methodId == SecurityManager.confirmGuardianAddition.selector ||\\n            methodId == SecurityManager.confirmGuardianRevokation.selector)\\n        {\\n            // anyone\\n            return (0, OwnerSignature.Anyone);\\n        }\\n        if (methodId == SecurityManager.lock.selector || methodId == SecurityManager.unlock.selector) {\\n            // any guardian\\n            return (1, OwnerSignature.Disallowed);\\n        }\\n        revert(\\\"SM: unknown method\\\");\\n    }\\n\\n    function _majorityOfGuardians(address _wallet) internal view returns (uint) {\\n        return Utils.ceil(guardianStorage.guardianCount(_wallet), 2);\\n    }\\n}\"\r\n    },\r\n    \"/Users/Elena/Source/argent-contracts/contracts/modules/RelayerManager.sol\": {\r\n      \"content\": \"// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.3;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"./common/Utils.sol\\\";\\nimport \\\"./common/BaseModule.sol\\\";\\nimport \\\"./common/SimpleOracle.sol\\\";\\nimport \\\"../infrastructure/storage/IGuardianStorage.sol\\\";\\n\\n/**\\n * @title RelayerManager\\n * @notice Abstract Module to execute transactions signed by ETH-less accounts and sent by a relayer.\\n * @author Julien Niset <julien@argent.xyz>, Olivier VDB <olivier@argent.xyz>\\n */\\nabstract contract RelayerManager is BaseModule, SimpleOracle {\\n\\n    uint256 constant internal BLOCKBOUND = 10000;\\n\\n    mapping (address => RelayerConfig) internal relayer;\\n\\n    struct RelayerConfig {\\n        uint256 nonce;\\n        mapping (bytes32 => bool) executedTx;\\n    }\\n\\n    // Used to avoid stack too deep error\\n    struct StackExtension {\\n        uint256 requiredSignatures;\\n        OwnerSignature ownerSignatureRequirement;\\n        bytes32 signHash;\\n        bool success;\\n        bytes returnData;\\n    }\\n\\n    event TransactionExecuted(address indexed wallet, bool indexed success, bytes returnData, bytes32 signedHash);\\n    event Refund(address indexed wallet, address indexed refundAddress, address refundToken, uint256 refundAmount);\\n\\n    // *************** Constructor ************************ //\\n\\n    constructor(address _uniswapRouter) SimpleOracle(_uniswapRouter) {\\n\\n    }\\n\\n    /* ***************** External methods ************************* */\\n\\n    /**\\n    * @notice Gets the number of valid signatures that must be provided to execute a\\n    * specific relayed transaction.\\n    * @param _wallet The target wallet.\\n    * @param _data The data of the relayed transaction.\\n    * @return The number of required signatures and the wallet owner signature requirement.\\n    */\\n    function getRequiredSignatures(address _wallet, bytes calldata _data) public view virtual returns (uint256, OwnerSignature);\\n\\n    /**\\n    * @notice Executes a relayed transaction.\\n    * @param _wallet The target wallet.\\n    * @param _data The data for the relayed transaction\\n    * @param _nonce The nonce used to prevent replay attacks.\\n    * @param _signatures The signatures as a concatenated byte array.\\n    * @param _gasPrice The max gas price (in token) to use for the gas refund.\\n    * @param _gasLimit The max gas limit to use for the gas refund.\\n    * @param _refundToken The token to use for the gas refund.\\n    * @param _refundAddress The address refunded to prevent front-running.\\n    */\\n    function execute(\\n        address _wallet,\\n        bytes calldata _data,\\n        uint256 _nonce,\\n        bytes calldata _signatures,\\n        uint256 _gasPrice,\\n        uint256 _gasLimit,\\n        address _refundToken,\\n        address _refundAddress\\n    )\\n        external\\n        returns (bool)\\n    {\\n        // initial gas = 21k + non_zero_bytes * 16 + zero_bytes * 4\\n        //            ~= 21k + calldata.length * [1/3 * 16 + 2/3 * 4]\\n        uint256 startGas = gasleft() + 21000 + msg.data.length * 8;\\n        require(startGas >= _gasLimit, \\\"RM: not enough gas provided\\\");\\n        require(verifyData(_wallet, _data), \\\"RM: Target of _data != _wallet\\\");\\n\\n        require(!_isLocked(_wallet) || _gasPrice == 0, \\\"RM: Locked wallet refund\\\");\\n\\n        StackExtension memory stack;\\n        (stack.requiredSignatures, stack.ownerSignatureRequirement) = getRequiredSignatures(_wallet, _data);\\n\\n        require(stack.requiredSignatures > 0 || stack.ownerSignatureRequirement == OwnerSignature.Anyone, \\\"RM: Wrong signature requirement\\\");\\n        require(stack.requiredSignatures * 65 == _signatures.length, \\\"RM: Wrong number of signatures\\\");\\n        stack.signHash = getSignHash(\\n            address(this),\\n            0,\\n            _data,\\n            _nonce,\\n            _gasPrice,\\n            _gasLimit,\\n            _refundToken,\\n            _refundAddress);\\n        require(checkAndUpdateUniqueness(\\n            _wallet,\\n            _nonce,\\n            stack.signHash,\\n            stack.requiredSignatures,\\n            stack.ownerSignatureRequirement), \\\"RM: Duplicate request\\\");\\n\\n        if (stack.ownerSignatureRequirement == OwnerSignature.Session) {\\n            require(validateSession(_wallet, stack.signHash, _signatures), \\\"RM: Invalid session\\\");\\n        } else {\\n            require(validateSignatures(_wallet, stack.signHash, _signatures, stack.ownerSignatureRequirement), \\\"RM: Invalid signatures\\\");\\n        }\\n        (stack.success, stack.returnData) = address(this).call(_data);\\n        refund(\\n            _wallet,\\n            startGas,\\n            _gasPrice,\\n            _gasLimit,\\n            _refundToken,\\n            _refundAddress,\\n            stack.requiredSignatures,\\n            stack.ownerSignatureRequirement);\\n        emit TransactionExecuted(_wallet, stack.success, stack.returnData, stack.signHash);\\n        return stack.success;\\n    }\\n\\n    /**\\n    * @notice Gets the current nonce for a wallet.\\n    * @param _wallet The target wallet.\\n    */\\n    function getNonce(address _wallet) external view returns (uint256 nonce) {\\n        return relayer[_wallet].nonce;\\n    }\\n\\n    /**\\n    * @notice Checks if a transaction identified by its sign hash has already been executed.\\n    * @param _wallet The target wallet.\\n    * @param _signHash The sign hash of the transaction.\\n    */\\n    function isExecutedTx(address _wallet, bytes32 _signHash) external view returns (bool executed) {\\n        return relayer[_wallet].executedTx[_signHash];\\n    }\\n\\n    /**\\n    * @notice Gets the last stored session for a wallet.\\n    * @param _wallet The target wallet.\\n    */\\n    function getSession(address _wallet) external view returns (address key, uint64 expires) {\\n        return (sessions[_wallet].key, sessions[_wallet].expires);\\n    }\\n\\n    /* ***************** Internal & Private methods ************************* */\\n\\n    /**\\n    * @notice Generates the signed hash of a relayed transaction according to ERC 1077.\\n    * @param _from The starting address for the relayed transaction (should be the relayer module)\\n    * @param _value The value for the relayed transaction.\\n    * @param _data The data for the relayed transaction which includes the wallet address.\\n    * @param _nonce The nonce used to prevent replay attacks.\\n    * @param _gasPrice The max gas price (in token) to use for the gas refund.\\n    * @param _gasLimit The max gas limit to use for the gas refund.\\n    * @param _refundToken The token to use for the gas refund.\\n    * @param _refundAddress The address refunded to prevent front-running.\\n    */\\n    function getSignHash(\\n        address _from,\\n        uint256 _value,\\n        bytes memory _data,\\n        uint256 _nonce,\\n        uint256 _gasPrice,\\n        uint256 _gasLimit,\\n        address _refundToken,\\n        address _refundAddress\\n    )\\n        internal\\n        view\\n        returns (bytes32)\\n    {\\n        return keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\n                keccak256(abi.encodePacked(\\n                    bytes1(0x19),\\n                    bytes1(0),\\n                    _from,\\n                    _value,\\n                    _data,\\n                    block.chainid,\\n                    _nonce,\\n                    _gasPrice,\\n                    _gasLimit,\\n                    _refundToken,\\n                    _refundAddress))\\n        ));\\n    }\\n\\n    /**\\n    * @notice Checks if the relayed transaction is unique. If yes the state is updated.\\n    * For actions requiring 1 signature by the owner or a session key we use the incremental nonce.\\n    * For all other actions we check/store the signHash in a mapping.\\n    * @param _wallet The target wallet.\\n    * @param _nonce The nonce.\\n    * @param _signHash The signed hash of the transaction.\\n    * @param requiredSignatures The number of signatures required.\\n    * @param ownerSignatureRequirement The wallet owner signature requirement.\\n    * @return true if the transaction is unique.\\n    */\\n    function checkAndUpdateUniqueness(\\n        address _wallet,\\n        uint256 _nonce,\\n        bytes32 _signHash,\\n        uint256 requiredSignatures,\\n        OwnerSignature ownerSignatureRequirement\\n    )\\n        internal\\n        returns (bool)\\n    {\\n        if (requiredSignatures == 1 &&\\n            (ownerSignatureRequirement == OwnerSignature.Required || ownerSignatureRequirement == OwnerSignature.Session)) {\\n            // use the incremental nonce\\n            if (_nonce <= relayer[_wallet].nonce) {\\n                return false;\\n            }\\n            uint256 nonceBlock = (_nonce & 0xffffffffffffffffffffffffffffffff00000000000000000000000000000000) >> 128;\\n            if (nonceBlock > block.number + BLOCKBOUND) {\\n                return false;\\n            }\\n            relayer[_wallet].nonce = _nonce;\\n            return true;\\n        } else {\\n            // use the txHash map\\n            if (relayer[_wallet].executedTx[_signHash] == true) {\\n                return false;\\n            }\\n            relayer[_wallet].executedTx[_signHash] = true;\\n            return true;\\n        }\\n    }\\n\\n    /**\\n    * @notice Validates the signatures provided with a relayed transaction.\\n    * @param _wallet The target wallet.\\n    * @param _signHash The signed hash representing the relayed transaction.\\n    * @param _signatures The signatures as a concatenated bytes array.\\n    * @param _option An OwnerSignature enum indicating whether the owner is required, optional or disallowed.\\n    * @return A boolean indicating whether the signatures are valid.\\n    */\\n    function validateSignatures(address _wallet, bytes32 _signHash, bytes memory _signatures, OwnerSignature _option) internal view returns (bool)\\n    {\\n        if (_signatures.length == 0) {\\n            return true;\\n        }\\n        address lastSigner = address(0);\\n        address[] memory guardians;\\n        if (_option != OwnerSignature.Required || _signatures.length > 65) {\\n            guardians = guardianStorage.getGuardians(_wallet); // guardians are only read if they may be needed\\n        }\\n        bool isGuardian;\\n\\n        for (uint256 i = 0; i < _signatures.length / 65; i++) {\\n            address signer = Utils.recoverSigner(_signHash, _signatures, i);\\n\\n            if (i == 0) {\\n                if (_option == OwnerSignature.Required) {\\n                    // First signer must be owner\\n                    if (_isOwner(_wallet, signer)) {\\n                        continue;\\n                    }\\n                    return false;\\n                } else if (_option == OwnerSignature.Optional) {\\n                    // First signer can be owner\\n                    if (_isOwner(_wallet, signer)) {\\n                        continue;\\n                    }\\n                }\\n            }\\n            if (signer <= lastSigner) {\\n                return false; // Signers must be different\\n            }\\n            lastSigner = signer;\\n            (isGuardian, guardians) = Utils.isGuardianOrGuardianSigner(guardians, signer);\\n            if (!isGuardian) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    /**\\n    * @notice Validates the signature provided when a session key was used.\\n    * @param _wallet The target wallet.\\n    * @param _signHash The signed hash representing the relayed transaction.\\n    * @param _signatures The signatures as a concatenated bytes array.\\n    * @return A boolean indicating whether the signature is valid.\\n    */\\n    function validateSession(address _wallet, bytes32 _signHash, bytes calldata _signatures) internal view returns (bool) { \\n        Session memory session = sessions[_wallet];\\n        address signer = Utils.recoverSigner(_signHash, _signatures, 0);\\n        return (signer == session.key && session.expires >= block.timestamp);\\n    }\\n\\n    /**\\n    * @notice Refunds the gas used to the Relayer.\\n    * @param _wallet The target wallet.\\n    * @param _startGas The gas provided at the start of the execution.\\n    * @param _gasPrice The max gas price (in token) for the refund.\\n    * @param _gasLimit The max gas limit for the refund.\\n    * @param _refundToken The token to use for the gas refund.\\n    * @param _refundAddress The address refunded to prevent front-running.\\n    * @param _requiredSignatures The number of signatures required.\\n    * @param _option An OwnerSignature enum indicating the signature requirement.\\n    */\\n    function refund(\\n        address _wallet,\\n        uint _startGas,\\n        uint _gasPrice,\\n        uint _gasLimit,\\n        address _refundToken,\\n        address _refundAddress,\\n        uint256 _requiredSignatures,\\n        OwnerSignature _option\\n    )\\n        internal\\n    {\\n        // Only refund when the owner is one of the signers or a session key was used\\n        if (_gasPrice > 0 && (_option == OwnerSignature.Required || _option == OwnerSignature.Session)) {\\n            address refundAddress = _refundAddress == address(0) ? msg.sender : _refundAddress;\\n            if (_requiredSignatures == 1 && _option == OwnerSignature.Required) {\\n                    // refundAddress must be whitelisted/authorised\\n                    if (!authoriser.isAuthorised(_wallet, refundAddress, address(0), EMPTY_BYTES)) {\\n                        uint whitelistAfter = userWhitelist.getWhitelist(_wallet, refundAddress);\\n                        require(whitelistAfter > 0 && whitelistAfter < block.timestamp, \\\"RM: refund not authorised\\\");\\n                    }\\n            }\\n            uint256 refundAmount;\\n            if (_refundToken == ETH_TOKEN) {\\n                // 23k as an upper bound to cover the rest of refund logic\\n                uint256 gasConsumed = _startGas - gasleft() + 23000;\\n                refundAmount = Math.min(gasConsumed, _gasLimit) * (Math.min(_gasPrice, tx.gasprice));\\n                invokeWallet(_wallet, refundAddress, refundAmount, EMPTY_BYTES);\\n            } else {\\n                // 37.5k as an upper bound to cover the rest of refund logic\\n                uint256 gasConsumed = _startGas - gasleft() + 37500;\\n                uint256 tokenGasPrice = inToken(_refundToken, tx.gasprice);\\n                refundAmount = Math.min(gasConsumed, _gasLimit) * (Math.min(_gasPrice, tokenGasPrice));\\n                bytes memory methodData = abi.encodeWithSelector(ERC20.transfer.selector, refundAddress, refundAmount);\\n                bytes memory transferSuccessBytes = invokeWallet(_wallet, _refundToken, 0, methodData);\\n                // Check token refund is successful, when `transfer` returns a success bool result\\n                if (transferSuccessBytes.length > 0) {\\n                    require(abi.decode(transferSuccessBytes, (bool)), \\\"RM: Refund transfer failed\\\");\\n                }\\n            }\\n            emit Refund(_wallet, refundAddress, _refundToken, refundAmount);    \\n        }\\n    }\\n\\n    /**\\n    * @notice Checks that the wallet address provided as the first parameter of _data matches _wallet\\n    * @return false if the addresses are different.\\n    */\\n    function verifyData(address _wallet, bytes calldata _data) internal pure returns (bool) {\\n        require(_data.length >= 36, \\\"RM: Invalid dataWallet\\\");\\n        address dataWallet = abi.decode(_data[4:], (address));\\n        return dataWallet == _wallet;\\n    }\\n}\"\r\n    },\r\n    \"/Users/Elena/Source/argent-contracts/contracts/modules/SecurityManager.sol\": {\r\n      \"content\": \"// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.3;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\nimport \\\"./common/Utils.sol\\\";\\nimport \\\"./common/BaseModule.sol\\\";\\nimport \\\"../wallet/IWallet.sol\\\";\\n\\n/**\\n * @title SecurityManager\\n * @notice Abstract module implementing the key security features of the wallet: guardians, lock and recovery.\\n * @author Julien Niset - <julien@argent.xyz>\\n * @author Olivier Van Den Biggelaar - <olivier@argent.xyz>\\n */\\nabstract contract SecurityManager is BaseModule {\\n\\n    struct RecoveryConfig {\\n        address recovery;\\n        uint64 executeAfter;\\n        uint32 guardianCount;\\n    }\\n\\n    struct GuardianManagerConfig {\\n        // The time at which a guardian addition or revokation will be confirmable by the owner\\n        mapping (bytes32 => uint256) pending;\\n    }\\n\\n    // Wallet specific storage for recovery\\n    mapping (address => RecoveryConfig) internal recoveryConfigs;\\n    // Wallet specific storage for pending guardian addition/revokation\\n    mapping (address => GuardianManagerConfig) internal guardianConfigs;\\n\\n\\n    // Recovery period\\n    uint256 internal immutable recoveryPeriod;\\n    // Lock period\\n    uint256 internal immutable lockPeriod;\\n    // The security period to add/remove guardians\\n    uint256 internal immutable securityPeriod;\\n    // The security window\\n    uint256 internal immutable securityWindow;\\n\\n    // *************** Events *************************** //\\n\\n    event RecoveryExecuted(address indexed wallet, address indexed _recovery, uint64 executeAfter);\\n    event RecoveryFinalized(address indexed wallet, address indexed _recovery);\\n    event RecoveryCanceled(address indexed wallet, address indexed _recovery);\\n    event OwnershipTransfered(address indexed wallet, address indexed _newOwner);\\n    event Locked(address indexed wallet, uint64 releaseAfter);\\n    event Unlocked(address indexed wallet);\\n    event GuardianAdditionRequested(address indexed wallet, address indexed guardian, uint256 executeAfter);\\n    event GuardianRevokationRequested(address indexed wallet, address indexed guardian, uint256 executeAfter);\\n    event GuardianAdditionCancelled(address indexed wallet, address indexed guardian);\\n    event GuardianRevokationCancelled(address indexed wallet, address indexed guardian);\\n    event GuardianAdded(address indexed wallet, address indexed guardian);\\n    event GuardianRevoked(address indexed wallet, address indexed guardian);\\n    // *************** Modifiers ************************ //\\n\\n    /**\\n     * @notice Throws if there is no ongoing recovery procedure.\\n     */\\n    modifier onlyWhenRecovery(address _wallet) {\\n        require(recoveryConfigs[_wallet].executeAfter > 0, \\\"SM: no ongoing recovery\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Throws if there is an ongoing recovery procedure.\\n     */\\n    modifier notWhenRecovery(address _wallet) {\\n        require(recoveryConfigs[_wallet].executeAfter == 0, \\\"SM: ongoing recovery\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Throws if the caller is not a guardian for the wallet or the module itself.\\n     */\\n    modifier onlyGuardianOrSelf(address _wallet) {\\n        require(_isSelf(msg.sender) || isGuardian(_wallet, msg.sender), \\\"SM: must be guardian/self\\\");\\n        _;\\n    }\\n\\n    // *************** Constructor ************************ //\\n\\n    constructor(\\n        uint256 _recoveryPeriod,\\n        uint256 _securityPeriod,\\n        uint256 _securityWindow,\\n        uint256 _lockPeriod\\n    ) {\\n        // For the wallet to be secure we must have recoveryPeriod >= securityPeriod + securityWindow\\n        // where securityPeriod and securityWindow are the security parameters of adding/removing guardians.\\n        require(_lockPeriod >= _recoveryPeriod, \\\"SM: insecure lock period\\\");\\n        require(_recoveryPeriod >= _securityPeriod + _securityWindow, \\\"SM: insecure security periods\\\");\\n        recoveryPeriod = _recoveryPeriod;\\n        lockPeriod = _lockPeriod;\\n        securityWindow = _securityWindow;\\n        securityPeriod = _securityPeriod;\\n    }\\n\\n    // *************** External functions ************************ //\\n\\n    // *************** Recovery functions ************************ //\\n\\n    /**\\n     * @notice Lets the guardians start the execution of the recovery procedure.\\n     * Once triggered the recovery is pending for the security period before it can be finalised.\\n     * Must be confirmed by N guardians, where N = ceil(Nb Guardians / 2).\\n     * @param _wallet The target wallet.\\n     * @param _recovery The address to which ownership should be transferred.\\n     */\\n    function executeRecovery(address _wallet, address _recovery) external onlySelf() notWhenRecovery(_wallet) {\\n        validateNewOwner(_wallet, _recovery);\\n        uint64 executeAfter = uint64(block.timestamp + recoveryPeriod);\\n        recoveryConfigs[_wallet] = RecoveryConfig(_recovery, executeAfter, uint32(guardianStorage.guardianCount(_wallet)));\\n        _setLock(_wallet, block.timestamp + lockPeriod, SecurityManager.executeRecovery.selector);\\n        emit RecoveryExecuted(_wallet, _recovery, executeAfter);\\n    }\\n\\n    /**\\n     * @notice Finalizes an ongoing recovery procedure if the security period is over.\\n     * The method is public and callable by anyone to enable orchestration.\\n     * @param _wallet The target wallet.\\n     */\\n    function finalizeRecovery(address _wallet) external onlyWhenRecovery(_wallet) {\\n        RecoveryConfig storage config = recoveryConfigs[_wallet];\\n        require(uint64(block.timestamp) > config.executeAfter, \\\"SM: ongoing recovery period\\\");\\n        address recoveryOwner = config.recovery;\\n        delete recoveryConfigs[_wallet];\\n\\n        _clearSession(_wallet);\\n\\n        IWallet(_wallet).setOwner(recoveryOwner);\\n        _setLock(_wallet, 0, bytes4(0));\\n\\n        emit RecoveryFinalized(_wallet, recoveryOwner);\\n    }\\n\\n    /**\\n     * @notice Lets the owner cancel an ongoing recovery procedure.\\n     * Must be confirmed by N guardians, where N = ceil(Nb Guardian at executeRecovery + 1) / 2) - 1.\\n     * @param _wallet The target wallet.\\n     */\\n    function cancelRecovery(address _wallet) external onlySelf() onlyWhenRecovery(_wallet) {\\n        address recoveryOwner = recoveryConfigs[_wallet].recovery;\\n        delete recoveryConfigs[_wallet];\\n        _setLock(_wallet, 0, bytes4(0));\\n\\n        emit RecoveryCanceled(_wallet, recoveryOwner);\\n    }\\n\\n    /**\\n     * @notice Lets the owner transfer the wallet ownership. This is executed immediately.\\n     * @param _wallet The target wallet.\\n     * @param _newOwner The address to which ownership should be transferred.\\n     */\\n    function transferOwnership(address _wallet, address _newOwner) external onlySelf() onlyWhenUnlocked(_wallet) {\\n        validateNewOwner(_wallet, _newOwner);\\n        IWallet(_wallet).setOwner(_newOwner);\\n\\n        emit OwnershipTransfered(_wallet, _newOwner);\\n    }\\n\\n    /**\\n    * @notice Gets the details of the ongoing recovery procedure if any.\\n    * @param _wallet The target wallet.\\n    */\\n    function getRecovery(address _wallet) external view returns(address _address, uint64 _executeAfter, uint32 _guardianCount) {\\n        RecoveryConfig storage config = recoveryConfigs[_wallet];\\n        return (config.recovery, config.executeAfter, config.guardianCount);\\n    }\\n\\n    // *************** Lock functions ************************ //\\n\\n    /**\\n     * @notice Lets a guardian lock a wallet.\\n     * @param _wallet The target wallet.\\n     */\\n    function lock(address _wallet) external onlyGuardianOrSelf(_wallet) onlyWhenUnlocked(_wallet) {\\n        _setLock(_wallet, block.timestamp + lockPeriod, SecurityManager.lock.selector);\\n        emit Locked(_wallet, uint64(block.timestamp + lockPeriod));\\n    }\\n\\n    /**\\n     * @notice Lets a guardian unlock a locked wallet.\\n     * @param _wallet The target wallet.\\n     */\\n    function unlock(address _wallet) external onlyGuardianOrSelf(_wallet) onlyWhenLocked(_wallet) {\\n        require(locks[_wallet].locker == SecurityManager.lock.selector, \\\"SM: cannot unlock\\\");\\n        _setLock(_wallet, 0, bytes4(0));\\n        emit Unlocked(_wallet);\\n    }\\n\\n    /**\\n     * @notice Returns the release time of a wallet lock or 0 if the wallet is unlocked.\\n     * @param _wallet The target wallet.\\n     * @return _releaseAfter The epoch time at which the lock will release (in seconds).\\n     */\\n    function getLock(address _wallet) external view returns(uint64 _releaseAfter) {\\n        return _isLocked(_wallet) ? locks[_wallet].release : 0;\\n    }\\n\\n    /**\\n     * @notice Checks if a wallet is locked.\\n     * @param _wallet The target wallet.\\n     * @return _isLocked `true` if the wallet is locked otherwise `false`.\\n     */\\n    function isLocked(address _wallet) external view returns (bool) {\\n        return _isLocked(_wallet);\\n    }\\n\\n    // *************** Guardian functions ************************ //\\n\\n    /**\\n     * @notice Lets the owner add a guardian to its wallet.\\n     * The first guardian is added immediately. All following additions must be confirmed\\n     * by calling the confirmGuardianAddition() method.\\n     * @param _wallet The target wallet.\\n     * @param _guardian The guardian to add.\\n     */\\n    function addGuardian(address _wallet, address _guardian) external onlyWalletOwnerOrSelf(_wallet) onlyWhenUnlocked(_wallet) {\\n        require(!_isOwner(_wallet, _guardian), \\\"SM: guardian cannot be owner\\\");\\n        require(!isGuardian(_wallet, _guardian), \\\"SM: duplicate guardian\\\");\\n        // Guardians must either be an EOA or a contract with an owner()\\n        // method that returns an address with a 25000 gas stipend.\\n        // Note that this test is not meant to be strict and can be bypassed by custom malicious contracts.\\n        (bool success,) = _guardian.call{gas: 25000}(abi.encodeWithSignature(\\\"owner()\\\"));\\n        require(success, \\\"SM: must be EOA/Argent wallet\\\");\\n\\n        bytes32 id = keccak256(abi.encodePacked(_wallet, _guardian, \\\"addition\\\"));\\n        GuardianManagerConfig storage config = guardianConfigs[_wallet];\\n        require(\\n            config.pending[id] == 0 || block.timestamp > config.pending[id] + securityWindow,\\n            \\\"SM: duplicate pending addition\\\");\\n        config.pending[id] = block.timestamp + securityPeriod;\\n        emit GuardianAdditionRequested(_wallet, _guardian, block.timestamp + securityPeriod);\\n    }\\n\\n    /**\\n     * @notice Confirms the pending addition of a guardian to a wallet.\\n     * The method must be called during the confirmation window and can be called by anyone to enable orchestration.\\n     * @param _wallet The target wallet.\\n     * @param _guardian The guardian.\\n     */\\n    function confirmGuardianAddition(address _wallet, address _guardian) external onlyWhenUnlocked(_wallet) {\\n        bytes32 id = keccak256(abi.encodePacked(_wallet, _guardian, \\\"addition\\\"));\\n        GuardianManagerConfig storage config = guardianConfigs[_wallet];\\n        require(config.pending[id] > 0, \\\"SM: unknown pending addition\\\");\\n        require(config.pending[id] < block.timestamp, \\\"SM: pending addition not over\\\");\\n        require(block.timestamp < config.pending[id] + securityWindow, \\\"SM: pending addition expired\\\");\\n        guardianStorage.addGuardian(_wallet, _guardian);\\n        emit GuardianAdded(_wallet, _guardian);\\n        delete config.pending[id];\\n    }\\n\\n    /**\\n     * @notice Lets the owner cancel a pending guardian addition.\\n     * @param _wallet The target wallet.\\n     * @param _guardian The guardian.\\n     */\\n    function cancelGuardianAddition(address _wallet, address _guardian) external onlyWalletOwnerOrSelf(_wallet) onlyWhenUnlocked(_wallet) {\\n        bytes32 id = keccak256(abi.encodePacked(_wallet, _guardian, \\\"addition\\\"));\\n        GuardianManagerConfig storage config = guardianConfigs[_wallet];\\n        require(config.pending[id] > 0, \\\"SM: unknown pending addition\\\");\\n        delete config.pending[id];\\n        emit GuardianAdditionCancelled(_wallet, _guardian);\\n    }\\n\\n    /**\\n     * @notice Lets the owner revoke a guardian from its wallet.\\n     * @dev Revokation must be confirmed by calling the confirmGuardianRevokation() method.\\n     * @param _wallet The target wallet.\\n     * @param _guardian The guardian to revoke.\\n     */\\n    function revokeGuardian(address _wallet, address _guardian) external onlyWalletOwnerOrSelf(_wallet) {\\n        require(isGuardian(_wallet, _guardian), \\\"SM: must be existing guardian\\\");\\n        bytes32 id = keccak256(abi.encodePacked(_wallet, _guardian, \\\"revokation\\\"));\\n        GuardianManagerConfig storage config = guardianConfigs[_wallet];\\n        require(\\n            config.pending[id] == 0 || block.timestamp > config.pending[id] + securityWindow,\\n            \\\"SM: duplicate pending revoke\\\"); // TODO need to allow if confirmation window passed\\n        config.pending[id] = block.timestamp + securityPeriod;\\n        emit GuardianRevokationRequested(_wallet, _guardian, block.timestamp + securityPeriod);\\n    }\\n\\n    /**\\n     * @notice Confirms the pending revokation of a guardian to a wallet.\\n     * The method must be called during the confirmation window and can be called by anyone to enable orchestration.\\n     * @param _wallet The target wallet.\\n     * @param _guardian The guardian.\\n     */\\n    function confirmGuardianRevokation(address _wallet, address _guardian) external {\\n        bytes32 id = keccak256(abi.encodePacked(_wallet, _guardian, \\\"revokation\\\"));\\n        GuardianManagerConfig storage config = guardianConfigs[_wallet];\\n        require(config.pending[id] > 0, \\\"SM: unknown pending revoke\\\");\\n        require(config.pending[id] < block.timestamp, \\\"SM: pending revoke not over\\\");\\n        require(block.timestamp < config.pending[id] + securityWindow, \\\"SM: pending revoke expired\\\");\\n        guardianStorage.revokeGuardian(_wallet, _guardian);\\n        emit GuardianRevoked(_wallet, _guardian);\\n        delete config.pending[id];\\n    }\\n\\n    /**\\n     * @notice Lets the owner cancel a pending guardian revokation.\\n     * @param _wallet The target wallet.\\n     * @param _guardian The guardian.\\n     */\\n    function cancelGuardianRevokation(address _wallet, address _guardian) external onlyWalletOwnerOrSelf(_wallet) onlyWhenUnlocked(_wallet) {\\n        bytes32 id = keccak256(abi.encodePacked(_wallet, _guardian, \\\"revokation\\\"));\\n        GuardianManagerConfig storage config = guardianConfigs[_wallet];\\n        require(config.pending[id] > 0, \\\"SM: unknown pending revoke\\\");\\n        delete config.pending[id];\\n        emit GuardianRevokationCancelled(_wallet, _guardian);\\n    }\\n\\n    /**\\n     * @notice Checks if an address is a guardian for a wallet.\\n     * @param _wallet The target wallet.\\n     * @param _guardian The address to check.\\n     * @return _isGuardian `true` if the address is a guardian for the wallet otherwise `false`.\\n     */\\n    function isGuardian(address _wallet, address _guardian) public view returns (bool _isGuardian) {\\n        return guardianStorage.isGuardian(_wallet, _guardian);\\n    }\\n\\n    /**\\n    * @notice Checks if an address is a guardian or an account authorised to sign on behalf of a smart-contract guardian.\\n    * @param _wallet The target wallet.\\n    * @param _guardian the address to test\\n    * @return _isGuardian `true` if the address is a guardian for the wallet otherwise `false`.\\n    */\\n    function isGuardianOrGuardianSigner(address _wallet, address _guardian) external view returns (bool _isGuardian) {\\n        (_isGuardian, ) = Utils.isGuardianOrGuardianSigner(guardianStorage.getGuardians(_wallet), _guardian);\\n    }\\n\\n    /**\\n     * @notice Counts the number of active guardians for a wallet.\\n     * @param _wallet The target wallet.\\n     * @return _count The number of active guardians for a wallet.\\n     */\\n    function guardianCount(address _wallet) external view returns (uint256 _count) {\\n        return guardianStorage.guardianCount(_wallet);\\n    }\\n\\n    /**\\n     * @notice Get the active guardians for a wallet.\\n     * @param _wallet The target wallet.\\n     * @return _guardians the active guardians for a wallet.\\n     */\\n    function getGuardians(address _wallet) external view returns (address[] memory _guardians) {\\n        return guardianStorage.getGuardians(_wallet);\\n    }\\n\\n    // *************** Internal Functions ********************* //\\n\\n    function validateNewOwner(address _wallet, address _newOwner) internal view {\\n        require(_newOwner != address(0), \\\"SM: new owner cannot be null\\\");\\n        require(!isGuardian(_wallet, _newOwner), \\\"SM: new owner cannot be guardian\\\");\\n    }\\n\\n    function _setLock(address _wallet, uint256 _releaseAfter, bytes4 _locker) internal {\\n        locks[_wallet] = Lock(SafeCast.toUint64(_releaseAfter), _locker);\\n    }\\n}\"\r\n    },\r\n    \"/Users/Elena/Source/argent-contracts/contracts/modules/TransactionManager.sol\": {\r\n      \"content\": \"// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.3;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\nimport \\\"./common/Utils.sol\\\";\\nimport \\\"./common/BaseModule.sol\\\";\\nimport \\\"../../lib_0.5/other/ERC20.sol\\\";\\n\\n/**\\n * @title TransactionManager\\n * @notice Module to execute transactions in sequence to e.g. transfer tokens (ETH, ERC20, ERC721, ERC1155) or call third-party contracts.\\n * @author Julien Niset - <julien@argent.xyz>\\n */\\nabstract contract TransactionManager is BaseModule {\\n\\n    // Static calls\\n    bytes4 private constant ERC1271_IS_VALID_SIGNATURE = bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"));\\n    bytes4 private constant ERC721_RECEIVED = bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"));\\n    bytes4 private constant ERC1155_RECEIVED = bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"));\\n    bytes4 private constant ERC1155_BATCH_RECEIVED = bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"));\\n    bytes4 private constant ERC165_INTERFACE = bytes4(keccak256(\\\"supportsInterface(bytes4)\\\"));\\n\\n    struct Call {\\n        address to;\\n        uint256 value;\\n        bytes data;\\n    }\\n\\n    // The time delay for adding a trusted contact\\n    uint256 internal immutable whitelistPeriod;\\n\\n    // *************** Events *************************** //\\n\\n    event AddedToWhitelist(address indexed wallet, address indexed target, uint64 whitelistAfter);\\n    event RemovedFromWhitelist(address indexed wallet, address indexed target);\\n    event SessionCreated(address indexed wallet, address sessionKey, uint64 expires);\\n    event SessionCleared(address indexed wallet, address sessionKey);\\n    // *************** Constructor ************************ //\\n\\n    constructor(uint256 _whitelistPeriod) {\\n        whitelistPeriod = _whitelistPeriod;\\n    }\\n\\n    // *************** External functions ************************ //\\n\\n    /**\\n     * @notice Makes the target wallet execute a sequence of transactions authorised by the wallet owner.\\n     * The method reverts if any of the inner transactions reverts.\\n     * The method reverts if any of the inner transaction is not to a trusted contact or an authorised dapp.\\n     * @param _wallet The target wallet.\\n     * @param _transactions The sequence of transactions.\\n     */\\n    function multiCall(\\n        address _wallet,\\n        Call[] calldata _transactions\\n    )\\n        external\\n        onlySelf()\\n        onlyWhenUnlocked(_wallet)\\n        returns (bytes[] memory)\\n    {\\n        bytes[] memory results = new bytes[](_transactions.length);\\n        for(uint i = 0; i < _transactions.length; i++) {\\n            address spender = Utils.recoverSpender(_transactions[i].to, _transactions[i].data);\\n            require(\\n                (_transactions[i].value == 0 || spender == _transactions[i].to) &&\\n                (isWhitelisted(_wallet, spender) || authoriser.isAuthorised(_wallet, spender, _transactions[i].to, _transactions[i].data)),\\n                \\\"TM: call not authorised\\\");\\n            results[i] = invokeWallet(_wallet, _transactions[i].to, _transactions[i].value, _transactions[i].data);\\n        }\\n        return results;\\n    }\\n\\n    /**\\n     * @notice Makes the target wallet execute a sequence of transactions authorised by a session key.\\n     * The method reverts if any of the inner transactions reverts.\\n     * @param _wallet The target wallet.\\n     * @param _transactions The sequence of transactions.\\n     */\\n    function multiCallWithSession(\\n        address _wallet,\\n        Call[] calldata _transactions\\n    )\\n        external\\n        onlySelf()\\n        onlyWhenUnlocked(_wallet)\\n        returns (bytes[] memory)\\n    {\\n        return multiCallWithApproval(_wallet, _transactions);\\n    }\\n\\n    /**\\n     * @notice Makes the target wallet execute a sequence of transactions approved by a majority of guardians.\\n     * The method reverts if any of the inner transactions reverts.\\n     * @param _wallet The target wallet.\\n     * @param _transactions The sequence of transactions.\\n     */\\n    function multiCallWithGuardians(\\n        address _wallet,\\n        Call[] calldata _transactions\\n    )\\n        external \\n        onlySelf()\\n        onlyWhenUnlocked(_wallet)\\n        returns (bytes[] memory)\\n    {\\n        return multiCallWithApproval(_wallet, _transactions);\\n    }\\n\\n    /**\\n     * @notice Makes the target wallet execute a sequence of transactions approved by a majority of guardians.\\n     * The method reverts if any of the inner transactions reverts.\\n     * Upon success a new session is started.\\n     * @param _wallet The target wallet.\\n     * @param _transactions The sequence of transactions.\\n     */\\n    function multiCallWithGuardiansAndStartSession(\\n        address _wallet,\\n        Call[] calldata _transactions,\\n        address _sessionUser,\\n        uint64 _duration\\n    )\\n        external \\n        onlySelf()\\n        onlyWhenUnlocked(_wallet)\\n        returns (bytes[] memory)\\n    {\\n        startSession(_wallet, _sessionUser, _duration);\\n        return multiCallWithApproval(_wallet, _transactions);\\n    }\\n\\n    /**\\n    * @notice Clears the active session of a wallet if any.\\n    * @param _wallet The target wallet.\\n    */\\n    function clearSession(address _wallet) external onlyWalletOwnerOrSelf(_wallet) onlyWhenUnlocked(_wallet) {\\n        emit SessionCleared(_wallet, sessions[_wallet].key);\\n        _clearSession(_wallet);\\n    }\\n\\n    /**\\n     * @notice Adds an address to the list of trusted contacts.\\n     * @param _wallet The target wallet.\\n     * @param _target The address to add.\\n     */\\n    function addToWhitelist(address _wallet, address _target) external onlyWalletOwnerOrSelf(_wallet) onlyWhenUnlocked(_wallet) {\\n        require(_target != _wallet, \\\"TM: Cannot whitelist wallet\\\");\\n        require(!registry.isRegisteredModule(_target), \\\"TM: Cannot whitelist module\\\");\\n        require(!isWhitelisted(_wallet, _target), \\\"TM: target already whitelisted\\\");\\n\\n        uint256 whitelistAfter = block.timestamp + whitelistPeriod;\\n        setWhitelist(_wallet, _target, whitelistAfter);\\n        emit AddedToWhitelist(_wallet, _target, uint64(whitelistAfter));\\n    }\\n\\n    /**\\n     * @notice Removes an address from the list of trusted contacts.\\n     * @param _wallet The target wallet.\\n     * @param _target The address to remove.\\n     */\\n    function removeFromWhitelist(address _wallet, address _target) external onlyWalletOwnerOrSelf(_wallet) onlyWhenUnlocked(_wallet) {\\n        setWhitelist(_wallet, _target, 0);\\n        emit RemovedFromWhitelist(_wallet, _target);\\n    }\\n\\n    /**\\n    * @notice Checks if an address is a trusted contact for a wallet.\\n    * @param _wallet The target wallet.\\n    * @param _target The address.\\n    * @return _isWhitelisted true if the address is a trusted contact.\\n    */\\n    function isWhitelisted(address _wallet, address _target) public view returns (bool _isWhitelisted) {\\n        uint whitelistAfter = userWhitelist.getWhitelist(_wallet, _target);\\n        return whitelistAfter > 0 && whitelistAfter < block.timestamp;\\n    }\\n    \\n    /*\\n    * @notice Enable the static calls required to make the wallet compatible with the ERC1155TokenReceiver \\n    * interface (see https://eips.ethereum.org/EIPS/eip-1155#erc-1155-token-receiver). This method only \\n    * needs to be called for wallets deployed in version lower or equal to 2.4.0 as the ERC1155 static calls\\n    * are not available by default for these versions of BaseWallet\\n    * @param _wallet The target wallet.\\n    */\\n    function enableERC1155TokenReceiver(address _wallet) external onlyWalletOwnerOrSelf(_wallet) onlyWhenUnlocked(_wallet) {\\n        IWallet(_wallet).enableStaticCall(address(this), ERC165_INTERFACE);\\n        IWallet(_wallet).enableStaticCall(address(this), ERC1155_RECEIVED);\\n        IWallet(_wallet).enableStaticCall(address(this), ERC1155_BATCH_RECEIVED);\\n    }\\n\\n    /**\\n     * @inheritdoc IModule\\n     */\\n    function supportsStaticCall(bytes4 _methodId) external pure override returns (bool _isSupported) {\\n        return _methodId == ERC1271_IS_VALID_SIGNATURE ||\\n               _methodId == ERC721_RECEIVED ||\\n               _methodId == ERC165_INTERFACE ||\\n               _methodId == ERC1155_RECEIVED ||\\n               _methodId == ERC1155_BATCH_RECEIVED;\\n    }\\n\\n    /** ******************* Callbacks ************************** */\\n\\n    /**\\n     * @notice Returns true if this contract implements the interface defined by\\n     * `interfaceId` (see https://eips.ethereum.org/EIPS/eip-165).\\n     */\\n    function supportsInterface(bytes4 _interfaceID) external pure returns (bool) {\\n        return  _interfaceID == ERC165_INTERFACE || _interfaceID == (ERC1155_RECEIVED ^ ERC1155_BATCH_RECEIVED);          \\n    }\\n\\n    /**\\n    * @notice Implementation of EIP 1271.\\n    * Should return whether the signature provided is valid for the provided data.\\n    * @param _msgHash Hash of a message signed on the behalf of address(this)\\n    * @param _signature Signature byte array associated with _msgHash\\n    */\\n    function isValidSignature(bytes32 _msgHash, bytes memory _signature) external view returns (bytes4) {\\n        require(_signature.length == 65, \\\"TM: invalid signature length\\\");\\n        address signer = Utils.recoverSigner(_msgHash, _signature, 0);\\n        require(_isOwner(msg.sender, signer), \\\"TM: Invalid signer\\\");\\n        return ERC1271_IS_VALID_SIGNATURE;\\n    }\\n\\n\\n    fallback() external {\\n        bytes4 methodId = Utils.functionPrefix(msg.data);\\n        if(methodId == ERC721_RECEIVED || methodId == ERC1155_RECEIVED || methodId == ERC1155_BATCH_RECEIVED) {\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {                \\n                calldatacopy(0, 0, 0x04)\\n                return (0, 0x20)\\n            }\\n        }\\n    }\\n\\n    // *************** Internal Functions ********************* //\\n\\n    function enableDefaultStaticCalls(address _wallet) internal {\\n        // setup the static calls that are available for free for all wallets\\n        IWallet(_wallet).enableStaticCall(address(this), ERC1271_IS_VALID_SIGNATURE);\\n        IWallet(_wallet).enableStaticCall(address(this), ERC721_RECEIVED);\\n    }\\n\\n    function multiCallWithApproval(address _wallet, Call[] calldata _transactions) internal returns (bytes[] memory) {\\n        bytes[] memory results = new bytes[](_transactions.length);\\n        for(uint i = 0; i < _transactions.length; i++) {\\n            results[i] = invokeWallet(_wallet, _transactions[i].to, _transactions[i].value, _transactions[i].data);\\n        }\\n        return results;\\n    }\\n\\n    function startSession(address _wallet, address _sessionUser, uint64 _duration) internal {\\n        require(_sessionUser != address(0), \\\"TM: Invalid session user\\\");\\n        require(_duration > 0, \\\"TM: Invalid session duration\\\");\\n\\n        uint64 expiry = SafeCast.toUint64(block.timestamp + _duration);\\n        sessions[_wallet] = Session(_sessionUser, expiry);\\n        emit SessionCreated(_wallet, _sessionUser, expiry);\\n    }\\n\\n    function setWhitelist(address _wallet, address _target, uint256 _whitelistAfter) internal {\\n        userWhitelist.setWhitelist(_wallet, _target, _whitelistAfter);\\n    }\\n}\"\r\n    },\r\n    \"/Users/Elena/Source/argent-contracts/contracts/modules/common/BaseModule.sol\": {\r\n      \"content\": \"// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.3;\\n\\nimport \\\"../../wallet/IWallet.sol\\\";\\nimport \\\"../../infrastructure/IModuleRegistry.sol\\\";\\nimport \\\"../../infrastructure/storage/IGuardianStorage.sol\\\";\\nimport \\\"../../infrastructure/IAuthoriser.sol\\\";\\nimport \\\"../../infrastructure/storage/ITransferStorage.sol\\\";\\nimport \\\"./IModule.sol\\\";\\nimport \\\"../../../lib_0.5/other/ERC20.sol\\\";\\n\\n/**\\n * @title BaseModule\\n * @notice Base Module contract that contains methods common to all Modules.\\n * @author Julien Niset - <julien@argent.xyz>, Olivier VDB - <olivier@argent.xyz>\\n */\\nabstract contract BaseModule is IModule {\\n\\n    // Empty calldata\\n    bytes constant internal EMPTY_BYTES = \\\"\\\";\\n    // Mock token address for ETH\\n    address constant internal ETH_TOKEN = address(0);\\n\\n    // The module registry\\n    IModuleRegistry internal immutable registry;\\n    // The guardians storage\\n    IGuardianStorage internal immutable guardianStorage;\\n    // The trusted contacts storage\\n    ITransferStorage internal immutable userWhitelist;\\n    // The authoriser\\n    IAuthoriser internal immutable authoriser;\\n\\n    event ModuleCreated(bytes32 name);\\n\\n    enum OwnerSignature {\\n        Anyone,             // Anyone\\n        Required,           // Owner required\\n        Optional,           // Owner and/or guardians\\n        Disallowed,         // Guardians only\\n        Session             // Session only\\n    }\\n\\n    struct Session {\\n        address key;\\n        uint64 expires;\\n    }\\n\\n    // Maps wallet to session\\n    mapping (address => Session) internal sessions;\\n\\n    struct Lock {\\n        // the lock's release timestamp\\n        uint64 release;\\n        // the signature of the method that set the last lock\\n        bytes4 locker;\\n    }\\n    \\n    // Wallet specific lock storage\\n    mapping (address => Lock) internal locks;\\n\\n    /**\\n     * @notice Throws if the wallet is not locked.\\n     */\\n    modifier onlyWhenLocked(address _wallet) {\\n        require(_isLocked(_wallet), \\\"BM: wallet must be locked\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Throws if the wallet is locked.\\n     */\\n    modifier onlyWhenUnlocked(address _wallet) {\\n        require(!_isLocked(_wallet), \\\"BM: wallet locked\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Throws if the sender is not the module itself.\\n     */\\n    modifier onlySelf() {\\n        require(_isSelf(msg.sender), \\\"BM: must be module\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Throws if the sender is not the module itself or the owner of the target wallet.\\n     */\\n    modifier onlyWalletOwnerOrSelf(address _wallet) {\\n        require(_isSelf(msg.sender) || _isOwner(_wallet, msg.sender), \\\"BM: must be wallet owner/self\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the target wallet of the call.\\n     */\\n    modifier onlyWallet(address _wallet) {\\n        require(msg.sender == _wallet, \\\"BM: caller must be wallet\\\");\\n        _;\\n    }\\n\\n    constructor(\\n        IModuleRegistry _registry,\\n        IGuardianStorage _guardianStorage,\\n        ITransferStorage _userWhitelist,\\n        IAuthoriser _authoriser,\\n        bytes32 _name\\n    ) {\\n        registry = _registry;\\n        guardianStorage = _guardianStorage;\\n        userWhitelist = _userWhitelist;\\n        authoriser = _authoriser;\\n        emit ModuleCreated(_name);\\n    }\\n\\n    /**\\n     * @notice Moves tokens that have been sent to the module by mistake.\\n     * @param _token The target token.\\n     */\\n    function recoverToken(address _token) external {\\n        uint total = ERC20(_token).balanceOf(address(this));\\n        ERC20(_token).transfer(address(registry), total);\\n    }\\n\\n    function _clearSession(address _wallet) internal {\\n        delete sessions[_wallet];\\n    }\\n    \\n    /**\\n     * @notice Helper method to check if an address is the owner of a target wallet.\\n     * @param _wallet The target wallet.\\n     * @param _addr The address.\\n     */\\n    function _isOwner(address _wallet, address _addr) internal view returns (bool) {\\n        return IWallet(_wallet).owner() == _addr;\\n    }\\n\\n    /**\\n     * @notice Helper method to check if a wallet is locked.\\n     * @param _wallet The target wallet.\\n     */\\n    function _isLocked(address _wallet) internal view returns (bool) {\\n        return locks[_wallet].release > uint64(block.timestamp);\\n    }\\n\\n    /**\\n     * @notice Helper method to check if an address is the module itself.\\n     * @param _addr The target address.\\n     */\\n    function _isSelf(address _addr) internal view returns (bool) {\\n        return _addr == address(this);\\n    }\\n\\n    /**\\n     * @notice Helper method to invoke a wallet.\\n     * @param _wallet The target wallet.\\n     * @param _to The target address for the transaction.\\n     * @param _value The value of the transaction.\\n     * @param _data The data of the transaction.\\n     */\\n    function invokeWallet(address _wallet, address _to, uint256 _value, bytes memory _data) internal returns (bytes memory _res) {\\n        bool success;\\n        (success, _res) = _wallet.call(abi.encodeWithSignature(\\\"invoke(address,uint256,bytes)\\\", _to, _value, _data));\\n        if (success && _res.length > 0) { //_res is empty if _wallet is an \\\"old\\\" BaseWallet that can't return output values\\n            (_res) = abi.decode(_res, (bytes));\\n        } else if (_res.length > 0) {\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        } else if (!success) {\\n            revert(\\\"BM: wallet invoke reverted\\\");\\n        }\\n    }\\n}\"\r\n    },\r\n    \"/Users/Elena/Source/argent-contracts/contracts/modules/common/IModule.sol\": {\r\n      \"content\": \"// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.3;\\n\\n/**\\n * @title IModule\\n * @notice Interface for a Module.\\n * @author Julien Niset - <julien@argent.xyz>, Olivier VDB - <olivier@argent.xyz>\\n */\\ninterface IModule {\\n\\n    /**\\t\\n     * @notice Adds a module to a wallet. Cannot execute when wallet is locked (or under recovery)\\t\\n     * @param _wallet The target wallet.\\t\\n     * @param _module The modules to authorise.\\t\\n     */\\t\\n    function addModule(address _wallet, address _module) external;\\n\\n    /**\\n     * @notice Inits a Module for a wallet by e.g. setting some wallet specific parameters in storage.\\n     * @param _wallet The wallet.\\n     */\\n    function init(address _wallet) external;\\n\\n\\n    /**\\n     * @notice Returns whether the module implements a callback for a given static call method.\\n     * @param _methodId The method id.\\n     */\\n    function supportsStaticCall(bytes4 _methodId) external view returns (bool _isSupported);\\n}\"\r\n    },\r\n    \"/Users/Elena/Source/argent-contracts/contracts/modules/common/SimpleOracle.sol\": {\r\n      \"content\": \"// Copyright (C) 2021  Argent Labs Ltd. <https://argent.xyz>\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.3;\\n\\nimport \\\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\\\";\\nimport \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\\\";\\n\\ncontract SimpleOracle {\\n\\n    address internal immutable weth;\\n    address internal immutable uniswapV2Factory;\\n\\n    constructor(address _uniswapRouter) {\\n        weth = IUniswapV2Router01(_uniswapRouter).WETH();\\n        uniswapV2Factory = IUniswapV2Router01(_uniswapRouter).factory();\\n    }\\n\\n    function inToken(address _token, uint256 _ethAmount) internal view returns (uint256) {\\n        (uint256 wethReserve, uint256 tokenReserve) = getReservesForTokenPool(_token);\\n        return _ethAmount * tokenReserve / wethReserve;\\n    }\\n\\n    function getReservesForTokenPool(address _token) internal view returns (uint256 wethReserve, uint256 tokenReserve) {\\n        if (weth < _token) {\\n            address pair = getPairForSorted(weth, _token);\\n            (wethReserve, tokenReserve,) = IUniswapV2Pair(pair).getReserves();\\n        } else {\\n            address pair = getPairForSorted(_token, weth);\\n            (tokenReserve, wethReserve,) = IUniswapV2Pair(pair).getReserves();\\n        }\\n        require(wethReserve != 0 && tokenReserve != 0, \\\"SO: no liquidity\\\");\\n    }\\n\\n    function getPairForSorted(address tokenA, address tokenB) internal virtual view returns (address pair) {    \\n        pair = address(uint160(uint256(keccak256(abi.encodePacked(\\n                hex'ff',\\n                uniswapV2Factory,\\n                keccak256(abi.encodePacked(tokenA, tokenB)),\\n                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f'\\n            )))));\\n    }\\n}\"\r\n    },\r\n    \"/Users/Elena/Source/argent-contracts/contracts/modules/common/Utils.sol\": {\r\n      \"content\": \"// Copyright (C) 2020  Argent Labs Ltd. <https://argent.xyz>\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.3;\\n\\n/**\\n * @title Utils\\n * @notice Common utility methods used by modules.\\n */\\nlibrary Utils {\\n\\n    // ERC20, ERC721 & ERC1155 transfers & approvals\\n    bytes4 private constant ERC20_TRANSFER = bytes4(keccak256(\\\"transfer(address,uint256)\\\"));\\n    bytes4 private constant ERC20_APPROVE = bytes4(keccak256(\\\"approve(address,uint256)\\\"));\\n    bytes4 private constant ERC721_SET_APPROVAL_FOR_ALL = bytes4(keccak256(\\\"setApprovalForAll(address,bool)\\\"));\\n    bytes4 private constant ERC721_TRANSFER_FROM = bytes4(keccak256(\\\"transferFrom(address,address,uint256)\\\"));\\n    bytes4 private constant ERC721_SAFE_TRANSFER_FROM = bytes4(keccak256(\\\"safeTransferFrom(address,address,uint256)\\\"));\\n    bytes4 private constant ERC721_SAFE_TRANSFER_FROM_BYTES = bytes4(keccak256(\\\"safeTransferFrom(address,address,uint256,bytes)\\\"));\\n    bytes4 private constant ERC1155_SAFE_TRANSFER_FROM = bytes4(keccak256(\\\"safeTransferFrom(address,address,uint256,uint256,bytes)\\\"));\\n\\n    bytes4 private constant OWNER_SIG = 0x8da5cb5b;\\n    /**\\n    * @notice Helper method to recover the signer at a given position from a list of concatenated signatures.\\n    * @param _signedHash The signed hash\\n    * @param _signatures The concatenated signatures.\\n    * @param _index The index of the signature to recover.\\n    */\\n    function recoverSigner(bytes32 _signedHash, bytes memory _signatures, uint _index) internal pure returns (address) {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n        // we jump 32 (0x20) as the first slot of bytes contains the length\\n        // we jump 65 (0x41) per signature\\n        // for v we load 32 bytes ending with v (the first 31 come from s) then apply a mask\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            r := mload(add(_signatures, add(0x20,mul(0x41,_index))))\\n            s := mload(add(_signatures, add(0x40,mul(0x41,_index))))\\n            v := and(mload(add(_signatures, add(0x41,mul(0x41,_index)))), 0xff)\\n        }\\n        require(v == 27 || v == 28, \\\"Utils: bad v value in signature\\\");\\n\\n        address recoveredAddress = ecrecover(_signedHash, v, r, s);\\n        require(recoveredAddress != address(0), \\\"Utils: ecrecover returned 0\\\");\\n        return recoveredAddress;\\n    }\\n\\n    /**\\n    * @notice Helper method to recover the spender from a contract call. \\n    * The method returns the contract unless the call is to a standard method of a ERC20/ERC721/ERC1155 token\\n    * in which case the spender is recovered from the data.\\n    * @param _to The target contract.\\n    * @param _data The data payload.\\n    */\\n    function recoverSpender(address _to, bytes memory _data) internal pure returns (address spender) {\\n        if(_data.length >= 68) {\\n            bytes4 methodId;\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                methodId := mload(add(_data, 0x20))\\n            }\\n            if(\\n                methodId == ERC20_TRANSFER ||\\n                methodId == ERC20_APPROVE ||\\n                methodId == ERC721_SET_APPROVAL_FOR_ALL) \\n            {\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    spender := mload(add(_data, 0x24))\\n                }\\n                return spender;\\n            }\\n            if(\\n                methodId == ERC721_TRANSFER_FROM ||\\n                methodId == ERC721_SAFE_TRANSFER_FROM ||\\n                methodId == ERC721_SAFE_TRANSFER_FROM_BYTES ||\\n                methodId == ERC1155_SAFE_TRANSFER_FROM)\\n            {\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    spender := mload(add(_data, 0x44))\\n                }\\n                return spender;\\n            }\\n        }\\n\\n        spender = _to;\\n    }\\n\\n    /**\\n    * @notice Helper method to parse data and extract the method signature.\\n    */\\n    function functionPrefix(bytes memory _data) internal pure returns (bytes4 prefix) {\\n        require(_data.length >= 4, \\\"Utils: Invalid functionPrefix\\\");\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            prefix := mload(add(_data, 0x20))\\n        }\\n    }\\n\\n    /**\\n    * @notice Checks if an address is a contract.\\n    * @param _addr The address.\\n    */\\n    function isContract(address _addr) internal view returns (bool) {\\n        uint32 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            size := extcodesize(_addr)\\n        }\\n        return (size > 0);\\n    }\\n\\n    /**\\n    * @notice Checks if an address is a guardian or an account authorised to sign on behalf of a smart-contract guardian\\n    * given a list of guardians.\\n    * @param _guardians the list of guardians\\n    * @param _guardian the address to test\\n    * @return true and the list of guardians minus the found guardian upon success, false and the original list of guardians if not found.\\n    */\\n    function isGuardianOrGuardianSigner(address[] memory _guardians, address _guardian) internal view returns (bool, address[] memory) {\\n        if (_guardians.length == 0 || _guardian == address(0)) {\\n            return (false, _guardians);\\n        }\\n        bool isFound = false;\\n        address[] memory updatedGuardians = new address[](_guardians.length - 1);\\n        uint256 index = 0;\\n        for (uint256 i = 0; i < _guardians.length; i++) {\\n            if (!isFound) {\\n                // check if _guardian is an account guardian\\n                if (_guardian == _guardians[i]) {\\n                    isFound = true;\\n                    continue;\\n                }\\n                // check if _guardian is the owner of a smart contract guardian\\n                if (isContract(_guardians[i]) && isGuardianOwner(_guardians[i], _guardian)) {\\n                    isFound = true;\\n                    continue;\\n                }\\n            }\\n            if (index < updatedGuardians.length) {\\n                updatedGuardians[index] = _guardians[i];\\n                index++;\\n            }\\n        }\\n        return isFound ? (true, updatedGuardians) : (false, _guardians);\\n    }\\n\\n    /**\\n    * @notice Checks if an address is the owner of a guardian contract.\\n    * The method does not revert if the call to the owner() method consumes more then 25000 gas.\\n    * @param _guardian The guardian contract\\n    * @param _owner The owner to verify.\\n    */\\n    function isGuardianOwner(address _guardian, address _owner) internal view returns (bool) {\\n        address owner = address(0);\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr,OWNER_SIG)\\n            let result := staticcall(25000, _guardian, ptr, 0x20, ptr, 0x20)\\n            if eq(result, 1) {\\n                owner := mload(ptr)\\n            }\\n        }\\n        return owner == _owner;\\n    }\\n\\n    /**\\n    * @notice Returns ceil(a / b).\\n    */\\n    function ceil(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a / b;\\n        if (a % b == 0) {\\n            return c;\\n        } else {\\n            return c + 1;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/Elena/Source/argent-contracts/contracts/wallet/IWallet.sol\": {\r\n      \"content\": \"// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity >=0.5.4 <0.9.0;\\n\\n/**\\n * @title IWallet\\n * @notice Interface for the BaseWallet\\n */\\ninterface IWallet {\\n    /**\\n     * @notice Returns the wallet owner.\\n     * @return The wallet owner address.\\n     */\\n    function owner() external view returns (address);\\n\\n    /**\\n     * @notice Returns the number of authorised modules.\\n     * @return The number of authorised modules.\\n     */\\n    function modules() external view returns (uint);\\n\\n    /**\\n     * @notice Sets a new owner for the wallet.\\n     * @param _newOwner The new owner.\\n     */\\n    function setOwner(address _newOwner) external;\\n\\n    /**\\n     * @notice Checks if a module is authorised on the wallet.\\n     * @param _module The module address to check.\\n     * @return `true` if the module is authorised, otherwise `false`.\\n     */\\n    function authorised(address _module) external view returns (bool);\\n\\n    /**\\n     * @notice Returns the module responsible for a static call redirection.\\n     * @param _sig The signature of the static call.\\n     * @return the module doing the redirection\\n     */\\n    function enabled(bytes4 _sig) external view returns (address);\\n\\n    /**\\n     * @notice Enables/Disables a module.\\n     * @param _module The target module.\\n     * @param _value Set to `true` to authorise the module.\\n     */\\n    function authoriseModule(address _module, bool _value) external;\\n\\n    /**\\n    * @notice Enables a static method by specifying the target module to which the call must be delegated.\\n    * @param _module The target module.\\n    * @param _method The static method signature.\\n    */\\n    function enableStaticCall(address _module, bytes4 _method) external;\\n}\"\r\n    },\r\n    \"/Users/Elena/Source/argent-contracts/lib_0.5/other/ERC20.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.4 <0.9.0;\\n\\n/**\\n * ERC20 contract interface.\\n */\\ninterface ERC20 {\\n    function totalSupply() external view returns (uint);\\n    function decimals() external view returns (uint);\\n    function balanceOf(address tokenOwner) external view returns (uint balance);\\n    function allowance(address tokenOwner, address spender) external view returns (uint remaining);\\n    function transfer(address to, uint tokens) external returns (bool success);\\n    function approve(address spender, uint tokens) external returns (bool success);\\n    function transferFrom(address from, address to, uint tokens) external returns (bool success);\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value < 2**128, \\\"SafeCast: value doesn\\\\'t fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value < 2**64, \\\"SafeCast: value doesn\\\\'t fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value < 2**32, \\\"SafeCast: value doesn\\\\'t fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value < 2**16, \\\"SafeCast: value doesn\\\\'t fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value < 2**8, \\\"SafeCast: value doesn\\\\'t fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128) {\\n        require(value >= -2**127 && value < 2**127, \\\"SafeCast: value doesn\\\\'t fit in 128 bits\\\");\\n        return int128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64) {\\n        require(value >= -2**63 && value < 2**63, \\\"SafeCast: value doesn\\\\'t fit in 64 bits\\\");\\n        return int64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32) {\\n        require(value >= -2**31 && value < 2**31, \\\"SafeCast: value doesn\\\\'t fit in 32 bits\\\");\\n        return int32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16) {\\n        require(value >= -2**15 && value < 2**15, \\\"SafeCast: value doesn\\\\'t fit in 16 bits\\\");\\n        return int16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8) {\\n        require(value >= -2**7 && value < 2**7, \\\"SafeCast: value doesn\\\\'t fit in 8 bits\\\");\\n        return int8(value);\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        require(value < 2**255, \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 300\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {\r\n      \"\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IModuleRegistry\",\"name\":\"_registry\",\"type\":\"address\"},{\"internalType\":\"contract IGuardianStorage\",\"name\":\"_guardianStorage\",\"type\":\"address\"},{\"internalType\":\"contract ITransferStorage\",\"name\":\"_userWhitelist\",\"type\":\"address\"},{\"internalType\":\"contract IAuthoriser\",\"name\":\"_authoriser\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_uniswapRouter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_securityPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_securityWindow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_recoveryPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lockPeriod\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"whitelistAfter\",\"type\":\"uint64\"}],\"name\":\"AddedToWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"guardian\",\"type\":\"address\"}],\"name\":\"GuardianAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"guardian\",\"type\":\"address\"}],\"name\":\"GuardianAdditionCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"guardian\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"executeAfter\",\"type\":\"uint256\"}],\"name\":\"GuardianAdditionRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"guardian\",\"type\":\"address\"}],\"name\":\"GuardianRevokationCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"guardian\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"executeAfter\",\"type\":\"uint256\"}],\"name\":\"GuardianRevokationRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"guardian\",\"type\":\"address\"}],\"name\":\"GuardianRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"releaseAfter\",\"type\":\"uint64\"}],\"name\":\"Locked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"}],\"name\":\"ModuleCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransfered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_recovery\",\"type\":\"address\"}],\"name\":\"RecoveryCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_recovery\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"executeAfter\",\"type\":\"uint64\"}],\"name\":\"RecoveryExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_recovery\",\"type\":\"address\"}],\"name\":\"RecoveryFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"refundAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"refundToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"refundAmount\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"RemovedFromWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sessionKey\",\"type\":\"address\"}],\"name\":\"SessionCleared\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sessionKey\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"expires\",\"type\":\"uint64\"}],\"name\":\"SessionCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"signedHash\",\"type\":\"bytes32\"}],\"name\":\"TransactionExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"Unlocked\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_guardian\",\"type\":\"address\"}],\"name\":\"addGuardian\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_module\",\"type\":\"address\"}],\"name\":\"addModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"addToWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_guardian\",\"type\":\"address\"}],\"name\":\"cancelGuardianAddition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_guardian\",\"type\":\"address\"}],\"name\":\"cancelGuardianRevokation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"cancelRecovery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"clearSession\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_guardian\",\"type\":\"address\"}],\"name\":\"confirmGuardianAddition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_guardian\",\"type\":\"address\"}],\"name\":\"confirmGuardianRevokation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"enableERC1155TokenReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_signatures\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_refundToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_refundAddress\",\"type\":\"address\"}],\"name\":\"execute\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recovery\",\"type\":\"address\"}],\"name\":\"executeRecovery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"finalizeRecovery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"getGuardians\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"_guardians\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"getLock\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"_releaseAfter\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"getNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"getRecovery\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_executeAfter\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"_guardianCount\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"getRequiredSignatures\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"enum BaseModule.OwnerSignature\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"getSession\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"key\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"expires\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"guardianCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_count\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_signHash\",\"type\":\"bytes32\"}],\"name\":\"isExecutedTx\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_guardian\",\"type\":\"address\"}],\"name\":\"isGuardian\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_isGuardian\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_guardian\",\"type\":\"address\"}],\"name\":\"isGuardianOrGuardianSigner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_isGuardian\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"isLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_msgHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_isWhitelisted\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct TransactionManager.Call[]\",\"name\":\"_transactions\",\"type\":\"tuple[]\"}],\"name\":\"multiCall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct TransactionManager.Call[]\",\"name\":\"_transactions\",\"type\":\"tuple[]\"}],\"name\":\"multiCallWithGuardians\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct TransactionManager.Call[]\",\"name\":\"_transactions\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"_sessionUser\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_duration\",\"type\":\"uint64\"}],\"name\":\"multiCallWithGuardiansAndStartSession\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct TransactionManager.Call[]\",\"name\":\"_transactions\",\"type\":\"tuple[]\"}],\"name\":\"multiCallWithSession\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"recoverToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"removeFromWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_guardian\",\"type\":\"address\"}],\"name\":\"revokeGuardian\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_methodId\",\"type\":\"bytes4\"}],\"name\":\"supportsStaticCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_isSupported\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"unlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ArgentModule","CompilerVersion":"v0.8.3+commit.8d00100c","OptimizationUsed":"1","Runs":"300","ConstructorArguments":"0000000000000000000000008ff41919435d50f113afd5bc25b88acf4cc3d8cc0000000000000000000000004cac0996ede3125a72be96942d299b1b26e5381b000000000000000000000000577e0b01a8538e4cb36e5f202528157f65cdf08a000000000000000000000000b5ecc8ab46e2e20573c2e57c865f7c97f58c27980000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d0000000000000000000000000000000000000000000000000000000000000e100000000000000000000000000000000000000000000000000000000000000e100000000000000000000000000000000000000000000000000000000000001c200000000000000000000000000000000000000000000000000000000000003840","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}