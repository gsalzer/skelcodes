{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/Mail/ENS_Registry.sol\": {\r\n      \"content\": \"// ███████╗░█████╗░██████╗░██████╗░███████╗██████╗░░░░███████╗██╗\\n// ╚════██║██╔══██╗██╔══██╗██╔══██╗██╔════╝██╔══██╗░░░██╔════╝██║\\n// ░░███╔═╝███████║██████╔╝██████╔╝█████╗░░██████╔╝░░░█████╗░░██║\\n// ██╔══╝░░██╔══██║██╔═══╝░██╔═══╝░██╔══╝░░██╔══██╗░░░██╔══╝░░██║\\n// ███████╗██║░░██║██║░░░░░██║░░░░░███████╗██║░░██║██╗██║░░░░░██║\\n// ╚══════╝╚═╝░░╚═╝╚═╝░░░░░╚═╝░░░░░╚══════╝╚═╝░░╚═╝╚═╝╚═╝░░░░░╚═╝\\n// Copyright (C) 2020 zapper\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 2 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n\\n///@author Zapper\\n///@notice Zapper Mail implementation, based heavily on Melon Mail from Melonport\\n// SPDX-License-Identifier: GPL-2.0\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title EnsRegistry\\n * @dev Extract of the interface for ENS Registry\\n */\\ninterface EnsRegistry {\\n    function setOwner(bytes32 _node, address _owner) external;\\n\\n    function setSubnodeOwner(\\n        bytes32 _node,\\n        bytes32 _label,\\n        address _owner\\n    ) external;\\n\\n    function setResolver(bytes32 _node, address _resolver) external;\\n\\n    function owner(bytes32 _node) external view returns (address);\\n\\n    function resolver(bytes32 _node) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/Mail/ENS_Resolver.sol\": {\r\n      \"content\": \"// ███████╗░█████╗░██████╗░██████╗░███████╗██████╗░░░░███████╗██╗\\n// ╚════██║██╔══██╗██╔══██╗██╔══██╗██╔════╝██╔══██╗░░░██╔════╝██║\\n// ░░███╔═╝███████║██████╔╝██████╔╝█████╗░░██████╔╝░░░█████╗░░██║\\n// ██╔══╝░░██╔══██║██╔═══╝░██╔═══╝░██╔══╝░░██╔══██╗░░░██╔══╝░░██║\\n// ███████╗██║░░██║██║░░░░░██║░░░░░███████╗██║░░██║██╗██║░░░░░██║\\n// ╚══════╝╚═╝░░╚═╝╚═╝░░░░░╚═╝░░░░░╚══════╝╚═╝░░╚═╝╚═╝╚═╝░░░░░╚═╝\\n// Copyright (C) 2020 zapper\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 2 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n\\n///@author Zapper\\n///@notice Zapper Mail implementation, based heavily on Melon Mail from Melonport\\n// SPDX-License-Identifier: GPL-2.0\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title EnsResolver\\n * @dev Extract of the interface for ENS Resolver\\n */\\ninterface EnsResolver {\\n    function setAddr(bytes32 _node, address _addr) external;\\n\\n    function setText(\\n        bytes32 node,\\n        string calldata key,\\n        string calldata value\\n    ) external;\\n\\n    function addr(bytes32 _node) external view returns (address);\\n\\n    function text(bytes32 node, string calldata key)\\n        external\\n        view\\n        returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/Mail/Signature_Verifier.sol\": {\r\n      \"content\": \"// ███████╗░█████╗░██████╗░██████╗░███████╗██████╗░░░░███████╗██╗\\n// ╚════██║██╔══██╗██╔══██╗██╔══██╗██╔════╝██╔══██╗░░░██╔════╝██║\\n// ░░███╔═╝███████║██████╔╝██████╔╝█████╗░░██████╔╝░░░█████╗░░██║\\n// ██╔══╝░░██╔══██║██╔═══╝░██╔═══╝░██╔══╝░░██╔══██╗░░░██╔══╝░░██║\\n// ███████╗██║░░██║██║░░░░░██║░░░░░███████╗██║░░██║██╗██║░░░░░██║\\n// ╚══════╝╚═╝░░╚═╝╚═╝░░░░░╚═╝░░░░░╚══════╝╚═╝░░╚═╝╚═╝╚═╝░░░░░╚═╝\\n// Copyright (C) 2021 zapper\\n// Copyright (c) 2018 Tasuku Nakamura\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 2 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n\\n///@author Zapper\\n///@notice This contract checks if a message has been signed by a verified signer via personal_sign.\\n// SPDX-License-Identifier: GPLv2\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../oz/0.8.0/access/Ownable.sol\\\";\\n\\ncontract SignatureVerifier is Ownable {\\n    address public signer;\\n\\n    event SignerUpdated(address indexed signer);\\n\\n    constructor(address _signer) {\\n        signer = _signer;\\n    }\\n\\n    function verify(\\n        address account,\\n        string calldata publicKey,\\n        bytes memory signature\\n    ) internal view returns (bool) {\\n        bytes32 messageHash = getMessageHash(account, publicKey);\\n        bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);\\n\\n        return recoverSigner(ethSignedMessageHash, signature) == signer;\\n    }\\n\\n    function updateSigner(address _signer) external onlyOwner {\\n        require(signer != _signer, \\\"Err: New signer should be different\\\");\\n        signer = _signer;\\n        emit SignerUpdated(_signer);\\n    }\\n\\n    function getMessageHash(address account, string calldata publicKey)\\n        public\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(abi.encodePacked(account, publicKey));\\n    }\\n\\n    function getEthSignedMessageHash(bytes32 messageHash)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\n                    messageHash\\n                )\\n            );\\n    }\\n\\n    function recoverSigner(\\n        bytes32 _ethSignedMessageHash,\\n        bytes memory _signature\\n    ) internal pure returns (address) {\\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\\n\\n        return ecrecover(_ethSignedMessageHash, v, r, s);\\n    }\\n\\n    function splitSignature(bytes memory signature)\\n        internal\\n        pure\\n        returns (\\n            bytes32 r,\\n            bytes32 s,\\n            uint8 v\\n        )\\n    {\\n        require(signature.length == 65, \\\"invalid signature length\\\");\\n\\n        assembly {\\n            r := mload(add(signature, 32))\\n            s := mload(add(signature, 64))\\n            v := byte(0, mload(add(signature, 96)))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Mail/Zapper_Mail_V1.sol\": {\r\n      \"content\": \"// ███████╗░█████╗░██████╗░██████╗░███████╗██████╗░░░░███████╗██╗\\n// ╚════██║██╔══██╗██╔══██╗██╔══██╗██╔════╝██╔══██╗░░░██╔════╝██║\\n// ░░███╔═╝███████║██████╔╝██████╔╝█████╗░░██████╔╝░░░█████╗░░██║\\n// ██╔══╝░░██╔══██║██╔═══╝░██╔═══╝░██╔══╝░░██╔══██╗░░░██╔══╝░░██║\\n// ███████╗██║░░██║██║░░░░░██║░░░░░███████╗██║░░██║██╗██║░░░░░██║\\n// ╚══════╝╚═╝░░╚═╝╚═╝░░░░░╚═╝░░░░░╚══════╝╚═╝░░╚═╝╚═╝╚═╝░░░░░╚═╝\\n// Copyright (C) 2021 zapper\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 2 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n\\n///@author Zapper\\n///@notice Zapper Mail implementation with inspiration from Melon Mail.\\n// SPDX-License-Identifier: GPL-2.0\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../oz/0.8.0/access/Ownable.sol\\\";\\nimport \\\"./Signature_Verifier.sol\\\";\\nimport \\\"./ENS_Registry.sol\\\";\\nimport \\\"./ENS_Resolver.sol\\\";\\n\\ninterface IERC20 {\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n}\\n\\ncontract Zapper_Mail_V1 is SignatureVerifier {\\n    EnsRegistry public registry;\\n    EnsResolver public resolver;\\n    bytes32 public baseNode;\\n    bool public paused = false;\\n    mapping(address => bytes32) public addressToNode;\\n\\n    event UserRegistered(\\n        bytes32 indexed baseNode,\\n        bytes32 indexed usernameHash,\\n        address indexed addr,\\n        string username,\\n        string publicKey\\n    );\\n    event UserUnregistered(\\n        bytes32 indexed baseNode,\\n        bytes32 indexed usernameHash,\\n        address indexed addr,\\n        string username\\n    );\\n    event MessageSent(\\n        bytes32 indexed baseNode,\\n        address indexed from,\\n        address indexed to,\\n        string mailHash\\n    );\\n    event RegistryUpdated(address indexed registry);\\n    event ResolverUpdated(address indexed resolver);\\n    event BaseNodeUpdated(bytes32 indexed basenode);\\n\\n    constructor(\\n        address _signer,\\n        EnsRegistry _registry,\\n        EnsResolver _resolver,\\n        bytes32 _baseNode\\n    ) SignatureVerifier(_signer) {\\n        registry = _registry;\\n        resolver = _resolver;\\n        baseNode = _baseNode;\\n    }\\n\\n    modifier pausable {\\n        if (paused) {\\n            revert(\\\"Paused\\\");\\n        } else {\\n            _;\\n        }\\n    }\\n\\n    /**\\n     * @dev Pause or unpause the mail functionality\\n     */\\n    function pause() external onlyOwner {\\n        paused = !paused;\\n    }\\n\\n    /**\\n     * @dev Transfer ownership of any domain or subdomain owned by this address\\n     * @param _node - namehash of the domain or subdomain to transfer\\n     * @param _owner - new owner for the ENS domain\\n     */\\n    function transferDomainOwnership(bytes32 _node, address _owner)\\n        external\\n        onlyOwner\\n    {\\n        registry.setOwner(_node, _owner);\\n    }\\n\\n    /**\\n     * @dev Returns the node for the subdomain specified by the username\\n     */\\n    function node(string calldata _username) public view returns (bytes32) {\\n        return\\n            keccak256(abi.encodePacked(baseNode, keccak256(bytes(_username))));\\n    }\\n\\n    /**\\n     * @dev Updates to new ENS registry.\\n     * @param _registry The address of new ENS registry to use.\\n     */\\n    function updateRegistry(EnsRegistry _registry) external onlyOwner {\\n        require(registry != _registry, \\\"Err: New registry should be different\\\");\\n        registry = _registry;\\n        emit RegistryUpdated(address(registry));\\n    }\\n\\n    /**\\n     * @dev Allows to update to new ENS resolver.\\n     * @param _resolver The address of new ENS resolver to use.\\n     */\\n    function updateResolver(EnsResolver _resolver) external onlyOwner {\\n        require(resolver != _resolver, \\\"Err: New resolver should be different\\\");\\n        resolver = _resolver;\\n        emit ResolverUpdated(address(resolver));\\n    }\\n\\n    /**\\n     * @dev Allows to update to new ENS base node.\\n     * @param _baseNode The new ENS base node to use.\\n     */\\n    function updateBaseNode(bytes32 _baseNode) external onlyOwner {\\n        require(baseNode != _baseNode, \\\"Err: New node should be different\\\");\\n        baseNode = _baseNode;\\n        emit BaseNodeUpdated(baseNode);\\n    }\\n\\n    /**\\n     * @dev Registers a username to an address, such that the address will own a subdomain of zappermail.eth\\n     * i.e.: If a user registers \\\"joe\\\", they will own \\\"joe.zappermail.eth\\\"\\n     * @param _username - Username being requested\\n     * @param _publicKey - The Zapper mail encryption public key for this username\\n     * @param _signature - Verified signature granting account the subdomain\\n     */\\n    function registerUser(\\n        string calldata _username,\\n        string calldata _publicKey,\\n        bytes calldata _signature\\n    ) external pausable {\\n        bytes32 _node = node(_username);\\n\\n        // Confirm that the signature matches that of the sender\\n        require(\\n            verify(msg.sender, _publicKey, _signature),\\n            \\\"Err: Invalid Signature\\\"\\n        );\\n\\n        // Require that the subdomain is not already owned or owned by the previous implementation (migration)\\n        require(\\n            resolver.addr(_node) == address(0) ||\\n                resolver.addr(_node) == address(this) ||\\n                resolver.addr(_node) == msg.sender, // For migrations from previous contract deployments\\n            \\\"Err: Subdomain already assigned\\\"\\n        );\\n\\n        // Require that the account does not already own a subdomain\\n        require(\\n            addressToNode[msg.sender] == \\\"\\\",\\n            \\\"Err: Account already owns a subdomain\\\"\\n        );\\n\\n        // Take ownership of the subdomain and configure it\\n        bytes32 usernameHash = keccak256(bytes(_username));\\n        registry.setSubnodeOwner(baseNode, usernameHash, address(this));\\n        registry.setResolver(_node, address(resolver));\\n        resolver.setAddr(_node, msg.sender);\\n        registry.setOwner(_node, address(this));\\n\\n        // Keep track of the associated node per account\\n        addressToNode[msg.sender] = _node;\\n\\n        // Emit event to index registration on the backend\\n        emit UserRegistered(\\n            baseNode,\\n            usernameHash,\\n            msg.sender,\\n            _username,\\n            _publicKey\\n        );\\n    }\\n\\n    function setUserData(\\n        string calldata _username,\\n        string calldata _key,\\n        string calldata _value\\n    ) external pausable {\\n        bytes32 _node = node(_username);\\n\\n        // Require that the subdomain is owned by this account\\n        require(\\n            _node == addressToNode[msg.sender] &&\\n                resolver.addr(_node) == msg.sender,\\n            \\\"Err: Subdomain not assigned to account\\\"\\n        );\\n\\n        resolver.setText(_node, _key, _value);\\n    }\\n\\n    function unregisterUser(string calldata _username) external pausable {\\n        bytes32 _node = node(_username);\\n\\n        // Require that the subdomain is owned by this account\\n        require(\\n            _node == addressToNode[msg.sender] &&\\n                resolver.addr(_node) == msg.sender,\\n            \\\"Err: Subdomain not assigned to account\\\"\\n        );\\n\\n        // Take ownership of the subdomain and configure it\\n        bytes32 usernameHash = keccak256(bytes(_username));\\n        registry.setSubnodeOwner(baseNode, usernameHash, address(this));\\n        resolver.setAddr(_node, address(0));\\n        registry.setOwner(_node, address(this));\\n\\n        // Keep track of the associated node per account\\n        addressToNode[tx.origin] = \\\"\\\";\\n\\n        // Emit event to index revocation on the backend\\n        emit UserUnregistered(baseNode, usernameHash, msg.sender, _username);\\n    }\\n\\n    /**\\n     * @dev Sends a message to a user\\n     * @param _recipient - Address of the recipient of the message\\n     * @param _hash - IPFS hash of the message\\n     */\\n    function sendMessage(address _recipient, string calldata _hash)\\n        external\\n        pausable\\n    {\\n        emit MessageSent(baseNode, tx.origin, _recipient, _hash);\\n    }\\n\\n    /**\\n     * @dev Batch sends a message to users\\n     * @param _recipients - Addresses of the recipients of the message\\n     * @param _hashes - IPFS hashes of the message\\n     */\\n    function batchSendMessage(\\n        address[] calldata _recipients,\\n        string[] calldata _hashes\\n    ) external pausable {\\n        require(\\n            _recipients.length == _hashes.length,\\n            \\\"Err: Expected same number of recipients as hashes\\\"\\n        );\\n        for (uint256 i = 0; i < _recipients.length; i++) {\\n            emit MessageSent(baseNode, tx.origin, _recipients[i], _hashes[i]);\\n        }\\n    }\\n\\n    /**\\n     * @dev Emergency withdraw if anyone sends funds to this address\\n     * @param _tokens - Addresses of the tokens (or ETH as zero address) to withdraw\\n     */\\n    function withdrawTokens(address[] calldata _tokens) external onlyOwner {\\n        for (uint256 i = 0; i < _tokens.length; i++) {\\n            if (_tokens[i] == address(0)) {\\n                payable(owner()).transfer(address(this).balance);\\n            } else {\\n                uint256 qty = IERC20(_tokens[i]).balanceOf(address(this));\\n                IERC20(_tokens[i]).transfer(owner(), qty);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/oz/0.8.0/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(\\n            newOwner != address(0),\\n            \\\"Ownable: new owner is the zero address\\\"\\n        );\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/oz/0.8.0/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"},{\"internalType\":\"contract EnsRegistry\",\"name\":\"_registry\",\"type\":\"address\"},{\"internalType\":\"contract EnsResolver\",\"name\":\"_resolver\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_baseNode\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"basenode\",\"type\":\"bytes32\"}],\"name\":\"BaseNodeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"baseNode\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"mailHash\",\"type\":\"string\"}],\"name\":\"MessageSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"registry\",\"type\":\"address\"}],\"name\":\"RegistryUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"}],\"name\":\"ResolverUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"SignerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"baseNode\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"usernameHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"username\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"publicKey\",\"type\":\"string\"}],\"name\":\"UserRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"baseNode\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"usernameHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"username\",\"type\":\"string\"}],\"name\":\"UserUnregistered\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToNode\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseNode\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_recipients\",\"type\":\"address[]\"},{\"internalType\":\"string[]\",\"name\":\"_hashes\",\"type\":\"string[]\"}],\"name\":\"batchSendMessage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"publicKey\",\"type\":\"string\"}],\"name\":\"getMessageHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_username\",\"type\":\"string\"}],\"name\":\"node\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_username\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_publicKey\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"registerUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"contract EnsRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resolver\",\"outputs\":[{\"internalType\":\"contract EnsResolver\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_hash\",\"type\":\"string\"}],\"name\":\"sendMessage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_username\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_key\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_value\",\"type\":\"string\"}],\"name\":\"setUserData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"signer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_node\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"transferDomainOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_username\",\"type\":\"string\"}],\"name\":\"unregisterUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_baseNode\",\"type\":\"bytes32\"}],\"name\":\"updateBaseNode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract EnsRegistry\",\"name\":\"_registry\",\"type\":\"address\"}],\"name\":\"updateRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract EnsResolver\",\"name\":\"_resolver\",\"type\":\"address\"}],\"name\":\"updateResolver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"}],\"name\":\"updateSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Zapper_Mail_V1","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000031d65d5d908b0c3ec294bc4a0df6260129eb609c00000000000000000000000000000000000c2e074ec69a0dfb2997ba6c7d2e1e0000000000000000000000004976fb03c32e5b8cfe2b6ccb31c09ba78ebaba41b14c7f29b6f1be833d649b38b7e1928d4f995665454ec530d7b4616f414ed025","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv2","Proxy":"0","Implementation":"","SwarmSource":""}]}