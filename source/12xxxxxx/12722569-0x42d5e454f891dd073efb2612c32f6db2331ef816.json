{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: GPL-3.0\r\n\r\n/**\r\nPublic good from https://twitter.com/0xfoobar\r\n\r\nCycle through NFTX pools until you find the ID you want\r\n\r\nSee https://github.com/NFTX-project/x-contracts-private/blob/4650f3cae4c2d776ca45effba65513c9e6ec4b6b/contracts/NFTX.sol\r\n\r\n*/\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\ninterface NFTXv7 {\r\n    function requestMint(uint256 vaultId, uint256[] memory nftIds) external payable;\r\n\r\n    // Burns a Meebit, gives you MEEBIT; see https://etherscan.io/tx/0x8d443e00c0a7b702b105cb1fbc4cafbd424a5cee756965007877a164203ee359\r\n    function mint(uint256 vaultId, uint256[] memory nftIds, uint256 d2Amount) external payable;\r\n\r\n    // Burns PUNK-BASIC, gives you a WPUNK; see https://etherscan.io/tx/0x7b30eabbcdad9a6827029ba6ffb8196fa1921f9960214b3ccc463b764b4a72ea\r\n    function redeem(uint256 vaultId, uint256 amount) external;\r\n\r\n\r\n}\r\n\r\ninterface xStore {\r\n    function xTokenAddress(uint256 vaultId) external view returns (address);\r\n    function nftAddress(uint256 vaultId) external view returns (address);\r\n}\r\n\r\ninterface IERC20 {\r\n    function transferFrom(address _from, address _to, uint256 amount) external payable;\r\n    function approve(address _spender, uint256 amount) external;\r\n}\r\n\r\ninterface IERC721 {\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n    function approve(address _spender, uint256 _tokenId) external;\r\n}\r\n\r\ninterface ERC721TokenReceiver {\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\r\n}\r\n\r\n\r\ncontract CycleNFTX is ERC721TokenReceiver {\r\n\r\n    address owner;\r\n    NFTXv7 nftx = NFTXv7(0xAf93fCce0548D3124A5fC3045adAf1ddE4e8Bf7e);\r\n    xStore store = xStore(0xBe54738723cea167a76ad5421b50cAa49692E7B7);\r\n    uint256 currentTokenId;\r\n    uint256[] desiredIds;\r\n\r\n    constructor() {\r\n        // owner = _owner;\r\n    }\r\n\r\n    // modifier onlyOwner() {\r\n    //     require(msg.sender == owner, \"Not owner\");\r\n    //     _;\r\n    // }\r\n\r\n    /**\r\n     * Precondition: have PUNK-BASIC tokens in your wallet and approve contract for transfer\r\n     * This will revert with out-of-gas unless the proper token is found, so no need to return tokens to user\r\n     * Uses 3.15M gas to do 10 iterations\r\n     * Uses 332k gas to do 1 iteration\r\n     */\r\n    function cycle(uint256 vaultId, uint256[] memory _desiredIds, uint256 maxIterations, bool acceptAny) public {\r\n        address xToken = store.xTokenAddress(vaultId); // PUNK-BASIC\r\n        address nftAddress = store.nftAddress(vaultId); // WPUNKS\r\n        uint256[] memory currentTokenIds = new uint256[](1);\r\n        desiredIds = _desiredIds;\r\n        IERC20(xToken).transferFrom(msg.sender, address(this), 1 ether);\r\n        uint iterations = 0;\r\n        while(true) {\r\n            IERC20(xToken).approve(address(nftx), 1 ether);\r\n            nftx.redeem(vaultId, 1);\r\n            if(acceptAny || isDesired(currentTokenId)) {\r\n                IERC721(nftAddress).transferFrom(address(this), msg.sender, currentTokenId);\r\n                return;\r\n            }\r\n            iterations += 1;\r\n            if(iterations >= maxIterations) {\r\n                require(false, \"Hit maximum iterations\");\r\n            }\r\n            currentTokenIds[0] = currentTokenId;\r\n            IERC721(nftAddress).approve(address(nftx), currentTokenId);\r\n            nftx.mint(vaultId, currentTokenIds, 1);\r\n        }\r\n    }\r\n\r\n    function isDesired(uint256 _tokenId) internal view returns (bool) {\r\n        for(uint i = 0; i < desiredIds.length; i++) {\r\n            if(_tokenId == desiredIds[i]) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) public override returns (bytes4) {\r\n        currentTokenId = _tokenId;\r\n        // TODO: hardcode this hash\r\n        return 0x150b7a02; //bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"));\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_desiredIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"maxIterations\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"acceptAny\",\"type\":\"bool\"}],\"name\":\"cycle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CycleNFTX","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://c94b7fe4dd4392606de1fb08b7ec19c51910e630179e3816aa8e7d39f05c783d"}]}