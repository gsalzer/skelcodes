{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.17;\r\n\r\ncontract RoyalETHBridge{\r\n    address private watcher;\r\n    event Deposit(bytes32 indexed to1,bytes32 indexed to2, uint value);\r\n    event Withdraw(address indexed to, uint value);\r\n\r\n    function RoyalETHBridge (address _watcher) public payable{\r\n        watcher = _watcher;\r\n    }\r\n    /**\r\n     * isContract\r\n     */\r\n     function isContract(address addr) internal view returns (bool) {\r\n        uint size;\r\n        assembly { size := extcodesize(addr) }\r\n        return size > 0;\r\n    }\r\n\r\n     function deposit(string  _to) public payable  {\r\n        require(!isContract(msg.sender) && msg.sender == tx.origin && msg.value > 0);\r\n        var ( result1 , result2) = toBytes(_to);\r\n        uint msgValue = msg.value;\r\n         Deposit( result1,result2, msgValue);\r\n     }\r\n\r\n    function withdraw(address _to, uint256 _value) public {\r\n         require(msg.sender == watcher && _to != address(0));\r\n         uint contractBalance = address(this).balance;\r\n           require(_value > 0 && contractBalance >= _value);\r\n         _to.transfer(_value);\r\n         Withdraw(_to, _value);\r\n    }\r\n    \r\n    function updateWatcher(address _watcher) public returns (bool){\r\n        require(msg.sender == watcher && _watcher != address(0));\r\n        watcher = _watcher;\r\n        return true;\r\n    }\r\n      /**\r\n     * convert the  address to bytes32 array \r\n     */\r\n    function toBytes(string memory  source) internal pure returns(bytes32 result1 ,bytes32 result2){\r\n       bytes memory value = bytes(source);\r\n        if (value.length == 0) {\r\n            return (0x0,0x0);\r\n        }else if(value.length <= 32){\r\n            assembly {\r\n            result1 := mload(add(source, 32))\r\n            result2 := 0x0\r\n        }\r\n        }else{\r\n            bytes memory remain = substr(value,32);\r\n            assembly {\r\n            result1 := mload(add(source, 32))\r\n            result2 := mload(add(remain, 32))\r\n        }\r\n        }\r\n         \r\n    }\r\n     /**\r\n     * sub  bytes  \r\n     */\r\n     function substr(bytes memory self, uint startIndex) internal pure returns (bytes memory) {\r\n        require(startIndex <= self.length);\r\n        uint len = self.length - startIndex;\r\n        uint addr = dataPtr(self);\r\n        return toBytes(addr + startIndex, len);\r\n    }\r\n     function dataPtr(bytes memory bts) internal pure returns (uint addr) {\r\n        assembly {\r\n            addr := add(bts, /*BYTES_HEADER_SIZE*/32)\r\n        }\r\n    }\r\n     function toBytes(uint addr, uint len) internal pure returns (bytes memory bts) {\r\n        bts = new bytes(len);\r\n        uint btsptr;\r\n        assembly {\r\n            btsptr := add(bts, /*BYTES_HEADER_SIZE*/32)\r\n        }\r\n        copy(addr, btsptr, len);\r\n    }\r\n     function copy(uint src, uint dest, uint len) internal pure {\r\n        // Copy word-length chunks while possible\r\n        for (; len >= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"string\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_watcher\",\"type\":\"address\"}],\"name\":\"updateWatcher\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_watcher\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to1\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"to2\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"}]","ContractName":"RoyalETHBridge","CompilerVersion":"v0.4.17+commit.bdeb9e52","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000779d65c484993bb23928401d26d07366929140cc","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://e93b1ff23c54fafa067e0f2e82f8fba9c2685b3de82107baa962f70ac840ff7a"}]}