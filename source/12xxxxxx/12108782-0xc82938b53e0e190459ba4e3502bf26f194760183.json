{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"sources\": {\r\n    \"IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.5;\\n\\ninterface IERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity =0.7.5;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function withdraw(uint256) external;\\n}\\n\"\r\n    },\r\n    \"SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.5;\\n\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\n\\nlibrary SafeMath {\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x + y) >= x, 'SM_ADD_OVERFLOW');\\n    }\\n\\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = sub(x, y, 'SM_SUB_UNDERFLOW');\\n    }\\n\\n    function sub(\\n        uint256 x,\\n        uint256 y,\\n        string memory message\\n    ) internal pure returns (uint256 z) {\\n        require((z = x - y) <= x, message);\\n    }\\n\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require(y == 0 || (z = x * y) / y == x, 'SM_MUL_OVERFLOW');\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, 'SM_DIV_BY_ZERO');\\n        uint256 c = a / b;\\n        return c;\\n    }\\n}\\n\"\r\n    },\r\n    \"TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.5;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TH_APPROVE_FAILED');\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TH_TRANSFER_FAILED');\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TH_TRANSFER_FROM_FAILED');\\n    }\\n\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{ value: value }(new bytes(0));\\n        require(success, 'TH_ETH_TRANSFER_FAILED');\\n    }\\n}\\n\"\r\n    },\r\n    \"TokenShares.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.5;\\n\\nimport 'IERC20.sol';\\nimport 'IWETH.sol';\\nimport 'SafeMath.sol';\\nimport 'TransferHelper.sol';\\n\\nlibrary TokenShares {\\n    using SafeMath for uint256;\\n    using TransferHelper for address;\\n\\n    event UnwrapFailed(address to, uint256 amount);\\n\\n    struct Data {\\n        mapping(address => uint256) totalShares;\\n        address weth;\\n    }\\n\\n    function setWeth(Data storage data, address _weth) internal {\\n        data.weth = _weth;\\n    }\\n\\n    function sharesToAmount(\\n        Data storage data,\\n        address token,\\n        uint256 share\\n    ) external returns (uint256) {\\n        if (share == 0) {\\n            return 0;\\n        }\\n        if (token == data.weth) {\\n            return share;\\n        }\\n        require(data.totalShares[token] >= share, 'TS_INSUFFICIENT_BALANCE');\\n        uint256 balance = IERC20(token).balanceOf(address(this));\\n        uint256 value = balance.mul(share).div(data.totalShares[token]);\\n        data.totalShares[token] = data.totalShares[token].sub(share);\\n        return value;\\n    }\\n\\n    function amountToShares(\\n        Data storage data,\\n        address token,\\n        uint256 amount,\\n        bool wrap\\n    ) external returns (uint256) {\\n        if (amount == 0) {\\n            return 0;\\n        }\\n        if (token == data.weth) {\\n            if (wrap) {\\n                require(msg.value >= amount, 'TS_INSUFFICIENT_AMOUNT');\\n                IWETH(token).deposit{ value: amount }();\\n            } else {\\n                token.safeTransferFrom(msg.sender, address(this), amount);\\n            }\\n            return amount;\\n        } else {\\n            uint256 balanceBefore = IERC20(token).balanceOf(address(this));\\n            require(balanceBefore > 0 || data.totalShares[token] == 0, 'TS_INVALID_SHARES');\\n            if (data.totalShares[token] == 0) {\\n                data.totalShares[token] = balanceBefore;\\n            }\\n            token.safeTransferFrom(msg.sender, address(this), amount);\\n            uint256 balanceAfter = IERC20(token).balanceOf(address(this));\\n            require(balanceAfter > balanceBefore, 'TS_INVALID_TRANSFER');\\n            if (balanceBefore > 0) {\\n                uint256 lastShares = data.totalShares[token];\\n                data.totalShares[token] = lastShares.mul(balanceAfter).div(balanceBefore);\\n                return data.totalShares[token] - lastShares;\\n            } else {\\n                data.totalShares[token] = balanceAfter;\\n                data.totalShares[token] = balanceAfter;\\n                return balanceAfter;\\n            }\\n        }\\n    }\\n\\n    function onUnwrapFailed(\\n        Data storage data,\\n        address to,\\n        uint256 amount\\n    ) external {\\n        emit UnwrapFailed(to, amount);\\n        IWETH(data.weth).deposit{ value: amount }();\\n        TransferHelper.safeTransfer(data.weth, to, amount);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"libraries\": {\r\n      \"IERC20.sol\": {},\r\n      \"IWETH.sol\": {},\r\n      \"SafeMath.sol\": {},\r\n      \"TransferHelper.sol\": {},\r\n      \"TokenShares.sol\": {}\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"language\": \"Solidity\"\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UnwrapFailed\",\"type\":\"event\"}]","ContractName":"TokenShares","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":""}]}