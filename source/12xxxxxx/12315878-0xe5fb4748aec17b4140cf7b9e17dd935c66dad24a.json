{"status":"1","message":"OK","result":[{"SourceCode":"{\"IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"},\"IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.2;\\n\\nimport \\\"IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``\\u0027s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\\n      *\\n      * Requirements:\\n      *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n      * - `tokenId` token must exist and be owned by `from`.\\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n      *\\n      * Emits a {Transfer} event.\\n      */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n}\\n\"},\"IERC721Enumerable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.2;\\n\\nimport \\\"IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``\\u0027s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"},\"IERC721Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.2;\\n\\nimport \\\"IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"},\"IPolyNFTLockProxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\ninterface IPolyNFTLockProxy {\\n    function managerProxyContract() external view returns (address);\\n    function proxyHashMap(uint64) external view returns (bytes memory);\\n    function assetHashMap(address, uint64) external view returns (bytes memory);\\n    function setManagerProxy(\\n        address eccmpAddr\\n    ) external;\\n    \\n    function bindProxyHash(\\n        uint64 toChainId, \\n        bytes calldata targetProxyHash\\n    ) external returns (bool);\\n\\n    function bindAssetHash(\\n        address fromAssetHash, \\n        uint64 toChainId, \\n        bytes calldata toAssetHash\\n    ) external returns (bool);\\n}\"},\"PolyNFTQuery.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.5.0;\\n\\nimport \\\"SafeMath.sol\\\";\\nimport \\\"ZeroCopySink.sol\\\";\\nimport \\\"ZeroCopySource.sol\\\";\\nimport \\\"IERC721.sol\\\";\\nimport \\\"IERC721Enumerable.sol\\\";\\nimport \\\"IERC721Metadata.sol\\\";\\nimport \\\"IPolyNFTLockProxy.sol\\\";\\n\\ncontract PolyNFTQuery {\\n    using SafeMath for uint;\\n\\n    function getAndCheckTokenUrl(address asset, address user, uint tokenId) public view returns (bool, string memory) {\\n        string memory url = \\\"\\\";\\n        address owner = IERC721(asset).ownerOf(tokenId);\\n        if (user != owner || user == address(0)) {\\n            return (false, url);\\n        }\\n\\n        url = IERC721Metadata(asset).tokenURI(tokenId);\\n        return (true, url);\\n    }\\n\\n    // getTokensByIndex index start from 0\\n    function getOwnerTokensByIndex(address asset, address owner, uint start, uint length) public view returns (bool, bytes memory) {\\n        bytes memory buff;\\n        if (length == 0 || length \\u003e 10) {\\n            return (false, buff);\\n        }\\n\\n        uint total = IERC721(asset).balanceOf(owner);\\n        if (total == 0 || start \\u003e= total) {\\n            return (false, buff);\\n        }        \\n        uint end = _calcEndIndex(start, length, total);\\n\\n        IERC721Metadata meta = IERC721Metadata(asset);\\n        IERC721Enumerable enu = IERC721Enumerable(asset);\\n        for (uint index = start; index \\u003c= end; index++) {\\n            uint tokenId = enu.tokenOfOwnerByIndex(owner, index);\\n            string memory url = meta.tokenURI(tokenId);\\n            buff = _serializeProfile(buff, tokenId, url);\\n        }\\n        return (true, buff);\\n    }\\n\\n    // getTokensByIndex index start from 0\\n    function getTokensByIds(address asset, bytes calldata args) public view returns (bool, bytes memory) {\\n        uint off = 0;\\n        uint tokenId = 0;\\n        uint length = 0;\\n        bytes memory buff;\\n\\n        (length, off) = ZeroCopySource.NextUint256(args, off);\\n        if (length == 0 || length \\u003e 10) {\\n            return (false, buff);\\n        }\\n\\n        IERC721Metadata meta = IERC721Metadata(asset);\\n        for (uint index = 0; index \\u003c length; index++) {\\n            (tokenId, off) = ZeroCopySource.NextUint256(args, off);\\n            string memory url = meta.tokenURI(tokenId);\\n            buff = _serializeProfile(buff, tokenId, url);\\n        }\\n        return (true, buff);\\n    }\\n\\n    function getFilterTokensByIndex(address asset, address ignore, uint start, uint length) public view returns (bool, bytes memory) {\\n        bytes memory buff;\\n        if (length == 0 || length \\u003e 10) {\\n            return (false, buff);\\n        }\\n\\n        IERC721Metadata meta = IERC721Metadata(asset);\\n        IERC721Enumerable enu = IERC721Enumerable(asset);\\n        IERC721 erc = IERC721(asset);\\n        \\n        uint256 total = enu.totalSupply();\\n        if (total == 0 || start \\u003e= total) {\\n            return (false, buff);\\n        }\\n\\n        uint end = _calcEndIndex(start, length, total);\\n        while(start \\u003c= end \\u0026\\u0026 end \\u003c total) {\\n            uint tokenId = enu.tokenByIndex(start);\\n            start = start + 1;\\n            address owner = erc.ownerOf(tokenId);\\n            if (owner == ignore) {\\n                end = end + 1;\\n                continue;\\n            }\\n            string memory url = meta.tokenURI(tokenId);\\n            buff = _serializeProfile(buff, tokenId, url);\\n        }\\n        return (true, buff);\\n    }\\n\\n    function _serializeProfile(bytes memory buff, uint tokenId, string memory url) internal pure returns (bytes memory) {\\n        buff = abi.encodePacked(\\n            buff,\\n            ZeroCopySink.WriteUint256(tokenId),\\n            ZeroCopySink.WriteVarBytes(bytes(url))\\n        );\\n        return buff;\\n    }\\n\\n    function _calcEndIndex(uint start, uint length, uint total) internal pure returns (uint) {\\n        uint end = start + length - 1;\\n        if (end \\u003e= total) {\\n            end = total - 1;\\n        }\\n        return end;\\n    }\\n}\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b != 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"},\"ZeroCopySink.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over encoding and serialization operation into bytes from bassic types in Solidity for PolyNetwork cross chain utility.\\n *\\n * Encode basic types in Solidity into bytes easily. It\\u0027s designed to be used \\n * for PolyNetwork cross chain application, and the encoding rules on Ethereum chain \\n * and the decoding rules on other chains should be consistent. Here we  \\n * follow the underlying serialization rule with implementation found here: \\n * https://github.com/polynetwork/poly/blob/master/common/zero_copy_sink.go\\n *\\n * Using this library instead of the unchecked serialization method can help reduce\\n * the risk of serious bugs and handfule, so it\\u0027s recommended to use it.\\n *\\n * Please note that risk can be minimized, yet not eliminated.\\n */\\nlibrary ZeroCopySink {\\n    /* @notice          Convert boolean value into bytes\\n    *  @param b         The boolean value\\n    *  @return          Converted bytes array\\n    */\\n    function WriteBool(bool b) internal pure returns (bytes memory) {\\n        bytes memory buff;\\n        assembly{\\n            buff := mload(0x40)\\n            mstore(buff, 1)\\n            switch iszero(b)\\n            case 1 {\\n                mstore(add(buff, 0x20), shl(248, 0x00))\\n                // mstore8(add(buff, 0x20), 0x00)\\n            }\\n            default {\\n                mstore(add(buff, 0x20), shl(248, 0x01))\\n                // mstore8(add(buff, 0x20), 0x01)\\n            }\\n            mstore(0x40, add(buff, 0x21))\\n        }\\n        return buff;\\n    }\\n\\n    /* @notice          Convert byte value into bytes\\n    *  @param b         The byte value\\n    *  @return          Converted bytes array\\n    */\\n    function WriteByte(byte b) internal pure returns (bytes memory) {\\n        return WriteUint8(uint8(b));\\n    }\\n\\n    /* @notice          Convert uint8 value into bytes\\n    *  @param v         The uint8 value\\n    *  @return          Converted bytes array\\n    */\\n    function WriteUint8(uint8 v) internal pure returns (bytes memory) {\\n        bytes memory buff;\\n        assembly{\\n            buff := mload(0x40)\\n            mstore(buff, 1)\\n            mstore(add(buff, 0x20), shl(248, v))\\n            // mstore(add(buff, 0x20), byte(0x1f, v))\\n            mstore(0x40, add(buff, 0x21))\\n        }\\n        return buff;\\n    }\\n\\n    /* @notice          Convert uint16 value into bytes\\n    *  @param v         The uint16 value\\n    *  @return          Converted bytes array\\n    */\\n    function WriteUint16(uint16 v) internal pure returns (bytes memory) {\\n        bytes memory buff;\\n\\n        assembly{\\n            buff := mload(0x40)\\n            let byteLen := 0x02\\n            mstore(buff, byteLen)\\n            for {\\n                let mindex := 0x00\\n                let vindex := 0x1f\\n            } lt(mindex, byteLen) {\\n                mindex := add(mindex, 0x01)\\n                vindex := sub(vindex, 0x01)\\n            }{\\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\\n            }\\n            mstore(0x40, add(buff, 0x22))\\n        }\\n        return buff;\\n    }\\n    \\n    /* @notice          Convert uint32 value into bytes\\n    *  @param v         The uint32 value\\n    *  @return          Converted bytes array\\n    */\\n    function WriteUint32(uint32 v) internal pure returns(bytes memory) {\\n        bytes memory buff;\\n        assembly{\\n            buff := mload(0x40)\\n            let byteLen := 0x04\\n            mstore(buff, byteLen)\\n            for {\\n                let mindex := 0x00\\n                let vindex := 0x1f\\n            } lt(mindex, byteLen) {\\n                mindex := add(mindex, 0x01)\\n                vindex := sub(vindex, 0x01)\\n            }{\\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\\n            }\\n            mstore(0x40, add(buff, 0x24))\\n        }\\n        return buff;\\n    }\\n\\n    /* @notice          Convert uint64 value into bytes\\n    *  @param v         The uint64 value\\n    *  @return          Converted bytes array\\n    */\\n    function WriteUint64(uint64 v) internal pure returns(bytes memory) {\\n        bytes memory buff;\\n\\n        assembly{\\n            buff := mload(0x40)\\n            let byteLen := 0x08\\n            mstore(buff, byteLen)\\n            for {\\n                let mindex := 0x00\\n                let vindex := 0x1f\\n            } lt(mindex, byteLen) {\\n                mindex := add(mindex, 0x01)\\n                vindex := sub(vindex, 0x01)\\n            }{\\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\\n            }\\n            mstore(0x40, add(buff, 0x28))\\n        }\\n        return buff;\\n    }\\n\\n    /* @notice          Convert limited uint256 value into bytes\\n    *  @param v         The uint256 value\\n    *  @return          Converted bytes array\\n    */\\n    function WriteUint255(uint256 v) internal pure returns (bytes memory) {\\n        require(v \\u003c= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \\\"Value exceeds uint255 range\\\");\\n        bytes memory buff;\\n\\n        assembly{\\n            buff := mload(0x40)\\n            let byteLen := 0x20\\n            mstore(buff, byteLen)\\n            for {\\n                let mindex := 0x00\\n                let vindex := 0x1f\\n            } lt(mindex, byteLen) {\\n                mindex := add(mindex, 0x01)\\n                vindex := sub(vindex, 0x01)\\n            }{\\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\\n            }\\n            mstore(0x40, add(buff, 0x40))\\n        }\\n        return buff;\\n    }\\n\\n    /* @notice          Convert limited uint256 value into bytes\\n    *  @param v         The uint256 value\\n    *  @return          Converted bytes array\\n    */\\n    function WriteUint256(uint256 v) internal pure returns (bytes memory) {\\n        require(v \\u003c= uint256(-1), \\\"Value exceeds uint256 range\\\");\\n        bytes memory buff;\\n\\n        assembly{\\n            buff := mload(0x40)\\n            let byteLen := 0x20\\n            mstore(buff, byteLen)\\n            for {\\n                let mindex := 0x00\\n                let vindex := 0x1f\\n            } lt(mindex, byteLen) {\\n                mindex := add(mindex, 0x01)\\n                vindex := sub(vindex, 0x01)\\n            }{\\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\\n            }\\n            mstore(0x40, add(buff, 0x40))\\n        }\\n        return buff;\\n    }\\n\\n    /* @notice          Encode bytes format data into bytes\\n    *  @param data      The bytes array data\\n    *  @return          Encoded bytes array\\n    */\\n    function WriteVarBytes(bytes memory data) internal pure returns (bytes memory) {\\n        uint64 l = uint64(data.length);\\n        return abi.encodePacked(WriteVarUint(l), data);\\n    }\\n\\n    function WriteVarUint(uint64 v) internal pure returns (bytes memory) {\\n        if (v \\u003c 0xFD){\\n    \\t\\treturn WriteUint8(uint8(v));\\n    \\t} else if (v \\u003c= 0xFFFF) {\\n    \\t\\treturn abi.encodePacked(WriteByte(0xFD), WriteUint16(uint16(v)));\\n    \\t} else if (v \\u003c= 0xFFFFFFFF) {\\n            return abi.encodePacked(WriteByte(0xFE), WriteUint32(uint32(v)));\\n    \\t} else {\\n    \\t\\treturn abi.encodePacked(WriteByte(0xFF), WriteUint64(uint64(v)));\\n    \\t}\\n    }\\n}\"},\"ZeroCopySource.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over decoding and deserialization operation from bytes into bassic types in Solidity for PolyNetwork cross chain utility.\\n *\\n * Decode into basic types in Solidity from bytes easily. It\\u0027s designed to be used \\n * for PolyNetwork cross chain application, and the decoding rules on Ethereum chain \\n * and the encoding rule on other chains should be consistent, and . Here we\\n * follow the underlying deserialization rule with implementation found here: \\n * https://github.com/polynetwork/poly/blob/master/common/zero_copy_source.go\\n *\\n * Using this library instead of the unchecked serialization method can help reduce\\n * the risk of serious bugs and handfule, so it\\u0027s recommended to use it.\\n *\\n * Please note that risk can be minimized, yet not eliminated.\\n */\\nlibrary ZeroCopySource {\\n    /* @notice              Read next byte as boolean type starting at offset from buff\\n    *  @param buff          Source bytes array\\n    *  @param offset        The position from where we read the boolean value\\n    *  @return              The the read boolean value and new offset\\n    */\\n    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\\n        require(offset + 1 \\u003c= buff.length \\u0026\\u0026 offset \\u003c offset + 1, \\\"Offset exceeds limit\\\");\\n        // byte === bytes1\\n        byte v;\\n        assembly{\\n            v := mload(add(add(buff, 0x20), offset))\\n        }\\n        bool value;\\n        if (v == 0x01) {\\n\\t\\t    value = true;\\n    \\t} else if (v == 0x00) {\\n            value = false;\\n        } else {\\n            revert(\\\"NextBool value error\\\");\\n        }\\n        return (value, offset + 1);\\n    }\\n\\n    /* @notice              Read next byte starting at offset from buff\\n    *  @param buff          Source bytes array\\n    *  @param offset        The position from where we read the byte value\\n    *  @return              The read byte value and new offset\\n    */\\n    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\\n        require(offset + 1 \\u003c= buff.length \\u0026\\u0026 offset \\u003c offset + 1, \\\"NextByte, Offset exceeds maximum\\\");\\n        byte v;\\n        assembly{\\n            v := mload(add(add(buff, 0x20), offset))\\n        }\\n        return (v, offset + 1);\\n    }\\n\\n    /* @notice              Read next byte as uint8 starting at offset from buff\\n    *  @param buff          Source bytes array\\n    *  @param offset        The position from where we read the byte value\\n    *  @return              The read uint8 value and new offset\\n    */\\n    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\\n        require(offset + 1 \\u003c= buff.length \\u0026\\u0026 offset \\u003c offset + 1, \\\"NextUint8, Offset exceeds maximum\\\");\\n        uint8 v;\\n        assembly{\\n            let tmpbytes := mload(0x40)\\n            let bvalue := mload(add(add(buff, 0x20), offset))\\n            mstore8(tmpbytes, byte(0, bvalue))\\n            mstore(0x40, add(tmpbytes, 0x01))\\n            v := mload(sub(tmpbytes, 0x1f))\\n        }\\n        return (v, offset + 1);\\n    }\\n\\n    /* @notice              Read next two bytes as uint16 type starting from offset\\n    *  @param buff          Source bytes array\\n    *  @param offset        The position from where we read the uint16 value\\n    *  @return              The read uint16 value and updated offset\\n    */\\n    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\\n        require(offset + 2 \\u003c= buff.length \\u0026\\u0026 offset \\u003c offset + 2, \\\"NextUint16, offset exceeds maximum\\\");\\n        \\n        uint16 v;\\n        assembly {\\n            let tmpbytes := mload(0x40)\\n            let bvalue := mload(add(add(buff, 0x20), offset))\\n            mstore8(tmpbytes, byte(0x01, bvalue))\\n            mstore8(add(tmpbytes, 0x01), byte(0, bvalue))\\n            mstore(0x40, add(tmpbytes, 0x02))\\n            v := mload(sub(tmpbytes, 0x1e))\\n        }\\n        return (v, offset + 2);\\n    }\\n\\n\\n    /* @notice              Read next four bytes as uint32 type starting from offset\\n    *  @param buff          Source bytes array\\n    *  @param offset        The position from where we read the uint32 value\\n    *  @return              The read uint32 value and updated offset\\n    */\\n    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\\n        require(offset + 4 \\u003c= buff.length \\u0026\\u0026 offset \\u003c offset + 4, \\\"NextUint32, offset exceeds maximum\\\");\\n        uint32 v;\\n        assembly {\\n            let tmpbytes := mload(0x40)\\n            let byteLen := 0x04\\n            for {\\n                let tindex := 0x00\\n                let bindex := sub(byteLen, 0x01)\\n                let bvalue := mload(add(add(buff, 0x20), offset))\\n            } lt(tindex, byteLen) {\\n                tindex := add(tindex, 0x01)\\n                bindex := sub(bindex, 0x01)\\n            }{\\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\\n            }\\n            mstore(0x40, add(tmpbytes, byteLen))\\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\\n        }\\n        return (v, offset + 4);\\n    }\\n\\n    /* @notice              Read next eight bytes as uint64 type starting from offset\\n    *  @param buff          Source bytes array\\n    *  @param offset        The position from where we read the uint64 value\\n    *  @return              The read uint64 value and updated offset\\n    */\\n    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\\n        require(offset + 8 \\u003c= buff.length \\u0026\\u0026 offset \\u003c offset + 8, \\\"NextUint64, offset exceeds maximum\\\");\\n        uint64 v;\\n        assembly {\\n            let tmpbytes := mload(0x40)\\n            let byteLen := 0x08\\n            for {\\n                let tindex := 0x00\\n                let bindex := sub(byteLen, 0x01)\\n                let bvalue := mload(add(add(buff, 0x20), offset))\\n            } lt(tindex, byteLen) {\\n                tindex := add(tindex, 0x01)\\n                bindex := sub(bindex, 0x01)\\n            }{\\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\\n            }\\n            mstore(0x40, add(tmpbytes, byteLen))\\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\\n        }\\n        return (v, offset + 8);\\n    }\\n\\n    /* @notice              Read next 32 bytes as uint256 type starting from offset,\\n                            there are limits considering the numerical limits in multi-chain\\n    *  @param buff          Source bytes array\\n    *  @param offset        The position from where we read the uint256 value\\n    *  @return              The read uint256 value and updated offset\\n    */\\n    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\\n        require(offset + 32 \\u003c= buff.length \\u0026\\u0026 offset \\u003c offset + 32, \\\"NextUint255, offset exceeds maximum\\\");\\n        uint256 v;\\n        assembly {\\n            let tmpbytes := mload(0x40)\\n            let byteLen := 0x20\\n            for {\\n                let tindex := 0x00\\n                let bindex := sub(byteLen, 0x01)\\n                let bvalue := mload(add(add(buff, 0x20), offset))\\n            } lt(tindex, byteLen) {\\n                tindex := add(tindex, 0x01)\\n                bindex := sub(bindex, 0x01)\\n            }{\\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\\n            }\\n            mstore(0x40, add(tmpbytes, byteLen))\\n            v := mload(tmpbytes)\\n        }\\n        require(v \\u003c= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \\\"Value exceeds the range\\\");\\n        return (v, offset + 32);\\n    }\\n\\n    function NextUint256(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\\n        require(offset + 32 \\u003c= buff.length \\u0026\\u0026 offset \\u003c offset + 32, \\\"NextUint256, offset exceeds maximum\\\");\\n        uint256 v;\\n        assembly {\\n            let tmpbytes := mload(0x40)\\n            let byteLen := 0x20\\n            for {\\n                let tindex := 0x00\\n                let bindex := sub(byteLen, 0x01)\\n                let bvalue := mload(add(add(buff, 0x20), offset))\\n            } lt(tindex, byteLen) {\\n                tindex := add(tindex, 0x01)\\n                bindex := sub(bindex, 0x01)\\n            }{\\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\\n            }\\n            mstore(0x40, add(tmpbytes, byteLen))\\n            v := mload(tmpbytes)\\n        }\\n        require(v \\u003c= uint256(-1), \\\"Value exceeds the range\\\");\\n        return (v, offset + 32);\\n    }\\n\\n    /* @notice              Read next variable bytes starting from offset,\\n                            the decoding rule coming from multi-chain\\n    *  @param buff          Source bytes array\\n    *  @param offset        The position from where we read the bytes value\\n    *  @return              The read variable bytes array value and updated offset\\n    */\\n    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\\n        uint len;\\n        (len, offset) = NextVarUint(buff, offset);\\n        require(offset + len \\u003c= buff.length \\u0026\\u0026 offset \\u003c offset + len, \\\"NextVarBytes, offset exceeds maximum\\\");\\n        bytes memory tempBytes;\\n        assembly{\\n            switch iszero(len)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don\\u0027t care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we\\u0027re done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(len, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin\\u0027s length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, len)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(buff, lengthmod), mul(0x20, iszero(lengthmod))), offset)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, len)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let\\u0027s just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return (tempBytes, offset + len);\\n    }\\n    /* @notice              Read next 32 bytes starting from offset,\\n    *  @param buff          Source bytes array\\n    *  @param offset        The position from where we read the bytes value\\n    *  @return              The read bytes32 value and updated offset\\n    */\\n    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\\n        require(offset + 32 \\u003c= buff.length \\u0026\\u0026 offset \\u003c offset + 32, \\\"NextHash, offset exceeds maximum\\\");\\n        bytes32 v;\\n        assembly {\\n            v := mload(add(buff, add(offset, 0x20)))\\n        }\\n        return (v, offset + 32);\\n    }\\n\\n    /* @notice              Read next 20 bytes starting from offset,\\n    *  @param buff          Source bytes array\\n    *  @param offset        The position from where we read the bytes value\\n    *  @return              The read bytes20 value and updated offset\\n    */\\n    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\\n        require(offset + 20 \\u003c= buff.length \\u0026\\u0026 offset \\u003c offset + 20, \\\"NextBytes20, offset exceeds maximum\\\");\\n        bytes20 v;\\n        assembly {\\n            v := mload(add(buff, add(offset, 0x20)))\\n        }\\n        return (v, offset + 20);\\n    }\\n    \\n    function NextVarUint(bytes memory buff, uint256 offset) internal pure returns(uint, uint256) {\\n        byte v;\\n        (v, offset) = NextByte(buff, offset);\\n\\n        uint value;\\n        if (v == 0xFD) {\\n            // return NextUint16(buff, offset);\\n            (value, offset) = NextUint16(buff, offset);\\n            require(value \\u003e= 0xFD \\u0026\\u0026 value \\u003c= 0xFFFF, \\\"NextUint16, value outside range\\\");\\n            return (value, offset);\\n        } else if (v == 0xFE) {\\n            // return NextUint32(buff, offset);\\n            (value, offset) = NextUint32(buff, offset);\\n            require(value \\u003e 0xFFFF \\u0026\\u0026 value \\u003c= 0xFFFFFFFF, \\\"NextVarUint, value outside range\\\");\\n            return (value, offset);\\n        } else if (v == 0xFF) {\\n            // return NextUint64(buff, offset);\\n            (value, offset) = NextUint64(buff, offset);\\n            require(value \\u003e 0xFFFFFFFF, \\\"NextVarUint, value outside range\\\");\\n            return (value, offset);\\n        } else{\\n            // return (uint8(v), offset);\\n            value = uint8(v);\\n            require(value \\u003c 0xFD, \\\"NextVarUint, value outside range\\\");\\n            return (value, offset);\\n        }\\n    }\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getAndCheckTokenUrl\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ignore\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"getFilterTokensByIndex\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"getOwnerTokensByIndex\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"args\",\"type\":\"bytes\"}],\"name\":\"getTokensByIds\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"PolyNFTQuery","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://5ac8e7d6745520d26a007790cb72497d6cfe6312c1ae356d91e6d901a90b5e61"}]}