{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity 0.8.6;\r\n\r\ninterface IERC20 {\r\n  function totalSupply() external view returns (uint);\r\n  function balanceOf(address account) external view returns (uint);\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n  function allowance(address owner, address spender) external view returns (uint);\r\n  function symbol() external view returns (string memory);\r\n  function decimals() external view returns (uint);\r\n  function approve(address spender, uint amount) external returns (bool);\r\n  function mint(address account, uint amount) external;\r\n  function burn(address account, uint amount) external;\r\n  function transferFrom(address sender, address recipient, uint amount) external returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ninterface ILPTokenMaster is IERC20 {\r\n  function initialize() external;\r\n  function transferOwnership(address newOwner) external;\r\n  function underlying() external view returns(address);\r\n  function owner() external view returns(address);\r\n  function lendingPair() external view returns(address);\r\n  function selfBurn(uint _amount) external;\r\n}\r\n\r\ninterface ILendingPair {\r\n  function checkAccountHealth(address _account) external view;\r\n  function accrueAccount(address _account) external;\r\n  function accrue() external;\r\n  function accountHealth(address _account) external view returns(uint);\r\n  function totalDebt(address _token) external view returns(uint);\r\n  function tokenA() external view returns(address);\r\n  function tokenB() external view returns(address);\r\n  function lpToken(address _token) external view returns(IERC20);\r\n  function debtOf(address _account, address _token) external view returns(uint);\r\n  function pendingDebtTotal(address _token) external view returns(uint);\r\n  function pendingSupplyTotal(address _token) external view returns(uint);\r\n  function deposit(address _token, uint _amount) external;\r\n  function withdraw(address _token, uint _amount) external;\r\n  function borrow(address _token, uint _amount) external;\r\n  function repay(address _token, uint _amount) external;\r\n  function withdrawBorrow(address _token, uint _amount) external;\r\n  function controller() external view returns(IController);\r\n\r\n  function borrowBalance(\r\n    address _account,\r\n    address _borrowedToken,\r\n    address _returnToken\r\n  ) external view returns(uint);\r\n\r\n  function convertTokenValues(\r\n    address _fromToken,\r\n    address _toToken,\r\n    uint    _inputAmount\r\n  ) external view returns(uint);\r\n}\r\n\r\ninterface IInterestRateModel {\r\n  function systemRate(ILendingPair _pair, address _token) external view returns(uint);\r\n  function supplyRatePerBlock(ILendingPair _pair, address _token) external view returns(uint);\r\n  function borrowRatePerBlock(ILendingPair _pair, address _token) external view returns(uint);\r\n}\r\n\r\ninterface IController {\r\n  function interestRateModel() external view returns(IInterestRateModel);\r\n  function rewardDistribution() external view returns(IRewardDistribution);\r\n  function feeRecipient() external view returns(address);\r\n  function LIQ_MIN_HEALTH() external view returns(uint);\r\n  function minBorrowUSD() external view returns(uint);\r\n  function liqFeeSystem(address _token) external view returns(uint);\r\n  function liqFeeCaller(address _token) external view returns(uint);\r\n  function liqFeesTotal(address _token) external view returns(uint);\r\n  function colFactor(address _token) external view returns(uint);\r\n  function depositLimit(address _lendingPair, address _token) external view returns(uint);\r\n  function borrowLimit(address _lendingPair, address _token) external view returns(uint);\r\n  function originFee(address _token) external view returns(uint);\r\n  function depositsEnabled() external view returns(bool);\r\n  function borrowingEnabled() external view returns(bool);\r\n  function setFeeRecipient(address _feeRecipient) external;\r\n  function tokenPrice(address _token) external view returns(uint);\r\n  function tokenSupported(address _token) external view returns(bool);\r\n}\r\n\r\ninterface IRewardDistribution {\r\n  function distributeReward(address _account, address _token) external;\r\n}\r\n\r\ninterface IWETH {\r\n  function deposit() external payable;\r\n  function withdraw(uint wad) external;\r\n  function balanceOf(address account) external view returns (uint);\r\n  function transfer(address recipient, uint amount) external returns (bool);\r\n  function approve(address spender, uint amount) external returns (bool);\r\n}\r\n\r\nlibrary Math {\r\n\r\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // (a + b) / 2 can overflow, so we distribute.\r\n    return (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2);\r\n  }\r\n\r\n  function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // (a + b - 1) / b can overflow on addition, so we distribute.\r\n    return a / b + (a % b == 0 ? 0 : 1);\r\n  }\r\n}\r\n\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nlibrary Clones {\r\n    /**\r\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `master`.\r\n     *\r\n     * This function uses the create opcode, which should never revert.\r\n     */\r\n    function clone(address master) internal returns (address instance) {\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(ptr, 0x14), shl(0x60, master))\r\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n            instance := create(0, ptr, 0x37)\r\n        }\r\n        require(instance != address(0), \"ERC1167: create failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `master`.\r\n     *\r\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\r\n     * the clone. Using the same `master` and `salt` multiple time will revert, since\r\n     * the clones cannot be deployed twice at the same address.\r\n     */\r\n    function cloneDeterministic(address master, bytes32 salt) internal returns (address instance) {\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(ptr, 0x14), shl(0x60, master))\r\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n            instance := create2(0, ptr, 0x37, salt)\r\n        }\r\n        require(instance != address(0), \"ERC1167: create2 failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\r\n     */\r\n    function predictDeterministicAddress(address master, bytes32 salt, address deployer) internal pure returns (address predicted) {\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(ptr, 0x14), shl(0x60, master))\r\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\r\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\r\n            mstore(add(ptr, 0x4c), salt)\r\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\r\n            predicted := keccak256(add(ptr, 0x37), 0x55)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\r\n     */\r\n    function predictDeterministicAddress(address master, bytes32 salt) internal view returns (address predicted) {\r\n        return predictDeterministicAddress(master, salt, address(this));\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n            uint256 newAllowance = oldAllowance - value;\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n\r\n  address public owner;\r\n  address public pendingOwner;\r\n\r\n  event OwnershipTransferInitiated(address indexed previousOwner, address indexed newOwner);\r\n  event OwnershipTransferConfirmed(address indexed previousOwner, address indexed newOwner);\r\n\r\n  constructor() {\r\n    owner = msg.sender;\r\n    emit OwnershipTransferConfirmed(address(0), owner);\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(isOwner(), \"Ownable: caller is not the owner\");\r\n    _;\r\n  }\r\n\r\n  function isOwner() public view returns (bool) {\r\n    return msg.sender == owner;\r\n  }\r\n\r\n  function transferOwnership(address _newOwner) external onlyOwner {\r\n    require(_newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n    emit OwnershipTransferInitiated(owner, _newOwner);\r\n    pendingOwner = _newOwner;\r\n  }\r\n\r\n  function acceptOwnership() external {\r\n    require(msg.sender == pendingOwner, \"Ownable: caller is not pending owner\");\r\n    emit OwnershipTransferConfirmed(owner, pendingOwner);\r\n    owner = pendingOwner;\r\n    pendingOwner = address(0);\r\n  }\r\n}\r\n\r\ncontract ERC20 is Ownable {\r\n\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n\r\n  mapping (address => uint) public balanceOf;\r\n  mapping (address => mapping (address => uint)) public allowance;\r\n\r\n  string public name;\r\n  string public symbol;\r\n  uint8 public immutable decimals;\r\n  uint public totalSupply;\r\n\r\n  constructor(\r\n    string memory _name,\r\n    string memory _symbol,\r\n    uint8 _decimals\r\n  ) {\r\n    name = _name;\r\n    symbol = _symbol;\r\n    decimals = _decimals;\r\n    require(_decimals > 0, \"decimals\");\r\n  }\r\n\r\n  function transfer(address _recipient, uint _amount) external returns (bool) {\r\n    _transfer(msg.sender, _recipient, _amount);\r\n    return true;\r\n  }\r\n\r\n  function approve(address _spender, uint _amount) external returns (bool) {\r\n    _approve(msg.sender, _spender, _amount);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address _sender, address _recipient, uint _amount) external returns (bool) {\r\n    require(allowance[_sender][msg.sender] >= _amount, \"ERC20: insufficient approval\");\r\n    _transfer(_sender, _recipient, _amount);\r\n    _approve(_sender, msg.sender, allowance[_sender][msg.sender] - _amount);\r\n    return true;\r\n  }\r\n\r\n  function mint(address _account, uint _amount) external onlyOwner {\r\n    _mint(_account, _amount);\r\n  }\r\n\r\n  function burn(address _account, uint _amount) external onlyOwner {\r\n    _burn(_account, _amount);\r\n  }\r\n\r\n  function _transfer(address _sender, address _recipient, uint _amount) internal {\r\n    require(_sender != address(0), \"ERC20: transfer from the zero address\");\r\n    require(_recipient != address(0), \"ERC20: transfer to the zero address\");\r\n    require(balanceOf[_sender] >= _amount, \"ERC20: insufficient funds\");\r\n\r\n    balanceOf[_sender] -= _amount;\r\n    balanceOf[_recipient] += _amount;\r\n    emit Transfer(_sender, _recipient, _amount);\r\n  }\r\n\r\n  function _mint(address _account, uint _amount) internal {\r\n    require(_account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n    totalSupply += _amount;\r\n    balanceOf[_account] += _amount;\r\n    emit Transfer(address(0), _account, _amount);\r\n  }\r\n\r\n  function _burn(address _account, uint _amount) internal {\r\n    require(_account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n    balanceOf[_account] -= _amount;\r\n    totalSupply -= _amount;\r\n    emit Transfer(_account, address(0), _amount);\r\n  }\r\n\r\n  function _approve(address _owner, address _spender, uint _amount) internal {\r\n    require(_owner != address(0), \"ERC20: approve from the zero address\");\r\n    require(_spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n    allowance[_owner][_spender] = _amount;\r\n    emit Approval(_owner, _spender, _amount);\r\n  }\r\n}\r\n\r\ncontract ReentrancyGuard {\r\n  uint256 private constant _NOT_ENTERED = 1;\r\n  uint256 private constant _ENTERED = 2;\r\n\r\n  uint256 private _status;\r\n\r\n  constructor () {\r\n    _status = _NOT_ENTERED;\r\n  }\r\n\r\n  modifier nonReentrant() {\r\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n    _status = _ENTERED;\r\n    _;\r\n    _status = _NOT_ENTERED;\r\n  }\r\n}\r\n\r\ncontract TransferHelper {\r\n\r\n  using SafeERC20 for IERC20;\r\n\r\n  // Mainnet\r\n  IWETH internal constant WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\r\n\r\n  // Kovan\r\n  // IWETH internal constant WETH = IWETH(0xd0A1E359811322d97991E03f863a0C30C2cF029C);\r\n\r\n  function _safeTransferFrom(address _token, address _sender, uint _amount) internal virtual {\r\n    require(_amount > 0, \"TransferHelper: amount must be > 0\");\r\n    IERC20(_token).safeTransferFrom(_sender, address(this), _amount);\r\n  }\r\n\r\n  function _safeTransfer(address _token, address _recipient, uint _amount) internal virtual {\r\n    require(_amount > 0, \"TransferHelper: amount must be > 0\");\r\n    IERC20(_token).safeTransfer(_recipient, _amount);\r\n  }\r\n\r\n  function _wethWithdrawTo(address _to, uint _amount) internal virtual {\r\n    require(_amount > 0, \"TransferHelper: amount must be > 0\");\r\n    require(_to != address(0), \"TransferHelper: invalid recipient\");\r\n\r\n    WETH.withdraw(_amount);\r\n    (bool success, ) = _to.call { value: _amount }(new bytes(0));\r\n    require(success, 'TransferHelper: ETH transfer failed');\r\n  }\r\n\r\n  function _depositWeth() internal {\r\n    require(msg.value > 0, \"TransferHelper: amount must be > 0\");\r\n    WETH.deposit { value: msg.value }();\r\n  }\r\n}\r\n\r\ncontract LendingPair is TransferHelper, ReentrancyGuard {\r\n\r\n  // Prevents division by zero and other undesirable behaviour\r\n  uint private constant MIN_RESERVE = 1000;\r\n\r\n  using Address for address;\r\n  using Clones for address;\r\n\r\n  mapping (address => mapping (address => uint)) public debtOf;\r\n  mapping (address => mapping (address => uint)) public accountInterestSnapshot;\r\n  mapping (address => uint) public cumulativeInterestRate; // 100e18 = 100%\r\n  mapping (address => uint) public totalDebt;\r\n  mapping (address => IERC20) public lpToken;\r\n\r\n  IController public controller;\r\n  address public tokenA;\r\n  address public tokenB;\r\n  uint public lastBlockAccrued;\r\n\r\n  event Liquidation(\r\n    address indexed account,\r\n    address indexed repayToken,\r\n    address indexed supplyToken,\r\n    uint repayAmount,\r\n    uint supplyAmount\r\n  );\r\n\r\n  event Deposit(address indexed account, address indexed token, uint amount);\r\n  event Withdraw(address indexed token, uint amount);\r\n  event Borrow(address indexed token, uint amount);\r\n  event Repay(address indexed account, address indexed token, uint amount);\r\n\r\n  receive() external payable {}\r\n\r\n  function initialize(\r\n    address _lpTokenMaster,\r\n    address _controller,\r\n    IERC20 _tokenA,\r\n    IERC20 _tokenB\r\n  ) external {\r\n    require(address(tokenA) == address(0), \"LendingPair: already initialized\");\r\n    require(address(_tokenA) != address(0) && address(_tokenB) != address(0), \"LendingPair: cannot be ZERO address\");\r\n\r\n    controller = IController(_controller);\r\n    tokenA = address(_tokenA);\r\n    tokenB = address(_tokenB);\r\n    lastBlockAccrued = block.number;\r\n\r\n    lpToken[tokenA] = _createLpToken(_lpTokenMaster);\r\n    lpToken[tokenB] = _createLpToken(_lpTokenMaster);\r\n  }\r\n\r\n  function depositRepay(address _account, address _token, uint _amount) external nonReentrant {\r\n    _validateToken(_token);\r\n    accrueAccount(_account);\r\n\r\n    _depositRepay(_account, _token, _amount);\r\n    _safeTransferFrom(_token, msg.sender, _amount);\r\n  }\r\n\r\n  function depositRepayETH(address _account) external payable nonReentrant {\r\n    _validateToken(address(WETH));\r\n    accrueAccount(_account);\r\n\r\n    _depositRepay(_account, address(WETH), msg.value);\r\n    _depositWeth();\r\n  }\r\n\r\n  function deposit(address _account, address _token, uint _amount) external nonReentrant {\r\n    _validateToken(_token);\r\n    accrueAccount(_account);\r\n\r\n    _deposit(_account, _token, _amount);\r\n    _safeTransferFrom(_token, msg.sender, _amount);\r\n  }\r\n\r\n  function withdrawBorrow(address _token, uint _amount) external nonReentrant {\r\n    _validateToken(_token);\r\n    accrueAccount(msg.sender);\r\n\r\n    _withdrawBorrow(_token, _amount);\r\n    _safeTransfer(_token, msg.sender, _amount);\r\n  }\r\n\r\n  function withdrawBorrowETH(uint _amount) external nonReentrant {\r\n    _validateToken(address(WETH));\r\n    accrueAccount(msg.sender);\r\n\r\n    _withdrawBorrow(address(WETH), _amount);\r\n    _wethWithdrawTo(msg.sender, _amount);\r\n  }\r\n\r\n  function withdraw(address _token, uint _amount) external nonReentrant {\r\n    _validateToken(_token);\r\n    accrueAccount(msg.sender);\r\n\r\n    _withdraw(_token, _amount);\r\n    _safeTransfer(_token, msg.sender, _amount);\r\n  }\r\n\r\n  function withdrawAll(address _token) external nonReentrant {\r\n    _validateToken(_token);\r\n    accrueAccount(msg.sender);\r\n\r\n    uint amount = lpToken[_token].balanceOf(msg.sender);\r\n    _withdraw(_token, amount);\r\n    _safeTransfer(_token, msg.sender, amount);\r\n  }\r\n\r\n  function withdrawAllETH() external nonReentrant {\r\n    _validateToken(address(WETH));\r\n    accrueAccount(msg.sender);\r\n\r\n    uint amount = lpToken[address(WETH)].balanceOf(msg.sender);\r\n    _withdraw(address(WETH), amount);\r\n    _wethWithdrawTo(msg.sender, amount);\r\n  }\r\n\r\n  function borrow(address _token, uint _amount) external nonReentrant {\r\n    _validateToken(_token);\r\n    accrueAccount(msg.sender);\r\n\r\n    _borrow(_token, _amount);\r\n    _safeTransfer(_token, msg.sender, _amount);\r\n  }\r\n\r\n  function repayAll(address _account, address _token) external nonReentrant {\r\n    _validateToken(_token);\r\n    _requireAccountNotAccrued(_token, _account);\r\n    accrueAccount(_account);\r\n\r\n    uint amount = debtOf[_token][_account];\r\n    _repay(_account, _token, amount);\r\n    _safeTransferFrom(_token, msg.sender, amount);\r\n  }\r\n\r\n  function repayAllETH(address _account) external payable nonReentrant {\r\n    _validateToken(address(WETH));\r\n    _requireAccountNotAccrued(address(WETH), _account);\r\n    accrueAccount(_account);\r\n\r\n    uint amount = debtOf[address(WETH)][_account];\r\n    require(msg.value >= amount, \"LendingPair: insufficient ETH deposit\");\r\n\r\n    _depositWeth();\r\n    _repay(_account, address(WETH), amount);\r\n    uint refundAmount = msg.value > amount ? (msg.value - amount) : 0;\r\n\r\n    if (refundAmount > 0) {\r\n      _wethWithdrawTo(msg.sender, refundAmount);\r\n    }\r\n  }\r\n\r\n  function repay(address _account, address _token, uint _amount) external nonReentrant {\r\n    _validateToken(_token);\r\n    accrueAccount(_account);\r\n\r\n    _repay(_account, _token, _amount);\r\n    _safeTransferFrom(_token, msg.sender, _amount);\r\n  }\r\n\r\n  function accrue() public {\r\n    if (lastBlockAccrued < block.number) {\r\n      _accrueInterest(tokenA);\r\n      _accrueInterest(tokenB);\r\n      lastBlockAccrued = block.number;\r\n    }\r\n  }\r\n\r\n  function accrueAccount(address _account) public {\r\n    _distributeReward(_account);\r\n    accrue();\r\n    _accrueAccountInterest(_account);\r\n\r\n    if (_account != feeRecipient()) {\r\n      _accrueAccountInterest(feeRecipient());\r\n    }\r\n  }\r\n\r\n  // Sell collateral to reduce debt and increase accountHealth\r\n  // Set _repayAmount to uint(-1) to repay all debt, inc. pending interest\r\n  function liquidateAccount(\r\n    address _account,\r\n    address _repayToken,\r\n    uint    _repayAmount,\r\n    uint    _minSupplyOutput\r\n  ) external nonReentrant {\r\n\r\n    // Input validation and adjustments\r\n\r\n    _validateToken(_repayToken);\r\n    address supplyToken = _repayToken == tokenA ? tokenB : tokenA;\r\n\r\n    // Check account is underwater after interest\r\n\r\n    accrueAccount(_account);\r\n    uint health = accountHealth(_account);\r\n    require(health < controller.LIQ_MIN_HEALTH(), \"LendingPair: account health < LIQ_MIN_HEALTH\");\r\n\r\n    // Calculate balance adjustments\r\n\r\n    _repayAmount = Math.min(_repayAmount, debtOf[_repayToken][_account]);\r\n\r\n    uint supplyDebt   = _convertTokenValues(_repayToken, supplyToken, _repayAmount);\r\n    uint callerFee    = supplyDebt * controller.liqFeeCaller(_repayToken) / 100e18;\r\n    uint systemFee    = supplyDebt * controller.liqFeeSystem(_repayToken) / 100e18;\r\n    uint supplyBurn   = supplyDebt + callerFee + systemFee;\r\n    uint supplyOutput = supplyDebt + callerFee;\r\n\r\n    require(supplyOutput >= _minSupplyOutput, \"LendingPair: supplyOutput >= _minSupplyOutput\");\r\n\r\n    // Adjust balances\r\n\r\n    _burnSupply(supplyToken, _account, supplyBurn);\r\n    _mintSupply(supplyToken, feeRecipient(), systemFee);\r\n    _burnDebt(_repayToken, _account, _repayAmount);\r\n\r\n    // Settle token transfers\r\n\r\n    _safeTransferFrom(_repayToken, msg.sender, _repayAmount);\r\n    _mintSupply(supplyToken, msg.sender, supplyOutput);\r\n\r\n    emit Liquidation(_account, _repayToken, supplyToken, _repayAmount, supplyOutput);\r\n  }\r\n\r\n  function accountHealth(address _account) public view returns(uint) {\r\n\r\n    if (debtOf[tokenA][_account] == 0 && debtOf[tokenB][_account] == 0) {\r\n      return controller.LIQ_MIN_HEALTH();\r\n    }\r\n\r\n    uint totalAccountSupply  = _supplyCredit(_account, tokenA, tokenA)  + _supplyCredit(_account, tokenB, tokenA);\r\n    uint totalAccountBorrow = _borrowBalance(_account, tokenA, tokenA) + _borrowBalance(_account, tokenB, tokenA);\r\n\r\n    return totalAccountSupply * 1e18 / totalAccountBorrow;\r\n  }\r\n\r\n  // Get borow balance converted to the units of _returnToken\r\n  function borrowBalance(\r\n    address _account,\r\n    address _borrowedToken,\r\n    address _returnToken\r\n  ) external view returns(uint) {\r\n\r\n    _validateToken(_borrowedToken);\r\n    _validateToken(_returnToken);\r\n\r\n    return _borrowBalance(_account, _borrowedToken, _returnToken);\r\n  }\r\n\r\n  function supplyBalance(\r\n    address _account,\r\n    address _suppliedToken,\r\n    address _returnToken\r\n  ) external view returns(uint) {\r\n\r\n    _validateToken(_suppliedToken);\r\n    _validateToken(_returnToken);\r\n\r\n    return _supplyBalance(_account, _suppliedToken, _returnToken);\r\n  }\r\n\r\n  function supplyRatePerBlock(address _token) external view returns(uint) {\r\n    _validateToken(_token);\r\n    return controller.interestRateModel().supplyRatePerBlock(ILendingPair(address(this)), _token);\r\n  }\r\n\r\n  function borrowRatePerBlock(address _token) external view returns(uint) {\r\n    _validateToken(_token);\r\n    return _borrowRatePerBlock(_token);\r\n  }\r\n\r\n  function pendingSupplyInterest(address _token, address _account) external view returns(uint) {\r\n    _validateToken(_token);\r\n    uint newInterest = _newInterest(lpToken[_token].balanceOf(_account), _token, _account);\r\n    return newInterest * _lpRate(_token) / 100e18;\r\n  }\r\n\r\n  function pendingBorrowInterest(address _token, address _account) external view returns(uint) {\r\n    _validateToken(_token);\r\n    return _pendingBorrowInterest(_token, _account);\r\n  }\r\n\r\n  function feeRecipient() public view returns(address) {\r\n    return controller.feeRecipient();\r\n  }\r\n\r\n  function checkAccountHealth(address _account) public view  {\r\n    uint health = accountHealth(_account);\r\n    require(health >= controller.LIQ_MIN_HEALTH(), \"LendingPair: insufficient accountHealth\");\r\n  }\r\n\r\n  function convertTokenValues(\r\n    address _fromToken,\r\n    address _toToken,\r\n    uint    _inputAmount\r\n  ) external view returns(uint) {\r\n\r\n    _validateToken(_fromToken);\r\n    _validateToken(_toToken);\r\n\r\n    return _convertTokenValues(_fromToken, _toToken, _inputAmount);\r\n  }\r\n\r\n  function _depositRepay(address _account, address _token, uint _amount) internal {\r\n\r\n    uint debt = debtOf[_token][_account];\r\n    uint repayAmount = debt > _amount ? _amount : debt;\r\n\r\n    if (repayAmount > 0) {\r\n      _repay(_account, _token, repayAmount);\r\n    }\r\n\r\n    uint depositAmount = _amount - repayAmount;\r\n\r\n    if (depositAmount > 0) {\r\n      _deposit(_account, _token, depositAmount);\r\n    }\r\n  }\r\n\r\n  function _withdrawBorrow(address _token, uint _amount) internal {\r\n\r\n    uint supplyAmount = lpToken[_token].balanceOf(msg.sender);\r\n    uint withdrawAmount = supplyAmount > _amount ? _amount : supplyAmount;\r\n\r\n    if (withdrawAmount > 0) {\r\n      _withdraw(_token, withdrawAmount);\r\n    }\r\n\r\n    uint borrowAmount = _amount - withdrawAmount;\r\n\r\n    if (borrowAmount > 0) {\r\n      _borrow(_token, borrowAmount);\r\n    }\r\n  }\r\n\r\n  function _distributeReward(address _account) internal {\r\n    IRewardDistribution rewardDistribution = controller.rewardDistribution();\r\n\r\n    if (\r\n      address(rewardDistribution) != address(0) &&\r\n      _account != feeRecipient()\r\n    ) {\r\n      rewardDistribution.distributeReward(_account, tokenA);\r\n      rewardDistribution.distributeReward(_account, tokenB);\r\n    }\r\n  }\r\n\r\n  function _mintSupply(address _token, address _account, uint _amount) internal {\r\n    if (_amount > 0) {\r\n      lpToken[_token].mint(_account, _amount);\r\n    }\r\n  }\r\n\r\n  function _burnSupply(address _token, address _account, uint _amount) internal {\r\n    if (_amount > 0) {\r\n      lpToken[_token].burn(_account, _amount);\r\n    }\r\n  }\r\n\r\n  function _mintDebt(address _token, address _account, uint _amount) internal {\r\n    debtOf[_token][_account] += _amount;\r\n    totalDebt[_token] += _amount;\r\n  }\r\n\r\n  // Origination fee is earned entirely by the protocol and is not split with the LPs\r\n  // The goal is to prevent free flash loans\r\n  function _mintDebtWithOriginFee(address _token, address _account, uint _amount) internal {\r\n    uint originFee = _originationFee(_token, _amount);\r\n    _mintSupply(_token, feeRecipient(), originFee);\r\n    _mintDebt(_token, _account, _amount + originFee);\r\n  }\r\n\r\n  function _burnDebt(address _token, address _account, uint _amount) internal {\r\n    debtOf[_token][_account] -= _amount;\r\n    totalDebt[_token] -= _amount;\r\n  }\r\n\r\n  function _accrueAccountInterest(address _account) internal {\r\n    uint lpBalanceA = lpToken[tokenA].balanceOf(_account);\r\n    uint lpBalanceB = lpToken[tokenB].balanceOf(_account);\r\n\r\n    _accrueAccountSupply(tokenA, lpBalanceA, _account);\r\n    _accrueAccountSupply(tokenB, lpBalanceB, _account);\r\n    _accrueAccountDebt(tokenA, _account);\r\n    _accrueAccountDebt(tokenB, _account);\r\n\r\n    accountInterestSnapshot[tokenA][_account] = cumulativeInterestRate[tokenA];\r\n    accountInterestSnapshot[tokenB][_account] = cumulativeInterestRate[tokenB];\r\n  }\r\n\r\n  function _accrueAccountSupply(address _token, uint _amount, address _account) internal {\r\n    if (_amount > 0) {\r\n      uint supplyInterest   = _newInterest(_amount, _token, _account);\r\n      uint newSupplyAccount = supplyInterest * _lpRate(_token) / 100e18;\r\n      uint newSupplySystem  = supplyInterest * _systemRate(_token) / 100e18;\r\n\r\n      _mintSupply(_token, _account, newSupplyAccount);\r\n      _mintSupply(_token, feeRecipient(), newSupplySystem);\r\n    }\r\n  }\r\n\r\n  function _accrueAccountDebt(address _token, address _account) internal {\r\n    if (debtOf[_token][_account] > 0) {\r\n      uint newDebt = _pendingBorrowInterest(_token, _account);\r\n      _mintDebt(_token, _account, newDebt);\r\n    }\r\n  }\r\n\r\n  function _withdraw(address _token, uint _amount) internal {\r\n\r\n    lpToken[_token].burn(msg.sender, _amount);\r\n\r\n    checkAccountHealth(msg.sender);\r\n\r\n    emit Withdraw(_token, _amount);\r\n  }\r\n\r\n  function _borrow(address _token, uint _amount) internal {\r\n\r\n    require(lpToken[_token].balanceOf(msg.sender) == 0, \"LendingPair: cannot borrow supplied token\");\r\n\r\n    _mintDebtWithOriginFee(_token, msg.sender, _amount);\r\n\r\n    _checkBorrowLimits(_token, msg.sender);\r\n    checkAccountHealth(msg.sender);\r\n\r\n    emit Borrow(_token, _amount);\r\n  }\r\n\r\n  function _repay(address _account, address _token, uint _amount) internal {\r\n    _burnDebt(_token, _account, _amount);\r\n    emit Repay(_account, _token, _amount);\r\n  }\r\n\r\n  function _deposit(address _account, address _token, uint _amount) internal {\r\n\r\n    _checkOracleSupport(tokenA);\r\n    _checkOracleSupport(tokenB);\r\n\r\n    require(debtOf[_token][_account] == 0, \"LendingPair: cannot deposit borrowed token\");\r\n\r\n    _mintSupply(_token, _account, _amount);\r\n    _checkDepositLimit(_token);\r\n\r\n    emit Deposit(_account, _token, _amount);\r\n  }\r\n\r\n  function _accrueInterest(address _token) internal {\r\n    cumulativeInterestRate[_token] += _pendingInterestRate(_token);\r\n  }\r\n\r\n  function _pendingInterestRate(address _token) internal view returns(uint) {\r\n    uint blocksElapsed = block.number - lastBlockAccrued;\r\n    return _borrowRatePerBlock(_token) * blocksElapsed;\r\n  }\r\n\r\n  function _createLpToken(address _lpTokenMaster) internal returns(IERC20) {\r\n    ILPTokenMaster newLPToken = ILPTokenMaster(_lpTokenMaster.clone());\r\n    newLPToken.initialize();\r\n    return IERC20(newLPToken);\r\n  }\r\n\r\n  function _safeTransfer(address _token, address _recipient, uint _amount) internal override {\r\n    TransferHelper._safeTransfer(_token, _recipient, _amount);\r\n    _checkMinReserve(address(_token));\r\n  }\r\n\r\n  function _wethWithdrawTo(address _to, uint _amount) internal override {\r\n    TransferHelper._wethWithdrawTo(_to, _amount);\r\n    _checkMinReserve(address(WETH));\r\n  }\r\n\r\n  function _borrowRatePerBlock(address _token) internal view returns(uint) {\r\n    return controller.interestRateModel().borrowRatePerBlock(ILendingPair(address(this)), _token);\r\n  }\r\n\r\n  function _pendingBorrowInterest(address _token, address _account) internal view returns(uint) {\r\n    return _newInterest(debtOf[_token][_account], _token, _account);\r\n  }\r\n\r\n  function _borrowBalance(\r\n    address _account,\r\n    address _borrowedToken,\r\n    address _returnToken\r\n  ) internal view returns(uint) {\r\n\r\n    return _convertTokenValues(_borrowedToken, _returnToken, debtOf[_borrowedToken][_account]);\r\n  }\r\n\r\n  // Get supply balance converted to the units of _returnToken\r\n  function _supplyBalance(\r\n    address _account,\r\n    address _suppliedToken,\r\n    address _returnToken\r\n  ) internal view returns(uint) {\r\n\r\n    return _convertTokenValues(_suppliedToken, _returnToken, lpToken[_suppliedToken].balanceOf(_account));\r\n  }\r\n\r\n  function _supplyCredit(\r\n    address _account,\r\n    address _suppliedToken,\r\n    address _returnToken\r\n  ) internal view returns(uint) {\r\n\r\n    return _supplyBalance(_account, _suppliedToken, _returnToken) * controller.colFactor(_suppliedToken) / 100e18;\r\n  }\r\n\r\n  function _convertTokenValues(\r\n    address _fromToken,\r\n    address _toToken,\r\n    uint    _inputAmount\r\n  ) internal view returns(uint) {\r\n\r\n    uint priceFrom = controller.tokenPrice(_fromToken) * 1e18 / 10 ** IERC20(_fromToken).decimals();\r\n    uint priceTo   = controller.tokenPrice(_toToken)   * 1e18 / 10 ** IERC20(_toToken).decimals();\r\n\r\n    return _inputAmount * priceFrom / priceTo;\r\n  }\r\n\r\n  function _validateToken(address _token) internal view {\r\n    require(_token == tokenA || _token == tokenB, \"LendingPair: invalid token\");\r\n  }\r\n\r\n  function _checkOracleSupport(address _token) internal view {\r\n    require(controller.tokenSupported(_token), \"LendingPair: token not supported\");\r\n  }\r\n\r\n  function _checkMinReserve(address _token) internal view {\r\n    require(IERC20(_token).balanceOf(address(this)) >= MIN_RESERVE, \"LendingPair: below MIN_RESERVE\");\r\n  }\r\n\r\n  function _checkDepositLimit(address _token) internal view {\r\n    require(controller.depositsEnabled(), \"LendingPair: deposits disabled\");\r\n\r\n    uint depositLimit = controller.depositLimit(address(this), _token);\r\n\r\n    if (depositLimit > 0) {\r\n      require((lpToken[_token].totalSupply()) <= depositLimit, \"LendingPair: deposit limit reached\");\r\n    }\r\n  }\r\n\r\n  function _checkBorrowLimits(address _token, address _account) internal view {\r\n    require(controller.borrowingEnabled(), \"LendingPair: borrowing disabled\");\r\n\r\n    uint accountBorrowUSD = debtOf[_token][_account] * controller.tokenPrice(_token) / 1e18;\r\n    require(accountBorrowUSD >= controller.minBorrowUSD(), \"LendingPair: borrow amount below minimum\");\r\n\r\n    uint borrowLimit = controller.borrowLimit(address(this), _token);\r\n\r\n    if (borrowLimit > 0) {\r\n      require(totalDebt[_token] <= borrowLimit, \"LendingPair: borrow limit reached\");\r\n    }\r\n  }\r\n\r\n  function _originationFee(address _token, uint _amount) internal view returns(uint) {\r\n    return _amount * controller.originFee(_token) / 100e18;\r\n  }\r\n\r\n  function _systemRate(address _token) internal view returns(uint) {\r\n    return controller.interestRateModel().systemRate(ILendingPair(address(this)), _token);\r\n  }\r\n\r\n  function _lpRate(address _token) internal view returns(uint) {\r\n    return 100e18 - _systemRate(_token);\r\n  }\r\n\r\n  function _newInterest(uint _balance, address _token, address _account) internal view returns(uint) {\r\n    uint currentCumulativeRate = cumulativeInterestRate[_token] + _pendingInterestRate(_token);\r\n    return _balance * (currentCumulativeRate - accountInterestSnapshot[_token][_account]) / 100e18;\r\n  }\r\n\r\n  // Used in repayAll and repayAllETH to prevent front-running\r\n  // Potential attack:\r\n  // Recipient account watches the mempool and takes out a large loan just before someone calls repayAll.\r\n  // As a result, paying account would end up paying much more than anticipated\r\n  function _requireAccountNotAccrued(address _token, address _account) internal view {\r\n    if (lastBlockAccrued == block.number && cumulativeInterestRate[_token] > 0) {\r\n      require(\r\n        cumulativeInterestRate[_token] > accountInterestSnapshot[_token][_account],\r\n        \"LendingPair: account already accrued\"\r\n      );\r\n    }\r\n  }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Borrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"repayToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"supplyToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"supplyAmount\",\"type\":\"uint256\"}],\"name\":\"Liquidation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Repay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"accountHealth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accountInterestSnapshot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accrue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"accrueAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"borrow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_borrowedToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_returnToken\",\"type\":\"address\"}],\"name\":\"borrowBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"borrowRatePerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"checkAccountHealth\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"contract IController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fromToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_toToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_inputAmount\",\"type\":\"uint256\"}],\"name\":\"convertTokenValues\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"cumulativeInterestRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"debtOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositRepay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"depositRepayETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lpTokenMaster\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_controller\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_tokenA\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_tokenB\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastBlockAccrued\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_repayToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_repayAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minSupplyOutput\",\"type\":\"uint256\"}],\"name\":\"liquidateAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lpToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"pendingBorrowInterest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"pendingSupplyInterest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"repay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"repayAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"repayAllETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_suppliedToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_returnToken\",\"type\":\"address\"}],\"name\":\"supplyBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"supplyRatePerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenA\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenB\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"withdrawAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAllETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawBorrow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawBorrowETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"LendingPair","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://de769c1265f1fd5c1d4c4a2427d31212fb9923cfd3b2dae12e2ab03d9807e65c"}]}