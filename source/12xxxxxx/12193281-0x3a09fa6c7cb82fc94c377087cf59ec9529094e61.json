{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"sources\": {\r\n    \"TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.5;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TH_APPROVE_FAILED');\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TH_TRANSFER_FAILED');\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TH_TRANSFER_FROM_FAILED');\\n    }\\n\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{ value: value }(new bytes(0));\\n        require(success, 'TH_ETH_TRANSFER_FAILED');\\n    }\\n}\\n\"\r\n    },\r\n    \"SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.5;\\n\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\n\\nlibrary SafeMath {\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x + y) >= x, 'SM_ADD_OVERFLOW');\\n    }\\n\\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = sub(x, y, 'SM_SUB_UNDERFLOW');\\n    }\\n\\n    function sub(\\n        uint256 x,\\n        uint256 y,\\n        string memory message\\n    ) internal pure returns (uint256 z) {\\n        require((z = x - y) <= x, message);\\n    }\\n\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require(y == 0 || (z = x * y) / y == x, 'SM_MUL_OVERFLOW');\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, 'SM_DIV_BY_ZERO');\\n        uint256 c = a / b;\\n        return c;\\n    }\\n}\\n\"\r\n    },\r\n    \"Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.5;\\n\\n// a library for performing various math operations\\n\\nlibrary Math {\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = x < y ? x : y;\\n    }\\n\\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = x > y ? x : y;\\n    }\\n\\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\\n        if (y > 3) {\\n            z = y;\\n            uint256 x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.5;\\n\\ninterface IERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"IIntegralERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.5;\\n\\nimport 'IERC20.sol';\\n\\ninterface IIntegralERC20 is IERC20 {\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"IReserves.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.5;\\n\\ninterface IReserves {\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n    event Fees(uint256 fee0, uint256 fee1);\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint112 reserve0,\\n            uint112 reserve1,\\n            uint32 lastTimestamp\\n        );\\n\\n    function getReferences()\\n        external\\n        view\\n        returns (\\n            uint112 reference0,\\n            uint112 reference1,\\n            uint32 epoch\\n        );\\n\\n    function getFees() external view returns (uint256 fee0, uint256 fee1);\\n}\\n\"\r\n    },\r\n    \"IIntegralPair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.5;\\n\\nimport 'IIntegralERC20.sol';\\nimport 'IReserves.sol';\\n\\ninterface IIntegralPair is IIntegralERC20, IReserves {\\n    event Mint(address indexed sender, address indexed to);\\n    event Burn(address indexed sender, address indexed to);\\n    event Swap(address indexed sender, address indexed to);\\n    event SetMintFee(uint256 fee);\\n    event SetBurnFee(uint256 fee);\\n    event SetSwapFee(uint256 fee);\\n    event SetOracle(address account);\\n    event SetTrader(address trader);\\n    event SetToken0AbsoluteLimit(uint256 limit);\\n    event SetToken1AbsoluteLimit(uint256 limit);\\n    event SetToken0RelativeLimit(uint256 limit);\\n    event SetToken1RelativeLimit(uint256 limit);\\n    event SetPriceDeviationLimit(uint256 limit);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\\n\\n    function factory() external view returns (address);\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n\\n    function oracle() external view returns (address);\\n\\n    function trader() external view returns (address);\\n\\n    function mintFee() external view returns (uint256);\\n\\n    function setMintFee(uint256 fee) external;\\n\\n    function mint(address to) external returns (uint256 liquidity);\\n\\n    function burnFee() external view returns (uint256);\\n\\n    function setBurnFee(uint256 fee) external;\\n\\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\\n\\n    function swapFee() external view returns (uint256);\\n\\n    function setSwapFee(uint256 fee) external;\\n\\n    function setOracle(address account) external;\\n\\n    function setTrader(address account) external;\\n\\n    function token0AbsoluteLimit() external view returns (uint256);\\n\\n    function setToken0AbsoluteLimit(uint256 limit) external;\\n\\n    function token1AbsoluteLimit() external view returns (uint256);\\n\\n    function setToken1AbsoluteLimit(uint256 limit) external;\\n\\n    function token0RelativeLimit() external view returns (uint256);\\n\\n    function setToken0RelativeLimit(uint256 limit) external;\\n\\n    function token1RelativeLimit() external view returns (uint256);\\n\\n    function setToken1RelativeLimit(uint256 limit) external;\\n\\n    function priceDeviationLimit() external view returns (uint256);\\n\\n    function setPriceDeviationLimit(uint256 limit) external;\\n\\n    function collect(address to) external;\\n\\n    function swap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to\\n    ) external;\\n\\n    function sync() external;\\n\\n    function initialize(\\n        address _token0,\\n        address _token1,\\n        address _oracle,\\n        address _trader\\n    ) external;\\n\\n    function syncWithOracle() external;\\n\\n    function fullSync() external;\\n\\n    function getSpotPrice() external view returns (uint256 spotPrice);\\n\\n    function getSwapAmount0In(uint256 amount1Out) external view returns (uint256 swapAmount0In);\\n\\n    function getSwapAmount1In(uint256 amount0Out) external view returns (uint256 swapAmount1In);\\n\\n    function getSwapAmount0Out(uint256 amount1In) external view returns (uint256 swapAmount0Out);\\n\\n    function getSwapAmount1Out(uint256 amount0In) external view returns (uint256 swapAmount1Out);\\n\\n    function getDepositAmount0In(uint256 amount0) external view returns (uint256 depositAmount0In);\\n\\n    function getDepositAmount1In(uint256 amount1) external view returns (uint256 depositAmount1In);\\n}\\n\"\r\n    },\r\n    \"AddLiquidity.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.5;\\n\\nimport 'TransferHelper.sol';\\nimport 'SafeMath.sol';\\nimport 'Math.sol';\\nimport 'IIntegralPair.sol';\\n\\nlibrary AddLiquidity {\\n    using SafeMath for uint256;\\n\\n    function _quote(\\n        uint256 amount0,\\n        uint256 reserve0,\\n        uint256 reserve1\\n    ) private pure returns (uint256 amountB) {\\n        require(amount0 > 0, 'AL_INSUFFICIENT_AMOUNT');\\n        require(reserve0 > 0 && reserve1 > 0, 'AL_INSUFFICIENT_LIQUIDITY');\\n        amountB = amount0.mul(reserve1) / reserve0;\\n    }\\n\\n    function addLiquidity(\\n        address pair,\\n        uint256 amount0Desired,\\n        uint256 amount1Desired\\n    ) external view returns (uint256 amount0, uint256 amount1) {\\n        if (amount0Desired == 0 || amount1Desired == 0) {\\n            return (0, 0);\\n        }\\n        (uint256 reserve0, uint256 reserve1, ) = IIntegralPair(pair).getReserves();\\n        if (reserve0 == 0 && reserve1 == 0) {\\n            (amount0, amount1) = (amount0Desired, amount1Desired);\\n        } else {\\n            uint256 amount1Optimal = _quote(amount0Desired, reserve0, reserve1);\\n            if (amount1Optimal <= amount1Desired) {\\n                (amount0, amount1) = (amount0Desired, amount1Optimal);\\n            } else {\\n                uint256 amount0Optimal = _quote(amount1Desired, reserve1, reserve0);\\n                assert(amount0Optimal <= amount0Desired);\\n                (amount0, amount1) = (amount0Optimal, amount1Desired);\\n            }\\n        }\\n    }\\n\\n    function swapDeposit0(\\n        address pair,\\n        address token0,\\n        uint256 amount0,\\n        uint256 minSwapPrice\\n    ) external returns (uint256 amount0Left, uint256 amount1Left) {\\n        uint256 amount0In = IIntegralPair(pair).getDepositAmount0In(amount0);\\n        amount1Left = IIntegralPair(pair).getSwapAmount1Out(amount0In);\\n        if (amount1Left == 0) {\\n            return (amount0, amount1Left);\\n        }\\n        uint256 price = amount1Left.mul(1e18).div(amount0In);\\n        require(minSwapPrice == 0 || price >= minSwapPrice, 'AL_PRICE_TOO_LOW');\\n        TransferHelper.safeTransfer(token0, pair, amount0In);\\n        IIntegralPair(pair).swap(0, amount1Left, address(this));\\n        amount0Left = amount0.sub(amount0In);\\n    }\\n\\n    function swapDeposit1(\\n        address pair,\\n        address token1,\\n        uint256 amount1,\\n        uint256 maxSwapPrice\\n    ) external returns (uint256 amount0Left, uint256 amount1Left) {\\n        uint256 amount1In = IIntegralPair(pair).getDepositAmount1In(amount1);\\n        amount0Left = IIntegralPair(pair).getSwapAmount0Out(amount1In);\\n        if (amount0Left == 0) {\\n            return (amount0Left, amount1);\\n        }\\n        uint256 price = amount1In.mul(1e18).div(amount0Left);\\n        require(maxSwapPrice == 0 || price <= maxSwapPrice, 'AL_PRICE_TOO_HIGH');\\n        TransferHelper.safeTransfer(token1, pair, amount1In);\\n        IIntegralPair(pair).swap(amount0Left, 0, address(this));\\n        amount1Left = amount1.sub(amount1In);\\n    }\\n\\n    function canSwap(\\n        uint256 initialRatio, // setting it to 0 disables swap\\n        uint256 minRatioChangeToSwap,\\n        address pairAddress\\n    ) external view returns (bool) {\\n        (uint256 reserve0, uint256 reserve1, ) = IIntegralPair(pairAddress).getReserves();\\n        if (reserve0 == 0 || reserve1 == 0 || initialRatio == 0) {\\n            return false;\\n        }\\n        uint256 ratio = reserve0.mul(1e18).div(reserve1);\\n        // ratioChange(before, after) = MAX(before, after) / MIN(before, after) - 1\\n        uint256 change = Math.max(initialRatio, ratio).mul(1e3).div(Math.min(initialRatio, ratio)).sub(1e3);\\n        return change >= minRatioChangeToSwap;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"libraries\": {\r\n      \"TransferHelper.sol\": {},\r\n      \"SafeMath.sol\": {},\r\n      \"Math.sol\": {},\r\n      \"IERC20.sol\": {},\r\n      \"IIntegralERC20.sol\": {},\r\n      \"IReserves.sol\": {},\r\n      \"IIntegralPair.sol\": {},\r\n      \"AddLiquidity.sol\": {}\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"language\": \"Solidity\"\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount0Desired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1Desired\",\"type\":\"uint256\"}],\"name\":\"addLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"initialRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minRatioChangeToSwap\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"pairAddress\",\"type\":\"address\"}],\"name\":\"canSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"AddLiquidity","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":""}]}