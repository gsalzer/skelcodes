{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: AGPL-3.0-or-later\r\npragma solidity 0.8.2;\r\npragma abicoder v2;\r\n\r\n\r\ninterface IPlatformIntegration {\r\n    /**\r\n     * @dev Deposit the given bAsset to Lending platform\r\n     * @param _bAsset bAsset address\r\n     * @param _amount Amount to deposit\r\n     */\r\n    function deposit(\r\n        address _bAsset,\r\n        uint256 _amount,\r\n        bool isTokenFeeCharged\r\n    ) external returns (uint256 quantityDeposited);\r\n\r\n    /**\r\n     * @dev Withdraw given bAsset from Lending platform\r\n     */\r\n    function withdraw(\r\n        address _receiver,\r\n        address _bAsset,\r\n        uint256 _amount,\r\n        bool _hasTxFee\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Withdraw given bAsset from Lending platform\r\n     */\r\n    function withdraw(\r\n        address _receiver,\r\n        address _bAsset,\r\n        uint256 _amount,\r\n        uint256 _totalAmount,\r\n        bool _hasTxFee\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Withdraw given bAsset from the cache\r\n     */\r\n    function withdrawRaw(\r\n        address _receiver,\r\n        address _bAsset,\r\n        uint256 _amount\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the current balance of the given bAsset\r\n     */\r\n    function checkBalance(address _bAsset) external returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the pToken\r\n     */\r\n    function bAssetToPToken(address _bAsset) external returns (address pToken);\r\n}\r\n\r\nstruct BassetPersonal {\r\n    // Address of the bAsset\r\n    address addr;\r\n    // Address of the bAsset\r\n    address integrator;\r\n    // An ERC20 can charge transfer fee, for example USDT, DGX tokens.\r\n    bool hasTxFee; // takes a byte in storage\r\n    // Status of the bAsset\r\n    BassetStatus status;\r\n}\r\n\r\nstruct BassetData {\r\n    // 1 Basset * ratio / ratioScale == x Masset (relative value)\r\n    // If ratio == 10e8 then 1 bAsset = 10 mAssets\r\n    // A ratio is divised as 10^(18-tokenDecimals) * measurementMultiple(relative value of 1 base unit)\r\n    uint128 ratio;\r\n    // Amount of the Basset that is held in Collateral\r\n    uint128 vaultBalance;\r\n}\r\n\r\n// Status of the Basset - has it broken its peg?\r\nenum BassetStatus {\r\n    Default,\r\n    Normal,\r\n    BrokenBelowPeg,\r\n    BrokenAbovePeg,\r\n    Blacklisted,\r\n    Liquidating,\r\n    Liquidated,\r\n    Failed\r\n}\r\n\r\nstruct BasketState {\r\n    bool undergoingRecol;\r\n    bool failed;\r\n}\r\n\r\nstruct InvariantConfig {\r\n    uint256 a;\r\n    WeightLimits limits;\r\n}\r\n\r\nstruct WeightLimits {\r\n    uint128 min;\r\n    uint128 max;\r\n}\r\n\r\nstruct FeederConfig {\r\n    uint256 supply;\r\n    uint256 a;\r\n    WeightLimits limits;\r\n}\r\n\r\nstruct AmpData {\r\n    uint64 initialA;\r\n    uint64 targetA;\r\n    uint64 rampStartTime;\r\n    uint64 rampEndTime;\r\n}\r\n\r\nstruct FeederData {\r\n    uint256 swapFee;\r\n    uint256 redemptionFee;\r\n    uint256 govFee;\r\n    uint256 pendingFees;\r\n    uint256 cacheSize;\r\n    BassetPersonal[] bAssetPersonal;\r\n    BassetData[] bAssetData;\r\n    AmpData ampData;\r\n    WeightLimits weightLimits;\r\n}\r\n\r\nstruct AssetData {\r\n    uint8 idx;\r\n    uint256 amt;\r\n    BassetPersonal personal;\r\n}\r\n\r\nstruct Asset {\r\n    uint8 idx;\r\n    address addr;\r\n    bool exists;\r\n}\r\n\r\nlibrary SafeCast {\r\n    /**\r\n     * @dev Returns the downcasted uint128 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint128).\r\n     *\r\n     * Counterpart to Solidity's `uint128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     */\r\n    function toUint128(uint256 value) internal pure returns (uint128) {\r\n        require(value < 2**128, \"SafeCast: value doesn\\'t fit in 128 bits\");\r\n        return uint128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint64 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint64).\r\n     *\r\n     * Counterpart to Solidity's `uint64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     */\r\n    function toUint64(uint256 value) internal pure returns (uint64) {\r\n        require(value < 2**64, \"SafeCast: value doesn\\'t fit in 64 bits\");\r\n        return uint64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint32 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint32).\r\n     *\r\n     * Counterpart to Solidity's `uint32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     */\r\n    function toUint32(uint256 value) internal pure returns (uint32) {\r\n        require(value < 2**32, \"SafeCast: value doesn\\'t fit in 32 bits\");\r\n        return uint32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint16 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint16).\r\n     *\r\n     * Counterpart to Solidity's `uint16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     */\r\n    function toUint16(uint256 value) internal pure returns (uint16) {\r\n        require(value < 2**16, \"SafeCast: value doesn\\'t fit in 16 bits\");\r\n        return uint16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint8 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint8).\r\n     *\r\n     * Counterpart to Solidity's `uint8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits.\r\n     */\r\n    function toUint8(uint256 value) internal pure returns (uint8) {\r\n        require(value < 2**8, \"SafeCast: value doesn\\'t fit in 8 bits\");\r\n        return uint8(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a signed int256 into an unsigned uint256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be greater than or equal to 0.\r\n     */\r\n    function toUint256(int256 value) internal pure returns (uint256) {\r\n        require(value >= 0, \"SafeCast: value must be positive\");\r\n        return uint256(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int128 from int256, reverting on\r\n     * overflow (when the input is less than smallest int128 or\r\n     * greater than largest int128).\r\n     *\r\n     * Counterpart to Solidity's `int128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt128(int256 value) internal pure returns (int128) {\r\n        require(value >= -2**127 && value < 2**127, \"SafeCast: value doesn\\'t fit in 128 bits\");\r\n        return int128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int64 from int256, reverting on\r\n     * overflow (when the input is less than smallest int64 or\r\n     * greater than largest int64).\r\n     *\r\n     * Counterpart to Solidity's `int64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt64(int256 value) internal pure returns (int64) {\r\n        require(value >= -2**63 && value < 2**63, \"SafeCast: value doesn\\'t fit in 64 bits\");\r\n        return int64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int32 from int256, reverting on\r\n     * overflow (when the input is less than smallest int32 or\r\n     * greater than largest int32).\r\n     *\r\n     * Counterpart to Solidity's `int32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt32(int256 value) internal pure returns (int32) {\r\n        require(value >= -2**31 && value < 2**31, \"SafeCast: value doesn\\'t fit in 32 bits\");\r\n        return int32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int16 from int256, reverting on\r\n     * overflow (when the input is less than smallest int16 or\r\n     * greater than largest int16).\r\n     *\r\n     * Counterpart to Solidity's `int16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt16(int256 value) internal pure returns (int16) {\r\n        require(value >= -2**15 && value < 2**15, \"SafeCast: value doesn\\'t fit in 16 bits\");\r\n        return int16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int8 from int256, reverting on\r\n     * overflow (when the input is less than smallest int8 or\r\n     * greater than largest int8).\r\n     *\r\n     * Counterpart to Solidity's `int8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt8(int256 value) internal pure returns (int8) {\r\n        require(value >= -2**7 && value < 2**7, \"SafeCast: value doesn\\'t fit in 8 bits\");\r\n        return int8(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an unsigned uint256 into a signed int256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be less than or equal to maxInt256.\r\n     */\r\n    function toInt256(uint256 value) internal pure returns (int256) {\r\n        require(value < 2**255, \"SafeCast: value doesn't fit in an int256\");\r\n        return int256(value);\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n            uint256 newAllowance = oldAllowance - value;\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\nlibrary StableMath {\r\n    /**\r\n     * @dev Scaling unit for use in specific calculations,\r\n     * where 1 * 10**18, or 1e18 represents a unit '1'\r\n     */\r\n    uint256 private constant FULL_SCALE = 1e18;\r\n\r\n    /**\r\n     * @dev Token Ratios are used when converting between units of bAsset, mAsset and MTA\r\n     * Reasoning: Takes into account token decimals, and difference in base unit (i.e. grams to Troy oz for gold)\r\n     * bAsset ratio unit for use in exact calculations,\r\n     * where (1 bAsset unit * bAsset.ratio) / ratioScale == x mAsset unit\r\n     */\r\n    uint256 private constant RATIO_SCALE = 1e8;\r\n\r\n    /**\r\n     * @dev Provides an interface to the scaling unit\r\n     * @return Scaling unit (1e18 or 1 * 10**18)\r\n     */\r\n    function getFullScale() internal pure returns (uint256) {\r\n        return FULL_SCALE;\r\n    }\r\n\r\n    /**\r\n     * @dev Provides an interface to the ratio unit\r\n     * @return Ratio scale unit (1e8 or 1 * 10**8)\r\n     */\r\n    function getRatioScale() internal pure returns (uint256) {\r\n        return RATIO_SCALE;\r\n    }\r\n\r\n    /**\r\n     * @dev Scales a given integer to the power of the full scale.\r\n     * @param x   Simple uint256 to scale\r\n     * @return    Scaled value a to an exact number\r\n     */\r\n    function scaleInteger(uint256 x) internal pure returns (uint256) {\r\n        return x * FULL_SCALE;\r\n    }\r\n\r\n    /***************************************\r\n              PRECISE ARITHMETIC\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Multiplies two precise units, and then truncates by the full scale\r\n     * @param x     Left hand input to multiplication\r\n     * @param y     Right hand input to multiplication\r\n     * @return      Result after multiplying the two inputs and then dividing by the shared\r\n     *              scale unit\r\n     */\r\n    function mulTruncate(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return mulTruncateScale(x, y, FULL_SCALE);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two precise units, and then truncates by the given scale. For example,\r\n     * when calculating 90% of 10e18, (10e18 * 9e17) / 1e18 = (9e36) / 1e18 = 9e18\r\n     * @param x     Left hand input to multiplication\r\n     * @param y     Right hand input to multiplication\r\n     * @param scale Scale unit\r\n     * @return      Result after multiplying the two inputs and then dividing by the shared\r\n     *              scale unit\r\n     */\r\n    function mulTruncateScale(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 scale\r\n    ) internal pure returns (uint256) {\r\n        // e.g. assume scale = fullScale\r\n        // z = 10e18 * 9e17 = 9e36\r\n        // return 9e38 / 1e18 = 9e18\r\n        return (x * y) / scale;\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two precise units, and then truncates by the full scale, rounding up the result\r\n     * @param x     Left hand input to multiplication\r\n     * @param y     Right hand input to multiplication\r\n     * @return      Result after multiplying the two inputs and then dividing by the shared\r\n     *              scale unit, rounded up to the closest base unit.\r\n     */\r\n    function mulTruncateCeil(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        // e.g. 8e17 * 17268172638 = 138145381104e17\r\n        uint256 scaled = x * y;\r\n        // e.g. 138145381104e17 + 9.99...e17 = 138145381113.99...e17\r\n        uint256 ceil = scaled + FULL_SCALE - 1;\r\n        // e.g. 13814538111.399...e18 / 1e18 = 13814538111\r\n        return ceil / FULL_SCALE;\r\n    }\r\n\r\n    /**\r\n     * @dev Precisely divides two units, by first scaling the left hand operand. Useful\r\n     *      for finding percentage weightings, i.e. 8e18/10e18 = 80% (or 8e17)\r\n     * @param x     Left hand input to division\r\n     * @param y     Right hand input to division\r\n     * @return      Result after multiplying the left operand by the scale, and\r\n     *              executing the division on the right hand input.\r\n     */\r\n    function divPrecisely(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        // e.g. 8e18 * 1e18 = 8e36\r\n        // e.g. 8e36 / 10e18 = 8e17\r\n        return (x * FULL_SCALE) / y;\r\n    }\r\n\r\n    /***************************************\r\n                  RATIO FUNCS\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Multiplies and truncates a token ratio, essentially flooring the result\r\n     *      i.e. How much mAsset is this bAsset worth?\r\n     * @param x     Left hand operand to multiplication (i.e Exact quantity)\r\n     * @param ratio bAsset ratio\r\n     * @return c    Result after multiplying the two inputs and then dividing by the ratio scale\r\n     */\r\n    function mulRatioTruncate(uint256 x, uint256 ratio) internal pure returns (uint256 c) {\r\n        return mulTruncateScale(x, ratio, RATIO_SCALE);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies and truncates a token ratio, rounding up the result\r\n     *      i.e. How much mAsset is this bAsset worth?\r\n     * @param x     Left hand input to multiplication (i.e Exact quantity)\r\n     * @param ratio bAsset ratio\r\n     * @return      Result after multiplying the two inputs and then dividing by the shared\r\n     *              ratio scale, rounded up to the closest base unit.\r\n     */\r\n    function mulRatioTruncateCeil(uint256 x, uint256 ratio) internal pure returns (uint256) {\r\n        // e.g. How much mAsset should I burn for this bAsset (x)?\r\n        // 1e18 * 1e8 = 1e26\r\n        uint256 scaled = x * ratio;\r\n        // 1e26 + 9.99e7 = 100..00.999e8\r\n        uint256 ceil = scaled + RATIO_SCALE - 1;\r\n        // return 100..00.999e8 / 1e8 = 1e18\r\n        return ceil / RATIO_SCALE;\r\n    }\r\n\r\n    /**\r\n     * @dev Precisely divides two ratioed units, by first scaling the left hand operand\r\n     *      i.e. How much bAsset is this mAsset worth?\r\n     * @param x     Left hand operand in division\r\n     * @param ratio bAsset ratio\r\n     * @return c    Result after multiplying the left operand by the scale, and\r\n     *              executing the division on the right hand input.\r\n     */\r\n    function divRatioPrecisely(uint256 x, uint256 ratio) internal pure returns (uint256 c) {\r\n        // e.g. 1e14 * 1e8 = 1e22\r\n        // return 1e22 / 1e12 = 1e10\r\n        return (x * RATIO_SCALE) / ratio;\r\n    }\r\n\r\n    /***************************************\r\n                    HELPERS\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Calculates minimum of two numbers\r\n     * @param x     Left hand input\r\n     * @param y     Right hand input\r\n     * @return      Minimum of the two inputs\r\n     */\r\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return x > y ? y : x;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculated maximum of two numbers\r\n     * @param x     Left hand input\r\n     * @param y     Right hand input\r\n     * @return      Maximum of the two inputs\r\n     */\r\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return x > y ? x : y;\r\n    }\r\n\r\n    /**\r\n     * @dev Clamps a value to an upper bound\r\n     * @param x           Left hand input\r\n     * @param upperBound  Maximum possible value to return\r\n     * @return            Input x clamped to a maximum value, upperBound\r\n     */\r\n    function clamp(uint256 x, uint256 upperBound) internal pure returns (uint256) {\r\n        return x > upperBound ? upperBound : x;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title   FeederManager\r\n * @author  mStable\r\n * @notice  Manager contract for fPools. Forked from `masset/Manager.sol`, and performs a subset of functionality\r\n *          related to basket management.\r\n * @dev     VERSION: 1.0\r\n *          DATE:    2021-03-01\r\n */\r\nlibrary FeederManager {\r\n    using SafeERC20 for IERC20;\r\n    using StableMath for uint256;\r\n\r\n    event BassetsMigrated(address[] bAssets, address newIntegrator);\r\n    event StartRampA(uint256 currentA, uint256 targetA, uint256 startTime, uint256 rampEndTime);\r\n    event StopRampA(uint256 currentA, uint256 time);\r\n\r\n    uint256 private constant MIN_RAMP_TIME = 1 days;\r\n    uint256 private constant MAX_A = 1e6;\r\n\r\n    /**\r\n     * @dev Calculates the gains accrued across all lending markets.\r\n     * @param _bAssetPersonal   Basset personal storage array\r\n     * @param _bAssetData       Basset data storage array\r\n     * @return idxs             Array [0,1]\r\n     * @return rawGains         Raw increases in vault Balance\r\n     */\r\n    function calculatePlatformInterest(\r\n        BassetPersonal[] memory _bAssetPersonal,\r\n        BassetData[] storage _bAssetData\r\n    ) external returns (uint8[] memory idxs, uint256[] memory rawGains) {\r\n        // Get basket details\r\n        BassetData[] memory bAssetData_ = _bAssetData;\r\n        uint256 count = bAssetData_.length;\r\n        idxs = new uint8[](count);\r\n        rawGains = new uint256[](count);\r\n        // 1. Calculate rawGains in each bAsset, in comparison to current vault balance\r\n        for (uint256 i = 0; i < count; i++) {\r\n            idxs[i] = uint8(i);\r\n            BassetPersonal memory bPersonal = _bAssetPersonal[i];\r\n            BassetData memory bData = bAssetData_[i];\r\n            // If there is no integration, then nothing can have accrued\r\n            if (bPersonal.integrator == address(0)) continue;\r\n            uint256 lending =\r\n                IPlatformIntegration(bPersonal.integrator).checkBalance(bPersonal.addr);\r\n            uint256 cache = 0;\r\n            if (!bPersonal.hasTxFee) {\r\n                cache = IERC20(bPersonal.addr).balanceOf(bPersonal.integrator);\r\n            }\r\n            uint256 balance = lending + cache;\r\n            uint256 oldVaultBalance = bData.vaultBalance;\r\n            if (balance > oldVaultBalance && bPersonal.status == BassetStatus.Normal) {\r\n                _bAssetData[i].vaultBalance = SafeCast.toUint128(balance);\r\n                uint256 interestDelta = balance - oldVaultBalance;\r\n                rawGains[i] = interestDelta;\r\n            } else {\r\n                rawGains[i] = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers all collateral from one lending market to another - used initially\r\n     *      to handle the migration between Aave V1 and Aave V2. Note - only supports non\r\n     *      tx fee enabled assets. Supports going from no integration to integration, but\r\n     *      not the other way around.\r\n     * @param _bAssetPersonal   Basset data storage array\r\n     * @param _bAssets          Array of basket assets to migrate\r\n     * @param _newIntegration   Address of the new platform integration\r\n     */\r\n    function migrateBassets(\r\n        BassetPersonal[] storage _bAssetPersonal,\r\n        address[] calldata _bAssets,\r\n        address _newIntegration\r\n    ) external {\r\n        uint256 len = _bAssets.length;\r\n        require(len > 0, \"Must migrate some bAssets\");\r\n\r\n        for (uint256 i = 0; i < len; i++) {\r\n            // 1. Check that the bAsset is in the basket\r\n            address bAsset = _bAssets[i];\r\n            uint256 index = _getAssetIndex(_bAssetPersonal, bAsset);\r\n            require(!_bAssetPersonal[index].hasTxFee, \"A bAsset has a transfer fee\");\r\n\r\n            // 2. Withdraw everything from the old platform integration\r\n            address oldAddress = _bAssetPersonal[index].integrator;\r\n            require(oldAddress != _newIntegration, \"Must transfer to new integrator\");\r\n            (uint256 cache, uint256 lendingBal) = (0, 0);\r\n            if (oldAddress == address(0)) {\r\n                cache = IERC20(bAsset).balanceOf(address(this));\r\n            } else {\r\n                IPlatformIntegration oldIntegration = IPlatformIntegration(oldAddress);\r\n                cache = IERC20(bAsset).balanceOf(address(oldIntegration));\r\n                // 2.1. Withdraw from the lending market\r\n                lendingBal = oldIntegration.checkBalance(bAsset);\r\n                if (lendingBal > 0) {\r\n                    oldIntegration.withdraw(address(this), bAsset, lendingBal, false);\r\n                }\r\n                // 2.2. Withdraw from the cache, if any\r\n                if (cache > 0) {\r\n                    oldIntegration.withdrawRaw(address(this), bAsset, cache);\r\n                }\r\n            }\r\n            uint256 sum = lendingBal + cache;\r\n\r\n            // 3. Update the integration address for this bAsset\r\n            _bAssetPersonal[index].integrator = _newIntegration;\r\n\r\n            // 4. Deposit everything into the new\r\n            //    This should fail if we did not receive the full amount from the platform withdrawal\r\n            // 4.1. Deposit all bAsset\r\n            IERC20(bAsset).safeTransfer(_newIntegration, sum);\r\n            IPlatformIntegration newIntegration = IPlatformIntegration(_newIntegration);\r\n            if (lendingBal > 0) {\r\n                newIntegration.deposit(bAsset, lendingBal, false);\r\n            }\r\n            // 4.2. Check balances\r\n            uint256 newLendingBal = newIntegration.checkBalance(bAsset);\r\n            uint256 newCache = IERC20(bAsset).balanceOf(address(newIntegration));\r\n            uint256 upperMargin = 10001e14;\r\n            uint256 lowerMargin = 9999e14;\r\n\r\n            require(\r\n                newLendingBal >= lendingBal.mulTruncate(lowerMargin) &&\r\n                    newLendingBal <= lendingBal.mulTruncate(upperMargin),\r\n                \"Must transfer full amount\"\r\n            );\r\n            require(\r\n                newCache >= cache.mulTruncate(lowerMargin) &&\r\n                    newCache <= cache.mulTruncate(upperMargin),\r\n                \"Must transfer full amount\"\r\n            );\r\n        }\r\n\r\n        emit BassetsMigrated(_bAssets, _newIntegration);\r\n    }\r\n\r\n    /**\r\n     * @dev Simply gets the asset index by looping through bAssets. Given there are only\r\n     * ever 2 assets, should not be gas intensive.\r\n     */\r\n    function _getAssetIndex(BassetPersonal[] storage _bAssetPersonal, address _asset)\r\n        internal\r\n        view\r\n        returns (uint8 idx)\r\n    {\r\n        uint256 len = _bAssetPersonal.length;\r\n        for (uint8 i = 0; i < len; i++) {\r\n            if (_bAssetPersonal[i].addr == _asset) return i;\r\n        }\r\n        revert(\"Invalid asset\");\r\n    }\r\n\r\n    /**\r\n     * @dev Starts changing of the amplification var A\r\n     * @param _targetA      Target A value\r\n     * @param _rampEndTime  Time at which A will arrive at _targetA\r\n     */\r\n    function startRampA(\r\n        AmpData storage _ampData,\r\n        uint256 _targetA,\r\n        uint256 _rampEndTime,\r\n        uint256 _currentA,\r\n        uint256 _precision\r\n    ) external {\r\n        require(\r\n            block.timestamp >= (_ampData.rampStartTime + MIN_RAMP_TIME),\r\n            \"Sufficient period of previous ramp has not elapsed\"\r\n        );\r\n        require(_rampEndTime >= (block.timestamp + MIN_RAMP_TIME), \"Ramp time too short\");\r\n        require(_targetA > 0 && _targetA < MAX_A, \"A target out of bounds\");\r\n\r\n        uint256 preciseTargetA = _targetA * _precision;\r\n\r\n        if (preciseTargetA > _currentA) {\r\n            require(preciseTargetA <= _currentA * 10, \"A target increase too big\");\r\n        } else {\r\n            require(preciseTargetA >= _currentA / 10, \"A target decrease too big\");\r\n        }\r\n\r\n        _ampData.initialA = SafeCast.toUint64(_currentA);\r\n        _ampData.targetA = SafeCast.toUint64(preciseTargetA);\r\n        _ampData.rampStartTime = SafeCast.toUint64(block.timestamp);\r\n        _ampData.rampEndTime = SafeCast.toUint64(_rampEndTime);\r\n\r\n        emit StartRampA(_currentA, preciseTargetA, block.timestamp, _rampEndTime);\r\n    }\r\n\r\n    /**\r\n     * @dev Stops the changing of the amplification var A, setting\r\n     * it to whatever the current value is.\r\n     */\r\n    function stopRampA(AmpData storage _ampData, uint256 _currentA) external {\r\n        require(block.timestamp < _ampData.rampEndTime, \"Amplification not changing\");\r\n\r\n        _ampData.initialA = SafeCast.toUint64(_currentA);\r\n        _ampData.targetA = SafeCast.toUint64(_currentA);\r\n        _ampData.rampStartTime = SafeCast.toUint64(block.timestamp);\r\n        _ampData.rampEndTime = SafeCast.toUint64(block.timestamp);\r\n\r\n        emit StopRampA(_currentA, block.timestamp);\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"bAssets\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newIntegrator\",\"type\":\"address\"}],\"name\":\"BassetsMigrated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"targetA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rampEndTime\",\"type\":\"uint256\"}],\"name\":\"StartRampA\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"StopRampA\",\"type\":\"event\"}]","ContractName":"FeederManager","CompilerVersion":"v0.8.2+commit.661d1103","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"ipfs://9f51551ef30b773af1daeddafc45ca33a52f839b5a27abe54ccf769645b1c4d1"}]}