{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/modules/cover/Quotation.sol\": {\r\n      \"content\": \"/* Copyright (C) 2020 NexusMutual.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../capital/MCR.sol\\\";\\nimport \\\"../capital/PoolData.sol\\\";\\nimport \\\"../claims/ClaimsReward.sol\\\";\\nimport \\\"../governance/MemberRoles.sol\\\";\\nimport \\\"../token/TokenController.sol\\\";\\nimport \\\"../token/TokenData.sol\\\";\\nimport \\\"../token/TokenFunctions.sol\\\";\\nimport \\\"./QuotationData.sol\\\";\\n\\ncontract Quotation is Iupgradable {\\n  using SafeMath for uint;\\n\\n  TokenFunctions public tf;\\n  TokenController public tc;\\n  TokenData public td;\\n  Pool public pool;\\n  PoolData public pd;\\n  QuotationData public qd;\\n  MCR public m1;\\n  MemberRoles public mr;\\n  ClaimsReward public cr;\\n\\n  bool internal locked;\\n\\n  event RefundEvent(address indexed user, bool indexed status, uint holdedCoverID, bytes32 reason);\\n\\n  modifier noReentrancy() {\\n    require(!locked, \\\"Reentrant call.\\\");\\n    locked = true;\\n    _;\\n    locked = false;\\n  }\\n\\n  /**\\n   * @dev Iupgradable Interface to update dependent contract address\\n   */\\n  function changeDependentContractAddress() public onlyInternal {\\n    m1 = MCR(ms.getLatestAddress(\\\"MC\\\"));\\n    tf = TokenFunctions(ms.getLatestAddress(\\\"TF\\\"));\\n    tc = TokenController(ms.getLatestAddress(\\\"TC\\\"));\\n    td = TokenData(ms.getLatestAddress(\\\"TD\\\"));\\n    qd = QuotationData(ms.getLatestAddress(\\\"QD\\\"));\\n    pd = PoolData(ms.getLatestAddress(\\\"PD\\\"));\\n    mr = MemberRoles(ms.getLatestAddress(\\\"MR\\\"));\\n    cr = ClaimsReward(ms.getLatestAddress(\\\"CR\\\"));\\n    pool = Pool(ms.getLatestAddress(\\\"P1\\\"));\\n  }\\n\\n  // solhint-disable-next-line no-empty-blocks\\n  function sendEther() public payable {}\\n\\n  /**\\n   * @dev Expires a cover after a set period of time and changes the status of the cover\\n   * @dev Reduces the total and contract sum assured\\n   * @param coverId Cover Id.\\n   */\\n  function expireCover(uint coverId) external {\\n\\n    uint expirationDate = qd.getValidityOfCover(coverId);\\n    require(expirationDate < now, \\\"Quotation: cover is not due to expire\\\");\\n\\n    uint coverStatus = qd.getCoverStatusNo(coverId);\\n    require(coverStatus != uint(QuotationData.CoverStatus.CoverExpired), \\\"Quotation: cover already expired\\\");\\n\\n    (/* claim count */, bool hasOpenClaim, /* accepted */) = tc.coverInfo(coverId);\\n    require(!hasOpenClaim, \\\"Quotation: cover has an open claim\\\");\\n\\n    if (coverStatus != uint(QuotationData.CoverStatus.ClaimAccepted)) {\\n      (,, address contractAddress, bytes4 currency, uint amount,) = qd.getCoverDetailsByCoverID1(coverId);\\n      qd.subFromTotalSumAssured(currency, amount);\\n      qd.subFromTotalSumAssuredSC(contractAddress, currency, amount);\\n    }\\n\\n    qd.changeCoverStatusNo(coverId, uint8(QuotationData.CoverStatus.CoverExpired));\\n  }\\n\\n  function withdrawCoverNote(address coverOwner, uint[] calldata coverIds, uint[] calldata reasonIndexes) external {\\n\\n    uint gracePeriod = tc.claimSubmissionGracePeriod();\\n\\n    for (uint i = 0; i < coverIds.length; i++) {\\n      uint expirationDate = qd.getValidityOfCover(coverIds[i]);\\n      require(expirationDate.add(gracePeriod) < now, \\\"Quotation: cannot withdraw before grace period expiration\\\");\\n    }\\n\\n    tc.withdrawCoverNote(coverOwner, coverIds, reasonIndexes);\\n  }\\n\\n  function getWithdrawableCoverNoteCoverIds(\\n    address coverOwner\\n  ) public view returns (\\n    uint[] memory expiredCoverIds,\\n    bytes32[] memory lockReasons\\n  ) {\\n\\n    uint[] memory coverIds = qd.getAllCoversOfUser(coverOwner);\\n    uint[] memory expiredIdsQueue = new uint[](coverIds.length);\\n    uint gracePeriod = tc.claimSubmissionGracePeriod();\\n    uint expiredQueueLength = 0;\\n\\n    for (uint i = 0; i < coverIds.length; i++) {\\n\\n      uint coverExpirationDate = qd.getValidityOfCover(coverIds[i]);\\n      uint gracePeriodExpirationDate = coverExpirationDate.add(gracePeriod);\\n      (/* claimCount */, bool hasOpenClaim, /* hasAcceptedClaim */) = tc.coverInfo(coverIds[i]);\\n\\n      if (!hasOpenClaim && gracePeriodExpirationDate < now) {\\n        expiredIdsQueue[expiredQueueLength] = coverIds[i];\\n        expiredQueueLength++;\\n      }\\n    }\\n\\n    expiredCoverIds = new uint[](expiredQueueLength);\\n    lockReasons = new bytes32[](expiredQueueLength);\\n\\n    for (uint i = 0; i < expiredQueueLength; i++) {\\n      expiredCoverIds[i] = expiredIdsQueue[i];\\n      lockReasons[i] = keccak256(abi.encodePacked(\\\"CN\\\", coverOwner, expiredIdsQueue[i]));\\n    }\\n  }\\n\\n  function getWithdrawableCoverNotesAmount(address coverOwner) external view returns (uint) {\\n\\n    uint withdrawableAmount;\\n    bytes32[] memory lockReasons;\\n    (/*expiredCoverIds*/, lockReasons) = getWithdrawableCoverNoteCoverIds(coverOwner);\\n\\n    for (uint i = 0; i < lockReasons.length; i++) {\\n      uint coverNoteAmount = tc.tokensLocked(coverOwner, lockReasons[i]);\\n      withdrawableAmount = withdrawableAmount.add(coverNoteAmount);\\n    }\\n\\n    return withdrawableAmount;\\n  }\\n\\n  /**\\n   * @dev Makes Cover funded via NXM tokens.\\n   * @param smartCAdd Smart Contract Address\\n   */\\n  function makeCoverUsingNXMTokens(\\n    uint[] memory coverDetails,\\n    uint16 coverPeriod,\\n    bytes4 coverCurr,\\n    address smartCAdd,\\n    uint8 _v,\\n    bytes32 _r,\\n    bytes32 _s\\n  )\\n  public\\n  isMemberAndcheckPause\\n  {\\n\\n    tc.burnFrom(msg.sender, coverDetails[2]); // need burn allowance\\n    _verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s, true);\\n  }\\n\\n  /**\\n   * @dev Verifies cover details signed off chain.\\n   * @param from address of funder.\\n   * @param scAddress Smart Contract Address\\n   */\\n  function verifyCoverDetails(\\n    address payable from,\\n    address scAddress,\\n    bytes4 coverCurr,\\n    uint[] memory coverDetails,\\n    uint16 coverPeriod,\\n    uint8 _v,\\n    bytes32 _r,\\n    bytes32 _s\\n  )\\n  public\\n  onlyInternal\\n  {\\n    _verifyCoverDetails(\\n      from,\\n      scAddress,\\n      coverCurr,\\n      coverDetails,\\n      coverPeriod,\\n      _v,\\n      _r,\\n      _s,\\n      false\\n    );\\n  }\\n\\n  /**\\n   * @dev Verifies signature.\\n   * @param coverDetails details related to cover.\\n   * @param coverPeriod validity of cover.\\n   * @param smaratCA smarat contract address.\\n   * @param _v argument from vrs hash.\\n   * @param _r argument from vrs hash.\\n   * @param _s argument from vrs hash.\\n   */\\n  function verifySign(\\n    uint[] memory coverDetails,\\n    uint16 coverPeriod,\\n    bytes4 curr,\\n    address smaratCA,\\n    uint8 _v,\\n    bytes32 _r,\\n    bytes32 _s\\n  )\\n  public\\n  view\\n  returns (bool)\\n  {\\n    require(smaratCA != address(0));\\n    require(pd.capReached() == 1, \\\"Can not buy cover until cap reached for 1st time\\\");\\n    bytes32 hash = getOrderHash(coverDetails, coverPeriod, curr, smaratCA);\\n    return isValidSignature(hash, _v, _r, _s);\\n  }\\n\\n  /**\\n   * @dev Gets order hash for given cover details.\\n   * @param coverDetails details realted to cover.\\n   * @param coverPeriod validity of cover.\\n   * @param smaratCA smarat contract address.\\n   */\\n  function getOrderHash(\\n    uint[] memory coverDetails,\\n    uint16 coverPeriod,\\n    bytes4 curr,\\n    address smaratCA\\n  )\\n  public\\n  view\\n  returns (bytes32)\\n  {\\n    return keccak256(\\n      abi.encodePacked(\\n        coverDetails[0],\\n        curr, coverPeriod,\\n        smaratCA,\\n        coverDetails[1],\\n        coverDetails[2],\\n        coverDetails[3],\\n        coverDetails[4],\\n        address(this)\\n      )\\n    );\\n  }\\n\\n  /**\\n   * @dev Verifies signature.\\n   * @param hash order hash\\n   * @param v argument from vrs hash.\\n   * @param r argument from vrs hash.\\n   * @param s argument from vrs hash.\\n   */\\n  function isValidSignature(bytes32 hash, uint8 v, bytes32 r, bytes32 s) public view returns (bool) {\\n    bytes memory prefix = \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\";\\n    bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, hash));\\n    address a = ecrecover(prefixedHash, v, r, s);\\n    return (a == qd.getAuthQuoteEngine());\\n  }\\n\\n  /**\\n   * @dev to get the verdict of kyc process\\n   * @param status is the kyc status\\n   * @param _add is the address of member\\n   */\\n  function kycVerdict(address _add, bool status) public checkPause noReentrancy {\\n    require(msg.sender == qd.kycAuthAddress());\\n    _kycTrigger(status, _add);\\n  }\\n\\n  /**\\n   * @dev transfering Ethers to newly created quotation contract.\\n   */\\n  function transferAssetsToNewContract(address newAdd) public onlyInternal noReentrancy {\\n    uint amount = address(this).balance;\\n    IERC20 erc20;\\n    if (amount > 0) {\\n      // newAdd.transfer(amount);\\n      Quotation newQT = Quotation(newAdd);\\n      newQT.sendEther.value(amount)();\\n    }\\n    uint currAssetLen = pd.getAllCurrenciesLen();\\n    for (uint64 i = 1; i < currAssetLen; i++) {\\n      bytes4 currName = pd.getCurrenciesByIndex(i);\\n      address currAddr = pd.getCurrencyAssetAddress(currName);\\n      erc20 = IERC20(currAddr); // solhint-disable-line\\n      if (erc20.balanceOf(address(this)) > 0) {\\n        require(erc20.transfer(newAdd, erc20.balanceOf(address(this))));\\n      }\\n    }\\n  }\\n\\n\\n  /**\\n   * @dev Creates cover of the quotation, changes the status of the quotation ,\\n   * updates the total sum assured and locks the tokens of the cover against a quote.\\n   * @param from Quote member Ethereum address.\\n   */\\n\\n  function _makeCover(//solhint-disable-line\\n    address payable from,\\n    address scAddress,\\n    bytes4 coverCurr,\\n    uint[] memory coverDetails,\\n    uint16 coverPeriod\\n  )\\n  internal\\n  {\\n    uint cid = qd.getCoverLength();\\n\\n    qd.addCover(\\n      coverPeriod,\\n      coverDetails[0],\\n      from,\\n      coverCurr,\\n      scAddress,\\n      coverDetails[1],\\n      coverDetails[2]\\n    );\\n\\n    uint coverNoteAmount = coverDetails[2].mul(qd.tokensRetained()).div(100);\\n    uint gracePeriod = tc.claimSubmissionGracePeriod();\\n    uint claimSubmissionPeriod = uint(coverPeriod).mul(1 days).add(gracePeriod);\\n    bytes32 reason = keccak256(abi.encodePacked(\\\"CN\\\", from, cid));\\n\\n    td.setDepositCNAmount(cid, coverNoteAmount);\\n    tc.mintCoverNote(from, reason, coverNoteAmount, claimSubmissionPeriod);\\n\\n    qd.addInTotalSumAssured(coverCurr, coverDetails[0]);\\n    qd.addInTotalSumAssuredSC(scAddress, coverCurr, coverDetails[0]);\\n\\n    tf.pushStakerRewards(scAddress, coverDetails[2]);\\n  }\\n\\n  /**\\n   * @dev Makes a cover.\\n   * @param from address of funder.\\n   * @param scAddress Smart Contract Address\\n   */\\n  function _verifyCoverDetails(\\n    address payable from,\\n    address scAddress,\\n    bytes4 coverCurr,\\n    uint[] memory coverDetails,\\n    uint16 coverPeriod,\\n    uint8 _v,\\n    bytes32 _r,\\n    bytes32 _s,\\n    bool isNXM\\n  ) internal {\\n    require(coverDetails[3] > now);\\n    require(!qd.timestampRepeated(coverDetails[4]));\\n    qd.setTimestampRepeated(coverDetails[4]);\\n    require(coverPeriod >= 30 && coverPeriod <= 365, \\\"Quotation: Cover period out of bounds\\\");\\n\\n    address asset = cr.getCurrencyAssetAddress(coverCurr);\\n    if (coverCurr != \\\"ETH\\\" && !isNXM) {\\n      pool.transferAssetFrom(asset, from, coverDetails[1]);\\n    }\\n\\n    require(verifySign(coverDetails, coverPeriod, coverCurr, scAddress, _v, _r, _s));\\n    _makeCover(from, scAddress, coverCurr, coverDetails, coverPeriod);\\n  }\\n\\n  function createCover(\\n    address payable from,\\n    address scAddress,\\n    bytes4 coverCurr,\\n    uint[] memory coverDetails,\\n    uint16 coverPeriod,\\n    uint8 _v,\\n    bytes32 _r,\\n    bytes32 _s\\n  ) public onlyInternal {\\n    require(coverDetails[3] > now, \\\"Quotation: quote is expired\\\");\\n    require(!qd.timestampRepeated(coverDetails[4]), \\\"Quotation: quote already used\\\");\\n    qd.setTimestampRepeated(coverDetails[4]);\\n    require(coverPeriod >= 30 && coverPeriod <= 365, \\\"Quotation: Cover period out of bounds\\\");\\n\\n    require(verifySign(coverDetails, coverPeriod, coverCurr, scAddress, _v, _r, _s), \\\"Quotation: signature mismatch\\\");\\n    _makeCover(from, scAddress, coverCurr, coverDetails, coverPeriod);\\n  }\\n\\n  /**\\n   * @dev to trigger the kyc process\\n   * @param status is the kyc status\\n   * @param _add is the address of member\\n   */\\n  function _kycTrigger(bool status, address _add) internal {\\n\\n    uint holdedCoverLen = qd.getUserHoldedCoverLength(_add).sub(1);\\n    uint holdedCoverID = qd.getUserHoldedCoverByIndex(_add, holdedCoverLen);\\n    address payable userAdd;\\n    address scAddress;\\n    bytes4 coverCurr;\\n    uint16 coverPeriod;\\n    uint[]  memory coverDetails = new uint[](4);\\n    IERC20 erc20;\\n\\n    (, userAdd, coverDetails) = qd.getHoldedCoverDetailsByID2(holdedCoverID);\\n    (, scAddress, coverCurr, coverPeriod) = qd.getHoldedCoverDetailsByID1(holdedCoverID);\\n    require(qd.refundEligible(userAdd));\\n    qd.setRefundEligible(userAdd, false);\\n    require(qd.holdedCoverIDStatus(holdedCoverID) == uint(QuotationData.HCIDStatus.kycPending));\\n    uint joinFee = td.joiningFee();\\n    if (status) {\\n      mr.payJoiningFee.value(joinFee)(userAdd);\\n      if (coverDetails[3] > now) {\\n        qd.setHoldedCoverIDStatus(holdedCoverID, uint(QuotationData.HCIDStatus.kycPass));\\n        if (coverCurr == \\\"ETH\\\") {\\n          // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n          (bool ok,) = address(pool).call.value(coverDetails[1])(\\\"\\\");\\n          require(ok, \\\"Quotation: ether transfer to pool failed\\\");\\n        } else {\\n          erc20 = IERC20(pd.getCurrencyAssetAddress(coverCurr)); // solhint-disable-line\\n          require(erc20.transfer(address(pool), coverDetails[1]));\\n        }\\n        emit RefundEvent(userAdd, status, holdedCoverID, \\\"KYC Passed\\\");\\n        _makeCover(userAdd, scAddress, coverCurr, coverDetails, coverPeriod);\\n\\n      } else {\\n        qd.setHoldedCoverIDStatus(holdedCoverID, uint(QuotationData.HCIDStatus.kycPassNoCover));\\n        if (coverCurr == \\\"ETH\\\") {\\n          userAdd.transfer(coverDetails[1]);\\n        } else {\\n          erc20 = IERC20(pd.getCurrencyAssetAddress(coverCurr)); // solhint-disable-line\\n          require(erc20.transfer(userAdd, coverDetails[1]));\\n        }\\n        emit RefundEvent(userAdd, status, holdedCoverID, \\\"Cover Failed\\\");\\n      }\\n    } else {\\n      qd.setHoldedCoverIDStatus(holdedCoverID, uint(QuotationData.HCIDStatus.kycFailedOrRefunded));\\n      uint totalRefund = joinFee;\\n      if (coverCurr == \\\"ETH\\\") {\\n        totalRefund = coverDetails[1].add(joinFee);\\n      } else {\\n        erc20 = IERC20(pd.getCurrencyAssetAddress(coverCurr)); // solhint-disable-line\\n        require(erc20.transfer(userAdd, coverDetails[1]));\\n      }\\n      userAdd.transfer(totalRefund);\\n      emit RefundEvent(userAdd, status, holdedCoverID, \\\"KYC Failed\\\");\\n    }\\n\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see {ERC20Detailed}.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/modules/capital/MCR.sol\": {\r\n      \"content\": \"/* Copyright (C) 2020 NexusMutual.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../capital/Pool.sol\\\";\\nimport \\\"../cover/QuotationData.sol\\\";\\nimport \\\"../governance/MemberRoles.sol\\\";\\nimport \\\"../governance/ProposalCategory.sol\\\";\\nimport \\\"../oracles/PriceFeedOracle.sol\\\";\\nimport \\\"../token/NXMToken.sol\\\";\\nimport \\\"../token/TokenData.sol\\\";\\nimport \\\"./PoolData.sol\\\";\\n\\ncontract MCR is Iupgradable {\\n  using SafeMath for uint;\\n\\n  Pool public pool;\\n  PoolData public pd;\\n  NXMToken public tk;\\n  QuotationData public qd;\\n  MemberRoles public mr;\\n  TokenData public td;\\n  ProposalCategory public proposalCategory;\\n\\n  uint private constant minCapFactor = uint(10) ** 21;\\n\\n  uint public variableMincap;\\n  uint public dynamicMincapThresholdx100 = 13000;\\n  uint public dynamicMincapIncrementx100 = 100;\\n\\n  event MCREvent(\\n    uint indexed date,\\n    uint blockNumber,\\n    bytes4[] allCurr,\\n    uint[] allCurrRates,\\n    uint mcrEtherx100,\\n    uint mcrPercx100,\\n    uint vFull\\n  );\\n\\n  constructor (address masterAddress) public {\\n\\n    changeMasterAddress(masterAddress);\\n\\n    // we'll pass the zero address on the first deploy\\n    // due to missing previous MCR contract\\n    if (masterAddress == address(0)) {\\n      return;\\n    }\\n\\n    address mcrAddress = ms.getLatestAddress(\\\"MC\\\");\\n    MCR previousMCR = MCR(mcrAddress);\\n\\n    // fetch MCR parameters from previous contract\\n    variableMincap = previousMCR.variableMincap();\\n    dynamicMincapThresholdx100 = previousMCR.dynamicMincapThresholdx100();\\n    dynamicMincapIncrementx100 = previousMCR.dynamicMincapIncrementx100();\\n  }\\n\\n  /**\\n   * @dev Adds new MCR data.\\n   * @param mcrP  Minimum Capital Requirement in percentage.\\n   * @param vF Pool fund value in Ether used in the last full daily calculation of the Capital model.\\n   * @param onlyDate  Date(yyyymmdd) at which MCR details are getting added.\\n   */\\n  function addMCRData(\\n    uint mcrP,\\n    uint mcrE,\\n    uint vF,\\n    bytes4[] calldata curr,\\n    uint[] calldata _threeDayAvg,\\n    uint64 onlyDate\\n  )\\n  external\\n  checkPause\\n  {\\n    require(proposalCategory.constructorCheck());\\n    require(pd.isnotarise(msg.sender));\\n    if (mr.launched() && pd.capReached() != 1) {\\n\\n      if (mcrP >= 10000)\\n        pd.setCapReached(1);\\n\\n    }\\n    uint len = pd.getMCRDataLength();\\n    _addMCRData(len, onlyDate, curr, mcrE, mcrP, vF, _threeDayAvg);\\n  }\\n\\n  // proxying this call through mcr contract to get rid of pd from pool\\n  function getLastMCREther() external view returns (uint) {\\n    return pd.getLastMCREther();\\n  }\\n\\n  /**\\n   * @dev Iupgradable Interface to update dependent contract address\\n   */\\n  function changeDependentContractAddress() public {\\n    qd = QuotationData(ms.getLatestAddress(\\\"QD\\\"));\\n    pool = Pool(ms.getLatestAddress(\\\"P1\\\"));\\n    pd = PoolData(ms.getLatestAddress(\\\"PD\\\"));\\n    tk = NXMToken(ms.tokenAddress());\\n    mr = MemberRoles(ms.getLatestAddress(\\\"MR\\\"));\\n    td = TokenData(ms.getLatestAddress(\\\"TD\\\"));\\n    proposalCategory = ProposalCategory(ms.getLatestAddress(\\\"PC\\\"));\\n  }\\n\\n  /**\\n   * @dev Gets total sum assured (in ETH).\\n   * @return amount of sum assured\\n   */\\n  function getAllSumAssurance() public view returns (uint) {\\n\\n    PriceFeedOracle priceFeed = pool.priceFeedOracle();\\n    address daiAddress = priceFeed.daiAddress();\\n\\n    uint ethAmount = qd.getTotalSumAssured(\\\"ETH\\\").mul(1e18);\\n    uint daiAmount = qd.getTotalSumAssured(\\\"DAI\\\").mul(1e18);\\n\\n    uint daiRate = priceFeed.getAssetToEthRate(daiAddress);\\n    uint daiAmountInEth = daiAmount.mul(daiRate).div(1e18);\\n\\n    return ethAmount.add(daiAmountInEth);\\n  }\\n\\n  function getThresholdValues(uint vtp, uint vF, uint totalSA, uint minCap) public view returns (uint lowerThreshold, uint upperThreshold)\\n  {\\n    minCap = (minCap.mul(minCapFactor)).add(variableMincap);\\n    uint lower = 0;\\n    if (vtp >= vF) {\\n      // Max Threshold = [MAX(Vtp, Vfull) x 120] / mcrMinCap\\n      upperThreshold = vtp.mul(120).mul(100).div((minCap));\\n    } else {\\n      upperThreshold = vF.mul(120).mul(100).div((minCap));\\n    }\\n\\n    if (vtp > 0) {\\n      lower = totalSA.mul(pd.shockParameter()).div(100);\\n      if (lower < minCap.mul(11).div(10))\\n        lower = minCap.mul(11).div(10);\\n    }\\n    if (lower > 0) {\\n      // Min Threshold = [Vtp / MAX(TotalActiveSA x ShockParameter, mcrMinCap x 1.1)] x 100\\n      lowerThreshold = vtp.mul(100).mul(100).div(lower);\\n    }\\n  }\\n\\n  /**\\n   * @dev Gets Uint Parameters of a code\\n   * @param code whose details we want\\n   * @return string value of the code\\n   * @return associated amount (time or perc or value) to the code\\n   */\\n  function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val) {\\n    codeVal = code;\\n    if (code == \\\"DMCT\\\") {\\n      val = dynamicMincapThresholdx100;\\n\\n    } else if (code == \\\"DMCI\\\") {\\n\\n      val = dynamicMincapIncrementx100;\\n\\n    }\\n\\n  }\\n\\n  /**\\n   * @dev Updates Uint Parameters of a code\\n   * @param code whose details we want to update\\n   * @param val value to set\\n   */\\n  function updateUintParameters(bytes8 code, uint val) public {\\n    require(ms.checkIsAuthToGoverned(msg.sender));\\n    if (code == \\\"DMCT\\\") {\\n      dynamicMincapThresholdx100 = val;\\n\\n    } else if (code == \\\"DMCI\\\") {\\n\\n      dynamicMincapIncrementx100 = val;\\n\\n    }\\n    else {\\n      revert(\\\"Invalid param code\\\");\\n    }\\n\\n  }\\n\\n  /**\\n   * @dev Adds MCR Data. Checks if MCR is within valid\\n   * thresholds in order to rule out any incorrect calculations\\n   */\\n  function _addMCRData(\\n    uint len,\\n    uint64 newMCRDate,\\n    bytes4[] memory curr,\\n    uint mcrE,\\n    uint mcrP,\\n    uint vF,\\n    uint[] memory _threeDayAvg\\n  )\\n  internal\\n  {\\n    uint lowerThreshold = 0;\\n    uint upperThreshold = 0;\\n\\n    if (len > 1) {\\n      uint vtp = pool.getPoolValueInEth();\\n      (lowerThreshold, upperThreshold) = getThresholdValues(vtp, vF, getAllSumAssurance(), pd.minCap());\\n    }\\n\\n    if (mcrP > dynamicMincapThresholdx100) {\\n      variableMincap = (variableMincap.mul(dynamicMincapIncrementx100.add(10000)).add(minCapFactor.mul(pd.minCap().mul(dynamicMincapIncrementx100)))).div(10000);\\n    }\\n\\n    // Explanation for above formula :-\\n    // actual formula -> variableMinCap =  variableMinCap + (variableMinCap+minCap)*dynamicMincapIncrement/100\\n    // Implemented formula is simplified form of actual formula.\\n    // Let consider above formula as b = b + (a+b)*c/100\\n    // here, dynamicMincapIncrement is in x100 format.\\n    // so b+(a+b)*cx100/10000 can be written as => (10000.b + b.cx100 + a.cx100)/10000.\\n    // It can further simplify to (b.(10000+cx100) + a.cx100)/10000.\\n    if (len == 1 || (mcrP) >= lowerThreshold && (mcrP) <= upperThreshold) {\\n\\n      pd.pushMCRData(mcrP, mcrE, vF, newMCRDate);\\n\\n      for (uint i = 0; i < curr.length; i++) {\\n        pd.updateCAAvgRate(curr[i], _threeDayAvg[i]);\\n      }\\n\\n      emit MCREvent(newMCRDate, block.number, curr, _threeDayAvg, mcrE, mcrP, vF);\\n      return;\\n    }\\n\\n    revert(\\\"MCR: Failed\\\");\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/modules/capital/PoolData.sol\": {\r\n      \"content\": \"/* Copyright (C) 2020 NexusMutual.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../../abstract/Iupgradable.sol\\\";\\n\\ncontract DSValue {\\n  function peek() public view returns (bytes32, bool);\\n\\n  function read() public view returns (bytes32);\\n}\\n\\ncontract PoolData is Iupgradable {\\n  using SafeMath for uint;\\n\\n  struct ApiId {\\n    bytes4 typeOf;\\n    bytes4 currency;\\n    uint id;\\n    uint64 dateAdd;\\n    uint64 dateUpd;\\n  }\\n\\n  struct CurrencyAssets {\\n    address currAddress;\\n    uint baseMin;\\n    uint varMin;\\n  }\\n\\n  struct InvestmentAssets {\\n    address currAddress;\\n    bool status;\\n    uint64 minHoldingPercX100;\\n    uint64 maxHoldingPercX100;\\n    uint8 decimals;\\n  }\\n\\n  struct IARankDetails {\\n    bytes4 maxIACurr;\\n    uint64 maxRate;\\n    bytes4 minIACurr;\\n    uint64 minRate;\\n  }\\n\\n  struct McrData {\\n    uint mcrPercx100;\\n    uint mcrEther;\\n    uint vFull; //Pool funds\\n    uint64 date;\\n  }\\n\\n  IARankDetails[] internal allIARankDetails;\\n  McrData[] public allMCRData;\\n\\n  bytes4[] internal allInvestmentCurrencies;\\n  bytes4[] internal allCurrencies;\\n  bytes32[] public allAPIcall;\\n  mapping(bytes32 => ApiId) public allAPIid;\\n  mapping(uint64 => uint) internal datewiseId;\\n  mapping(bytes16 => uint) internal currencyLastIndex;\\n  mapping(bytes4 => CurrencyAssets) internal allCurrencyAssets;\\n  mapping(bytes4 => InvestmentAssets) internal allInvestmentAssets;\\n  mapping(bytes4 => uint) internal caAvgRate;\\n  mapping(bytes4 => uint) internal iaAvgRate;\\n\\n  address public notariseMCR;\\n  address public daiFeedAddress;\\n  uint private constant DECIMAL1E18 = uint(10) ** 18;\\n  uint public uniswapDeadline;\\n  uint public liquidityTradeCallbackTime;\\n  uint public lastLiquidityTradeTrigger;\\n  uint64 internal lastDate;\\n  uint public variationPercX100;\\n  uint public iaRatesTime;\\n  uint public minCap;\\n  uint public mcrTime;\\n  uint public a;\\n  uint public shockParameter;\\n  uint public c;\\n  uint public mcrFailTime;\\n  uint public ethVolumeLimit;\\n  uint public capReached;\\n  uint public capacityLimit;\\n\\n  constructor(address _notariseAdd, address _daiFeedAdd, address _daiAdd) public {\\n    notariseMCR = _notariseAdd;\\n    daiFeedAddress = _daiFeedAdd;\\n    c = 5800000;\\n    a = 1028;\\n    mcrTime = 24 hours;\\n    mcrFailTime = 6 hours;\\n    allMCRData.push(McrData(0, 0, 0, 0));\\n    minCap = 12000 * DECIMAL1E18;\\n    shockParameter = 50;\\n    variationPercX100 = 100; // 1%\\n    iaRatesTime = 24 hours; // 24 hours in seconds\\n    uniswapDeadline = 20 minutes;\\n    liquidityTradeCallbackTime = 4 hours;\\n    ethVolumeLimit = 4;\\n    capacityLimit = 10;\\n    allCurrencies.push(\\\"ETH\\\");\\n    allCurrencyAssets[\\\"ETH\\\"] = CurrencyAssets(address(0), 1000 * DECIMAL1E18, 0);\\n    allCurrencies.push(\\\"DAI\\\");\\n    allCurrencyAssets[\\\"DAI\\\"] = CurrencyAssets(_daiAdd, 50000 * DECIMAL1E18, 0);\\n    allInvestmentCurrencies.push(\\\"ETH\\\");\\n    allInvestmentAssets[\\\"ETH\\\"] = InvestmentAssets(address(0), true, 2500, 10000, 18);\\n    allInvestmentCurrencies.push(\\\"DAI\\\");\\n    allInvestmentAssets[\\\"DAI\\\"] = InvestmentAssets(_daiAdd, true, 250, 1500, 18);\\n  }\\n\\n  /**\\n   * @dev to set the maximum cap allowed\\n   * @param val is the new value\\n   */\\n  function setCapReached(uint val) external onlyInternal {\\n    capReached = val;\\n  }\\n\\n  /// @dev Updates the 3 day average rate of a IA currency.\\n  /// To be replaced by MakerDao's on chain rates\\n  /// @param curr IA Currency Name.\\n  /// @param rate Average exchange rate X 100 (of last 3 days).\\n  function updateIAAvgRate(bytes4 curr, uint rate) external onlyInternal {\\n    iaAvgRate[curr] = rate;\\n  }\\n\\n  /// @dev Updates the 3 day average rate of a CA currency.\\n  /// To be replaced by MakerDao's on chain rates\\n  /// @param curr Currency Name.\\n  /// @param rate Average exchange rate X 100 (of last 3 days).\\n  function updateCAAvgRate(bytes4 curr, uint rate) external onlyInternal {\\n    caAvgRate[curr] = rate;\\n  }\\n\\n  /// @dev Adds details of (Minimum Capital Requirement)MCR.\\n  /// @param mcrp Minimum Capital Requirement percentage (MCR% * 100 ,Ex:for 54.56% ,given 5456)\\n  /// @param vf Pool fund value in Ether used in the last full daily calculation from the Capital model.\\n  function pushMCRData(uint mcrp, uint mcre, uint vf, uint64 time) external onlyInternal {\\n    allMCRData.push(McrData(mcrp, mcre, vf, time));\\n  }\\n\\n  /**\\n   * @dev Updates the Timestamp at which result of oracalize call is received.\\n   */\\n  function updateDateUpdOfAPI(bytes32 myid) external onlyInternal {\\n    allAPIid[myid].dateUpd = uint64(now);\\n  }\\n\\n  /**\\n   * @dev Saves the details of the Oraclize API.\\n   * @param myid Id return by the oraclize query.\\n   * @param _typeof type of the query for which oraclize call is made.\\n   * @param id ID of the proposal,quote,cover etc. for which oraclize call is made\\n   */\\n  function saveApiDetails(bytes32 myid, bytes4 _typeof, uint id) external onlyInternal {\\n    allAPIid[myid] = ApiId(_typeof, \\\"\\\", id, uint64(now), uint64(now));\\n  }\\n\\n  /**\\n   * @dev Stores the id return by the oraclize query.\\n   * Maintains record of all the Ids return by oraclize query.\\n   * @param myid Id return by the oraclize query.\\n   */\\n  function addInAllApiCall(bytes32 myid) external onlyInternal {\\n    allAPIcall.push(myid);\\n  }\\n\\n  /**\\n   * @dev Saves investment asset rank details.\\n   * @param maxIACurr Maximum ranked investment asset currency.\\n   * @param maxRate Maximum ranked investment asset rate.\\n   * @param minIACurr Minimum ranked investment asset currency.\\n   * @param minRate Minimum ranked investment asset rate.\\n   * @param date in yyyymmdd.\\n   */\\n  function saveIARankDetails(\\n    bytes4 maxIACurr,\\n    uint64 maxRate,\\n    bytes4 minIACurr,\\n    uint64 minRate,\\n    uint64 date\\n  )\\n  external\\n  onlyInternal\\n  {\\n    allIARankDetails.push(IARankDetails(maxIACurr, maxRate, minIACurr, minRate));\\n    datewiseId[date] = allIARankDetails.length.sub(1);\\n  }\\n\\n  /**\\n   * @dev to get the time for the laste liquidity trade trigger\\n   */\\n  function setLastLiquidityTradeTrigger() external onlyInternal {\\n    lastLiquidityTradeTrigger = now;\\n  }\\n\\n  /**\\n   * @dev Updates Last Date.\\n   */\\n  function updatelastDate(uint64 newDate) external onlyInternal {\\n    lastDate = newDate;\\n  }\\n\\n  /**\\n   * @dev Adds currency asset currency.\\n   * @param curr currency of the asset\\n   * @param currAddress address of the currency\\n   * @param baseMin base minimum in 10^18.\\n   */\\n  function addCurrencyAssetCurrency(\\n    bytes4 curr,\\n    address currAddress,\\n    uint baseMin\\n  )\\n  external\\n  {\\n    require(ms.checkIsAuthToGoverned(msg.sender));\\n    allCurrencies.push(curr);\\n    allCurrencyAssets[curr] = CurrencyAssets(currAddress, baseMin, 0);\\n  }\\n\\n  /**\\n   * @dev Adds investment asset.\\n   */\\n  function addInvestmentAssetCurrency(\\n    bytes4 curr,\\n    address currAddress,\\n    bool status,\\n    uint64 minHoldingPercX100,\\n    uint64 maxHoldingPercX100,\\n    uint8 decimals\\n  )\\n  external\\n  {\\n    require(ms.checkIsAuthToGoverned(msg.sender));\\n    allInvestmentCurrencies.push(curr);\\n    allInvestmentAssets[curr] = InvestmentAssets(currAddress, status,\\n      minHoldingPercX100, maxHoldingPercX100, decimals);\\n  }\\n\\n  /**\\n   * @dev Changes base minimum of a given currency asset.\\n   */\\n  function changeCurrencyAssetBaseMin(bytes4 curr, uint baseMin) external {\\n    require(ms.checkIsAuthToGoverned(msg.sender));\\n    allCurrencyAssets[curr].baseMin = baseMin;\\n  }\\n\\n  /**\\n   * @dev changes variable minimum of a given currency asset.\\n   */\\n  function changeCurrencyAssetVarMin(bytes4 curr, uint varMin) external onlyInternal {\\n    allCurrencyAssets[curr].varMin = varMin;\\n  }\\n\\n  /**\\n   * @dev Changes the investment asset status.\\n   */\\n  function changeInvestmentAssetStatus(bytes4 curr, bool status) external {\\n    require(ms.checkIsAuthToGoverned(msg.sender));\\n    allInvestmentAssets[curr].status = status;\\n  }\\n\\n  /**\\n   * @dev Changes the investment asset Holding percentage of a given currency.\\n   */\\n  function changeInvestmentAssetHoldingPerc(\\n    bytes4 curr,\\n    uint64 minPercX100,\\n    uint64 maxPercX100\\n  )\\n  external\\n  {\\n    require(ms.checkIsAuthToGoverned(msg.sender));\\n    allInvestmentAssets[curr].minHoldingPercX100 = minPercX100;\\n    allInvestmentAssets[curr].maxHoldingPercX100 = maxPercX100;\\n  }\\n\\n  /**\\n   * @dev Gets Currency asset token address.\\n   */\\n  function changeCurrencyAssetAddress(bytes4 curr, address currAdd) external {\\n    require(ms.checkIsAuthToGoverned(msg.sender));\\n    allCurrencyAssets[curr].currAddress = currAdd;\\n  }\\n\\n  /**\\n   * @dev Changes Investment asset token address.\\n   */\\n  function changeInvestmentAssetAddressAndDecimal(\\n    bytes4 curr,\\n    address currAdd,\\n    uint8 newDecimal\\n  )\\n  external\\n  {\\n    require(ms.checkIsAuthToGoverned(msg.sender));\\n    allInvestmentAssets[curr].currAddress = currAdd;\\n    allInvestmentAssets[curr].decimals = newDecimal;\\n  }\\n\\n  /// @dev Changes address allowed to post MCR.\\n  function changeNotariseAddress(address _add) external onlyInternal {\\n    notariseMCR = _add;\\n  }\\n\\n  /// @dev updates daiFeedAddress address.\\n  /// @param _add address of DAI feed.\\n  function changeDAIfeedAddress(address _add) external onlyInternal {\\n    daiFeedAddress = _add;\\n  }\\n\\n  /**\\n   * @dev Gets Uint Parameters of a code\\n   * @param code whose details we want\\n   * @return string value of the code\\n   * @return associated amount (time or perc or value) to the code\\n   */\\n  function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val) {\\n    codeVal = code;\\n    if (code == \\\"MCRTIM\\\") {\\n      val = mcrTime / (1 hours);\\n\\n    } else if (code == \\\"MCRFTIM\\\") {\\n\\n      val = mcrFailTime / (1 hours);\\n\\n    } else if (code == \\\"MCRMIN\\\") {\\n\\n      val = minCap;\\n\\n    } else if (code == \\\"MCRSHOCK\\\") {\\n\\n      val = shockParameter;\\n\\n    } else if (code == \\\"MCRCAPL\\\") {\\n\\n      val = capacityLimit;\\n\\n    } else if (code == \\\"IMZ\\\") {\\n\\n      val = variationPercX100;\\n\\n    } else if (code == \\\"IMRATET\\\") {\\n\\n      val = iaRatesTime / (1 hours);\\n\\n    } else if (code == \\\"IMUNIDL\\\") {\\n\\n      val = uniswapDeadline / (1 minutes);\\n\\n    } else if (code == \\\"IMLIQT\\\") {\\n\\n      val = liquidityTradeCallbackTime / (1 hours);\\n\\n    } else if (code == \\\"IMETHVL\\\") {\\n\\n      val = ethVolumeLimit;\\n\\n    } else if (code == \\\"C\\\") {\\n      val = c;\\n\\n    } else if (code == \\\"A\\\") {\\n\\n      val = a;\\n\\n    }\\n\\n  }\\n\\n  /// @dev Checks whether a given address can notaise MCR data or not.\\n  /// @param _add Address.\\n  /// @return res Returns 0 if address is not authorized, else 1.\\n  function isnotarise(address _add) external view returns (bool res) {\\n    res = false;\\n    if (_add == notariseMCR)\\n      res = true;\\n  }\\n\\n  /// @dev Gets the details of last added MCR.\\n  /// @return mcrPercx100 Total Minimum Capital Requirement percentage of that month of year(multiplied by 100).\\n  /// @return vFull Total Pool fund value in Ether used in the last full daily calculation.\\n  function getLastMCR() external view returns (uint mcrPercx100, uint mcrEtherx1E18, uint vFull, uint64 date) {\\n    uint index = allMCRData.length.sub(1);\\n    return (\\n    allMCRData[index].mcrPercx100,\\n    allMCRData[index].mcrEther,\\n    allMCRData[index].vFull,\\n    allMCRData[index].date\\n    );\\n  }\\n\\n  /// @dev Gets last Minimum Capital Requirement percentage of Capital Model\\n  /// @return val MCR% value,multiplied by 100.\\n  function getLastMCRPerc() external view returns (uint) {\\n    return allMCRData[allMCRData.length.sub(1)].mcrPercx100;\\n  }\\n\\n  /// @dev Gets last Ether price of Capital Model\\n  /// @return val ether value,multiplied by 100.\\n  function getLastMCREther() external view returns (uint) {\\n    return allMCRData[allMCRData.length.sub(1)].mcrEther;\\n  }\\n\\n  /// @dev Gets Pool fund value in Ether used in the last full daily calculation from the Capital model.\\n  function getLastVfull() external view returns (uint) {\\n    return allMCRData[allMCRData.length.sub(1)].vFull;\\n  }\\n\\n  /// @dev Gets last Minimum Capital Requirement in Ether.\\n  /// @return date of MCR.\\n  function getLastMCRDate() external view returns (uint64 date) {\\n    date = allMCRData[allMCRData.length.sub(1)].date;\\n  }\\n\\n  /// @dev Gets details for token price calculation.\\n  function getTokenPriceDetails(bytes4 curr) external view returns (uint _a, uint _c, uint rate) {\\n    _a = a;\\n    _c = c;\\n    rate = _getAvgRate(curr, false);\\n  }\\n\\n  /// @dev Gets the total number of times MCR calculation has been made.\\n  function getMCRDataLength() external view returns (uint len) {\\n    len = allMCRData.length;\\n  }\\n\\n  /**\\n   * @dev Gets investment asset rank details by given date.\\n   */\\n  function getIARankDetailsByDate(\\n    uint64 date\\n  )\\n  external\\n  view\\n  returns (\\n    bytes4 maxIACurr,\\n    uint64 maxRate,\\n    bytes4 minIACurr,\\n    uint64 minRate\\n  )\\n  {\\n    uint index = datewiseId[date];\\n    return (\\n    allIARankDetails[index].maxIACurr,\\n    allIARankDetails[index].maxRate,\\n    allIARankDetails[index].minIACurr,\\n    allIARankDetails[index].minRate\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets Last Date.\\n   */\\n  function getLastDate() external view returns (uint64 date) {\\n    return lastDate;\\n  }\\n\\n  /**\\n   * @dev Gets investment currency for a given index.\\n   */\\n  function getInvestmentCurrencyByIndex(uint index) external view returns (bytes4 currName) {\\n    return allInvestmentCurrencies[index];\\n  }\\n\\n  /**\\n   * @dev Gets count of investment currency.\\n   */\\n  function getInvestmentCurrencyLen() external view returns (uint len) {\\n    return allInvestmentCurrencies.length;\\n  }\\n\\n  /**\\n   * @dev Gets all the investment currencies.\\n   */\\n  function getAllInvestmentCurrencies() external view returns (bytes4[] memory currencies) {\\n    return allInvestmentCurrencies;\\n  }\\n\\n  /**\\n   * @dev Gets All currency for a given index.\\n   */\\n  function getCurrenciesByIndex(uint index) external view returns (bytes4 currName) {\\n    return allCurrencies[index];\\n  }\\n\\n  /**\\n   * @dev Gets count of All currency.\\n   */\\n  function getAllCurrenciesLen() external view returns (uint len) {\\n    return allCurrencies.length;\\n  }\\n\\n  /**\\n   * @dev Gets all currencies\\n   */\\n  function getAllCurrencies() external view returns (bytes4[] memory currencies) {\\n    return allCurrencies;\\n  }\\n\\n  /**\\n   * @dev Gets currency asset details for a given currency.\\n   */\\n  function getCurrencyAssetVarBase(\\n    bytes4 curr\\n  )\\n  external\\n  view\\n  returns (\\n    bytes4 currency,\\n    uint baseMin,\\n    uint varMin\\n  )\\n  {\\n    return (\\n    curr,\\n    allCurrencyAssets[curr].baseMin,\\n    allCurrencyAssets[curr].varMin\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets minimum variable value for currency asset.\\n   */\\n  function getCurrencyAssetVarMin(bytes4 curr) external view returns (uint varMin) {\\n    return allCurrencyAssets[curr].varMin;\\n  }\\n\\n  /**\\n   * @dev Gets base minimum of  a given currency asset.\\n   */\\n  function getCurrencyAssetBaseMin(bytes4 curr) external view returns (uint baseMin) {\\n    return allCurrencyAssets[curr].baseMin;\\n  }\\n\\n  /**\\n   * @dev Gets investment asset maximum and minimum holding percentage of a given currency.\\n   */\\n  function getInvestmentAssetHoldingPerc(\\n    bytes4 curr\\n  )\\n  external\\n  view\\n  returns (\\n    uint64 minHoldingPercX100,\\n    uint64 maxHoldingPercX100\\n  )\\n  {\\n    return (\\n    allInvestmentAssets[curr].minHoldingPercX100,\\n    allInvestmentAssets[curr].maxHoldingPercX100\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets investment asset decimals.\\n   */\\n  function getInvestmentAssetDecimals(bytes4 curr) external view returns (uint8 decimal) {\\n    return allInvestmentAssets[curr].decimals;\\n  }\\n\\n  /**\\n   * @dev Gets investment asset maximum holding percentage of a given currency.\\n   */\\n  function getInvestmentAssetMaxHoldingPerc(bytes4 curr) external view returns (uint64 maxHoldingPercX100) {\\n    return allInvestmentAssets[curr].maxHoldingPercX100;\\n  }\\n\\n  /**\\n   * @dev Gets investment asset minimum holding percentage of a given currency.\\n   */\\n  function getInvestmentAssetMinHoldingPerc(bytes4 curr) external view returns (uint64 minHoldingPercX100) {\\n    return allInvestmentAssets[curr].minHoldingPercX100;\\n  }\\n\\n  /**\\n   * @dev Gets investment asset details of a given currency\\n   */\\n  function getInvestmentAssetDetails(\\n    bytes4 curr\\n  )\\n  external\\n  view\\n  returns (\\n    bytes4 currency,\\n    address currAddress,\\n    bool status,\\n    uint64 minHoldingPerc,\\n    uint64 maxHoldingPerc,\\n    uint8 decimals\\n  )\\n  {\\n    return (\\n    curr,\\n    allInvestmentAssets[curr].currAddress,\\n    allInvestmentAssets[curr].status,\\n    allInvestmentAssets[curr].minHoldingPercX100,\\n    allInvestmentAssets[curr].maxHoldingPercX100,\\n    allInvestmentAssets[curr].decimals\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets Currency asset token address.\\n   */\\n  function getCurrencyAssetAddress(bytes4 curr) external view returns (address) {\\n    return allCurrencyAssets[curr].currAddress;\\n  }\\n\\n  /**\\n   * @dev Gets investment asset token address.\\n   */\\n  function getInvestmentAssetAddress(bytes4 curr) external view returns (address) {\\n    return allInvestmentAssets[curr].currAddress;\\n  }\\n\\n  /**\\n   * @dev Gets investment asset active Status of a given currency.\\n   */\\n  function getInvestmentAssetStatus(bytes4 curr) external view returns (bool status) {\\n    return allInvestmentAssets[curr].status;\\n  }\\n\\n  /**\\n   * @dev Gets type of oraclize query for a given Oraclize Query ID.\\n   * @param myid Oraclize Query ID identifying the query for which the result is being received.\\n   * @return _typeof It could be of type \\\"quote\\\",\\\"quotation\\\",\\\"cover\\\",\\\"claim\\\" etc.\\n   */\\n  function getApiIdTypeOf(bytes32 myid) external view returns (bytes4) {\\n    return allAPIid[myid].typeOf;\\n  }\\n\\n  /**\\n   * @dev Gets ID associated to oraclize query for a given Oraclize Query ID.\\n   * @param myid Oraclize Query ID identifying the query for which the result is being received.\\n   * @return id1 It could be the ID of \\\"proposal\\\",\\\"quotation\\\",\\\"cover\\\",\\\"claim\\\" etc.\\n   */\\n  function getIdOfApiId(bytes32 myid) external view returns (uint) {\\n    return allAPIid[myid].id;\\n  }\\n\\n  /**\\n   * @dev Gets the Timestamp of a oracalize call.\\n   */\\n  function getDateAddOfAPI(bytes32 myid) external view returns (uint64) {\\n    return allAPIid[myid].dateAdd;\\n  }\\n\\n  /**\\n   * @dev Gets the Timestamp at which result of oracalize call is received.\\n   */\\n  function getDateUpdOfAPI(bytes32 myid) external view returns (uint64) {\\n    return allAPIid[myid].dateUpd;\\n  }\\n\\n  /**\\n   * @dev Gets currency by oracalize id.\\n   */\\n  function getCurrOfApiId(bytes32 myid) external view returns (bytes4) {\\n    return allAPIid[myid].currency;\\n  }\\n\\n  /**\\n   * @dev Gets ID return by the oraclize query of a given index.\\n   * @param index Index.\\n   * @return myid ID return by the oraclize query.\\n   */\\n  function getApiCallIndex(uint index) external view returns (bytes32 myid) {\\n    myid = allAPIcall[index];\\n  }\\n\\n  /**\\n   * @dev Gets Length of API call.\\n   */\\n  function getApilCallLength() external view returns (uint) {\\n    return allAPIcall.length;\\n  }\\n\\n  /**\\n   * @dev Get Details of Oraclize API when given Oraclize Id.\\n   * @param myid ID return by the oraclize query.\\n   * @return _typeof ype of the query for which oraclize\\n   * call is made.(\\\"proposal\\\",\\\"quote\\\",\\\"quotation\\\" etc.)\\n   */\\n  function getApiCallDetails(\\n    bytes32 myid\\n  )\\n  external\\n  view\\n  returns (\\n    bytes4 _typeof,\\n    bytes4 curr,\\n    uint id,\\n    uint64 dateAdd,\\n    uint64 dateUpd\\n  )\\n  {\\n    return (\\n    allAPIid[myid].typeOf,\\n    allAPIid[myid].currency,\\n    allAPIid[myid].id,\\n    allAPIid[myid].dateAdd,\\n    allAPIid[myid].dateUpd\\n    );\\n  }\\n\\n  /**\\n   * @dev Updates Uint Parameters of a code\\n   * @param code whose details we want to update\\n   * @param val value to set\\n   */\\n  function updateUintParameters(bytes8 code, uint val) public {\\n    require(ms.checkIsAuthToGoverned(msg.sender));\\n    if (code == \\\"MCRTIM\\\") {\\n      _changeMCRTime(val * 1 hours);\\n\\n    } else if (code == \\\"MCRFTIM\\\") {\\n\\n      _changeMCRFailTime(val * 1 hours);\\n\\n    } else if (code == \\\"MCRMIN\\\") {\\n\\n      _changeMinCap(val);\\n\\n    } else if (code == \\\"MCRSHOCK\\\") {\\n\\n      _changeShockParameter(val);\\n\\n    } else if (code == \\\"MCRCAPL\\\") {\\n\\n      _changeCapacityLimit(val);\\n\\n    } else if (code == \\\"IMZ\\\") {\\n\\n      _changeVariationPercX100(val);\\n\\n    } else if (code == \\\"IMRATET\\\") {\\n\\n      _changeIARatesTime(val * 1 hours);\\n\\n    } else if (code == \\\"IMUNIDL\\\") {\\n\\n      _changeUniswapDeadlineTime(val * 1 minutes);\\n\\n    } else if (code == \\\"IMLIQT\\\") {\\n\\n      _changeliquidityTradeCallbackTime(val * 1 hours);\\n\\n    } else if (code == \\\"IMETHVL\\\") {\\n\\n      _setEthVolumeLimit(val);\\n\\n    } else if (code == \\\"C\\\") {\\n      _changeC(val);\\n\\n    } else if (code == \\\"A\\\") {\\n\\n      _changeA(val);\\n\\n    } else {\\n      revert(\\\"Invalid param code\\\");\\n    }\\n\\n  }\\n\\n  /**\\n   * @dev to get the average rate of currency rate\\n   * @param curr is the currency in concern\\n   * @return required rate\\n   */\\n  function getCAAvgRate(bytes4 curr) public view returns (uint rate) {\\n    return _getAvgRate(curr, false);\\n  }\\n\\n  /**\\n   * @dev to get the average rate of investment rate\\n   * @param curr is the investment in concern\\n   * @return required rate\\n   */\\n  function getIAAvgRate(bytes4 curr) public view returns (uint rate) {\\n    return _getAvgRate(curr, true);\\n  }\\n\\n  function changeDependentContractAddress() public onlyInternal {}\\n\\n  /// @dev Gets the average rate of a CA currency.\\n  /// @param curr Currency Name.\\n  /// @return rate Average rate X 100(of last 3 days).\\n  function _getAvgRate(bytes4 curr, bool isIA) internal view returns (uint rate) {\\n    if (curr == \\\"DAI\\\") {\\n      DSValue ds = DSValue(daiFeedAddress);\\n      rate = uint(ds.read()).div(uint(10) ** 16);\\n    } else if (isIA) {\\n      rate = iaAvgRate[curr];\\n    } else {\\n      rate = caAvgRate[curr];\\n    }\\n  }\\n\\n  /**\\n   * @dev to set the ethereum volume limit\\n   * @param val is the new limit value\\n   */\\n  function _setEthVolumeLimit(uint val) internal {\\n    ethVolumeLimit = val;\\n  }\\n\\n  /// @dev Sets minimum Cap.\\n  function _changeMinCap(uint newCap) internal {\\n    minCap = newCap;\\n  }\\n\\n  /// @dev Sets Shock Parameter.\\n  function _changeShockParameter(uint newParam) internal {\\n    shockParameter = newParam;\\n  }\\n\\n  /// @dev Changes time period for obtaining new MCR data from external oracle query.\\n  function _changeMCRTime(uint _time) internal {\\n    mcrTime = _time;\\n  }\\n\\n  /// @dev Sets MCR Fail time.\\n  function _changeMCRFailTime(uint _time) internal {\\n    mcrFailTime = _time;\\n  }\\n\\n  /**\\n   * @dev to change the uniswap deadline time\\n   * @param newDeadline is the value\\n   */\\n  function _changeUniswapDeadlineTime(uint newDeadline) internal {\\n    uniswapDeadline = newDeadline;\\n  }\\n\\n  /**\\n   * @dev to change the liquidity trade call back time\\n   * @param newTime is the new value to be set\\n   */\\n  function _changeliquidityTradeCallbackTime(uint newTime) internal {\\n    liquidityTradeCallbackTime = newTime;\\n  }\\n\\n  /**\\n   * @dev Changes time after which investment asset rates need to be fed.\\n   */\\n  function _changeIARatesTime(uint _newTime) internal {\\n    iaRatesTime = _newTime;\\n  }\\n\\n  /**\\n   * @dev Changes the variation range percentage.\\n   */\\n  function _changeVariationPercX100(uint newPercX100) internal {\\n    variationPercX100 = newPercX100;\\n  }\\n\\n  /// @dev Changes Growth Step\\n  function _changeC(uint newC) internal {\\n    c = newC;\\n  }\\n\\n  /// @dev Changes scaling factor.\\n  function _changeA(uint val) internal {\\n    a = val;\\n  }\\n\\n  /**\\n   * @dev to change the capacity limit\\n   * @param val is the new value\\n   */\\n  function _changeCapacityLimit(uint val) internal {\\n    capacityLimit = val;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/claims/ClaimsReward.sol\": {\r\n      \"content\": \"/* Copyright (C) 2020 NexusMutual.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\n//Claims Reward Contract contains the functions for calculating number of tokens\\n// that will get rewarded, unlocked or burned depending upon the status of claim.\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"../../interfaces/IPooledStaking.sol\\\";\\nimport \\\"../capital/Pool.sol\\\";\\nimport \\\"../cover/QuotationData.sol\\\";\\nimport \\\"../governance/Governance.sol\\\";\\nimport \\\"../token/TokenData.sol\\\";\\nimport \\\"../token/TokenFunctions.sol\\\";\\nimport \\\"./Claims.sol\\\";\\nimport \\\"./ClaimsData.sol\\\";\\n\\ncontract ClaimsReward is Iupgradable {\\n  using SafeMath for uint;\\n\\n  NXMToken internal tk;\\n  TokenController internal tc;\\n  TokenFunctions internal tf;\\n  TokenData internal td;\\n  QuotationData internal qd;\\n  Claims internal c1;\\n  ClaimsData internal cd;\\n  Pool internal pool;\\n  Governance internal gv;\\n  IPooledStaking internal pooledStaking;\\n  MemberRoles internal memberRoles;\\n\\n  // assigned in constructor\\n  address public DAI;\\n\\n  // constants\\n  address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n  uint private constant DECIMAL1E18 = uint(10) ** 18;\\n\\n  constructor (address masterAddress, address _daiAddress) public {\\n    changeMasterAddress(masterAddress);\\n    DAI = _daiAddress;\\n  }\\n\\n  function changeDependentContractAddress() public onlyInternal {\\n    c1 = Claims(ms.getLatestAddress(\\\"CL\\\"));\\n    cd = ClaimsData(ms.getLatestAddress(\\\"CD\\\"));\\n    tk = NXMToken(ms.tokenAddress());\\n    tc = TokenController(ms.getLatestAddress(\\\"TC\\\"));\\n    td = TokenData(ms.getLatestAddress(\\\"TD\\\"));\\n    tf = TokenFunctions(ms.getLatestAddress(\\\"TF\\\"));\\n    qd = QuotationData(ms.getLatestAddress(\\\"QD\\\"));\\n    gv = Governance(ms.getLatestAddress(\\\"GV\\\"));\\n    pooledStaking = IPooledStaking(ms.getLatestAddress(\\\"PS\\\"));\\n    memberRoles = MemberRoles(ms.getLatestAddress(\\\"MR\\\"));\\n    pool = Pool(ms.getLatestAddress(\\\"P1\\\"));\\n  }\\n\\n  /// @dev Decides the next course of action for a given claim.\\n  function changeClaimStatus(uint claimid) public checkPause onlyInternal {\\n\\n    (, uint coverid) = cd.getClaimCoverId(claimid);\\n    (, uint status) = cd.getClaimStatusNumber(claimid);\\n\\n    // when current status is \\\"Pending-Claim Assessor Vote\\\"\\n    if (status == 0) {\\n      _changeClaimStatusCA(claimid, coverid, status);\\n    } else if (status >= 1 && status <= 5) {\\n      _changeClaimStatusMV(claimid, coverid, status);\\n    } else if (status == 12) {// when current status is \\\"Claim Accepted Payout Pending\\\"\\n\\n      bool payoutSucceeded = attemptClaimPayout(coverid);\\n\\n      if (payoutSucceeded) {\\n        c1.setClaimStatus(claimid, 14);\\n      } else {\\n        c1.setClaimStatus(claimid, 12);\\n      }\\n    }\\n  }\\n\\n  function getCurrencyAssetAddress(bytes4 currency) public view returns (address) {\\n\\n    if (currency == \\\"ETH\\\") {\\n      return ETH;\\n    }\\n\\n    if (currency == \\\"DAI\\\") {\\n      return DAI;\\n    }\\n\\n    revert(\\\"ClaimsReward: unknown asset\\\");\\n  }\\n\\n  function attemptClaimPayout(uint coverId) internal returns (bool success) {\\n\\n    uint sumAssured = qd.getCoverSumAssured(coverId);\\n    // TODO: when adding new cover currencies, fetch the correct decimals for this multiplication\\n    uint sumAssuredWei = sumAssured.mul(1e18);\\n\\n    // get asset address\\n    bytes4 coverCurrency = qd.getCurrencyOfCover(coverId);\\n    address asset = getCurrencyAssetAddress(coverCurrency);\\n\\n    // get payout address\\n    address payable coverHolder = qd.getCoverMemberAddress(coverId);\\n    address payable payoutAddress = memberRoles.getClaimPayoutAddress(coverHolder);\\n\\n    // execute the payout\\n    bool payoutSucceeded = pool.sendClaimPayout(asset, payoutAddress, sumAssuredWei);\\n\\n    if (payoutSucceeded) {\\n\\n      // burn staked tokens\\n      (, address scAddress) = qd.getscAddressOfCover(coverId);\\n      uint tokenPrice = pool.getTokenPrice(asset);\\n\\n      // note: for new assets \\\"18\\\" needs to be replaced with target asset decimals\\n      uint burnNXMAmount = sumAssuredWei.mul(1e18).div(tokenPrice);\\n      pooledStaking.pushBurn(scAddress, burnNXMAmount);\\n\\n      // adjust total sum assured\\n      (, address coverContract) = qd.getscAddressOfCover(coverId);\\n      qd.subFromTotalSumAssured(coverCurrency, sumAssured);\\n      qd.subFromTotalSumAssuredSC(coverContract, coverCurrency, sumAssured);\\n\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  /// @dev Amount of tokens to be rewarded to a user for a particular vote id.\\n  /// @param check 1 -> CA vote, else member vote\\n  /// @param voteid vote id for which reward has to be Calculated\\n  /// @param flag if 1 calculate even if claimed,else don't calculate if already claimed\\n  /// @return tokenCalculated reward to be given for vote id\\n  /// @return lastClaimedCheck true if final verdict is still pending for that voteid\\n  /// @return tokens number of tokens locked under that voteid\\n  /// @return perc percentage of reward to be given.\\n  function getRewardToBeGiven(\\n    uint check,\\n    uint voteid,\\n    uint flag\\n  )\\n  public\\n  view\\n  returns (\\n    uint tokenCalculated,\\n    bool lastClaimedCheck,\\n    uint tokens,\\n    uint perc\\n  )\\n\\n  {\\n    uint claimId;\\n    int8 verdict;\\n    bool claimed;\\n    uint tokensToBeDist;\\n    uint totalTokens;\\n    (tokens, claimId, verdict, claimed) = cd.getVoteDetails(voteid);\\n    lastClaimedCheck = false;\\n    int8 claimVerdict = cd.getFinalVerdict(claimId);\\n    if (claimVerdict == 0) {\\n      lastClaimedCheck = true;\\n    }\\n\\n    if (claimVerdict == verdict && (claimed == false || flag == 1)) {\\n\\n      if (check == 1) {\\n        (perc, , tokensToBeDist) = cd.getClaimRewardDetail(claimId);\\n      } else {\\n        (, perc, tokensToBeDist) = cd.getClaimRewardDetail(claimId);\\n      }\\n\\n      if (perc > 0) {\\n        if (check == 1) {\\n          if (verdict == 1) {\\n            (, totalTokens,) = cd.getClaimsTokenCA(claimId);\\n          } else {\\n            (,, totalTokens) = cd.getClaimsTokenCA(claimId);\\n          }\\n        } else {\\n          if (verdict == 1) {\\n            (, totalTokens,) = cd.getClaimsTokenMV(claimId);\\n          } else {\\n            (,, totalTokens) = cd.getClaimsTokenMV(claimId);\\n          }\\n        }\\n        tokenCalculated = (perc.mul(tokens).mul(tokensToBeDist)).div(totalTokens.mul(100));\\n\\n\\n      }\\n    }\\n  }\\n\\n  /// @dev Transfers all tokens held by contract to a new contract in case of upgrade.\\n  function upgrade(address _newAdd) public onlyInternal {\\n    uint amount = tk.balanceOf(address(this));\\n    if (amount > 0) {\\n      require(tk.transfer(_newAdd, amount));\\n    }\\n\\n  }\\n\\n  /// @dev Total reward in token due for claim by a user.\\n  /// @return total total number of tokens\\n  function getRewardToBeDistributedByUser(address _add) public view returns (uint total) {\\n    uint lengthVote = cd.getVoteAddressCALength(_add);\\n    uint lastIndexCA;\\n    uint lastIndexMV;\\n    uint tokenForVoteId;\\n    uint voteId;\\n    (lastIndexCA, lastIndexMV) = cd.getRewardDistributedIndex(_add);\\n\\n    for (uint i = lastIndexCA; i < lengthVote; i++) {\\n      voteId = cd.getVoteAddressCA(_add, i);\\n      (tokenForVoteId,,,) = getRewardToBeGiven(1, voteId, 0);\\n      total = total.add(tokenForVoteId);\\n    }\\n\\n    lengthVote = cd.getVoteAddressMemberLength(_add);\\n\\n    for (uint j = lastIndexMV; j < lengthVote; j++) {\\n      voteId = cd.getVoteAddressMember(_add, j);\\n      (tokenForVoteId,,,) = getRewardToBeGiven(0, voteId, 0);\\n      total = total.add(tokenForVoteId);\\n    }\\n    return (total);\\n  }\\n\\n  /// @dev Gets reward amount and claiming status for a given claim id.\\n  /// @return reward amount of tokens to user.\\n  /// @return claimed true if already claimed false if yet to be claimed.\\n  function getRewardAndClaimedStatus(uint check, uint claimId) public view returns (uint reward, bool claimed) {\\n    uint voteId;\\n    uint claimid;\\n    uint lengthVote;\\n\\n    if (check == 1) {\\n      lengthVote = cd.getVoteAddressCALength(msg.sender);\\n      for (uint i = 0; i < lengthVote; i++) {\\n        voteId = cd.getVoteAddressCA(msg.sender, i);\\n        (, claimid, , claimed) = cd.getVoteDetails(voteId);\\n        if (claimid == claimId) {break;}\\n      }\\n    } else {\\n      lengthVote = cd.getVoteAddressMemberLength(msg.sender);\\n      for (uint j = 0; j < lengthVote; j++) {\\n        voteId = cd.getVoteAddressMember(msg.sender, j);\\n        (, claimid, , claimed) = cd.getVoteDetails(voteId);\\n        if (claimid == claimId) {break;}\\n      }\\n    }\\n    (reward,,,) = getRewardToBeGiven(check, voteId, 1);\\n\\n  }\\n\\n  /**\\n   * @dev Function used to claim all pending rewards : Claims Assessment + Risk Assessment + Governance\\n   * Claim assesment, Risk assesment, Governance rewards\\n   */\\n  function claimAllPendingReward(uint records) public isMemberAndcheckPause {\\n    _claimRewardToBeDistributed(records);\\n    pooledStaking.withdrawReward(msg.sender);\\n    uint governanceRewards = gv.claimReward(msg.sender, records);\\n    if (governanceRewards > 0) {\\n      require(tk.transfer(msg.sender, governanceRewards));\\n    }\\n  }\\n\\n  /**\\n   * @dev Function used to get pending rewards of a particular user address.\\n   * @param _add user address.\\n   * @return total reward amount of the user\\n   */\\n  function getAllPendingRewardOfUser(address _add) public view returns (uint) {\\n    uint caReward = getRewardToBeDistributedByUser(_add);\\n    uint pooledStakingReward = pooledStaking.stakerReward(_add);\\n    uint governanceReward = gv.getPendingReward(_add);\\n    return caReward.add(pooledStakingReward).add(governanceReward);\\n  }\\n\\n  /// @dev Rewards/Punishes users who  participated in Claims assessment.\\n  //    Unlocking and burning of the tokens will also depend upon the status of claim.\\n  /// @param claimid Claim Id.\\n  function _rewardAgainstClaim(uint claimid, uint coverid, uint status) internal {\\n\\n    uint premiumNXM = qd.getCoverPremiumNXM(coverid);\\n    uint distributableTokens = premiumNXM.mul(cd.claimRewardPerc()).div(100); // 20% of premium\\n\\n    uint percCA;\\n    uint percMV;\\n\\n    (percCA, percMV) = cd.getRewardStatus(status);\\n    cd.setClaimRewardDetail(claimid, percCA, percMV, distributableTokens);\\n\\n    if (percCA > 0 || percMV > 0) {\\n      tc.mint(address(this), distributableTokens);\\n    }\\n\\n    // denied\\n    if (status == 6 || status == 9 || status == 11) {\\n\\n      cd.changeFinalVerdict(claimid, -1);\\n      tc.markCoverClaimClosed(coverid, false);\\n      tf.burnDepositCN(coverid); // burn Deposited CN\\n\\n    // accepted\\n    } else if (status == 7 || status == 8 || status == 10) {\\n\\n      cd.changeFinalVerdict(claimid, 1);\\n      tc.markCoverClaimClosed(coverid, true);\\n      tf.unlockCN(coverid);\\n\\n      bool payoutSucceeded = attemptClaimPayout(coverid);\\n\\n      // 12 = payout pending, 14 = payout succeeded\\n      uint nextStatus = payoutSucceeded ? 14 : 12;\\n      c1.setClaimStatus(claimid, nextStatus);\\n    }\\n  }\\n\\n  /// @dev Computes the result of Claim Assessors Voting for a given claim id.\\n  function _changeClaimStatusCA(uint claimid, uint coverid, uint status) internal {\\n    // Check if voting should be closed or not\\n    if (c1.checkVoteClosing(claimid) == 1) {\\n      uint caTokens = c1.getCATokens(claimid, 0); // converted in cover currency.\\n      uint accept;\\n      uint deny;\\n      uint acceptAndDeny;\\n      bool rewardOrPunish;\\n      uint sumAssured;\\n      (, accept) = cd.getClaimVote(claimid, 1);\\n      (, deny) = cd.getClaimVote(claimid, - 1);\\n      acceptAndDeny = accept.add(deny);\\n      accept = accept.mul(100);\\n      deny = deny.mul(100);\\n\\n      if (caTokens == 0) {\\n        status = 3;\\n      } else {\\n        sumAssured = qd.getCoverSumAssured(coverid).mul(DECIMAL1E18);\\n        // Min threshold reached tokens used for voting > 5* sum assured\\n        if (caTokens > sumAssured.mul(5)) {\\n\\n          if (accept.div(acceptAndDeny) > 70) {\\n            status = 7;\\n            qd.changeCoverStatusNo(coverid, uint8(QuotationData.CoverStatus.ClaimAccepted));\\n            rewardOrPunish = true;\\n          } else if (deny.div(acceptAndDeny) > 70) {\\n            status = 6;\\n            qd.changeCoverStatusNo(coverid, uint8(QuotationData.CoverStatus.ClaimDenied));\\n            rewardOrPunish = true;\\n          } else if (accept.div(acceptAndDeny) > deny.div(acceptAndDeny)) {\\n            status = 4;\\n          } else {\\n            status = 5;\\n          }\\n\\n        } else {\\n\\n          if (accept.div(acceptAndDeny) > deny.div(acceptAndDeny)) {\\n            status = 2;\\n          } else {\\n            status = 3;\\n          }\\n        }\\n      }\\n\\n      c1.setClaimStatus(claimid, status);\\n\\n      if (rewardOrPunish) {\\n        _rewardAgainstClaim(claimid, coverid, status);\\n      }\\n    }\\n  }\\n\\n  /// @dev Computes the result of Member Voting for a given claim id.\\n  function _changeClaimStatusMV(uint claimid, uint coverid, uint status) internal {\\n\\n    // Check if voting should be closed or not\\n    if (c1.checkVoteClosing(claimid) == 1) {\\n      uint8 coverStatus;\\n      uint statusOrig = status;\\n      uint mvTokens = c1.getCATokens(claimid, 1); // converted in cover currency.\\n\\n      // If tokens used for acceptance >50%, claim is accepted\\n      uint sumAssured = qd.getCoverSumAssured(coverid).mul(DECIMAL1E18);\\n      uint thresholdUnreached = 0;\\n      // Minimum threshold for member voting is reached only when\\n      // value of tokens used for voting > 5* sum assured of claim id\\n      if (mvTokens < sumAssured.mul(5)) {\\n        thresholdUnreached = 1;\\n      }\\n\\n      uint accept;\\n      (, accept) = cd.getClaimMVote(claimid, 1);\\n      uint deny;\\n      (, deny) = cd.getClaimMVote(claimid, - 1);\\n\\n      if (accept.add(deny) > 0) {\\n        if (accept.mul(100).div(accept.add(deny)) >= 50 && statusOrig > 1 &&\\n        statusOrig <= 5 && thresholdUnreached == 0) {\\n          status = 8;\\n          coverStatus = uint8(QuotationData.CoverStatus.ClaimAccepted);\\n        } else if (deny.mul(100).div(accept.add(deny)) >= 50 && statusOrig > 1 &&\\n        statusOrig <= 5 && thresholdUnreached == 0) {\\n          status = 9;\\n          coverStatus = uint8(QuotationData.CoverStatus.ClaimDenied);\\n        }\\n      }\\n\\n      if (thresholdUnreached == 1 && (statusOrig == 2 || statusOrig == 4)) {\\n        status = 10;\\n        coverStatus = uint8(QuotationData.CoverStatus.ClaimAccepted);\\n      } else if (thresholdUnreached == 1 && (statusOrig == 5 || statusOrig == 3 || statusOrig == 1)) {\\n        status = 11;\\n        coverStatus = uint8(QuotationData.CoverStatus.ClaimDenied);\\n      }\\n\\n      c1.setClaimStatus(claimid, status);\\n      qd.changeCoverStatusNo(coverid, uint8(coverStatus));\\n      // Reward/Punish Claim Assessors and Members who participated in Claims assessment\\n      _rewardAgainstClaim(claimid, coverid, status);\\n    }\\n  }\\n\\n  /// @dev Allows a user to claim all pending  Claims assessment rewards.\\n  function _claimRewardToBeDistributed(uint _records) internal {\\n    uint lengthVote = cd.getVoteAddressCALength(msg.sender);\\n    uint voteid;\\n    uint lastIndex;\\n    (lastIndex,) = cd.getRewardDistributedIndex(msg.sender);\\n    uint total = 0;\\n    uint tokenForVoteId = 0;\\n    bool lastClaimedCheck;\\n    uint _days = td.lockCADays();\\n    bool claimed;\\n    uint counter = 0;\\n    uint claimId;\\n    uint perc;\\n    uint i;\\n    uint lastClaimed = lengthVote;\\n\\n    for (i = lastIndex; i < lengthVote && counter < _records; i++) {\\n      voteid = cd.getVoteAddressCA(msg.sender, i);\\n      (tokenForVoteId, lastClaimedCheck, , perc) = getRewardToBeGiven(1, voteid, 0);\\n      if (lastClaimed == lengthVote && lastClaimedCheck == true) {\\n        lastClaimed = i;\\n      }\\n      (, claimId, , claimed) = cd.getVoteDetails(voteid);\\n\\n      if (perc > 0 && !claimed) {\\n        counter++;\\n        cd.setRewardClaimed(voteid, true);\\n      } else if (perc == 0 && cd.getFinalVerdict(claimId) != 0 && !claimed) {\\n        (perc,,) = cd.getClaimRewardDetail(claimId);\\n        if (perc == 0) {\\n          counter++;\\n        }\\n        cd.setRewardClaimed(voteid, true);\\n      }\\n      if (tokenForVoteId > 0) {\\n        total = tokenForVoteId.add(total);\\n      }\\n    }\\n    if (lastClaimed == lengthVote) {\\n      cd.setRewardDistributedIndexCA(msg.sender, i);\\n    }\\n    else {\\n      cd.setRewardDistributedIndexCA(msg.sender, lastClaimed);\\n    }\\n    lengthVote = cd.getVoteAddressMemberLength(msg.sender);\\n    lastClaimed = lengthVote;\\n    _days = _days.mul(counter);\\n    if (tc.tokensLockedAtTime(msg.sender, \\\"CLA\\\", now) > 0) {\\n      tc.reduceLock(msg.sender, \\\"CLA\\\", _days);\\n    }\\n    (, lastIndex) = cd.getRewardDistributedIndex(msg.sender);\\n    lastClaimed = lengthVote;\\n    counter = 0;\\n    for (i = lastIndex; i < lengthVote && counter < _records; i++) {\\n      voteid = cd.getVoteAddressMember(msg.sender, i);\\n      (tokenForVoteId, lastClaimedCheck,,) = getRewardToBeGiven(0, voteid, 0);\\n      if (lastClaimed == lengthVote && lastClaimedCheck == true) {\\n        lastClaimed = i;\\n      }\\n      (, claimId, , claimed) = cd.getVoteDetails(voteid);\\n      if (claimed == false && cd.getFinalVerdict(claimId) != 0) {\\n        cd.setRewardClaimed(voteid, true);\\n        counter++;\\n      }\\n      if (tokenForVoteId > 0) {\\n        total = tokenForVoteId.add(total);\\n      }\\n    }\\n    if (total > 0) {\\n      require(tk.transfer(msg.sender, total));\\n    }\\n    if (lastClaimed == lengthVote) {\\n      cd.setRewardDistributedIndexMV(msg.sender, i);\\n    }\\n    else {\\n      cd.setRewardDistributedIndexMV(msg.sender, lastClaimed);\\n    }\\n  }\\n\\n  /**\\n   * @dev Function used to claim the commission earned by the staker.\\n   */\\n  function _claimStakeCommission(uint _records, address _user) external onlyInternal {\\n    uint total = 0;\\n    uint len = td.getStakerStakedContractLength(_user);\\n    uint lastCompletedStakeCommission = td.lastCompletedStakeCommission(_user);\\n    uint commissionEarned;\\n    uint commissionRedeemed;\\n    uint maxCommission;\\n    uint lastCommisionRedeemed = len;\\n    uint counter;\\n    uint i;\\n\\n    for (i = lastCompletedStakeCommission; i < len && counter < _records; i++) {\\n      commissionRedeemed = td.getStakerRedeemedStakeCommission(_user, i);\\n      commissionEarned = td.getStakerEarnedStakeCommission(_user, i);\\n      maxCommission = td.getStakerInitialStakedAmountOnContract(\\n        _user, i).mul(td.stakerMaxCommissionPer()).div(100);\\n      if (lastCommisionRedeemed == len && maxCommission != commissionEarned)\\n        lastCommisionRedeemed = i;\\n      td.pushRedeemedStakeCommissions(_user, i, commissionEarned.sub(commissionRedeemed));\\n      total = total.add(commissionEarned.sub(commissionRedeemed));\\n      counter++;\\n    }\\n    if (lastCommisionRedeemed == len) {\\n      td.setLastCompletedStakeCommissionIndex(_user, i);\\n    } else {\\n      td.setLastCompletedStakeCommissionIndex(_user, lastCommisionRedeemed);\\n    }\\n\\n    if (total > 0)\\n      require(tk.transfer(_user, total)); // solhint-disable-line\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/modules/governance/MemberRoles.sol\": {\r\n      \"content\": \"/* Copyright (C) 2017 GovBlocks.io\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"../claims/ClaimsReward.sol\\\";\\nimport \\\"../cover/QuotationData.sol\\\";\\nimport \\\"../token/TokenController.sol\\\";\\nimport \\\"../token/TokenData.sol\\\";\\nimport \\\"../token/TokenFunctions.sol\\\";\\nimport \\\"./Governance.sol\\\";\\nimport \\\"./external/Governed.sol\\\";\\n\\ncontract MemberRoles is Governed, Iupgradable {\\n\\n  TokenController public tc;\\n  TokenData internal td;\\n  QuotationData internal qd;\\n  ClaimsReward internal cr;\\n  Governance internal gv;\\n  TokenFunctions internal tf;\\n  NXMToken public tk;\\n\\n  struct MemberRoleDetails {\\n    uint memberCounter;\\n    mapping(address => bool) memberActive;\\n    address[] memberAddress;\\n    address authorized;\\n  }\\n\\n  enum Role {UnAssigned, AdvisoryBoard, Member, Owner}\\n\\n  event MemberRole(uint256 indexed roleId, bytes32 roleName, string roleDescription);\\n\\n  event switchedMembership(address indexed previousMember, address indexed newMember, uint timeStamp);\\n\\n  event ClaimPayoutAddressSet(address indexed member, address indexed payoutAddress);\\n\\n  MemberRoleDetails[] internal memberRoleData;\\n  bool internal constructorCheck;\\n  uint public maxABCount;\\n  bool public launched;\\n  uint public launchedOn;\\n\\n  mapping (address => address payable) internal claimPayoutAddress;\\n\\n  modifier checkRoleAuthority(uint _memberRoleId) {\\n    if (memberRoleData[_memberRoleId].authorized != address(0))\\n      require(msg.sender == memberRoleData[_memberRoleId].authorized);\\n    else\\n      require(isAuthorizedToGovern(msg.sender), \\\"Not Authorized\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev to swap advisory board member\\n   * @param _newABAddress is address of new AB member\\n   * @param _removeAB is advisory board member to be removed\\n   */\\n  function swapABMember(\\n    address _newABAddress,\\n    address _removeAB\\n  )\\n  external\\n  checkRoleAuthority(uint(Role.AdvisoryBoard)) {\\n\\n    _updateRole(_newABAddress, uint(Role.AdvisoryBoard), true);\\n    _updateRole(_removeAB, uint(Role.AdvisoryBoard), false);\\n\\n  }\\n\\n  /**\\n   * @dev to swap the owner address\\n   * @param _newOwnerAddress is the new owner address\\n   */\\n  function swapOwner(\\n    address _newOwnerAddress\\n  )\\n  external {\\n    require(msg.sender == address(ms));\\n    _updateRole(ms.owner(), uint(Role.Owner), false);\\n    _updateRole(_newOwnerAddress, uint(Role.Owner), true);\\n  }\\n\\n  /**\\n   * @dev is used to add initital advisory board members\\n   * @param abArray is the list of initial advisory board members\\n   */\\n  function addInitialABMembers(address[] calldata abArray) external onlyOwner {\\n\\n    //Ensure that NXMaster has initialized.\\n    require(ms.masterInitialized());\\n\\n    require(maxABCount >=\\n      SafeMath.add(numberOfMembers(uint(Role.AdvisoryBoard)), abArray.length)\\n    );\\n    //AB count can't exceed maxABCount\\n    for (uint i = 0; i < abArray.length; i++) {\\n      require(checkRole(abArray[i], uint(MemberRoles.Role.Member)));\\n      _updateRole(abArray[i], uint(Role.AdvisoryBoard), true);\\n    }\\n  }\\n\\n  /**\\n   * @dev to change max number of AB members allowed\\n   * @param _val is the new value to be set\\n   */\\n  function changeMaxABCount(uint _val) external onlyInternal {\\n    maxABCount = _val;\\n  }\\n\\n  /**\\n   * @dev Iupgradable Interface to update dependent contract address\\n   */\\n  function changeDependentContractAddress() public {\\n    td = TokenData(ms.getLatestAddress(\\\"TD\\\"));\\n    cr = ClaimsReward(ms.getLatestAddress(\\\"CR\\\"));\\n    qd = QuotationData(ms.getLatestAddress(\\\"QD\\\"));\\n    gv = Governance(ms.getLatestAddress(\\\"GV\\\"));\\n    tf = TokenFunctions(ms.getLatestAddress(\\\"TF\\\"));\\n    tk = NXMToken(ms.tokenAddress());\\n    tc = TokenController(ms.getLatestAddress(\\\"TC\\\"));\\n  }\\n\\n  /**\\n   * @dev to change the master address\\n   * @param _masterAddress is the new master address\\n   */\\n  function changeMasterAddress(address _masterAddress) public {\\n\\n    if (masterAddress != address(0)) {\\n      require(masterAddress == msg.sender);\\n    }\\n\\n    masterAddress = _masterAddress;\\n    ms = INXMMaster(_masterAddress);\\n    nxMasterAddress = _masterAddress;\\n  }\\n\\n  /**\\n   * @dev to initiate the member roles\\n   * @param _firstAB is the address of the first AB member\\n   * @param memberAuthority is the authority (role) of the member\\n   */\\n  function memberRolesInitiate(address _firstAB, address memberAuthority) public {\\n    require(!constructorCheck);\\n    _addInitialMemberRoles(_firstAB, memberAuthority);\\n    constructorCheck = true;\\n  }\\n\\n  /// @dev Adds new member role\\n  /// @param _roleName New role name\\n  /// @param _roleDescription New description hash\\n  /// @param _authorized Authorized member against every role id\\n  function addRole(//solhint-disable-line\\n    bytes32 _roleName,\\n    string memory _roleDescription,\\n    address _authorized\\n  )\\n  public\\n  onlyAuthorizedToGovern {\\n    _addRole(_roleName, _roleDescription, _authorized);\\n  }\\n\\n  /// @dev Assign or Delete a member from specific role.\\n  /// @param _memberAddress Address of Member\\n  /// @param _roleId RoleId to update\\n  /// @param _active active is set to be True if we want to assign this role to member, False otherwise!\\n  function updateRole(//solhint-disable-line\\n    address _memberAddress,\\n    uint _roleId,\\n    bool _active\\n  )\\n  public\\n  checkRoleAuthority(_roleId) {\\n    _updateRole(_memberAddress, _roleId, _active);\\n  }\\n\\n  /**\\n   * @dev to add members before launch\\n   * @param userArray is list of addresses of members\\n   * @param tokens is list of tokens minted for each array element\\n   */\\n  function addMembersBeforeLaunch(address[] memory userArray, uint[] memory tokens) public onlyOwner {\\n    require(!launched);\\n\\n    for (uint i = 0; i < userArray.length; i++) {\\n      require(!ms.isMember(userArray[i]));\\n      tc.addToWhitelist(userArray[i]);\\n      _updateRole(userArray[i], uint(Role.Member), true);\\n      tc.mint(userArray[i], tokens[i]);\\n    }\\n    launched = true;\\n    launchedOn = now;\\n\\n  }\\n\\n  /**\\n    * @dev Called by user to pay joining membership fee\\n    */\\n  function payJoiningFee(address _userAddress) public payable {\\n    require(_userAddress != address(0));\\n    require(!ms.isPause(), \\\"Emergency Pause Applied\\\");\\n    if (msg.sender == address(ms.getLatestAddress(\\\"QT\\\"))) {\\n      require(td.walletAddress() != address(0), \\\"No walletAddress present\\\");\\n      tc.addToWhitelist(_userAddress);\\n      _updateRole(_userAddress, uint(Role.Member), true);\\n      td.walletAddress().transfer(msg.value);\\n    } else {\\n      require(!qd.refundEligible(_userAddress));\\n      require(!ms.isMember(_userAddress));\\n      require(msg.value == td.joiningFee());\\n      qd.setRefundEligible(_userAddress, true);\\n    }\\n  }\\n\\n  /**\\n   * @dev to perform kyc verdict\\n   * @param _userAddress whose kyc is being performed\\n   * @param verdict of kyc process\\n   */\\n  function kycVerdict(address payable _userAddress, bool verdict) public {\\n\\n    require(msg.sender == qd.kycAuthAddress());\\n    require(!ms.isPause());\\n    require(_userAddress != address(0));\\n    require(!ms.isMember(_userAddress));\\n    require(qd.refundEligible(_userAddress));\\n    if (verdict) {\\n      qd.setRefundEligible(_userAddress, false);\\n      uint fee = td.joiningFee();\\n      tc.addToWhitelist(_userAddress);\\n      _updateRole(_userAddress, uint(Role.Member), true);\\n      td.walletAddress().transfer(fee); // solhint-disable-line\\n\\n    } else {\\n      qd.setRefundEligible(_userAddress, false);\\n      _userAddress.transfer(td.joiningFee()); // solhint-disable-line\\n    }\\n  }\\n\\n  /**\\n   * @dev withdraws membership for msg.sender if currently a member.\\n   */\\n  function withdrawMembership() public {\\n\\n    require(!ms.isPause() && ms.isMember(msg.sender));\\n    require(tc.totalLockedBalance(msg.sender) == 0); // solhint-disable-line\\n    require(!tf.isLockedForMemberVote(msg.sender)); // No locked tokens for Member/Governance voting\\n    require(cr.getAllPendingRewardOfUser(msg.sender) == 0); // No pending reward to be claimed(claim assesment).\\n\\n    gv.removeDelegation(msg.sender);\\n    tc.burnFrom(msg.sender, tk.balanceOf(msg.sender));\\n    _updateRole(msg.sender, uint(Role.Member), false);\\n    tc.removeFromWhitelist(msg.sender); // need clarification on whitelist\\n\\n    if (claimPayoutAddress[msg.sender] != address(0)) {\\n      claimPayoutAddress[msg.sender] = address(0);\\n      emit ClaimPayoutAddressSet(msg.sender, address(0));\\n    }\\n  }\\n\\n  /**\\n   * @dev switches membership for msg.sender to the specified address.\\n   * @param newAddress address of user to forward membership.\\n   */\\n  function switchMembership(address newAddress) external {\\n    _switchMembership(msg.sender, newAddress);\\n    tk.transferFrom(msg.sender, newAddress, tk.balanceOf(msg.sender));\\n  }\\n\\n  function switchMembershipOf(address member, address newAddress) external onlyInternal {\\n    _switchMembership(member, newAddress);\\n  }\\n\\n  /**\\n   * @dev switches membership for member to the specified address.\\n   * @param newAddress address of user to forward membership.\\n   */\\n  function _switchMembership(address member, address newAddress) internal {\\n\\n    require(!ms.isPause() && ms.isMember(member) && !ms.isMember(newAddress));\\n    require(tc.totalLockedBalance(member) == 0); // solhint-disable-line\\n    require(!tf.isLockedForMemberVote(member)); // No locked tokens for Member/Governance voting\\n    require(cr.getAllPendingRewardOfUser(member) == 0); // No pending reward to be claimed(claim assesment).\\n\\n    gv.removeDelegation(member);\\n    tc.addToWhitelist(newAddress);\\n    _updateRole(newAddress, uint(Role.Member), true);\\n    _updateRole(member, uint(Role.Member), false);\\n    tc.removeFromWhitelist(member);\\n\\n    address payable previousPayoutAddress = claimPayoutAddress[member];\\n\\n    if (previousPayoutAddress != address(0)) {\\n\\n      address payable storedAddress = previousPayoutAddress == newAddress ? address(0) : previousPayoutAddress;\\n\\n      claimPayoutAddress[member] = address(0);\\n      claimPayoutAddress[newAddress] = storedAddress;\\n\\n      // emit event for old address reset\\n      emit ClaimPayoutAddressSet(member, address(0));\\n\\n      if (storedAddress != address(0)) {\\n        // emit event for setting the payout address on the new member address if it's non zero\\n        emit ClaimPayoutAddressSet(newAddress, storedAddress);\\n      }\\n    }\\n\\n    emit switchedMembership(member, newAddress, now);\\n  }\\n\\n  function getClaimPayoutAddress(address payable _member) external view returns (address payable) {\\n    address payable payoutAddress = claimPayoutAddress[_member];\\n    return payoutAddress != address(0) ? payoutAddress : _member;\\n  }\\n\\n  function setClaimPayoutAddress(address payable _address) external {\\n\\n    require(!ms.isPause(), \\\"system is paused\\\");\\n    require(ms.isMember(msg.sender), \\\"sender is not a member\\\");\\n    require(_address != msg.sender, \\\"should be different than the member address\\\");\\n\\n    claimPayoutAddress[msg.sender] = _address;\\n    emit ClaimPayoutAddressSet(msg.sender, _address);\\n  }\\n\\n  /// @dev Return number of member roles\\n  function totalRoles() public view returns (uint256) {//solhint-disable-line\\n    return memberRoleData.length;\\n  }\\n\\n  /// @dev Change Member Address who holds the authority to Add/Delete any member from specific role.\\n  /// @param _roleId roleId to update its Authorized Address\\n  /// @param _newAuthorized New authorized address against role id\\n  function changeAuthorized(uint _roleId, address _newAuthorized) public checkRoleAuthority(_roleId) {//solhint-disable-line\\n    memberRoleData[_roleId].authorized = _newAuthorized;\\n  }\\n\\n  /// @dev Gets the member addresses assigned by a specific role\\n  /// @param _memberRoleId Member role id\\n  /// @return roleId Role id\\n  /// @return allMemberAddress Member addresses of specified role id\\n  function members(uint _memberRoleId) public view returns (uint, address[] memory memberArray) {//solhint-disable-line\\n    uint length = memberRoleData[_memberRoleId].memberAddress.length;\\n    uint i;\\n    uint j = 0;\\n    memberArray = new address[](memberRoleData[_memberRoleId].memberCounter);\\n    for (i = 0; i < length; i++) {\\n      address member = memberRoleData[_memberRoleId].memberAddress[i];\\n      if (memberRoleData[_memberRoleId].memberActive[member] && !_checkMemberInArray(member, memberArray)) {//solhint-disable-line\\n        memberArray[j] = member;\\n        j++;\\n      }\\n    }\\n\\n    return (_memberRoleId, memberArray);\\n  }\\n\\n  /// @dev Gets all members' length\\n  /// @param _memberRoleId Member role id\\n  /// @return memberRoleData[_memberRoleId].memberCounter Member length\\n  function numberOfMembers(uint _memberRoleId) public view returns (uint) {//solhint-disable-line\\n    return memberRoleData[_memberRoleId].memberCounter;\\n  }\\n\\n  /// @dev Return member address who holds the right to add/remove any member from specific role.\\n  function authorized(uint _memberRoleId) public view returns (address) {//solhint-disable-line\\n    return memberRoleData[_memberRoleId].authorized;\\n  }\\n\\n  /// @dev Get All role ids array that has been assigned to a member so far.\\n  function roles(address _memberAddress) public view returns (uint[] memory) {//solhint-disable-line\\n    uint length = memberRoleData.length;\\n    uint[] memory assignedRoles = new uint[](length);\\n    uint counter = 0;\\n    for (uint i = 1; i < length; i++) {\\n      if (memberRoleData[i].memberActive[_memberAddress]) {\\n        assignedRoles[counter] = i;\\n        counter++;\\n      }\\n    }\\n    return assignedRoles;\\n  }\\n\\n  /// @dev Returns true if the given role id is assigned to a member.\\n  /// @param _memberAddress Address of member\\n  /// @param _roleId Checks member's authenticity with the roleId.\\n  /// i.e. Returns true if this roleId is assigned to member\\n  function checkRole(address _memberAddress, uint _roleId) public view returns (bool) {//solhint-disable-line\\n    if (_roleId == uint(Role.UnAssigned))\\n      return true;\\n    else\\n      if (memberRoleData[_roleId].memberActive[_memberAddress]) //solhint-disable-line\\n        return true;\\n      else\\n        return false;\\n  }\\n\\n  /// @dev Return total number of members assigned against each role id.\\n  /// @return totalMembers Total members in particular role id\\n  function getMemberLengthForAllRoles() public view returns (uint[] memory totalMembers) {//solhint-disable-line\\n    totalMembers = new uint[](memberRoleData.length);\\n    for (uint i = 0; i < memberRoleData.length; i++) {\\n      totalMembers[i] = numberOfMembers(i);\\n    }\\n  }\\n\\n  /**\\n   * @dev to update the member roles\\n   * @param _memberAddress in concern\\n   * @param _roleId the id of role\\n   * @param _active if active is true, add the member, else remove it\\n   */\\n  function _updateRole(address _memberAddress,\\n    uint _roleId,\\n    bool _active) internal {\\n    // require(_roleId != uint(Role.TokenHolder), \\\"Membership to Token holder is detected automatically\\\");\\n    if (_active) {\\n      require(!memberRoleData[_roleId].memberActive[_memberAddress]);\\n      memberRoleData[_roleId].memberCounter = SafeMath.add(memberRoleData[_roleId].memberCounter, 1);\\n      memberRoleData[_roleId].memberActive[_memberAddress] = true;\\n      memberRoleData[_roleId].memberAddress.push(_memberAddress);\\n    } else {\\n      require(memberRoleData[_roleId].memberActive[_memberAddress]);\\n      memberRoleData[_roleId].memberCounter = SafeMath.sub(memberRoleData[_roleId].memberCounter, 1);\\n      delete memberRoleData[_roleId].memberActive[_memberAddress];\\n    }\\n  }\\n\\n  /// @dev Adds new member role\\n  /// @param _roleName New role name\\n  /// @param _roleDescription New description hash\\n  /// @param _authorized Authorized member against every role id\\n  function _addRole(\\n    bytes32 _roleName,\\n    string memory _roleDescription,\\n    address _authorized\\n  ) internal {\\n    emit MemberRole(memberRoleData.length, _roleName, _roleDescription);\\n    memberRoleData.push(MemberRoleDetails(0, new address[](0), _authorized));\\n  }\\n\\n  /**\\n   * @dev to check if member is in the given member array\\n   * @param _memberAddress in concern\\n   * @param memberArray in concern\\n   * @return boolean to represent the presence\\n   */\\n  function _checkMemberInArray(\\n    address _memberAddress,\\n    address[] memory memberArray\\n  )\\n  internal\\n  pure\\n  returns (bool memberExists)\\n  {\\n    uint i;\\n    for (i = 0; i < memberArray.length; i++) {\\n      if (memberArray[i] == _memberAddress) {\\n        memberExists = true;\\n        break;\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @dev to add initial member roles\\n   * @param _firstAB is the member address to be added\\n   * @param memberAuthority is the member authority(role) to be added for\\n   */\\n  function _addInitialMemberRoles(address _firstAB, address memberAuthority) internal {\\n    maxABCount = 5;\\n    _addRole(\\\"Unassigned\\\", \\\"Unassigned\\\", address(0));\\n    _addRole(\\n      \\\"Advisory Board\\\",\\n      \\\"Selected few members that are deeply entrusted by the dApp. An ideal advisory board should be a mix of skills of domain, governance, research, technology, consulting etc to improve the performance of the dApp.\\\", //solhint-disable-line\\n      address(0)\\n    );\\n    _addRole(\\n      \\\"Member\\\",\\n      \\\"Represents all users of Mutual.\\\", //solhint-disable-line\\n      memberAuthority\\n    );\\n    _addRole(\\n      \\\"Owner\\\",\\n      \\\"Represents Owner of Mutual.\\\", //solhint-disable-line\\n      address(0)\\n    );\\n    // _updateRole(_firstAB, uint(Role.AdvisoryBoard), true);\\n    _updateRole(_firstAB, uint(Role.Owner), true);\\n    // _updateRole(_firstAB, uint(Role.Member), true);\\n    launchedOn = 0;\\n  }\\n\\n  function memberAtIndex(uint _memberRoleId, uint index) external view returns (address, bool) {\\n    address memberAddress = memberRoleData[_memberRoleId].memberAddress[index];\\n    return (memberAddress, memberRoleData[_memberRoleId].memberActive[memberAddress]);\\n  }\\n\\n  function membersLength(uint _memberRoleId) external view returns (uint) {\\n    return memberRoleData[_memberRoleId].memberAddress.length;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/token/TokenController.sol\": {\r\n      \"content\": \"/* Copyright (C) 2020 NexusMutual.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n  it under the terms of the GNU General Public License as published by\\n  the Free Software Foundation, either version 3 of the License, or\\n  (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n  GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n  along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../../abstract/Iupgradable.sol\\\";\\nimport \\\"../../interfaces/IPooledStaking.sol\\\";\\nimport \\\"../claims/ClaimsData.sol\\\";\\nimport \\\"./NXMToken.sol\\\";\\nimport \\\"./external/LockHandler.sol\\\";\\n\\ncontract TokenController is LockHandler, Iupgradable {\\n  using SafeMath for uint256;\\n\\n  struct CoverInfo {\\n    uint16 claimCount;\\n    bool hasOpenClaim;\\n    bool hasAcceptedClaim;\\n    // note: still 224 bits available here, can be used later\\n  }\\n\\n  NXMToken public token;\\n  IPooledStaking public pooledStaking;\\n\\n  uint public minCALockTime;\\n  uint public claimSubmissionGracePeriod;\\n\\n  // coverId => CoverInfo\\n  mapping(uint => CoverInfo) public coverInfo;\\n\\n  event Locked(address indexed _of, bytes32 indexed _reason, uint256 _amount, uint256 _validity);\\n\\n  event Unlocked(address indexed _of, bytes32 indexed _reason, uint256 _amount);\\n\\n  event Burned(address indexed member, bytes32 lockedUnder, uint256 amount);\\n\\n  modifier onlyGovernance {\\n    require(msg.sender == ms.getLatestAddress(\\\"GV\\\"), \\\"TokenController: Caller is not governance\\\");\\n    _;\\n  }\\n\\n  /**\\n  * @dev Just for interface\\n  */\\n  function changeDependentContractAddress() public {\\n    token = NXMToken(ms.tokenAddress());\\n    pooledStaking = IPooledStaking(ms.getLatestAddress(\\\"PS\\\"));\\n  }\\n\\n  function markCoverClaimOpen(uint coverId) external onlyInternal {\\n\\n    CoverInfo storage info = coverInfo[coverId];\\n\\n    uint16 claimCount;\\n    bool hasOpenClaim;\\n    bool hasAcceptedClaim;\\n\\n    // reads all of them using a single SLOAD\\n    (claimCount, hasOpenClaim, hasAcceptedClaim) = (info.claimCount, info.hasOpenClaim, info.hasAcceptedClaim);\\n\\n    // no safemath for uint16 but should be safe from\\n    // overflows as there're max 2 claims per cover\\n    claimCount = claimCount + 1;\\n\\n    require(claimCount <= 2, \\\"TokenController: Max claim count exceeded\\\");\\n    require(hasOpenClaim == false, \\\"TokenController: Cover already has an open claim\\\");\\n    require(hasAcceptedClaim == false, \\\"TokenController: Cover already has accepted claims\\\");\\n\\n    // should use a single SSTORE for both\\n    (info.claimCount, info.hasOpenClaim) = (claimCount, true);\\n  }\\n\\n  /**\\n   * @param coverId cover id (careful, not claim id!)\\n   * @param isAccepted claim verdict\\n   */\\n  function markCoverClaimClosed(uint coverId, bool isAccepted) external onlyInternal {\\n\\n    CoverInfo storage info = coverInfo[coverId];\\n    require(info.hasOpenClaim == true, \\\"TokenController: Cover claim is not marked as open\\\");\\n\\n    // should use a single SSTORE for both\\n    (info.hasOpenClaim, info.hasAcceptedClaim) = (false, isAccepted);\\n  }\\n\\n  /**\\n   * @dev to change the operator address\\n   * @param _newOperator is the new address of operator\\n   */\\n  function changeOperator(address _newOperator) public onlyInternal {\\n    token.changeOperator(_newOperator);\\n  }\\n\\n  /**\\n   * @dev Proxies token transfer through this contract to allow staking when members are locked for voting\\n   * @param _from   Source address\\n   * @param _to     Destination address\\n   * @param _value  Amount to transfer\\n   */\\n  function operatorTransfer(address _from, address _to, uint _value) external onlyInternal returns (bool) {\\n    require(msg.sender == address(pooledStaking), \\\"TokenController: Call is only allowed from PooledStaking address\\\");\\n    token.operatorTransfer(_from, _value);\\n    token.transfer(_to, _value);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Locks a specified amount of tokens,\\n  *    for CLA reason and for a specified time\\n  * @param _amount Number of tokens to be locked\\n  * @param _time Lock time in seconds\\n  */\\n  function lockClaimAssessmentTokens(uint256 _amount, uint256 _time) external checkPause {\\n    require(minCALockTime <= _time, \\\"TokenController: Must lock for minimum time\\\");\\n    require(_time <= 180 days, \\\"TokenController: Tokens can be locked for 180 days maximum\\\");\\n    // If tokens are already locked, then functions extendLock or\\n    // increaseClaimAssessmentLock should be used to make any changes\\n    _lock(msg.sender, \\\"CLA\\\", _amount, _time);\\n  }\\n\\n  /**\\n  * @dev Locks a specified amount of tokens against an address,\\n  *    for a specified reason and time\\n  * @param _reason The reason to lock tokens\\n  * @param _amount Number of tokens to be locked\\n  * @param _time Lock time in seconds\\n  * @param _of address whose tokens are to be locked\\n  */\\n  function lockOf(address _of, bytes32 _reason, uint256 _amount, uint256 _time)\\n  public\\n  onlyInternal\\n  returns (bool)\\n  {\\n    // If tokens are already locked, then functions extendLock or\\n    // increaseLockAmount should be used to make any changes\\n    _lock(_of, _reason, _amount, _time);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Mints and locks a specified amount of tokens against an address,\\n  *      for a CN reason and time\\n  * @param _of address whose tokens are to be locked\\n  * @param _reason The reason to lock tokens\\n  * @param _amount Number of tokens to be locked\\n  * @param _time Lock time in seconds\\n  */\\n  function mintCoverNote(\\n    address _of,\\n    bytes32 _reason,\\n    uint256 _amount,\\n    uint256 _time\\n  ) external onlyInternal {\\n\\n    require(_tokensLocked(_of, _reason) == 0, \\\"TokenController: An amount of tokens is already locked\\\");\\n    require(_amount != 0, \\\"TokenController: Amount shouldn't be zero\\\");\\n\\n    if (locked[_of][_reason].amount == 0) {\\n      lockReason[_of].push(_reason);\\n    }\\n\\n    token.mint(address(this), _amount);\\n\\n    uint256 lockedUntil = now.add(_time);\\n    locked[_of][_reason] = LockToken(_amount, lockedUntil, false);\\n\\n    emit Locked(_of, _reason, _amount, lockedUntil);\\n  }\\n\\n  /**\\n  * @dev Extends lock for reason CLA for a specified time\\n  * @param _time Lock extension time in seconds\\n  */\\n  function extendClaimAssessmentLock(uint256 _time) external checkPause {\\n    uint256 validity = getLockedTokensValidity(msg.sender, \\\"CLA\\\");\\n    require(validity.add(_time).sub(block.timestamp) <= 180 days, \\\"TokenController: Tokens can be locked for 180 days maximum\\\");\\n    _extendLock(msg.sender, \\\"CLA\\\", _time);\\n  }\\n\\n  /**\\n  * @dev Extends lock for a specified reason and time\\n  * @param _reason The reason to lock tokens\\n  * @param _time Lock extension time in seconds\\n  */\\n  function extendLockOf(address _of, bytes32 _reason, uint256 _time)\\n  public\\n  onlyInternal\\n  returns (bool)\\n  {\\n    _extendLock(_of, _reason, _time);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Increase number of tokens locked for a CLA reason\\n  * @param _amount Number of tokens to be increased\\n  */\\n  function increaseClaimAssessmentLock(uint256 _amount) external checkPause\\n  {\\n    require(_tokensLocked(msg.sender, \\\"CLA\\\") > 0, \\\"TokenController: No tokens locked\\\");\\n    token.operatorTransfer(msg.sender, _amount);\\n\\n    locked[msg.sender][\\\"CLA\\\"].amount = locked[msg.sender][\\\"CLA\\\"].amount.add(_amount);\\n    emit Locked(msg.sender, \\\"CLA\\\", _amount, locked[msg.sender][\\\"CLA\\\"].validity);\\n  }\\n\\n  /**\\n   * @dev burns tokens of an address\\n   * @param _of is the address to burn tokens of\\n   * @param amount is the amount to burn\\n   * @return the boolean status of the burning process\\n   */\\n  function burnFrom(address _of, uint amount) public onlyInternal returns (bool) {\\n    return token.burnFrom(_of, amount);\\n  }\\n\\n  /**\\n  * @dev Burns locked tokens of a user\\n  * @param _of address whose tokens are to be burned\\n  * @param _reason lock reason for which tokens are to be burned\\n  * @param _amount amount of tokens to burn\\n  */\\n  function burnLockedTokens(address _of, bytes32 _reason, uint256 _amount) public onlyInternal {\\n    _burnLockedTokens(_of, _reason, _amount);\\n  }\\n\\n  /**\\n  * @dev reduce lock duration for a specified reason and time\\n  * @param _of The address whose tokens are locked\\n  * @param _reason The reason to lock tokens\\n  * @param _time Lock reduction time in seconds\\n  */\\n  function reduceLock(address _of, bytes32 _reason, uint256 _time) public onlyInternal {\\n    _reduceLock(_of, _reason, _time);\\n  }\\n\\n  /**\\n  * @dev Released locked tokens of an address locked for a specific reason\\n  * @param _of address whose tokens are to be released from lock\\n  * @param _reason reason of the lock\\n  * @param _amount amount of tokens to release\\n  */\\n  function releaseLockedTokens(address _of, bytes32 _reason, uint256 _amount)\\n  public\\n  onlyInternal\\n  {\\n    _releaseLockedTokens(_of, _reason, _amount);\\n  }\\n\\n  /**\\n  * @dev Adds an address to whitelist maintained in the contract\\n  * @param _member address to add to whitelist\\n  */\\n  function addToWhitelist(address _member) public onlyInternal {\\n    token.addToWhiteList(_member);\\n  }\\n\\n  /**\\n  * @dev Removes an address from the whitelist in the token\\n  * @param _member address to remove\\n  */\\n  function removeFromWhitelist(address _member) public onlyInternal {\\n    token.removeFromWhiteList(_member);\\n  }\\n\\n  /**\\n  * @dev Mints new token for an address\\n  * @param _member address to reward the minted tokens\\n  * @param _amount number of tokens to mint\\n  */\\n  function mint(address _member, uint _amount) public onlyInternal {\\n    token.mint(_member, _amount);\\n  }\\n\\n  /**\\n   * @dev Lock the user's tokens\\n   * @param _of user's address.\\n   */\\n  function lockForMemberVote(address _of, uint _days) public onlyInternal {\\n    token.lockForMemberVote(_of, _days);\\n  }\\n\\n  /**\\n  * @dev Unlocks the withdrawable tokens against CLA of a specified address\\n  * @param _of Address of user, claiming back withdrawable tokens against CLA\\n  */\\n  function withdrawClaimAssessmentTokens(address _of) external checkPause {\\n    uint256 withdrawableTokens = _tokensUnlockable(_of, \\\"CLA\\\");\\n    if (withdrawableTokens > 0) {\\n      locked[_of][\\\"CLA\\\"].claimed = true;\\n      emit Unlocked(_of, \\\"CLA\\\", withdrawableTokens);\\n      token.transfer(_of, withdrawableTokens);\\n    }\\n  }\\n\\n  /**\\n   * @dev Updates Uint Parameters of a code\\n   * @param code whose details we want to update\\n   * @param value value to set\\n   */\\n  function updateUintParameters(bytes8 code, uint value) external onlyGovernance {\\n\\n    if (code == \\\"MNCLT\\\") {\\n      minCALockTime = value;\\n      return;\\n    }\\n\\n    if (code == \\\"GRACEPER\\\") {\\n      claimSubmissionGracePeriod = value;\\n      return;\\n    }\\n\\n    revert(\\\"TokenController: invalid param code\\\");\\n  }\\n\\n  function getLockReasons(address _of) external view returns (bytes32[] memory reasons) {\\n    return lockReason[_of];\\n  }\\n\\n  /**\\n  * @dev Gets the validity of locked tokens of a specified address\\n  * @param _of The address to query the validity\\n  * @param reason reason for which tokens were locked\\n  */\\n  function getLockedTokensValidity(address _of, bytes32 reason) public view returns (uint256 validity) {\\n    validity = locked[_of][reason].validity;\\n  }\\n\\n  /**\\n  * @dev Gets the unlockable tokens of a specified address\\n  * @param _of The address to query the the unlockable token count of\\n  */\\n  function getUnlockableTokens(address _of)\\n  public\\n  view\\n  returns (uint256 unlockableTokens)\\n  {\\n    for (uint256 i = 0; i < lockReason[_of].length; i++) {\\n      unlockableTokens = unlockableTokens.add(_tokensUnlockable(_of, lockReason[_of][i]));\\n    }\\n  }\\n\\n  /**\\n  * @dev Returns tokens locked for a specified address for a\\n  *    specified reason\\n  *\\n  * @param _of The address whose tokens are locked\\n  * @param _reason The reason to query the lock tokens for\\n  */\\n  function tokensLocked(address _of, bytes32 _reason)\\n  public\\n  view\\n  returns (uint256 amount)\\n  {\\n    return _tokensLocked(_of, _reason);\\n  }\\n\\n  /**\\n  * @dev Returns tokens locked and validity for a specified address and reason\\n  * @param _of The address whose tokens are locked\\n  * @param _reason The reason to query the lock tokens for\\n  */\\n  function tokensLockedWithValidity(address _of, bytes32 _reason)\\n  public\\n  view\\n  returns (uint256 amount, uint256 validity)\\n  {\\n\\n    bool claimed = locked[_of][_reason].claimed;\\n    amount = locked[_of][_reason].amount;\\n    validity = locked[_of][_reason].validity;\\n\\n    if (claimed) {\\n      amount = 0;\\n    }\\n  }\\n\\n  /**\\n  * @dev Returns unlockable tokens for a specified address for a specified reason\\n  * @param _of The address to query the the unlockable token count of\\n  * @param _reason The reason to query the unlockable tokens for\\n  */\\n  function tokensUnlockable(address _of, bytes32 _reason)\\n  public\\n  view\\n  returns (uint256 amount)\\n  {\\n    return _tokensUnlockable(_of, _reason);\\n  }\\n\\n  function totalSupply() public view returns (uint256)\\n  {\\n    return token.totalSupply();\\n  }\\n\\n  /**\\n  * @dev Returns tokens locked for a specified address for a\\n  *    specified reason at a specific time\\n  *\\n  * @param _of The address whose tokens are locked\\n  * @param _reason The reason to query the lock tokens for\\n  * @param _time The timestamp to query the lock tokens for\\n  */\\n  function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)\\n  public\\n  view\\n  returns (uint256 amount)\\n  {\\n    return _tokensLockedAtTime(_of, _reason, _time);\\n  }\\n\\n  /**\\n  * @dev Returns the total amount of tokens held by an address:\\n  *   transferable + locked + staked for pooled staking - pending burns.\\n  *   Used by Claims and Governance in member voting to calculate the user's vote weight.\\n  *\\n  * @param _of The address to query the total balance of\\n  * @param _of The address to query the total balance of\\n  */\\n  function totalBalanceOf(address _of) public view returns (uint256 amount) {\\n\\n    amount = token.balanceOf(_of);\\n\\n    for (uint256 i = 0; i < lockReason[_of].length; i++) {\\n      amount = amount.add(_tokensLocked(_of, lockReason[_of][i]));\\n    }\\n\\n    uint stakerReward = pooledStaking.stakerReward(_of);\\n    uint stakerDeposit = pooledStaking.stakerDeposit(_of);\\n\\n    amount = amount.add(stakerDeposit).add(stakerReward);\\n  }\\n\\n  /**\\n  * @dev Returns the total amount of locked and staked tokens.\\n  *      Used by MemberRoles to check eligibility for withdraw / switch membership.\\n  *      Includes tokens locked for claim assessment, tokens staked for risk assessment, and locked cover notes\\n  *      Does not take into account pending burns.\\n  * @param _of member whose locked tokens are to be calculate\\n  */\\n  function totalLockedBalance(address _of) public view returns (uint256 amount) {\\n\\n    for (uint256 i = 0; i < lockReason[_of].length; i++) {\\n      amount = amount.add(_tokensLocked(_of, lockReason[_of][i]));\\n    }\\n\\n    amount = amount.add(pooledStaking.stakerDeposit(_of));\\n  }\\n\\n  /**\\n  * @dev Locks a specified amount of tokens against an address,\\n  *    for a specified reason and time\\n  * @param _of address whose tokens are to be locked\\n  * @param _reason The reason to lock tokens\\n  * @param _amount Number of tokens to be locked\\n  * @param _time Lock time in seconds\\n  */\\n  function _lock(address _of, bytes32 _reason, uint256 _amount, uint256 _time) internal {\\n    require(_tokensLocked(_of, _reason) == 0, \\\"TokenController: An amount of tokens is already locked\\\");\\n    require(_amount != 0, \\\"TokenController: Amount shouldn't be zero\\\");\\n\\n    if (locked[_of][_reason].amount == 0) {\\n      lockReason[_of].push(_reason);\\n    }\\n\\n    token.operatorTransfer(_of, _amount);\\n\\n    uint256 validUntil = now.add(_time);\\n    locked[_of][_reason] = LockToken(_amount, validUntil, false);\\n    emit Locked(_of, _reason, _amount, validUntil);\\n  }\\n\\n  /**\\n  * @dev Returns tokens locked for a specified address for a\\n  *    specified reason\\n  *\\n  * @param _of The address whose tokens are locked\\n  * @param _reason The reason to query the lock tokens for\\n  */\\n  function _tokensLocked(address _of, bytes32 _reason)\\n  internal\\n  view\\n  returns (uint256 amount)\\n  {\\n    if (!locked[_of][_reason].claimed) {\\n      amount = locked[_of][_reason].amount;\\n    }\\n  }\\n\\n  /**\\n  * @dev Returns tokens locked for a specified address for a\\n  *    specified reason at a specific time\\n  *\\n  * @param _of The address whose tokens are locked\\n  * @param _reason The reason to query the lock tokens for\\n  * @param _time The timestamp to query the lock tokens for\\n  */\\n  function _tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)\\n  internal\\n  view\\n  returns (uint256 amount)\\n  {\\n    if (locked[_of][_reason].validity > _time) {\\n      amount = locked[_of][_reason].amount;\\n    }\\n  }\\n\\n  /**\\n  * @dev Extends lock for a specified reason and time\\n  * @param _of The address whose tokens are locked\\n  * @param _reason The reason to lock tokens\\n  * @param _time Lock extension time in seconds\\n  */\\n  function _extendLock(address _of, bytes32 _reason, uint256 _time) internal {\\n    require(_tokensLocked(_of, _reason) > 0, \\\"TokenController: No tokens locked\\\");\\n    emit Unlocked(_of, _reason, locked[_of][_reason].amount);\\n    locked[_of][_reason].validity = locked[_of][_reason].validity.add(_time);\\n    emit Locked(_of, _reason, locked[_of][_reason].amount, locked[_of][_reason].validity);\\n  }\\n\\n  /**\\n  * @dev reduce lock duration for a specified reason and time\\n  * @param _of The address whose tokens are locked\\n  * @param _reason The reason to lock tokens\\n  * @param _time Lock reduction time in seconds\\n  */\\n  function _reduceLock(address _of, bytes32 _reason, uint256 _time) internal {\\n    require(_tokensLocked(_of, _reason) > 0, \\\"TokenController: No tokens locked\\\");\\n    emit Unlocked(_of, _reason, locked[_of][_reason].amount);\\n    locked[_of][_reason].validity = locked[_of][_reason].validity.sub(_time);\\n    emit Locked(_of, _reason, locked[_of][_reason].amount, locked[_of][_reason].validity);\\n  }\\n\\n  /**\\n  * @dev Returns unlockable tokens for a specified address for a specified reason\\n  * @param _of The address to query the the unlockable token count of\\n  * @param _reason The reason to query the unlockable tokens for\\n  */\\n  function _tokensUnlockable(address _of, bytes32 _reason) internal view returns (uint256 amount)\\n  {\\n    if (locked[_of][_reason].validity <= now && !locked[_of][_reason].claimed) {\\n      amount = locked[_of][_reason].amount;\\n    }\\n  }\\n\\n  /**\\n  * @dev Burns locked tokens of a user\\n  * @param _of address whose tokens are to be burned\\n  * @param _reason lock reason for which tokens are to be burned\\n  * @param _amount amount of tokens to burn\\n  */\\n  function _burnLockedTokens(address _of, bytes32 _reason, uint256 _amount) internal {\\n    uint256 amount = _tokensLocked(_of, _reason);\\n    require(amount >= _amount, \\\"TokenController: Amount exceedes locked tokens amount\\\");\\n\\n    if (amount == _amount) {\\n      locked[_of][_reason].claimed = true;\\n    }\\n\\n    locked[_of][_reason].amount = locked[_of][_reason].amount.sub(_amount);\\n\\n    // lock reason removal is skipped here: needs to be done from offchain\\n\\n    token.burn(_amount);\\n    emit Burned(_of, _reason, _amount);\\n  }\\n\\n  /**\\n  * @dev Released locked tokens of an address locked for a specific reason\\n  * @param _of address whose tokens are to be released from lock\\n  * @param _reason reason of the lock\\n  * @param _amount amount of tokens to release\\n  */\\n  function _releaseLockedTokens(address _of, bytes32 _reason, uint256 _amount) internal\\n  {\\n    uint256 amount = _tokensLocked(_of, _reason);\\n    require(amount >= _amount, \\\"TokenController: Amount exceedes locked tokens amount\\\");\\n\\n    if (amount == _amount) {\\n      locked[_of][_reason].claimed = true;\\n    }\\n\\n    locked[_of][_reason].amount = locked[_of][_reason].amount.sub(_amount);\\n\\n    // lock reason removal is skipped here: needs to be done from offchain\\n\\n    token.transfer(_of, _amount);\\n    emit Unlocked(_of, _reason, _amount);\\n  }\\n\\n  function withdrawCoverNote(\\n    address _of,\\n    uint[] calldata _coverIds,\\n    uint[] calldata _indexes\\n  ) external onlyInternal {\\n\\n    uint reasonCount = lockReason[_of].length;\\n    uint lastReasonIndex = reasonCount.sub(1, \\\"TokenController: No locked cover notes found\\\");\\n    uint totalAmount = 0;\\n\\n    // The iteration is done from the last to first to prevent reason indexes from\\n    // changing due to the way we delete the items (copy last to current and pop last).\\n    // The provided indexes array must be ordered, otherwise reason index checks will fail.\\n\\n    for (uint i = _coverIds.length; i > 0; i--) {\\n\\n      bool hasOpenClaim = coverInfo[_coverIds[i - 1]].hasOpenClaim;\\n      require(hasOpenClaim == false, \\\"TokenController: Cannot withdraw for cover with an open claim\\\");\\n\\n      // note: cover owner is implicitly checked using the reason hash\\n      bytes32 _reason = keccak256(abi.encodePacked(\\\"CN\\\", _of, _coverIds[i - 1]));\\n      uint _reasonIndex = _indexes[i - 1];\\n      require(lockReason[_of][_reasonIndex] == _reason, \\\"TokenController: Bad reason index\\\");\\n\\n      uint amount = locked[_of][_reason].amount;\\n      totalAmount = totalAmount.add(amount);\\n      delete locked[_of][_reason];\\n\\n      if (lastReasonIndex != _reasonIndex) {\\n        lockReason[_of][_reasonIndex] = lockReason[_of][lastReasonIndex];\\n      }\\n\\n      lockReason[_of].pop();\\n      emit Unlocked(_of, _reason, amount);\\n\\n      if (lastReasonIndex > 0) {\\n        lastReasonIndex = lastReasonIndex.sub(1, \\\"TokenController: Reason count mismatch\\\");\\n      }\\n    }\\n\\n    token.transfer(_of, totalAmount);\\n  }\\n\\n  function removeEmptyReason(address _of, bytes32 _reason, uint _index) external {\\n    _removeEmptyReason(_of, _reason, _index);\\n  }\\n\\n  function removeMultipleEmptyReasons(\\n    address[] calldata _members,\\n    bytes32[] calldata _reasons,\\n    uint[] calldata _indexes\\n  ) external {\\n\\n    require(_members.length == _reasons.length, \\\"TokenController: members and reasons array lengths differ\\\");\\n    require(_reasons.length == _indexes.length, \\\"TokenController: reasons and indexes array lengths differ\\\");\\n\\n    for (uint i = _members.length; i > 0; i--) {\\n      uint idx = i - 1;\\n      _removeEmptyReason(_members[idx], _reasons[idx], _indexes[idx]);\\n    }\\n  }\\n\\n  function _removeEmptyReason(address _of, bytes32 _reason, uint _index) internal {\\n\\n    uint lastReasonIndex = lockReason[_of].length.sub(1, \\\"TokenController: lockReason is empty\\\");\\n\\n    require(lockReason[_of][_index] == _reason, \\\"TokenController: bad reason index\\\");\\n    require(locked[_of][_reason].amount == 0, \\\"TokenController: reason amount is not zero\\\");\\n\\n    if (lastReasonIndex != _index) {\\n      lockReason[_of][_index] = lockReason[_of][lastReasonIndex];\\n    }\\n\\n    lockReason[_of].pop();\\n  }\\n\\n  function initialize() external {\\n    require(claimSubmissionGracePeriod == 0, \\\"TokenController: Already initialized\\\");\\n    claimSubmissionGracePeriod = 120 days;\\n    migrate();\\n  }\\n\\n  function migrate() internal {\\n\\n    ClaimsData cd = ClaimsData(ms.getLatestAddress(\\\"CD\\\"));\\n    uint totalClaims = cd.actualClaimLength() - 1;\\n\\n    // fix stuck claims 21 & 22\\n    cd.changeFinalVerdict(20, -1);\\n    cd.setClaimStatus(20, 6);\\n    cd.changeFinalVerdict(21, -1);\\n    cd.setClaimStatus(21, 6);\\n\\n    // reduce claim assessment lock period for members locked for more than 180 days\\n    // extracted using scripts/extract-ca-locked-more-than-180.js\\n    address payable[3] memory members = [\\n      0x4a9fA34da6d2378c8f3B9F6b83532B169beaEDFc,\\n      0x6b5DCDA27b5c3d88e71867D6b10b35372208361F,\\n      0x8B6D1e5b4db5B6f9aCcc659e2b9619B0Cd90D617\\n    ];\\n\\n    for (uint i = 0; i < members.length; i++) {\\n      if (locked[members[i]][\\\"CLA\\\"].validity > now + 180 days) {\\n        locked[members[i]][\\\"CLA\\\"].validity = now + 180 days;\\n      }\\n    }\\n\\n    for (uint i = 1; i <= totalClaims; i++) {\\n\\n      (/*id*/, uint status) = cd.getClaimStatusNumber(i);\\n      (/*id*/, uint coverId) = cd.getClaimCoverId(i);\\n      int8 verdict = cd.getFinalVerdict(i);\\n\\n      // SLOAD\\n      CoverInfo memory info = coverInfo[coverId];\\n\\n      info.claimCount = info.claimCount + 1;\\n      info.hasAcceptedClaim = (status == 14);\\n      info.hasOpenClaim = (verdict == 0);\\n\\n      // SSTORE\\n      coverInfo[coverId] = info;\\n    }\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/modules/token/TokenData.sol\": {\r\n      \"content\": \"/* Copyright (C) 2020 NexusMutual.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../../abstract/Iupgradable.sol\\\";\\n\\ncontract TokenData is Iupgradable {\\n  using SafeMath for uint;\\n\\n  address payable public walletAddress;\\n  uint public lockTokenTimeAfterCoverExp;\\n  uint public bookTime;\\n  uint public lockCADays;\\n  uint public lockMVDays;\\n  uint public scValidDays;\\n  uint public joiningFee;\\n  uint public stakerCommissionPer;\\n  uint public stakerMaxCommissionPer;\\n  uint public tokenExponent;\\n  uint public priceStep;\\n\\n  struct StakeCommission {\\n    uint commissionEarned;\\n    uint commissionRedeemed;\\n  }\\n\\n  struct Stake {\\n    address stakedContractAddress;\\n    uint stakedContractIndex;\\n    uint dateAdd;\\n    uint stakeAmount;\\n    uint unlockedAmount;\\n    uint burnedAmount;\\n    uint unLockableBeforeLastBurn;\\n  }\\n\\n  struct Staker {\\n    address stakerAddress;\\n    uint stakerIndex;\\n  }\\n\\n  struct CoverNote {\\n    uint amount;\\n    bool isDeposited;\\n  }\\n\\n  /**\\n   * @dev mapping of uw address to array of sc address to fetch\\n   * all staked contract address of underwriter, pushing\\n   * data into this array of Stake returns stakerIndex\\n   */\\n  mapping(address => Stake[]) public stakerStakedContracts;\\n\\n  /**\\n   * @dev mapping of sc address to array of UW address to fetch\\n   * all underwritters of the staked smart contract\\n   * pushing data into this mapped array returns scIndex\\n   */\\n  mapping(address => Staker[]) public stakedContractStakers;\\n\\n  /**\\n   * @dev mapping of staked contract Address to the array of StakeCommission\\n   * here index of this array is stakedContractIndex\\n   */\\n  mapping(address => mapping(uint => StakeCommission)) public stakedContractStakeCommission;\\n\\n  mapping(address => uint) public lastCompletedStakeCommission;\\n\\n  /**\\n   * @dev mapping of the staked contract address to the current\\n   * staker index who will receive commission.\\n   */\\n  mapping(address => uint) public stakedContractCurrentCommissionIndex;\\n\\n  /**\\n   * @dev mapping of the staked contract address to the\\n   * current staker index to burn token from.\\n   */\\n  mapping(address => uint) public stakedContractCurrentBurnIndex;\\n\\n  /**\\n   * @dev mapping to return true if Cover Note deposited against coverId\\n   */\\n  mapping(uint => CoverNote) public depositedCN;\\n\\n  mapping(address => uint) internal isBookedTokens;\\n\\n  event Commission(\\n    address indexed stakedContractAddress,\\n    address indexed stakerAddress,\\n    uint indexed scIndex,\\n    uint commissionAmount\\n  );\\n\\n  constructor(address payable _walletAdd) public {\\n    walletAddress = _walletAdd;\\n    bookTime = 12 hours;\\n    joiningFee = 2000000000000000; // 0.002 Ether\\n    lockTokenTimeAfterCoverExp = 35 days;\\n    scValidDays = 250;\\n    lockCADays = 7 days;\\n    lockMVDays = 2 days;\\n    stakerCommissionPer = 20;\\n    stakerMaxCommissionPer = 50;\\n    tokenExponent = 4;\\n    priceStep = 1000;\\n  }\\n\\n  /**\\n   * @dev Change the wallet address which receive Joining Fee\\n   */\\n  function changeWalletAddress(address payable _address) external onlyInternal {\\n    walletAddress = _address;\\n  }\\n\\n  /**\\n   * @dev Gets Uint Parameters of a code\\n   * @param code whose details we want\\n   * @return string value of the code\\n   * @return associated amount (time or perc or value) to the code\\n   */\\n  function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val) {\\n    codeVal = code;\\n    if (code == \\\"TOKEXP\\\") {\\n\\n      val = tokenExponent;\\n\\n    } else if (code == \\\"TOKSTEP\\\") {\\n\\n      val = priceStep;\\n\\n    } else if (code == \\\"RALOCKT\\\") {\\n\\n      val = scValidDays;\\n\\n    } else if (code == \\\"RACOMM\\\") {\\n\\n      val = stakerCommissionPer;\\n\\n    } else if (code == \\\"RAMAXC\\\") {\\n\\n      val = stakerMaxCommissionPer;\\n\\n    } else if (code == \\\"CABOOKT\\\") {\\n\\n      val = bookTime / (1 hours);\\n\\n    } else if (code == \\\"CALOCKT\\\") {\\n\\n      val = lockCADays / (1 days);\\n\\n    } else if (code == \\\"MVLOCKT\\\") {\\n\\n      val = lockMVDays / (1 days);\\n\\n    } else if (code == \\\"QUOLOCKT\\\") {\\n\\n      val = lockTokenTimeAfterCoverExp / (1 days);\\n\\n    } else if (code == \\\"JOINFEE\\\") {\\n\\n      val = joiningFee;\\n\\n    }\\n  }\\n\\n  /**\\n  * @dev Just for interface\\n  */\\n  function changeDependentContractAddress() public {//solhint-disable-line\\n  }\\n\\n  /**\\n   * @dev to get the contract staked by a staker\\n   * @param _stakerAddress is the address of the staker\\n   * @param _stakerIndex is the index of staker\\n   * @return the address of staked contract\\n   */\\n  function getStakerStakedContractByIndex(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  public\\n  view\\n  returns (address stakedContractAddress)\\n  {\\n    stakedContractAddress = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].stakedContractAddress;\\n  }\\n\\n  /**\\n   * @dev to get the staker's staked burned\\n   * @param _stakerAddress is the address of the staker\\n   * @param _stakerIndex is the index of staker\\n   * @return amount burned\\n   */\\n  function getStakerStakedBurnedByIndex(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  public\\n  view\\n  returns (uint burnedAmount)\\n  {\\n    burnedAmount = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].burnedAmount;\\n  }\\n\\n  /**\\n   * @dev to get the staker's staked unlockable before the last burn\\n   * @param _stakerAddress is the address of the staker\\n   * @param _stakerIndex is the index of staker\\n   * @return unlockable staked tokens\\n   */\\n  function getStakerStakedUnlockableBeforeLastBurnByIndex(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  public\\n  view\\n  returns (uint unlockable)\\n  {\\n    unlockable = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].unLockableBeforeLastBurn;\\n  }\\n\\n  /**\\n   * @dev to get the staker's staked contract index\\n   * @param _stakerAddress is the address of the staker\\n   * @param _stakerIndex is the index of staker\\n   * @return is the index of the smart contract address\\n   */\\n  function getStakerStakedContractIndex(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  public\\n  view\\n  returns (uint scIndex)\\n  {\\n    scIndex = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].stakedContractIndex;\\n  }\\n\\n  /**\\n   * @dev to get the staker index of the staked contract\\n   * @param _stakedContractAddress is the address of the staked contract\\n   * @param _stakedContractIndex is the index of staked contract\\n   * @return is the index of the staker\\n   */\\n  function getStakedContractStakerIndex(\\n    address _stakedContractAddress,\\n    uint _stakedContractIndex\\n  )\\n  public\\n  view\\n  returns (uint sIndex)\\n  {\\n    sIndex = stakedContractStakers[\\n    _stakedContractAddress][_stakedContractIndex].stakerIndex;\\n  }\\n\\n  /**\\n   * @dev to get the staker's initial staked amount on the contract\\n   * @param _stakerAddress is the address of the staker\\n   * @param _stakerIndex is the index of staker\\n   * @return staked amount\\n   */\\n  function getStakerInitialStakedAmountOnContract(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  public\\n  view\\n  returns (uint amount)\\n  {\\n    amount = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].stakeAmount;\\n  }\\n\\n  /**\\n   * @dev to get the staker's staked contract length\\n   * @param _stakerAddress is the address of the staker\\n   * @return length of staked contract\\n   */\\n  function getStakerStakedContractLength(\\n    address _stakerAddress\\n  )\\n  public\\n  view\\n  returns (uint length)\\n  {\\n    length = stakerStakedContracts[_stakerAddress].length;\\n  }\\n\\n  /**\\n   * @dev to get the staker's unlocked tokens which were staked\\n   * @param _stakerAddress is the address of the staker\\n   * @param _stakerIndex is the index of staker\\n   * @return amount\\n   */\\n  function getStakerUnlockedStakedTokens(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  public\\n  view\\n  returns (uint amount)\\n  {\\n    amount = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].unlockedAmount;\\n  }\\n\\n  /**\\n   * @dev pushes the unlocked staked tokens by a staker.\\n   * @param _stakerAddress address of staker.\\n   * @param _stakerIndex index of the staker to distribute commission.\\n   * @param _amount amount to be given as commission.\\n   */\\n  function pushUnlockedStakedTokens(\\n    address _stakerAddress,\\n    uint _stakerIndex,\\n    uint _amount\\n  )\\n  public\\n  onlyInternal\\n  {\\n    stakerStakedContracts[_stakerAddress][\\n    _stakerIndex].unlockedAmount = stakerStakedContracts[_stakerAddress][\\n    _stakerIndex].unlockedAmount.add(_amount);\\n  }\\n\\n  /**\\n   * @dev pushes the Burned tokens for a staker.\\n   * @param _stakerAddress address of staker.\\n   * @param _stakerIndex index of the staker.\\n   * @param _amount amount to be burned.\\n   */\\n  function pushBurnedTokens(\\n    address _stakerAddress,\\n    uint _stakerIndex,\\n    uint _amount\\n  )\\n  public\\n  onlyInternal\\n  {\\n    stakerStakedContracts[_stakerAddress][\\n    _stakerIndex].burnedAmount = stakerStakedContracts[_stakerAddress][\\n    _stakerIndex].burnedAmount.add(_amount);\\n  }\\n\\n  /**\\n   * @dev pushes the unLockable tokens for a staker before last burn.\\n   * @param _stakerAddress address of staker.\\n   * @param _stakerIndex index of the staker.\\n   * @param _amount amount to be added to unlockable.\\n   */\\n  function pushUnlockableBeforeLastBurnTokens(\\n    address _stakerAddress,\\n    uint _stakerIndex,\\n    uint _amount\\n  )\\n  public\\n  onlyInternal\\n  {\\n    stakerStakedContracts[_stakerAddress][\\n    _stakerIndex].unLockableBeforeLastBurn = stakerStakedContracts[_stakerAddress][\\n    _stakerIndex].unLockableBeforeLastBurn.add(_amount);\\n  }\\n\\n  /**\\n   * @dev sets the unLockable tokens for a staker before last burn.\\n   * @param _stakerAddress address of staker.\\n   * @param _stakerIndex index of the staker.\\n   * @param _amount amount to be added to unlockable.\\n   */\\n  function setUnlockableBeforeLastBurnTokens(\\n    address _stakerAddress,\\n    uint _stakerIndex,\\n    uint _amount\\n  )\\n  public\\n  onlyInternal\\n  {\\n    stakerStakedContracts[_stakerAddress][\\n    _stakerIndex].unLockableBeforeLastBurn = _amount;\\n  }\\n\\n  /**\\n   * @dev pushes the earned commission earned by a staker.\\n   * @param _stakerAddress address of staker.\\n   * @param _stakedContractAddress address of smart contract.\\n   * @param _stakedContractIndex index of the staker to distribute commission.\\n   * @param _commissionAmount amount to be given as commission.\\n   */\\n  function pushEarnedStakeCommissions(\\n    address _stakerAddress,\\n    address _stakedContractAddress,\\n    uint _stakedContractIndex,\\n    uint _commissionAmount\\n  )\\n  public\\n  onlyInternal\\n  {\\n    stakedContractStakeCommission[_stakedContractAddress][_stakedContractIndex].\\n    commissionEarned = stakedContractStakeCommission[_stakedContractAddress][\\n    _stakedContractIndex].commissionEarned.add(_commissionAmount);\\n\\n    emit Commission(\\n      _stakerAddress,\\n      _stakedContractAddress,\\n      _stakedContractIndex,\\n      _commissionAmount\\n    );\\n  }\\n\\n  /**\\n   * @dev pushes the redeemed commission redeemed by a staker.\\n   * @param _stakerAddress address of staker.\\n   * @param _stakerIndex index of the staker to distribute commission.\\n   * @param _amount amount to be given as commission.\\n   */\\n  function pushRedeemedStakeCommissions(\\n    address _stakerAddress,\\n    uint _stakerIndex,\\n    uint _amount\\n  )\\n  public\\n  onlyInternal\\n  {\\n    uint stakedContractIndex = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].stakedContractIndex;\\n    address stakedContractAddress = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].stakedContractAddress;\\n    stakedContractStakeCommission[stakedContractAddress][stakedContractIndex].\\n    commissionRedeemed = stakedContractStakeCommission[\\n    stakedContractAddress][stakedContractIndex].commissionRedeemed.add(_amount);\\n  }\\n\\n  /**\\n   * @dev Gets stake commission given to an underwriter\\n   * for particular stakedcontract on given index.\\n   * @param _stakerAddress address of staker.\\n   * @param _stakerIndex index of the staker commission.\\n   */\\n  function getStakerEarnedStakeCommission(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  public\\n  view\\n  returns (uint)\\n  {\\n    return _getStakerEarnedStakeCommission(_stakerAddress, _stakerIndex);\\n  }\\n\\n  /**\\n   * @dev Gets stake commission redeemed by an underwriter\\n   * for particular staked contract on given index.\\n   * @param _stakerAddress address of staker.\\n   * @param _stakerIndex index of the staker commission.\\n   * @return commissionEarned total amount given to staker.\\n   */\\n  function getStakerRedeemedStakeCommission(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  public\\n  view\\n  returns (uint)\\n  {\\n    return _getStakerRedeemedStakeCommission(_stakerAddress, _stakerIndex);\\n  }\\n\\n  /**\\n   * @dev Gets total stake commission given to an underwriter\\n   * @param _stakerAddress address of staker.\\n   * @return totalCommissionEarned total commission earned by staker.\\n   */\\n  function getStakerTotalEarnedStakeCommission(\\n    address _stakerAddress\\n  )\\n  public\\n  view\\n  returns (uint totalCommissionEarned)\\n  {\\n    totalCommissionEarned = 0;\\n    for (uint i = 0; i < stakerStakedContracts[_stakerAddress].length; i++) {\\n      totalCommissionEarned = totalCommissionEarned.\\n      add(_getStakerEarnedStakeCommission(_stakerAddress, i));\\n    }\\n  }\\n\\n  /**\\n   * @dev Gets total stake commission given to an underwriter\\n   * @param _stakerAddress address of staker.\\n   * @return totalCommissionEarned total commission earned by staker.\\n   */\\n  function getStakerTotalReedmedStakeCommission(\\n    address _stakerAddress\\n  )\\n  public\\n  view\\n  returns (uint totalCommissionRedeemed)\\n  {\\n    totalCommissionRedeemed = 0;\\n    for (uint i = 0; i < stakerStakedContracts[_stakerAddress].length; i++) {\\n      totalCommissionRedeemed = totalCommissionRedeemed.add(\\n        _getStakerRedeemedStakeCommission(_stakerAddress, i));\\n    }\\n  }\\n\\n  /**\\n   * @dev set flag to deposit/ undeposit cover note\\n   * against a cover Id\\n   * @param coverId coverId of Cover\\n   * @param flag true/false for deposit/undeposit\\n   */\\n  function setDepositCN(uint coverId, bool flag) public onlyInternal {\\n\\n    if (flag == true) {\\n      require(!depositedCN[coverId].isDeposited, \\\"Cover note already deposited\\\");\\n    }\\n\\n    depositedCN[coverId].isDeposited = flag;\\n  }\\n\\n  /**\\n   * @dev set locked cover note amount\\n   * against a cover Id\\n   * @param coverId coverId of Cover\\n   * @param amount amount of nxm to be locked\\n   */\\n  function setDepositCNAmount(uint coverId, uint amount) public onlyInternal {\\n\\n    depositedCN[coverId].amount = amount;\\n  }\\n\\n  /**\\n   * @dev to get the staker address on a staked contract\\n   * @param _stakedContractAddress is the address of the staked contract in concern\\n   * @param _stakedContractIndex is the index of staked contract's index\\n   * @return address of staker\\n   */\\n  function getStakedContractStakerByIndex(\\n    address _stakedContractAddress,\\n    uint _stakedContractIndex\\n  )\\n  public\\n  view\\n  returns (address stakerAddress)\\n  {\\n    stakerAddress = stakedContractStakers[\\n    _stakedContractAddress][_stakedContractIndex].stakerAddress;\\n  }\\n\\n  /**\\n   * @dev to get the length of stakers on a staked contract\\n   * @param _stakedContractAddress is the address of the staked contract in concern\\n   * @return length in concern\\n   */\\n  function getStakedContractStakersLength(\\n    address _stakedContractAddress\\n  )\\n  public\\n  view\\n  returns (uint length)\\n  {\\n    length = stakedContractStakers[_stakedContractAddress].length;\\n  }\\n\\n  /**\\n   * @dev Adds a new stake record.\\n   * @param _stakerAddress staker address.\\n   * @param _stakedContractAddress smart contract address.\\n   * @param _amount amountof NXM to be staked.\\n   */\\n  function addStake(\\n    address _stakerAddress,\\n    address _stakedContractAddress,\\n    uint _amount\\n  )\\n  public\\n  onlyInternal\\n  returns (uint scIndex)\\n  {\\n    scIndex = (stakedContractStakers[_stakedContractAddress].push(\\n      Staker(_stakerAddress, stakerStakedContracts[_stakerAddress].length))).sub(1);\\n    stakerStakedContracts[_stakerAddress].push(\\n      Stake(_stakedContractAddress, scIndex, now, _amount, 0, 0, 0));\\n  }\\n\\n  /**\\n   * @dev books the user's tokens for maintaining Assessor Velocity,\\n   * i.e. once a token is used to cast a vote as a Claims assessor,\\n   * @param _of user's address.\\n   */\\n  function bookCATokens(address _of) public onlyInternal {\\n    require(!isCATokensBooked(_of), \\\"Tokens already booked\\\");\\n    isBookedTokens[_of] = now.add(bookTime);\\n  }\\n\\n  /**\\n   * @dev to know if claim assessor's tokens are booked or not\\n   * @param _of is the claim assessor's address in concern\\n   * @return boolean representing the status of tokens booked\\n   */\\n  function isCATokensBooked(address _of) public view returns (bool res) {\\n    if (now < isBookedTokens[_of])\\n      res = true;\\n  }\\n\\n  /**\\n   * @dev Sets the index which will receive commission.\\n   * @param _stakedContractAddress smart contract address.\\n   * @param _index current index.\\n   */\\n  function setStakedContractCurrentCommissionIndex(\\n    address _stakedContractAddress,\\n    uint _index\\n  )\\n  public\\n  onlyInternal\\n  {\\n    stakedContractCurrentCommissionIndex[_stakedContractAddress] = _index;\\n  }\\n\\n  /**\\n   * @dev Sets the last complete commission index\\n   * @param _stakerAddress smart contract address.\\n   * @param _index current index.\\n   */\\n  function setLastCompletedStakeCommissionIndex(\\n    address _stakerAddress,\\n    uint _index\\n  )\\n  public\\n  onlyInternal\\n  {\\n    lastCompletedStakeCommission[_stakerAddress] = _index;\\n  }\\n\\n  /**\\n   * @dev Sets the index till which commission is distrubuted.\\n   * @param _stakedContractAddress smart contract address.\\n   * @param _index current index.\\n   */\\n  function setStakedContractCurrentBurnIndex(\\n    address _stakedContractAddress,\\n    uint _index\\n  )\\n  public\\n  onlyInternal\\n  {\\n    stakedContractCurrentBurnIndex[_stakedContractAddress] = _index;\\n  }\\n\\n  /**\\n   * @dev Updates Uint Parameters of a code\\n   * @param code whose details we want to update\\n   * @param val value to set\\n   */\\n  function updateUintParameters(bytes8 code, uint val) public {\\n    require(ms.checkIsAuthToGoverned(msg.sender));\\n    if (code == \\\"TOKEXP\\\") {\\n\\n      _setTokenExponent(val);\\n\\n    } else if (code == \\\"TOKSTEP\\\") {\\n\\n      _setPriceStep(val);\\n\\n    } else if (code == \\\"RALOCKT\\\") {\\n\\n      _changeSCValidDays(val);\\n\\n    } else if (code == \\\"RACOMM\\\") {\\n\\n      _setStakerCommissionPer(val);\\n\\n    } else if (code == \\\"RAMAXC\\\") {\\n\\n      _setStakerMaxCommissionPer(val);\\n\\n    } else if (code == \\\"CABOOKT\\\") {\\n\\n      _changeBookTime(val * 1 hours);\\n\\n    } else if (code == \\\"CALOCKT\\\") {\\n\\n      _changelockCADays(val * 1 days);\\n\\n    } else if (code == \\\"MVLOCKT\\\") {\\n\\n      _changelockMVDays(val * 1 days);\\n\\n    } else if (code == \\\"QUOLOCKT\\\") {\\n\\n      _setLockTokenTimeAfterCoverExp(val * 1 days);\\n\\n    } else if (code == \\\"JOINFEE\\\") {\\n\\n      _setJoiningFee(val);\\n\\n    } else {\\n      revert(\\\"Invalid param code\\\");\\n    }\\n  }\\n\\n  /**\\n   * @dev Internal function to get stake commission given to an\\n   * underwriter for particular stakedcontract on given index.\\n   * @param _stakerAddress address of staker.\\n   * @param _stakerIndex index of the staker commission.\\n   */\\n  function _getStakerEarnedStakeCommission(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  internal\\n  view\\n  returns (uint amount)\\n  {\\n    uint _stakedContractIndex;\\n    address _stakedContractAddress;\\n    _stakedContractAddress = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].stakedContractAddress;\\n    _stakedContractIndex = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].stakedContractIndex;\\n    amount = stakedContractStakeCommission[\\n    _stakedContractAddress][_stakedContractIndex].commissionEarned;\\n  }\\n\\n  /**\\n   * @dev Internal function to get stake commission redeemed by an\\n   * underwriter for particular stakedcontract on given index.\\n   * @param _stakerAddress address of staker.\\n   * @param _stakerIndex index of the staker commission.\\n   */\\n  function _getStakerRedeemedStakeCommission(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  internal\\n  view\\n  returns (uint amount)\\n  {\\n    uint _stakedContractIndex;\\n    address _stakedContractAddress;\\n    _stakedContractAddress = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].stakedContractAddress;\\n    _stakedContractIndex = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].stakedContractIndex;\\n    amount = stakedContractStakeCommission[\\n    _stakedContractAddress][_stakedContractIndex].commissionRedeemed;\\n  }\\n\\n  /**\\n   * @dev to set the percentage of staker commission\\n   * @param _val is new percentage value\\n   */\\n  function _setStakerCommissionPer(uint _val) internal {\\n    stakerCommissionPer = _val;\\n  }\\n\\n  /**\\n   * @dev to set the max percentage of staker commission\\n   * @param _val is new percentage value\\n   */\\n  function _setStakerMaxCommissionPer(uint _val) internal {\\n    stakerMaxCommissionPer = _val;\\n  }\\n\\n  /**\\n   * @dev to set the token exponent value\\n   * @param _val is new value\\n   */\\n  function _setTokenExponent(uint _val) internal {\\n    tokenExponent = _val;\\n  }\\n\\n  /**\\n   * @dev to set the price step\\n   * @param _val is new value\\n   */\\n  function _setPriceStep(uint _val) internal {\\n    priceStep = _val;\\n  }\\n\\n  /**\\n   * @dev Changes number of days for which NXM needs to staked in case of underwriting\\n   */\\n  function _changeSCValidDays(uint _days) internal {\\n    scValidDays = _days;\\n  }\\n\\n  /**\\n   * @dev Changes the time period up to which tokens will be locked.\\n   *      Used to generate the validity period of tokens booked by\\n   *      a user for participating in claim's assessment/claim's voting.\\n   */\\n  function _changeBookTime(uint _time) internal {\\n    bookTime = _time;\\n  }\\n\\n  /**\\n   * @dev Changes lock CA days - number of days for which tokens\\n   * are locked while submitting a vote.\\n   */\\n  function _changelockCADays(uint _val) internal {\\n    lockCADays = _val;\\n  }\\n\\n  /**\\n   * @dev Changes lock MV days - number of days for which tokens are locked\\n   * while submitting a vote.\\n   */\\n  function _changelockMVDays(uint _val) internal {\\n    lockMVDays = _val;\\n  }\\n\\n  /**\\n   * @dev Changes extra lock period for a cover, post its expiry.\\n   */\\n  function _setLockTokenTimeAfterCoverExp(uint time) internal {\\n    lockTokenTimeAfterCoverExp = time;\\n  }\\n\\n  /**\\n   * @dev Set the joining fee for membership\\n   */\\n  function _setJoiningFee(uint _amount) internal {\\n    joiningFee = _amount;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/token/TokenFunctions.sol\": {\r\n      \"content\": \"/* Copyright (C) 2020 NexusMutual.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../../interfaces/IPooledStaking.sol\\\";\\nimport \\\"../cover/QuotationData.sol\\\";\\nimport \\\"./NXMToken.sol\\\";\\nimport \\\"./TokenController.sol\\\";\\nimport \\\"./TokenData.sol\\\";\\n\\ncontract TokenFunctions is Iupgradable {\\n  using SafeMath for uint;\\n\\n  NXMToken public tk;\\n  TokenController public tc;\\n  TokenData public td;\\n  QuotationData public qd;\\n  IPooledStaking public pooledStaking;\\n\\n  event BurnCATokens(uint claimId, address addr, uint amount);\\n\\n  /**\\n   * @dev Rewards stakers on purchase of cover on smart contract.\\n   * @param _contractAddress smart contract address.\\n   * @param _coverPriceNXM cover price in NXM.\\n   */\\n  function pushStakerRewards(address _contractAddress, uint _coverPriceNXM) external onlyInternal {\\n    uint rewardValue = _coverPriceNXM.mul(td.stakerCommissionPer()).div(100);\\n    pooledStaking.accumulateReward(_contractAddress, rewardValue);\\n  }\\n\\n  /**\\n   * @dev Returns amount of NXM Tokens locked as Cover Note for given coverId.\\n   * @param _of address of the coverHolder.\\n   * @param _coverId coverId of the cover.\\n   */\\n  function getUserLockedCNTokens(address _of, uint _coverId) external view returns (uint) {\\n    return _getUserLockedCNTokens(_of, _coverId);\\n  }\\n\\n  /**\\n   * @dev to get the all the cover locked tokens of a user\\n   * @param _of is the user address in concern\\n   * @return amount locked\\n   */\\n  function getUserAllLockedCNTokens(address _of) external view returns (uint amount) {\\n    for (uint i = 0; i < qd.getUserCoverLength(_of); i++) {\\n      amount = amount.add(_getUserLockedCNTokens(_of, qd.getAllCoversOfUser(_of)[i]));\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns amount of NXM Tokens locked as Cover Note against given coverId.\\n   * @param _coverId coverId of the cover.\\n   */\\n  function getLockedCNAgainstCover(uint _coverId) external view returns (uint) {\\n    return _getLockedCNAgainstCover(_coverId);\\n  }\\n\\n  /**\\n   * @dev Change Dependent Contract Address\\n   */\\n  function changeDependentContractAddress() public {\\n    tk = NXMToken(ms.tokenAddress());\\n    td = TokenData(ms.getLatestAddress(\\\"TD\\\"));\\n    tc = TokenController(ms.getLatestAddress(\\\"TC\\\"));\\n    qd = QuotationData(ms.getLatestAddress(\\\"QD\\\"));\\n    pooledStaking = IPooledStaking(ms.getLatestAddress(\\\"PS\\\"));\\n  }\\n\\n  /**\\n   * @dev to burn the deposited cover tokens\\n   * @param coverId is id of cover whose tokens have to be burned\\n   * @return the status of the successful burning\\n   */\\n  function burnDepositCN(uint coverId) public onlyInternal returns (bool success) {\\n\\n    address _of = qd.getCoverMemberAddress(coverId);\\n    bytes32 reason = keccak256(abi.encodePacked(\\\"CN\\\", _of, coverId));\\n    uint lockedAmount = tc.tokensLocked(_of, reason);\\n\\n    (uint amount,) = td.depositedCN(coverId);\\n    amount = amount.div(2);\\n\\n    // limit burn amount to actual amount locked\\n    uint burnAmount = lockedAmount < amount ? lockedAmount : amount;\\n\\n    if (burnAmount != 0) {\\n      tc.burnLockedTokens(_of, reason, amount);\\n    }\\n\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Unlocks covernote locked against a given cover\\n   * @param coverId id of cover\\n   */\\n  function unlockCN(uint coverId) public onlyInternal {\\n    address coverHolder = qd.getCoverMemberAddress(coverId);\\n    bytes32 reason = keccak256(abi.encodePacked(\\\"CN\\\", coverHolder, coverId));\\n    uint lockedCN = tc.tokensLocked(coverHolder, reason);\\n    if (lockedCN != 0) {\\n      tc.releaseLockedTokens(coverHolder, reason, lockedCN);\\n    }\\n  }\\n\\n  /**\\n   * @dev Burns tokens used for fraudulent voting against a claim\\n   * @param claimid Claim Id.\\n   * @param _value number of tokens to be burned\\n   * @param _of Claim Assessor's address.\\n   */\\n  function burnCAToken(uint claimid, uint _value, address _of) public {\\n\\n    require(ms.checkIsAuthToGoverned(msg.sender));\\n    tc.burnLockedTokens(_of, \\\"CLA\\\", _value);\\n    emit BurnCATokens(claimid, _of, _value);\\n  }\\n\\n  /**\\n   * @dev to lock cover note tokens\\n   * @param coverNoteAmount is number of tokens to be locked\\n   * @param coverPeriod is cover period in concern\\n   * @param coverId is the cover id of cover in concern\\n   * @param _of address whose tokens are to be locked\\n   */\\n  function lockCN(\\n    uint coverNoteAmount,\\n    uint coverPeriod,\\n    uint coverId,\\n    address _of\\n  )\\n  public\\n  onlyInternal\\n  {\\n    uint gracePeriod = tc.claimSubmissionGracePeriod();\\n    uint validity = (coverPeriod * 1 days).add(gracePeriod);\\n    bytes32 reason = keccak256(abi.encodePacked(\\\"CN\\\", _of, coverId));\\n    td.setDepositCNAmount(coverId, coverNoteAmount);\\n    tc.lockOf(_of, reason, coverNoteAmount, validity);\\n  }\\n\\n  /**\\n   * @dev to check if a  member is locked for member vote\\n   * @param _of is the member address in concern\\n   * @return the boolean status\\n   */\\n  function isLockedForMemberVote(address _of) public view returns (bool) {\\n    return now < tk.isLockedForMV(_of);\\n  }\\n\\n  /**\\n   * @dev Returns amount of NXM Tokens locked as Cover Note for given coverId.\\n   * @param _coverId coverId of the cover.\\n   */\\n  function _getLockedCNAgainstCover(uint _coverId) internal view returns (uint) {\\n    address coverHolder = qd.getCoverMemberAddress(_coverId);\\n    bytes32 reason = keccak256(abi.encodePacked(\\\"CN\\\", coverHolder, _coverId));\\n    return tc.tokensLockedAtTime(coverHolder, reason, now);\\n  }\\n\\n  /**\\n   * @dev Returns amount of NXM Tokens locked as Cover Note for given coverId.\\n   * @param _of address of the coverHolder.\\n   * @param _coverId coverId of the cover.\\n   */\\n  function _getUserLockedCNTokens(address _of, uint _coverId) internal view returns (uint) {\\n    bytes32 reason = keccak256(abi.encodePacked(\\\"CN\\\", _of, _coverId));\\n    return tc.tokensLockedAtTime(_of, reason, now);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/cover/QuotationData.sol\": {\r\n      \"content\": \"/* Copyright (C) 2020 NexusMutual.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../../abstract/Iupgradable.sol\\\";\\n\\ncontract QuotationData is Iupgradable {\\n  using SafeMath for uint;\\n\\n  enum HCIDStatus {NA, kycPending, kycPass, kycFailedOrRefunded, kycPassNoCover}\\n\\n  enum CoverStatus {Active, ClaimAccepted, ClaimDenied, CoverExpired, ClaimSubmitted, Requested}\\n\\n  struct Cover {\\n    address payable memberAddress;\\n    bytes4 currencyCode;\\n    uint sumAssured;\\n    uint16 coverPeriod;\\n    uint validUntil;\\n    address scAddress;\\n    uint premiumNXM;\\n  }\\n\\n  struct HoldCover {\\n    uint holdCoverId;\\n    address payable userAddress;\\n    address scAddress;\\n    bytes4 coverCurr;\\n    uint[] coverDetails;\\n    uint16 coverPeriod;\\n  }\\n\\n  address public authQuoteEngine;\\n\\n  mapping(bytes4 => uint) internal currencyCSA;\\n  mapping(address => uint[]) internal userCover;\\n  mapping(address => uint[]) public userHoldedCover;\\n  mapping(address => bool) public refundEligible;\\n  mapping(address => mapping(bytes4 => uint)) internal currencyCSAOfSCAdd;\\n  mapping(uint => uint8) public coverStatus;\\n  mapping(uint => uint) public holdedCoverIDStatus;\\n  mapping(uint => bool) public timestampRepeated;\\n\\n\\n  Cover[] internal allCovers;\\n  HoldCover[] internal allCoverHolded;\\n\\n  uint public stlp;\\n  uint public stl;\\n  uint public pm;\\n  uint public minDays;\\n  uint public tokensRetained;\\n  address public kycAuthAddress;\\n\\n  event CoverDetailsEvent(\\n    uint indexed cid,\\n    address scAdd,\\n    uint sumAssured,\\n    uint expiry,\\n    uint premium,\\n    uint premiumNXM,\\n    bytes4 curr\\n  );\\n\\n  event CoverStatusEvent(uint indexed cid, uint8 statusNum);\\n\\n  constructor(address _authQuoteAdd, address _kycAuthAdd) public {\\n    authQuoteEngine = _authQuoteAdd;\\n    kycAuthAddress = _kycAuthAdd;\\n    stlp = 90;\\n    stl = 100;\\n    pm = 30;\\n    minDays = 30;\\n    tokensRetained = 10;\\n    allCovers.push(Cover(address(0), \\\"0x00\\\", 0, 0, 0, address(0), 0));\\n    uint[] memory arr = new uint[](1);\\n    allCoverHolded.push(HoldCover(0, address(0), address(0), 0x00, arr, 0));\\n\\n  }\\n\\n  /// @dev Adds the amount in Total Sum Assured of a given currency of a given smart contract address.\\n  /// @param _add Smart Contract Address.\\n  /// @param _amount Amount to be added.\\n  function addInTotalSumAssuredSC(address _add, bytes4 _curr, uint _amount) external onlyInternal {\\n    currencyCSAOfSCAdd[_add][_curr] = currencyCSAOfSCAdd[_add][_curr].add(_amount);\\n  }\\n\\n  /// @dev Subtracts the amount from Total Sum Assured of a given currency and smart contract address.\\n  /// @param _add Smart Contract Address.\\n  /// @param _amount Amount to be subtracted.\\n  function subFromTotalSumAssuredSC(address _add, bytes4 _curr, uint _amount) external onlyInternal {\\n    currencyCSAOfSCAdd[_add][_curr] = currencyCSAOfSCAdd[_add][_curr].sub(_amount);\\n  }\\n\\n  /// @dev Subtracts the amount from Total Sum Assured of a given currency.\\n  /// @param _curr Currency Name.\\n  /// @param _amount Amount to be subtracted.\\n  function subFromTotalSumAssured(bytes4 _curr, uint _amount) external onlyInternal {\\n    currencyCSA[_curr] = currencyCSA[_curr].sub(_amount);\\n  }\\n\\n  /// @dev Adds the amount in Total Sum Assured of a given currency.\\n  /// @param _curr Currency Name.\\n  /// @param _amount Amount to be added.\\n  function addInTotalSumAssured(bytes4 _curr, uint _amount) external onlyInternal {\\n    currencyCSA[_curr] = currencyCSA[_curr].add(_amount);\\n  }\\n\\n  /// @dev sets bit for timestamp to avoid replay attacks.\\n  function setTimestampRepeated(uint _timestamp) external onlyInternal {\\n    timestampRepeated[_timestamp] = true;\\n  }\\n\\n  /// @dev Creates a blank new cover.\\n  function addCover(\\n    uint16 _coverPeriod,\\n    uint _sumAssured,\\n    address payable _userAddress,\\n    bytes4 _currencyCode,\\n    address _scAddress,\\n    uint premium,\\n    uint premiumNXM\\n  )\\n  external\\n  onlyInternal\\n  {\\n    uint expiryDate = now.add(uint(_coverPeriod).mul(1 days));\\n    allCovers.push(Cover(_userAddress, _currencyCode,\\n      _sumAssured, _coverPeriod, expiryDate, _scAddress, premiumNXM));\\n    uint cid = allCovers.length.sub(1);\\n    userCover[_userAddress].push(cid);\\n    emit CoverDetailsEvent(cid, _scAddress, _sumAssured, expiryDate, premium, premiumNXM, _currencyCode);\\n  }\\n\\n  /// @dev create holded cover which will process after verdict of KYC.\\n  function addHoldCover(\\n    address payable from,\\n    address scAddress,\\n    bytes4 coverCurr,\\n    uint[] calldata coverDetails,\\n    uint16 coverPeriod\\n  )\\n  external\\n  onlyInternal\\n  {\\n    uint holdedCoverLen = allCoverHolded.length;\\n    holdedCoverIDStatus[holdedCoverLen] = uint(HCIDStatus.kycPending);\\n    allCoverHolded.push(HoldCover(holdedCoverLen, from, scAddress,\\n      coverCurr, coverDetails, coverPeriod));\\n    userHoldedCover[from].push(allCoverHolded.length.sub(1));\\n\\n  }\\n\\n  ///@dev sets refund eligible bit.\\n  ///@param _add user address.\\n  ///@param status indicates if user have pending kyc.\\n  function setRefundEligible(address _add, bool status) external onlyInternal {\\n    refundEligible[_add] = status;\\n  }\\n\\n  /// @dev to set current status of particular holded coverID (1 for not completed KYC,\\n  /// 2 for KYC passed, 3 for failed KYC or full refunded,\\n  /// 4 for KYC completed but cover not processed)\\n  function setHoldedCoverIDStatus(uint holdedCoverID, uint status) external onlyInternal {\\n    holdedCoverIDStatus[holdedCoverID] = status;\\n  }\\n\\n  /**\\n   * @dev to set address of kyc authentication\\n   * @param _add is the new address\\n   */\\n  function setKycAuthAddress(address _add) external onlyInternal {\\n    kycAuthAddress = _add;\\n  }\\n\\n  /// @dev Changes authorised address for generating quote off chain.\\n  function changeAuthQuoteEngine(address _add) external onlyInternal {\\n    authQuoteEngine = _add;\\n  }\\n\\n  /**\\n   * @dev Gets Uint Parameters of a code\\n   * @param code whose details we want\\n   * @return string value of the code\\n   * @return associated amount (time or perc or value) to the code\\n   */\\n  function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val) {\\n    codeVal = code;\\n\\n    if (code == \\\"STLP\\\") {\\n      val = stlp;\\n\\n    } else if (code == \\\"STL\\\") {\\n\\n      val = stl;\\n\\n    } else if (code == \\\"PM\\\") {\\n\\n      val = pm;\\n\\n    } else if (code == \\\"QUOMIND\\\") {\\n\\n      val = minDays;\\n\\n    } else if (code == \\\"QUOTOK\\\") {\\n\\n      val = tokensRetained;\\n\\n    }\\n\\n  }\\n\\n  /// @dev Gets Product details.\\n  /// @return  _minDays minimum cover period.\\n  /// @return  _PM Profit margin.\\n  /// @return  _STL short term Load.\\n  /// @return  _STLP short term load period.\\n  function getProductDetails()\\n  external\\n  view\\n  returns (\\n    uint _minDays,\\n    uint _pm,\\n    uint _stl,\\n    uint _stlp\\n  )\\n  {\\n\\n    _minDays = minDays;\\n    _pm = pm;\\n    _stl = stl;\\n    _stlp = stlp;\\n  }\\n\\n  /// @dev Gets total number covers created till date.\\n  function getCoverLength() external view returns (uint len) {\\n    return (allCovers.length);\\n  }\\n\\n  /// @dev Gets Authorised Engine address.\\n  function getAuthQuoteEngine() external view returns (address _add) {\\n    _add = authQuoteEngine;\\n  }\\n\\n  /// @dev Gets the Total Sum Assured amount of a given currency.\\n  function getTotalSumAssured(bytes4 _curr) external view returns (uint amount) {\\n    amount = currencyCSA[_curr];\\n  }\\n\\n  /// @dev Gets all the Cover ids generated by a given address.\\n  /// @param _add User's address.\\n  /// @return allCover array of covers.\\n  function getAllCoversOfUser(address _add) external view returns (uint[] memory allCover) {\\n    return (userCover[_add]);\\n  }\\n\\n  /// @dev Gets total number of covers generated by a given address\\n  function getUserCoverLength(address _add) external view returns (uint len) {\\n    len = userCover[_add].length;\\n  }\\n\\n  /// @dev Gets the status of a given cover.\\n  function getCoverStatusNo(uint _cid) external view returns (uint8) {\\n    return coverStatus[_cid];\\n  }\\n\\n  /// @dev Gets the Cover Period (in days) of a given cover.\\n  function getCoverPeriod(uint _cid) external view returns (uint32 cp) {\\n    cp = allCovers[_cid].coverPeriod;\\n  }\\n\\n  /// @dev Gets the Sum Assured Amount of a given cover.\\n  function getCoverSumAssured(uint _cid) external view returns (uint sa) {\\n    sa = allCovers[_cid].sumAssured;\\n  }\\n\\n  /// @dev Gets the Currency Name in which a given cover is assured.\\n  function getCurrencyOfCover(uint _cid) external view returns (bytes4 curr) {\\n    curr = allCovers[_cid].currencyCode;\\n  }\\n\\n  /// @dev Gets the validity date (timestamp) of a given cover.\\n  function getValidityOfCover(uint _cid) external view returns (uint date) {\\n    date = allCovers[_cid].validUntil;\\n  }\\n\\n  /// @dev Gets Smart contract address of cover.\\n  function getscAddressOfCover(uint _cid) external view returns (uint, address) {\\n    return (_cid, allCovers[_cid].scAddress);\\n  }\\n\\n  /// @dev Gets the owner address of a given cover.\\n  function getCoverMemberAddress(uint _cid) external view returns (address payable _add) {\\n    _add = allCovers[_cid].memberAddress;\\n  }\\n\\n  /// @dev Gets the premium amount of a given cover in NXM.\\n  function getCoverPremiumNXM(uint _cid) external view returns (uint _premiumNXM) {\\n    _premiumNXM = allCovers[_cid].premiumNXM;\\n  }\\n\\n  /// @dev Provides the details of a cover Id\\n  /// @param _cid cover Id\\n  /// @return memberAddress cover user address.\\n  /// @return scAddress smart contract Address\\n  /// @return currencyCode currency of cover\\n  /// @return sumAssured sum assured of cover\\n  /// @return premiumNXM premium in NXM\\n  function getCoverDetailsByCoverID1(\\n    uint _cid\\n  )\\n  external\\n  view\\n  returns (\\n    uint cid,\\n    address _memberAddress,\\n    address _scAddress,\\n    bytes4 _currencyCode,\\n    uint _sumAssured,\\n    uint premiumNXM\\n  )\\n  {\\n    return (\\n    _cid,\\n    allCovers[_cid].memberAddress,\\n    allCovers[_cid].scAddress,\\n    allCovers[_cid].currencyCode,\\n    allCovers[_cid].sumAssured,\\n    allCovers[_cid].premiumNXM\\n    );\\n  }\\n\\n  /// @dev Provides details of a cover Id\\n  /// @param _cid cover Id\\n  /// @return status status of cover.\\n  /// @return sumAssured Sum assurance of cover.\\n  /// @return coverPeriod Cover Period of cover (in days).\\n  /// @return validUntil is validity of cover.\\n  function getCoverDetailsByCoverID2(\\n    uint _cid\\n  )\\n  external\\n  view\\n  returns (\\n    uint cid,\\n    uint8 status,\\n    uint sumAssured,\\n    uint16 coverPeriod,\\n    uint validUntil\\n  )\\n  {\\n\\n    return (\\n    _cid,\\n    coverStatus[_cid],\\n    allCovers[_cid].sumAssured,\\n    allCovers[_cid].coverPeriod,\\n    allCovers[_cid].validUntil\\n    );\\n  }\\n\\n  /// @dev Provides details of a holded cover Id\\n  /// @param _hcid holded cover Id\\n  /// @return scAddress SmartCover address of cover.\\n  /// @return coverCurr currency of cover.\\n  /// @return coverPeriod Cover Period of cover (in days).\\n  function getHoldedCoverDetailsByID1(\\n    uint _hcid\\n  )\\n  external\\n  view\\n  returns (\\n    uint hcid,\\n    address scAddress,\\n    bytes4 coverCurr,\\n    uint16 coverPeriod\\n  )\\n  {\\n    return (\\n    _hcid,\\n    allCoverHolded[_hcid].scAddress,\\n    allCoverHolded[_hcid].coverCurr,\\n    allCoverHolded[_hcid].coverPeriod\\n    );\\n  }\\n\\n  /// @dev Gets total number holded covers created till date.\\n  function getUserHoldedCoverLength(address _add) external view returns (uint) {\\n    return userHoldedCover[_add].length;\\n  }\\n\\n  /// @dev Gets holded cover index by index of user holded covers.\\n  function getUserHoldedCoverByIndex(address _add, uint index) external view returns (uint) {\\n    return userHoldedCover[_add][index];\\n  }\\n\\n  /// @dev Provides the details of a holded cover Id\\n  /// @param _hcid holded cover Id\\n  /// @return memberAddress holded cover user address.\\n  /// @return coverDetails array contains SA, Cover Currency Price,Price in NXM, Expiration time of Qoute.\\n  function getHoldedCoverDetailsByID2(\\n    uint _hcid\\n  )\\n  external\\n  view\\n  returns (\\n    uint hcid,\\n    address payable memberAddress,\\n    uint[] memory coverDetails\\n  )\\n  {\\n    return (\\n    _hcid,\\n    allCoverHolded[_hcid].userAddress,\\n    allCoverHolded[_hcid].coverDetails\\n    );\\n  }\\n\\n  /// @dev Gets the Total Sum Assured amount of a given currency and smart contract address.\\n  function getTotalSumAssuredSC(address _add, bytes4 _curr) external view returns (uint amount) {\\n    amount = currencyCSAOfSCAdd[_add][_curr];\\n  }\\n\\n  //solhint-disable-next-line\\n  function changeDependentContractAddress() public {}\\n\\n  /// @dev Changes the status of a given cover.\\n  /// @param _cid cover Id.\\n  /// @param _stat New status.\\n  function changeCoverStatusNo(uint _cid, uint8 _stat) public onlyInternal {\\n    coverStatus[_cid] = _stat;\\n    emit CoverStatusEvent(_cid, _stat);\\n  }\\n\\n  /**\\n   * @dev Updates Uint Parameters of a code\\n   * @param code whose details we want to update\\n   * @param val value to set\\n   */\\n  function updateUintParameters(bytes8 code, uint val) public {\\n\\n    require(ms.checkIsAuthToGoverned(msg.sender));\\n    if (code == \\\"STLP\\\") {\\n      _changeSTLP(val);\\n\\n    } else if (code == \\\"STL\\\") {\\n\\n      _changeSTL(val);\\n\\n    } else if (code == \\\"PM\\\") {\\n\\n      _changePM(val);\\n\\n    } else if (code == \\\"QUOMIND\\\") {\\n\\n      _changeMinDays(val);\\n\\n    } else if (code == \\\"QUOTOK\\\") {\\n\\n      _setTokensRetained(val);\\n\\n    } else {\\n\\n      revert(\\\"Invalid param code\\\");\\n    }\\n\\n  }\\n\\n  /// @dev Changes the existing Profit Margin value\\n  function _changePM(uint _pm) internal {\\n    pm = _pm;\\n  }\\n\\n  /// @dev Changes the existing Short Term Load Period (STLP) value.\\n  function _changeSTLP(uint _stlp) internal {\\n    stlp = _stlp;\\n  }\\n\\n  /// @dev Changes the existing Short Term Load (STL) value.\\n  function _changeSTL(uint _stl) internal {\\n    stl = _stl;\\n  }\\n\\n  /// @dev Changes the existing Minimum cover period (in days)\\n  function _changeMinDays(uint _days) internal {\\n    minDays = _days;\\n  }\\n\\n  /**\\n   * @dev to set the the amount of tokens retained\\n   * @param val is the amount retained\\n   */\\n  function _setTokensRetained(uint val) internal {\\n    tokensRetained = val;\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/capital/Pool.sol\": {\r\n      \"content\": \"/* Copyright (C) 2020 NexusMutual.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\\\";\\nimport \\\"../../abstract/MasterAware.sol\\\";\\nimport \\\"../cover/Quotation.sol\\\";\\nimport \\\"../oracles/PriceFeedOracle.sol\\\";\\nimport \\\"../token/NXMToken.sol\\\";\\nimport \\\"../token/TokenController.sol\\\";\\nimport \\\"./MCR.sol\\\";\\nimport \\\"./SwapAgent.sol\\\";\\n\\ncontract Pool is MasterAware, ReentrancyGuard {\\n  using Address for address;\\n  using SafeMath for uint;\\n  using SafeERC20 for IERC20;\\n\\n  /* storage */\\n  address[] public assets;\\n  mapping(address => SwapAgent.AssetData) public assetData;\\n\\n  // contracts\\n  Quotation public quotation;\\n  NXMToken public nxmToken;\\n  TokenController public tokenController;\\n  MCR public mcr;\\n\\n  // parameters\\n  address public twapOracle;\\n  address public swapController;\\n  uint public minPoolEth;\\n  PriceFeedOracle public priceFeedOracle;\\n\\n  /* constants */\\n  address constant public ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n  uint public constant MCR_RATIO_DECIMALS = 4;\\n  uint public constant MAX_MCR_RATIO = 40000; // 400%\\n  uint public constant MAX_BUY_SELL_MCR_ETH_FRACTION = 500; // 5%. 4 decimal points\\n\\n  uint internal constant CONSTANT_C = 5800000;\\n  uint internal constant CONSTANT_A = 1028 * 1e13;\\n  uint internal constant TOKEN_EXPONENT = 4;\\n\\n  /* events */\\n  event Payout(address indexed to, address indexed asset, uint amount);\\n  event NXMSold (address indexed member, uint nxmIn, uint ethOut);\\n  event NXMBought (address indexed member, uint ethIn, uint nxmOut);\\n  event Swapped(address indexed fromAsset, address indexed toAsset, uint amountIn, uint amountOut);\\n\\n  /* logic */\\n  modifier onlySwapController {\\n    require(msg.sender == swapController, \\\"Pool: not swapController\\\");\\n    _;\\n  }\\n\\n  constructor (\\n    address[] memory _assets,\\n    uint112[] memory _minAmounts,\\n    uint112[] memory _maxAmounts,\\n    uint[] memory _maxSlippageRatios,\\n    address _master,\\n    address _priceOracle,\\n    address _twapOracle,\\n    address _swapController\\n  ) public {\\n\\n    require(_assets.length == _minAmounts.length, \\\"Pool: length mismatch\\\");\\n    require(_assets.length == _maxAmounts.length, \\\"Pool: length mismatch\\\");\\n    require(_assets.length == _maxSlippageRatios.length, \\\"Pool: length mismatch\\\");\\n\\n    for (uint i = 0; i < _assets.length; i++) {\\n\\n      address asset = _assets[i];\\n      require(asset != address(0), \\\"Pool: asset is zero address\\\");\\n      require(_maxAmounts[i] >= _minAmounts[i], \\\"Pool: max < min\\\");\\n      require(_maxSlippageRatios[i] <= 1 ether, \\\"Pool: max < min\\\");\\n\\n      assets.push(asset);\\n      assetData[asset].minAmount = _minAmounts[i];\\n      assetData[asset].maxAmount = _maxAmounts[i];\\n      assetData[asset].maxSlippageRatio = _maxSlippageRatios[i];\\n    }\\n\\n    master = INXMMaster(_master);\\n    priceFeedOracle = PriceFeedOracle(_priceOracle);\\n    twapOracle = _twapOracle;\\n    swapController = _swapController;\\n  }\\n\\n  // fallback function\\n  function() external payable {}\\n\\n  // for legacy Pool1 upgrade compatibility\\n  function sendEther() external payable {}\\n\\n  /**\\n   * @dev Calculates total value of all pool assets in ether\\n   */\\n  function getPoolValueInEth() public view returns (uint) {\\n\\n    uint total = address(this).balance;\\n\\n    for (uint i = 0; i < assets.length; i++) {\\n\\n      address assetAddress = assets[i];\\n      IERC20 token = IERC20(assetAddress);\\n\\n      uint rate = priceFeedOracle.getAssetToEthRate(assetAddress);\\n      require(rate > 0, \\\"Pool: zero rate\\\");\\n\\n      uint assetBalance = token.balanceOf(address(this));\\n      uint assetValue = assetBalance.mul(rate).div(1e18);\\n\\n      total = total.add(assetValue);\\n    }\\n\\n    return total;\\n  }\\n\\n  /* asset related functions */\\n\\n  function getAssets() external view returns (address[] memory) {\\n    return assets;\\n  }\\n\\n  function getAssetDetails(address _asset) external view returns (\\n    uint balance,\\n    uint112 min,\\n    uint112 max,\\n    uint32 lastAssetSwapTime,\\n    uint maxSlippageRatio\\n  ) {\\n\\n    IERC20 token = IERC20(_asset);\\n    balance = token.balanceOf(address(this));\\n    SwapAgent.AssetData memory data = assetData[_asset];\\n\\n    return (balance, data.minAmount, data.maxAmount, data.lastSwapTime, data.maxSlippageRatio);\\n  }\\n\\n  function addAsset(\\n    address _asset,\\n    uint112 _min,\\n    uint112 _max,\\n    uint _maxSlippageRatio\\n  ) external onlyGovernance {\\n\\n    require(_asset != address(0), \\\"Pool: asset is zero address\\\");\\n    require(_max >= _min, \\\"Pool: max < min\\\");\\n    require(_maxSlippageRatio <= 1 ether, \\\"Pool: max slippage ratio > 1\\\");\\n\\n    for (uint i = 0; i < assets.length; i++) {\\n      require(_asset != assets[i], \\\"Pool: asset exists\\\");\\n    }\\n\\n    assets.push(_asset);\\n    assetData[_asset] = SwapAgent.AssetData(_min, _max, 0, _maxSlippageRatio);\\n  }\\n\\n  function removeAsset(address _asset) external onlyGovernance {\\n\\n    for (uint i = 0; i < assets.length; i++) {\\n\\n      if (_asset != assets[i]) {\\n        continue;\\n      }\\n\\n      delete assetData[_asset];\\n      assets[i] = assets[assets.length - 1];\\n      assets.pop();\\n\\n      return;\\n    }\\n\\n    revert(\\\"Pool: asset not found\\\");\\n  }\\n\\n  function setAssetDetails(\\n    address _asset,\\n    uint112 _min,\\n    uint112 _max,\\n    uint _maxSlippageRatio\\n  ) external onlyGovernance {\\n\\n    require(_min <= _max, \\\"Pool: min > max\\\");\\n    require(_maxSlippageRatio <= 1 ether, \\\"Pool: max slippage ratio > 1\\\");\\n\\n    for (uint i = 0; i < assets.length; i++) {\\n\\n      if (_asset != assets[i]) {\\n        continue;\\n      }\\n\\n      assetData[_asset].minAmount = _min;\\n      assetData[_asset].maxAmount = _max;\\n      assetData[_asset].maxSlippageRatio = _maxSlippageRatio;\\n\\n      return;\\n    }\\n\\n    revert(\\\"Pool: asset not found\\\");\\n  }\\n\\n  /* swap functions */\\n\\n  function getSwapQuote(\\n    uint tokenAmountIn,\\n    IERC20 fromToken,\\n    IERC20 toToken\\n  ) public view returns (uint tokenAmountOut) {\\n\\n    return SwapAgent.getSwapQuote(\\n      tokenAmountIn,\\n      fromToken,\\n      toToken\\n    );\\n  }\\n\\n  function swapETHForAsset(\\n    address toTokenAddress,\\n    uint amountIn,\\n    uint amountOutMin\\n  ) external whenNotPaused onlySwapController nonReentrant {\\n\\n    SwapAgent.AssetData storage assetDetails = assetData[toTokenAddress];\\n\\n    uint amountOut = SwapAgent.swapETHForAsset(\\n      twapOracle,\\n      assetDetails,\\n      toTokenAddress,\\n      amountIn,\\n      amountOutMin,\\n      minPoolEth\\n    );\\n\\n    emit Swapped(ETH, toTokenAddress, amountIn, amountOut);\\n  }\\n\\n  function swapAssetForETH(\\n    address fromTokenAddress,\\n    uint amountIn,\\n    uint amountOutMin\\n  ) external whenNotPaused onlySwapController nonReentrant {\\n\\n    uint amountOut = SwapAgent.swapAssetForETH(\\n      twapOracle,\\n      assetData[fromTokenAddress],\\n      fromTokenAddress,\\n      amountIn,\\n      amountOutMin\\n    );\\n\\n    emit Swapped(fromTokenAddress, ETH, amountIn, amountOut);\\n  }\\n\\n  /* claim related functions */\\n\\n  /**\\n   * @dev Execute the payout in case a claim is accepted\\n   * @param asset token address or 0xEee...EEeE for ether\\n   * @param payoutAddress send funds to this address\\n   * @param amount amount to send\\n   */\\n  function sendClaimPayout (\\n    address asset,\\n    address payable payoutAddress,\\n    uint amount\\n  ) external onlyInternal nonReentrant returns (bool success) {\\n\\n    bool ok;\\n\\n    if (asset == ETH) {\\n      // solhint-disable-next-line avoid-low-level-calls\\n      (ok, /* data */) = payoutAddress.call.value(amount)(\\\"\\\");\\n    } else {\\n      ok =  _safeTokenTransfer(asset, payoutAddress, amount);\\n    }\\n\\n    if (ok) {\\n      emit Payout(payoutAddress, asset, amount);\\n    }\\n\\n    return ok;\\n  }\\n\\n  /**\\n   * @dev safeTransfer implementation that does not revert\\n   * @param tokenAddress ERC20 address\\n   * @param to destination\\n   * @param value amount to send\\n   * @return success true if the transfer was successfull\\n   */\\n  function _safeTokenTransfer (\\n    address tokenAddress,\\n    address to,\\n    uint256 value\\n  ) internal returns (bool) {\\n\\n    // token address is not a contract\\n    if (!tokenAddress.isContract()) {\\n      return false;\\n    }\\n\\n    IERC20 token = IERC20(tokenAddress);\\n    bytes memory data = abi.encodeWithSelector(token.transfer.selector, to, value);\\n    // solhint-disable-next-line avoid-low-level-calls\\n    (bool success, bytes memory returndata) = tokenAddress.call(data);\\n\\n    // low-level call failed/reverted\\n    if (!success) {\\n      return false;\\n    }\\n\\n    // tokens that don't have return data\\n    if (returndata.length == 0) {\\n      return true;\\n    }\\n\\n    // tokens that have return data will return a bool\\n    return abi.decode(returndata, (bool));\\n  }\\n\\n  /* pool lifecycle functions */\\n\\n  function transferAsset(\\n    address asset,\\n    address payable destination,\\n    uint amount\\n  ) external onlyGovernance nonReentrant {\\n\\n    require(assetData[asset].maxAmount == 0, \\\"Pool: max not zero\\\");\\n    require(destination != address(0), \\\"Pool: dest zero\\\");\\n\\n    IERC20 token = IERC20(asset);\\n    uint balance = token.balanceOf(address(this));\\n    uint transferableAmount = amount > balance ? balance : amount;\\n\\n    token.safeTransfer(destination, transferableAmount);\\n  }\\n\\n  function upgradeCapitalPool(address payable newPoolAddress) external onlyMaster nonReentrant {\\n\\n    // transfer ether\\n    uint ethBalance = address(this).balance;\\n    (bool ok, /* data */) = newPoolAddress.call.value(ethBalance)(\\\"\\\");\\n    require(ok, \\\"Pool: transfer failed\\\");\\n\\n    // transfer assets\\n    for (uint i = 0; i < assets.length; i++) {\\n      IERC20 token = IERC20(assets[i]);\\n      uint tokenBalance = token.balanceOf(address(this));\\n      token.safeTransfer(newPoolAddress, tokenBalance);\\n    }\\n\\n  }\\n\\n  /**\\n   * @dev Update dependent contract address\\n   * @dev Implements MasterAware interface function\\n   */\\n  function changeDependentContractAddress() public {\\n    nxmToken = NXMToken(master.tokenAddress());\\n    tokenController = TokenController(master.getLatestAddress(\\\"TC\\\"));\\n    quotation = Quotation(master.getLatestAddress(\\\"QT\\\"));\\n    mcr = MCR(master.getLatestAddress(\\\"MC\\\"));\\n  }\\n\\n  /* cover purchase functions */\\n\\n  /// @dev Enables user to purchase cover with funding in ETH.\\n  /// @param smartCAdd Smart Contract Address\\n  function makeCoverBegin(\\n    address smartCAdd,\\n    bytes4 coverCurr,\\n    uint[] memory coverDetails,\\n    uint16 coverPeriod,\\n    uint8 _v,\\n    bytes32 _r,\\n    bytes32 _s\\n  ) public payable onlyMember whenNotPaused {\\n\\n    require(coverCurr == \\\"ETH\\\", \\\"Pool: Unexpected asset type\\\");\\n    require(msg.value == coverDetails[1], \\\"Pool: ETH amount does not match premium\\\");\\n\\n    quotation.verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);\\n  }\\n\\n  /**\\n   * @dev Enables user to purchase cover via currency asset eg DAI\\n   */\\n  function makeCoverUsingCA(\\n    address smartCAdd,\\n    bytes4 coverCurr,\\n    uint[] memory coverDetails,\\n    uint16 coverPeriod,\\n    uint8 _v,\\n    bytes32 _r,\\n    bytes32 _s\\n  ) public onlyMember whenNotPaused {\\n    require(coverCurr != \\\"ETH\\\", \\\"Pool: Unexpected asset type\\\");\\n    quotation.verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);\\n  }\\n\\n  function transferAssetFrom (address asset, address from, uint amount) public onlyInternal whenNotPaused {\\n    IERC20 token = IERC20(asset);\\n    token.safeTransferFrom(from, address(this), amount);\\n  }\\n\\n  /* token sale functions */\\n\\n  /**\\n   * @dev (DEPRECATED, use sellTokens function instead) Allows selling of NXM for ether.\\n   * Seller first needs to give this contract allowance to\\n   * transfer/burn tokens in the NXMToken contract\\n   * @param  _amount Amount of NXM to sell\\n   * @return success returns true on successfull sale\\n   */\\n  function sellNXMTokens(uint _amount) public onlyMember whenNotPaused returns (bool success) {\\n    sellNXM(_amount, 0);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev (DEPRECATED, use calculateNXMForEth function instead) Returns the amount of wei a seller will get for selling NXM\\n   * @param amount Amount of NXM to sell\\n   * @return weiToPay Amount of wei the seller will get\\n   */\\n  function getWei(uint amount) external view returns (uint weiToPay) {\\n    return getEthForNXM(amount);\\n  }\\n\\n  /**\\n   * @dev Buys NXM tokens with ETH.\\n   * @param  minTokensOut Minimum amount of tokens to be bought. Revert if boughtTokens falls below this number.\\n   * @return boughtTokens number of bought tokens.\\n   */\\n  function buyNXM(uint minTokensOut) public payable onlyMember whenNotPaused {\\n\\n    uint ethIn = msg.value;\\n    require(ethIn > 0, \\\"Pool: ethIn > 0\\\");\\n\\n    uint totalAssetValue = getPoolValueInEth().sub(ethIn);\\n    uint mcrEth = mcr.getLastMCREther();\\n    uint mcrRatio = calculateMCRRatio(totalAssetValue, mcrEth);\\n    require(mcrRatio <= MAX_MCR_RATIO, \\\"Pool: Cannot purchase if MCR% > 400%\\\");\\n    uint tokensOut = calculateNXMForEth(ethIn, totalAssetValue, mcrEth);\\n    require(tokensOut >= minTokensOut, \\\"Pool: tokensOut is less than minTokensOut\\\");\\n    tokenController.mint(msg.sender, tokensOut);\\n\\n    emit NXMBought(msg.sender, ethIn, tokensOut);\\n  }\\n\\n  /**\\n   * @dev Sell NXM tokens and receive ETH.\\n   * @param tokenAmount Amount of tokens to sell.\\n   * @param  minEthOut Minimum amount of ETH to be received. Revert if ethOut falls below this number.\\n   * @return ethOut amount of ETH received in exchange for the tokens.\\n   */\\n  function sellNXM(uint tokenAmount, uint minEthOut) public onlyMember nonReentrant whenNotPaused {\\n\\n    require(nxmToken.balanceOf(msg.sender) >= tokenAmount, \\\"Pool: Not enough balance\\\");\\n    require(nxmToken.isLockedForMV(msg.sender) <= now, \\\"Pool: NXM tokens are locked for voting\\\");\\n\\n    uint currentTotalAssetValue = getPoolValueInEth();\\n    uint mcrEth = mcr.getLastMCREther();\\n    uint ethOut = calculateEthForNXM(tokenAmount, currentTotalAssetValue, mcrEth);\\n    require(currentTotalAssetValue.sub(ethOut) >= mcrEth, \\\"Pool: MCR% cannot fall below 100%\\\");\\n    require(ethOut >= minEthOut, \\\"Pool: ethOut < minEthOut\\\");\\n\\n    tokenController.burnFrom(msg.sender, tokenAmount);\\n    (bool ok, /* data */) = msg.sender.call.value(ethOut)(\\\"\\\");\\n    require(ok, \\\"Pool: Sell transfer failed\\\");\\n\\n    emit NXMSold(msg.sender, tokenAmount, ethOut);\\n  }\\n\\n  /**\\n   * @dev Get value in tokens for an ethAmount purchase.\\n   * @param ethAmount amount of ETH used for buying.\\n   * @return tokenValue tokens obtained by buying worth of ethAmount\\n   */\\n  function getNXMForEth(\\n    uint ethAmount\\n  ) public view returns (uint) {\\n    uint totalAssetValue = getPoolValueInEth();\\n    uint mcrEth = mcr.getLastMCREther();\\n    return calculateNXMForEth(ethAmount, totalAssetValue, mcrEth);\\n  }\\n\\n  function calculateNXMForEth(\\n    uint ethAmount,\\n    uint currentTotalAssetValue,\\n    uint mcrEth\\n  ) public pure returns (uint) {\\n\\n    require(\\n      ethAmount <= mcrEth.mul(MAX_BUY_SELL_MCR_ETH_FRACTION).div(10 ** MCR_RATIO_DECIMALS),\\n      \\\"Pool: Purchases worth higher than 5% of MCReth are not allowed\\\"\\n    );\\n\\n    /*\\n      The price formula is:\\n      P(V) = A + MCReth / C *  MCR% ^ 4\\n      where MCR% = V / MCReth\\n      P(V) = A + 1 / (C * MCReth ^ 3) *  V ^ 4\\n\\n      To compute the number of tokens issued we can integrate with respect to V the following:\\n        ΔT = ΔV / P(V)\\n        which assumes that for an infinitesimally small change in locked value V price is constant and we\\n        get an infinitesimally change in token supply ΔT.\\n      This is not computable on-chain, below we use an approximation that works well assuming\\n       * MCR% stays within [100%, 400%]\\n       * ethAmount <= 5% * MCReth\\n\\n      Use a simplified formula excluding the constant A price offset to compute the amount of tokens to be minted.\\n      AdjustedP(V) = 1 / (C * MCReth ^ 3) *  V ^ 4\\n      AdjustedP(V) = 1 / (C * MCReth ^ 3) *  V ^ 4\\n\\n      For a very small variation in tokens ΔT, we have,  ΔT = ΔV / P(V), to get total T we integrate with respect to V.\\n      adjustedTokenAmount = ∫ (dV / AdjustedP(V)) from V0 (currentTotalAssetValue) to V1 (nextTotalAssetValue)\\n      adjustedTokenAmount = ∫ ((C * MCReth ^ 3) / V ^ 4 * dV) from V0 to V1\\n      Evaluating the above using the antiderivative of the function we get:\\n      adjustedTokenAmount = - MCReth ^ 3 * C / (3 * V1 ^3) + MCReth * C /(3 * V0 ^ 3)\\n    */\\n\\n    if (currentTotalAssetValue == 0 || mcrEth.div(currentTotalAssetValue) > 1e12) {\\n      /*\\n       If the currentTotalAssetValue = 0, adjustedTokenPrice approaches 0. Therefore we can assume the price is A.\\n       If currentTotalAssetValue is far smaller than mcrEth, MCR% approaches 0, let the price be A (baseline price).\\n       This avoids overflow in the calculateIntegralAtPoint computation.\\n       This approximation is safe from arbitrage since at MCR% < 100% no sells are possible.\\n      */\\n      uint tokenPrice = CONSTANT_A;\\n      return ethAmount.mul(1e18).div(tokenPrice);\\n    }\\n\\n    // MCReth * C /(3 * V0 ^ 3)\\n    uint point0 = calculateIntegralAtPoint(currentTotalAssetValue, mcrEth);\\n    // MCReth * C / (3 * V1 ^3)\\n    uint nextTotalAssetValue = currentTotalAssetValue.add(ethAmount);\\n    uint point1 = calculateIntegralAtPoint(nextTotalAssetValue, mcrEth);\\n    uint adjustedTokenAmount = point0.sub(point1);\\n    /*\\n      Compute a preliminary adjustedTokenPrice for the minted tokens based on the adjustedTokenAmount above,\\n      and to that add the A constant (the price offset previously removed in the adjusted Price formula)\\n      to obtain the finalPrice and ultimately the tokenValue based on the finalPrice.\\n\\n      adjustedPrice = ethAmount / adjustedTokenAmount\\n      finalPrice = adjustedPrice + A\\n      tokenValue = ethAmount  / finalPrice\\n    */\\n    // ethAmount is multiplied by 1e18 to cancel out the multiplication factor of 1e18 of the adjustedTokenAmount\\n    uint adjustedTokenPrice = ethAmount.mul(1e18).div(adjustedTokenAmount);\\n    uint tokenPrice = adjustedTokenPrice.add(CONSTANT_A);\\n\\n    return ethAmount.mul(1e18).div(tokenPrice);\\n  }\\n\\n  /**\\n   * @dev integral(V) =  MCReth ^ 3 * C / (3 * V ^ 3) * 1e18\\n   * computation result is multiplied by 1e18 to allow for a precision of 18 decimals.\\n   * NOTE: omits the minus sign of the correct integral to use a uint result type for simplicity\\n   * WARNING: this low-level function should be called from a contract which checks that\\n   * mcrEth / assetValue < 1e17 (no overflow) and assetValue != 0\\n   */\\n  function calculateIntegralAtPoint(\\n    uint assetValue,\\n    uint mcrEth\\n  ) internal pure returns (uint) {\\n\\n    return CONSTANT_C\\n      .mul(1e18)\\n      .div(3)\\n      .mul(mcrEth).div(assetValue)\\n      .mul(mcrEth).div(assetValue)\\n      .mul(mcrEth).div(assetValue);\\n  }\\n\\n  function getEthForNXM(uint nxmAmount) public view returns (uint ethAmount) {\\n    uint currentTotalAssetValue = getPoolValueInEth();\\n    uint mcrEth = mcr.getLastMCREther();\\n    return calculateEthForNXM(nxmAmount, currentTotalAssetValue, mcrEth);\\n  }\\n\\n  /**\\n   * @dev Computes token sell value for a tokenAmount in ETH with a sell spread of 2.5%.\\n   * for values in ETH of the sale <= 1% * MCReth the sell spread is very close to the exact value of 2.5%.\\n   * for values higher than that sell spread may exceed 2.5%\\n   * (The higher amount being sold at any given time the higher the spread)\\n   */\\n  function calculateEthForNXM(\\n    uint nxmAmount,\\n    uint currentTotalAssetValue,\\n    uint mcrEth\\n  ) public pure returns (uint) {\\n\\n    // Step 1. Calculate spot price at current values and amount of ETH if tokens are sold at that price\\n    uint spotPrice0 = calculateTokenSpotPrice(currentTotalAssetValue, mcrEth);\\n    uint spotEthAmount = nxmAmount.mul(spotPrice0).div(1e18);\\n\\n    //  Step 2. Calculate spot price using V = currentTotalAssetValue - spotEthAmount from step 1\\n    uint totalValuePostSpotPriceSell = currentTotalAssetValue.sub(spotEthAmount);\\n    uint spotPrice1 = calculateTokenSpotPrice(totalValuePostSpotPriceSell, mcrEth);\\n\\n    // Step 3. Min [average[Price(0), Price(1)] x ( 1 - Sell Spread), Price(1) ]\\n    // Sell Spread = 2.5%\\n    uint averagePriceWithSpread = spotPrice0.add(spotPrice1).div(2).mul(975).div(1000);\\n    uint finalPrice = averagePriceWithSpread < spotPrice1 ? averagePriceWithSpread : spotPrice1;\\n    uint ethAmount = finalPrice.mul(nxmAmount).div(1e18);\\n\\n    require(\\n      ethAmount <= mcrEth.mul(MAX_BUY_SELL_MCR_ETH_FRACTION).div(10 ** MCR_RATIO_DECIMALS),\\n      \\\"Pool: Sales worth more than 5% of MCReth are not allowed\\\"\\n    );\\n\\n    return ethAmount;\\n  }\\n\\n  function calculateMCRRatio(uint totalAssetValue, uint mcrEth) public pure returns (uint) {\\n    return totalAssetValue.mul(10 ** MCR_RATIO_DECIMALS).div(mcrEth);\\n  }\\n\\n  /**\\n  * @dev Calculates token price in ETH 1 NXM token. TokenPrice = A + (MCReth / C) * MCR%^4\\n  */\\n  function calculateTokenSpotPrice(uint totalAssetValue, uint mcrEth) public pure returns (uint tokenPrice) {\\n\\n    uint mcrRatio = calculateMCRRatio(totalAssetValue, mcrEth);\\n    uint precisionDecimals = 10 ** TOKEN_EXPONENT.mul(MCR_RATIO_DECIMALS);\\n\\n    return mcrEth\\n      .mul(mcrRatio ** TOKEN_EXPONENT)\\n      .div(CONSTANT_C)\\n      .div(precisionDecimals)\\n      .add(CONSTANT_A);\\n  }\\n\\n  /**\\n   * @dev Returns the NXM price in a given asset\\n   * @param asset Asset name.\\n   */\\n  function getTokenPrice(address asset) public view returns (uint tokenPrice) {\\n\\n    uint totalAssetValue = getPoolValueInEth();\\n    uint mcrEth = mcr.getLastMCREther();\\n    uint tokenSpotPriceEth = calculateTokenSpotPrice(totalAssetValue, mcrEth);\\n\\n    return priceFeedOracle.getAssetForEth(asset, tokenSpotPriceEth);\\n  }\\n\\n  function getMCRRatio() public view returns (uint) {\\n    uint totalAssetValue = getPoolValueInEth();\\n    uint mcrEth = mcr.getLastMCREther();\\n    return calculateMCRRatio(totalAssetValue, mcrEth);\\n  }\\n\\n  function updateUintParameters(bytes8 code, uint value) external onlyGovernance {\\n\\n    if (code == \\\"MIN_ETH\\\") {\\n      minPoolEth = value;\\n      return;\\n    }\\n\\n    revert(\\\"Pool: unknown parameter\\\");\\n  }\\n\\n  function updateAddressParameters(bytes8 code, address value) external onlyGovernance {\\n\\n    if (code == \\\"TWAP\\\") {\\n      twapOracle = value;\\n      return;\\n    }\\n\\n    if (code == \\\"SWAP\\\") {\\n      swapController = value;\\n      return;\\n    }\\n\\n    if (code == \\\"PRC_FEED\\\") {\\n      priceFeedOracle = PriceFeedOracle(value);\\n      return;\\n    }\\n\\n    revert(\\\"Pool: unknown parameter\\\");\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/governance/ProposalCategory.sol\": {\r\n      \"content\": \"/* Copyright (C) 2017 GovBlocks.io\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\npragma solidity ^0.5.0;\\n\\nimport \\\"../../abstract/Iupgradable.sol\\\";\\nimport \\\"./MemberRoles.sol\\\";\\nimport \\\"./external/Governed.sol\\\";\\nimport \\\"./external/IProposalCategory.sol\\\";\\n\\ncontract ProposalCategory is Governed, IProposalCategory, Iupgradable {\\n\\n  bool public constructorCheck;\\n  MemberRoles internal mr;\\n\\n  struct CategoryStruct {\\n    uint memberRoleToVote;\\n    uint majorityVotePerc;\\n    uint quorumPerc;\\n    uint[] allowedToCreateProposal;\\n    uint closingTime;\\n    uint minStake;\\n  }\\n\\n  struct CategoryAction {\\n    uint defaultIncentive;\\n    address contractAddress;\\n    bytes2 contractName;\\n  }\\n\\n  CategoryStruct[] internal allCategory;\\n  mapping(uint => CategoryAction) internal categoryActionData;\\n  mapping(uint => uint) public categoryABReq;\\n  mapping(uint => uint) public isSpecialResolution;\\n  mapping(uint => bytes) public categoryActionHashes;\\n\\n  bool public categoryActionHashUpdated;\\n\\n  /**\\n  * @dev Adds new category (Discontinued, moved functionality to newCategory)\\n  * @param _name Category name\\n  * @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\\n  * @param _majorityVotePerc Majority Vote threshold for Each voting layer\\n  * @param _quorumPerc minimum threshold percentage required in voting to calculate result\\n  * @param _allowedToCreateProposal Member roles allowed to create the proposal\\n  * @param _closingTime Vote closing time for Each voting layer\\n  * @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\\n  * @param _contractAddress address of contract to call after proposal is accepted\\n  * @param _contractName name of contract to be called after proposal is accepted\\n  * @param _incentives rewards to distributed after proposal is accepted\\n  */\\n  function addCategory(\\n    string calldata _name,\\n    uint _memberRoleToVote,\\n    uint _majorityVotePerc,\\n    uint _quorumPerc,\\n    uint[] calldata _allowedToCreateProposal,\\n    uint _closingTime,\\n    string calldata _actionHash,\\n    address _contractAddress,\\n    bytes2 _contractName,\\n    uint[] calldata _incentives\\n  ) external {}\\n\\n  /**\\n  * @dev Initiates Default settings for Proposal Category contract (Adding default categories)\\n  */\\n  function proposalCategoryInitiate() external {}\\n\\n  /**\\n  * @dev Initiates Default action function hashes for existing categories\\n  * To be called after the contract has been upgraded by governance\\n  */\\n  function updateCategoryActionHashes() external onlyOwner {\\n\\n    require(!categoryActionHashUpdated, \\\"Category action hashes already updated\\\");\\n    categoryActionHashUpdated = true;\\n    categoryActionHashes[1] = abi.encodeWithSignature(\\\"addRole(bytes32,string,address)\\\");\\n    categoryActionHashes[2] = abi.encodeWithSignature(\\\"updateRole(address,uint256,bool)\\\");\\n    categoryActionHashes[3] = abi.encodeWithSignature(\\\"newCategory(string,uint256,uint256,uint256,uint256[],uint256,string,address,bytes2,uint256[],string)\\\"); // solhint-disable-line\\n    categoryActionHashes[4] = abi.encodeWithSignature(\\\"editCategory(uint256,string,uint256,uint256,uint256,uint256[],uint256,string,address,bytes2,uint256[],string)\\\"); // solhint-disable-line\\n    categoryActionHashes[5] = abi.encodeWithSignature(\\\"upgradeContractImplementation(bytes2,address)\\\");\\n    categoryActionHashes[6] = abi.encodeWithSignature(\\\"startEmergencyPause()\\\");\\n    categoryActionHashes[7] = abi.encodeWithSignature(\\\"addEmergencyPause(bool,bytes4)\\\");\\n    categoryActionHashes[8] = abi.encodeWithSignature(\\\"burnCAToken(uint256,uint256,address)\\\");\\n    categoryActionHashes[9] = abi.encodeWithSignature(\\\"setUserClaimVotePausedOn(address)\\\");\\n    categoryActionHashes[12] = abi.encodeWithSignature(\\\"transferEther(uint256,address)\\\");\\n    categoryActionHashes[13] = abi.encodeWithSignature(\\\"addInvestmentAssetCurrency(bytes4,address,bool,uint64,uint64,uint8)\\\"); // solhint-disable-line\\n    categoryActionHashes[14] = abi.encodeWithSignature(\\\"changeInvestmentAssetHoldingPerc(bytes4,uint64,uint64)\\\");\\n    categoryActionHashes[15] = abi.encodeWithSignature(\\\"changeInvestmentAssetStatus(bytes4,bool)\\\");\\n    categoryActionHashes[16] = abi.encodeWithSignature(\\\"swapABMember(address,address)\\\");\\n    categoryActionHashes[17] = abi.encodeWithSignature(\\\"addCurrencyAssetCurrency(bytes4,address,uint256)\\\");\\n    categoryActionHashes[20] = abi.encodeWithSignature(\\\"updateUintParameters(bytes8,uint256)\\\");\\n    categoryActionHashes[21] = abi.encodeWithSignature(\\\"updateUintParameters(bytes8,uint256)\\\");\\n    categoryActionHashes[22] = abi.encodeWithSignature(\\\"updateUintParameters(bytes8,uint256)\\\");\\n    categoryActionHashes[23] = abi.encodeWithSignature(\\\"updateUintParameters(bytes8,uint256)\\\");\\n    categoryActionHashes[24] = abi.encodeWithSignature(\\\"updateUintParameters(bytes8,uint256)\\\");\\n    categoryActionHashes[25] = abi.encodeWithSignature(\\\"updateUintParameters(bytes8,uint256)\\\");\\n    categoryActionHashes[26] = abi.encodeWithSignature(\\\"updateUintParameters(bytes8,uint256)\\\");\\n    categoryActionHashes[27] = abi.encodeWithSignature(\\\"updateAddressParameters(bytes8,address)\\\");\\n    categoryActionHashes[28] = abi.encodeWithSignature(\\\"updateOwnerParameters(bytes8,address)\\\");\\n    categoryActionHashes[29] = abi.encodeWithSignature(\\\"upgradeMultipleContracts(bytes2[],address[])\\\");\\n    categoryActionHashes[30] = abi.encodeWithSignature(\\\"changeCurrencyAssetAddress(bytes4,address)\\\");\\n    categoryActionHashes[31] = abi.encodeWithSignature(\\\"changeCurrencyAssetBaseMin(bytes4,uint256)\\\");\\n    categoryActionHashes[32] = abi.encodeWithSignature(\\\"changeInvestmentAssetAddressAndDecimal(bytes4,address,uint8)\\\"); // solhint-disable-line\\n    categoryActionHashes[33] = abi.encodeWithSignature(\\\"externalLiquidityTrade()\\\");\\n  }\\n\\n  /**\\n  * @dev Gets Total number of categories added till now\\n  */\\n  function totalCategories() external view returns (uint) {\\n    return allCategory.length;\\n  }\\n\\n  /**\\n  * @dev Gets category details\\n  */\\n  function category(uint _categoryId) external view returns (uint, uint, uint, uint, uint[] memory, uint, uint) {\\n    return (\\n    _categoryId,\\n    allCategory[_categoryId].memberRoleToVote,\\n    allCategory[_categoryId].majorityVotePerc,\\n    allCategory[_categoryId].quorumPerc,\\n    allCategory[_categoryId].allowedToCreateProposal,\\n    allCategory[_categoryId].closingTime,\\n    allCategory[_categoryId].minStake\\n    );\\n  }\\n\\n  /**\\n  * @dev Gets category ab required and isSpecialResolution\\n  * @return the category id\\n  * @return if AB voting is required\\n  * @return is category a special resolution\\n  */\\n  function categoryExtendedData(uint _categoryId) external view returns (uint, uint, uint) {\\n    return (\\n    _categoryId,\\n    categoryABReq[_categoryId],\\n    isSpecialResolution[_categoryId]\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets the category acion details\\n   * @param _categoryId is the category id in concern\\n   * @return the category id\\n   * @return the contract address\\n   * @return the contract name\\n   * @return the default incentive\\n   */\\n  function categoryAction(uint _categoryId) external view returns (uint, address, bytes2, uint) {\\n\\n    return (\\n    _categoryId,\\n    categoryActionData[_categoryId].contractAddress,\\n    categoryActionData[_categoryId].contractName,\\n    categoryActionData[_categoryId].defaultIncentive\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets the category acion details of a category id\\n   * @param _categoryId is the category id in concern\\n   * @return the category id\\n   * @return the contract address\\n   * @return the contract name\\n   * @return the default incentive\\n   * @return action function hash\\n   */\\n  function categoryActionDetails(uint _categoryId) external view returns (uint, address, bytes2, uint, bytes memory) {\\n    return (\\n    _categoryId,\\n    categoryActionData[_categoryId].contractAddress,\\n    categoryActionData[_categoryId].contractName,\\n    categoryActionData[_categoryId].defaultIncentive,\\n    categoryActionHashes[_categoryId]\\n    );\\n  }\\n\\n  /**\\n  * @dev Updates dependant contract addresses\\n  */\\n  function changeDependentContractAddress() public {\\n    mr = MemberRoles(ms.getLatestAddress(\\\"MR\\\"));\\n  }\\n\\n  /**\\n  * @dev Adds new category\\n  * @param _name Category name\\n  * @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\\n  * @param _majorityVotePerc Majority Vote threshold for Each voting layer\\n  * @param _quorumPerc minimum threshold percentage required in voting to calculate result\\n  * @param _allowedToCreateProposal Member roles allowed to create the proposal\\n  * @param _closingTime Vote closing time for Each voting layer\\n  * @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\\n  * @param _contractAddress address of contract to call after proposal is accepted\\n  * @param _contractName name of contract to be called after proposal is accepted\\n  * @param _incentives rewards to distributed after proposal is accepted\\n  * @param _functionHash function signature to be executed\\n  */\\n  function newCategory(\\n    string memory _name,\\n    uint _memberRoleToVote,\\n    uint _majorityVotePerc,\\n    uint _quorumPerc,\\n    uint[] memory _allowedToCreateProposal,\\n    uint _closingTime,\\n    string memory _actionHash,\\n    address _contractAddress,\\n    bytes2 _contractName,\\n    uint[] memory _incentives,\\n    string memory _functionHash\\n  )\\n  public\\n  onlyAuthorizedToGovern\\n  {\\n\\n    require(_quorumPerc <= 100 && _majorityVotePerc <= 100, \\\"Invalid percentage\\\");\\n\\n    require((_contractName == \\\"EX\\\" && _contractAddress == address(0)) || bytes(_functionHash).length > 0);\\n\\n    require(_incentives[3] <= 1, \\\"Invalid special resolution flag\\\");\\n\\n    //If category is special resolution role authorized should be member\\n    if (_incentives[3] == 1) {\\n      require(_memberRoleToVote == uint(MemberRoles.Role.Member));\\n      _majorityVotePerc = 0;\\n      _quorumPerc = 0;\\n    }\\n\\n    _addCategory(\\n      _name,\\n      _memberRoleToVote,\\n      _majorityVotePerc,\\n      _quorumPerc,\\n      _allowedToCreateProposal,\\n      _closingTime,\\n      _actionHash,\\n      _contractAddress,\\n      _contractName,\\n      _incentives\\n    );\\n\\n\\n    if (bytes(_functionHash).length > 0 && abi.encodeWithSignature(_functionHash).length == 4) {\\n      categoryActionHashes[allCategory.length - 1] = abi.encodeWithSignature(_functionHash);\\n    }\\n  }\\n\\n  /**\\n   * @dev Changes the master address and update it's instance\\n   * @param _masterAddress is the new master address\\n   */\\n  function changeMasterAddress(address _masterAddress) public {\\n    if (masterAddress != address(0))\\n      require(masterAddress == msg.sender);\\n    masterAddress = _masterAddress;\\n    ms = INXMMaster(_masterAddress);\\n    nxMasterAddress = _masterAddress;\\n\\n  }\\n\\n  /**\\n  * @dev Updates category details (Discontinued, moved functionality to editCategory)\\n  * @param _categoryId Category id that needs to be updated\\n  * @param _name Category name\\n  * @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\\n  * @param _allowedToCreateProposal Member roles allowed to create the proposal\\n  * @param _majorityVotePerc Majority Vote threshold for Each voting layer\\n  * @param _quorumPerc minimum threshold percentage required in voting to calculate result\\n  * @param _closingTime Vote closing time for Each voting layer\\n  * @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\\n  * @param _contractAddress address of contract to call after proposal is accepted\\n  * @param _contractName name of contract to be called after proposal is accepted\\n  * @param _incentives rewards to distributed after proposal is accepted\\n  */\\n  function updateCategory(\\n    uint _categoryId,\\n    string memory _name,\\n    uint _memberRoleToVote,\\n    uint _majorityVotePerc,\\n    uint _quorumPerc,\\n    uint[] memory _allowedToCreateProposal,\\n    uint _closingTime,\\n    string memory _actionHash,\\n    address _contractAddress,\\n    bytes2 _contractName,\\n    uint[] memory _incentives\\n  ) public {}\\n\\n  /**\\n  * @dev Updates category details\\n  * @param _categoryId Category id that needs to be updated\\n  * @param _name Category name\\n  * @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\\n  * @param _allowedToCreateProposal Member roles allowed to create the proposal\\n  * @param _majorityVotePerc Majority Vote threshold for Each voting layer\\n  * @param _quorumPerc minimum threshold percentage required in voting to calculate result\\n  * @param _closingTime Vote closing time for Each voting layer\\n  * @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\\n  * @param _contractAddress address of contract to call after proposal is accepted\\n  * @param _contractName name of contract to be called after proposal is accepted\\n  * @param _incentives rewards to distributed after proposal is accepted\\n  * @param _functionHash function signature to be executed\\n  */\\n  function editCategory(\\n    uint _categoryId,\\n    string memory _name,\\n    uint _memberRoleToVote,\\n    uint _majorityVotePerc,\\n    uint _quorumPerc,\\n    uint[] memory _allowedToCreateProposal,\\n    uint _closingTime,\\n    string memory _actionHash,\\n    address _contractAddress,\\n    bytes2 _contractName,\\n    uint[] memory _incentives,\\n    string memory _functionHash\\n  )\\n  public\\n  onlyAuthorizedToGovern\\n  {\\n    require(_verifyMemberRoles(_memberRoleToVote, _allowedToCreateProposal) == 1, \\\"Invalid Role\\\");\\n\\n    require(_quorumPerc <= 100 && _majorityVotePerc <= 100, \\\"Invalid percentage\\\");\\n\\n    require((_contractName == \\\"EX\\\" && _contractAddress == address(0)) || bytes(_functionHash).length > 0);\\n\\n    require(_incentives[3] <= 1, \\\"Invalid special resolution flag\\\");\\n\\n    //If category is special resolution role authorized should be member\\n    if (_incentives[3] == 1) {\\n      require(_memberRoleToVote == uint(MemberRoles.Role.Member));\\n      _majorityVotePerc = 0;\\n      _quorumPerc = 0;\\n    }\\n\\n    delete categoryActionHashes[_categoryId];\\n    if (bytes(_functionHash).length > 0 && abi.encodeWithSignature(_functionHash).length == 4) {\\n      categoryActionHashes[_categoryId] = abi.encodeWithSignature(_functionHash);\\n    }\\n    allCategory[_categoryId].memberRoleToVote = _memberRoleToVote;\\n    allCategory[_categoryId].majorityVotePerc = _majorityVotePerc;\\n    allCategory[_categoryId].closingTime = _closingTime;\\n    allCategory[_categoryId].allowedToCreateProposal = _allowedToCreateProposal;\\n    allCategory[_categoryId].minStake = _incentives[0];\\n    allCategory[_categoryId].quorumPerc = _quorumPerc;\\n    categoryActionData[_categoryId].defaultIncentive = _incentives[1];\\n    categoryActionData[_categoryId].contractName = _contractName;\\n    categoryActionData[_categoryId].contractAddress = _contractAddress;\\n    categoryABReq[_categoryId] = _incentives[2];\\n    isSpecialResolution[_categoryId] = _incentives[3];\\n    emit Category(_categoryId, _name, _actionHash);\\n  }\\n\\n  /**\\n  * @dev Internal call to add new category\\n  * @param _name Category name\\n  * @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\\n  * @param _majorityVotePerc Majority Vote threshold for Each voting layer\\n  * @param _quorumPerc minimum threshold percentage required in voting to calculate result\\n  * @param _allowedToCreateProposal Member roles allowed to create the proposal\\n  * @param _closingTime Vote closing time for Each voting layer\\n  * @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\\n  * @param _contractAddress address of contract to call after proposal is accepted\\n  * @param _contractName name of contract to be called after proposal is accepted\\n  * @param _incentives rewards to distributed after proposal is accepted\\n  */\\n  function _addCategory(\\n    string memory _name,\\n    uint _memberRoleToVote,\\n    uint _majorityVotePerc,\\n    uint _quorumPerc,\\n    uint[] memory _allowedToCreateProposal,\\n    uint _closingTime,\\n    string memory _actionHash,\\n    address _contractAddress,\\n    bytes2 _contractName,\\n    uint[] memory _incentives\\n  )\\n  internal\\n  {\\n    require(_verifyMemberRoles(_memberRoleToVote, _allowedToCreateProposal) == 1, \\\"Invalid Role\\\");\\n    allCategory.push(\\n      CategoryStruct(\\n        _memberRoleToVote,\\n        _majorityVotePerc,\\n        _quorumPerc,\\n        _allowedToCreateProposal,\\n        _closingTime,\\n        _incentives[0]\\n      )\\n    );\\n    uint categoryId = allCategory.length - 1;\\n    categoryActionData[categoryId] = CategoryAction(_incentives[1], _contractAddress, _contractName);\\n    categoryABReq[categoryId] = _incentives[2];\\n    isSpecialResolution[categoryId] = _incentives[3];\\n    emit Category(categoryId, _name, _actionHash);\\n  }\\n\\n  /**\\n  * @dev Internal call to check if given roles are valid or not\\n  */\\n  function _verifyMemberRoles(uint _memberRoleToVote, uint[] memory _allowedToCreateProposal)\\n  internal view returns (uint) {\\n    uint totalRoles = mr.totalRoles();\\n    if (_memberRoleToVote >= totalRoles) {\\n      return 0;\\n    }\\n    for (uint i = 0; i < _allowedToCreateProposal.length; i++) {\\n      if (_allowedToCreateProposal[i] >= totalRoles) {\\n        return 0;\\n      }\\n    }\\n    return 1;\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/modules/oracles/PriceFeedOracle.sol\": {\r\n      \"content\": \"/* Copyright (C) 2020 NexusMutual.io\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\ncontract Aggregator {\\n  function latestAnswer() public view returns (int);\\n}\\n\\ncontract PriceFeedOracle {\\n  using SafeMath for uint;\\n\\n  mapping (address => address) public aggregators;\\n  address public daiAddress;\\n  address constant public ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n  constructor (address[] memory assets, address[] memory _aggregators, address _daiAddress) public {\\n    require(assets.length == _aggregators.length, \\\"PriceFeedOracle: assets and _aggregators need to have same length\\\");\\n    for (uint i = 0; i < assets.length; i++) {\\n      aggregators[assets[i]] = _aggregators[i];\\n    }\\n    daiAddress = _daiAddress;\\n  }\\n\\n  /**\\n   * @dev Returns the amount of ether in wei that are equivalent to 1 unit (10 ** decimals) of asset\\n   * @param asset quoted currency\\n   * @return price in ether\\n   */\\n  function getAssetToEthRate(address asset) public view returns (uint) {\\n\\n    if (asset == ETH) {\\n      return 1 ether;\\n    }\\n\\n    address aggregatorAddress = aggregators[asset];\\n\\n    if (aggregatorAddress == address(0)) {\\n      revert(\\\"PriceFeedOracle: Oracle asset not found\\\");\\n    }\\n\\n    int rate = Aggregator(aggregatorAddress).latestAnswer();\\n    require(rate > 0, \\\"PriceFeedOracle: Rate must be > 0\\\");\\n\\n    return uint(rate);\\n  }\\n\\n  /**\\n  * @dev Returns the amount of currency that is equivalent to ethIn amount of ether.\\n  * @param asset quoted  Supported values: [\\\"DAI\\\", \\\"ETH\\\"]\\n  * @param ethIn amount of ether to be converted to the currency\\n  * @return price in ether\\n  */\\n  function getAssetForEth(address asset, uint ethIn) external view returns (uint) {\\n\\n    if (asset == daiAddress) {\\n      return ethIn.mul(1e18).div(getAssetToEthRate(daiAddress));\\n    }\\n\\n    if (asset == ETH) {\\n      return ethIn;\\n    }\\n\\n    revert(\\\"PriceFeedOracle: Unknown asset\\\");\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/modules/token/NXMToken.sol\": {\r\n      \"content\": \"/* Copyright (C) 2020 NexusMutual.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"./external/OZIERC20.sol\\\";\\nimport \\\"./external/OZSafeMath.sol\\\";\\n\\ncontract NXMToken is OZIERC20 {\\n  using OZSafeMath for uint256;\\n\\n  event WhiteListed(address indexed member);\\n\\n  event BlackListed(address indexed member);\\n\\n  mapping(address => uint256) private _balances;\\n\\n  mapping(address => mapping(address => uint256)) private _allowed;\\n\\n  mapping(address => bool) public whiteListed;\\n\\n  mapping(address => uint) public isLockedForMV;\\n\\n  uint256 private _totalSupply;\\n\\n  string public name = \\\"NXM\\\";\\n  string public symbol = \\\"NXM\\\";\\n  uint8 public decimals = 18;\\n  address public operator;\\n\\n  modifier canTransfer(address _to) {\\n    require(whiteListed[_to]);\\n    _;\\n  }\\n\\n  modifier onlyOperator() {\\n    if (operator != address(0))\\n      require(msg.sender == operator);\\n    _;\\n  }\\n\\n  constructor(address _founderAddress, uint _initialSupply) public {\\n    _mint(_founderAddress, _initialSupply);\\n  }\\n\\n  /**\\n  * @dev Total number of tokens in existence\\n  */\\n  function totalSupply() public view returns (uint256) {\\n    return _totalSupply;\\n  }\\n\\n  /**\\n  * @dev Gets the balance of the specified address.\\n  * @param owner The address to query the balance of.\\n  * @return An uint256 representing the amount owned by the passed address.\\n  */\\n  function balanceOf(address owner) public view returns (uint256) {\\n    return _balances[owner];\\n  }\\n\\n  /**\\n  * @dev Function to check the amount of tokens that an owner allowed to a spender.\\n  * @param owner address The address which owns the funds.\\n  * @param spender address The address which will spend the funds.\\n  * @return A uint256 specifying the amount of tokens still available for the spender.\\n  */\\n  function allowance(\\n    address owner,\\n    address spender\\n  )\\n  public\\n  view\\n  returns (uint256)\\n  {\\n    return _allowed[owner][spender];\\n  }\\n\\n  /**\\n  * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\n  * Beware that changing an allowance with this method brings the risk that someone may use both the old\\n  * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\\n  * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\\n  * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n  * @param spender The address which will spend the funds.\\n  * @param value The amount of tokens to be spent.\\n  */\\n  function approve(address spender, uint256 value) public returns (bool) {\\n    require(spender != address(0));\\n\\n    _allowed[msg.sender][spender] = value;\\n    emit Approval(msg.sender, spender, value);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Increase the amount of tokens that an owner allowed to a spender.\\n  * approve should be called when allowed_[_spender] == 0. To increment\\n  * allowed value is better to use this function to avoid 2 calls (and wait until\\n  * the first transaction is mined)\\n  * From MonolithDAO Token.sol\\n  * @param spender The address which will spend the funds.\\n  * @param addedValue The amount of tokens to increase the allowance by.\\n  */\\n  function increaseAllowance(\\n    address spender,\\n    uint256 addedValue\\n  )\\n  public\\n  returns (bool)\\n  {\\n    require(spender != address(0));\\n\\n    _allowed[msg.sender][spender] = (\\n    _allowed[msg.sender][spender].add(addedValue));\\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Decrease the amount of tokens that an owner allowed to a spender.\\n  * approve should be called when allowed_[_spender] == 0. To decrement\\n  * allowed value is better to use this function to avoid 2 calls (and wait until\\n  * the first transaction is mined)\\n  * From MonolithDAO Token.sol\\n  * @param spender The address which will spend the funds.\\n  * @param subtractedValue The amount of tokens to decrease the allowance by.\\n  */\\n  function decreaseAllowance(\\n    address spender,\\n    uint256 subtractedValue\\n  )\\n  public\\n  returns (bool)\\n  {\\n    require(spender != address(0));\\n\\n    _allowed[msg.sender][spender] = (\\n    _allowed[msg.sender][spender].sub(subtractedValue));\\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Adds a user to whitelist\\n  * @param _member address to add to whitelist\\n  */\\n  function addToWhiteList(address _member) public onlyOperator returns (bool) {\\n    whiteListed[_member] = true;\\n    emit WhiteListed(_member);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev removes a user from whitelist\\n  * @param _member address to remove from whitelist\\n  */\\n  function removeFromWhiteList(address _member) public onlyOperator returns (bool) {\\n    whiteListed[_member] = false;\\n    emit BlackListed(_member);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev change operator address\\n  * @param _newOperator address of new operator\\n  */\\n  function changeOperator(address _newOperator) public onlyOperator returns (bool) {\\n    operator = _newOperator;\\n    return true;\\n  }\\n\\n  /**\\n  * @dev burns an amount of the tokens of the message sender\\n  * account.\\n  * @param amount The amount that will be burnt.\\n  */\\n  function burn(uint256 amount) public returns (bool) {\\n    _burn(msg.sender, amount);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Burns a specific amount of tokens from the target address and decrements allowance\\n  * @param from address The address which you want to send tokens from\\n  * @param value uint256 The amount of token to be burned\\n  */\\n  function burnFrom(address from, uint256 value) public returns (bool) {\\n    _burnFrom(from, value);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev function that mints an amount of the token and assigns it to\\n  * an account.\\n  * @param account The account that will receive the created tokens.\\n  * @param amount The amount that will be created.\\n  */\\n  function mint(address account, uint256 amount) public onlyOperator {\\n    _mint(account, amount);\\n  }\\n\\n  /**\\n  * @dev Transfer token for a specified address\\n  * @param to The address to transfer to.\\n  * @param value The amount to be transferred.\\n  */\\n  function transfer(address to, uint256 value) public canTransfer(to) returns (bool) {\\n\\n    require(isLockedForMV[msg.sender] < now); // if not voted under governance\\n    require(value <= _balances[msg.sender]);\\n    _transfer(to, value);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Transfer tokens to the operator from the specified address\\n  * @param from The address to transfer from.\\n  * @param value The amount to be transferred.\\n  */\\n  function operatorTransfer(address from, uint256 value) public onlyOperator returns (bool) {\\n    require(value <= _balances[from]);\\n    _transferFrom(from, operator, value);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Transfer tokens from one address to another\\n  * @param from address The address which you want to send tokens from\\n  * @param to address The address which you want to transfer to\\n  * @param value uint256 the amount of tokens to be transferred\\n  */\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 value\\n  )\\n  public\\n  canTransfer(to)\\n  returns (bool)\\n  {\\n    require(isLockedForMV[from] < now); // if not voted under governance\\n    require(value <= _balances[from]);\\n    require(value <= _allowed[from][msg.sender]);\\n    _transferFrom(from, to, value);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Lock the user's tokens\\n   * @param _of user's address.\\n   */\\n  function lockForMemberVote(address _of, uint _days) public onlyOperator {\\n    if (_days.add(now) > isLockedForMV[_of])\\n      isLockedForMV[_of] = _days.add(now);\\n  }\\n\\n  /**\\n  * @dev Transfer token for a specified address\\n  * @param to The address to transfer to.\\n  * @param value The amount to be transferred.\\n  */\\n  function _transfer(address to, uint256 value) internal {\\n    _balances[msg.sender] = _balances[msg.sender].sub(value);\\n    _balances[to] = _balances[to].add(value);\\n    emit Transfer(msg.sender, to, value);\\n  }\\n\\n  /**\\n  * @dev Transfer tokens from one address to another\\n  * @param from address The address which you want to send tokens from\\n  * @param to address The address which you want to transfer to\\n  * @param value uint256 the amount of tokens to be transferred\\n  */\\n  function _transferFrom(\\n    address from,\\n    address to,\\n    uint256 value\\n  )\\n  internal\\n  {\\n    _balances[from] = _balances[from].sub(value);\\n    _balances[to] = _balances[to].add(value);\\n    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\\n    emit Transfer(from, to, value);\\n  }\\n\\n  /**\\n  * @dev Internal function that mints an amount of the token and assigns it to\\n  * an account. This encapsulates the modification of balances such that the\\n  * proper events are emitted.\\n  * @param account The account that will receive the created tokens.\\n  * @param amount The amount that will be created.\\n  */\\n  function _mint(address account, uint256 amount) internal {\\n    require(account != address(0));\\n    _totalSupply = _totalSupply.add(amount);\\n    _balances[account] = _balances[account].add(amount);\\n    emit Transfer(address(0), account, amount);\\n  }\\n\\n  /**\\n  * @dev Internal function that burns an amount of the token of a given\\n  * account.\\n  * @param account The account whose tokens will be burnt.\\n  * @param amount The amount that will be burnt.\\n  */\\n  function _burn(address account, uint256 amount) internal {\\n    require(amount <= _balances[account]);\\n\\n    _totalSupply = _totalSupply.sub(amount);\\n    _balances[account] = _balances[account].sub(amount);\\n    emit Transfer(account, address(0), amount);\\n  }\\n\\n  /**\\n  * @dev Internal function that burns an amount of the token of a given\\n  * account, deducting from the sender's allowance for said account. Uses the\\n  * internal burn function.\\n  * @param account The account whose tokens will be burnt.\\n  * @param value The amount that will be burnt.\\n  */\\n  function _burnFrom(address account, uint256 value) internal {\\n    require(value <= _allowed[account][msg.sender]);\\n\\n    // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,\\n    // this function needs to emit an event with the updated approval.\\n    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(\\n      value);\\n    _burn(account, value);\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves.\\n\\n        // A Solidity high level call has three parts:\\n        //  1. The target address is checked to verify it contains contract code\\n        //  2. The call itself is made, and success asserted\\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\\n        // solhint-disable-next-line max-line-length\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\n\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n *\\n * _Since v2.5.0:_ this module is now much more gas efficient, given net gas\\n * metering changes introduced in the Istanbul hardfork.\\n */\\ncontract ReentrancyGuard {\\n    bool private _notEntered;\\n\\n    constructor () internal {\\n        // Storing an initial non-zero value makes deployment a bit more\\n        // expensive, but in exchange the refund on every call to nonReentrant\\n        // will be lower in amount. Since refunds are capped to a percetange of\\n        // the total transaction's gas, it is best to keep them low in cases\\n        // like this one, to increase the likelihood of the full refund coming\\n        // into effect.\\n        _notEntered = true;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_notEntered, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _notEntered = false;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _notEntered = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.5;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following \\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256('')`\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != accountHash && codehash != 0x0);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` into `address payable`. Note that this is\\n     * simply a type cast: the actual underlying value is not changed.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function toPayable(address account) internal pure returns (address payable) {\\n        return address(uint160(account));\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-call-value\\n        (bool success, ) = recipient.call.value(amount)(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    },\r\n    \"contracts/abstract/MasterAware.sol\": {\r\n      \"content\": \"/*\\n    Copyright (C) 2020 NexusMutual.io\\n\\n    This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n    This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n    You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/\\n*/\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"./INXMMaster.sol\\\";\\n\\ncontract MasterAware {\\n\\n  INXMMaster public master;\\n\\n  modifier onlyMember {\\n    require(master.isMember(msg.sender), \\\"Caller is not a member\\\");\\n    _;\\n  }\\n\\n  modifier onlyInternal {\\n    require(master.isInternal(msg.sender), \\\"Caller is not an internal contract\\\");\\n    _;\\n  }\\n\\n  modifier onlyMaster {\\n    if (address(master) != address(0)) {\\n      require(address(master) == msg.sender, \\\"Not master\\\");\\n    }\\n    _;\\n  }\\n\\n  modifier onlyGovernance {\\n    require(\\n      master.checkIsAuthToGoverned(msg.sender),\\n      \\\"Caller is not authorized to govern\\\"\\n    );\\n    _;\\n  }\\n\\n  modifier whenPaused {\\n    require(master.isPause(), \\\"System is not paused\\\");\\n    _;\\n  }\\n\\n  modifier whenNotPaused {\\n    require(!master.isPause(), \\\"System is paused\\\");\\n    _;\\n  }\\n\\n  function changeMasterAddress(address masterAddress) public onlyMaster {\\n    master = INXMMaster(masterAddress);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/capital/SwapAgent.sol\": {\r\n      \"content\": \"/* Copyright (C) 2020 NexusMutual.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"../../external/uniswap/IUniswapV2Router02.sol\\\";\\nimport \\\"../oracles/TwapOracle.sol\\\";\\n\\nlibrary SwapAgent {\\n  using SafeMath for uint;\\n\\n  struct AssetData {\\n    uint112 minAmount;\\n    uint112 maxAmount;\\n    uint32 lastSwapTime;\\n    // 18 decimals of precision. 0.01% -> 0.0001 -> 1e14\\n    uint maxSlippageRatio;\\n  }\\n\\n  IUniswapV2Router02 constant public router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\n  uint constant public MAX_LIQUIDITY_RATIO = 3 * 1e15;\\n\\n  function getSwapQuote(\\n    uint tokenAmountIn,\\n    IERC20 fromToken,\\n    IERC20 toToken\\n  ) public view returns (uint tokenAmountOut) {\\n\\n    address[] memory path = new address[](2);\\n    path[0] = address(fromToken);\\n    path[1] = address(toToken);\\n    uint[] memory amountsOut = router.getAmountsOut(tokenAmountIn, path);\\n\\n    return amountsOut[1];\\n  }\\n\\n  function swapETHForAsset(\\n    address _oracle,\\n    AssetData storage assetData,\\n    address toTokenAddress,\\n    uint amountIn,\\n    uint amountOutMin,\\n    uint minLeftETH\\n  ) external returns (uint) {\\n\\n    uint balanceBefore = IERC20(toTokenAddress).balanceOf(address(this));\\n    address WETH = router.WETH();\\n\\n    {\\n      // scope for swap frequency check\\n      uint timeSinceLastTrade = block.timestamp.sub(uint(assetData.lastSwapTime));\\n      require(timeSinceLastTrade > TwapOracle(_oracle).periodSize(), \\\"SwapAgent: too fast\\\");\\n    }\\n\\n    {\\n      // scope for liquidity check\\n      address pairAddress = TwapOracle(_oracle).pairFor(WETH, toTokenAddress);\\n      IUniswapV2Pair pair = IUniswapV2Pair(pairAddress);\\n      (uint112 reserve0, uint112 reserve1, /* time */) = pair.getReserves();\\n\\n      uint ethReserve = WETH < toTokenAddress ? reserve0 : reserve1;\\n      uint maxTradable = ethReserve.mul(MAX_LIQUIDITY_RATIO).div(1e18);\\n\\n      require(amountIn <= maxTradable, \\\"SwapAgent: exceeds max tradable amount\\\");\\n    }\\n\\n    {\\n      // scope for ether checks\\n      uint ethBalanceBefore = address(this).balance;\\n      uint ethBalanceAfter = ethBalanceBefore.sub(amountIn);\\n      require(ethBalanceAfter >= minLeftETH, \\\"SwapAgent: insufficient ether left\\\");\\n    }\\n\\n    {\\n      // scope for token checks\\n      uint avgAmountOut = TwapOracle(_oracle).consult(WETH, amountIn, toTokenAddress);\\n      uint maxSlippageAmount = avgAmountOut.mul(assetData.maxSlippageRatio).div(1e18);\\n      uint minOutOnMaxSlippage = avgAmountOut.sub(maxSlippageAmount);\\n\\n      // gas optimisation: reads both values using a single SLOAD\\n      (uint minAssetAmount, uint maxAssetAmount) = (assetData.minAmount, assetData.maxAmount);\\n\\n      require(amountOutMin >= minOutOnMaxSlippage, \\\"SwapAgent: amountOutMin < minOutOnMaxSlippage\\\");\\n      require(balanceBefore < minAssetAmount, \\\"SwapAgent: balanceBefore >= min\\\");\\n      require(balanceBefore.add(amountOutMin) <= maxAssetAmount, \\\"SwapAgent: balanceAfter > max\\\");\\n    }\\n\\n    address[] memory path = new address[](2);\\n    path[0] = WETH;\\n    path[1] = toTokenAddress;\\n    router.swapExactETHForTokens.value(amountIn)(amountOutMin, path, address(this), block.timestamp);\\n\\n    assetData.lastSwapTime = uint32(block.timestamp);\\n\\n    uint balanceAfter = IERC20(toTokenAddress).balanceOf(address(this));\\n    uint amountOut = balanceAfter.sub(balanceBefore);\\n\\n    return amountOut;\\n  }\\n\\n  function swapAssetForETH(\\n    address _oracle,\\n    AssetData storage assetData,\\n    address fromTokenAddress,\\n    uint amountIn,\\n    uint amountOutMin\\n  ) external returns (uint) {\\n\\n    uint tokenBalanceBefore = IERC20(fromTokenAddress).balanceOf(address(this));\\n    uint balanceBefore = address(this).balance;\\n    address WETH = router.WETH();\\n\\n    {\\n      // scope for swap frequency check\\n      uint timeSinceLastTrade = block.timestamp.sub(uint(assetData.lastSwapTime));\\n      require(timeSinceLastTrade > TwapOracle(_oracle).periodSize(), \\\"SwapAgent: too fast\\\");\\n    }\\n\\n    {\\n      // scope for liquidity check\\n      address pairAddress = TwapOracle(_oracle).pairFor(fromTokenAddress, WETH);\\n      IUniswapV2Pair pair = IUniswapV2Pair(pairAddress);\\n      (uint112 reserve0, uint112 reserve1, /* time */) = pair.getReserves();\\n\\n      uint tokenReserve = fromTokenAddress < WETH ? reserve0 : reserve1;\\n      uint maxTradable = tokenReserve.mul(MAX_LIQUIDITY_RATIO).div(1e18);\\n\\n      require(amountIn <= maxTradable, \\\"SwapAgent: exceeds max tradable amount\\\");\\n    }\\n\\n    {\\n      // scope for token checks\\n      uint avgAmountOut = TwapOracle(_oracle).consult(fromTokenAddress, amountIn, WETH);\\n      uint maxSlippageAmount = avgAmountOut.mul(assetData.maxSlippageRatio).div(1e18);\\n      uint minOutOnMaxSlippage = avgAmountOut.sub(maxSlippageAmount);\\n\\n      // gas optimisation: reads both values using a single SLOAD\\n      (uint minAssetAmount, uint maxAssetAmount) = (assetData.minAmount, assetData.maxAmount);\\n\\n      require(amountOutMin >= minOutOnMaxSlippage, \\\"SwapAgent: amountOutMin < minOutOnMaxSlippage\\\");\\n      require(tokenBalanceBefore > maxAssetAmount, \\\"SwapAgent: tokenBalanceBefore <= max\\\");\\n      require(tokenBalanceBefore.sub(amountIn) >= minAssetAmount, \\\"SwapAgent: tokenBalanceAfter < min\\\");\\n    }\\n\\n    address[] memory path = new address[](2);\\n    path[0] = fromTokenAddress;\\n    path[1] = router.WETH();\\n    IERC20(fromTokenAddress).approve(address(router), amountIn);\\n    router.swapExactTokensForETH(amountIn, amountOutMin, path, address(this), block.timestamp);\\n\\n    assetData.lastSwapTime = uint32(block.timestamp);\\n\\n    uint balanceAfter = address(this).balance;\\n    uint amountOut = balanceAfter.sub(balanceBefore);\\n\\n    return amountOut;\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/abstract/INXMMaster.sol\": {\r\n      \"content\": \"/* Copyright (C) 2020 NexusMutual.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\ncontract INXMMaster {\\n\\n  address public tokenAddress;\\n\\n  address public owner;\\n\\n  uint public pauseTime;\\n\\n  function delegateCallBack(bytes32 myid) external;\\n\\n  function masterInitialized() public view returns (bool);\\n\\n  function isInternal(address _add) public view returns (bool);\\n\\n  function isPause() public view returns (bool check);\\n\\n  function isOwner(address _add) public view returns (bool);\\n\\n  function isMember(address _add) public view returns (bool);\\n\\n  function checkIsAuthToGoverned(address _add) public view returns (bool);\\n\\n  function updatePauseTime(uint _time) public;\\n\\n  function dAppLocker() public view returns (address _add);\\n\\n  function dAppToken() public view returns (address _add);\\n\\n  function getLatestAddress(bytes2 _contractName) public view returns (address payable contractAddress);\\n}\\n\"\r\n    },\r\n    \"contracts/abstract/Iupgradable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./INXMMaster.sol\\\";\\n\\ncontract Iupgradable {\\n\\n  INXMMaster public ms;\\n  address public nxMasterAddress;\\n\\n  modifier onlyInternal {\\n    require(ms.isInternal(msg.sender));\\n    _;\\n  }\\n\\n  modifier isMemberAndcheckPause {\\n    require(ms.isPause() == false && ms.isMember(msg.sender) == true);\\n    _;\\n  }\\n\\n  modifier onlyOwner {\\n    require(ms.isOwner(msg.sender));\\n    _;\\n  }\\n\\n  modifier checkPause {\\n    require(ms.isPause() == false);\\n    _;\\n  }\\n\\n  modifier isMember {\\n    require(ms.isMember(msg.sender), \\\"Not member\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Iupgradable Interface to update dependent contract address\\n   */\\n  function changeDependentContractAddress() public;\\n\\n  /**\\n   * @dev change master address\\n   * @param _masterAddress is the new address\\n   */\\n  function changeMasterAddress(address _masterAddress) public {\\n    if (address(ms) != address(0)) {\\n      require(address(ms) == msg.sender, \\\"Not master\\\");\\n    }\\n\\n    ms = INXMMaster(_masterAddress);\\n    nxMasterAddress = _masterAddress;\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPooledStaking.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n\\ninterface IPooledStaking {\\n\\n  function accumulateReward(address contractAddress, uint amount) external;\\n\\n  function pushBurn(address contractAddress, uint amount) external;\\n\\n  function hasPendingActions() external view returns (bool);\\n\\n  function contractStake(address contractAddress) external view returns (uint);\\n\\n  function stakerReward(address staker) external view returns (uint);\\n\\n  function stakerDeposit(address staker) external view returns (uint);\\n\\n  function stakerContractStake(address staker, address contractAddress) external view returns (uint);\\n\\n  function withdraw(uint amount) external;\\n\\n  function stakerMaxWithdrawable(address stakerAddress) external view returns (uint);\\n\\n  function withdrawReward(address stakerAddress) external;\\n}\\n\"\r\n    },\r\n    \"contracts/modules/governance/Governance.sol\": {\r\n      \"content\": \"// /* Copyright (C) 2017 GovBlocks.io\\r\\n\\r\\n//   This program is free software: you can redistribute it and/or modify\\r\\n//     it under the terms of the GNU General Public License as published by\\r\\n//     the Free Software Foundation, either version 3 of the License, or\\r\\n//     (at your option) any later version.\\r\\n\\r\\n//   This program is distributed in the hope that it will be useful,\\r\\n//     but WITHOUT ANY WARRANTY; without even the implied warranty of\\r\\n//     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\r\\n//     GNU General Public License for more details.\\r\\n\\r\\n//   You should have received a copy of the GNU General Public License\\r\\n//     along with this program.  If not, see http://www.gnu.org/licenses/ */\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\nimport \\\"../token/TokenController.sol\\\";\\r\\nimport \\\"./MemberRoles.sol\\\";\\r\\nimport \\\"./ProposalCategory.sol\\\";\\r\\nimport \\\"./external/IGovernance.sol\\\";\\r\\n\\r\\ncontract Governance is IGovernance, Iupgradable {\\r\\n\\r\\n  using SafeMath for uint;\\r\\n\\r\\n  enum ProposalStatus {\\r\\n    Draft,\\r\\n    AwaitingSolution,\\r\\n    VotingStarted,\\r\\n    Accepted,\\r\\n    Rejected,\\r\\n    Majority_Not_Reached_But_Accepted,\\r\\n    Denied\\r\\n  }\\r\\n\\r\\n  struct ProposalData {\\r\\n    uint propStatus;\\r\\n    uint finalVerdict;\\r\\n    uint category;\\r\\n    uint commonIncentive;\\r\\n    uint dateUpd;\\r\\n    address owner;\\r\\n  }\\r\\n\\r\\n  struct ProposalVote {\\r\\n    address voter;\\r\\n    uint proposalId;\\r\\n    uint dateAdd;\\r\\n  }\\r\\n\\r\\n  struct VoteTally {\\r\\n    mapping(uint => uint) memberVoteValue;\\r\\n    mapping(uint => uint) abVoteValue;\\r\\n    uint voters;\\r\\n  }\\r\\n\\r\\n  struct DelegateVote {\\r\\n    address follower;\\r\\n    address leader;\\r\\n    uint lastUpd;\\r\\n  }\\r\\n\\r\\n  ProposalVote[] internal allVotes;\\r\\n  DelegateVote[] public allDelegation;\\r\\n\\r\\n  mapping(uint => ProposalData) internal allProposalData;\\r\\n  mapping(uint => bytes[]) internal allProposalSolutions;\\r\\n  mapping(address => uint[]) internal allVotesByMember;\\r\\n  mapping(uint => mapping(address => bool)) public rewardClaimed;\\r\\n  mapping(address => mapping(uint => uint)) public memberProposalVote;\\r\\n  mapping(address => uint) public followerDelegation;\\r\\n  mapping(address => uint) internal followerCount;\\r\\n  mapping(address => uint[]) internal leaderDelegation;\\r\\n  mapping(uint => VoteTally) public proposalVoteTally;\\r\\n  mapping(address => bool) public isOpenForDelegation;\\r\\n  mapping(address => uint) public lastRewardClaimed;\\r\\n\\r\\n  bool internal constructorCheck;\\r\\n  uint public tokenHoldingTime;\\r\\n  uint internal roleIdAllowedToCatgorize;\\r\\n  uint internal maxVoteWeigthPer;\\r\\n  uint internal specialResolutionMajPerc;\\r\\n  uint internal maxFollowers;\\r\\n  uint internal totalProposals;\\r\\n  uint internal maxDraftTime;\\r\\n\\r\\n  MemberRoles internal memberRole;\\r\\n  ProposalCategory internal proposalCategory;\\r\\n  TokenController internal tokenInstance;\\r\\n\\r\\n  mapping(uint => uint) public proposalActionStatus;\\r\\n  mapping(uint => uint) internal proposalExecutionTime;\\r\\n  mapping(uint => mapping(address => bool)) public proposalRejectedByAB;\\r\\n  mapping(uint => uint) internal actionRejectedCount;\\r\\n\\r\\n  bool internal actionParamsInitialised;\\r\\n  uint internal actionWaitingTime;\\r\\n  uint constant internal AB_MAJ_TO_REJECT_ACTION = 3;\\r\\n\\r\\n  enum ActionStatus {\\r\\n    Pending,\\r\\n    Accepted,\\r\\n    Rejected,\\r\\n    Executed,\\r\\n    NoAction\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Called whenever an action execution is failed.\\r\\n  */\\r\\n  event ActionFailed (\\r\\n    uint256 proposalId\\r\\n  );\\r\\n\\r\\n  /**\\r\\n  * @dev Called whenever an AB member rejects the action execution.\\r\\n  */\\r\\n  event ActionRejected (\\r\\n    uint256 indexed proposalId,\\r\\n    address rejectedBy\\r\\n  );\\r\\n\\r\\n  /**\\r\\n  * @dev Checks if msg.sender is proposal owner\\r\\n  */\\r\\n  modifier onlyProposalOwner(uint _proposalId) {\\r\\n    require(msg.sender == allProposalData[_proposalId].owner, \\\"Not allowed\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Checks if proposal is opened for voting\\r\\n  */\\r\\n  modifier voteNotStarted(uint _proposalId) {\\r\\n    require(allProposalData[_proposalId].propStatus < uint(ProposalStatus.VotingStarted));\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Checks if msg.sender is allowed to create proposal under given category\\r\\n  */\\r\\n  modifier isAllowed(uint _categoryId) {\\r\\n    require(allowedToCreateProposal(_categoryId), \\\"Not allowed\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Checks if msg.sender is allowed categorize proposal under given category\\r\\n  */\\r\\n  modifier isAllowedToCategorize() {\\r\\n    require(memberRole.checkRole(msg.sender, roleIdAllowedToCatgorize), \\\"Not allowed\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Checks if msg.sender had any pending rewards to be claimed\\r\\n  */\\r\\n  modifier checkPendingRewards {\\r\\n    require(getPendingReward(msg.sender) == 0, \\\"Claim reward\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Event emitted whenever a proposal is categorized\\r\\n  */\\r\\n  event ProposalCategorized(\\r\\n    uint indexed proposalId,\\r\\n    address indexed categorizedBy,\\r\\n    uint categoryId\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @dev Removes delegation of an address.\\r\\n   * @param _add address to undelegate.\\r\\n   */\\r\\n  function removeDelegation(address _add) external onlyInternal {\\r\\n    _unDelegate(_add);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Creates a new proposal\\r\\n  * @param _proposalDescHash Proposal description hash through IPFS having Short and long description of proposal\\r\\n  * @param _categoryId This id tells under which the proposal is categorized i.e. Proposal's Objective\\r\\n  */\\r\\n  function createProposal(\\r\\n    string calldata _proposalTitle,\\r\\n    string calldata _proposalSD,\\r\\n    string calldata _proposalDescHash,\\r\\n    uint _categoryId\\r\\n  )\\r\\n  external isAllowed(_categoryId)\\r\\n  {\\r\\n    require(ms.isMember(msg.sender), \\\"Not Member\\\");\\r\\n\\r\\n    _createProposal(_proposalTitle, _proposalSD, _proposalDescHash, _categoryId);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Edits the details of an existing proposal\\r\\n  * @param _proposalId Proposal id that details needs to be updated\\r\\n  * @param _proposalDescHash Proposal description hash having long and short description of proposal.\\r\\n  */\\r\\n  function updateProposal(\\r\\n    uint _proposalId,\\r\\n    string calldata _proposalTitle,\\r\\n    string calldata _proposalSD,\\r\\n    string calldata _proposalDescHash\\r\\n  )\\r\\n  external onlyProposalOwner(_proposalId)\\r\\n  {\\r\\n    require(\\r\\n      allProposalSolutions[_proposalId].length < 2,\\r\\n      \\\"Not allowed\\\"\\r\\n    );\\r\\n    allProposalData[_proposalId].propStatus = uint(ProposalStatus.Draft);\\r\\n    allProposalData[_proposalId].category = 0;\\r\\n    allProposalData[_proposalId].commonIncentive = 0;\\r\\n    emit Proposal(\\r\\n      allProposalData[_proposalId].owner,\\r\\n      _proposalId,\\r\\n      now,\\r\\n      _proposalTitle,\\r\\n      _proposalSD,\\r\\n      _proposalDescHash\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Categorizes proposal to proceed further. Categories shows the proposal objective.\\r\\n  */\\r\\n  function categorizeProposal(\\r\\n    uint _proposalId,\\r\\n    uint _categoryId,\\r\\n    uint _incentive\\r\\n  )\\r\\n  external\\r\\n  voteNotStarted(_proposalId) isAllowedToCategorize\\r\\n  {\\r\\n    _categorizeProposal(_proposalId, _categoryId, _incentive);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Submit proposal with solution\\r\\n  * @param _proposalId Proposal id\\r\\n  * @param _solutionHash Solution hash contains  parameters, values and description needed according to proposal\\r\\n  */\\r\\n  function submitProposalWithSolution(\\r\\n    uint _proposalId,\\r\\n    string calldata _solutionHash,\\r\\n    bytes calldata _action\\r\\n  )\\r\\n  external\\r\\n  onlyProposalOwner(_proposalId)\\r\\n  {\\r\\n\\r\\n    require(allProposalData[_proposalId].propStatus == uint(ProposalStatus.AwaitingSolution));\\r\\n\\r\\n    _proposalSubmission(_proposalId, _solutionHash, _action);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Creates a new proposal with solution\\r\\n  * @param _proposalDescHash Proposal description hash through IPFS having Short and long description of proposal\\r\\n  * @param _categoryId This id tells under which the proposal is categorized i.e. Proposal's Objective\\r\\n  * @param _solutionHash Solution hash contains  parameters, values and description needed according to proposal\\r\\n  */\\r\\n  function createProposalwithSolution(\\r\\n    string calldata _proposalTitle,\\r\\n    string calldata _proposalSD,\\r\\n    string calldata _proposalDescHash,\\r\\n    uint _categoryId,\\r\\n    string calldata _solutionHash,\\r\\n    bytes calldata _action\\r\\n  )\\r\\n  external isAllowed(_categoryId)\\r\\n  {\\r\\n\\r\\n\\r\\n    uint proposalId = totalProposals;\\r\\n\\r\\n    _createProposal(_proposalTitle, _proposalSD, _proposalDescHash, _categoryId);\\r\\n\\r\\n    require(_categoryId > 0);\\r\\n\\r\\n    _proposalSubmission(\\r\\n      proposalId,\\r\\n      _solutionHash,\\r\\n      _action\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Submit a vote on the proposal.\\r\\n   * @param _proposalId to vote upon.\\r\\n   * @param _solutionChosen is the chosen vote.\\r\\n   */\\r\\n  function submitVote(uint _proposalId, uint _solutionChosen) external {\\r\\n\\r\\n    require(allProposalData[_proposalId].propStatus ==\\r\\n      uint(Governance.ProposalStatus.VotingStarted), \\\"Not allowed\\\");\\r\\n\\r\\n    require(_solutionChosen < allProposalSolutions[_proposalId].length);\\r\\n\\r\\n\\r\\n    _submitVote(_proposalId, _solutionChosen);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Closes the proposal.\\r\\n   * @param _proposalId of proposal to be closed.\\r\\n   */\\r\\n  function closeProposal(uint _proposalId) external {\\r\\n    uint category = allProposalData[_proposalId].category;\\r\\n\\r\\n\\r\\n    uint _memberRole;\\r\\n    if (allProposalData[_proposalId].dateUpd.add(maxDraftTime) <= now &&\\r\\n      allProposalData[_proposalId].propStatus < uint(ProposalStatus.VotingStarted)) {\\r\\n      _updateProposalStatus(_proposalId, uint(ProposalStatus.Denied));\\r\\n    } else {\\r\\n      require(canCloseProposal(_proposalId) == 1);\\r\\n      (, _memberRole,,,,,) = proposalCategory.category(allProposalData[_proposalId].category);\\r\\n      if (_memberRole == uint(MemberRoles.Role.AdvisoryBoard)) {\\r\\n        _closeAdvisoryBoardVote(_proposalId, category);\\r\\n      } else {\\r\\n        _closeMemberVote(_proposalId, category);\\r\\n      }\\r\\n    }\\r\\n\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Claims reward for member.\\r\\n   * @param _memberAddress to claim reward of.\\r\\n   * @param _maxRecords maximum number of records to claim reward for.\\r\\n   _proposals list of proposals of which reward will be claimed.\\r\\n   * @return amount of pending reward.\\r\\n   */\\r\\n  function claimReward(address _memberAddress, uint _maxRecords)\\r\\n  external returns (uint pendingDAppReward)\\r\\n  {\\r\\n\\r\\n    uint voteId;\\r\\n    address leader;\\r\\n    uint lastUpd;\\r\\n\\r\\n    require(msg.sender == ms.getLatestAddress(\\\"CR\\\"));\\r\\n\\r\\n    uint delegationId = followerDelegation[_memberAddress];\\r\\n    DelegateVote memory delegationData = allDelegation[delegationId];\\r\\n    if (delegationId > 0 && delegationData.leader != address(0)) {\\r\\n      leader = delegationData.leader;\\r\\n      lastUpd = delegationData.lastUpd;\\r\\n    } else\\r\\n      leader = _memberAddress;\\r\\n\\r\\n    uint proposalId;\\r\\n    uint totalVotes = allVotesByMember[leader].length;\\r\\n    uint lastClaimed = totalVotes;\\r\\n    uint j;\\r\\n    uint i;\\r\\n    for (i = lastRewardClaimed[_memberAddress]; i < totalVotes && j < _maxRecords; i++) {\\r\\n      voteId = allVotesByMember[leader][i];\\r\\n      proposalId = allVotes[voteId].proposalId;\\r\\n      if (proposalVoteTally[proposalId].voters > 0 && (allVotes[voteId].dateAdd > (\\r\\n      lastUpd.add(tokenHoldingTime)) || leader == _memberAddress)) {\\r\\n        if (allProposalData[proposalId].propStatus > uint(ProposalStatus.VotingStarted)) {\\r\\n          if (!rewardClaimed[voteId][_memberAddress]) {\\r\\n            pendingDAppReward = pendingDAppReward.add(\\r\\n              allProposalData[proposalId].commonIncentive.div(\\r\\n                proposalVoteTally[proposalId].voters\\r\\n              )\\r\\n            );\\r\\n            rewardClaimed[voteId][_memberAddress] = true;\\r\\n            j++;\\r\\n          }\\r\\n        } else {\\r\\n          if (lastClaimed == totalVotes) {\\r\\n            lastClaimed = i;\\r\\n          }\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (lastClaimed == totalVotes) {\\r\\n      lastRewardClaimed[_memberAddress] = i;\\r\\n    } else {\\r\\n      lastRewardClaimed[_memberAddress] = lastClaimed;\\r\\n    }\\r\\n\\r\\n    if (j > 0) {\\r\\n      emit RewardClaimed(\\r\\n        _memberAddress,\\r\\n        pendingDAppReward\\r\\n      );\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Sets delegation acceptance status of individual user\\r\\n   * @param _status delegation acceptance status\\r\\n   */\\r\\n  function setDelegationStatus(bool _status) external isMemberAndcheckPause checkPendingRewards {\\r\\n    isOpenForDelegation[msg.sender] = _status;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Delegates vote to an address.\\r\\n   * @param _add is the address to delegate vote to.\\r\\n   */\\r\\n  function delegateVote(address _add) external isMemberAndcheckPause checkPendingRewards {\\r\\n\\r\\n    require(ms.masterInitialized());\\r\\n\\r\\n    require(allDelegation[followerDelegation[_add]].leader == address(0));\\r\\n\\r\\n    if (followerDelegation[msg.sender] > 0) {\\r\\n      require((allDelegation[followerDelegation[msg.sender]].lastUpd).add(tokenHoldingTime) < now);\\r\\n    }\\r\\n\\r\\n    require(!alreadyDelegated(msg.sender));\\r\\n    require(!memberRole.checkRole(msg.sender, uint(MemberRoles.Role.Owner)));\\r\\n    require(!memberRole.checkRole(msg.sender, uint(MemberRoles.Role.AdvisoryBoard)));\\r\\n\\r\\n\\r\\n    require(followerCount[_add] < maxFollowers);\\r\\n\\r\\n    if (allVotesByMember[msg.sender].length > 0) {\\r\\n      require((allVotes[allVotesByMember[msg.sender][allVotesByMember[msg.sender].length - 1]].dateAdd).add(tokenHoldingTime)\\r\\n        < now);\\r\\n    }\\r\\n\\r\\n    require(ms.isMember(_add));\\r\\n\\r\\n    require(isOpenForDelegation[_add]);\\r\\n\\r\\n    allDelegation.push(DelegateVote(msg.sender, _add, now));\\r\\n    followerDelegation[msg.sender] = allDelegation.length - 1;\\r\\n    leaderDelegation[_add].push(allDelegation.length - 1);\\r\\n    followerCount[_add]++;\\r\\n    lastRewardClaimed[msg.sender] = allVotesByMember[_add].length;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Undelegates the sender\\r\\n   */\\r\\n  function unDelegate() external isMemberAndcheckPause checkPendingRewards {\\r\\n    _unDelegate(msg.sender);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Triggers action of accepted proposal after waiting time is finished\\r\\n   */\\r\\n  function triggerAction(uint _proposalId) external {\\r\\n    require(proposalActionStatus[_proposalId] == uint(ActionStatus.Accepted) && proposalExecutionTime[_proposalId] <= now, \\\"Cannot trigger\\\");\\r\\n    _triggerAction(_proposalId, allProposalData[_proposalId].category);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Provides option to Advisory board member to reject proposal action execution within actionWaitingTime, if found suspicious\\r\\n   */\\r\\n  function rejectAction(uint _proposalId) external {\\r\\n    require(memberRole.checkRole(msg.sender, uint(MemberRoles.Role.AdvisoryBoard)) && proposalExecutionTime[_proposalId] > now);\\r\\n\\r\\n    require(proposalActionStatus[_proposalId] == uint(ActionStatus.Accepted));\\r\\n\\r\\n    require(!proposalRejectedByAB[_proposalId][msg.sender]);\\r\\n\\r\\n    require(\\r\\n      keccak256(proposalCategory.categoryActionHashes(allProposalData[_proposalId].category))\\r\\n      != keccak256(abi.encodeWithSignature(\\\"swapABMember(address,address)\\\"))\\r\\n    );\\r\\n\\r\\n    proposalRejectedByAB[_proposalId][msg.sender] = true;\\r\\n    actionRejectedCount[_proposalId]++;\\r\\n    emit ActionRejected(_proposalId, msg.sender);\\r\\n    if (actionRejectedCount[_proposalId] == AB_MAJ_TO_REJECT_ACTION) {\\r\\n      proposalActionStatus[_proposalId] = uint(ActionStatus.Rejected);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Sets intial actionWaitingTime value\\r\\n   * To be called after governance implementation has been updated\\r\\n   */\\r\\n  function setInitialActionParameters() external onlyOwner {\\r\\n    require(!actionParamsInitialised);\\r\\n    actionParamsInitialised = true;\\r\\n    actionWaitingTime = 24 * 1 hours;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets Uint Parameters of a code\\r\\n   * @param code whose details we want\\r\\n   * @return string value of the code\\r\\n   * @return associated amount (time or perc or value) to the code\\r\\n   */\\r\\n  function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val) {\\r\\n\\r\\n    codeVal = code;\\r\\n\\r\\n    if (code == \\\"GOVHOLD\\\") {\\r\\n\\r\\n      val = tokenHoldingTime / (1 days);\\r\\n\\r\\n    } else if (code == \\\"MAXFOL\\\") {\\r\\n\\r\\n      val = maxFollowers;\\r\\n\\r\\n    } else if (code == \\\"MAXDRFT\\\") {\\r\\n\\r\\n      val = maxDraftTime / (1 days);\\r\\n\\r\\n    } else if (code == \\\"EPTIME\\\") {\\r\\n\\r\\n      val = ms.pauseTime() / (1 days);\\r\\n\\r\\n    } else if (code == \\\"ACWT\\\") {\\r\\n\\r\\n      val = actionWaitingTime / (1 hours);\\r\\n\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets all details of a propsal\\r\\n   * @param _proposalId whose details we want\\r\\n   * @return proposalId\\r\\n   * @return category\\r\\n   * @return status\\r\\n   * @return finalVerdict\\r\\n   * @return totalReward\\r\\n   */\\r\\n  function proposal(uint _proposalId)\\r\\n  external\\r\\n  view\\r\\n  returns (\\r\\n    uint proposalId,\\r\\n    uint category,\\r\\n    uint status,\\r\\n    uint finalVerdict,\\r\\n    uint totalRewar\\r\\n  )\\r\\n  {\\r\\n    return (\\r\\n    _proposalId,\\r\\n    allProposalData[_proposalId].category,\\r\\n    allProposalData[_proposalId].propStatus,\\r\\n    allProposalData[_proposalId].finalVerdict,\\r\\n    allProposalData[_proposalId].commonIncentive\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets some details of a propsal\\r\\n   * @param _proposalId whose details we want\\r\\n   * @return proposalId\\r\\n   * @return number of all proposal solutions\\r\\n   * @return amount of votes\\r\\n   */\\r\\n  function proposalDetails(uint _proposalId) external view returns (uint, uint, uint) {\\r\\n    return (\\r\\n    _proposalId,\\r\\n    allProposalSolutions[_proposalId].length,\\r\\n    proposalVoteTally[_proposalId].voters\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets solution action on a proposal\\r\\n   * @param _proposalId whose details we want\\r\\n   * @param _solution whose details we want\\r\\n   * @return action of a solution on a proposal\\r\\n   */\\r\\n  function getSolutionAction(uint _proposalId, uint _solution) external view returns (uint, bytes memory) {\\r\\n    return (\\r\\n    _solution,\\r\\n    allProposalSolutions[_proposalId][_solution]\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets length of propsal\\r\\n   * @return length of propsal\\r\\n   */\\r\\n  function getProposalLength() external view returns (uint) {\\r\\n    return totalProposals;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Get followers of an address\\r\\n   * @return get followers of an address\\r\\n   */\\r\\n  function getFollowers(address _add) external view returns (uint[] memory) {\\r\\n    return leaderDelegation[_add];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets pending rewards of a member\\r\\n   * @param _memberAddress in concern\\r\\n   * @return amount of pending reward\\r\\n   */\\r\\n  function getPendingReward(address _memberAddress)\\r\\n  public view returns (uint pendingDAppReward)\\r\\n  {\\r\\n    uint delegationId = followerDelegation[_memberAddress];\\r\\n    address leader;\\r\\n    uint lastUpd;\\r\\n    DelegateVote memory delegationData = allDelegation[delegationId];\\r\\n\\r\\n    if (delegationId > 0 && delegationData.leader != address(0)) {\\r\\n      leader = delegationData.leader;\\r\\n      lastUpd = delegationData.lastUpd;\\r\\n    } else\\r\\n      leader = _memberAddress;\\r\\n\\r\\n    uint proposalId;\\r\\n    for (uint i = lastRewardClaimed[_memberAddress]; i < allVotesByMember[leader].length; i++) {\\r\\n      if (allVotes[allVotesByMember[leader][i]].dateAdd > (\\r\\n      lastUpd.add(tokenHoldingTime)) || leader == _memberAddress) {\\r\\n        if (!rewardClaimed[allVotesByMember[leader][i]][_memberAddress]) {\\r\\n          proposalId = allVotes[allVotesByMember[leader][i]].proposalId;\\r\\n          if (proposalVoteTally[proposalId].voters > 0 && allProposalData[proposalId].propStatus\\r\\n          > uint(ProposalStatus.VotingStarted)) {\\r\\n            pendingDAppReward = pendingDAppReward.add(\\r\\n              allProposalData[proposalId].commonIncentive.div(\\r\\n                proposalVoteTally[proposalId].voters\\r\\n              )\\r\\n            );\\r\\n          }\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Updates Uint Parameters of a code\\r\\n   * @param code whose details we want to update\\r\\n   * @param val value to set\\r\\n   */\\r\\n  function updateUintParameters(bytes8 code, uint val) public {\\r\\n\\r\\n    require(ms.checkIsAuthToGoverned(msg.sender));\\r\\n    if (code == \\\"GOVHOLD\\\") {\\r\\n\\r\\n      tokenHoldingTime = val * 1 days;\\r\\n\\r\\n    } else if (code == \\\"MAXFOL\\\") {\\r\\n\\r\\n      maxFollowers = val;\\r\\n\\r\\n    } else if (code == \\\"MAXDRFT\\\") {\\r\\n\\r\\n      maxDraftTime = val * 1 days;\\r\\n\\r\\n    } else if (code == \\\"EPTIME\\\") {\\r\\n\\r\\n      ms.updatePauseTime(val * 1 days);\\r\\n\\r\\n    } else if (code == \\\"ACWT\\\") {\\r\\n\\r\\n      actionWaitingTime = val * 1 hours;\\r\\n\\r\\n    } else {\\r\\n\\r\\n      revert(\\\"Invalid code\\\");\\r\\n\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Updates all dependency addresses to latest ones from Master\\r\\n  */\\r\\n  function changeDependentContractAddress() public {\\r\\n    tokenInstance = TokenController(ms.dAppLocker());\\r\\n    memberRole = MemberRoles(ms.getLatestAddress(\\\"MR\\\"));\\r\\n    proposalCategory = ProposalCategory(ms.getLatestAddress(\\\"PC\\\"));\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Checks if msg.sender is allowed to create a proposal under given category\\r\\n  */\\r\\n  function allowedToCreateProposal(uint category) public view returns (bool check) {\\r\\n    if (category == 0)\\r\\n      return true;\\r\\n    uint[] memory mrAllowed;\\r\\n    (,,,, mrAllowed,,) = proposalCategory.category(category);\\r\\n    for (uint i = 0; i < mrAllowed.length; i++) {\\r\\n      if (mrAllowed[i] == 0 || memberRole.checkRole(msg.sender, mrAllowed[i]))\\r\\n        return true;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Checks if an address is already delegated\\r\\n   * @param _add in concern\\r\\n   * @return bool value if the address is delegated or not\\r\\n   */\\r\\n  function alreadyDelegated(address _add) public view returns (bool delegated) {\\r\\n    for (uint i = 0; i < leaderDelegation[_add].length; i++) {\\r\\n      if (allDelegation[leaderDelegation[_add][i]].leader == _add) {\\r\\n        return true;\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Checks If the proposal voting time is up and it's ready to close\\r\\n  *      i.e. Closevalue is 1 if proposal is ready to be closed, 2 if already closed, 0 otherwise!\\r\\n  * @param _proposalId Proposal id to which closing value is being checked\\r\\n  */\\r\\n  function canCloseProposal(uint _proposalId)\\r\\n  public\\r\\n  view\\r\\n  returns (uint)\\r\\n  {\\r\\n    uint dateUpdate;\\r\\n    uint pStatus;\\r\\n    uint _closingTime;\\r\\n    uint _roleId;\\r\\n    uint majority;\\r\\n    pStatus = allProposalData[_proposalId].propStatus;\\r\\n    dateUpdate = allProposalData[_proposalId].dateUpd;\\r\\n    (, _roleId, majority, , , _closingTime,) = proposalCategory.category(allProposalData[_proposalId].category);\\r\\n    if (\\r\\n      pStatus == uint(ProposalStatus.VotingStarted)\\r\\n    ) {\\r\\n      uint numberOfMembers = memberRole.numberOfMembers(_roleId);\\r\\n      if (_roleId == uint(MemberRoles.Role.AdvisoryBoard)) {\\r\\n        if (proposalVoteTally[_proposalId].abVoteValue[1].mul(100).div(numberOfMembers) >= majority\\r\\n        || proposalVoteTally[_proposalId].abVoteValue[1].add(proposalVoteTally[_proposalId].abVoteValue[0]) == numberOfMembers\\r\\n          || dateUpdate.add(_closingTime) <= now) {\\r\\n\\r\\n          return 1;\\r\\n        }\\r\\n      } else {\\r\\n        if (numberOfMembers == proposalVoteTally[_proposalId].voters\\r\\n          || dateUpdate.add(_closingTime) <= now)\\r\\n          return 1;\\r\\n      }\\r\\n    } else if (pStatus > uint(ProposalStatus.VotingStarted)) {\\r\\n      return 2;\\r\\n    } else {\\r\\n      return 0;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets Id of member role allowed to categorize the proposal\\r\\n   * @return roleId allowed to categorize the proposal\\r\\n   */\\r\\n  function allowedToCatgorize() public view returns (uint roleId) {\\r\\n    return roleIdAllowedToCatgorize;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets vote tally data\\r\\n   * @param _proposalId in concern\\r\\n   * @param _solution of a proposal id\\r\\n   * @return member vote value\\r\\n   * @return advisory board vote value\\r\\n   * @return amount of votes\\r\\n   */\\r\\n  function voteTallyData(uint _proposalId, uint _solution) public view returns (uint, uint, uint) {\\r\\n    return (proposalVoteTally[_proposalId].memberVoteValue[_solution],\\r\\n    proposalVoteTally[_proposalId].abVoteValue[_solution], proposalVoteTally[_proposalId].voters);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Internal call to create proposal\\r\\n   * @param _proposalTitle of proposal\\r\\n   * @param _proposalSD is short description of proposal\\r\\n   * @param _proposalDescHash IPFS hash value of propsal\\r\\n   * @param _categoryId of proposal\\r\\n   */\\r\\n  function _createProposal(\\r\\n    string memory _proposalTitle,\\r\\n    string memory _proposalSD,\\r\\n    string memory _proposalDescHash,\\r\\n    uint _categoryId\\r\\n  )\\r\\n  internal\\r\\n  {\\r\\n    require(proposalCategory.categoryABReq(_categoryId) == 0 || _categoryId == 0);\\r\\n    uint _proposalId = totalProposals;\\r\\n    allProposalData[_proposalId].owner = msg.sender;\\r\\n    allProposalData[_proposalId].dateUpd = now;\\r\\n    allProposalSolutions[_proposalId].push(\\\"\\\");\\r\\n    totalProposals++;\\r\\n\\r\\n    emit Proposal(\\r\\n      msg.sender,\\r\\n      _proposalId,\\r\\n      now,\\r\\n      _proposalTitle,\\r\\n      _proposalSD,\\r\\n      _proposalDescHash\\r\\n    );\\r\\n\\r\\n    if (_categoryId > 0)\\r\\n      _categorizeProposal(_proposalId, _categoryId, 0);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Internal call to categorize a proposal\\r\\n   * @param _proposalId of proposal\\r\\n   * @param _categoryId of proposal\\r\\n   * @param _incentive is commonIncentive\\r\\n   */\\r\\n  function _categorizeProposal(\\r\\n    uint _proposalId,\\r\\n    uint _categoryId,\\r\\n    uint _incentive\\r\\n  )\\r\\n  internal\\r\\n  {\\r\\n    require(\\r\\n      _categoryId > 0 && _categoryId < proposalCategory.totalCategories(),\\r\\n      \\\"Invalid category\\\"\\r\\n    );\\r\\n    allProposalData[_proposalId].category = _categoryId;\\r\\n    allProposalData[_proposalId].commonIncentive = _incentive;\\r\\n    allProposalData[_proposalId].propStatus = uint(ProposalStatus.AwaitingSolution);\\r\\n\\r\\n    emit ProposalCategorized(_proposalId, msg.sender, _categoryId);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Internal call to add solution to a proposal\\r\\n   * @param _proposalId in concern\\r\\n   * @param _action on that solution\\r\\n   * @param _solutionHash string value\\r\\n   */\\r\\n  function _addSolution(uint _proposalId, bytes memory _action, string memory _solutionHash)\\r\\n  internal\\r\\n  {\\r\\n    allProposalSolutions[_proposalId].push(_action);\\r\\n    emit Solution(_proposalId, msg.sender, allProposalSolutions[_proposalId].length - 1, _solutionHash, now);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Internal call to add solution and open proposal for voting\\r\\n  */\\r\\n  function _proposalSubmission(\\r\\n    uint _proposalId,\\r\\n    string memory _solutionHash,\\r\\n    bytes memory _action\\r\\n  )\\r\\n  internal\\r\\n  {\\r\\n\\r\\n    uint _categoryId = allProposalData[_proposalId].category;\\r\\n    if (proposalCategory.categoryActionHashes(_categoryId).length == 0) {\\r\\n      require(keccak256(_action) == keccak256(\\\"\\\"));\\r\\n      proposalActionStatus[_proposalId] = uint(ActionStatus.NoAction);\\r\\n    }\\r\\n\\r\\n    _addSolution(\\r\\n      _proposalId,\\r\\n      _action,\\r\\n      _solutionHash\\r\\n    );\\r\\n\\r\\n    _updateProposalStatus(_proposalId, uint(ProposalStatus.VotingStarted));\\r\\n    (, , , , , uint closingTime,) = proposalCategory.category(_categoryId);\\r\\n    emit CloseProposalOnTime(_proposalId, closingTime.add(now));\\r\\n\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Internal call to submit vote\\r\\n   * @param _proposalId of proposal in concern\\r\\n   * @param _solution for that proposal\\r\\n   */\\r\\n  function _submitVote(uint _proposalId, uint _solution) internal {\\r\\n\\r\\n    uint delegationId = followerDelegation[msg.sender];\\r\\n    uint mrSequence;\\r\\n    uint majority;\\r\\n    uint closingTime;\\r\\n    (, mrSequence, majority, , , closingTime,) = proposalCategory.category(allProposalData[_proposalId].category);\\r\\n\\r\\n    require(allProposalData[_proposalId].dateUpd.add(closingTime) > now, \\\"Closed\\\");\\r\\n\\r\\n    require(memberProposalVote[msg.sender][_proposalId] == 0, \\\"Not allowed\\\");\\r\\n    require((delegationId == 0) || (delegationId > 0 && allDelegation[delegationId].leader == address(0) &&\\r\\n    _checkLastUpd(allDelegation[delegationId].lastUpd)));\\r\\n\\r\\n    require(memberRole.checkRole(msg.sender, mrSequence), \\\"Not Authorized\\\");\\r\\n    uint totalVotes = allVotes.length;\\r\\n\\r\\n    allVotesByMember[msg.sender].push(totalVotes);\\r\\n    memberProposalVote[msg.sender][_proposalId] = totalVotes;\\r\\n\\r\\n    allVotes.push(ProposalVote(msg.sender, _proposalId, now));\\r\\n\\r\\n    emit Vote(msg.sender, _proposalId, totalVotes, now, _solution);\\r\\n    if (mrSequence == uint(MemberRoles.Role.Owner)) {\\r\\n      if (_solution == 1)\\r\\n        _callIfMajReached(_proposalId, uint(ProposalStatus.Accepted), allProposalData[_proposalId].category, 1, MemberRoles.Role.Owner);\\r\\n      else\\r\\n        _updateProposalStatus(_proposalId, uint(ProposalStatus.Rejected));\\r\\n\\r\\n    } else {\\r\\n      uint numberOfMembers = memberRole.numberOfMembers(mrSequence);\\r\\n      _setVoteTally(_proposalId, _solution, mrSequence);\\r\\n\\r\\n      if (mrSequence == uint(MemberRoles.Role.AdvisoryBoard)) {\\r\\n        if (proposalVoteTally[_proposalId].abVoteValue[1].mul(100).div(numberOfMembers)\\r\\n        >= majority\\r\\n          || (proposalVoteTally[_proposalId].abVoteValue[1].add(proposalVoteTally[_proposalId].abVoteValue[0])) == numberOfMembers) {\\r\\n          emit VoteCast(_proposalId);\\r\\n        }\\r\\n      } else {\\r\\n        if (numberOfMembers == proposalVoteTally[_proposalId].voters)\\r\\n          emit VoteCast(_proposalId);\\r\\n      }\\r\\n    }\\r\\n\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Internal call to set vote tally of a proposal\\r\\n   * @param _proposalId of proposal in concern\\r\\n   * @param _solution of proposal in concern\\r\\n   * @param mrSequence number of members for a role\\r\\n   */\\r\\n  function _setVoteTally(uint _proposalId, uint _solution, uint mrSequence) internal\\r\\n  {\\r\\n    uint categoryABReq;\\r\\n    uint isSpecialResolution;\\r\\n    (, categoryABReq, isSpecialResolution) = proposalCategory.categoryExtendedData(allProposalData[_proposalId].category);\\r\\n    if (memberRole.checkRole(msg.sender, uint(MemberRoles.Role.AdvisoryBoard)) && (categoryABReq > 0) ||\\r\\n      mrSequence == uint(MemberRoles.Role.AdvisoryBoard)) {\\r\\n      proposalVoteTally[_proposalId].abVoteValue[_solution]++;\\r\\n    }\\r\\n    tokenInstance.lockForMemberVote(msg.sender, tokenHoldingTime);\\r\\n    if (mrSequence != uint(MemberRoles.Role.AdvisoryBoard)) {\\r\\n      uint voteWeight;\\r\\n      uint voters = 1;\\r\\n      uint tokenBalance = tokenInstance.totalBalanceOf(msg.sender);\\r\\n      uint totalSupply = tokenInstance.totalSupply();\\r\\n      if (isSpecialResolution == 1) {\\r\\n        voteWeight = tokenBalance.add(10 ** 18);\\r\\n      } else {\\r\\n        voteWeight = (_minOf(tokenBalance, maxVoteWeigthPer.mul(totalSupply).div(100))).add(10 ** 18);\\r\\n      }\\r\\n      DelegateVote memory delegationData;\\r\\n      for (uint i = 0; i < leaderDelegation[msg.sender].length; i++) {\\r\\n        delegationData = allDelegation[leaderDelegation[msg.sender][i]];\\r\\n        if (delegationData.leader == msg.sender &&\\r\\n          _checkLastUpd(delegationData.lastUpd)) {\\r\\n          if (memberRole.checkRole(delegationData.follower, mrSequence)) {\\r\\n            tokenBalance = tokenInstance.totalBalanceOf(delegationData.follower);\\r\\n            tokenInstance.lockForMemberVote(delegationData.follower, tokenHoldingTime);\\r\\n            voters++;\\r\\n            if (isSpecialResolution == 1) {\\r\\n              voteWeight = voteWeight.add(tokenBalance.add(10 ** 18));\\r\\n            } else {\\r\\n              voteWeight = voteWeight.add((_minOf(tokenBalance, maxVoteWeigthPer.mul(totalSupply).div(100))).add(10 ** 18));\\r\\n            }\\r\\n          }\\r\\n        }\\r\\n      }\\r\\n      proposalVoteTally[_proposalId].memberVoteValue[_solution] = proposalVoteTally[_proposalId].memberVoteValue[_solution].add(voteWeight);\\r\\n      proposalVoteTally[_proposalId].voters = proposalVoteTally[_proposalId].voters + voters;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets minimum of two numbers\\r\\n   * @param a one of the two numbers\\r\\n   * @param b one of the two numbers\\r\\n   * @return minimum number out of the two\\r\\n   */\\r\\n  function _minOf(uint a, uint b) internal pure returns (uint res) {\\r\\n    res = a;\\r\\n    if (res > b)\\r\\n      res = b;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Check the time since last update has exceeded token holding time or not\\r\\n   * @param _lastUpd is last update time\\r\\n   * @return the bool which tells if the time since last update has exceeded token holding time or not\\r\\n   */\\r\\n  function _checkLastUpd(uint _lastUpd) internal view returns (bool) {\\r\\n    return (now - _lastUpd) > tokenHoldingTime;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Checks if the vote count against any solution passes the threshold value or not.\\r\\n  */\\r\\n  function _checkForThreshold(uint _proposalId, uint _category) internal view returns (bool check) {\\r\\n    uint categoryQuorumPerc;\\r\\n    uint roleAuthorized;\\r\\n    (, roleAuthorized, , categoryQuorumPerc, , ,) = proposalCategory.category(_category);\\r\\n    check = ((proposalVoteTally[_proposalId].memberVoteValue[0]\\r\\n    .add(proposalVoteTally[_proposalId].memberVoteValue[1]))\\r\\n    .mul(100))\\r\\n    .div(\\r\\n      tokenInstance.totalSupply().add(\\r\\n        memberRole.numberOfMembers(roleAuthorized).mul(10 ** 18)\\r\\n      )\\r\\n    ) >= categoryQuorumPerc;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Called when vote majority is reached\\r\\n   * @param _proposalId of proposal in concern\\r\\n   * @param _status of proposal in concern\\r\\n   * @param category of proposal in concern\\r\\n   * @param max vote value of proposal in concern\\r\\n   */\\r\\n  function _callIfMajReached(uint _proposalId, uint _status, uint category, uint max, MemberRoles.Role role) internal {\\r\\n\\r\\n    allProposalData[_proposalId].finalVerdict = max;\\r\\n    _updateProposalStatus(_proposalId, _status);\\r\\n    emit ProposalAccepted(_proposalId);\\r\\n    if (proposalActionStatus[_proposalId] != uint(ActionStatus.NoAction)) {\\r\\n      if (role == MemberRoles.Role.AdvisoryBoard) {\\r\\n        _triggerAction(_proposalId, category);\\r\\n      } else {\\r\\n        proposalActionStatus[_proposalId] = uint(ActionStatus.Accepted);\\r\\n        proposalExecutionTime[_proposalId] = actionWaitingTime.add(now);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Internal function to trigger action of accepted proposal\\r\\n   */\\r\\n  function _triggerAction(uint _proposalId, uint _categoryId) internal {\\r\\n    proposalActionStatus[_proposalId] = uint(ActionStatus.Executed);\\r\\n    bytes2 contractName;\\r\\n    address actionAddress;\\r\\n    bytes memory _functionHash;\\r\\n    (, actionAddress, contractName, , _functionHash) = proposalCategory.categoryActionDetails(_categoryId);\\r\\n    if (contractName == \\\"MS\\\") {\\r\\n      actionAddress = address(ms);\\r\\n    } else if (contractName != \\\"EX\\\") {\\r\\n      actionAddress = ms.getLatestAddress(contractName);\\r\\n    }\\r\\n    // solhint-disable-next-line avoid-low-level-calls\\r\\n    (bool actionStatus,) = actionAddress.call(abi.encodePacked(_functionHash, allProposalSolutions[_proposalId][1]));\\r\\n    if (actionStatus) {\\r\\n      emit ActionSuccess(_proposalId);\\r\\n    } else {\\r\\n      proposalActionStatus[_proposalId] = uint(ActionStatus.Accepted);\\r\\n      emit ActionFailed(_proposalId);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Internal call to update proposal status\\r\\n   * @param _proposalId of proposal in concern\\r\\n   * @param _status of proposal to set\\r\\n   */\\r\\n  function _updateProposalStatus(uint _proposalId, uint _status) internal {\\r\\n    if (_status == uint(ProposalStatus.Rejected) || _status == uint(ProposalStatus.Denied)) {\\r\\n      proposalActionStatus[_proposalId] = uint(ActionStatus.NoAction);\\r\\n    }\\r\\n    allProposalData[_proposalId].dateUpd = now;\\r\\n    allProposalData[_proposalId].propStatus = _status;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Internal call to undelegate a follower\\r\\n   * @param _follower is address of follower to undelegate\\r\\n   */\\r\\n  function _unDelegate(address _follower) internal {\\r\\n    uint followerId = followerDelegation[_follower];\\r\\n    if (followerId > 0) {\\r\\n\\r\\n      followerCount[allDelegation[followerId].leader] = followerCount[allDelegation[followerId].leader].sub(1);\\r\\n      allDelegation[followerId].leader = address(0);\\r\\n      allDelegation[followerId].lastUpd = now;\\r\\n\\r\\n      lastRewardClaimed[_follower] = allVotesByMember[_follower].length;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Internal call to close member voting\\r\\n   * @param _proposalId of proposal in concern\\r\\n   * @param category of proposal in concern\\r\\n   */\\r\\n  function _closeMemberVote(uint _proposalId, uint category) internal {\\r\\n    uint isSpecialResolution;\\r\\n    uint abMaj;\\r\\n    (, abMaj, isSpecialResolution) = proposalCategory.categoryExtendedData(category);\\r\\n    if (isSpecialResolution == 1) {\\r\\n      uint acceptedVotePerc = proposalVoteTally[_proposalId].memberVoteValue[1].mul(100)\\r\\n      .div(\\r\\n        tokenInstance.totalSupply().add(\\r\\n          memberRole.numberOfMembers(uint(MemberRoles.Role.Member)).mul(10 ** 18)\\r\\n        ));\\r\\n      if (acceptedVotePerc >= specialResolutionMajPerc) {\\r\\n        _callIfMajReached(_proposalId, uint(ProposalStatus.Accepted), category, 1, MemberRoles.Role.Member);\\r\\n      } else {\\r\\n        _updateProposalStatus(_proposalId, uint(ProposalStatus.Denied));\\r\\n      }\\r\\n    } else {\\r\\n      if (_checkForThreshold(_proposalId, category)) {\\r\\n        uint majorityVote;\\r\\n        (,, majorityVote,,,,) = proposalCategory.category(category);\\r\\n        if (\\r\\n          ((proposalVoteTally[_proposalId].memberVoteValue[1].mul(100))\\r\\n          .div(proposalVoteTally[_proposalId].memberVoteValue[0]\\r\\n          .add(proposalVoteTally[_proposalId].memberVoteValue[1])\\r\\n          ))\\r\\n          >= majorityVote\\r\\n        ) {\\r\\n          _callIfMajReached(_proposalId, uint(ProposalStatus.Accepted), category, 1, MemberRoles.Role.Member);\\r\\n        } else {\\r\\n          _updateProposalStatus(_proposalId, uint(ProposalStatus.Rejected));\\r\\n        }\\r\\n      } else {\\r\\n        if (abMaj > 0 && proposalVoteTally[_proposalId].abVoteValue[1].mul(100)\\r\\n        .div(memberRole.numberOfMembers(uint(MemberRoles.Role.AdvisoryBoard))) >= abMaj) {\\r\\n          _callIfMajReached(_proposalId, uint(ProposalStatus.Accepted), category, 1, MemberRoles.Role.Member);\\r\\n        } else {\\r\\n          _updateProposalStatus(_proposalId, uint(ProposalStatus.Denied));\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (proposalVoteTally[_proposalId].voters > 0) {\\r\\n      tokenInstance.mint(ms.getLatestAddress(\\\"CR\\\"), allProposalData[_proposalId].commonIncentive);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Internal call to close advisory board voting\\r\\n   * @param _proposalId of proposal in concern\\r\\n   * @param category of proposal in concern\\r\\n   */\\r\\n  function _closeAdvisoryBoardVote(uint _proposalId, uint category) internal {\\r\\n    uint _majorityVote;\\r\\n    MemberRoles.Role _roleId = MemberRoles.Role.AdvisoryBoard;\\r\\n    (,, _majorityVote,,,,) = proposalCategory.category(category);\\r\\n    if (proposalVoteTally[_proposalId].abVoteValue[1].mul(100)\\r\\n    .div(memberRole.numberOfMembers(uint(_roleId))) >= _majorityVote) {\\r\\n      _callIfMajReached(_proposalId, uint(ProposalStatus.Accepted), category, 1, _roleId);\\r\\n    } else {\\r\\n      _updateProposalStatus(_proposalId, uint(ProposalStatus.Denied));\\r\\n    }\\r\\n\\r\\n  }\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/modules/claims/Claims.sol\": {\r\n      \"content\": \"/* Copyright (C) 2020 NexusMutual.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"../capital/Pool.sol\\\";\\nimport \\\"../claims/ClaimsReward.sol\\\";\\nimport \\\"../token/NXMToken.sol\\\";\\nimport \\\"../token/TokenController.sol\\\";\\nimport \\\"../token/TokenFunctions.sol\\\";\\nimport \\\"./ClaimsData.sol\\\";\\n\\ncontract Claims is Iupgradable {\\n  using SafeMath for uint;\\n\\n  TokenFunctions internal tf;\\n  NXMToken internal tk;\\n  TokenController internal tc;\\n  ClaimsReward internal cr;\\n  Pool internal p1;\\n  ClaimsData internal cd;\\n  TokenData internal td;\\n  QuotationData internal qd;\\n\\n  uint private constant DECIMAL1E18 = uint(10) ** 18;\\n\\n  /**\\n   * @dev Sets the status of claim using claim id.\\n   * @param claimId claim id.\\n   * @param stat status to be set.\\n   */\\n  function setClaimStatus(uint claimId, uint stat) external onlyInternal {\\n    _setClaimStatus(claimId, stat);\\n  }\\n\\n  /**\\n   * @dev Gets claim details of claim id = pending claim start + given index\\n   */\\n  function getClaimFromNewStart(\\n    uint index\\n  )\\n  external\\n  view\\n  returns (\\n    uint coverId,\\n    uint claimId,\\n    int8 voteCA,\\n    int8 voteMV,\\n    uint statusnumber\\n  )\\n  {\\n    (coverId, claimId, voteCA, voteMV, statusnumber) = cd.getClaimFromNewStart(index, msg.sender);\\n  }\\n\\n  /**\\n   * @dev Gets details of a claim submitted by the calling user, at a given index\\n   */\\n  function getUserClaimByIndex(\\n    uint index\\n  )\\n  external\\n  view\\n  returns (\\n    uint status,\\n    uint coverId,\\n    uint claimId\\n  )\\n  {\\n    uint statusno;\\n    (statusno, coverId, claimId) = cd.getUserClaimByIndex(index, msg.sender);\\n    status = statusno;\\n  }\\n\\n  /**\\n   * @dev Gets details of a given claim id.\\n   * @param _claimId Claim Id.\\n   * @return status Current status of claim id\\n   * @return finalVerdict Decision made on the claim, 1 -> acceptance, -1 -> denial\\n   * @return claimOwner Address through which claim is submitted\\n   * @return coverId Coverid associated with the claim id\\n   */\\n  function getClaimbyIndex(uint _claimId) external view returns (\\n    uint claimId,\\n    uint status,\\n    int8 finalVerdict,\\n    address claimOwner,\\n    uint coverId\\n  )\\n  {\\n    uint stat;\\n    claimId = _claimId;\\n    (, coverId, finalVerdict, stat,,) = cd.getClaim(_claimId);\\n    claimOwner = qd.getCoverMemberAddress(coverId);\\n    status = stat;\\n  }\\n\\n  /**\\n   * @dev Calculates total amount that has been used to assess a claim.\\n   * Computaion:Adds acceptCA(tokens used for voting in favor of a claim)\\n   * denyCA(tokens used for voting against a claim) *  current token price.\\n   * @param claimId Claim Id.\\n   * @param member Member type 0 -> Claim Assessors, else members.\\n   * @return tokens Total Amount used in Claims assessment.\\n   */\\n  function getCATokens(uint claimId, uint member) external view returns (uint tokens) {\\n    uint coverId;\\n    (, coverId) = cd.getClaimCoverId(claimId);\\n\\n    bytes4 currency = qd.getCurrencyOfCover(coverId);\\n    address asset = cr.getCurrencyAssetAddress(currency);\\n    uint tokenx1e18 = p1.getTokenPrice(asset);\\n\\n    uint accept;\\n    uint deny;\\n    if (member == 0) {\\n      (, accept, deny) = cd.getClaimsTokenCA(claimId);\\n    } else {\\n      (, accept, deny) = cd.getClaimsTokenMV(claimId);\\n    }\\n    tokens = ((accept.add(deny)).mul(tokenx1e18)).div(DECIMAL1E18); // amount (not in tokens)\\n  }\\n\\n  /**\\n   * Iupgradable Interface to update dependent contract address\\n   */\\n  function changeDependentContractAddress() public onlyInternal {\\n    tk = NXMToken(ms.tokenAddress());\\n    td = TokenData(ms.getLatestAddress(\\\"TD\\\"));\\n    tf = TokenFunctions(ms.getLatestAddress(\\\"TF\\\"));\\n    tc = TokenController(ms.getLatestAddress(\\\"TC\\\"));\\n    p1 = Pool(ms.getLatestAddress(\\\"P1\\\"));\\n    cr = ClaimsReward(ms.getLatestAddress(\\\"CR\\\"));\\n    cd = ClaimsData(ms.getLatestAddress(\\\"CD\\\"));\\n    qd = QuotationData(ms.getLatestAddress(\\\"QD\\\"));\\n  }\\n\\n  /**\\n   * @dev Submits a claim for a given cover note.\\n   * Adds claim to queue incase of emergency pause else directly submits the claim.\\n   * @param coverId Cover Id.\\n   */\\n  function submitClaim(uint coverId) external {\\n    _submitClaim(coverId, msg.sender);\\n  }\\n\\n  function submitClaimForMember(uint coverId, address member) external onlyInternal {\\n    _submitClaim(coverId, member);\\n  }\\n\\n  function _submitClaim(uint coverId, address member) internal {\\n\\n    require(!ms.isPause(), \\\"Claims: System is paused\\\");\\n\\n    address coverOwner = qd.getCoverMemberAddress(coverId);\\n    require(coverOwner == member, \\\"Claims: Not cover owner\\\");\\n\\n    uint expirationDate = qd.getValidityOfCover(coverId);\\n    uint gracePeriod = tc.claimSubmissionGracePeriod();\\n    require(expirationDate.add(gracePeriod) > now, \\\"Claims: Grace period has expired\\\");\\n\\n    tc.markCoverClaimOpen(coverId);\\n    qd.changeCoverStatusNo(coverId, uint8(QuotationData.CoverStatus.ClaimSubmitted));\\n\\n    uint claimId = cd.actualClaimLength();\\n    cd.addClaim(claimId, coverId, coverOwner, now);\\n    cd.callClaimEvent(coverId, coverOwner, claimId, now);\\n  }\\n\\n  // solhint-disable-next-line no-empty-blocks\\n  function submitClaimAfterEPOff() external pure {}\\n\\n  /**\\n   * @dev Castes vote for members who have tokens locked under Claims Assessment\\n   * @param claimId  claim id.\\n   * @param verdict 1 for Accept,-1 for Deny.\\n   */\\n  function submitCAVote(uint claimId, int8 verdict) public isMemberAndcheckPause {\\n    require(checkVoteClosing(claimId) != 1);\\n    require(cd.userClaimVotePausedOn(msg.sender).add(cd.pauseDaysCA()) < now);\\n    uint tokens = tc.tokensLockedAtTime(msg.sender, \\\"CLA\\\", now.add(cd.claimDepositTime()));\\n    require(tokens > 0);\\n    uint stat;\\n    (, stat) = cd.getClaimStatusNumber(claimId);\\n    require(stat == 0);\\n    require(cd.getUserClaimVoteCA(msg.sender, claimId) == 0);\\n    td.bookCATokens(msg.sender);\\n    cd.addVote(msg.sender, tokens, claimId, verdict);\\n    cd.callVoteEvent(msg.sender, claimId, \\\"CAV\\\", tokens, now, verdict);\\n    uint voteLength = cd.getAllVoteLength();\\n    cd.addClaimVoteCA(claimId, voteLength);\\n    cd.setUserClaimVoteCA(msg.sender, claimId, voteLength);\\n    cd.setClaimTokensCA(claimId, verdict, tokens);\\n    tc.extendLockOf(msg.sender, \\\"CLA\\\", td.lockCADays());\\n    int close = checkVoteClosing(claimId);\\n    if (close == 1) {\\n      cr.changeClaimStatus(claimId);\\n    }\\n  }\\n\\n  /**\\n   * @dev Submits a member vote for assessing a claim.\\n   * Tokens other than those locked under Claims\\n   * Assessment can be used to cast a vote for a given claim id.\\n   * @param claimId Selected claim id.\\n   * @param verdict 1 for Accept,-1 for Deny.\\n   */\\n  function submitMemberVote(uint claimId, int8 verdict) public isMemberAndcheckPause {\\n    require(checkVoteClosing(claimId) != 1);\\n    uint stat;\\n    uint tokens = tc.totalBalanceOf(msg.sender);\\n    (, stat) = cd.getClaimStatusNumber(claimId);\\n    require(stat >= 1 && stat <= 5);\\n    require(cd.getUserClaimVoteMember(msg.sender, claimId) == 0);\\n    cd.addVote(msg.sender, tokens, claimId, verdict);\\n    cd.callVoteEvent(msg.sender, claimId, \\\"MV\\\", tokens, now, verdict);\\n    tc.lockForMemberVote(msg.sender, td.lockMVDays());\\n    uint voteLength = cd.getAllVoteLength();\\n    cd.addClaimVotemember(claimId, voteLength);\\n    cd.setUserClaimVoteMember(msg.sender, claimId, voteLength);\\n    cd.setClaimTokensMV(claimId, verdict, tokens);\\n    int close = checkVoteClosing(claimId);\\n    if (close == 1) {\\n      cr.changeClaimStatus(claimId);\\n    }\\n  }\\n\\n  // solhint-disable-next-line no-empty-blocks\\n  function pauseAllPendingClaimsVoting() external pure {}\\n\\n  // solhint-disable-next-line no-empty-blocks\\n  function startAllPendingClaimsVoting() external pure {}\\n\\n  /**\\n   * @dev Checks if voting of a claim should be closed or not.\\n   * @param claimId Claim Id.\\n   * @return close 1 -> voting should be closed, 0 -> if voting should not be closed,\\n   * -1 -> voting has already been closed.\\n   */\\n  function checkVoteClosing(uint claimId) public view returns (int8 close) {\\n    close = 0;\\n    uint status;\\n    (, status) = cd.getClaimStatusNumber(claimId);\\n    uint dateUpd = cd.getClaimDateUpd(claimId);\\n    if (status == 12 && dateUpd.add(cd.payoutRetryTime()) < now) {\\n      if (cd.getClaimState12Count(claimId) < 60)\\n        close = 1;\\n    }\\n\\n    if (status > 5 && status != 12) {\\n      close = - 1;\\n    } else if (status != 12 && dateUpd.add(cd.maxVotingTime()) <= now) {\\n      close = 1;\\n    } else if (status != 12 && dateUpd.add(cd.minVotingTime()) >= now) {\\n      close = 0;\\n    } else if (status == 0 || (status >= 1 && status <= 5)) {\\n      close = _checkVoteClosingFinal(claimId, status);\\n    }\\n\\n  }\\n\\n  /**\\n   * @dev Checks if voting of a claim should be closed or not.\\n   * Internally called by checkVoteClosing method\\n   * for Claims whose status number is 0 or status number lie between 2 and 6.\\n   * @param claimId Claim Id.\\n   * @param status Current status of claim.\\n   * @return close 1 if voting should be closed,0 in case voting should not be closed,\\n   * -1 if voting has already been closed.\\n   */\\n  function _checkVoteClosingFinal(uint claimId, uint status) internal view returns (int8 close) {\\n    close = 0;\\n    uint coverId;\\n    (, coverId) = cd.getClaimCoverId(claimId);\\n\\n    bytes4 currency = qd.getCurrencyOfCover(coverId);\\n    address asset = cr.getCurrencyAssetAddress(currency);\\n    uint tokenx1e18 = p1.getTokenPrice(asset);\\n\\n    uint accept;\\n    uint deny;\\n    (, accept, deny) = cd.getClaimsTokenCA(claimId);\\n    uint caTokens = ((accept.add(deny)).mul(tokenx1e18)).div(DECIMAL1E18);\\n    (, accept, deny) = cd.getClaimsTokenMV(claimId);\\n    uint mvTokens = ((accept.add(deny)).mul(tokenx1e18)).div(DECIMAL1E18);\\n    uint sumassured = qd.getCoverSumAssured(coverId).mul(DECIMAL1E18);\\n    if (status == 0 && caTokens >= sumassured.mul(10)) {\\n      close = 1;\\n    } else if (status >= 1 && status <= 5 && mvTokens >= sumassured.mul(10)) {\\n      close = 1;\\n    }\\n  }\\n\\n  /**\\n   * @dev Changes the status of an existing claim id, based on current\\n   * status and current conditions of the system\\n   * @param claimId Claim Id.\\n   * @param stat status number.\\n   */\\n  function _setClaimStatus(uint claimId, uint stat) internal {\\n\\n    uint origstat;\\n    uint state12Count;\\n    uint dateUpd;\\n    uint coverId;\\n    (, coverId, , origstat, dateUpd, state12Count) = cd.getClaim(claimId);\\n    (, origstat) = cd.getClaimStatusNumber(claimId);\\n\\n    if (stat == 12 && origstat == 12) {\\n      cd.updateState12Count(claimId, 1);\\n    }\\n    cd.setClaimStatus(claimId, stat);\\n\\n    if (state12Count >= 60 && stat == 12) {\\n      cd.setClaimStatus(claimId, 13);\\n      qd.changeCoverStatusNo(coverId, uint8(QuotationData.CoverStatus.ClaimDenied));\\n    }\\n\\n    cd.setClaimdateUpd(claimId, now);\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/modules/claims/ClaimsData.sol\": {\r\n      \"content\": \"/* Copyright (C) 2020 NexusMutual.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../../abstract/Iupgradable.sol\\\";\\n\\ncontract ClaimsData is Iupgradable {\\n  using SafeMath for uint;\\n\\n  struct Claim {\\n    uint coverId;\\n    uint dateUpd;\\n  }\\n\\n  struct Vote {\\n    address voter;\\n    uint tokens;\\n    uint claimId;\\n    int8 verdict;\\n    bool rewardClaimed;\\n  }\\n\\n  struct ClaimsPause {\\n    uint coverid;\\n    uint dateUpd;\\n    bool submit;\\n  }\\n\\n  struct ClaimPauseVoting {\\n    uint claimid;\\n    uint pendingTime;\\n    bool voting;\\n  }\\n\\n  struct RewardDistributed {\\n    uint lastCAvoteIndex;\\n    uint lastMVvoteIndex;\\n\\n  }\\n\\n  struct ClaimRewardDetails {\\n    uint percCA;\\n    uint percMV;\\n    uint tokenToBeDist;\\n\\n  }\\n\\n  struct ClaimTotalTokens {\\n    uint accept;\\n    uint deny;\\n  }\\n\\n  struct ClaimRewardStatus {\\n    uint percCA;\\n    uint percMV;\\n  }\\n\\n  ClaimRewardStatus[] internal rewardStatus;\\n\\n  Claim[] internal allClaims;\\n  Vote[] internal allvotes;\\n  ClaimsPause[] internal claimPause;\\n  ClaimPauseVoting[] internal claimPauseVotingEP;\\n\\n  mapping(address => RewardDistributed) internal voterVoteRewardReceived;\\n  mapping(uint => ClaimRewardDetails) internal claimRewardDetail;\\n  mapping(uint => ClaimTotalTokens) internal claimTokensCA;\\n  mapping(uint => ClaimTotalTokens) internal claimTokensMV;\\n  mapping(uint => int8) internal claimVote;\\n  mapping(uint => uint) internal claimsStatus;\\n  mapping(uint => uint) internal claimState12Count;\\n  mapping(uint => uint[]) internal claimVoteCA;\\n  mapping(uint => uint[]) internal claimVoteMember;\\n  mapping(address => uint[]) internal voteAddressCA;\\n  mapping(address => uint[]) internal voteAddressMember;\\n  mapping(address => uint[]) internal allClaimsByAddress;\\n  mapping(address => mapping(uint => uint)) internal userClaimVoteCA;\\n  mapping(address => mapping(uint => uint)) internal userClaimVoteMember;\\n  mapping(address => uint) public userClaimVotePausedOn;\\n\\n  uint internal claimPauseLastsubmit;\\n  uint internal claimStartVotingFirstIndex;\\n  uint public pendingClaimStart;\\n  uint public claimDepositTime;\\n  uint public maxVotingTime;\\n  uint public minVotingTime;\\n  uint public payoutRetryTime;\\n  uint public claimRewardPerc;\\n  uint public minVoteThreshold;\\n  uint public maxVoteThreshold;\\n  uint public majorityConsensus;\\n  uint public pauseDaysCA;\\n\\n  event ClaimRaise(\\n    uint indexed coverId,\\n    address indexed userAddress,\\n    uint claimId,\\n    uint dateSubmit\\n  );\\n\\n  event VoteCast(\\n    address indexed userAddress,\\n    uint indexed claimId,\\n    bytes4 indexed typeOf,\\n    uint tokens,\\n    uint submitDate,\\n    int8 verdict\\n  );\\n\\n  constructor() public {\\n    pendingClaimStart = 1;\\n    maxVotingTime = 48 * 1 hours;\\n    minVotingTime = 12 * 1 hours;\\n    payoutRetryTime = 24 * 1 hours;\\n    allvotes.push(Vote(address(0), 0, 0, 0, false));\\n    allClaims.push(Claim(0, 0));\\n    claimDepositTime = 7 days;\\n    claimRewardPerc = 20;\\n    minVoteThreshold = 5;\\n    maxVoteThreshold = 10;\\n    majorityConsensus = 70;\\n    pauseDaysCA = 3 days;\\n    _addRewardIncentive();\\n  }\\n\\n  /**\\n   * @dev Updates the pending claim start variable,\\n   * the lowest claim id with a pending decision/payout.\\n   */\\n  function setpendingClaimStart(uint _start) external onlyInternal {\\n    require(pendingClaimStart <= _start);\\n    pendingClaimStart = _start;\\n  }\\n\\n  /**\\n   * @dev Updates the max vote index for which claim assessor has received reward\\n   * @param _voter address of the voter.\\n   * @param caIndex last index till which reward was distributed for CA\\n   */\\n  function setRewardDistributedIndexCA(address _voter, uint caIndex) external onlyInternal {\\n    voterVoteRewardReceived[_voter].lastCAvoteIndex = caIndex;\\n\\n  }\\n\\n  /**\\n   * @dev Used to pause claim assessor activity for 3 days\\n   * @param user Member address whose claim voting ability needs to be paused\\n   */\\n  function setUserClaimVotePausedOn(address user) external {\\n    require(ms.checkIsAuthToGoverned(msg.sender));\\n    userClaimVotePausedOn[user] = now;\\n  }\\n\\n  /**\\n   * @dev Updates the max vote index for which member has received reward\\n   * @param _voter address of the voter.\\n   * @param mvIndex last index till which reward was distributed for member\\n   */\\n  function setRewardDistributedIndexMV(address _voter, uint mvIndex) external onlyInternal {\\n\\n    voterVoteRewardReceived[_voter].lastMVvoteIndex = mvIndex;\\n  }\\n\\n  /**\\n   * @param claimid claim id.\\n   * @param percCA reward Percentage reward for claim assessor\\n   * @param percMV reward Percentage reward for members\\n   * @param tokens total tokens to be rewarded\\n   */\\n  function setClaimRewardDetail(\\n    uint claimid,\\n    uint percCA,\\n    uint percMV,\\n    uint tokens\\n  )\\n  external\\n  onlyInternal\\n  {\\n    claimRewardDetail[claimid].percCA = percCA;\\n    claimRewardDetail[claimid].percMV = percMV;\\n    claimRewardDetail[claimid].tokenToBeDist = tokens;\\n  }\\n\\n  /**\\n   * @dev Sets the reward claim status against a vote id.\\n   * @param _voteid vote Id.\\n   * @param claimed true if reward for vote is claimed, else false.\\n   */\\n  function setRewardClaimed(uint _voteid, bool claimed) external onlyInternal {\\n    allvotes[_voteid].rewardClaimed = claimed;\\n  }\\n\\n  /**\\n   * @dev Sets the final vote's result(either accepted or declined)of a claim.\\n   * @param _claimId Claim Id.\\n   * @param _verdict 1 if claim is accepted,-1 if declined.\\n   */\\n  function changeFinalVerdict(uint _claimId, int8 _verdict) external onlyInternal {\\n    claimVote[_claimId] = _verdict;\\n  }\\n\\n  /**\\n   * @dev Creates a new claim.\\n   */\\n  function addClaim(\\n    uint _claimId,\\n    uint _coverId,\\n    address _from,\\n    uint _nowtime\\n  )\\n  external\\n  onlyInternal\\n  {\\n    allClaims.push(Claim(_coverId, _nowtime));\\n    allClaimsByAddress[_from].push(_claimId);\\n  }\\n\\n  /**\\n   * @dev Add Vote's details of a given claim.\\n   */\\n  function addVote(\\n    address _voter,\\n    uint _tokens,\\n    uint claimId,\\n    int8 _verdict\\n  )\\n  external\\n  onlyInternal\\n  {\\n    allvotes.push(Vote(_voter, _tokens, claimId, _verdict, false));\\n  }\\n\\n  /**\\n   * @dev Stores the id of the claim assessor vote given to a claim.\\n   * Maintains record of all votes given by all the CA to a claim.\\n   * @param _claimId Claim Id to which vote has given by the CA.\\n   * @param _voteid Vote Id.\\n   */\\n  function addClaimVoteCA(uint _claimId, uint _voteid) external onlyInternal {\\n    claimVoteCA[_claimId].push(_voteid);\\n  }\\n\\n  /**\\n   * @dev Sets the id of the vote.\\n   * @param _from Claim assessor's address who has given the vote.\\n   * @param _claimId Claim Id for which vote has been given by the CA.\\n   * @param _voteid Vote Id which will be stored against the given _from and claimid.\\n   */\\n  function setUserClaimVoteCA(\\n    address _from,\\n    uint _claimId,\\n    uint _voteid\\n  )\\n  external\\n  onlyInternal\\n  {\\n    userClaimVoteCA[_from][_claimId] = _voteid;\\n    voteAddressCA[_from].push(_voteid);\\n  }\\n\\n  /**\\n   * @dev Stores the tokens locked by the Claim Assessors during voting of a given claim.\\n   * @param _claimId Claim Id.\\n   * @param _vote 1 for accept and increases the tokens of claim as accept,\\n   * -1 for deny and increases the tokens of claim as deny.\\n   * @param _tokens Number of tokens.\\n   */\\n  function setClaimTokensCA(uint _claimId, int8 _vote, uint _tokens) external onlyInternal {\\n    if (_vote == 1)\\n      claimTokensCA[_claimId].accept = claimTokensCA[_claimId].accept.add(_tokens);\\n    if (_vote == - 1)\\n      claimTokensCA[_claimId].deny = claimTokensCA[_claimId].deny.add(_tokens);\\n  }\\n\\n  /**\\n   * @dev Stores the tokens locked by the Members during voting of a given claim.\\n   * @param _claimId Claim Id.\\n   * @param _vote 1 for accept and increases the tokens of claim as accept,\\n   * -1 for deny and increases the tokens of claim as deny.\\n   * @param _tokens Number of tokens.\\n   */\\n  function setClaimTokensMV(uint _claimId, int8 _vote, uint _tokens) external onlyInternal {\\n    if (_vote == 1)\\n      claimTokensMV[_claimId].accept = claimTokensMV[_claimId].accept.add(_tokens);\\n    if (_vote == - 1)\\n      claimTokensMV[_claimId].deny = claimTokensMV[_claimId].deny.add(_tokens);\\n  }\\n\\n  /**\\n   * @dev Stores the id of the member vote given to a claim.\\n   * Maintains record of all votes given by all the Members to a claim.\\n   * @param _claimId Claim Id to which vote has been given by the Member.\\n   * @param _voteid Vote Id.\\n   */\\n  function addClaimVotemember(uint _claimId, uint _voteid) external onlyInternal {\\n    claimVoteMember[_claimId].push(_voteid);\\n  }\\n\\n  /**\\n   * @dev Sets the id of the vote.\\n   * @param _from Member's address who has given the vote.\\n   * @param _claimId Claim Id for which vote has been given by the Member.\\n   * @param _voteid Vote Id which will be stored against the given _from and claimid.\\n   */\\n  function setUserClaimVoteMember(\\n    address _from,\\n    uint _claimId,\\n    uint _voteid\\n  )\\n  external\\n  onlyInternal\\n  {\\n    userClaimVoteMember[_from][_claimId] = _voteid;\\n    voteAddressMember[_from].push(_voteid);\\n\\n  }\\n\\n  /**\\n   * @dev Increases the count of failure until payout of a claim is successful.\\n   */\\n  function updateState12Count(uint _claimId, uint _cnt) external onlyInternal {\\n    claimState12Count[_claimId] = claimState12Count[_claimId].add(_cnt);\\n  }\\n\\n  /**\\n   * @dev Sets status of a claim.\\n   * @param _claimId Claim Id.\\n   * @param _stat Status number.\\n   */\\n  function setClaimStatus(uint _claimId, uint _stat) external onlyInternal {\\n    claimsStatus[_claimId] = _stat;\\n  }\\n\\n  /**\\n   * @dev Sets the timestamp of a given claim at which the Claim's details has been updated.\\n   * @param _claimId Claim Id of claim which has been changed.\\n   * @param _dateUpd timestamp at which claim is updated.\\n   */\\n  function setClaimdateUpd(uint _claimId, uint _dateUpd) external onlyInternal {\\n    allClaims[_claimId].dateUpd = _dateUpd;\\n  }\\n\\n  /**\\n   @dev Queues Claims during Emergency Pause.\\n   */\\n  function setClaimAtEmergencyPause(\\n    uint _coverId,\\n    uint _dateUpd,\\n    bool _submit\\n  )\\n  external\\n  onlyInternal\\n  {\\n    claimPause.push(ClaimsPause(_coverId, _dateUpd, _submit));\\n  }\\n\\n  /**\\n   * @dev Set submission flag for Claims queued during emergency pause.\\n   * Set to true after EP is turned off and the claim is submitted .\\n   */\\n  function setClaimSubmittedAtEPTrue(uint _index, bool _submit) external onlyInternal {\\n    claimPause[_index].submit = _submit;\\n  }\\n\\n  /**\\n   * @dev Sets the index from which claim needs to be\\n   * submitted when emergency pause is swithched off.\\n   */\\n  function setFirstClaimIndexToSubmitAfterEP(\\n    uint _firstClaimIndexToSubmit\\n  )\\n  external\\n  onlyInternal\\n  {\\n    claimPauseLastsubmit = _firstClaimIndexToSubmit;\\n  }\\n\\n  /**\\n   * @dev Sets the pending vote duration for a claim in case of emergency pause.\\n   */\\n  function setPendingClaimDetails(\\n    uint _claimId,\\n    uint _pendingTime,\\n    bool _voting\\n  )\\n  external\\n  onlyInternal\\n  {\\n    claimPauseVotingEP.push(ClaimPauseVoting(_claimId, _pendingTime, _voting));\\n  }\\n\\n  /**\\n   * @dev Sets voting flag true after claim is reopened for voting after emergency pause.\\n   */\\n  function setPendingClaimVoteStatus(uint _claimId, bool _vote) external onlyInternal {\\n    claimPauseVotingEP[_claimId].voting = _vote;\\n  }\\n\\n  /**\\n   * @dev Sets the index from which claim needs to be\\n   * reopened when emergency pause is swithched off.\\n   */\\n  function setFirstClaimIndexToStartVotingAfterEP(\\n    uint _claimStartVotingFirstIndex\\n  )\\n  external\\n  onlyInternal\\n  {\\n    claimStartVotingFirstIndex = _claimStartVotingFirstIndex;\\n  }\\n\\n  /**\\n   * @dev Calls Vote Event.\\n   */\\n  function callVoteEvent(\\n    address _userAddress,\\n    uint _claimId,\\n    bytes4 _typeOf,\\n    uint _tokens,\\n    uint _submitDate,\\n    int8 _verdict\\n  )\\n  external\\n  onlyInternal\\n  {\\n    emit VoteCast(\\n      _userAddress,\\n      _claimId,\\n      _typeOf,\\n      _tokens,\\n      _submitDate,\\n      _verdict\\n    );\\n  }\\n\\n  /**\\n   * @dev Calls Claim Event.\\n   */\\n  function callClaimEvent(\\n    uint _coverId,\\n    address _userAddress,\\n    uint _claimId,\\n    uint _datesubmit\\n  )\\n  external\\n  onlyInternal\\n  {\\n    emit ClaimRaise(_coverId, _userAddress, _claimId, _datesubmit);\\n  }\\n\\n  /**\\n   * @dev Gets Uint Parameters by parameter code\\n   * @param code whose details we want\\n   * @return string value of the parameter\\n   * @return associated amount (time or perc or value) to the code\\n   */\\n  function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val) {\\n    codeVal = code;\\n    if (code == \\\"CAMAXVT\\\") {\\n      val = maxVotingTime / (1 hours);\\n\\n    } else if (code == \\\"CAMINVT\\\") {\\n\\n      val = minVotingTime / (1 hours);\\n\\n    } else if (code == \\\"CAPRETRY\\\") {\\n\\n      val = payoutRetryTime / (1 hours);\\n\\n    } else if (code == \\\"CADEPT\\\") {\\n\\n      val = claimDepositTime / (1 days);\\n\\n    } else if (code == \\\"CAREWPER\\\") {\\n\\n      val = claimRewardPerc;\\n\\n    } else if (code == \\\"CAMINTH\\\") {\\n\\n      val = minVoteThreshold;\\n\\n    } else if (code == \\\"CAMAXTH\\\") {\\n\\n      val = maxVoteThreshold;\\n\\n    } else if (code == \\\"CACONPER\\\") {\\n\\n      val = majorityConsensus;\\n\\n    } else if (code == \\\"CAPAUSET\\\") {\\n      val = pauseDaysCA / (1 days);\\n    }\\n\\n  }\\n\\n  /**\\n   * @dev Get claim queued during emergency pause by index.\\n   */\\n  function getClaimOfEmergencyPauseByIndex(\\n    uint _index\\n  )\\n  external\\n  view\\n  returns (\\n    uint coverId,\\n    uint dateUpd,\\n    bool submit\\n  )\\n  {\\n    coverId = claimPause[_index].coverid;\\n    dateUpd = claimPause[_index].dateUpd;\\n    submit = claimPause[_index].submit;\\n  }\\n\\n  /**\\n   * @dev Gets the Claim's details of given claimid.\\n   */\\n  function getAllClaimsByIndex(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint coverId,\\n    int8 vote,\\n    uint status,\\n    uint dateUpd,\\n    uint state12Count\\n  )\\n  {\\n    return (\\n    allClaims[_claimId].coverId,\\n    claimVote[_claimId],\\n    claimsStatus[_claimId],\\n    allClaims[_claimId].dateUpd,\\n    claimState12Count[_claimId]\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets the vote id of a given claim of a given Claim Assessor.\\n   */\\n  function getUserClaimVoteCA(\\n    address _add,\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (uint idVote)\\n  {\\n    return userClaimVoteCA[_add][_claimId];\\n  }\\n\\n  /**\\n   * @dev Gets the vote id of a given claim of a given member.\\n   */\\n  function getUserClaimVoteMember(\\n    address _add,\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (uint idVote)\\n  {\\n    return userClaimVoteMember[_add][_claimId];\\n  }\\n\\n  /**\\n   * @dev Gets the count of all votes.\\n   */\\n  function getAllVoteLength() external view returns (uint voteCount) {\\n    return allvotes.length.sub(1); // Start Index always from 1.\\n  }\\n\\n  /**\\n   * @dev Gets the status number of a given claim.\\n   * @param _claimId Claim id.\\n   * @return statno Status Number.\\n   */\\n  function getClaimStatusNumber(uint _claimId) external view returns (uint claimId, uint statno) {\\n    return (_claimId, claimsStatus[_claimId]);\\n  }\\n\\n  /**\\n   * @dev Gets the reward percentage to be distributed for a given status id\\n   * @param statusNumber the number of type of status\\n   * @return percCA reward Percentage for claim assessor\\n   * @return percMV reward Percentage for members\\n   */\\n  function getRewardStatus(uint statusNumber) external view returns (uint percCA, uint percMV) {\\n    return (rewardStatus[statusNumber].percCA, rewardStatus[statusNumber].percMV);\\n  }\\n\\n  /**\\n   * @dev Gets the number of tries that have been made for a successful payout of a Claim.\\n   */\\n  function getClaimState12Count(uint _claimId) external view returns (uint num) {\\n    num = claimState12Count[_claimId];\\n  }\\n\\n  /**\\n   * @dev Gets the last update date of a claim.\\n   */\\n  function getClaimDateUpd(uint _claimId) external view returns (uint dateupd) {\\n    dateupd = allClaims[_claimId].dateUpd;\\n  }\\n\\n  /**\\n   * @dev Gets all Claims created by a user till date.\\n   * @param _member user's address.\\n   * @return claimarr List of Claims id.\\n   */\\n  function getAllClaimsByAddress(address _member) external view returns (uint[] memory claimarr) {\\n    return allClaimsByAddress[_member];\\n  }\\n\\n  /**\\n   * @dev Gets the number of tokens that has been locked\\n   * while giving vote to a claim by  Claim Assessors.\\n   * @param _claimId Claim Id.\\n   * @return accept Total number of tokens when CA accepts the claim.\\n   * @return deny Total number of tokens when CA declines the claim.\\n   */\\n  function getClaimsTokenCA(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint accept,\\n    uint deny\\n  )\\n  {\\n    return (\\n    _claimId,\\n    claimTokensCA[_claimId].accept,\\n    claimTokensCA[_claimId].deny\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets the number of tokens that have been\\n   * locked while assessing a claim as a member.\\n   * @param _claimId Claim Id.\\n   * @return accept Total number of tokens in acceptance of the claim.\\n   * @return deny Total number of tokens against the claim.\\n   */\\n  function getClaimsTokenMV(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint accept,\\n    uint deny\\n  )\\n  {\\n    return (\\n    _claimId,\\n    claimTokensMV[_claimId].accept,\\n    claimTokensMV[_claimId].deny\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets the total number of votes cast as Claims assessor for/against a given claim\\n   */\\n  function getCaClaimVotesToken(uint _claimId) external view returns (uint claimId, uint cnt) {\\n    claimId = _claimId;\\n    cnt = 0;\\n    for (uint i = 0; i < claimVoteCA[_claimId].length; i++) {\\n      cnt = cnt.add(allvotes[claimVoteCA[_claimId][i]].tokens);\\n    }\\n  }\\n\\n  /**\\n   * @dev Gets the total number of tokens cast as a member for/against a given claim\\n   */\\n  function getMemberClaimVotesToken(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (uint claimId, uint cnt)\\n  {\\n    claimId = _claimId;\\n    cnt = 0;\\n    for (uint i = 0; i < claimVoteMember[_claimId].length; i++) {\\n      cnt = cnt.add(allvotes[claimVoteMember[_claimId][i]].tokens);\\n    }\\n  }\\n\\n  /**\\n   * @dev Provides information of a vote when given its vote id.\\n   * @param _voteid Vote Id.\\n   */\\n  function getVoteDetails(uint _voteid)\\n  external view\\n  returns (\\n    uint tokens,\\n    uint claimId,\\n    int8 verdict,\\n    bool rewardClaimed\\n  )\\n  {\\n    return (\\n    allvotes[_voteid].tokens,\\n    allvotes[_voteid].claimId,\\n    allvotes[_voteid].verdict,\\n    allvotes[_voteid].rewardClaimed\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets the voter's address of a given vote id.\\n   */\\n  function getVoterVote(uint _voteid) external view returns (address voter) {\\n    return allvotes[_voteid].voter;\\n  }\\n\\n  /**\\n   * @dev Provides information of a Claim when given its claim id.\\n   * @param _claimId Claim Id.\\n   */\\n  function getClaim(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint coverId,\\n    int8 vote,\\n    uint status,\\n    uint dateUpd,\\n    uint state12Count\\n  )\\n  {\\n    return (\\n    _claimId,\\n    allClaims[_claimId].coverId,\\n    claimVote[_claimId],\\n    claimsStatus[_claimId],\\n    allClaims[_claimId].dateUpd,\\n    claimState12Count[_claimId]\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets the total number of votes of a given claim.\\n   * @param _claimId Claim Id.\\n   * @param _ca if 1: votes given by Claim Assessors to a claim,\\n   * else returns the number of votes of given by Members to a claim.\\n   * @return len total number of votes for/against a given claim.\\n   */\\n  function getClaimVoteLength(\\n    uint _claimId,\\n    uint8 _ca\\n  )\\n  external\\n  view\\n  returns (uint claimId, uint len)\\n  {\\n    claimId = _claimId;\\n    if (_ca == 1)\\n      len = claimVoteCA[_claimId].length;\\n    else\\n      len = claimVoteMember[_claimId].length;\\n  }\\n\\n  /**\\n   * @dev Gets the verdict of a vote using claim id and index.\\n   * @param _ca 1 for vote given as a CA, else for vote given as a member.\\n   * @return ver 1 if vote was given in favour,-1 if given in against.\\n   */\\n  function getVoteVerdict(\\n    uint _claimId,\\n    uint _index,\\n    uint8 _ca\\n  )\\n  external\\n  view\\n  returns (int8 ver)\\n  {\\n    if (_ca == 1)\\n      ver = allvotes[claimVoteCA[_claimId][_index]].verdict;\\n    else\\n      ver = allvotes[claimVoteMember[_claimId][_index]].verdict;\\n  }\\n\\n  /**\\n   * @dev Gets the Number of tokens of a vote using claim id and index.\\n   * @param _ca 1 for vote given as a CA, else for vote given as a member.\\n   * @return tok Number of tokens.\\n   */\\n  function getVoteToken(\\n    uint _claimId,\\n    uint _index,\\n    uint8 _ca\\n  )\\n  external\\n  view\\n  returns (uint tok)\\n  {\\n    if (_ca == 1)\\n      tok = allvotes[claimVoteCA[_claimId][_index]].tokens;\\n    else\\n      tok = allvotes[claimVoteMember[_claimId][_index]].tokens;\\n  }\\n\\n  /**\\n   * @dev Gets the Voter's address of a vote using claim id and index.\\n   * @param _ca 1 for vote given as a CA, else for vote given as a member.\\n   * @return voter Voter's address.\\n   */\\n  function getVoteVoter(\\n    uint _claimId,\\n    uint _index,\\n    uint8 _ca\\n  )\\n  external\\n  view\\n  returns (address voter)\\n  {\\n    if (_ca == 1)\\n      voter = allvotes[claimVoteCA[_claimId][_index]].voter;\\n    else\\n      voter = allvotes[claimVoteMember[_claimId][_index]].voter;\\n  }\\n\\n  /**\\n   * @dev Gets total number of Claims created by a user till date.\\n   * @param _add User's address.\\n   */\\n  function getUserClaimCount(address _add) external view returns (uint len) {\\n    len = allClaimsByAddress[_add].length;\\n  }\\n\\n  /**\\n   * @dev Calculates number of Claims that are in pending state.\\n   */\\n  function getClaimLength() external view returns (uint len) {\\n    len = allClaims.length.sub(pendingClaimStart);\\n  }\\n\\n  /**\\n   * @dev Gets the Number of all the Claims created till date.\\n   */\\n  function actualClaimLength() external view returns (uint len) {\\n    len = allClaims.length;\\n  }\\n\\n  /**\\n   * @dev Gets details of a claim.\\n   * @param _index claim id = pending claim start + given index\\n   * @param _add User's address.\\n   * @return coverid cover against which claim has been submitted.\\n   * @return claimId Claim  Id.\\n   * @return voteCA verdict of vote given as a Claim Assessor.\\n   * @return voteMV verdict of vote given as a Member.\\n   * @return statusnumber Status of claim.\\n   */\\n  function getClaimFromNewStart(\\n    uint _index,\\n    address _add\\n  )\\n  external\\n  view\\n  returns (\\n    uint coverid,\\n    uint claimId,\\n    int8 voteCA,\\n    int8 voteMV,\\n    uint statusnumber\\n  )\\n  {\\n    uint i = pendingClaimStart.add(_index);\\n    coverid = allClaims[i].coverId;\\n    claimId = i;\\n    if (userClaimVoteCA[_add][i] > 0)\\n      voteCA = allvotes[userClaimVoteCA[_add][i]].verdict;\\n    else\\n      voteCA = 0;\\n\\n    if (userClaimVoteMember[_add][i] > 0)\\n      voteMV = allvotes[userClaimVoteMember[_add][i]].verdict;\\n    else\\n      voteMV = 0;\\n\\n    statusnumber = claimsStatus[i];\\n  }\\n\\n  /**\\n   * @dev Gets details of a claim of a user at a given index.\\n   */\\n  function getUserClaimByIndex(\\n    uint _index,\\n    address _add\\n  )\\n  external\\n  view\\n  returns (\\n    uint status,\\n    uint coverid,\\n    uint claimId\\n  )\\n  {\\n    claimId = allClaimsByAddress[_add][_index];\\n    status = claimsStatus[claimId];\\n    coverid = allClaims[claimId].coverId;\\n  }\\n\\n  /**\\n   * @dev Gets Id of all the votes given to a claim.\\n   * @param _claimId Claim Id.\\n   * @return ca id of all the votes given by Claim assessors to a claim.\\n   * @return mv id of all the votes given by members to a claim.\\n   */\\n  function getAllVotesForClaim(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint[] memory ca,\\n    uint[] memory mv\\n  )\\n  {\\n    return (_claimId, claimVoteCA[_claimId], claimVoteMember[_claimId]);\\n  }\\n\\n  /**\\n   * @dev Gets Number of tokens deposit in a vote using\\n   * Claim assessor's address and claim id.\\n   * @return tokens Number of deposited tokens.\\n   */\\n  function getTokensClaim(\\n    address _of,\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint tokens\\n  )\\n  {\\n    return (_claimId, allvotes[userClaimVoteCA[_of][_claimId]].tokens);\\n  }\\n\\n  /**\\n   * @param _voter address of the voter.\\n   * @return lastCAvoteIndex last index till which reward was distributed for CA\\n   * @return lastMVvoteIndex last index till which reward was distributed for member\\n   */\\n  function getRewardDistributedIndex(\\n    address _voter\\n  )\\n  external\\n  view\\n  returns (\\n    uint lastCAvoteIndex,\\n    uint lastMVvoteIndex\\n  )\\n  {\\n    return (\\n    voterVoteRewardReceived[_voter].lastCAvoteIndex,\\n    voterVoteRewardReceived[_voter].lastMVvoteIndex\\n    );\\n  }\\n\\n  /**\\n   * @param claimid claim id.\\n   * @return perc_CA reward Percentage for claim assessor\\n   * @return perc_MV reward Percentage for members\\n   * @return tokens total tokens to be rewarded\\n   */\\n  function getClaimRewardDetail(\\n    uint claimid\\n  )\\n  external\\n  view\\n  returns (\\n    uint percCA,\\n    uint percMV,\\n    uint tokens\\n  )\\n  {\\n    return (\\n    claimRewardDetail[claimid].percCA,\\n    claimRewardDetail[claimid].percMV,\\n    claimRewardDetail[claimid].tokenToBeDist\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets cover id of a claim.\\n   */\\n  function getClaimCoverId(uint _claimId) external view returns (uint claimId, uint coverid) {\\n    return (_claimId, allClaims[_claimId].coverId);\\n  }\\n\\n  /**\\n   * @dev Gets total number of tokens staked during voting by Claim Assessors.\\n   * @param _claimId Claim Id.\\n   * @param _verdict 1 to get total number of accept tokens, -1 to get total number of deny tokens.\\n   * @return token token Number of tokens(either accept or deny on the basis of verdict given as parameter).\\n   */\\n  function getClaimVote(uint _claimId, int8 _verdict) external view returns (uint claimId, uint token) {\\n    claimId = _claimId;\\n    token = 0;\\n    for (uint i = 0; i < claimVoteCA[_claimId].length; i++) {\\n      if (allvotes[claimVoteCA[_claimId][i]].verdict == _verdict)\\n        token = token.add(allvotes[claimVoteCA[_claimId][i]].tokens);\\n    }\\n  }\\n\\n  /**\\n   * @dev Gets total number of tokens staked during voting by Members.\\n   * @param _claimId Claim Id.\\n   * @param _verdict 1 to get total number of accept tokens,\\n   *  -1 to get total number of deny tokens.\\n   * @return token token Number of tokens(either accept or\\n   * deny on the basis of verdict given as parameter).\\n   */\\n  function getClaimMVote(uint _claimId, int8 _verdict) external view returns (uint claimId, uint token) {\\n    claimId = _claimId;\\n    token = 0;\\n    for (uint i = 0; i < claimVoteMember[_claimId].length; i++) {\\n      if (allvotes[claimVoteMember[_claimId][i]].verdict == _verdict)\\n        token = token.add(allvotes[claimVoteMember[_claimId][i]].tokens);\\n    }\\n  }\\n\\n  /**\\n   * @param _voter address  of voteid\\n   * @param index index to get voteid in CA\\n   */\\n  function getVoteAddressCA(address _voter, uint index) external view returns (uint) {\\n    return voteAddressCA[_voter][index];\\n  }\\n\\n  /**\\n   * @param _voter address  of voter\\n   * @param index index to get voteid in member vote\\n   */\\n  function getVoteAddressMember(address _voter, uint index) external view returns (uint) {\\n    return voteAddressMember[_voter][index];\\n  }\\n\\n  /**\\n   * @param _voter address  of voter\\n   */\\n  function getVoteAddressCALength(address _voter) external view returns (uint) {\\n    return voteAddressCA[_voter].length;\\n  }\\n\\n  /**\\n   * @param _voter address  of voter\\n   */\\n  function getVoteAddressMemberLength(address _voter) external view returns (uint) {\\n    return voteAddressMember[_voter].length;\\n  }\\n\\n  /**\\n   * @dev Gets the Final result of voting of a claim.\\n   * @param _claimId Claim id.\\n   * @return verdict 1 if claim is accepted, -1 if declined.\\n   */\\n  function getFinalVerdict(uint _claimId) external view returns (int8 verdict) {\\n    return claimVote[_claimId];\\n  }\\n\\n  /**\\n   * @dev Get number of Claims queued for submission during emergency pause.\\n   */\\n  function getLengthOfClaimSubmittedAtEP() external view returns (uint len) {\\n    len = claimPause.length;\\n  }\\n\\n  /**\\n   * @dev Gets the index from which claim needs to be\\n   * submitted when emergency pause is swithched off.\\n   */\\n  function getFirstClaimIndexToSubmitAfterEP() external view returns (uint indexToSubmit) {\\n    indexToSubmit = claimPauseLastsubmit;\\n  }\\n\\n  /**\\n   * @dev Gets number of Claims to be reopened for voting post emergency pause period.\\n   */\\n  function getLengthOfClaimVotingPause() external view returns (uint len) {\\n    len = claimPauseVotingEP.length;\\n  }\\n\\n  /**\\n   * @dev Gets claim details to be reopened for voting after emergency pause.\\n   */\\n  function getPendingClaimDetailsByIndex(\\n    uint _index\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint pendingTime,\\n    bool voting\\n  )\\n  {\\n    claimId = claimPauseVotingEP[_index].claimid;\\n    pendingTime = claimPauseVotingEP[_index].pendingTime;\\n    voting = claimPauseVotingEP[_index].voting;\\n  }\\n\\n  /**\\n   * @dev Gets the index from which claim needs to be reopened when emergency pause is swithched off.\\n   */\\n  function getFirstClaimIndexToStartVotingAfterEP() external view returns (uint firstindex) {\\n    firstindex = claimStartVotingFirstIndex;\\n  }\\n\\n  /**\\n   * @dev Updates Uint Parameters of a code\\n   * @param code whose details we want to update\\n   * @param val value to set\\n   */\\n  function updateUintParameters(bytes8 code, uint val) public {\\n    require(ms.checkIsAuthToGoverned(msg.sender));\\n    if (code == \\\"CAMAXVT\\\") {\\n      _setMaxVotingTime(val * 1 hours);\\n\\n    } else if (code == \\\"CAMINVT\\\") {\\n\\n      _setMinVotingTime(val * 1 hours);\\n\\n    } else if (code == \\\"CAPRETRY\\\") {\\n\\n      _setPayoutRetryTime(val * 1 hours);\\n\\n    } else if (code == \\\"CADEPT\\\") {\\n\\n      _setClaimDepositTime(val * 1 days);\\n\\n    } else if (code == \\\"CAREWPER\\\") {\\n\\n      _setClaimRewardPerc(val);\\n\\n    } else if (code == \\\"CAMINTH\\\") {\\n\\n      _setMinVoteThreshold(val);\\n\\n    } else if (code == \\\"CAMAXTH\\\") {\\n\\n      _setMaxVoteThreshold(val);\\n\\n    } else if (code == \\\"CACONPER\\\") {\\n\\n      _setMajorityConsensus(val);\\n\\n    } else if (code == \\\"CAPAUSET\\\") {\\n      _setPauseDaysCA(val * 1 days);\\n    } else {\\n\\n      revert(\\\"Invalid param code\\\");\\n    }\\n\\n  }\\n\\n  /**\\n   * @dev Iupgradable Interface to update dependent contract address\\n   */\\n  function changeDependentContractAddress() public onlyInternal {}\\n\\n  /**\\n   * @dev Adds status under which a claim can lie.\\n   * @param percCA reward percentage for claim assessor\\n   * @param percMV reward percentage for members\\n   */\\n  function _pushStatus(uint percCA, uint percMV) internal {\\n    rewardStatus.push(ClaimRewardStatus(percCA, percMV));\\n  }\\n\\n  /**\\n   * @dev adds reward incentive for all possible claim status for Claim assessors and members\\n   */\\n  function _addRewardIncentive() internal {\\n    _pushStatus(0, 0); // 0  Pending-Claim Assessor Vote\\n    _pushStatus(0, 0); // 1 Pending-Claim Assessor Vote Denied, Pending Member Vote\\n    _pushStatus(0, 0); // 2 Pending-CA Vote Threshold not Reached Accept, Pending Member Vote\\n    _pushStatus(0, 0); // 3 Pending-CA Vote Threshold not Reached Deny, Pending Member Vote\\n    _pushStatus(0, 0); // 4 Pending-CA Consensus not reached Accept, Pending Member Vote\\n    _pushStatus(0, 0); // 5 Pending-CA Consensus not reached Deny, Pending Member Vote\\n    _pushStatus(100, 0); // 6 Final-Claim Assessor Vote Denied\\n    _pushStatus(100, 0); // 7 Final-Claim Assessor Vote Accepted\\n    _pushStatus(0, 100); // 8 Final-Claim Assessor Vote Denied, MV Accepted\\n    _pushStatus(0, 100); // 9 Final-Claim Assessor Vote Denied, MV Denied\\n    _pushStatus(0, 0); // 10 Final-Claim Assessor Vote Accept, MV Nodecision\\n    _pushStatus(0, 0); // 11 Final-Claim Assessor Vote Denied, MV Nodecision\\n    _pushStatus(0, 0); // 12 Claim Accepted Payout Pending\\n    _pushStatus(0, 0); // 13 Claim Accepted No Payout\\n    _pushStatus(0, 0); // 14 Claim Accepted Payout Done\\n  }\\n\\n  /**\\n   * @dev Sets Maximum time(in seconds) for which claim assessment voting is open\\n   */\\n  function _setMaxVotingTime(uint _time) internal {\\n    maxVotingTime = _time;\\n  }\\n\\n  /**\\n   *  @dev Sets Minimum time(in seconds) for which claim assessment voting is open\\n   */\\n  function _setMinVotingTime(uint _time) internal {\\n    minVotingTime = _time;\\n  }\\n\\n  /**\\n   *  @dev Sets Minimum vote threshold required\\n   */\\n  function _setMinVoteThreshold(uint val) internal {\\n    minVoteThreshold = val;\\n  }\\n\\n  /**\\n   *  @dev Sets Maximum vote threshold required\\n   */\\n  function _setMaxVoteThreshold(uint val) internal {\\n    maxVoteThreshold = val;\\n  }\\n\\n  /**\\n   *  @dev Sets the value considered as Majority Consenus in voting\\n   */\\n  function _setMajorityConsensus(uint val) internal {\\n    majorityConsensus = val;\\n  }\\n\\n  /**\\n   * @dev Sets the payout retry time\\n   */\\n  function _setPayoutRetryTime(uint _time) internal {\\n    payoutRetryTime = _time;\\n  }\\n\\n  /**\\n   *  @dev Sets percentage of reward given for claim assessment\\n   */\\n  function _setClaimRewardPerc(uint _val) internal {\\n\\n    claimRewardPerc = _val;\\n  }\\n\\n  /**\\n   * @dev Sets the time for which claim is deposited.\\n   */\\n  function _setClaimDepositTime(uint _time) internal {\\n\\n    claimDepositTime = _time;\\n  }\\n\\n  /**\\n   *  @dev Sets number of days claim assessment will be paused\\n   */\\n  function _setPauseDaysCA(uint val) internal {\\n    pauseDaysCA = val;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/token/external/OZIERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ninterface OZIERC20 {\\n  function transfer(address to, uint256 value) external returns (bool);\\n\\n  function approve(address spender, uint256 value)\\n  external returns (bool);\\n\\n  function transferFrom(address from, address to, uint256 value)\\n  external returns (bool);\\n\\n  function totalSupply() external view returns (uint256);\\n\\n  function balanceOf(address who) external view returns (uint256);\\n\\n  function allowance(address owner, address spender)\\n  external view returns (uint256);\\n\\n  event Transfer(\\n    address indexed from,\\n    address indexed to,\\n    uint256 value\\n  );\\n\\n  event Approval(\\n    address indexed owner,\\n    address indexed spender,\\n    uint256 value\\n  );\\n}\\n\"\r\n    },\r\n    \"contracts/modules/token/external/OZSafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that revert on error\\n */\\nlibrary OZSafeMath {\\n\\n  /**\\n  * @dev Multiplies two numbers, reverts on overflow.\\n  */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b);\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\\n  */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n  */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b <= a);\\n    uint256 c = a - b;\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Adds two numbers, reverts on overflow.\\n  */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a);\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\\n  * reverts when dividing by zero.\\n  */\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0);\\n    return a % b;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/token/external/LockHandler.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @title ERC1132 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/1132\\n */\\n\\ncontract LockHandler {\\n  /**\\n   * @dev Reasons why a user's tokens have been locked\\n   */\\n  mapping(address => bytes32[]) public lockReason;\\n\\n  /**\\n   * @dev locked token structure\\n   */\\n  struct LockToken {\\n    uint256 amount;\\n    uint256 validity;\\n    bool claimed;\\n  }\\n\\n  /**\\n   * @dev Holds number & validity of tokens locked for a given reason for\\n   *      a specified address\\n   */\\n  mapping(address => mapping(bytes32 => LockToken)) public locked;\\n}\\n\"\r\n    },\r\n    \"contracts/modules/governance/external/Governed.sol\": {\r\n      \"content\": \"/* Copyright (C) 2017 GovBlocks.io\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\n\\ninterface IMaster {\\n  function getLatestAddress(bytes2 _module) external view returns (address);\\n}\\n\\ncontract Governed {\\n\\n  address public masterAddress; // Name of the dApp, needs to be set by contracts inheriting this contract\\n\\n  /// @dev modifier that allows only the authorized addresses to execute the function\\n  modifier onlyAuthorizedToGovern() {\\n    IMaster ms = IMaster(masterAddress);\\n    require(ms.getLatestAddress(\\\"GV\\\") == msg.sender, \\\"Not authorized\\\");\\n    _;\\n  }\\n\\n  /// @dev checks if an address is authorized to govern\\n  function isAuthorizedToGovern(address _toCheck) public view returns (bool) {\\n    IMaster ms = IMaster(masterAddress);\\n    return (ms.getLatestAddress(\\\"GV\\\") == _toCheck);\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/modules/governance/external/IGovernance.sol\": {\r\n      \"content\": \"/* Copyright (C) 2017 GovBlocks.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\ncontract IGovernance {\\n\\n  event Proposal(\\n    address indexed proposalOwner,\\n    uint256 indexed proposalId,\\n    uint256 dateAdd,\\n    string proposalTitle,\\n    string proposalSD,\\n    string proposalDescHash\\n  );\\n\\n  event Solution(\\n    uint256 indexed proposalId,\\n    address indexed solutionOwner,\\n    uint256 indexed solutionId,\\n    string solutionDescHash,\\n    uint256 dateAdd\\n  );\\n\\n  event Vote(\\n    address indexed from,\\n    uint256 indexed proposalId,\\n    uint256 indexed voteId,\\n    uint256 dateAdd,\\n    uint256 solutionChosen\\n  );\\n\\n  event RewardClaimed(\\n    address indexed member,\\n    uint gbtReward\\n  );\\n\\n  /// @dev VoteCast event is called whenever a vote is cast that can potentially close the proposal.\\n  event VoteCast (uint256 proposalId);\\n\\n  /// @dev ProposalAccepted event is called when a proposal is accepted so that a server can listen that can\\n  ///      call any offchain actions\\n  event ProposalAccepted (uint256 proposalId);\\n\\n  /// @dev CloseProposalOnTime event is called whenever a proposal is created or updated to close it on time.\\n  event CloseProposalOnTime (\\n    uint256 indexed proposalId,\\n    uint256 time\\n  );\\n\\n  /// @dev ActionSuccess event is called whenever an onchain action is executed.\\n  event ActionSuccess (\\n    uint256 proposalId\\n  );\\n\\n  /// @dev Creates a new proposal\\n  /// @param _proposalDescHash Proposal description hash through IPFS having Short and long description of proposal\\n  /// @param _categoryId This id tells under which the proposal is categorized i.e. Proposal's Objective\\n  function createProposal(\\n    string calldata _proposalTitle,\\n    string calldata _proposalSD,\\n    string calldata _proposalDescHash,\\n    uint _categoryId\\n  )\\n  external;\\n\\n  /// @dev Edits the details of an existing proposal and creates new version\\n  /// @param _proposalId Proposal id that details needs to be updated\\n  /// @param _proposalDescHash Proposal description hash having long and short description of proposal.\\n  function updateProposal(\\n    uint _proposalId,\\n    string calldata _proposalTitle,\\n    string calldata _proposalSD,\\n    string calldata _proposalDescHash\\n  )\\n  external;\\n\\n  /// @dev Categorizes proposal to proceed further. Categories shows the proposal objective.\\n  function categorizeProposal(\\n    uint _proposalId,\\n    uint _categoryId,\\n    uint _incentives\\n  )\\n  external;\\n\\n  /// @dev Submit proposal with solution\\n  /// @param _proposalId Proposal id\\n  /// @param _solutionHash Solution hash contains  parameters, values and description needed according to proposal\\n  function submitProposalWithSolution(\\n    uint _proposalId,\\n    string calldata _solutionHash,\\n    bytes calldata _action\\n  )\\n  external;\\n\\n  /// @dev Creates a new proposal with solution and votes for the solution\\n  /// @param _proposalDescHash Proposal description hash through IPFS having Short and long description of proposal\\n  /// @param _categoryId This id tells under which the proposal is categorized i.e. Proposal's Objective\\n  /// @param _solutionHash Solution hash contains  parameters, values and description needed according to proposal\\n  function createProposalwithSolution(\\n    string calldata _proposalTitle,\\n    string calldata _proposalSD,\\n    string calldata _proposalDescHash,\\n    uint _categoryId,\\n    string calldata _solutionHash,\\n    bytes calldata _action\\n  )\\n  external;\\n\\n  /// @dev Casts vote\\n  /// @param _proposalId Proposal id\\n  /// @param _solutionChosen solution chosen while voting. _solutionChosen[0] is the chosen solution\\n  function submitVote(uint _proposalId, uint _solutionChosen) external;\\n\\n  function closeProposal(uint _proposalId) external;\\n\\n  function claimReward(address _memberAddress, uint _maxRecords) external returns (uint pendingDAppReward);\\n\\n  function proposal(uint _proposalId)\\n  external\\n  view\\n  returns (\\n    uint proposalId,\\n    uint category,\\n    uint status,\\n    uint finalVerdict,\\n    uint totalReward\\n  );\\n\\n  function canCloseProposal(uint _proposalId) public view returns (uint closeValue);\\n\\n  function allowedToCatgorize() public view returns (uint roleId);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/modules/governance/external/IProposalCategory.sol\": {\r\n      \"content\": \"/* Copyright (C) 2017 GovBlocks.io\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\ncontract IProposalCategory {\\n\\n  event Category(\\n    uint indexed categoryId,\\n    string categoryName,\\n    string actionHash\\n  );\\n\\n  /// @dev Adds new category\\n  /// @param _name Category name\\n  /// @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\\n  /// @param _allowedToCreateProposal Member roles allowed to create the proposal\\n  /// @param _majorityVotePerc Majority Vote threshold for Each voting layer\\n  /// @param _quorumPerc minimum threshold percentage required in voting to calculate result\\n  /// @param _closingTime Vote closing time for Each voting layer\\n  /// @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\\n  /// @param _contractAddress address of contract to call after proposal is accepted\\n  /// @param _contractName name of contract to be called after proposal is accepted\\n  /// @param _incentives rewards to distributed after proposal is accepted\\n  function addCategory(\\n    string calldata _name,\\n    uint _memberRoleToVote,\\n    uint _majorityVotePerc,\\n    uint _quorumPerc,\\n    uint[] calldata _allowedToCreateProposal,\\n    uint _closingTime,\\n    string calldata _actionHash,\\n    address _contractAddress,\\n    bytes2 _contractName,\\n    uint[] calldata _incentives\\n  )\\n  external;\\n\\n  /// @dev gets category details\\n  function category(uint _categoryId)\\n  external\\n  view\\n  returns (\\n    uint categoryId,\\n    uint memberRoleToVote,\\n    uint majorityVotePerc,\\n    uint quorumPerc,\\n    uint[] memory allowedToCreateProposal,\\n    uint closingTime,\\n    uint minStake\\n  );\\n\\n  ///@dev gets category action details\\n  function categoryAction(uint _categoryId)\\n  external\\n  view\\n  returns (\\n    uint categoryId,\\n    address contractAddress,\\n    bytes2 contractName,\\n    uint defaultIncentive\\n  );\\n\\n  /// @dev Gets Total number of categories added till now\\n  function totalCategories() external view returns (uint numberOfCategories);\\n\\n  /// @dev Updates category details\\n  /// @param _categoryId Category id that needs to be updated\\n  /// @param _name Category name\\n  /// @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\\n  /// @param _allowedToCreateProposal Member roles allowed to create the proposal\\n  /// @param _majorityVotePerc Majority Vote threshold for Each voting layer\\n  /// @param _quorumPerc minimum threshold percentage required in voting to calculate result\\n  /// @param _closingTime Vote closing time for Each voting layer\\n  /// @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\\n  /// @param _contractAddress address of contract to call after proposal is accepted\\n  /// @param _contractName name of contract to be called after proposal is accepted\\n  /// @param _incentives rewards to distributed after proposal is accepted\\n  function updateCategory(\\n    uint _categoryId,\\n    string memory _name,\\n    uint _memberRoleToVote,\\n    uint _majorityVotePerc,\\n    uint _quorumPerc,\\n    uint[] memory _allowedToCreateProposal,\\n    uint _closingTime,\\n    string memory _actionHash,\\n    address _contractAddress,\\n    bytes2 _contractName,\\n    uint[] memory _incentives\\n  )\\n  public;\\n\\n}\\n\"\r\n    },\r\n    \"contracts/external/uniswap/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport './IUniswapV2Router01.sol';\\n\\ncontract IUniswapV2Router02 is IUniswapV2Router01 {\\n\\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\\n    address token,\\n    uint liquidity,\\n    uint amountTokenMin,\\n    uint amountETHMin,\\n    address to,\\n    uint deadline\\n  ) external returns (uint amountETH);\\n\\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n    address token,\\n    uint liquidity,\\n    uint amountTokenMin,\\n    uint amountETHMin,\\n    address to,\\n    uint deadline,\\n    bool approveMax, uint8 v, bytes32 r, bytes32 s\\n  ) external returns (uint amountETH);\\n\\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n    uint amountIn,\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external;\\n\\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external payable;\\n\\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n    uint amountIn,\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/modules/oracles/TwapOracle.sol\": {\r\n      \"content\": \"/* Copyright (C) 2020 NexusMutual.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"@uniswap/lib/contracts/libraries/FixedPoint.sol\\\";\\nimport \\\"@uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary.sol\\\";\\n\\ncontract TwapOracle {\\n  using FixedPoint for *;\\n\\n  struct Bucket {\\n    uint timestamp;\\n    uint price0Cumulative;\\n    uint price1Cumulative;\\n  }\\n\\n  event Updated(address indexed pair, uint timestamp, uint price0Cumulative, uint price1Cumulative);\\n\\n  uint constant public periodSize = 1800;\\n  uint constant public periodsPerWindow = 8;\\n  uint constant public windowSize = periodSize * periodsPerWindow;\\n\\n  address public factory;\\n\\n  // token pair => Bucket[8]\\n  mapping(address => Bucket[8]) public buckets;\\n\\n  constructor (address _factory) public {\\n    factory = _factory;\\n  }\\n\\n  /* utils */\\n\\n  // https://uniswap.org/docs/v2/smart-contract-integration/getting-pair-addresses/\\n  function _pairFor(address _factory, address tokenA, address tokenB) internal pure returns (address pair) {\\n\\n    // sort tokens\\n    (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n\\n    require(token0 != token1, \\\"TWAP: identical addresses\\\");\\n    require(token0 != address(0), \\\"TWAP: zero address\\\");\\n\\n    pair = address(uint(keccak256(abi.encodePacked(\\n        hex'ff',\\n        _factory,\\n        keccak256(abi.encodePacked(token0, token1)),\\n        hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f'\\n      ))));\\n  }\\n\\n  function timestampToIndex(uint timestamp) internal pure returns (uint index) {\\n    uint epochPeriod = timestamp / periodSize;\\n    return epochPeriod % periodsPerWindow;\\n  }\\n\\n  function pairFor(address tokenA, address tokenB) external view returns (address pair) {\\n    return _pairFor(factory, tokenA, tokenB);\\n  }\\n\\n  function currentBucketIndex() external view returns (uint index) {\\n    return timestampToIndex(block.timestamp);\\n  }\\n\\n  /* update */\\n\\n  function update(address[] calldata pairs) external {\\n\\n    for (uint i = 0; i < pairs.length; i++) {\\n\\n      // note: not reusing canUpdate() because we need the bucket variable\\n      address pair = pairs[i];\\n      uint index = timestampToIndex(block.timestamp);\\n      Bucket storage bucket = buckets[pair][index];\\n\\n      if (block.timestamp - bucket.timestamp < periodSize) {\\n        continue;\\n      }\\n\\n      (uint price0Cumulative, uint price1Cumulative,) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\\n      bucket.timestamp = block.timestamp;\\n      bucket.price0Cumulative = price0Cumulative;\\n      bucket.price1Cumulative = price1Cumulative;\\n\\n      emit Updated(pair, block.timestamp, price0Cumulative, price1Cumulative);\\n    }\\n  }\\n\\n  function canUpdate(address pair) external view returns (bool) {\\n\\n    uint index = timestampToIndex(block.timestamp);\\n    Bucket storage bucket = buckets[pair][index];\\n    uint timeElapsed = block.timestamp - bucket.timestamp;\\n\\n    return timeElapsed > periodSize;\\n  }\\n\\n  /* consult */\\n\\n  function _getCumulativePrices(\\n    address tokenIn,\\n    address tokenOut\\n  ) internal view returns (uint priceCumulativeStart, uint priceCumulativeEnd, uint timeElapsed) {\\n\\n    uint currentIndex = timestampToIndex(block.timestamp);\\n    uint firstBucketIndex = (currentIndex + 1) % periodsPerWindow;\\n\\n    address pair = _pairFor(factory, tokenIn, tokenOut);\\n    Bucket storage firstBucket = buckets[pair][firstBucketIndex];\\n\\n    timeElapsed = block.timestamp - firstBucket.timestamp;\\n    require(timeElapsed <= windowSize, \\\"TWAP: missing historical reading\\\");\\n    require(timeElapsed >= windowSize - periodSize * 2, \\\"TWAP: unexpected time elapsed\\\");\\n\\n    (uint price0Cumulative, uint price1Cumulative,) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\\n\\n    if (tokenIn < tokenOut) {\\n      return (firstBucket.price0Cumulative, price0Cumulative, timeElapsed);\\n    }\\n\\n    return (firstBucket.price1Cumulative, price1Cumulative, timeElapsed);\\n  }\\n\\n  function _computeAmountOut(\\n    uint priceCumulativeStart,\\n    uint priceCumulativeEnd,\\n    uint timeElapsed,\\n    uint amountIn\\n  ) internal pure returns (uint amountOut) {\\n\\n    // overflow is desired.\\n    FixedPoint.uq112x112 memory priceAverage = FixedPoint.uq112x112(\\n      uint224((priceCumulativeEnd - priceCumulativeStart) / timeElapsed)\\n    );\\n\\n    return priceAverage.mul(amountIn).decode144();\\n  }\\n\\n  /**\\n   *  @dev Returns the amount out corresponding to the amount in for a given token using the\\n   *  @dev   moving average over the time range [now - [windowSize, windowSize - periodSize * 2], now]\\n   *  @dev   update must have been called for the bucket corresponding to timestamp `now - windowSize`\\n   */\\n  function consult(address tokenIn, uint amountIn, address tokenOut) external view returns (uint amountOut) {\\n\\n    uint pastPriceCumulative;\\n    uint currentPriceCumulative;\\n    uint timeElapsed;\\n\\n    (pastPriceCumulative, currentPriceCumulative, timeElapsed) = _getCumulativePrices(tokenIn, tokenOut);\\n\\n    return _computeAmountOut(\\n      pastPriceCumulative,\\n      currentPriceCumulative,\\n      timeElapsed,\\n      amountIn\\n    );\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/external/uniswap/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\ninterface IUniswapV2Router01 {\\n\\n  function factory() external pure returns (address);\\n\\n  function WETH() external pure returns (address);\\n\\n  function addLiquidity(\\n    address tokenA,\\n    address tokenB,\\n    uint amountADesired,\\n    uint amountBDesired,\\n    uint amountAMin,\\n    uint amountBMin,\\n    address to,\\n    uint deadline\\n  ) external returns (uint amountA, uint amountB, uint liquidity);\\n\\n  function addLiquidityETH(\\n    address token,\\n    uint amountTokenDesired,\\n    uint amountTokenMin,\\n    uint amountETHMin,\\n    address to,\\n    uint deadline\\n  ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n\\n  function removeLiquidity(\\n    address tokenA,\\n    address tokenB,\\n    uint liquidity,\\n    uint amountAMin,\\n    uint amountBMin,\\n    address to,\\n    uint deadline\\n  ) external returns (uint amountA, uint amountB);\\n\\n  function removeLiquidityETH(\\n    address token,\\n    uint liquidity,\\n    uint amountTokenMin,\\n    uint amountETHMin,\\n    address to,\\n    uint deadline\\n  ) external returns (uint amountToken, uint amountETH);\\n\\n  function removeLiquidityWithPermit(\\n    address tokenA,\\n    address tokenB,\\n    uint liquidity,\\n    uint amountAMin,\\n    uint amountBMin,\\n    address to,\\n    uint deadline,\\n    bool approveMax, uint8 v, bytes32 r, bytes32 s\\n  ) external returns (uint amountA, uint amountB);\\n\\n  function removeLiquidityETHWithPermit(\\n    address token,\\n    uint liquidity,\\n    uint amountTokenMin,\\n    uint amountETHMin,\\n    address to,\\n    uint deadline,\\n    bool approveMax, uint8 v, bytes32 r, bytes32 s\\n  ) external returns (uint amountToken, uint amountETH);\\n\\n  function swapExactTokensForTokens(\\n    uint amountIn,\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external returns (uint[] memory amounts);\\n\\n  function swapTokensForExactTokens(\\n    uint amountOut,\\n    uint amountInMax,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external returns (uint[] memory amounts);\\n\\n  function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n  external\\n  payable\\n  returns (uint[] memory amounts);\\n\\n  function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n  external\\n  returns (uint[] memory amounts);\\n\\n  function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n  external\\n  returns (uint[] memory amounts);\\n\\n  function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n  external\\n  payable\\n  returns (uint[] memory amounts);\\n\\n  function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n\\n  function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n\\n  function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n\\n  function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n\\n  function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"@uniswap/lib/contracts/libraries/FixedPoint.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.0;\\n\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\nlibrary FixedPoint {\\n    // range: [0, 2**112 - 1]\\n    // resolution: 1 / 2**112\\n    struct uq112x112 {\\n        uint224 _x;\\n    }\\n\\n    // range: [0, 2**144 - 1]\\n    // resolution: 1 / 2**112\\n    struct uq144x112 {\\n        uint _x;\\n    }\\n\\n    uint8 private constant RESOLUTION = 112;\\n\\n    // encode a uint112 as a UQ112x112\\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\\n        return uq112x112(uint224(x) << RESOLUTION);\\n    }\\n\\n    // encodes a uint144 as a UQ144x112\\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\\n        return uq144x112(uint256(x) << RESOLUTION);\\n    }\\n\\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\\n    function div(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {\\n        require(x != 0, 'FixedPoint: DIV_BY_ZERO');\\n        return uq112x112(self._x / uint224(x));\\n    }\\n\\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\\n    // reverts on overflow\\n    function mul(uq112x112 memory self, uint y) internal pure returns (uq144x112 memory) {\\n        uint z;\\n        require(y == 0 || (z = uint(self._x) * y) / y == uint(self._x), \\\"FixedPoint: MULTIPLICATION_OVERFLOW\\\");\\n        return uq144x112(z);\\n    }\\n\\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\\n    // equivalent to encode(numerator).div(denominator)\\n    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\\n        require(denominator > 0, \\\"FixedPoint: DIV_BY_ZERO\\\");\\n        return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\\n    }\\n\\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\\n        return uint112(self._x >> RESOLUTION);\\n    }\\n\\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\\n        return uint144(self._x >> RESOLUTION);\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\\nimport '@uniswap/lib/contracts/libraries/FixedPoint.sol';\\n\\n// library with helper methods for oracles that are concerned with computing average prices\\nlibrary UniswapV2OracleLibrary {\\n    using FixedPoint for *;\\n\\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\\n    function currentBlockTimestamp() internal view returns (uint32) {\\n        return uint32(block.timestamp % 2 ** 32);\\n    }\\n\\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\\n    function currentCumulativePrices(\\n        address pair\\n    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\\n        blockTimestamp = currentBlockTimestamp();\\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\\n\\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\\n        if (blockTimestampLast != blockTimestamp) {\\n            // subtraction overflow is desired\\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\\n            // addition overflow is desired\\n            // counterfactual\\n            price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\\n            // counterfactual\\n            price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"holdedCoverID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"reason\",\"type\":\"bytes32\"}],\"name\":\"RefundEvent\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[],\"name\":\"changeDependentContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_masterAddress\",\"type\":\"address\"}],\"name\":\"changeMasterAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cr\",\"outputs\":[{\"internalType\":\"contract ClaimsReward\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"scAddress\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"coverCurr\",\"type\":\"bytes4\"},{\"internalType\":\"uint256[]\",\"name\":\"coverDetails\",\"type\":\"uint256[]\"},{\"internalType\":\"uint16\",\"name\":\"coverPeriod\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"createCover\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"coverId\",\"type\":\"uint256\"}],\"name\":\"expireCover\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"coverDetails\",\"type\":\"uint256[]\"},{\"internalType\":\"uint16\",\"name\":\"coverPeriod\",\"type\":\"uint16\"},{\"internalType\":\"bytes4\",\"name\":\"curr\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"smaratCA\",\"type\":\"address\"}],\"name\":\"getOrderHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"coverOwner\",\"type\":\"address\"}],\"name\":\"getWithdrawableCoverNoteCoverIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"expiredCoverIds\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"lockReasons\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"coverOwner\",\"type\":\"address\"}],\"name\":\"getWithdrawableCoverNotesAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_add\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"kycVerdict\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m1\",\"outputs\":[{\"internalType\":\"contract MCR\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"coverDetails\",\"type\":\"uint256[]\"},{\"internalType\":\"uint16\",\"name\":\"coverPeriod\",\"type\":\"uint16\"},{\"internalType\":\"bytes4\",\"name\":\"coverCurr\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"smartCAdd\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"makeCoverUsingNXMTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mr\",\"outputs\":[{\"internalType\":\"contract MemberRoles\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ms\",\"outputs\":[{\"internalType\":\"contract INXMMaster\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nxMasterAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pd\",\"outputs\":[{\"internalType\":\"contract PoolData\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"contract Pool\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"qd\",\"outputs\":[{\"internalType\":\"contract QuotationData\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sendEther\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tc\",\"outputs\":[{\"internalType\":\"contract TokenController\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"td\",\"outputs\":[{\"internalType\":\"contract TokenData\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tf\",\"outputs\":[{\"internalType\":\"contract TokenFunctions\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdd\",\"type\":\"address\"}],\"name\":\"transferAssetsToNewContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"scAddress\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"coverCurr\",\"type\":\"bytes4\"},{\"internalType\":\"uint256[]\",\"name\":\"coverDetails\",\"type\":\"uint256[]\"},{\"internalType\":\"uint16\",\"name\":\"coverPeriod\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"verifyCoverDetails\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"coverDetails\",\"type\":\"uint256[]\"},{\"internalType\":\"uint16\",\"name\":\"coverPeriod\",\"type\":\"uint16\"},{\"internalType\":\"bytes4\",\"name\":\"curr\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"smaratCA\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"verifySign\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"coverOwner\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"coverIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"reasonIndexes\",\"type\":\"uint256[]\"}],\"name\":\"withdrawCoverNote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Quotation","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}