{"status":"1","message":"OK","result":[{"SourceCode":"// Sources flattened with hardhat v2.1.1 https://hardhat.org\r\n\r\n// File contracts/oracle/interfaces/FinderInterface.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Provides addresses of the live contracts implementing certain interfaces.\r\n * @dev Examples are the Oracle or Store interfaces.\r\n */\r\ninterface FinderInterface {\r\n    /**\r\n     * @notice Updates the address of the contract that implements `interfaceName`.\r\n     * @param interfaceName bytes32 encoding of the interface name that is either changed or registered.\r\n     * @param implementationAddress address of the deployed contract that implements the interface.\r\n     */\r\n    function changeImplementationAddress(bytes32 interfaceName, address implementationAddress) external;\r\n\r\n    /**\r\n     * @notice Gets the address of the contract that implements the given `interfaceName`.\r\n     * @param interfaceName queried interface.\r\n     * @return implementationAddress address of the deployed contract that implements the interface.\r\n     */\r\n    function getImplementationAddress(bytes32 interfaceName) external view returns (address);\r\n}\r\n\r\n\r\n// File contracts/chainbridge/IBridge.sol\r\n\r\n// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n    @title Interface for Bridge contract.\r\n    @dev Copied directly from here: https://github.com/ChainSafe/chainbridge-solidity/releases/tag/v1.0.0 except for \r\n         the addition of `deposit()` so that this contract can be called from Sink and Source Oracle contracts.\r\n    @author ChainSafe Systems.\r\n */\r\ninterface IBridge {\r\n    /**\r\n        @notice Exposing getter for {_chainID} instead of forcing the use of call.\r\n        @return uint8 The {_chainID} that is currently set for the Bridge contract.\r\n     */\r\n    function _chainID() external returns (uint8);\r\n\r\n    function deposit(\r\n        uint8 destinationChainID,\r\n        bytes32 resourceID,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n\r\n// File contracts/oracle/implementation/Constants.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Stores common interface names used throughout the DVM by registration in the Finder.\r\n */\r\nlibrary OracleInterfaces {\r\n    bytes32 public constant Oracle = \"Oracle\";\r\n    bytes32 public constant IdentifierWhitelist = \"IdentifierWhitelist\";\r\n    bytes32 public constant Store = \"Store\";\r\n    bytes32 public constant FinancialContractsAdmin = \"FinancialContractsAdmin\";\r\n    bytes32 public constant Registry = \"Registry\";\r\n    bytes32 public constant CollateralWhitelist = \"CollateralWhitelist\";\r\n    bytes32 public constant OptimisticOracle = \"OptimisticOracle\";\r\n    bytes32 public constant Bridge = \"Bridge\";\r\n    bytes32 public constant GenericHandler = \"GenericHandler\";\r\n}\r\n\r\n\r\n// File contracts/chainbridge/BeaconOracle.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n/**\r\n * @title Simple implementation of the OracleInterface used to communicate price request data cross-chain between\r\n * EVM networks. Can be extended either into a \"Source\" or \"Sink\" oracle that specializes in making and resolving\r\n * cross-chain price requests, respectivly. The \"Source\" Oracle is the originator or source of price resolution data\r\n * and can only resolve prices already published by the DVM. The \"Sink\" Oracle receives the price resolution data\r\n * from the Source Oracle and makes it available on non-Mainnet chains. The \"Sink\" Oracle can also be used to trigger\r\n * price requests from the DVM on Mainnet.\r\n */\r\nabstract contract BeaconOracle {\r\n    enum RequestState { NeverRequested, PendingRequest, Requested, PendingResolve, Resolved }\r\n\r\n    struct Price {\r\n        RequestState state;\r\n        int256 price;\r\n    }\r\n\r\n    // Chain ID for this Oracle.\r\n    uint8 public currentChainID;\r\n\r\n    // Mapping of encoded price requests {identifier, time, ancillaryData} to Price objects.\r\n    mapping(bytes32 => Price) internal prices;\r\n\r\n    // Finder to provide addresses for DVM system contracts.\r\n    FinderInterface public finder;\r\n\r\n    event PriceRequestAdded(\r\n        address indexed requester,\r\n        uint8 indexed chainID,\r\n        bytes32 indexed identifier,\r\n        uint256 time,\r\n        bytes ancillaryData\r\n    );\r\n    event PushedPrice(\r\n        address indexed pusher,\r\n        uint8 indexed chainID,\r\n        bytes32 indexed identifier,\r\n        uint256 time,\r\n        bytes ancillaryData,\r\n        int256 price\r\n    );\r\n\r\n    /**\r\n     * @notice Constructor.\r\n     * @param _finderAddress finder to use to get addresses of DVM contracts.\r\n     */\r\n    constructor(address _finderAddress, uint8 _chainID) {\r\n        finder = FinderInterface(_finderAddress);\r\n        currentChainID = _chainID;\r\n    }\r\n\r\n    // We assume that there is only one GenericHandler for this network.\r\n    modifier onlyGenericHandlerContract() {\r\n        require(\r\n            msg.sender == finder.getImplementationAddress(OracleInterfaces.GenericHandler),\r\n            \"Caller must be GenericHandler\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Enqueues a request (if a request isn't already present) for the given (identifier, time, ancillary data)\r\n     * pair. Will revert if request has been requested already.\r\n     */\r\n    function _requestPrice(\r\n        uint8 chainID,\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) internal {\r\n        bytes32 priceRequestId = _encodePriceRequest(chainID, identifier, time, ancillaryData);\r\n        Price storage lookup = prices[priceRequestId];\r\n        if (lookup.state == RequestState.NeverRequested) {\r\n            lookup.state = RequestState.PendingRequest;\r\n            emit PriceRequestAdded(msg.sender, chainID, identifier, time, ancillaryData);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Derived contract needs call this method in order to advance state from PendingRequest --> Requested\r\n     * before _publishPrice can be called.\r\n     */\r\n    function _finalizeRequest(\r\n        uint8 chainID,\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) internal {\r\n        bytes32 priceRequestId = _encodePriceRequest(chainID, identifier, time, ancillaryData);\r\n        Price storage lookup = prices[priceRequestId];\r\n        require(lookup.state == RequestState.PendingRequest, \"Price has not been requested\");\r\n        lookup.state = RequestState.Requested;\r\n    }\r\n\r\n    /**\r\n     * @notice Publishes price for a requested query. Will revert if request hasn't been requested yet or has been\r\n     * resolved already.\r\n     */\r\n    function _publishPrice(\r\n        uint8 chainID,\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData,\r\n        int256 price\r\n    ) internal {\r\n        bytes32 priceRequestId = _encodePriceRequest(chainID, identifier, time, ancillaryData);\r\n        Price storage lookup = prices[priceRequestId];\r\n        require(lookup.state == RequestState.Requested, \"Price request is not currently pending\");\r\n        lookup.price = price;\r\n        lookup.state = RequestState.PendingResolve;\r\n        emit PushedPrice(msg.sender, chainID, identifier, time, ancillaryData, lookup.price);\r\n    }\r\n\r\n    function _finalizePublish(\r\n        uint8 chainID,\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) internal {\r\n        bytes32 priceRequestId = _encodePriceRequest(chainID, identifier, time, ancillaryData);\r\n        Price storage lookup = prices[priceRequestId];\r\n        require(lookup.state == RequestState.PendingResolve, \"Price has not been published\");\r\n        lookup.state = RequestState.Resolved;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns Bridge contract on network.\r\n     */\r\n    function _getBridge() internal view returns (IBridge) {\r\n        return IBridge(finder.getImplementationAddress(OracleInterfaces.Bridge));\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the convenient way to store price requests, uniquely identified by {chainID, identifier, time,\r\n     * ancillaryData }.\r\n     */\r\n    function _encodePriceRequest(\r\n        uint8 chainID,\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) internal pure returns (bytes32) {\r\n        return keccak256(abi.encode(chainID, identifier, time, ancillaryData));\r\n    }\r\n}\r\n\r\n\r\n// File contracts/oracle/interfaces/OracleAncillaryInterface.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Financial contract facing Oracle interface.\r\n * @dev Interface used by financial contracts to interact with the Oracle. Voters will use a different interface.\r\n */\r\nabstract contract OracleAncillaryInterface {\r\n    /**\r\n     * @notice Enqueues a request (if a request isn't already present) for the given `identifier`, `time` pair.\r\n     * @dev Time must be in the past and the identifier must be supported.\r\n     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\r\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\r\n     * @param time unix timestamp for the price request.\r\n     */\r\n\r\n    function requestPrice(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) public virtual;\r\n\r\n    /**\r\n     * @notice Whether the price for `identifier` and `time` is available.\r\n     * @dev Time must be in the past and the identifier must be supported.\r\n     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\r\n     * @param time unix timestamp for the price request.\r\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\r\n     * @return bool if the DVM has resolved to a price for the given identifier and timestamp.\r\n     */\r\n    function hasPrice(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) public view virtual returns (bool);\r\n\r\n    /**\r\n     * @notice Gets the price for `identifier` and `time` if it has already been requested and resolved.\r\n     * @dev If the price is not available, the method reverts.\r\n     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\r\n     * @param time unix timestamp for the price request.\r\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\r\n     * @return int256 representing the resolved price for the given identifier and timestamp.\r\n     */\r\n\r\n    function getPrice(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) public view virtual returns (int256);\r\n}\r\n\r\n\r\n// File contracts/chainbridge/SourceOracle.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @title Extension of BeaconOracle that is intended to be deployed on Mainnet to give financial\r\n * contracts on non-Mainnet networks the ability to trigger cross-chain price requests to the Mainnet DVM. This contract\r\n * is responsible for triggering price requests originating from non-Mainnet, and broadcasting resolved price data\r\n * back to those networks. Technically, this contract is more of a Proxy than an Oracle, because it does not implement\r\n * the full Oracle interface including the getPrice and requestPrice methods. It's goal is to shuttle price request\r\n * functionality between L2 and L1.\r\n * @dev The intended client of this contract is some off-chain bot watching for resolved price events on the DVM. Once\r\n * that bot sees a price has resolved, it can call `publishPrice()` on this contract which will call the local Bridge\r\n * contract to signal to an off-chain relayer to bridge a price request to another network.\r\n * @dev This contract must be a registered financial contract in order to call DVM methods.\r\n */\r\ncontract SourceOracle is BeaconOracle {\r\n    constructor(address _finderAddress, uint8 _chainID) BeaconOracle(_finderAddress, _chainID) {}\r\n\r\n    /***************************************************************\r\n     * Publishing Price Request Data to L2:\r\n     ***************************************************************/\r\n\r\n    /**\r\n     * @notice This is the first method that should be called in order to publish a price request to another network\r\n     * marked by `sinkChainID`.\r\n     * @dev Publishes the DVM resolved price for the price request, or reverts if not resolved yet. Will call the\r\n     * local Bridge's deposit() method which will emit a Deposit event in order to signal to an off-chain\r\n     * relayer to begin the cross-chain process.\r\n     */\r\n    function publishPrice(\r\n        uint8 sinkChainID,\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) public {\r\n        require(_getOracle().hasPrice(identifier, time, ancillaryData), \"DVM has not resolved price\");\r\n        int256 price = _getOracle().getPrice(identifier, time, ancillaryData);\r\n        _publishPrice(sinkChainID, identifier, time, ancillaryData, price);\r\n\r\n        // Initiate cross-chain price request, which should lead the `Bridge` to call `validateDeposit` on this\r\n        // contract.\r\n        _getBridge().deposit(\r\n            sinkChainID,\r\n            getResourceId(),\r\n            formatMetadata(sinkChainID, identifier, time, ancillaryData, price)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice This method will ultimately be called after `publishPrice` calls `Bridge.deposit()`, which will call\r\n     * `GenericHandler.deposit()` and ultimately this method.\r\n     * @dev This method should basically check that the `Bridge.deposit()` was triggered by a valid publish event.\r\n     */\r\n    function validateDeposit(\r\n        uint8 sinkChainID,\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData,\r\n        int256 price\r\n    ) public {\r\n        bytes32 priceRequestId = _encodePriceRequest(sinkChainID, identifier, time, ancillaryData);\r\n        Price storage lookup = prices[priceRequestId];\r\n        require(lookup.price == price, \"Unexpected price published\");\r\n        // Advance state so that directly calling Bridge.deposit will revert and not emit a duplicate `Deposit` event.\r\n        _finalizePublish(sinkChainID, identifier, time, ancillaryData);\r\n    }\r\n\r\n    /***************************************************************\r\n     * Responding to a Price Request from L2:\r\n     ***************************************************************/\r\n\r\n    /**\r\n     * @notice This method will ultimately be called after a `requestPrice` has been bridged cross-chain from\r\n     * non-Mainnet to this network via an off-chain relayer. The relayer will call `Bridge.executeProposal` on this\r\n     * local network, which call `GenericHandler.executeProposal()` and ultimately this method.\r\n     * @dev This method should prepare this oracle to receive a published price and then forward the price request\r\n     * to the DVM. Can only be called by the `GenericHandler`.\r\n     */\r\n\r\n    function executeRequestPrice(\r\n        uint8 sinkChainID,\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) public onlyGenericHandlerContract() {\r\n        _requestPrice(sinkChainID, identifier, time, ancillaryData);\r\n        _finalizeRequest(sinkChainID, identifier, time, ancillaryData);\r\n        _getOracle().requestPrice(identifier, time, ancillaryData);\r\n    }\r\n\r\n    /**\r\n     * @notice Convenience method to get cross-chain Bridge resource ID linking this contract with its SinkOracles.\r\n     * @dev More details about Resource ID's here: https://chainbridge.chainsafe.io/spec/#resource-id\r\n     * @return bytes32 Hash containing this stored chain ID.\r\n     */\r\n    function getResourceId() public view returns (bytes32) {\r\n        return keccak256(abi.encode(\"Oracle\", currentChainID));\r\n    }\r\n\r\n    /**\r\n     * @notice Return DVM for this network.\r\n     */\r\n    function _getOracle() internal view returns (OracleAncillaryInterface) {\r\n        return OracleAncillaryInterface(finder.getImplementationAddress(OracleInterfaces.Oracle));\r\n    }\r\n\r\n    /**\r\n     * @notice This helper method is useful for calling Bridge.deposit().\r\n     * @dev GenericHandler.deposit() expects data to be formatted as:\r\n     *     len(data)                              uint256     bytes  0  - 64\r\n     *     data                                   bytes       bytes  64 - END\r\n     */\r\n    function formatMetadata(\r\n        uint8 chainID,\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData,\r\n        int256 price\r\n    ) public pure returns (bytes memory) {\r\n        bytes memory metadata = abi.encode(chainID, identifier, time, ancillaryData, price);\r\n        return abi.encodePacked(metadata.length, metadata);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_finderAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_chainID\",\"type\":\"uint8\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"chainID\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"ancillaryData\",\"type\":\"bytes\"}],\"name\":\"PriceRequestAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pusher\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"chainID\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"ancillaryData\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"price\",\"type\":\"int256\"}],\"name\":\"PushedPrice\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"currentChainID\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"sinkChainID\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"ancillaryData\",\"type\":\"bytes\"}],\"name\":\"executeRequestPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finder\",\"outputs\":[{\"internalType\":\"contract FinderInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"chainID\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"ancillaryData\",\"type\":\"bytes\"},{\"internalType\":\"int256\",\"name\":\"price\",\"type\":\"int256\"}],\"name\":\"formatMetadata\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getResourceId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"sinkChainID\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"ancillaryData\",\"type\":\"bytes\"}],\"name\":\"publishPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"sinkChainID\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"ancillaryData\",\"type\":\"bytes\"},{\"internalType\":\"int256\",\"name\":\"price\",\"type\":\"int256\"}],\"name\":\"validateDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"SourceOracle","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"199","ConstructorArguments":"00000000000000000000000040f941e48a552bf496b154af6bf55725f18d77c30000000000000000000000000000000000000000000000000000000000000001","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":"ipfs://cf7ad428a4432c7e028b929ebc16767b6074bfeb26d9f21b54624b39e3454782"}]}