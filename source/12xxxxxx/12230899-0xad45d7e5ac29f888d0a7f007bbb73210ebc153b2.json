{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/Elena/Source/argent-contracts/contracts/modules/common/IModule.sol\": {\r\n      \"content\": \"// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.3;\\n\\n/**\\n * @title IModule\\n * @notice Interface for a Module.\\n * @author Julien Niset - <julien@argent.xyz>, Olivier VDB - <olivier@argent.xyz>\\n */\\ninterface IModule {\\n\\n    /**\\t\\n     * @notice Adds a module to a wallet. Cannot execute when wallet is locked (or under recovery)\\t\\n     * @param _wallet The target wallet.\\t\\n     * @param _module The modules to authorise.\\t\\n     */\\t\\n    function addModule(address _wallet, address _module) external;\\n\\n    /**\\n     * @notice Inits a Module for a wallet by e.g. setting some wallet specific parameters in storage.\\n     * @param _wallet The wallet.\\n     */\\n    function init(address _wallet) external;\\n\\n\\n    /**\\n     * @notice Returns whether the module implements a callback for a given static call method.\\n     * @param _methodId The method id.\\n     */\\n    function supportsStaticCall(bytes4 _methodId) external view returns (bool _isSupported);\\n}\"\r\n    },\r\n    \"/Users/Elena/Source/argent-contracts/contracts/wallet/BaseWallet.sol\": {\r\n      \"content\": \"// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.3;\\n\\nimport \\\"../modules/common/IModule.sol\\\";\\nimport \\\"./IWallet.sol\\\";\\n\\n/**\\n * @title BaseWallet\\n * @notice Simple modular wallet that authorises modules to call its invoke() method.\\n * @author Julien Niset - <julien@argent.xyz>\\n */\\ncontract BaseWallet is IWallet {\\n\\n    // The owner\\n    address public override owner;\\n    // The authorised modules\\n    mapping (address => bool) public override authorised;\\n    // module executing static calls\\n    address public staticCallExecutor;\\n    // The number of modules\\n    uint public override modules;\\n\\n    event AuthorisedModule(address indexed module, bool value);\\n    event Invoked(address indexed module, address indexed target, uint indexed value, bytes data);\\n    event Received(uint indexed value, address indexed sender, bytes data);\\n    event OwnerChanged(address owner);\\n\\n    /**\\n     * @notice Throws if the sender is not an authorised module.\\n     */\\n    modifier moduleOnly {\\n        require(authorised[msg.sender], \\\"BW: sender not authorized\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Inits the wallet by setting the owner and authorising a list of modules.\\n     * @param _owner The owner.\\n     * @param _modules The modules to authorise.\\n     */\\n    function init(address _owner, address[] calldata _modules) external {\\n        require(owner == address(0) && modules == 0, \\\"BW: wallet already initialised\\\");\\n        require(_modules.length > 0, \\\"BW: empty modules\\\");\\n        owner = _owner;\\n        modules = _modules.length;\\n        for (uint256 i = 0; i < _modules.length; i++) {\\n            require(authorised[_modules[i]] == false, \\\"BW: module is already added\\\");\\n            authorised[_modules[i]] = true;\\n            IModule(_modules[i]).init(address(this));\\n            emit AuthorisedModule(_modules[i], true);\\n        }\\n        if (address(this).balance > 0) {\\n            emit Received(address(this).balance, address(0), \\\"\\\");\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc IWallet\\n     */\\n    function authoriseModule(address _module, bool _value) external override moduleOnly {\\n        if (authorised[_module] != _value) {\\n            emit AuthorisedModule(_module, _value);\\n            if (_value == true) {\\n                modules += 1;\\n                authorised[_module] = true;\\n                IModule(_module).init(address(this));\\n            } else {\\n                modules -= 1;\\n                require(modules > 0, \\\"BW: cannot remove last module\\\");\\n                delete authorised[_module];\\n            }\\n        }\\n    }\\n\\n    /**\\n    * @inheritdoc IWallet\\n    */\\n    function enabled(bytes4 _sig) public view override returns (address) {\\n        address executor = staticCallExecutor;\\n        if(executor != address(0) && IModule(executor).supportsStaticCall(_sig)) {\\n            return executor;\\n        }\\n        return address(0);\\n    }\\n\\n    /**\\n    * @inheritdoc IWallet\\n    */\\n    function enableStaticCall(address _module, bytes4 /* _method */) external override moduleOnly {\\n        if(staticCallExecutor != _module) {\\n            require(authorised[_module], \\\"BW: unauthorized executor\\\");\\n            staticCallExecutor = _module;\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc IWallet\\n     */\\n    function setOwner(address _newOwner) external override moduleOnly {\\n        require(_newOwner != address(0), \\\"BW: address cannot be null\\\");\\n        owner = _newOwner;\\n        emit OwnerChanged(_newOwner);\\n    }\\n\\n    /**\\n     * @notice Performs a generic transaction.\\n     * @param _target The address for the transaction.\\n     * @param _value The value of the transaction.\\n     * @param _data The data of the transaction.\\n     */\\n    function invoke(address _target, uint _value, bytes calldata _data) external moduleOnly returns (bytes memory _result) {\\n        bool success;\\n        (success, _result) = _target.call{value: _value}(_data);\\n        if (!success) {\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n        emit Invoked(msg.sender, _target, _value, _data);\\n    }\\n\\n    /**\\n     * @notice This method delegates the static call to a target contract if the data corresponds\\n     * to an enabled module, or logs the call otherwise.\\n     */\\n    fallback() external payable {\\n        address module = enabled(msg.sig);\\n        if (module == address(0)) {\\n            emit Received(msg.value, msg.sender, msg.data);\\n        } else {\\n            require(authorised[module], \\\"BW: unauthorised module\\\");\\n\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                calldatacopy(0, 0, calldatasize())\\n                let result := staticcall(gas(), module, 0, calldatasize(), 0, 0)\\n                returndatacopy(0, 0, returndatasize())\\n                switch result\\n                case 0 {revert(0, returndatasize())}\\n                default {return (0, returndatasize())}\\n            }\\n        }\\n    }\\n\\n    receive() external payable {\\n    }\\n}\"\r\n    },\r\n    \"/Users/Elena/Source/argent-contracts/contracts/wallet/IWallet.sol\": {\r\n      \"content\": \"// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity >=0.5.4 <0.9.0;\\n\\n/**\\n * @title IWallet\\n * @notice Interface for the BaseWallet\\n */\\ninterface IWallet {\\n    /**\\n     * @notice Returns the wallet owner.\\n     * @return The wallet owner address.\\n     */\\n    function owner() external view returns (address);\\n\\n    /**\\n     * @notice Returns the number of authorised modules.\\n     * @return The number of authorised modules.\\n     */\\n    function modules() external view returns (uint);\\n\\n    /**\\n     * @notice Sets a new owner for the wallet.\\n     * @param _newOwner The new owner.\\n     */\\n    function setOwner(address _newOwner) external;\\n\\n    /**\\n     * @notice Checks if a module is authorised on the wallet.\\n     * @param _module The module address to check.\\n     * @return `true` if the module is authorised, otherwise `false`.\\n     */\\n    function authorised(address _module) external view returns (bool);\\n\\n    /**\\n     * @notice Returns the module responsible for a static call redirection.\\n     * @param _sig The signature of the static call.\\n     * @return the module doing the redirection\\n     */\\n    function enabled(bytes4 _sig) external view returns (address);\\n\\n    /**\\n     * @notice Enables/Disables a module.\\n     * @param _module The target module.\\n     * @param _value Set to `true` to authorise the module.\\n     */\\n    function authoriseModule(address _module, bool _value) external;\\n\\n    /**\\n    * @notice Enables a static method by specifying the target module to which the call must be delegated.\\n    * @param _module The target module.\\n    * @param _method The static method signature.\\n    */\\n    function enableStaticCall(address _module, bytes4 _method) external;\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {\r\n      \"\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"AuthorisedModule\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Invoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Received\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_module\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"authoriseModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorised\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_module\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"name\":\"enableStaticCall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_sig\",\"type\":\"bytes4\"}],\"name\":\"enabled\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_modules\",\"type\":\"address[]\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"invoke\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"_result\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"modules\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"staticCallExecutor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"BaseWallet","CompilerVersion":"v0.8.3+commit.8d00100c","OptimizationUsed":"1","Runs":"999","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}