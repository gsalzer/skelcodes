{"status":"1","message":"OK","result":[{"SourceCode":"{\"liqnetCoin.sol\":{\"content\":\"pragma solidity ^0.4.26;\\n\\n/// import base  contracts, interfaces, libraries from latest gitHUB\\n\\n/**\\n * @title ERC20Basic\\n * @dev Simpler version of ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/179\\n */\\ncontract ERC20Basic {\\n  uint256 public totalSupply;\\n  function balanceOf(address who) public constant returns (uint256);\\n  function transfer(address to, uint256 value) public returns (bool);\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n}\\n \\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ncontract ERC20 is ERC20Basic {\\n  function allowance(address owner, address spender) public constant returns (uint256);\\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\\n  function approve(address spender, uint256 value) public returns (bool);\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n \\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error\\n */\\nlibrary SafeMath {\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a * b;\\n    assert(a == 0 || c / a == b);\\n    return c;\\n  }\\n \\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // assert(b \\u003e 0); // Solidity automatically throws when dividing by 0\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n    return c;\\n  }\\n \\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    assert(b \\u003c= a); \\n    return a - b; \\n  } \\n  \\n  function add(uint256 a, uint256 b) internal pure returns (uint256) { \\n    uint256 c = a + b; assert(c \\u003e= a);\\n    return c;\\n  }\\n \\n}\\n\\n/**\\n * @title ERC223 interface\\n * @dev interface ERC223 for emit tokenFallback event\\n */\\n \\ncontract TokenReceiver {\\n  function tokenFallback(address _sender, address _origin, uint _value) public returns (bool ok);\\n}\\n\\n/**\\n * @title Basic token\\n * @dev Basic version of StandardToken, with no allowances.\\n * @dev Addedd ERC223 send tokens to another contract Implementation\\n */\\n \\ncontract BasicToken is ERC20Basic {\\n  using SafeMath for uint256;\\n \\n  mapping(address =\\u003e uint256) balances;\\n  \\n  modifier onlyPayloadSize(uint size) {\\n      require(!(msg.data.length \\u003c size + 4));\\n      _;\\n  }\\n \\n  /**\\n  * @dev transfer token for a specified address\\n  * @param _to The address to transfer to.\\n  * @param _value The amount to be transferred.\\n  */\\n  function transfer(address _to, uint256 _value) public onlyPayloadSize(2*32) returns (bool) {\\n    bool result = _transfer(msg.sender, _to, _value);\\n    if (result \\u0026\\u0026 isContract(_to)) {\\n        result = _transferToContract(msg.sender, _to, _value);\\n    }\\n    return result;\\n  }\\n  \\n  function _transfer(address _from, address _to, uint256 _value) internal returns (bool) {\\n    require(_to != address(0));\\n    require(_value \\u003e 0);\\n    require(_value \\u003c= balances[_from]); \\n    // SafeMath.sub will throw if there is not enough balance. \\n    balances[_from] = balances[_from].sub(_value); \\n    balances[_to] = balances[_to].add(_value); \\n    emit Transfer(_from, _to, _value); \\n    return true; \\n  }\\n  \\n  //assemble the given address bytecode. If bytecode exists then the _addr is a contract.\\n  function isContract(address _addr) internal constant returns (bool is_contract) {\\n    uint length;\\n    assembly {\\n        //retrieve the size of the code on target address, this needs assembly\\n        length := extcodesize(_addr)\\n    }\\n    return (length \\u003e 0);\\n  }\\n  \\n  /**\\n    * @dev Function that is called when a user or another contract wants\\n    *  to transfer funds to smart-contract\\n    * @return A boolean that indicates if the operation was successful\\n    */\\n    function _transferToContract(address _from, address _to, uint _value) internal returns (bool success) {\\n        TokenReceiver receiver = TokenReceiver(_to);\\n        return receiver.tokenFallback(_from, this, _value);\\n    }\\n \\n  /** \\n   * @dev Gets the balance of the specified address. \\n   * @param _owner The address to query the the balance of. \\n   * @return An uint256 representing the amount owned by the passed address. \\n   */ \\n  function balanceOf(address _owner) public constant returns (uint256 balance) { \\n    return balances[_owner]; \\n  } \\n}\\n\\n/** \\n * @title Standard ERC20 token \\n * \\n * @dev Implementation of the basic standard token. \\n * @dev https://github.com/ethereum/EIPs/issues/20 \\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol \\n */ \\ncontract StandardToken is ERC20, BasicToken {\\n \\n  mapping (address =\\u003e mapping (address =\\u003e uint256)) internal allowed;\\n \\n  /**\\n   * @dev Transfer tokens from one address to another\\n   * @param _from address The address which you want to send tokens from\\n   * @param _to address The address which you want to transfer to\\n   * @param _value uint256 the amount of tokens to be transferred\\n   */\\n  function transferFrom(address _from, address _to, uint256 _value) public onlyPayloadSize(3*32) returns (bool) {\\n    require(_value \\u003c= allowed[_from][msg.sender]);\\n    bool result = _transfer(_from, _to, _value);\\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\\n    if (result \\u0026\\u0026 isContract(_to)) {\\n        result = _transferToContract(_from, _to, _value);\\n    }\\n    return result; \\n  } \\n \\n /** \\n  * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. \\n  * \\n  * Beware that changing an allowance with this method brings the risk that someone may use both the old \\n  * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this \\n  * race condition is to first reduce the spender\\u0027s allowance to 0 and set the desired value afterwards: \\n  * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \\n  * @param _spender The address which will spend the funds. \\n  * @param _value The amount of tokens to be spent. \\n  */ \\n  function approve(address _spender, uint256 _value) public onlyPayloadSize(2*32) returns (bool) { \\n    allowed[msg.sender][_spender] = _value; \\n    emit Approval(msg.sender, _spender, _value); \\n    return true; \\n  }\\n \\n /** \\n  * @dev Function to check the amount of tokens that an owner allowed to a spender. \\n  * @param _owner address The address which owns the funds. \\n  * @param _spender address The address which will spend the funds. \\n  * @return A uint256 specifying the amount of tokens still available for the spender. \\n  */ \\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { \\n    return allowed[_owner][_spender]; \\n  } \\n \\n /** \\n  * approve should be called when allowed[_spender] == 0. To increment \\n  * allowed value is better to use this function to avoid 2 calls (and wait until \\n  * the first transaction is mined) * From MonolithDAO Token.sol \\n  */ \\n  function increaseApproval (address _spender, uint _addedValue) public onlyPayloadSize(2*32) returns (bool success) {\\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); \\n    return true; \\n  }\\n \\n  function decreaseApproval (address _spender, uint _subtractedValue) public onlyPayloadSize(2*32) returns (bool success) {\\n    uint oldValue = allowed[msg.sender][_spender]; \\n    if (_subtractedValue \\u003e oldValue) {\\n      allowed[msg.sender][_spender] = 0;\\n    } else {\\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\\n    }\\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\n    return true;\\n  }\\n \\n  /*this function is commented for payload to commissions ability. see ERC223Receiver contract\\n  function () public payable {\\n    revert();\\n  }*/\\n \\n}\\n\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Ownable {\\n  address public owner;\\n \\n \\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n \\n \\n  /**\\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n   * account.\\n   */\\n  constructor () public {\\n    owner = msg.sender;\\n  }\\n \\n \\n  /**\\n   * @dev Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    require(msg.sender == owner);\\n    _;\\n  }\\n \\n \\n  /**\\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n   * @param newOwner The address to transfer ownership to.\\n   */\\n  function transferOwnership(address newOwner) onlyOwner public {\\n    require(newOwner != address(0));\\n    emit OwnershipTransferred(owner, newOwner);\\n    owner = newOwner;\\n  }\\n \\n}\\n\\n/**\\n * @title ERC223 receiver\\n * @dev - basic implementation that sent all tokens to special address, by default to owner.\\n */\\ncontract ERC223Receiver is TokenReceiver, Ownable {\\n    address tokenHolder;\\n    event getTokens(address indexed _from, address indexed _origin, uint _value);\\n    \\n    constructor () public {\\n        tokenHolder = msg.sender;\\n    }\\n    \\n    /**\\n     * @dev - set new address to sent all incoming tokens.\\n     * @param _newTokenHolder address to sent all incoming tokens.\\n     */\\n    function setTokenHolder(address _newTokenHolder) public onlyOwner {\\n        tokenHolder = _newTokenHolder;\\n    }\\n    \\n    /**\\n     * @dev - ERC223 special callback function. callable from another contract.\\n     * @param _sender address that sent tokens\\n     * @param _origin ERC223 contract address\\n     * @param _value amount of transferred tokens.\\n     */\\n    function tokenFallback(address _sender, address _origin, uint _value) public returns (bool ok) {\\n        // in contract._origin was transfer(_sender, this, _value);\\n        // to send all we can\\n        // 1. create contract._origin\\n        // 2. transfer from this to special address _value tokens.\\n        // 3. do something changes in this contract? mint some tokens?\\n        ERC20Basic erc223 = ERC20Basic(_origin);\\n        bool result = erc223.transfer(tokenHolder, _value);\\n        emit getTokens(_sender, _origin, _value);\\n        return result;\\n    }\\n    \\n    /**\\n     * @dev noERC223 special function for transfer erc20 basable tokens from this contract to tokenHolder(by default owner) special address.\\n     * @param _contract address of contract to check for balance \\u0026 transfer tokens to tokenHolder.\\n     * @return true if balance greter than 0 \\u0026 transfer is ok.\\n     */\\n    function collectTokens(address _contract) public returns (bool ok) {\\n        ERC20Basic erc20 = ERC20Basic(_contract);\\n        uint256 balance = erc20.balanceOf(this);\\n        ok = false;\\n        if (balance \\u003e 0) {\\n            ok = erc20.transfer(tokenHolder, balance);\\n            emit getTokens(msg.sender, _contract, balance);\\n        }\\n        return ok;\\n    }\\n    \\n    /**\\n     * @dev function to send all ethers from contract to owner\\n     */\\n    function collectEther() public onlyOwner payable {\\n        owner.transfer(address(this).balance);\\n    }\\n    \\n    function () external payable {\\n    }\\n}\\n\\n/**\\n * @title - Liqnet Extension Token\\n * @dev - LIQNET Extension for Mintable \\u0026 Burnable for maxMintableSupply\\n */\\ncontract LiqnetExtToken is ERC223Receiver {\\n    \\n    using SafeMath for uint256;\\n    \\n    uint public maxMintSupply;\\n    uint public totalMinted = 0;\\n    \\n    modifier canMint(uint value) {\\n        require((totalMinted.add(value)) \\u003c= maxMintSupply);\\n        _;\\n    }\\n    \\n    function isMintFinished() internal view returns (bool isFinished) {\\n        return (totalMinted \\u003e= maxMintSupply);\\n    }\\n}\\n\\n\\n \\n/**\\n * @title Mintable token\\n * @dev Simple ERC20 Token example, with mintable token creation\\n * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120\\n * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\\n */\\n \\ncontract MintableToken is StandardToken, Ownable, LiqnetExtToken {\\n    \\n  event Mint(address indexed to, uint256 amount);\\n  \\n  event MintFinished();\\n \\n  bool public mintingFinished = false;\\n \\n  address public saleAgent;\\n  \\n  constructor () public {\\n      saleAgent = msg.sender;\\n  }\\n  \\n  /**\\n   * @dev Allows the current owner to approve control of the minting to additional address.\\n   * @param newSaleAgent The address to approve minting control.\\n   */\\n  function setSaleAgent(address newSaleAgent) public {\\n    require(msg.sender == saleAgent || msg.sender == owner);\\n    saleAgent = newSaleAgent;\\n  }\\n  \\n  /**\\n   * @dev Allows the current owner or saleAgent mint some coins to address.\\n   * @param _to The address for new coins.\\n   * @param _amount amount of coin to mint.\\n   * @return true if mint is successful.\\n   */\\n  function mint(address _to, uint256 _amount) public canMint(_amount) returns (bool) {\\n    require((msg.sender == saleAgent || msg.sender == owner) \\u0026\\u0026 !mintingFinished);\\n    totalSupply = totalSupply.add(_amount);\\n    totalMinted = totalMinted.add(_amount); //**************************LiqnetExtToken\\n    balances[_to] = balances[_to].add(_amount);\\n    emit Mint(_to, _amount);\\n    if (isMintFinished()) { finishMinting(); } //***********LiqnetExtToken\\n    return true;\\n  }\\n \\n  /**\\n   * @dev Function to stop minting new tokens.\\n   * @return True if the operation was successful.\\n   */\\n  function finishMinting() public returns (bool) {\\n    require((msg.sender == saleAgent || msg.sender == owner) \\u0026\\u0026 !mintingFinished);\\n    mintingFinished = true;\\n    emit MintFinished();\\n    return true;\\n  }\\n}\\n\\n/**\\n * @title Burnable tokens\\n * @dev functions for burn previosly minted tokens\\n */\\ncontract BurnableToken is StandardToken, Ownable, LiqnetExtToken {\\n    \\n    uint public totalBurned = 0;\\n    \\n    /**\\n   * @dev Allows the current owner of coins burn it.\\n   * @param value - amount of coins to burn.\\n   */\\n    function burn(uint value) public onlyPayloadSize(32) {\\n        require(value\\u003e0 \\u0026\\u0026 balances[msg.sender] \\u003e= value);\\n        balances[msg.sender] = balances[msg.sender].sub(value);\\n        totalSupply = totalSupply.sub(value);\\n        totalBurned = totalBurned.add(value);\\n        emit Burn(msg.sender, value);\\n    }\\n    \\n    /**\\n   * @dev Allows the spender (approve function) to burn some coins from another address.\\n   * @param from - address for burn coins.\\n   * @param value - amount of coins to burn.\\n   */\\n    function burnFrom(address from, uint value) public onlyPayloadSize(2*32)  {\\n        require(value \\u003e 0 \\u0026\\u0026 value \\u003c= balances[from] \\u0026\\u0026 value \\u003c= allowed[from][msg.sender]);\\n        balances[from] = balances[from].sub(value);\\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(value);\\n        totalSupply = totalSupply.sub(value);\\n        totalBurned = totalBurned.add(value);\\n        emit Burn(from, value);\\n    }\\n    \\n    event Burn(address indexed burner, uint indexed value);\\n}\\n\\n\\n/**\\n * @title - LIQNET Liqidity Exchange Network tokens\\n * @dev mint will be executed from Crowdsale contract\\n */\\ncontract LiqnetCoin is MintableToken, BurnableToken {\\n    \\n    string public constant name = \\\"Liqnet Coin\\\";\\n    \\n    string public constant symbol = \\\"LEN\\\";\\n    \\n    uint32 public constant decimals = 18;\\n    \\n    constructor() public {\\n        maxMintSupply = 3500000 * (1 ether);\\n    }\\n    \\n}\"},\"liqnetCrowdsale.sol\":{\"content\":\"pragma solidity ^0.4.26;\\n\\nimport \\\"./liqnetCoin.sol\\\";\\n\\n/**\\n * @title exchangeRate\\n * @dev base for crowdsale to apply rate changing\\n */\\ncontract exchangeRate is Ownable {\\n    \\n    using SafeMath for uint256;\\n\\n    address public trader;\\n    uint public rate;\\n    //decimal by default = 18 or 1 ether\\n    \\n    event rateChanged(uint newRate, uint time);\\n    \\n    modifier isTrader() {\\n       require(msg.sender == owner || msg.sender == trader);\\n       _;\\n    }\\n    \\n    /**\\n    * @dev set new Trader address\\n    * @param newAddr - new trader address.\\n    */\\n    function setTrader(address newAddr) public isTrader {\\n        trader = newAddr;\\n    }\\n    \\n    /**\\n     * @dev set new rate in ether format\\n     * @param newRate - new exchange rate of ETH to Coin. for 2510.69 is 2510690000000000000000\\n     */\\n    function setRate(uint newRate) public isTrader {\\n        rate = newRate;\\n        emit rateChanged(newRate, now);\\n    }\\n    \\n    /**\\n     * @dev set only integer part of rate.\\n     * @param newRate - only interger for 2510.69 is 2511\\n     */\\n    function setRateInt(uint newRate) public isTrader {\\n        rate = newRate.mul(1 ether);\\n    }\\n    \\n    /**\\n     * @dev set new rate with 2 decimals.\\n     * @param newRate - new rate. for 2510.6912 is 251069\\n     */\\n    function setRate2Decimals(uint newRate) public isTrader {\\n        rate = newRate.mul(1 ether).div(100);\\n    }\\n    \\n    /**\\n     * @dev convert ETH to Coins\\n     * @param value - amount of ETH\\n     * @return amount of Coins\\n     */\\n    function convert(uint value) public constant returns (uint usd) {\\n        return rate.mul(value).div(1 ether);\\n    }\\n}\\n\\ncontract crowdsaleBase is ERC223Receiver, exchangeRate {\\n    \\n    using SafeMath for uint256;\\n    \\n    address multisig;\\n    \\n    uint public hardcap;\\n    uint public currentETH = 0;\\n    uint public currentLEN = 0;\\n    \\n    uint start = 1623024000;//07 jun 2012\\n    \\n    uint period = 90;\\n    \\n    modifier salesIsOn() {\\n        require(now \\u003e start \\u0026\\u0026 now \\u003c start + period * 1 days);\\n        _;\\n    }\\n    \\n    modifier isUnderHardcap() {\\n        require(currentLEN \\u003c hardcap);\\n        _;\\n    }\\n    \\n    /**\\n     * @dev calculation of bonus tokens\\n     * @param tokens - base amount of tokens\\n     * @return amount of bonus Tokens\\n     */\\n    function calcBonusTokens(uint tokens) internal constant returns (uint bonusTokens) {\\n        bonusTokens = 0;\\n        /*if (now \\u003c start + (24 hours)) {\\n            bonusTokens = tokens.div(5);\\n        } else */\\n        if (now \\u003c start + (30 days)) {\\n            bonusTokens = tokens.div(100).mul(15);\\n        } else if (now \\u003c start + (60 days)) {\\n            bonusTokens = tokens.div(1000).mul(75);\\n        }\\n        return bonusTokens;\\n    }\\n    \\n    /**\\n     * @dev calculation oftokens\\n     */\\n    function createTokensBase(uint _amount) internal isUnderHardcap salesIsOn returns (uint tokens) {\\n        tokens = convert(_amount);\\n        tokens = tokens.add(calcBonusTokens(tokens));\\n        \\n        currentLEN = currentLEN.add(tokens);\\n        currentETH = currentETH.add(_amount);\\n        \\n        return tokens;\\n    }\\n}\\n\\n/**\\n * @title Crowdsale LEN tokens. This contract is saleAgent for LEN_ERC20 compatible.\\n */\\ncontract LiqnetCrowdsale is crowdsaleBase {\\n    \\n    using SafeMath for uint256;\\n    \\n    LiqnetCoin token = LiqnetCoin(0xf569E6bDfAC9ca4AD2814C7Af393B27B4A03bE0B);// paste real address \\u0026 setSaleAgent for iteraction.\\n    \\n    constructor () public {\\n        hardcap = 3500000 * (1 ether);\\n        rate = 2241060000000000000000;//2241.06\\n        multisig = 0x806b5968FD6E67caC021f6354443434d99AEcA20;//address to transfer all income Ethers\\n        start = 1623628800;//test //1624320000;//22 jun 2021\\n        period = 90;\\n    }\\n    \\n    function createTokens() public isUnderHardcap salesIsOn payable {\\n        uint tokens = createTokensBase(msg.value);\\n        multisig.transfer(msg.value);//comment this to hold eth in contract address.\\n        \\n        //Mintable\\n        token.mint(msg.sender, tokens);//send tokens to investor. 1eth=1token\\n    }\\n    \\n    function() external payable {\\n        createTokens();\\n    }\\n}\"}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"trader\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newRate\",\"type\":\"uint256\"}],\"name\":\"setRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"collectTokens\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newRate\",\"type\":\"uint256\"}],\"name\":\"setRateInt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newRate\",\"type\":\"uint256\"}],\"name\":\"setRate2Decimals\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"convert\",\"outputs\":[{\"name\":\"usd\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAddr\",\"type\":\"address\"}],\"name\":\"setTrader\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardcap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"createTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_origin\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"tokenFallback\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentLEN\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newTokenHolder\",\"type\":\"address\"}],\"name\":\"setTokenHolder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"collectEther\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"rateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_origin\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"getTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"LiqnetCrowdsale","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://bc6efe4cb76f266a870c7ef5dc066d24315bd376709c1c0b908d85314172a400"}]}