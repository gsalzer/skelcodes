{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/PoolFactory.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is disstributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.7.6;\\n\\n// Builds new Pools, logging their addresses and providing `isPool(address) -> (bool)`\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./IPoolBuilder.sol\\\";\\nimport \\\"./IPool.sol\\\";\\nimport \\\"./Color.sol\\\";\\nimport \\\"./IPausablePool.sol\\\";\\nimport \\\"./libs/complifi/registries/IAddressRegistry.sol\\\";\\n\\ncontract PoolFactory is Bronze, Ownable {\\n    event LOG_NEW_POOL(\\n        address indexed caller,\\n        address indexed pool\\n    );\\n\\n    event LOG_BLABS(\\n        address indexed caller,\\n        address indexed blabs\\n    );\\n\\n    address[] internal _pools;\\n    mapping(address=>bool) private _isPool;\\n\\n    IPoolBuilder public _poolBuilder;\\n    address public _dynamicFee;\\n\\n    IAddressRegistry public _repricerRegistry;\\n\\n    constructor(\\n        address poolBuilder,\\n        address dynamicFee,\\n        address repricerRegistry\\n    ) public {\\n        setPoolBuilder(poolBuilder);\\n        setDynamicFee(dynamicFee);\\n        setRepricerRegistry(repricerRegistry);\\n    }\\n\\n    function isPool(address b)\\n    external view returns (bool)\\n    {\\n        return _isPool[b];\\n    }\\n\\n    function newPool(\\n        address derivativeVault,\\n        bytes32 repricerSymbol,\\n        uint baseFee,\\n        uint maxFee,\\n        uint feeAmp\\n    )\\n    external\\n    returns (IPool)\\n    {\\n        address bpool = _poolBuilder.buildPool(\\n            msg.sender,\\n            derivativeVault,\\n            _dynamicFee,\\n            _repricerRegistry.get(repricerSymbol),\\n            baseFee,\\n            maxFee,\\n            feeAmp\\n        );\\n        _pools.push(bpool);\\n        _isPool[bpool] = true;\\n        emit LOG_NEW_POOL(msg.sender, bpool);\\n        return IPool(bpool);\\n    }\\n\\n    function setPoolBuilder(address poolBuilder) public onlyOwner {\\n        require(poolBuilder != address(0), \\\"Pool builder\\\");\\n        _poolBuilder = IPoolBuilder(poolBuilder);\\n    }\\n\\n    function setDynamicFee(address dynamicFee) public onlyOwner {\\n        require(dynamicFee != address(0), \\\"DynamicFee\\\");\\n        _dynamicFee = dynamicFee;\\n    }\\n\\n    function setRepricerRegistry(address repricerRegistry) public onlyOwner {\\n        require(repricerRegistry != address(0), \\\"Repricer registry\\\");\\n        _repricerRegistry = IAddressRegistry(repricerRegistry);\\n    }\\n\\n    function setRepricer(address _value) external {\\n        _repricerRegistry.set(_value);\\n    }\\n\\n    function pausePool(address _pool) public onlyOwner {\\n        IPausablePool(_pool).pause();\\n    }\\n\\n    function unpausePool(address _pool) public onlyOwner {\\n        IPausablePool(_pool).unpause();\\n    }\\n\\n    function collect(IPool pool)\\n        external onlyOwner\\n    {\\n        uint collected = IERC20(pool).balanceOf(address(this));\\n        bool xfer = pool.transfer(owner(), collected);\\n        require(xfer, \\\"ERC20_FAILED\\\");\\n    }\\n\\n    function getPool(uint _index) external view returns(address) {\\n        return _pools[_index];\\n    }\\n\\n    function getLastPoolIndex() external view returns(uint) {\\n        return _pools.length - 1;\\n    }\\n\\n    function getAllPools() external view returns(address[] memory) {\\n        return _pools;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/IPoolBuilder.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: GNU General Public License v3.0\\\"\\n\\npragma solidity 0.7.6;\\n\\ninterface IPoolBuilder {\\n    function buildPool(\\n        address _controller,\\n        address _derivativeVault,\\n        address _feeCalculator,\\n        address _repricer,\\n        uint _baseFee,\\n        uint _maxFee,\\n        uint _feeAmp\\n    ) external returns(address);\\n}\\n\"\r\n    },\r\n    \"contracts/IPool.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"./Token.sol\\\";\\nimport \\\"./IVault.sol\\\";\\n\\ninterface IPool is IERC20 {\\n\\n    function repricingBlock() external view returns(uint);\\n\\n    function baseFee() external view returns(uint);\\n    function feeAmp() external view returns(uint);\\n    function maxFee() external view returns(uint);\\n\\n    function pMin() external view returns(uint);\\n    function qMin() external view returns(uint);\\n    function exposureLimit() external view returns(uint);\\n    function volatility() external view returns(uint);\\n\\n    function derivativeVault() external view returns(IVault);\\n    function dynamicFee() external view returns(address);\\n    function repricer() external view returns(address);\\n\\n    function isFinalized()\\n    external view\\n    returns (bool);\\n\\n    function getNumTokens()\\n    external view\\n    returns (uint);\\n\\n    function getTokens()\\n    external view\\n    returns (address[] memory tokens);\\n\\n    function getLeverage(address token)\\n    external view\\n    returns (uint);\\n\\n    function getBalance(address token)\\n    external view\\n    returns (uint);\\n\\n    function getController()\\n    external view\\n    returns (address);\\n\\n    function setController(address manager)\\n    external;\\n\\n\\n    function joinPool(uint poolAmountOut, uint[2] calldata maxAmountsIn)\\n    external;\\n\\n    function exitPool(uint poolAmountIn, uint[2] calldata minAmountsOut)\\n    external;\\n\\n    function swapExactAmountIn(\\n        address tokenIn,\\n        uint tokenAmountIn,\\n        address tokenOut,\\n        uint minAmountOut\\n    )\\n    external\\n    returns (uint tokenAmountOut, uint spotPriceAfter);\\n}\\n\"\r\n    },\r\n    \"contracts/Color.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.7.6;\\n\\nabstract contract Color {\\n    function getColor()\\n        external view virtual\\n        returns (bytes32);\\n}\\n\\ncontract Bronze is Color {\\n    function getColor()\\n        external view override\\n        returns (bytes32) {\\n            return bytes32(\\\"BRONZE\\\");\\n        }\\n}\\n\"\r\n    },\r\n    \"contracts/IPausablePool.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\npragma solidity 0.7.6;\\n\\ninterface IPausablePool {\\n    function pause() external;\\n    function unpause() external;\\n}\\n\"\r\n    },\r\n    \"contracts/libs/complifi/registries/IAddressRegistry.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: GPL-3.0-or-later\\\"\\n\\npragma solidity 0.7.6;\\n\\ninterface IAddressRegistry {\\n    function get(bytes32 _key) external view returns (address);\\n\\n    function set(address _value) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Token.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"./Num.sol\\\";\\n\\n// Highly opinionated token implementation\\n\\ninterface IERC20 {\\n\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address whom) external view returns (uint);\\n    function allowance(address src, address dst) external view returns (uint);\\n\\n    function approve(address dst, uint amt) external returns (bool);\\n    function transfer(address dst, uint amt) external returns (bool);\\n    function transferFrom(\\n        address src, address dst, uint amt\\n    ) external returns (bool);\\n}\\n\\ncontract TokenBase is Num {\\n\\n    mapping(address => uint)                   internal _balance;\\n    mapping(address => mapping(address=>uint)) internal _allowance;\\n    uint internal _totalSupply;\\n\\n    event Approval(address indexed src, address indexed dst, uint amt);\\n    event Transfer(address indexed src, address indexed dst, uint amt);\\n\\n    function _mint(uint amt) internal {\\n        _balance[address(this)] = add(_balance[address(this)], amt);\\n        _totalSupply = add(_totalSupply, amt);\\n        emit Transfer(address(0), address(this), amt);\\n    }\\n\\n    function _burn(uint amt) internal {\\n        require(_balance[address(this)] >= amt, \\\"INSUFFICIENT_BAL\\\");\\n        _balance[address(this)] = sub(_balance[address(this)], amt);\\n        _totalSupply = sub(_totalSupply, amt);\\n        emit Transfer(address(this), address(0), amt);\\n    }\\n\\n    function _move(address src, address dst, uint amt) internal {\\n        require(_balance[src] >= amt, \\\"INSUFFICIENT_BAL\\\");\\n        _balance[src] = sub(_balance[src], amt);\\n        _balance[dst] = add(_balance[dst], amt);\\n        emit Transfer(src, dst, amt);\\n    }\\n\\n    function _push(address to, uint amt) internal {\\n        _move(address(this), to, amt);\\n    }\\n\\n    function _pull(address from, uint amt) internal {\\n        _move(from, address(this), amt);\\n    }\\n}\\n\\ncontract Token is TokenBase, IERC20 {\\n\\n    string  private _name;\\n    string  private _symbol;\\n    uint8   private constant _decimals = 18;\\n\\n    function setName(string memory name) internal {\\n        _name = name;\\n    }\\n\\n    function setSymbol(string memory symbol) internal {\\n        _symbol = symbol;\\n    }\\n\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view returns(uint8) {\\n        return _decimals;\\n    }\\n\\n    function allowance(address src, address dst) external view override returns (uint) {\\n        return _allowance[src][dst];\\n    }\\n\\n    function balanceOf(address whom) external view override returns (uint) {\\n        return _balance[whom];\\n    }\\n\\n    function totalSupply() public view override returns (uint) {\\n        return _totalSupply;\\n    }\\n\\n    function approve(address dst, uint amt) external override returns (bool) {\\n        _allowance[msg.sender][dst] = amt;\\n        emit Approval(msg.sender, dst, amt);\\n        return true;\\n    }\\n\\n    function increaseApproval(address dst, uint amt) external returns (bool) {\\n        _allowance[msg.sender][dst] = add(_allowance[msg.sender][dst], amt);\\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\\n        return true;\\n    }\\n\\n    function decreaseApproval(address dst, uint amt) external returns (bool) {\\n        uint oldValue = _allowance[msg.sender][dst];\\n        if (amt > oldValue) {\\n            _allowance[msg.sender][dst] = 0;\\n        } else {\\n            _allowance[msg.sender][dst] = sub(oldValue, amt);\\n        }\\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\\n        return true;\\n    }\\n\\n    function transfer(address dst, uint amt) external override returns (bool) {\\n        _move(msg.sender, dst, amt);\\n        return true;\\n    }\\n\\n    function transferFrom(address src, address dst, uint amt) external override returns (bool) {\\n        uint oldValue = _allowance[src][msg.sender];\\n        require(msg.sender == src || amt <= oldValue, \\\"TOKEN_BAD_CALLER\\\");\\n        _move(src, dst, amt);\\n        if (msg.sender != src && oldValue != uint256(-1)) {\\n            _allowance[src][msg.sender] = sub(oldValue, amt);\\n            emit Approval(msg.sender, dst, _allowance[src][msg.sender]);\\n        }\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/IVault.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"./Token.sol\\\";\\nimport \\\"./libs/complifi/IDerivativeSpecification.sol\\\";\\n\\ninterface IVault {\\n    /// @notice vault initialization time\\n    function initializationTime() external view returns(uint256);\\n    /// @notice start of live period\\n    function liveTime() external view returns(uint256);\\n    /// @notice end of live period\\n    function settleTime() external view returns(uint256);\\n\\n    /// @notice underlying value at the start of live period\\n    function underlyingStarts(uint index) external view returns(int256);\\n    /// @notice underlying value at the end of live period\\n    function underlyingEnds(uint index) external view returns(int256);\\n\\n    /// @notice primary token conversion rate multiplied by 10 ^ 12\\n    function primaryConversion() external view returns(uint256);\\n    /// @notice complement token conversion rate multiplied by 10 ^ 12\\n    function complementConversion() external view returns(uint256);\\n\\n    // @notice derivative specification address\\n    function derivativeSpecification() external view returns(IDerivativeSpecification);\\n    // @notice collateral token address\\n    function collateralToken() external view returns(IERC20);\\n    // @notice oracle address\\n    function oracles(uint index) external view returns(address);\\n    function oracleIterators(uint index) external view returns(address);\\n\\n    // @notice primary token address\\n    function primaryToken() external view returns(IERC20);\\n    // @notice complement token address\\n    function complementToken() external view returns(IERC20);\\n}\\n\"\r\n    },\r\n    \"contracts/Num.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"./Const.sol\\\";\\n\\ncontract Num is Const {\\n\\n    function toi(uint a)\\n        internal pure\\n        returns (uint)\\n    {\\n        return a / BONE;\\n    }\\n\\n    function floor(uint a)\\n        internal pure\\n        returns (uint)\\n    {\\n        return toi(a) * BONE;\\n    }\\n\\n    function add(uint a, uint b)\\n        internal pure\\n        returns (uint c)\\n    {\\n        c = a + b;\\n        require(c >= a, \\\"ADD_OVERFLOW\\\");\\n    }\\n\\n    function sub(uint a, uint b)\\n        internal pure\\n        returns (uint c)\\n    {\\n        bool flag;\\n        (c, flag) = subSign(a, b);\\n        require(!flag, \\\"SUB_UNDERFLOW\\\");\\n    }\\n\\n    function subSign(uint a, uint b)\\n        internal pure\\n        returns (uint, bool)\\n    {\\n        if (a >= b) {\\n            return (a - b, false);\\n        } else {\\n            return (b - a, true);\\n        }\\n    }\\n\\n    function mul(uint a, uint b)\\n        internal pure\\n        returns (uint c)\\n    {\\n        uint c0 = a * b;\\n        require(a == 0 || c0 / a == b, \\\"MUL_OVERFLOW\\\");\\n        uint c1 = c0 + (BONE / 2);\\n        require(c1 >= c0, \\\"MUL_OVERFLOW\\\");\\n        c = c1 / BONE;\\n    }\\n\\n    function div(uint a, uint b)\\n        internal pure\\n        returns (uint c)\\n    {\\n        require(b != 0, \\\"DIV_ZERO\\\");\\n        uint c0 = a * BONE;\\n        require(a == 0 || c0 / a == BONE, \\\"DIV_INTERNAL\\\"); // mul overflow\\n        uint c1 = c0 + (b / 2);\\n        require(c1 >= c0, \\\"DIV_INTERNAL\\\"); //  add require\\n        c = c1 / b;\\n    }\\n\\n    // DSMath.wpow\\n    function powi(uint a, uint n)\\n        internal pure\\n        returns (uint z)\\n    {\\n        z = n % 2 != 0 ? a : BONE;\\n\\n        for (n /= 2; n != 0; n /= 2) {\\n            a = mul(a, a);\\n\\n            if (n % 2 != 0) {\\n                z = mul(z, a);\\n            }\\n        }\\n    }\\n\\n    // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\\n    // Use `powi` for `b^e` and `powK` for k iterations\\n    // of approximation of b^0.w\\n    function pow(uint base, uint exp)\\n        internal pure\\n        returns (uint)\\n    {\\n        require(base >= MIN_POW_BASE, \\\"POW_BASE_TOO_LOW\\\");\\n        require(base <= MAX_POW_BASE, \\\"POW_BASE_TOO_HIGH\\\");\\n\\n        uint whole  = floor(exp);\\n        uint remain = sub(exp, whole);\\n\\n        uint wholePow = powi(base, toi(whole));\\n\\n        if (remain == 0) {\\n            return wholePow;\\n        }\\n\\n        uint partialResult = powApprox(base, remain, POW_PRECISION);\\n        return mul(wholePow, partialResult);\\n    }\\n\\n    function powApprox(uint base, uint exp, uint precision)\\n        internal pure\\n        returns (uint sum)\\n    {\\n        // term 0:\\n        uint a     = exp;\\n        (uint x, bool xneg)  = subSign(base, BONE);\\n        uint term = BONE;\\n        sum   = term;\\n        bool negative = false;\\n\\n\\n        // term(k) = numer / denom\\n        //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\\n        // each iteration, multiply previous term by (a-(k-1)) * x / k\\n        // continue until term is less than precision\\n        for (uint i = 1; term >= precision; i++) {\\n            uint bigK = i * BONE;\\n            (uint c, bool cneg) = subSign(a, sub(bigK, BONE));\\n            term = mul(term, mul(c, x));\\n            term = div(term, bigK);\\n            if (term == 0) break;\\n\\n            if (xneg) negative = !negative;\\n            if (cneg) negative = !negative;\\n            if (negative) {\\n                sum = sub(sum, term);\\n            } else {\\n                sum = add(sum, term);\\n            }\\n        }\\n    }\\n\\n    function min(uint first, uint second)\\n        internal pure\\n        returns (uint)\\n    {\\n        if(first < second) {\\n            return first;\\n        }\\n        return second;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Const.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"./Color.sol\\\";\\n\\ncontract Const is Bronze {\\n    uint public constant BONE              = 10**18;\\n    int public constant  iBONE             = int(BONE);\\n\\n    uint public constant MIN_POW_BASE      = 1 wei;\\n    uint public constant MAX_POW_BASE      = (2 * BONE) - 1 wei;\\n    uint public constant POW_PRECISION     = BONE / 10**10;\\n\\n    uint public constant MAX_IN_RATIO      = BONE / 2;\\n    uint public constant MAX_OUT_RATIO     = (BONE / 3) + 1 wei;\\n}\\n\"\r\n    },\r\n    \"contracts/libs/complifi/IDerivativeSpecification.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: GPL-3.0-or-later\\\"\\n\\npragma solidity 0.7.6;\\n\\n/// @title Derivative Specification interface\\n/// @notice Immutable collection of derivative attributes\\n/// @dev Created by the derivative's author and published to the DerivativeSpecificationRegistry\\ninterface IDerivativeSpecification {\\n    /// @notice Proof of a derivative specification\\n    /// @dev Verifies that contract is a derivative specification\\n    /// @return true if contract is a derivative specification\\n    function isDerivativeSpecification() external pure returns (bool);\\n\\n    /// @notice Set of oracles that are relied upon to measure changes in the state of the world\\n    /// between the start and the end of the Live period\\n    /// @dev Should be resolved through OracleRegistry contract\\n    /// @return oracle symbols\\n    function oracleSymbols() external view returns (bytes32[] memory);\\n\\n    /// @notice Algorithm that, for the type of oracle used by the derivative,\\n    /// finds the value closest to a given timestamp\\n    /// @dev Should be resolved through OracleIteratorRegistry contract\\n    /// @return oracle iterator symbols\\n    function oracleIteratorSymbols() external view returns (bytes32[] memory);\\n\\n    /// @notice Type of collateral that users submit to mint the derivative\\n    /// @dev Should be resolved through CollateralTokenRegistry contract\\n    /// @return collateral token symbol\\n    function collateralTokenSymbol() external view returns (bytes32);\\n\\n    /// @notice Mapping from the change in the underlying variable (as defined by the oracle)\\n    /// and the initial collateral split to the final collateral split\\n    /// @dev Should be resolved through CollateralSplitRegistry contract\\n    /// @return collateral split symbol\\n    function collateralSplitSymbol() external view returns (bytes32);\\n\\n    /// @notice Lifecycle parameter that define the length of the derivative's Live period.\\n    /// @dev Set in seconds\\n    /// @return live period value\\n    function livePeriod() external view returns (uint256);\\n\\n    /// @notice Parameter that determines starting nominal value of primary asset\\n    /// @dev Units of collateral theoretically swappable for 1 unit of primary asset\\n    /// @return primary nominal value\\n    function primaryNominalValue() external view returns (uint256);\\n\\n    /// @notice Parameter that determines starting nominal value of complement asset\\n    /// @dev Units of collateral theoretically swappable for 1 unit of complement asset\\n    /// @return complement nominal value\\n    function complementNominalValue() external view returns (uint256);\\n\\n    /// @notice Minting fee rate due to the author of the derivative specification.\\n    /// @dev Percentage fee multiplied by 10 ^ 12\\n    /// @return author fee\\n    function authorFee() external view returns (uint256);\\n\\n    /// @notice Symbol of the derivative\\n    /// @dev Should be resolved through DerivativeSpecificationRegistry contract\\n    /// @return derivative specification symbol\\n    function symbol() external view returns (string memory);\\n\\n    /// @notice Return optional long name of the derivative\\n    /// @dev Isn't used directly in the protocol\\n    /// @return long name\\n    function name() external view returns (string memory);\\n\\n    /// @notice Optional URI to the derivative specs\\n    /// @dev Isn't used directly in the protocol\\n    /// @return URI to the derivative specs\\n    function baseURI() external view returns (string memory);\\n\\n    /// @notice Derivative spec author\\n    /// @dev Used to set and receive author's fee\\n    /// @return address of the author\\n    function author() external view returns (address);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolBuilder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dynamicFee\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"repricerRegistry\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"blabs\",\"type\":\"address\"}],\"name\":\"LOG_BLABS\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"LOG_NEW_POOL\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_dynamicFee\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_poolBuilder\",\"outputs\":[{\"internalType\":\"contract IPoolBuilder\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_repricerRegistry\",\"outputs\":[{\"internalType\":\"contract IAddressRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IPool\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"collect\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllPools\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getColor\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastPoolIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"b\",\"type\":\"address\"}],\"name\":\"isPool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"derivativeVault\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"repricerSymbol\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"baseFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeAmp\",\"type\":\"uint256\"}],\"name\":\"newPool\",\"outputs\":[{\"internalType\":\"contract IPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"}],\"name\":\"pausePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dynamicFee\",\"type\":\"address\"}],\"name\":\"setDynamicFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolBuilder\",\"type\":\"address\"}],\"name\":\"setPoolBuilder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_value\",\"type\":\"address\"}],\"name\":\"setRepricer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"repricerRegistry\",\"type\":\"address\"}],\"name\":\"setRepricerRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"}],\"name\":\"unpausePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"PoolFactory","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"0000000000000000000000008afeb0bfe04383572dad1cf4be961c3f7f33e4ae00000000000000000000000066356d0e324337620c0d27dd95fbb368ac8d24320000000000000000000000001aaf2cc01d532958808ad339ee8c90b788c6a153","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}