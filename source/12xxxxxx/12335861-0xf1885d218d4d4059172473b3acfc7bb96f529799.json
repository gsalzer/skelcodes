{"status":"1","message":"OK","result":[{"SourceCode":"{\"Interfaces.sol\":{\"content\":\"// SPDX-License-Identifier: --GRISE--\\r\\n\\r\\npragma solidity =0.7.6;\\r\\n\\r\\ninterface IGriseToken {\\r\\n\\r\\n    function currentLPDay()\\r\\n        external view\\r\\n        returns (uint64);\\r\\n\\r\\n    function approve(\\r\\n        address _spender,\\r\\n        uint256 _value\\r\\n    ) external returns (bool success);\\r\\n\\r\\n    function mintSupply(\\r\\n        address _investorAddress,\\r\\n        uint256 _amount\\r\\n    ) external;\\r\\n}\\r\\n\\r\\ninterface UniswapRouterV2 {\\r\\n\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint256 amountTokenMax,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external payable returns (\\r\\n        uint256 amountToken,\\r\\n        uint256 amountETH,\\r\\n        uint256 liquidity\\r\\n    );\\r\\n\\r\\n    function swapExactTokensForETH(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (\\r\\n        uint256[] memory amounts\\r\\n    );\\r\\n}\\r\\n\\r\\ninterface RefundSponsorI {\\r\\n    function addGasRefund(address _a, uint256 _c) external;\\r\\n}\\r\\n\\r\\ninterface IERC20Token {\\r\\n\\r\\n    function transferFrom(\\r\\n        address _from,\\r\\n        address _to,\\r\\n        uint256 _value\\r\\n    )  external returns (\\r\\n        bool success\\r\\n    );\\r\\n\\r\\n    function approve(\\r\\n        address _spender,\\r\\n        uint256 _value\\r\\n    )  external returns (\\r\\n        bool success\\r\\n    );\\r\\n}\\r\\n\"},\"LiquidityTransformer.sol\":{\"content\":\"// SPDX-License-Identifier: --GRISE--\\r\\n\\r\\npragma solidity =0.7.6;\\r\\n\\r\\nimport \\u0027./Interfaces.sol\\u0027;\\r\\nimport \\u0027./Randomness.sol\\u0027;\\r\\n\\r\\ncontract LiquidityTransformer {\\r\\n\\r\\n    using SafeMathLT for uint256;\\r\\n    using SafeMathLT for uint128;\\r\\n\\r\\n    Randomness public randomness;\\r\\n    IGriseToken public GRISE_CONTRACT;\\r\\n    RefundSponsorI public REFUND_SPONSOR;\\r\\n   \\r\\n    UniswapRouterV2 public constant UNISWAP_ROUTER = UniswapRouterV2(\\r\\n        0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D // mainnet\\r\\n    );\\r\\n\\r\\n    address payable constant TEAM_ADDRESS = 0xa377433831E83C7a4Fa10fB75C33217cD7CABec2; \\r\\n    address payable constant DEV_ADDRESS = 0xcD8DcbA8e4791B19719934886A8bA77EA3fad447;\\r\\n    address public TOKEN_DEFINER;\\r\\n\\r\\n    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // mainnet\\r\\n    \\r\\n    uint8 constant INVESTMENT_DAYS = 50;\\r\\n    uint8 constant MAX_DAY_SLOT = 147;\\r\\n\\r\\n    uint128 constant THRESHOLD_LIMIT_MIN = 100000000000000000 wei;\\r\\n    uint128 constant THRESHOLD_LIMIT_MAX = 20 ether;\\r\\n    uint256 public TEAM_ETHER;\\r\\n    uint128 constant MIN_INVEST = 100000000000000000 wei;   \\r\\n    uint128 constant DAILY_MAX_SUPPLY = 12000;\\r\\n    \\r\\n    uint256 constant REI_PER_GRISE = 10 ** uint256(18);\\r\\n\\r\\n    struct Globals {\\r\\n        uint64 generatedDays;\\r\\n        uint64 preparedReferrals;\\r\\n        uint256 totalTransferTokens;\\r\\n        uint256 totalWeiContributed;\\r\\n        uint256 totalReferralTokens;\\r\\n    }\\r\\n\\r\\n    Globals public g;\\r\\n\\r\\n    mapping(uint256 =\\u003e uint256) dailyMinSupply;\\r\\n    mapping(uint256 =\\u003e uint256) dailyMaxSupply;\\r\\n    mapping(uint256 =\\u003e uint256) public dailyTotalSupply;\\r\\n    mapping(uint256 =\\u003e uint256) public dailyTotalInvestment;\\r\\n    mapping(uint256 =\\u003e uint256) public dailySlots;\\r\\n    \\r\\n    uint256 public totalInvestment;\\r\\n    uint8 public totalTransactions;\\r\\n    uint8 constant GAS_REFUND_THRESHOLD = 200;\\r\\n\\r\\n    mapping(uint256 =\\u003e uint256) public investorAccountCount;\\r\\n    mapping(uint256 =\\u003e mapping(uint256 =\\u003e address)) public investorAccounts;\\r\\n    mapping(address =\\u003e mapping(uint256 =\\u003e uint256)) public investorBalances;\\r\\n    mapping(address =\\u003e mapping(uint256 =\\u003e uint256)) public investorBalancesRecord;\\r\\n\\r\\n    mapping(address =\\u003e uint256) public referralAmount;\\r\\n    mapping(address =\\u003e uint256) public referralTokens;\\r\\n    mapping(address =\\u003e uint256) public investorTotalBalance;\\r\\n    mapping(address =\\u003e uint256) originalInvestment;\\r\\n\\r\\n    uint256 public referralAccountCount;\\r\\n    uint256 public uniqueInvestorCount;\\r\\n\\r\\n    mapping (uint256 =\\u003e address) public uniqueInvestors;\\r\\n    mapping (uint256 =\\u003e address) public referralAccounts;\\r\\n\\r\\n    event GeneratedRandomSupply(\\r\\n        uint256 indexed investmentDay,\\r\\n        uint256 randomSupply\\r\\n    );\\r\\n\\r\\n    event GeneratedStaticSupply(\\r\\n        uint256 indexed investmentDay,\\r\\n        uint256 staticSupply\\r\\n    );\\r\\n\\r\\n\\r\\n    event ReferralAdded(\\r\\n        address indexed referral,\\r\\n        address indexed referee,\\r\\n        uint256 amount\\r\\n    );\\r\\n\\r\\n    event UniSwapResult(\\r\\n        uint256 amountToken,\\r\\n        uint256 amountETH,\\r\\n        uint256 liquidity\\r\\n    );\\r\\n\\r\\n    event GriseReservation(\\r\\n        address indexed sender,\\r\\n        uint256 indexed investmentDay,\\r\\n        uint256 amount\\r\\n    );\\r\\n\\r\\n    modifier afterInvestmentPhase() {\\r\\n        require(\\r\\n            _currentLPDay() \\u003e INVESTMENT_DAYS,\\r\\n            \\u0027GRISE: ongoing investment phase\\u0027\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier afterUniswapTransfer() {\\r\\n        require (\\r\\n            g.generatedDays \\u003e 0 \\u0026\\u0026\\r\\n            g.totalWeiContributed == 0,\\r\\n            \\u0027GRISE: forward liquidity first\\u0027\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier investmentDaysRange(uint256 _investmentDay) {\\r\\n        require(\\r\\n            _investmentDay \\u003e 0 \\u0026\\u0026\\r\\n            _investmentDay \\u003c= INVESTMENT_DAYS,\\r\\n            \\u0027GRISE: not in initial investment days range\\u0027\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyFundedDays(uint256 _investmentDay) {\\r\\n        require(\\r\\n            dailyTotalInvestment[_investmentDay] \\u003e 0,\\r\\n            \\u0027GRISE: no investments on that day\\u0027\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier refundSponsorDynamic() {\\r\\n        uint256 gasStart = gasleft();\\r\\n        _;\\r\\n        uint256 gasSpent = (21000 + gasStart - gasleft()).mul(tx.gasprice);\\r\\n        gasSpent = msg.value.div(10) \\u003e gasSpent ? gasSpent : msg.value.div(10);\\r\\n        \\r\\n        if(totalTransactions \\u003c= GAS_REFUND_THRESHOLD){\\r\\n        REFUND_SPONSOR.addGasRefund(msg.sender, gasSpent);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    modifier refundSponsorFixed() {\\r\\n        uint256 gasStart = gasleft();\\r\\n        _;\\r\\n        uint256 gasSpent = (21000 + gasStart - gasleft()).mul(tx.gasprice);\\r\\n        gasSpent = gasSpent \\u003e 5000000000000000 ? 5000000000000000 : gasSpent;\\r\\n        \\r\\n        if(totalTransactions \\u003c= GAS_REFUND_THRESHOLD){\\r\\n        REFUND_SPONSOR.addGasRefund(msg.sender, gasSpent);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    modifier onlyTokenDefiner() {\\r\\n        require(\\r\\n            msg.sender == TOKEN_DEFINER,\\r\\n            \\u0027GRISE: wrong sender\\u0027\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n\\r\\n    receive() external payable {\\r\\n        require (\\r\\n            msg.sender == address(UNISWAP_ROUTER) ||\\r\\n            msg.sender == TEAM_ADDRESS ||\\r\\n            msg.sender == DEV_ADDRESS ||\\r\\n            msg.sender == TOKEN_DEFINER,\\r\\n            \\u0027GRISE: direct deposits disabled\\u0027\\r\\n        );\\r\\n        \\r\\n    }\\r\\n\\r\\n    function defineToken(\\r\\n        address _griseToken\\r\\n    )\\r\\n        external\\r\\n        onlyTokenDefiner\\r\\n    {\\r\\n        GRISE_CONTRACT = IGriseToken(_griseToken);\\r\\n    }\\r\\n\\r\\n    function revokeAccess()\\r\\n        external\\r\\n        onlyTokenDefiner\\r\\n    {\\r\\n        TOKEN_DEFINER = address(0x0);\\r\\n    }\\r\\n\\r\\n    constructor(address _griseToken, Randomness _randomness, address _refundSponsor) {\\r\\n        randomness=_randomness;\\r\\n        GRISE_CONTRACT = IGriseToken(_griseToken);\\r\\n        REFUND_SPONSOR = RefundSponsorI(_refundSponsor);\\r\\n        TOKEN_DEFINER = msg.sender;\\r\\n\\r\\n        dailyMinSupply[1] = 6000;\\r\\n        dailyMinSupply[2] = 6000;\\r\\n        dailyMinSupply[3] = 6000;\\r\\n        dailyMinSupply[4] = 6000;\\r\\n        dailyMinSupply[5] = 2150;\\r\\n        dailyMinSupply[6] = 6000;\\r\\n        dailyMinSupply[7] = 3650;\\r\\n        dailyMinSupply[8] = 6000;\\r\\n        dailyMinSupply[9] = 3650;\\r\\n        dailyMinSupply[10] = 6000;\\r\\n        \\r\\n        dailyMinSupply[11] = 3650;\\r\\n        dailyMinSupply[12] = 6000;\\r\\n        dailyMinSupply[13] = 6000;\\r\\n        dailyMinSupply[14] = 2150;\\r\\n        dailyMinSupply[15] = 6000;\\r\\n        dailyMinSupply[16] = 3650;\\r\\n        dailyMinSupply[17] = 6000;\\r\\n        dailyMinSupply[18] = 3650;\\r\\n        dailyMinSupply[19] = 6000;\\r\\n        dailyMinSupply[20] = 2150;\\r\\n        \\r\\n        dailyMinSupply[21] = 6000;\\r\\n        dailyMinSupply[22] = 2150;\\r\\n        dailyMinSupply[23] = 6000;\\r\\n        dailyMinSupply[24] = 2150;\\r\\n        dailyMinSupply[25] = 6000;\\r\\n        dailyMinSupply[26] = 2150;\\r\\n        dailyMinSupply[27] = 6000;\\r\\n        dailyMinSupply[28] = 6000;\\r\\n        dailyMinSupply[29] = 3650;\\r\\n        dailyMinSupply[30] = 6000;\\r\\n        \\r\\n        dailyMinSupply[31] = 6000;\\r\\n        dailyMinSupply[32] = 2150;\\r\\n        dailyMinSupply[33] = 6000;\\r\\n        dailyMinSupply[34] = 3650;\\r\\n        dailyMinSupply[35] = 6000;\\r\\n        dailyMinSupply[36] = 3650;\\r\\n        dailyMinSupply[37] = 6000;\\r\\n        dailyMinSupply[38] = 2150;\\r\\n        dailyMinSupply[39] = 2150;\\r\\n        dailyMinSupply[40] = 6000;\\r\\n        \\r\\n        dailyMinSupply[41] = 3650;\\r\\n        dailyMinSupply[42] = 6000;\\r\\n        dailyMinSupply[43] = 6000;\\r\\n        dailyMinSupply[44] = 2150;\\r\\n        dailyMinSupply[45] = 6000;\\r\\n        dailyMinSupply[46] = 3650;\\r\\n        dailyMinSupply[47] = 2150;\\r\\n        dailyMinSupply[48] = 3650;\\r\\n        dailyMinSupply[49] = 6000;\\r\\n        dailyMinSupply[50] = 6000;\\r\\n        \\r\\n        \\r\\n        dailyMaxSupply[5] = 16850;\\r\\n        dailyMaxSupply[14] = 16850;\\r\\n        dailyMaxSupply[20] = 16850;\\r\\n        dailyMaxSupply[22] = 16850;\\r\\n        dailyMaxSupply[24] = 16850;\\r\\n        dailyMaxSupply[26] = 16850;\\r\\n        dailyMaxSupply[32] = 16850;\\r\\n        dailyMaxSupply[38] = 16850;\\r\\n        dailyMaxSupply[39] = 16850;\\r\\n        dailyMaxSupply[44] = 16850;\\r\\n        dailyMaxSupply[47] = 16850;\\r\\n        \\r\\n        dailyMaxSupply[7] = 11850;\\r\\n        dailyMaxSupply[9] = 11850;\\r\\n        dailyMaxSupply[11] = 11850;\\r\\n        dailyMaxSupply[16] = 11850;\\r\\n        dailyMaxSupply[18] = 11850;\\r\\n        dailyMaxSupply[29] = 11850;\\r\\n        dailyMaxSupply[34] = 11850;\\r\\n        dailyMaxSupply[36] = 11850;\\r\\n        dailyMaxSupply[41] = 11850;\\r\\n        dailyMaxSupply[46] = 11850;\\r\\n        dailyMaxSupply[48] = 11850;\\r\\n    }\\r\\n\\r\\n\\r\\n    //  GRISE RESERVATION (EXTERNAL FUNCTIONS)  //\\r\\n    //  -------------------------------------  //\\r\\n\\r\\n    /** @dev Performs reservation of GRISE tokens with ETH\\r\\n      * @param _investmentDays array of reservation days.\\r\\n      * @param _referralAddress referral address for bonus.\\r\\n      */\\r\\n    function reserveGrise(\\r\\n        uint8[] calldata _investmentDays,\\r\\n        address _referralAddress\\r\\n    )\\r\\n        external\\r\\n        payable\\r\\n        refundSponsorDynamic\\r\\n    {\\r\\n        checkInvestmentDays(\\r\\n            _investmentDays,\\r\\n            _currentLPDay(),\\r\\n            msg.sender,\\r\\n            msg.value\\r\\n        );\\r\\n        \\r\\n        \\r\\n        _reserveGrise(\\r\\n            _investmentDays,\\r\\n            _referralAddress,\\r\\n            msg.sender,\\r\\n            msg.value\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /** @notice Allows reservation of GRISE tokens with other ERC20 tokens\\r\\n      * @dev this will require LT contract to be approved as spender\\r\\n      * @param _tokenAddress address of an ERC20 token to use\\r\\n      * @param _tokenAmount amount of tokens to use for reservation\\r\\n      * @param _investmentDays array of reservation days\\r\\n      * @param _referralAddress referral address for bonus\\r\\n      */\\r\\n    function reserveGriseWithToken(\\r\\n        address _tokenAddress,\\r\\n        uint256 _tokenAmount,\\r\\n        uint8[] calldata _investmentDays,\\r\\n        address _referralAddress\\r\\n    )\\r\\n        external\\r\\n        refundSponsorFixed\\r\\n    {\\r\\n        IERC20Token _token = IERC20Token(\\r\\n            _tokenAddress\\r\\n        );\\r\\n\\r\\n        _token.transferFrom(\\r\\n            msg.sender,\\r\\n            address(this),\\r\\n            _tokenAmount\\r\\n        );\\r\\n\\r\\n        _token.approve(\\r\\n            address(UNISWAP_ROUTER),\\r\\n            _tokenAmount\\r\\n        );\\r\\n\\r\\n        address[] memory _path = preparePath(\\r\\n            _tokenAddress\\r\\n        );\\r\\n\\r\\n        uint256[] memory amounts =\\r\\n        UNISWAP_ROUTER.swapExactTokensForETH(\\r\\n            _tokenAmount,\\r\\n            0,\\r\\n            _path,\\r\\n            address(this),\\r\\n            block.timestamp.add(2 hours)\\r\\n        );\\r\\n\\r\\n\\r\\n        checkInvestmentDays(\\r\\n            _investmentDays,\\r\\n            _currentLPDay(),\\r\\n            msg.sender,\\r\\n            amounts[1]\\r\\n        );\\r\\n        \\r\\n\\r\\n        _reserveGrise(\\r\\n            _investmentDays,\\r\\n            _referralAddress,\\r\\n            msg.sender,\\r\\n            amounts[1]\\r\\n        );\\r\\n    }\\r\\n\\r\\n    //  GRISE RESERVATION (INTERNAL FUNCTIONS)  //\\r\\n    //  -------------------------------------  //\\r\\n\\r\\n    /** @notice Distributes ETH equaly between selected reservation days\\r\\n      * @dev this will require LT contract to be approved as a spender\\r\\n      * @param _investmentDays array of selected reservation days\\r\\n      * @param _referralAddress referral address for bonus\\r\\n      * @param _senderAddress address of the investor\\r\\n      * @param _senderValue amount of ETH contributed\\r\\n      */\\r\\n    function _reserveGrise(\\r\\n        uint8[] memory _investmentDays,\\r\\n        address _referralAddress,\\r\\n        address _senderAddress,\\r\\n        uint256 _senderValue\\r\\n    )\\r\\n        internal\\r\\n    {\\r\\n        require(\\r\\n            _senderAddress != _referralAddress,\\r\\n            \\u0027GRISE: must be a different address\\u0027\\r\\n        );\\r\\n\\r\\n        require(\\r\\n            notContract(_referralAddress),\\r\\n            \\u0027GRISE: invalid referral address\\u0027\\r\\n        );\\r\\n\\r\\n        uint256 _investmentBalance = _referralAddress == address(0x0)\\r\\n            ? _senderValue \\r\\n            : referralAmount[_referralAddress].add(_senderValue) \\u003e THRESHOLD_LIMIT_MAX\\r\\n            ?_senderValue.mul(1100).div(1000)\\r\\n            :_senderValue.mul(10500).div(10000);\\r\\n\\r\\n\\r\\n\\r\\n        uint256 _totalDays = _investmentDays.length;\\r\\n        uint256 _dailyAmount = _investmentBalance.div(_totalDays);\\r\\n        uint256 _leftOver = _investmentBalance.mod(_totalDays);\\r\\n\\r\\n        _addBalance(\\r\\n            _senderAddress,\\r\\n            _investmentDays[0],\\r\\n            _dailyAmount.add(_leftOver)\\r\\n        );\\r\\n        \\r\\n       \\r\\n\\r\\n        for (uint8 _i = 1; _i \\u003c _totalDays; _i++) {\\r\\n            _addBalance(\\r\\n                _senderAddress,\\r\\n                _investmentDays[_i],\\r\\n                _dailyAmount\\r\\n            );\\r\\n             \\r\\n        }\\r\\n\\r\\n        _trackInvestors(\\r\\n            _senderAddress,\\r\\n            _investmentBalance\\r\\n        );\\r\\n\\r\\n        if (_referralAddress != address(0x0)) {\\r\\n\\r\\n            _trackReferrals(_referralAddress, _senderValue);\\r\\n\\r\\n            emit ReferralAdded(\\r\\n                _referralAddress,\\r\\n                _senderAddress,\\r\\n                _senderValue\\r\\n            );\\r\\n        }\\r\\n\\r\\n        originalInvestment[_senderAddress] += _senderValue;\\r\\n        g.totalWeiContributed += _senderValue;\\r\\n    }\\r\\n\\r\\n    /** @notice Allocates investors balance to specific day\\r\\n      * @param _senderAddress investors wallet address\\r\\n      * @param _investmentDay selected investment day\\r\\n      * @param _investmentBalance amount invested (with bonus)\\r\\n      */\\r\\n    function _addBalance(\\r\\n        address _senderAddress,\\r\\n        uint256 _investmentDay,\\r\\n        uint256 _investmentBalance\\r\\n    )\\r\\n        internal\\r\\n    {\\r\\n        if (investorBalances[_senderAddress][_investmentDay] == 0) {\\r\\n            investorAccounts[_investmentDay][investorAccountCount[_investmentDay]] = _senderAddress;\\r\\n            investorAccountCount[_investmentDay]++;\\r\\n        }\\r\\n\\r\\n        investorBalances[_senderAddress][_investmentDay] += _investmentBalance;\\r\\n        investorBalancesRecord[_senderAddress][_investmentDay] += _investmentBalance;\\r\\n        dailyTotalInvestment[_investmentDay] += _investmentBalance;\\r\\n        totalInvestment += _investmentBalance;\\r\\n        totalTransactions++;\\r\\n\\r\\n        emit GriseReservation(\\r\\n            _senderAddress,\\r\\n            _investmentDay,\\r\\n            _investmentBalance\\r\\n        );\\r\\n    }\\r\\n\\r\\n    //  GRISE RESERVATION (PRIVATE FUNCTIONS)  //\\r\\n    //  ------------------------------------  //\\r\\n\\r\\n    /** @notice Tracks investorTotalBalance and uniqueInvestors\\r\\n      * @dev used in _reserveGrise() internal function\\r\\n      * @param _investorAddress address of the investor\\r\\n      * @param _value ETH amount invested (with bonus)\\r\\n      */\\r\\n    function _trackInvestors(address _investorAddress, uint256 _value) private {\\r\\n       \\r\\n        if (investorTotalBalance[_investorAddress] == 0) {\\r\\n            uniqueInvestors[uniqueInvestorCount] = _investorAddress;\\r\\n            uniqueInvestorCount++;\\r\\n        }\\r\\n        investorTotalBalance[_investorAddress] += _value;\\r\\n    }\\r\\n\\r\\n    /** @notice Tracks referralAmount and referralAccounts\\r\\n      * @dev used in _reserveGrise() internal function\\r\\n      * @param _referralAddress address of the referrer\\r\\n      * @param _value ETH amount referred during reservation\\r\\n      */\\r\\n    function _trackReferrals(address _referralAddress, uint256 _value) private {\\r\\n        if (referralAmount[_referralAddress] == 0) {\\r\\n            referralAccounts[\\r\\n            referralAccountCount] = _referralAddress;\\r\\n            referralAccountCount++;\\r\\n        }\\r\\n        referralAmount[_referralAddress] += _value;\\r\\n    }\\r\\n\\r\\n\\r\\n    //  SUPPLY GENERATION (EXTERNAL FUNCTION)  //\\r\\n    //  -------------------------------------  //\\r\\n\\r\\n    /** @notice Allows to generate supply for past funded days\\r\\n      * @param _investmentDay investemnt day index (1-50)\\r\\n      */\\r\\n    function generateSupply(\\r\\n        uint64 _investmentDay\\r\\n    )\\r\\n        external\\r\\n        investmentDaysRange(_investmentDay)\\r\\n        onlyFundedDays(_investmentDay)\\r\\n    {\\r\\n        require(\\r\\n            _investmentDay \\u003c _currentLPDay(),\\r\\n            \\u0027GRISE: investment day must be in past\\u0027\\r\\n        );\\r\\n\\r\\n        require(\\r\\n            dailyTotalSupply[_investmentDay] == 0,\\r\\n            \\u0027GRISE: supply already generated\\u0027\\r\\n        );\\r\\n                \\r\\n        DAILY_MAX_SUPPLY - dailyMinSupply[_investmentDay] == dailyMinSupply[_investmentDay]\\r\\n            ? _generateStaticSupply(_investmentDay)\\r\\n            : _generateRandomSupply(_investmentDay);\\r\\n    }\\r\\n\\r\\n\\r\\n    //  SUPPLY GENERATION (INTERNAL FUNCTIONS)  //\\r\\n    //  --------------------------------------  //\\r\\n\\r\\n    /** @notice Generates supply for days with static supply\\r\\n      * @param _investmentDay investemnt day index (1-50)\\r\\n      */\\r\\n    function _generateStaticSupply(\\r\\n        uint256 _investmentDay\\r\\n    )\\r\\n        internal\\r\\n    {\\r\\n        dailyTotalSupply[_investmentDay] = dailyMinSupply[_investmentDay] * REI_PER_GRISE;\\r\\n        g.totalTransferTokens += dailyTotalSupply[_investmentDay];\\r\\n\\r\\n        g.generatedDays++;\\r\\n        \\r\\n        emit GeneratedStaticSupply(\\r\\n            _investmentDay,\\r\\n            dailyTotalSupply[_investmentDay]\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /** @notice Generates supply for days with random supply\\r\\n      * @dev uses nreAPI to request random number\\r\\n      * @param _investmentDay investemnt day index (1-50)\\r\\n      */\\r\\n    function _generateRandomSupply(\\r\\n        uint256 _investmentDay\\r\\n    )\\r\\n        internal\\r\\n    {\\r\\n        uint256 ceilingDayMaxSupply = dailyMaxSupply[_investmentDay].sub(dailyMinSupply[_investmentDay]);\\r\\n        uint256 randomSupply =  randomness.stateRandomNumber() % ceilingDayMaxSupply;\\r\\n    \\r\\n        g.generatedDays = g.generatedDays + 1;\\r\\n        dailyTotalSupply[_investmentDay] = dailyMinSupply[_investmentDay]\\r\\n            .add(randomSupply)\\r\\n            .mul(REI_PER_GRISE);\\r\\n\\r\\n        g.totalTransferTokens = g.totalTransferTokens\\r\\n            .add(dailyTotalSupply[_investmentDay]);\\r\\n\\r\\n        emit GeneratedRandomSupply(\\r\\n            _investmentDay,\\r\\n            dailyTotalSupply[_investmentDay]\\r\\n        );\\r\\n\\r\\n    }\\r\\n    \\r\\n\\r\\n    //  PRE-LIQUIDITY GENERATION FUNCTION  //\\r\\n    //  ---------------------------------  //\\r\\n\\r\\n    /** @notice Pre-calculates amount of tokens each referrer will get\\r\\n      * @dev must run this for all referrer addresses in batches\\r\\n      * converts _referralAmount to _referralTokens based on dailyRatio\\r\\n      */\\r\\n    function prepareReferralBonuses(\\r\\n        uint256 _referralBatchFrom,\\r\\n        uint256 _referralBatchTo\\r\\n    )\\r\\n        external\\r\\n        afterInvestmentPhase\\r\\n    {\\r\\n        require(\\r\\n            _referralBatchFrom \\u003c _referralBatchTo,\\r\\n            \\u0027GRISE: incorrect referral batch\\u0027\\r\\n        );\\r\\n\\r\\n        require (\\r\\n            g.preparedReferrals \\u003c referralAccountCount,\\r\\n            \\u0027GRISE: all referrals already prepared\\u0027\\r\\n        );\\r\\n\\r\\n        uint256 _totalRatio = g.totalTransferTokens.div(g.totalWeiContributed);\\r\\n\\r\\n        for (uint256 i = _referralBatchFrom; i \\u003c _referralBatchTo; i++) {\\r\\n            address _referralAddress = referralAccounts[i];\\r\\n            uint256 _referralAmount = referralAmount[_referralAddress];\\r\\n            if (referralAmount[_referralAddress] \\u003e 0) {\\r\\n                referralAmount[_referralAddress] = 0;\\r\\n                if (_referralAmount \\u003e= THRESHOLD_LIMIT_MIN) {\\r\\n                    _referralAmount \\u003e= THRESHOLD_LIMIT_MAX\\r\\n                        ? _fullReferralBonus(_referralAddress, _referralAmount, _totalRatio)\\r\\n                        : _familyReferralBonus(_referralAddress, _referralAmount,  _totalRatio);\\r\\n\\r\\n                    g.totalReferralTokens = g.totalReferralTokens.add(\\r\\n                        referralTokens[_referralAddress]\\r\\n                    );\\r\\n                }\\r\\n                g.preparedReferrals++;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /** @notice performs token allocation for 10% of referral amount\\r\\n      * @dev after liquidity is formed referrer can withdraw this amount\\r\\n      */\\r\\n    function _fullReferralBonus(address _referralAddress, uint256 _referralAmount, uint256 _ratio) internal {\\r\\n        referralTokens[_referralAddress] = _referralAmount.div(10).mul(_ratio);\\r\\n    }\\r\\n\\r\\n    /** @notice performs token allocation for 5% of referral amount\\r\\n      * @dev after liquidity is formed referrer can withdraw this amount\\r\\n      */\\r\\n    function _familyReferralBonus(address _referralAddress, uint256 _referralAmount, uint256 _ratio) internal {\\r\\n        referralTokens[_referralAddress] = _referralAmount.div(20).mul(_ratio);\\r\\n    }\\r\\n\\r\\n\\r\\n    //  LIQUIDITY GENERATION FUNCTION  //\\r\\n    //  -----------------------------  //\\r\\n\\r\\n    /** @notice Creates initial liquidity on Uniswap by forwarding\\r\\n      * reserved tokens equivalent to ETH contributed to the contract\\r\\n      * @dev check addLiquidityETH documentation\\r\\n      */\\r\\n    function forwardLiquidity(/*🦄*/)\\r\\n        external\\r\\n        afterInvestmentPhase\\r\\n    {\\r\\n        require(\\r\\n            g.generatedDays == fundedDays(),\\r\\n            \\u0027GRISE: must generate supply for all days\\u0027\\r\\n        );\\r\\n\\r\\n        require (\\r\\n            g.preparedReferrals == referralAccountCount,\\r\\n            \\u0027GRISE: must prepare all referrals\\u0027\\r\\n        );\\r\\n\\r\\n        require (\\r\\n            g.totalTransferTokens \\u003e 0,\\r\\n            \\u0027GRISE: must have tokens to transfer\\u0027\\r\\n        );\\r\\n\\r\\n        uint256 _balance = g.totalWeiContributed;\\r\\n        uint256 _buffer = g.totalTransferTokens + g.totalReferralTokens;\\r\\n        \\r\\n        uint256 _bounty = _buffer.mul(8).div(100);\\r\\n\\r\\n        _balance = _balance.sub(\\r\\n            _teamContribution(\\r\\n                _balance.mul(15).div(100)\\r\\n            )\\r\\n        );\\r\\n\\r\\n        _buffer = _buffer.mul(_balance).div(\\r\\n            g.totalWeiContributed\\r\\n        );\\r\\n        \\r\\n        _bounty = _bounty.add(_buffer.mul(8).div(100));\\r\\n        \\r\\n\\r\\n        GRISE_CONTRACT.mintSupply(\\r\\n            address(this), _buffer\\r\\n        );\\r\\n        \\r\\n        GRISE_CONTRACT.mintSupply(\\r\\n            TEAM_ADDRESS, _bounty\\r\\n        );\\r\\n        \\r\\n\\r\\n        GRISE_CONTRACT.approve(\\r\\n            address(UNISWAP_ROUTER), _buffer\\r\\n        );\\r\\n\\r\\n        (\\r\\n            uint256 amountToken,\\r\\n            uint256 amountETH,\\r\\n            uint256 liquidity\\r\\n        ) =\\r\\n\\r\\n        UNISWAP_ROUTER.addLiquidityETH{value: _balance}(\\r\\n            address(GRISE_CONTRACT),\\r\\n            _buffer,\\r\\n            0,\\r\\n            0,\\r\\n            address(0x0),\\r\\n            block.timestamp.add(2 hours)\\r\\n        );\\r\\n\\r\\n        g.totalTransferTokens = 0;\\r\\n        g.totalReferralTokens = 0;\\r\\n        g.totalWeiContributed = 0;\\r\\n\\r\\n        emit UniSwapResult(\\r\\n            amountToken, amountETH, liquidity\\r\\n        );\\r\\n    }\\r\\n\\r\\n\\r\\n    //  GRISE TOKEN PAYOUT FUNCTIONS (INDIVIDUAL)  //\\r\\n    //  ----------------------------------------  //\\r\\n\\r\\n    /** @notice Allows to mint all the tokens\\r\\n      * from investor and referrer perspectives\\r\\n      * @dev can be called after forwardLiquidity()\\r\\n      */\\r\\n    function getMyTokens(/*💰*/)\\r\\n        external\\r\\n        afterUniswapTransfer\\r\\n    {\\r\\n        payoutInvestorAddress(msg.sender);\\r\\n        payoutReferralAddress(msg.sender);\\r\\n    }\\r\\n\\r\\n    /** @notice Allows to mint tokens for specific investor address\\r\\n      * @dev aggregades investors tokens across all investment days\\r\\n      * and uses GRISE_CONTRACT instance to mint all the GRISE tokens\\r\\n      * @param _investorAddress requested investor calculation address\\r\\n      * @return _payout amount minted to the investors address\\r\\n      */\\r\\n    function payoutInvestorAddress(\\r\\n        address _investorAddress\\r\\n    )\\r\\n        public\\r\\n        afterUniswapTransfer\\r\\n        returns (uint256 _payout)\\r\\n    {\\r\\n        for (uint8 i = 1; i \\u003c= INVESTMENT_DAYS; i++) {\\r\\n            if (investorBalances[_investorAddress][i] \\u003e 0) {\\r\\n                _payout += investorBalances[_investorAddress][i].mul(\\r\\n                    _calculateDailyRatio(i)\\r\\n                ).div(100E18);\\r\\n                investorBalances[_investorAddress][i] = 0;\\r\\n            }\\r\\n        }\\r\\n        if (_payout \\u003e 0) {\\r\\n            GRISE_CONTRACT.mintSupply(\\r\\n                _investorAddress,\\r\\n                _payout\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /** @notice Allows to mint tokens for specific referrer address\\r\\n      * @dev must be pre-calculated in prepareReferralBonuses()\\r\\n      * @param _referralAddress referrer payout address\\r\\n      * @return _referralTokens amount minted to the referrer address\\r\\n      */\\r\\n    function payoutReferralAddress(\\r\\n        address _referralAddress\\r\\n    ) public\\r\\n        afterUniswapTransfer\\r\\n        returns (uint256 _referralTokens)\\r\\n    {\\r\\n        _referralTokens = referralTokens[_referralAddress];\\r\\n        if (referralTokens[_referralAddress] \\u003e 0) {\\r\\n            referralTokens[_referralAddress] = 0;\\r\\n            GRISE_CONTRACT.mintSupply(\\r\\n                _referralAddress,\\r\\n                _referralTokens\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //  GRISE TOKEN PAYOUT FUNCTIONS (BATCHES)  //\\r\\n    //  -------------------------------------  //\\r\\n\\r\\n    /** @notice Allows to mint tokens for specific investment day\\r\\n      * recommended batch size is up to 50 addresses per call\\r\\n      * @param _investmentDay processing investment day\\r\\n      * @param _investorBatchFrom batch starting index\\r\\n      * @param _investorBatchTo bach finishing index\\r\\n      */\\r\\n    function payoutInvestmentDayBatch(\\r\\n        uint256 _investmentDay,\\r\\n        uint256 _investorBatchFrom,\\r\\n        uint256 _investorBatchTo\\r\\n    )\\r\\n        external\\r\\n        afterUniswapTransfer\\r\\n        onlyFundedDays(_investmentDay)\\r\\n    {\\r\\n        require(\\r\\n            _investorBatchFrom \\u003c _investorBatchTo,\\r\\n            \\u0027GRISE: incorrect investment batch\\u0027\\r\\n        );\\r\\n\\r\\n        uint256 _dailyRatio = _calculateDailyRatio(_investmentDay);\\r\\n\\r\\n        for (uint256 i = _investorBatchFrom; i \\u003c _investorBatchTo; i++) {\\r\\n            address _investor = investorAccounts[_investmentDay][i];\\r\\n            uint256 _balance = investorBalances[_investor][_investmentDay];\\r\\n            uint256 _payout = _balance.mul(_dailyRatio).div(100E18);\\r\\n\\r\\n            if (investorBalances[_investor][_investmentDay] \\u003e 0) {\\r\\n                investorBalances[_investor][_investmentDay] = 0;\\r\\n                GRISE_CONTRACT.mintSupply(\\r\\n                    _investor,\\r\\n                    _payout\\r\\n                );\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /** @notice Allows to mint tokens for referrers in batches\\r\\n      * @dev can be called right after forwardLiquidity()\\r\\n      * recommended batch size is up to 50 addresses per call\\r\\n      * @param _referralBatchFrom batch starting index\\r\\n      * @param _referralBatchTo bach finishing index\\r\\n      */\\r\\n    function payoutReferralBatch(\\r\\n        uint256 _referralBatchFrom,\\r\\n        uint256 _referralBatchTo\\r\\n    )\\r\\n        external\\r\\n        afterUniswapTransfer\\r\\n    {\\r\\n        require(\\r\\n            _referralBatchFrom \\u003c _referralBatchTo,\\r\\n            \\u0027GRISE: incorrect referral batch\\u0027\\r\\n        );\\r\\n\\r\\n        for (uint256 i = _referralBatchFrom; i \\u003c _referralBatchTo; i++) {\\r\\n            address _referralAddress = referralAccounts[i];\\r\\n            uint256 _referralTokens = referralTokens[_referralAddress];\\r\\n            if (referralTokens[_referralAddress] \\u003e 0) {\\r\\n                referralTokens[_referralAddress] = 0;\\r\\n                GRISE_CONTRACT.mintSupply(\\r\\n                    _referralAddress,\\r\\n                    _referralTokens\\r\\n                );\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //  INFO VIEW FUNCTIONS (PERSONAL)  //\\r\\n    //  ------------------------------  //\\r\\n\\r\\n    /** @notice checks for callers investment amount on specific day (with bonus)\\r\\n      * @return total amount invested across specific investment day (with bonus)\\r\\n      */\\r\\n    function myInvestmentAmount(uint256 _investmentDay) external view returns (uint256) {\\r\\n        return investorBalances[msg.sender][_investmentDay];\\r\\n    }\\r\\n\\r\\n    /** @notice checks for callers claimable amount on specific day (with bonus)\\r\\n      * @return total amount claimable across specific investment day (with bonus)\\r\\n      */\\r\\n    function myClaimAmount(uint256 _investmentDay) external view returns (uint256) {\\r\\n        if (investorBalances[msg.sender][_investmentDay] \\u003e 0) {\\r\\n            return investorBalances[msg.sender][_investmentDay].mul(\\r\\n                    _calculateDailyRatio(_investmentDay)).div(100E18);\\r\\n        }else{\\r\\n            return 0;\\r\\n        }            \\r\\n    }\\r\\n\\r\\n    /** @notice checks for callers investment amount on each day (with bonus)\\r\\n      * @return _myAllDays total amount invested across all days (with bonus)\\r\\n      */\\r\\n    function myInvestmentAmountAllDays() external view returns (uint256[51] memory _myAllDays) {\\r\\n        for (uint256 i = 1; i \\u003c= INVESTMENT_DAYS; i++) {\\r\\n            _myAllDays[i] = investorBalances[msg.sender][i];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /** @notice checks for callers total investment amount (with bonus)\\r\\n      * @return total amount invested across all investment days (with bonus)\\r\\n      */\\r\\n    function myTotalInvestmentAmount() external view returns (uint256) {\\r\\n        return investorTotalBalance[msg.sender];\\r\\n    }\\r\\n\\r\\n    /** @notice checks for callers total claimable amount (with refferal bonus)\\r\\n      * @return total claimable amount across all investment days (with refferal bonus)\\r\\n      */\\r\\n    function myClaimAmountAllDays() external view returns (uint256) {\\r\\n        uint256 _payout;\\r\\n        for (uint256 i = 1; i \\u003c= INVESTMENT_DAYS; i++) {\\r\\n            if (investorBalances[msg.sender][i] \\u003e 0) {\\r\\n                _payout += investorBalances[msg.sender][i].mul(\\r\\n                    _calculateDailyRatio(i)\\r\\n                ).div(100E18);\\r\\n            }    \\r\\n        }\\r\\n\\r\\n        return _payout + referralTokens[msg.sender];\\r\\n    }\\r\\n\\r\\n\\r\\n    //  INFO VIEW FUNCTIONS (GLOBAL)  //\\r\\n    //  ----------------------------  //\\r\\n\\r\\n    /** @notice checks for investors count on specific day\\r\\n      * @return investors count for specific day\\r\\n      */\\r\\n    function investorsOnDay(uint256 _investmentDay) public view returns (uint256) {\\r\\n        return dailyTotalInvestment[_investmentDay] \\u003e 0 ? investorAccountCount[_investmentDay] : 0;\\r\\n    }\\r\\n\\r\\n    /** @notice checks for investors count on each day\\r\\n      * @return _allInvestors array with investors count for each day\\r\\n      */\\r\\n    function investorsOnAllDays() external view returns (uint256[51] memory _allInvestors) {\\r\\n        for (uint256 i = 1; i \\u003c= INVESTMENT_DAYS; i++) {\\r\\n            _allInvestors[i] = investorsOnDay(i);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /** @notice checks for investment amount on each day\\r\\n      * @return _allInvestments array with investment amount for each day\\r\\n      */\\r\\n    function investmentsOnAllDays() external view returns (uint256[51] memory _allInvestments) {\\r\\n        for (uint256 i = 1; i \\u003c= INVESTMENT_DAYS; i++) {\\r\\n            _allInvestments[i] = dailyTotalInvestment[i];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /** @notice checks for supply amount on each day\\r\\n      * @return _allSupply array with supply amount for each day\\r\\n      */\\r\\n    function supplyOnAllDays() external view returns (uint256[51] memory _allSupply) {\\r\\n        for (uint256 i = 1; i \\u003c= INVESTMENT_DAYS; i++) {\\r\\n            _allSupply[i] = dailyTotalSupply[i];\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    //  HELPER FUNCTIONS (PURE)  //\\r\\n    //  -----------------------  //\\r\\n\\r\\n    /** @notice checks that provided days are valid for investemnt\\r\\n      * @dev used in reserveGrise() and reserveGriseWithToken()\\r\\n      */\\r\\n    function checkInvestmentDays(\\r\\n        uint8[] memory _investmentDays,\\r\\n        uint64 _griseDay,\\r\\n        address _senderAddress,\\r\\n        uint256 _senderValue\\r\\n    )\\r\\n        internal\\r\\n    {\\r\\n        uint256 _totalDays = _investmentDays.length;\\r\\n        uint256 _dailyAmount = _senderValue.div(_totalDays);\\r\\n        \\r\\n        for (uint8 _i = 0; _i \\u003c _investmentDays.length; _i++) {\\r\\n            \\r\\n            require(\\r\\n                (_dailyAmount \\u003e= MIN_INVEST) || (investorBalances[_senderAddress][_investmentDays[_i]] \\u003e 0),\\r\\n                \\u0027GRISE: investment below minimum\\u0027\\r\\n            );\\r\\n            \\r\\n            require(\\r\\n                _investmentDays[_i] \\u003e= _griseDay,\\r\\n                \\u0027GRISE: investment day already passed\\u0027\\r\\n            );\\r\\n            require(\\r\\n                _investmentDays[_i] \\u003e 0 \\u0026\\u0026\\r\\n                _investmentDays[_i] \\u003c= INVESTMENT_DAYS,\\r\\n                \\u0027GRISE: incorrect investment day\\u0027\\r\\n            );\\r\\n            \\r\\n            \\r\\n            require(\\r\\n                (dailySlots[_investmentDays[_i]] \\u003c MAX_DAY_SLOT) || \\r\\n                (investorBalances[_senderAddress][_investmentDays[_i]] \\u003e 0)\\r\\n                ,\\r\\n                \\u0027GRISE: investment slots are not available\\u0027\\r\\n            );\\r\\n            \\r\\n            if(investorBalances[_senderAddress][_investmentDays[_i]] == 0){\\r\\n                dailySlots[_investmentDays[_i]]++;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    \\r\\n\\r\\n    /** @notice prepares path variable for uniswap to exchange tokens\\r\\n      * @dev used in reserveGriseWithToken() swapExactTokensForETH call\\r\\n      * @param _tokenAddress ERC20 token address to be swapped for ETH\\r\\n      * @return _path that is used to swap tokens for ETH on uniswap\\r\\n      */\\r\\n    function preparePath(\\r\\n        address _tokenAddress\\r\\n    ) internal pure returns (\\r\\n        address[] memory _path\\r\\n    ) {\\r\\n        _path = new address[](2);\\r\\n        _path[0] = _tokenAddress;\\r\\n        _path[1] = WETH;\\r\\n    }\\r\\n\\r\\n    /** @notice keeps team contribution \\r\\n      * @dev subtracts amount during forwardLiquidity()\\r\\n      * @return ETH amount the team is allowed to withdraw\\r\\n      */\\r\\n    function _teamContribution(\\r\\n        uint256 _teamAmount\\r\\n    ) internal returns (uint256) {\\r\\n        TEAM_ETHER = _teamAmount;\\r\\n        return _teamAmount;\\r\\n    }\\r\\n\\r\\n    /** @notice checks for invesments on all days\\r\\n      * @dev used in forwardLiquidity() requirements\\r\\n      * @return $fundedDays - amount of funded days 0-50\\r\\n      */\\r\\n    function fundedDays() public view returns (\\r\\n        uint8 $fundedDays\\r\\n    ) {\\r\\n        for (uint8 i = 1; i \\u003c= INVESTMENT_DAYS; i++) {\\r\\n            if (dailyTotalInvestment[i] \\u003e 0) $fundedDays++;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /** @notice GRISE equivalent in ETH price calculation\\r\\n      * @dev returned value has 100E18 precision - divided later on\\r\\n      * @return token price for specific day based on total investement\\r\\n      */\\r\\n    function _calculateDailyRatio(\\r\\n        uint256 _investmentDay\\r\\n    ) internal view returns (uint256) {\\r\\n\\r\\n        uint256 dailyRatio = dailyTotalSupply[_investmentDay].mul(100E18)\\r\\n            .div(dailyTotalInvestment[_investmentDay]);\\r\\n\\r\\n        uint256 remainderCheck = dailyTotalSupply[_investmentDay].mul(100E18)\\r\\n            .mod(dailyTotalInvestment[_investmentDay]);\\r\\n\\r\\n        return remainderCheck == 0 ? dailyRatio : dailyRatio.add(1);\\r\\n    }\\r\\n\\r\\n    //  TIMING FUNCTIONS  //\\r\\n    //  ----------------  //\\r\\n\\r\\n    /** @notice shows current slot of GriseToken\\r\\n      * @dev value is fetched from GRISE_CONTRACT\\r\\n      * @return iteration day since GRISE inception\\r\\n      */\\r\\n    function _currentLPDay() public view returns (uint64) {\\r\\n        return GRISE_CONTRACT.currentLPDay();\\r\\n    }\\r\\n\\r\\n    /** @notice allows to withdraw team funds for the work\\r\\n      * strictly only after the uniswap liquidity is formed\\r\\n      */\\r\\n    function requestTeamFunds()\\r\\n        external\\r\\n        afterUniswapTransfer\\r\\n    {\\r\\n        TEAM_ADDRESS.transfer(TEAM_ETHER.mul(4).div(5));\\r\\n        DEV_ADDRESS.transfer(TEAM_ETHER.div(5));\\r\\n    }\\r\\n\\r\\n    function notContract(address _addr) internal view returns (bool) {\\r\\n        uint32 size;\\r\\n        assembly {\\r\\n            size := extcodesize(_addr)\\r\\n        }\\r\\n        return (size == 0);\\r\\n    }\\r\\n\\r\\n}\\r\\n\\r\\nlibrary SafeMathLT {\\r\\n\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\u0027GRISE: addition overflow\\u0027);\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, \\u0027GRISE: subtraction overflow\\u0027);\\r\\n        uint256 c = a - b;\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\u0027GRISE: multiplication overflow\\u0027);\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, \\u0027GRISE: division by zero\\u0027);\\r\\n        uint256 c = a / b;\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b != 0, \\u0027GRISE: modulo by zero\\u0027);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\"},\"nreAPI.sol\":{\"content\":\"/*\\r\\n\\r\\nÑíguez Randomity Engine API\\r\\n\\r\\nMIT License\\r\\n\\r\\nCopyright (c) 2019 niguezrandomityengine | Programmed and designed by Scheich R. Ahmed\\r\\n\\r\\nPermission is hereby granted, free of charge, to any person obtaining a copy\\r\\nof this software and associated documentation files (the \\\"Software\\\"), to deal\\r\\nin the Software without restriction, including without limitation the rights\\r\\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\r\\ncopies of the Software, and to permit persons to whom the Software is\\r\\nfurnished to do so, subject to the following conditions:\\r\\n\\r\\nThe above copyright notice and this permission notice shall be included in all\\r\\ncopies or substantial portions of the Software.\\r\\n\\r\\nTHE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\r\\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\r\\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\r\\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\r\\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\r\\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\r\\nSOFTWARE.\\r\\n\\r\\n*/\\r\\n\\r\\n// SPDX-License-Identifier: --🦉--\\r\\n\\r\\npragma solidity \\u003e= 0.4.0; // Compiler version incompatible error!\\r\\n\\r\\nabstract contract niguezRandomityEngine {\\r\\n\\r\\n\\tfunction rd() external virtual returns (uint256);\\r\\n\\tfunction rm() external virtual returns (uint256);\\r\\n\\tfunction rv() external virtual returns (uint256);\\r\\n\\tfunction rx() external virtual returns (uint256);\\r\\n\\tfunction rf() external virtual returns (uint256);\\r\\n\\r\\n}\\r\\n\\r\\ncontract usingNRE {\\r\\n\\r\\n  niguezRandomityEngine internal nre = niguezRandomityEngine(0x031eaE8a8105217ab64359D4361022d0947f4572);\\t\\r\\n\\tfunction rd() internal returns (uint256) {\\r\\n        return nre.rd();\\r\\n    }\\r\\n\\r\\n\\tfunction rf() internal returns (uint256) {\\r\\n        return nre.rf();\\r\\n    }\\r\\n\\t\\t\\r\\n\\tfunction rm() internal returns (uint256) {\\r\\n        return nre.rm();\\r\\n    }\\r\\n\\r\\n\\tfunction rv() internal returns (uint256) {\\r\\n        return nre.rv();\\r\\n    }\\r\\n\\t\\r\\n\\tfunction rx() internal returns (uint256) {\\r\\n        return nre.rx();\\r\\n    }\\r\\n}\\r\\n\\r\\n/*\\r\\nEnd of API\\r\\n*/\\r\\n\"},\"Randomness.sol\":{\"content\":\"// SPDX-License-Identifier: --GRISE--\\r\\npragma solidity =0.7.6;\\r\\n\\r\\nimport \\\"./nreAPI.sol\\\";\\r\\n\\r\\ncontract Randomness is usingNRE { \\r\\n    \\r\\n   function stateRandomNumber() public returns (uint256) {\\r\\n       uint256 randomNumber;\\r\\n       randomNumber = (rm()%(10**5));\\r\\n       return randomNumber;\\r\\n    }\\r\\n \\r\\n}\\r\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_griseToken\",\"type\":\"address\"},{\"internalType\":\"contract Randomness\",\"name\":\"_randomness\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_refundSponsor\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"investmentDay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"randomSupply\",\"type\":\"uint256\"}],\"name\":\"GeneratedRandomSupply\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"investmentDay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"staticSupply\",\"type\":\"uint256\"}],\"name\":\"GeneratedStaticSupply\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"investmentDay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"GriseReservation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referee\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReferralAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"name\":\"UniSwapResult\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"GRISE_CONTRACT\",\"outputs\":[{\"internalType\":\"contract IGriseToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REFUND_SPONSOR\",\"outputs\":[{\"internalType\":\"contract RefundSponsorI\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TEAM_ETHER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN_DEFINER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNISWAP_ROUTER\",\"outputs\":[{\"internalType\":\"contract UniswapRouterV2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_currentLPDay\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dailySlots\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dailyTotalInvestment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dailyTotalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_griseToken\",\"type\":\"address\"}],\"name\":\"defineToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"forwardLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundedDays\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"$fundedDays\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"g\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"generatedDays\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"preparedReferrals\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"totalTransferTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWeiContributed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalReferralTokens\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_investmentDay\",\"type\":\"uint64\"}],\"name\":\"generateSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMyTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"investmentsOnAllDays\",\"outputs\":[{\"internalType\":\"uint256[51]\",\"name\":\"_allInvestments\",\"type\":\"uint256[51]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"investorAccountCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"investorAccounts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"investorBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"investorBalancesRecord\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"investorTotalBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"investorsOnAllDays\",\"outputs\":[{\"internalType\":\"uint256[51]\",\"name\":\"_allInvestors\",\"type\":\"uint256[51]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_investmentDay\",\"type\":\"uint256\"}],\"name\":\"investorsOnDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_investmentDay\",\"type\":\"uint256\"}],\"name\":\"myClaimAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"myClaimAmountAllDays\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_investmentDay\",\"type\":\"uint256\"}],\"name\":\"myInvestmentAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"myInvestmentAmountAllDays\",\"outputs\":[{\"internalType\":\"uint256[51]\",\"name\":\"_myAllDays\",\"type\":\"uint256[51]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"myTotalInvestmentAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_investmentDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_investorBatchFrom\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_investorBatchTo\",\"type\":\"uint256\"}],\"name\":\"payoutInvestmentDayBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_investorAddress\",\"type\":\"address\"}],\"name\":\"payoutInvestorAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_payout\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referralAddress\",\"type\":\"address\"}],\"name\":\"payoutReferralAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_referralTokens\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_referralBatchFrom\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_referralBatchTo\",\"type\":\"uint256\"}],\"name\":\"payoutReferralBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_referralBatchFrom\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_referralBatchTo\",\"type\":\"uint256\"}],\"name\":\"prepareReferralBonuses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"randomness\",\"outputs\":[{\"internalType\":\"contract Randomness\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralAccountCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"referralAccounts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referralAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referralTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestTeamFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8[]\",\"name\":\"_investmentDays\",\"type\":\"uint8[]\"},{\"internalType\":\"address\",\"name\":\"_referralAddress\",\"type\":\"address\"}],\"name\":\"reserveGrise\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint8[]\",\"name\":\"_investmentDays\",\"type\":\"uint8[]\"},{\"internalType\":\"address\",\"name\":\"_referralAddress\",\"type\":\"address\"}],\"name\":\"reserveGriseWithToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revokeAccess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supplyOnAllDays\",\"outputs\":[{\"internalType\":\"uint256[51]\",\"name\":\"_allSupply\",\"type\":\"uint256[51]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalInvestment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTransactions\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniqueInvestorCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"uniqueInvestors\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"LiquidityTransformer","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000eff9c1b11bcde99cdfb6305d25bea1db52fa6032000000000000000000000000c5e59baa5e5af76eb5ae77bf538714c4836efb7b0000000000000000000000008c37e2c13406c5353b3c60f00bc5160f4cf36395","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://80efc0303d54d96254e57cc04a0d6c906241862482bbba22c0ffa0a6c02b56a5"}]}