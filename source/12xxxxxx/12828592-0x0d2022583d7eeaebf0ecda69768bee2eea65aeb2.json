{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2021-07-14\r\n*/\r\n\r\n//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.1;\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @dev Interface contains all of the events necessary for staking Vega token\r\n */\r\ninterface IStake {\r\n  event Stake_Deposited(address indexed user, uint256 amount, bytes32 indexed vega_public_key);\r\n  event Stake_Removed(address indexed user, uint256 amount, bytes32 indexed vega_public_key);\r\n  event Stake_Transferred(address indexed from, uint256 amount, address indexed to, bytes32 indexed vega_public_key);\r\n\r\n  /// @return the address of the token that is able to be staked\r\n  function staking_token() external view returns (address);\r\n\r\n  /// @param target Target address to check\r\n  /// @param vega_public_key Target vega public key to check\r\n  /// @return the number of tokens staked for that address->vega_public_key pair\r\n  function stake_balance(address target, bytes32 vega_public_key) external view returns (uint256);\r\n\r\n\r\n  /// @return total tokens staked on contract\r\n  function total_staked() external view returns (uint256);\r\n}\r\n\r\n\r\n/// @title ERC20 Vesting\r\n/// @author Vega Protocol\r\n/// @notice This contract manages the vesting of the Vega V2 ERC20 token\r\ncontract ERC20_Vesting is IStake {\r\n\r\n  event Tranche_Created(uint8 indexed tranche_id, uint256 cliff_start, uint256 duration);\r\n  event Tranche_Balance_Added(address indexed user, uint8 indexed tranche_id, uint256 amount);\r\n  event Tranche_Balance_Removed(address indexed user, uint8 indexed tranche_id, uint256 amount);\r\n  event Issuer_Permitted(address indexed issuer, uint256 amount);\r\n  event Issuer_Revoked(address indexed issuer);\r\n  event Controller_Set(address indexed new_controller);\r\n\r\n  /// @notice controller is similar to \"owner\" in other contracts\r\n  address public controller;\r\n  /// @notice tranche_count starts at 1 to cause tranche 0 (perma-lock) to exist as the default tranche\r\n  uint8 public tranche_count = 1;\r\n  /// @notice user => has been migrated\r\n  mapping(address => bool) public v1_migrated;\r\n  /// @notice user => user_stat struct\r\n  mapping(address=> user_stat) public user_stats;\r\n\r\n  /// @notice total_locked is the total amount of tokens \"on\" this contract that are locked into a tranche\r\n  uint256 public total_locked;\r\n  /// @notice v1_address is the address for Vega's v1 ERC20 token that has already been deployed\r\n  address public v1_address; // mainnet = 0xD249B16f61cB9489Fe0Bb046119A48025545b58a;\r\n  /// @notice v2_address is the address for Vega's v2 ERC20 token that replaces v1\r\n  address public v2_address;\r\n  /// @notice accuracy_scale is the multiplier to assist in integer division\r\n  uint256 constant public accuracy_scale = 100000000000;\r\n  /// @notice default_tranche_id is the tranche_id for the default tranche\r\n  uint8 constant public default_tranche_id = 0;\r\n  /// @dev total_staked_tokens is the number of tokens staked across all users\r\n  uint256 total_staked_tokens;\r\n\r\n  /****ADDRESS MIGRATION**/\r\n  /// @notice new address => old address\r\n  mapping(address => address) public address_migration;\r\n  /*****/\r\n\r\n  /// @param token_v1_address Vega's already deployed v1 ERC20 token address\r\n  /// @param token_v2_address Vega's v2 ERC20 token and the token being vested here\r\n  /// @dev emits Controller_Set event\r\n  constructor(address token_v1_address, address token_v2_address, address[] memory old_addresses, address[] memory new_addresses) {\r\n    require(old_addresses.length == new_addresses.length, \"array length mismatch\");\r\n\r\n    for(uint8 map_idx = 0; map_idx < old_addresses.length; map_idx++) {\r\n      /// @dev the following line prevents double-mapping attack\r\n      require(!v1_migrated[old_addresses[map_idx]]);\r\n      v1_migrated[old_addresses[map_idx]] = true;\r\n      address_migration[new_addresses[map_idx]] = old_addresses[map_idx];\r\n    }\r\n\r\n    v1_address = token_v1_address;\r\n    /// @notice this initializes the total_locked with the amount of already issued v1 VEGA ERC20 tokens\r\n    total_locked = IERC20(token_v1_address).totalSupply() - IERC20(token_v1_address).balanceOf(token_v1_address);\r\n    v2_address = token_v2_address;\r\n    controller = msg.sender;\r\n    emit Controller_Set(controller);\r\n  }\r\n\r\n  /// @notice tranche_balance has the params necessary to track what a user is owed in a single tranche\r\n  /// @param total_deposited is the total number of tokens deposited into this single tranche for a single user\r\n  /// @param total_claimed is the total number of tokens in this tranche that have been withdrawn\r\n  struct tranche_balance {\r\n      uint256 total_deposited;\r\n      uint256 total_claimed;\r\n  }\r\n\r\n  /// @notice user_stat is a struct that holds all the details needed to handle a single user's vesting\r\n  /// @param total_in_all_tranches is the total number of tokens currently in all tranches that have been migrated to v2\r\n  /// @param lien total amount of locked tokens that have been marked for staking\r\n  /// @param tranche_balances is a mapping of tranche_id => tranche_balance\r\n  struct user_stat {\r\n    uint256 total_in_all_tranches;\r\n    uint256 lien;\r\n    mapping (uint8 => tranche_balance) tranche_balances;\r\n    mapping(bytes32 => uint256) stake;\r\n  }\r\n\r\n  /// @notice tranche is a struct that hold the details needed for calculating individual tranche vesting\r\n  /// @param cliff_start is a timestamp after which vesting starts\r\n  /// @param duration is the number of seconds after cliff_start until the tranche is 100% vested\r\n  struct tranche {\r\n    uint256 cliff_start;\r\n    uint256 duration;\r\n  }\r\n\r\n  /// @notice tranche_id => tranche struct\r\n  mapping(uint8 => tranche) public tranches;\r\n  /// @notice issuer address => permitted issuance allowance\r\n  mapping(address => uint256) public permitted_issuance;\r\n\r\n  /// @notice this function allows the contract controller to create a tranche\r\n  /// @notice tranche zero is perma-locked and already exists prior to running this function, making the first vesting tranche \"tranche:1\"\r\n  /// @param cliff_start is a timestamp in seconds of when vesting begins for this tranche\r\n  /// @param duration is the number of seconds after cliff_start that the tranche will be fully vested\r\n  function create_tranche(uint256 cliff_start, uint256 duration) public only_controller {\r\n    tranches[tranche_count] = tranche(cliff_start, duration);\r\n    emit Tranche_Created(tranche_count, cliff_start, duration);\r\n    /// @notice sol ^0.8 comes with auto-overflow protection\r\n    tranche_count++;\r\n  }\r\n\r\n  /// @notice this function allows the conroller or permitted issuer to issue tokens from this contract itself (no tranches) into the specified tranche\r\n  /// @notice tranche MUST be created\r\n  /// @notice once assigned to a tranche, tokens can never be clawed back, but they can be reassigned IFF they are in tranche_id:0\r\n  /// @param user The user being issued the tokens\r\n  /// @param tranche_id the id of the target tranche\r\n  /// @param amount number of tokens to be issued into tranche\r\n  /// @dev emits Tranche_Balance_Added event\r\n  function issue_into_tranche(address user, uint8 tranche_id, uint256 amount) public controller_or_issuer {\r\n    require(tranche_id < tranche_count, \"tranche_id out of bounds\");\r\n    if(permitted_issuance[msg.sender] > 0){\r\n      /// @dev if code gets here, they are an issuer if not they must be the controller\r\n      require(permitted_issuance[msg.sender] >= amount, \"not enough permitted balance\");\r\n      require(user != msg.sender, \"cannot issue to self\");\r\n      permitted_issuance[msg.sender] -= amount;\r\n    }\r\n    require( IERC20(v2_address).balanceOf(address(this)) - (total_locked + amount) >= 0, \"contract token balance low\" );\r\n\r\n    /// @dev only runs once\r\n    if(!v1_migrated[user]){\r\n      uint256 bal = v1_bal(user);\r\n      user_stats[user].tranche_balances[0].total_deposited += bal;\r\n      user_stats[user].total_in_all_tranches += bal;\r\n      v1_migrated[user] = true;\r\n    }\r\n    user_stats[user].tranche_balances[tranche_id].total_deposited += amount;\r\n    user_stats[user].total_in_all_tranches += amount;\r\n    total_locked += amount;\r\n    emit Tranche_Balance_Added(user, tranche_id, amount);\r\n  }\r\n\r\n\r\n  /// @notice this function allows the controller to move tokens issued into tranche zero to the target tranche\r\n  /// @notice can only be moved from tranche 0\r\n  /// @param user The user being issued the tokens\r\n  /// @param tranche_id the id of the target tranche\r\n  /// @param amount number of tokens to be moved from tranche 0\r\n  /// @dev emits Tranche_Balance_Removed event\r\n  /// @dev emits Tranche_Balance_Added event\r\n  function move_into_tranche(address user, uint8 tranche_id, uint256 amount) public only_controller {\r\n    require(tranche_id > 0 && tranche_id < tranche_count);\r\n\r\n    /// @dev only runs once\r\n    if(!v1_migrated[user]){\r\n      uint256 bal = v1_bal(user);\r\n      user_stats[user].tranche_balances[default_tranche_id].total_deposited += bal;\r\n      user_stats[user].total_in_all_tranches += bal;\r\n      v1_migrated[user] = true;\r\n    }\r\n    require(user_stats[user].tranche_balances[default_tranche_id].total_deposited >= amount);\r\n    user_stats[user].tranche_balances[default_tranche_id].total_deposited -= amount;\r\n    user_stats[user].tranche_balances[tranche_id].total_deposited += amount;\r\n    emit Tranche_Balance_Removed(user, default_tranche_id, amount);\r\n    emit Tranche_Balance_Added(user, tranche_id, amount);\r\n  }\r\n\r\n  /// @notice this view returns the balance of the given tranche for the given user\r\n  /// @notice tranche 0 balance of a non-v1_migrated user will return user's v1 token balance as they are pre-issued to the current hodlers\r\n  /// @param user Target user address\r\n  /// @param tranche_id target tranche\r\n  /// @return balance of target tranche of user\r\n  function get_tranche_balance(address user, uint8 tranche_id) public view returns(uint256) {\r\n    if(tranche_id == default_tranche_id && !v1_migrated[user]){\r\n      return v1_bal(user);\r\n    } else {\r\n      return user_stats[user].tranche_balances[tranche_id].total_deposited - user_stats[user].tranche_balances[tranche_id].total_claimed;\r\n    }\r\n  }\r\n\r\n  /// @notice This view returns the amount that is currently vested in a given tranche\r\n  /// @notice This does NOT take into account any current lien\r\n  /// @param user Target user address\r\n  /// @param tranche_id Target tranche\r\n  /// @return number of tokens vested in the target tranche for the target user\r\n  function get_vested_for_tranche(address user, uint8 tranche_id) public view returns(uint256) {\r\n    if(block.timestamp < tranches[tranche_id].cliff_start){\r\n      return 0;\r\n    }\r\n    else if(block.timestamp > tranches[tranche_id].cliff_start + tranches[tranche_id].duration || tranches[tranche_id].duration == 0){\r\n      return user_stats[user].tranche_balances[tranche_id].total_deposited -  user_stats[user].tranche_balances[tranche_id].total_claimed;\r\n    } else {\r\n      return (((( accuracy_scale * (block.timestamp - tranches[tranche_id].cliff_start) )  / tranches[tranche_id].duration\r\n          ) * user_stats[user].tranche_balances[tranche_id].total_deposited\r\n        ) / accuracy_scale ) - user_stats[user].tranche_balances[tranche_id].total_claimed;\r\n    }\r\n  }\r\n\r\n  /// @notice This view returns the balance remaining in Vega V1 for a given user\r\n  /// @notice Once migrated, the balance will always return zero, hence \"remaining\"\r\n  /// @param user Target user\r\n  /// @return remaining v1 balance\r\n  function v1_bal(address user) internal view returns(uint256) {\r\n    if(!v1_migrated[user]){\r\n      if(address_migration[user] != address(0)){\r\n        return IERC20(v1_address).balanceOf(user) + IERC20(v1_address).balanceOf(address_migration[user]);\r\n      } else {\r\n        return IERC20(v1_address).balanceOf(user);\r\n      }\r\n    } else {\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  /// @notice This view returns the current amount of tokens locked in all tranches\r\n  /// @notice This includes remaining v1 balance\r\n  /// @param user Target user\r\n  /// @return the current amount of tokens for target user in all tranches\r\n  function user_total_all_tranches(address user) public view returns(uint256){\r\n    return user_stats[user].total_in_all_tranches + v1_bal(user);\r\n  }\r\n\r\n  /// @notice This function withdraws all the currently available vested tokens from the target tranche\r\n  /// @notice This will not allow a user's total tranch balance to go below the user's lien amount\r\n  /// @dev Emits Tranche_Balance_Removed event if successful\r\n  /// @param tranche_id Id of target tranche\r\n  function withdraw_from_tranche(uint8 tranche_id) public {\r\n    require(tranche_id != default_tranche_id);\r\n    uint256 to_withdraw = get_vested_for_tranche(msg.sender, tranche_id);\r\n    require(user_stats[msg.sender].total_in_all_tranches - to_withdraw >=  user_stats[msg.sender].lien);\r\n    user_stats[msg.sender].tranche_balances[tranche_id].total_claimed += to_withdraw;\r\n    /// @dev Solidity ^0.8 has overflow protection, if this next line overflows, the transaction will revert\r\n    user_stats[msg.sender].total_in_all_tranches -= to_withdraw;\r\n    /// @dev Solidity ^0.8 has overflow protection, if this next line overflows, the transaction will revert\r\n    total_locked -= to_withdraw;\r\n    require(IERC20(v2_address).transfer(msg.sender, to_withdraw));\r\n    emit Tranche_Balance_Removed(msg.sender, tranche_id, to_withdraw);\r\n  }\r\n\r\n  /// @notice This function allows the controller to assist the target user with their withdrawal. All the currently available vested tokens FOR THE TARGET will be withdrawn TO THE TARGET ADDRESS WALLET\r\n  /// @notice This function exists in case of users using custodial wallets that are incapable of running \"withdraw_from_tranche\" but are still ERC20 compatable\r\n  /// @notice ONLY the controller can run this function and it will only be ran at the target users request\r\n  /// @notice This will not allow a user's total tranch balance to go below the user's lien amount\r\n  /// @notice This function does not allow the controller to access any funds from other addresses or change which address is in control of any funds\r\n  /// @dev Emits Tranche_Balance_Removed event if successful\r\n  /// @param tranche_id Id of target tranche\r\n  /// @param target Address with balance that needs the assist\r\n  function assisted_withdraw_from_tranche(uint8 tranche_id, address target) public only_controller {\r\n    require(tranche_id != default_tranche_id);\r\n    uint256 to_withdraw = get_vested_for_tranche(target, tranche_id);\r\n    require(user_stats[target].total_in_all_tranches - to_withdraw >=  user_stats[target].lien);\r\n    user_stats[target].tranche_balances[tranche_id].total_claimed += to_withdraw;\r\n    /// @dev Solidity ^0.8 has overflow protection, if this next line overflows, the transaction will revert\r\n    user_stats[target].total_in_all_tranches -= to_withdraw;\r\n    /// @dev Solidity ^0.8 has overflow protection, if this next line overflows, the transaction will revert\r\n    total_locked -= to_withdraw;\r\n    require(IERC20(v2_address).transfer(target, to_withdraw));\r\n    emit Tranche_Balance_Removed(target, tranche_id, to_withdraw);\r\n  }\r\n\r\n\r\n  /// @notice This function will put a lien on the user who runs this function\r\n  /// @dev Emits Stake_Deposited event if successful\r\n  /// @param amount Amount of tokens to stake\r\n  /// @param vega_public_key Target Vega public key to be credited with the stake lock\r\n  function stake_tokens(uint256 amount, bytes32 vega_public_key) public {\r\n    require(user_stats[msg.sender].lien + amount > user_stats[msg.sender].lien);\r\n    require(user_total_all_tranches(msg.sender) >= user_stats[msg.sender].lien + amount);\r\n    /// @dev Solidity ^0.8 has overflow protection, if this next line overflows, the transaction will revert\r\n    user_stats[msg.sender].lien += amount;\r\n    user_stats[msg.sender].stake[vega_public_key] += amount;\r\n    total_staked_tokens += amount;\r\n    emit Stake_Deposited(msg.sender, amount, vega_public_key);\r\n  }\r\n\r\n  /// @notice This function will remove the lien from the user who runs this function\r\n  /// @notice clears \"amount\" of lien\r\n  /// @dev emits Stake_Removed event if successful\r\n  /// @param amount Amount of tokens to remove from Staking\r\n  /// @param vega_public_key Target Vega public key from which to remove stake lock\r\n  function remove_stake(uint256 amount, bytes32 vega_public_key) public {\r\n    /// @dev Solidity ^0.8 has overflow protection, if this next line overflows, the transaction will revert\r\n    user_stats[msg.sender].stake[vega_public_key] -= amount;\r\n    /// @dev Solidity ^0.8 has overflow protection, if this next line overflows, the transaction will revert\r\n    user_stats[msg.sender].lien -= amount;\r\n    total_staked_tokens -= amount;\r\n    emit Stake_Removed(msg.sender, amount, vega_public_key);\r\n  }\r\n\r\n  /// @notice This function allows the controller to permit the given address to issue the given Amount\r\n  /// @notice Target users MUST have a zero (0) permitted issuance balance (try revoke_issuer)\r\n  /// @dev emits Issuer_Permitted event\r\n  /// @param issuer Target address to be allowed to issue given amount\r\n  /// @param amount Number of tokens issuer is permitted to issue\r\n  function permit_issuer(address issuer, uint256 amount) public only_controller {\r\n    /// @notice revoke is required first to stop a simple double allowance attack\r\n    require(amount > 0, \"amount must be > 0\");\r\n    require(permitted_issuance[issuer] == 0, \"issuer already permitted, revoke first\");\r\n    require(controller != issuer, \"controller cannot be permitted issuer\");\r\n    permitted_issuance[issuer] = amount;\r\n    emit Issuer_Permitted(issuer, amount);\r\n  }\r\n\r\n  /// @notice This function allows the controller to revoke issuance permission from given target\r\n  /// @notice permitted_issuance must be greater than zero (0)\r\n  /// @dev emits Issuer_Revoked event\r\n  /// @param issuer Target address of issuer to be revoked\r\n  function revoke_issuer(address issuer) public only_controller {\r\n    require(permitted_issuance[issuer] != 0, \"issuer already revoked\");\r\n    permitted_issuance[issuer] = 0;\r\n    emit Issuer_Revoked(issuer);\r\n  }\r\n\r\n  /// @notice This function allows the controller to assign a new controller\r\n  /// @dev Emits Controller_Set event\r\n  /// @param new_controller Address of the new controller\r\n  function set_controller(address new_controller) public only_controller {\r\n    controller = new_controller;\r\n    if(permitted_issuance[new_controller] > 0){\r\n      permitted_issuance[new_controller] = 0;\r\n      emit Issuer_Revoked(new_controller);\r\n    }\r\n    emit Controller_Set(new_controller);\r\n  }\r\n\r\n  /// @dev This is IStake.staking_token\r\n  /// @return the address of the token that is able to be staked\r\n  function staking_token() external override view returns (address) {\r\n    return v2_address;\r\n  }\r\n\r\n  /// @dev This is IStake.stake_balance\r\n  /// @param target Target address to check\r\n  /// @param vega_public_key Target vega public key to check\r\n  /// @return the number of tokens staked for that address->vega_public_key pair\r\n  function stake_balance(address target, bytes32 vega_public_key) external override view returns (uint256) {\r\n    return user_stats[target].stake[vega_public_key];\r\n  }\r\n\r\n  /// @dev This is IStake.total_staked\r\n  /// @return total tokens staked on contract\r\n  function total_staked() external override view returns (uint256) {\r\n    return total_staked_tokens;\r\n  }\r\n\r\n  /// @notice this modifier requires that msg.sender is the controller of this contract\r\n  modifier only_controller {\r\n         require( msg.sender == controller, \"not controller\" );\r\n         _;\r\n  }\r\n\r\n  /// @notice this modifier requires that msg.sender is the controller of this contract or has a permitted issuance remaining of more than zero (0)\r\n  modifier controller_or_issuer {\r\n         require( msg.sender == controller || permitted_issuance[msg.sender] > 0,\"not controller or issuer\" );\r\n         _;\r\n  }\r\n}\r\n\r\n/**\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMWEMMMMMMMMMMMMMMMMMMMMMMMMMM...............MMMMMMMMMMMMM\r\nMMMMMMLOVEMMMMMMMMMMMMMMMMMMMMMM...............MMMMMMMMMMMMM\r\nMMMMMMMMMMHIXELMMMMMMMMMMMM....................MMMMMNNMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMM....................MMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMM88=........................+MMMMMMMMMM\r\nMMMMMMMMMMMMMMMMM....................MMMMM...MMMMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMM....................MMMMM...MMMMMMMMMMMMMMM\r\nMMMMMMMMMMMM.........................MM+..MMM....+MMMMMMMMMM\r\nMMMMMMMMMNMM...................... ..MM?..MMM.. .+MMMMMMMMMM\r\nMMMMNDDMM+........................+MM........MM..+MMMMMMMMMM\r\nMMMMZ.............................+MM....................MMM\r\nMMMMZ.............................+MM....................MMM\r\nMMMMZ.............................+MM....................DDD\r\nMMMMZ.............................+MM..ZMMMMMMMMMMMMMMMMMMMM\r\nMMMMZ.............................+MM..ZMMMMMMMMMMMMMMMMMMMM\r\nMM..............................MMZ....ZMMMMMMMMMMMMMMMMMMMM\r\nMM............................MM.......ZMMMMMMMMMMMMMMMMMMMM\r\nMM............................MM.......ZMMMMMMMMMMMMMMMMMMMM\r\nMM......................ZMMMMM.......MMMMMMMMMMMMMMMMMMMMMMM\r\nMM............... ......ZMMMMM.... ..MMMMMMMMMMMMMMMMMMMMMMM\r\nMM...............MMMMM88~.........+MM..ZMMMMMMMMMMMMMMMMMMMM\r\nMM.......$DDDDDDD.......$DDDDD..DDNMM..ZMMMMMMMMMMMMMMMMMMMM\r\nMM.......$DDDDDDD.......$DDDDD..DDNMM..ZMMMMMMMMMMMMMMMMMMMM\r\nMM.......ZMMMMMMM.......ZMMMMM..MMMMM..ZMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMM+.......MMMMM88NMMMMM..MMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMM+.......MMMMM88NMMMMM..MMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_v1_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token_v2_address\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"old_addresses\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"new_addresses\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"new_controller\",\"type\":\"address\"}],\"name\":\"Controller_Set\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"issuer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Issuer_Permitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"issuer\",\"type\":\"address\"}],\"name\":\"Issuer_Revoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"vega_public_key\",\"type\":\"bytes32\"}],\"name\":\"Stake_Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"vega_public_key\",\"type\":\"bytes32\"}],\"name\":\"Stake_Removed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"vega_public_key\",\"type\":\"bytes32\"}],\"name\":\"Stake_Transferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"tranche_id\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Tranche_Balance_Added\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"tranche_id\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Tranche_Balance_Removed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"tranche_id\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cliff_start\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"Tranche_Created\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"accuracy_scale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"address_migration\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"tranche_id\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"assisted_withdraw_from_tranche\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cliff_start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"create_tranche\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"default_tranche_id\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"tranche_id\",\"type\":\"uint8\"}],\"name\":\"get_tranche_balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"tranche_id\",\"type\":\"uint8\"}],\"name\":\"get_vested_for_tranche\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"tranche_id\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"issue_into_tranche\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"tranche_id\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"move_into_tranche\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"issuer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"permit_issuer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"permitted_issuance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"vega_public_key\",\"type\":\"bytes32\"}],\"name\":\"remove_stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"issuer\",\"type\":\"address\"}],\"name\":\"revoke_issuer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"new_controller\",\"type\":\"address\"}],\"name\":\"set_controller\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"vega_public_key\",\"type\":\"bytes32\"}],\"name\":\"stake_balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"vega_public_key\",\"type\":\"bytes32\"}],\"name\":\"stake_tokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"staking_token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"total_locked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"total_staked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tranche_count\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"tranches\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cliff_start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"user_stats\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"total_in_all_tranches\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lien\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"user_total_all_tranches\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"v1_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"v1_migrated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"v2_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"tranche_id\",\"type\":\"uint8\"}],\"name\":\"withdraw_from_tranche\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ERC20_Vesting","CompilerVersion":"v0.8.1+commit.df193b15","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000d249b16f61cb9489fe0bb046119a48025545b58a0000000000000000000000003647e4c91197e521650b4d2d620b8dc91156e7a300000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000680000000000000000000000000000000000000000000000000000000000000002f0000000000000000000000008e4868bd1ac69790def1155653f75123e2abeffa000000000000000000000000589980efc28f69a6f65d9f8e8b81e6b4f573633e00000000000000000000000066371d5511f9c9d94159044731c3da3b3551cc30000000000000000000000000ce10eb700e8234bb75af72648e402d907b99efc1000000000000000000000000600d2528ef9ed1d6a1e24beefa42bbaee98f9bcd00000000000000000000000005cb5772faf1819ab03ca9dcbe010a11c68a78fc000000000000000000000000312fe624f88b25419d1b2069951099df6d59c236000000000000000000000000e45b825ff851d4452e9603131cb6eb084ebf90a4000000000000000000000000b5b47dd43771eb3a074e0053d15d1b8230d6e00a000000000000000000000000fd04f36aecae828ba3a1d3fd9f12ad6e4626587600000000000000000000000061bbae1a038fad5cab0e094872279a0917450d66000000000000000000000000bdf739b7190cc1cf35052456866996c05a881c790000000000000000000000009310875c95ebd340d026f542e8b083778a5f96720000000000000000000000009a55e845453b73ac01d8eb19985d017447b9705f000000000000000000000000ced350756d62fd2c37101e8a5bd03b95c68084d900000000000000000000000036febc6773f25faaf40677a12718e9b99aafa9bf000000000000000000000000aa29fcbb9b45dd3e938e7a99440be60f2b8d1a9600000000000000000000000095d8541051cf3287e8aecb32b6c0e41623e00d73000000000000000000000000432642741243e5a1a04304bd173a77fc4c4712a3000000000000000000000000611a0e8bcfc34ddd51ac2e17f3e8180a1bf9bb29000000000000000000000000869588245f0123a3344aae45fb2d9c85d1f8010e0000000000000000000000008ce335b76c1f2855497d26747c21e3142e9bb18400000000000000000000000098f7896bd7b996224ecd6a48d203d7aacf0de18c0000000000000000000000009191876fc52ea8cb16c2c4767bdb1f29e14c9d1c0000000000000000000000001cc4b4961acd33d1f640c5ad071b626e071f176e00000000000000000000000039a7501ce0e76c1b6228f6bb6b9bce208a91d1b3000000000000000000000000fb34e3b590bb08ac006b8669e02db1c3b3914cba00000000000000000000000075e5044e4af796d45df56e6f15406eb75cef6e4a000000000000000000000000330cd4f571bff6bf08288a1c82b889f7f464e824000000000000000000000000170b515467c56dcdb702a6468edcefb3ae4b218f000000000000000000000000d93c317b10a6463cc486d6017ca804513b9ade1a000000000000000000000000f500a991b5398716a9a6e4329521461bd3ea34ec000000000000000000000000d5c6e7f8f4e57031ad25916ed91a791b03d8feac000000000000000000000000ab8b7a75565877ad843a7f0849828fec2bad5c68000000000000000000000000375c8a4a337bfa7faacf827b2e1f71f3ef19ade70000000000000000000000000cbd6ed39898c7c6b1dfc405b398d9bc49b8406d00000000000000000000000037d98b42348fd64a71685dbcdacbeb2e6916fb32000000000000000000000000ec8060514b00485946611e8d92ff65e3637a85c0000000000000000000000000aa53ec9fcea382b0751f4751dc9cbf2794d10360000000000000000000000000c1612c40a98790902842725b4eeab2d4095edb07000000000000000000000000003773c8cef7c2a609372798a79e38a15e24acb5000000000000000000000000c628347e39657dc9acb114154524491bb28545ab000000000000000000000000e4eb4572ebb70415f109ba6f5a056719d101c22e000000000000000000000000a666173610c9ea917242cb8ed43c783b15b78b3100000000000000000000000024d19f100ba142543a863fc2294b188e35ab55b900000000000000000000000003be4f2ead4cfb6fa33a31da13e2ac8b218ce748000000000000000000000000f5688c0b8e7f1c101917f1f1d13513e00473b3a2000000000000000000000000000000000000000000000000000000000000002f00000000000000000000000087d71adabc11c35af566ed51421eda0c82828a3a000000000000000000000000e20d4d4ffb165e4b9926467d82d03c0e9ab66d890000000000000000000000009cf9b305601154c85ff86014d10a8762c802db0b00000000000000000000000001a8055a97b461b58ba8e37cd349721feae77a8d00000000000000000000000008afb70d190aaa9c66bf1654aaa8f44ea67221a800000000000000000000000064548eb9bd7b4a4a1e53c4f20ac77e3ec34d45d6000000000000000000000000cf852533bd3c17d7917985c05dd9ab9e09ae144a00000000000000000000000009a158ca712d12f5fe22f2eaebc971326e9193a1000000000000000000000000ae75a3bd37e6b5ad55883c00eae9d912057fd8bc000000000000000000000000e5517551c3aac4184fadd736a711efe1b9bad9de000000000000000000000000457c399e8fe371103b788c08ab0bc0055579851d000000000000000000000000dc9722a17912a0e75e04a12e974b969f7b53f0670000000000000000000000004092e429b149b5495265b608fd6fae69fa5bfbe6000000000000000000000000435bb0923134a1bc35d0665b14dcc2ed7db41050000000000000000000000000834b777e3ab758c84febbfb9d6bb675bc4b169150000000000000000000000006213b4ca9f2f6c9e30459554a469961c36960fad000000000000000000000000b091d456d0dfcb94dcba6f355379056c5bb995fc000000000000000000000000620646e5895f768d98ee5ec159a2efa602d76cdc0000000000000000000000002818da8354f587854d260fe93656b57e6ea450d90000000000000000000000006295bc707c3502562742330926cb58a7a0b73b51000000000000000000000000de0e306363e557b14ea74d61bd282a47049a2dba000000000000000000000000a53b55f9b39fe7dbbb5b80a79565480117f899e000000000000000000000000040a5785b5bfe73a7f958c65241733401ec6e61a2000000000000000000000000b9909e1f6d3213d9e640fab866c798a2c1c9dd3a00000000000000000000000000c7276399483015a75b25ef7afab6a743febc7f00000000000000000000000040937be701f6bb5633f6c774921564080f62a0c100000000000000000000000097d7e211abc1554921fdd412c9b9b23dd9a05cc7000000000000000000000000c985ffa00217fe9868493e36ca904fc71e4cb70b00000000000000000000000002184ab7d6db67633c12f135fb3bba80013dffa2000000000000000000000000db74914b0c7831d1646118d597fbebb84453b2e10000000000000000000000005a856c02dd32b9d95668c19d62ba300537091d54000000000000000000000000cc5cafd3daa3bb2caa68521f35d1ebeb6cf7c0510000000000000000000000003e2377dbf36a9b36d89470bb8a5a801c830b2f16000000000000000000000000264e6fae28d30bc33b36758b740a20ec7e7a41850000000000000000000000000f27bb59f654e4e603f5833174dfaf2748b78f39000000000000000000000000c5f7ff99d3eed8f7b383104435a6c00a8ced445100000000000000000000000026769b78b82e509e1faccd090555124318872d410000000000000000000000005f01a497e4033e4812ba5d494bcbc2220cd510ed00000000000000000000000016ca0b89e252a8f08da30311579876569b82376a0000000000000000000000008da3586ff7526e122093ee6dd86dfbf067ad8704000000000000000000000000e24b12358d444f4f246cd19ae7c40d9e0af8ca18000000000000000000000000ac3bf9e857eebc5fd292e58dc706041be343bf3600000000000000000000000026932d9d36a3b87c6a9f7007289938a5ca9368d00000000000000000000000006dde38ba3c6c451beeb0f736dc7d6542bedb3baf00000000000000000000000001a8055a97b461b58ba8e37cd349721feae77a8d0000000000000000000000000ab71ccb75d2bc3ebebdcab536c6a3188947e9080000000000000000000000004aa3c35f6cc2d507e5c18205ee57099a4c80b19b","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://dfb218f32c1a70950b29a1857e51c7edd8e566576947f207d16ab9bef1f0a4dc"}]}