{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/RewardDistributorV3.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\n\\nimport \\\"./interface/IiToken.sol\\\";\\nimport \\\"./interface/IRewardDistributorV3.sol\\\";\\nimport \\\"./interface/IPriceOracle.sol\\\";\\n\\nimport \\\"./library/Initializable.sol\\\";\\nimport \\\"./library/Ownable.sol\\\";\\nimport \\\"./library/SafeRatioMath.sol\\\";\\nimport \\\"./Controller.sol\\\";\\n\\n/**\\n * @title dForce's lending reward distributor Contract\\n * @author dForce\\n */\\ncontract RewardDistributorV3 is Initializable, Ownable, IRewardDistributorV3 {\\n    using SafeRatioMath for uint256;\\n    using SafeMathUpgradeable for uint256;\\n    using SafeERC20Upgradeable for IERC20Upgradeable;\\n\\n    /// @notice the controller\\n    Controller public controller;\\n\\n    /// @notice the global Reward distribution speed\\n    uint256 public globalDistributionSpeed;\\n\\n    /// @notice the Reward distribution speed of each iToken\\n    mapping(address => uint256) public distributionSpeed;\\n\\n    /// @notice the Reward distribution factor of each iToken, 1.0 by default. stored as a mantissa\\n    mapping(address => uint256) public distributionFactorMantissa;\\n\\n    struct DistributionState {\\n        // Token's last updated index, stored as a mantissa\\n        uint256 index;\\n        // The block number the index was last updated at\\n        uint256 block;\\n    }\\n\\n    /// @notice the Reward distribution supply state of each iToken\\n    mapping(address => DistributionState) public distributionSupplyState;\\n    /// @notice the Reward distribution borrow state of each iToken\\n    mapping(address => DistributionState) public distributionBorrowState;\\n\\n    /// @notice the Reward distribution state of each account of each iToken\\n    mapping(address => mapping(address => uint256))\\n        public distributionSupplierIndex;\\n    /// @notice the Reward distribution state of each account of each iToken\\n    mapping(address => mapping(address => uint256))\\n        public distributionBorrowerIndex;\\n\\n    /// @notice the Reward distributed into each account\\n    mapping(address => uint256) public reward;\\n\\n    /// @notice the Reward token address\\n    address public rewardToken;\\n\\n    /// @notice whether the reward distribution is paused\\n    bool public paused;\\n\\n    /// @notice the Reward distribution speed supply side of each iToken\\n    mapping(address => uint256) public distributionSupplySpeed;\\n\\n    /// @notice the global Reward distribution speed for supply\\n    uint256 public globalDistributionSupplySpeed;\\n\\n    /**\\n     * @dev Throws if called by any account other than the controller.\\n     */\\n    modifier onlyController() {\\n        require(\\n            address(controller) == msg.sender,\\n            \\\"onlyController: caller is not the controller\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @notice Initializes the contract.\\n     */\\n    function initialize(Controller _controller) external initializer {\\n        require(\\n            address(_controller) != address(0),\\n            \\\"initialize: controller address should not be zero address!\\\"\\n        );\\n        __Ownable_init();\\n        controller = _controller;\\n        paused = true;\\n    }\\n\\n    /**\\n     * @notice set reward token address\\n     * @dev Admin function, only owner can call this\\n     * @param _newRewardToken the address of reward token\\n     */\\n    function _setRewardToken(address _newRewardToken)\\n        external\\n        override\\n        onlyOwner\\n    {\\n        address _oldRewardToken = rewardToken;\\n        require(\\n            _newRewardToken != address(0) && _newRewardToken != _oldRewardToken,\\n            \\\"Reward token address invalid\\\"\\n        );\\n        rewardToken = _newRewardToken;\\n        emit NewRewardToken(_oldRewardToken, _newRewardToken);\\n    }\\n\\n    /**\\n     * @notice Add the iToken as receipient\\n     * @dev Admin function, only controller can call this\\n     * @param _iToken the iToken to add as recipient\\n     * @param _distributionFactor the distribution factor of the recipient\\n     */\\n    function _addRecipient(address _iToken, uint256 _distributionFactor)\\n        external\\n        override\\n        onlyController\\n    {\\n        distributionFactorMantissa[_iToken] = _distributionFactor;\\n        distributionSupplyState[_iToken] = DistributionState({\\n            index: 0,\\n            block: block.number\\n        });\\n        distributionBorrowState[_iToken] = DistributionState({\\n            index: 0,\\n            block: block.number\\n        });\\n\\n        emit NewRecipient(_iToken, _distributionFactor);\\n    }\\n\\n    /**\\n     * @notice Pause the reward distribution\\n     * @dev Admin function, pause will set global speed to 0 to stop the accumulation\\n     */\\n    function _pause() external override onlyOwner {\\n        // Set the global distribution speed to 0 to stop accumulation\\n        address[] memory _iTokens = controller.getAlliTokens();\\n        uint256 _len = _iTokens.length;\\n        for (uint256 i = 0; i < _len; i++) {\\n            _setDistributionBorrowSpeed(_iTokens[i], 0);\\n            _setDistributionSupplySpeed(_iTokens[i], 0);\\n        }\\n\\n        _refreshGlobalDistributionSpeeds();\\n\\n        _setPaused(true);\\n    }\\n\\n    /**\\n     * @notice Unpause and set distribution speeds\\n     * @dev Admin function\\n     * @param _borrowiTokens The borrow asset array\\n     * @param _borrowSpeeds  The borrow speed array\\n     * @param _supplyiTokens The supply asset array\\n     * @param _supplySpeeds  The supply speed array\\n     */\\n    function _unpause(\\n        address[] calldata _borrowiTokens,\\n        uint256[] calldata _borrowSpeeds,\\n        address[] calldata _supplyiTokens,\\n        uint256[] calldata _supplySpeeds\\n    ) external override onlyOwner {\\n        _setPaused(false);\\n\\n        _setDistributionSpeedsInternal(\\n            _borrowiTokens,\\n            _borrowSpeeds,\\n            _supplyiTokens,\\n            _supplySpeeds\\n        );\\n\\n        _refreshGlobalDistributionSpeeds();\\n    }\\n\\n    /**\\n     * @notice Pause/Unpause the reward distribution\\n     * @dev Admin function\\n     * @param _paused whether to pause/unpause the distribution\\n     */\\n    function _setPaused(bool _paused) internal {\\n        paused = _paused;\\n        emit Paused(_paused);\\n    }\\n\\n    /**\\n     * @notice Set distribution speeds\\n     * @dev Admin function, will fail when paused\\n     * @param _borrowiTokens The borrow asset array\\n     * @param _borrowSpeeds  The borrow speed array\\n     * @param _supplyiTokens The supply asset array\\n     * @param _supplySpeeds  The supply speed array\\n     */\\n    function _setDistributionSpeeds(\\n        address[] calldata _borrowiTokens,\\n        uint256[] calldata _borrowSpeeds,\\n        address[] calldata _supplyiTokens,\\n        uint256[] calldata _supplySpeeds\\n    ) external onlyOwner {\\n        require(!paused, \\\"Can not change speeds when paused\\\");\\n\\n        _setDistributionSpeedsInternal(\\n            _borrowiTokens,\\n            _borrowSpeeds,\\n            _supplyiTokens,\\n            _supplySpeeds\\n        );\\n\\n        _refreshGlobalDistributionSpeeds();\\n    }\\n\\n    function _setDistributionSpeedsInternal(\\n        address[] memory _borrowiTokens,\\n        uint256[] memory _borrowSpeeds,\\n        address[] memory _supplyiTokens,\\n        uint256[] memory _supplySpeeds\\n    ) internal {\\n        _setDistributionBorrowSpeedsInternal(_borrowiTokens, _borrowSpeeds);\\n        _setDistributionSupplySpeedsInternal(_supplyiTokens, _supplySpeeds);\\n    }\\n\\n    /**\\n     * @notice Set borrow distribution speeds\\n     * @dev Admin function, will fail when paused\\n     * @param _iTokens The borrow asset array\\n     * @param _borrowSpeeds  The borrow speed array\\n     */\\n    function _setDistributionBorrowSpeeds(\\n        address[] calldata _iTokens,\\n        uint256[] calldata _borrowSpeeds\\n    ) external onlyOwner {\\n        require(!paused, \\\"Can not change borrow speeds when paused\\\");\\n\\n        _setDistributionBorrowSpeedsInternal(_iTokens, _borrowSpeeds);\\n\\n        _refreshGlobalDistributionSpeeds();\\n    }\\n\\n    /**\\n     * @notice Set supply distribution speeds\\n     * @dev Admin function, will fail when paused\\n     * @param _iTokens The supply asset array\\n     * @param _supplySpeeds The supply speed array\\n     */\\n    function _setDistributionSupplySpeeds(\\n        address[] calldata _iTokens,\\n        uint256[] calldata _supplySpeeds\\n    ) external onlyOwner {\\n        require(!paused, \\\"Can not change supply speeds when paused\\\");\\n\\n        _setDistributionSupplySpeedsInternal(_iTokens, _supplySpeeds);\\n\\n        _refreshGlobalDistributionSpeeds();\\n    }\\n\\n    function _refreshGlobalDistributionSpeeds() internal {\\n        address[] memory _iTokens = controller.getAlliTokens();\\n        uint256 _len = _iTokens.length;\\n        uint256 _borrowSpeed;\\n        uint256 _supplySpeed;\\n        for (uint256 i = 0; i < _len; i++) {\\n            _borrowSpeed = _borrowSpeed.add(distributionSpeed[_iTokens[i]]);\\n            _supplySpeed = _supplySpeed.add(\\n                distributionSupplySpeed[_iTokens[i]]\\n            );\\n        }\\n\\n        globalDistributionSpeed = _borrowSpeed;\\n        globalDistributionSupplySpeed = _supplySpeed;\\n\\n        emit GlobalDistributionSpeedsUpdated(_borrowSpeed, _supplySpeed);\\n    }\\n\\n    function _setDistributionBorrowSpeedsInternal(\\n        address[] memory _iTokens,\\n        uint256[] memory _borrowSpeeds\\n    ) internal {\\n        require(\\n            _iTokens.length == _borrowSpeeds.length,\\n            \\\"Length of _iTokens and _borrowSpeeds mismatch\\\"\\n        );\\n\\n        uint256 _len = _iTokens.length;\\n        for (uint256 i = 0; i < _len; i++) {\\n            _setDistributionBorrowSpeed(_iTokens[i], _borrowSpeeds[i]);\\n        }\\n    }\\n\\n    function _setDistributionSupplySpeedsInternal(\\n        address[] memory _iTokens,\\n        uint256[] memory _supplySpeeds\\n    ) internal {\\n        require(\\n            _iTokens.length == _supplySpeeds.length,\\n            \\\"Length of _iTokens and _supplySpeeds mismatch\\\"\\n        );\\n\\n        uint256 _len = _iTokens.length;\\n        for (uint256 i = 0; i < _len; i++) {\\n            _setDistributionSupplySpeed(_iTokens[i], _supplySpeeds[i]);\\n        }\\n    }\\n\\n    function _setDistributionBorrowSpeed(address _iToken, uint256 _borrowSpeed)\\n        internal\\n    {\\n        // iToken must have been listed\\n        require(controller.hasiToken(_iToken), \\\"Token has not been listed\\\");\\n\\n        // Update borrow state before updating new speed\\n        _updateDistributionState(_iToken, true);\\n\\n        distributionSpeed[_iToken] = _borrowSpeed;\\n        emit DistributionBorrowSpeedUpdated(_iToken, _borrowSpeed);\\n    }\\n\\n    function _setDistributionSupplySpeed(address _iToken, uint256 _supplySpeed)\\n        internal\\n    {\\n        // iToken must have been listed\\n        require(controller.hasiToken(_iToken), \\\"Token has not been listed\\\");\\n\\n        // Update supply state before updating new speed\\n        _updateDistributionState(_iToken, false);\\n\\n        distributionSupplySpeed[_iToken] = _supplySpeed;\\n        emit DistributionSupplySpeedUpdated(_iToken, _supplySpeed);\\n    }\\n\\n    /**\\n     * @notice Update the iToken's  Reward distribution state\\n     * @dev Will be called every time when the iToken's supply/borrow changes\\n     * @param _iToken The iToken to be updated\\n     * @param _isBorrow whether to update the borrow state\\n     */\\n    function updateDistributionState(address _iToken, bool _isBorrow)\\n        external\\n        override\\n    {\\n        // Skip all updates if it is paused\\n        if (paused) {\\n            return;\\n        }\\n\\n        _updateDistributionState(_iToken, _isBorrow);\\n    }\\n\\n    function _updateDistributionState(address _iToken, bool _isBorrow)\\n        internal\\n    {\\n        require(controller.hasiToken(_iToken), \\\"Token has not been listed\\\");\\n\\n        DistributionState storage state =\\n            _isBorrow\\n                ? distributionBorrowState[_iToken]\\n                : distributionSupplyState[_iToken];\\n\\n        uint256 _speed =\\n            _isBorrow\\n                ? distributionSpeed[_iToken]\\n                : distributionSupplySpeed[_iToken];\\n\\n        uint256 _blockNumber = block.number;\\n        uint256 _deltaBlocks = _blockNumber.sub(state.block);\\n\\n        if (_deltaBlocks > 0 && _speed > 0) {\\n            uint256 _totalToken =\\n                _isBorrow\\n                    ? IiToken(_iToken).totalBorrows()\\n                    : IERC20Upgradeable(_iToken).totalSupply();\\n            uint256 _totalDistributed = _speed.mul(_deltaBlocks);\\n\\n            // Reward distributed per token since last time\\n            uint256 _distributedPerToken =\\n                _totalToken > 0 ? _totalDistributed.rdiv(_totalToken) : 0;\\n\\n            state.index = state.index.add(_distributedPerToken);\\n        }\\n\\n        state.block = _blockNumber;\\n    }\\n\\n    /**\\n     * @notice Update the account's Reward distribution state\\n     * @dev Will be called every time when the account's supply/borrow changes\\n     * @param _iToken The iToken to be updated\\n     * @param _account The account to be updated\\n     * @param _isBorrow whether to update the borrow state\\n     */\\n    function updateReward(\\n        address _iToken,\\n        address _account,\\n        bool _isBorrow\\n    ) external override {\\n        // Skip all updates if it is paused\\n        if (paused) {\\n            return;\\n        }\\n\\n        _updateReward(_iToken, _account, _isBorrow);\\n    }\\n\\n    function _updateReward(\\n        address _iToken,\\n        address _account,\\n        bool _isBorrow\\n    ) internal {\\n        require(_account != address(0), \\\"Invalid account address!\\\");\\n        require(controller.hasiToken(_iToken), \\\"Token has not been listed\\\");\\n\\n        uint256 _iTokenIndex;\\n        uint256 _accountIndex;\\n        uint256 _accountBalance;\\n        if (_isBorrow) {\\n            _iTokenIndex = distributionBorrowState[_iToken].index;\\n            _accountIndex = distributionBorrowerIndex[_iToken][_account];\\n            _accountBalance = IiToken(_iToken).borrowBalanceStored(_account);\\n\\n            // Update the account state to date\\n            distributionBorrowerIndex[_iToken][_account] = _iTokenIndex;\\n        } else {\\n            _iTokenIndex = distributionSupplyState[_iToken].index;\\n            _accountIndex = distributionSupplierIndex[_iToken][_account];\\n            _accountBalance = IERC20Upgradeable(_iToken).balanceOf(_account);\\n\\n            // Update the account state to date\\n            distributionSupplierIndex[_iToken][_account] = _iTokenIndex;\\n        }\\n\\n        uint256 _deltaIndex = _iTokenIndex.sub(_accountIndex);\\n        uint256 _amount = _accountBalance.rmul(_deltaIndex);\\n\\n        if (_amount > 0) {\\n            reward[_account] = reward[_account].add(_amount);\\n\\n            emit RewardDistributed(_iToken, _account, _amount, _accountIndex);\\n        }\\n    }\\n\\n    /**\\n     * @notice Update reward accrued in iTokens by the holders regardless of paused or not\\n     * @param _holders The account to update\\n     * @param _iTokens The _iTokens to update\\n     */\\n    function updateRewardBatch(\\n        address[] memory _holders,\\n        address[] memory _iTokens\\n    ) public override {\\n        // Update rewards for all _iTokens for holders\\n        for (uint256 i = 0; i < _iTokens.length; i++) {\\n            address _iToken = _iTokens[i];\\n            _updateDistributionState(_iToken, false);\\n            _updateDistributionState(_iToken, true);\\n            for (uint256 j = 0; j < _holders.length; j++) {\\n                _updateReward(_iToken, _holders[j], false);\\n                _updateReward(_iToken, _holders[j], true);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Update reward accrued in iTokens by the holders regardless of paused or not\\n     * @param _holders The account to update\\n     * @param _iTokens The _iTokens to update\\n     * @param _isBorrow whether to update the borrow state\\n     */\\n    function _updateRewards(\\n        address[] memory _holders,\\n        address[] memory _iTokens,\\n        bool _isBorrow\\n    ) internal {\\n        // Update rewards for all _iTokens for holders\\n        for (uint256 i = 0; i < _iTokens.length; i++) {\\n            address _iToken = _iTokens[i];\\n            _updateDistributionState(_iToken, _isBorrow);\\n            for (uint256 j = 0; j < _holders.length; j++) {\\n                _updateReward(_iToken, _holders[j], _isBorrow);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Claim reward accrued in iTokens by the holders\\n     * @param _holders The account to claim for\\n     * @param _iTokens The _iTokens to claim from\\n     */\\n    function claimReward(address[] memory _holders, address[] memory _iTokens)\\n        public\\n        override\\n    {\\n        updateRewardBatch(_holders, _iTokens);\\n\\n        // Withdraw all reward for all holders\\n        for (uint256 j = 0; j < _holders.length; j++) {\\n            address _account = _holders[j];\\n            uint256 _reward = reward[_account];\\n            if (_reward > 0) {\\n                reward[_account] = 0;\\n                IERC20Upgradeable(rewardToken).safeTransfer(_account, _reward);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Claim reward accrued in iTokens by the holders\\n     * @param _holders The account to claim for\\n     * @param _suppliediTokens The _suppliediTokens to claim from\\n     * @param _borrowediTokens The _borrowediTokens to claim from\\n     */\\n    function claimRewards(address[] memory _holders, address[] memory _suppliediTokens, address[] memory _borrowediTokens)\\n        external\\n        override\\n    {\\n        _updateRewards(_holders, _suppliediTokens, false);\\n        _updateRewards(_holders, _borrowediTokens, true);\\n\\n        // Withdraw all reward for all holders\\n        for (uint256 j = 0; j < _holders.length; j++) {\\n            address _account = _holders[j];\\n            uint256 _reward = reward[_account];\\n            if (_reward > 0) {\\n                reward[_account] = 0;\\n                IERC20Upgradeable(rewardToken).safeTransfer(_account, _reward);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Claim reward accrued in all iTokens by the holders\\n     * @param _holders The account to claim for\\n     */\\n    function claimAllReward(address[] memory _holders) external override {\\n        claimReward(_holders, controller.getAlliTokens());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC20Upgradeable.sol\\\";\\nimport \\\"../../math/SafeMathUpgradeable.sol\\\";\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20Upgradeable {\\n    using SafeMathUpgradeable for uint256;\\n    using AddressUpgradeable for address;\\n\\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IiToken.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\nimport \\\"./IInterestRateModelInterface.sol\\\";\\nimport \\\"./IControllerInterface.sol\\\";\\n\\ninterface IiToken {\\n    function isSupported() external returns (bool);\\n    \\n    function isiToken() external returns (bool);\\n\\n    //----------------------------------\\n    //********* User Interface *********\\n    //----------------------------------\\n    function mint(address recipient, uint256 mintAmount) external;\\n\\n    function redeem(address from, uint256 redeemTokens) external;\\n\\n    function redeemUnderlying(address from, uint256 redeemAmount) external;\\n\\n    function borrow(uint256 borrowAmount) external;\\n\\n    function repayBorrow(uint256 repayAmount) external;\\n\\n    function repayBorrowBehalf(address borrower, uint256 repayAmount) external;\\n\\n    function liquidateBorrow(\\n        address borrower,\\n        uint256 repayAmount,\\n        address iTokenCollateral\\n    ) external;\\n\\n    function flashloan(\\n        address recipient,\\n        uint256 loanAmount,\\n        bytes memory data\\n    ) external;\\n\\n    function seize(\\n        address _liquidator,\\n        address _borrower,\\n        uint256 _seizeTokens\\n    ) external;\\n\\n    function updateInterest() external returns (bool);\\n\\n    function controller() external view returns (address);\\n\\n    function exchangeRateCurrent() external returns (uint256);\\n\\n    function exchangeRateStored() external view returns (uint256);\\n\\n    function totalBorrowsCurrent() external returns (uint256);\\n\\n    function totalBorrows() external view returns (uint256);\\n\\n    function borrowBalanceCurrent(address _user) external returns (uint256);\\n\\n    function borrowBalanceStored(address _user) external view returns (uint256);\\n\\n    function borrowIndex() external view returns (uint256);\\n\\n    function getAccountSnapshot(address _account)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function borrowRatePerBlock() external view returns (uint256);\\n\\n    function supplyRatePerBlock() external view returns (uint256);\\n\\n    function getCash() external view returns (uint256);\\n\\n    //----------------------------------\\n    //********* Owner Actions **********\\n    //----------------------------------\\n\\n    function _setNewReserveRatio(uint256 _newReserveRatio) external;\\n\\n    function _setNewFlashloanFeeRatio(uint256 _newFlashloanFeeRatio) external;\\n\\n    function _setNewProtocolFeeRatio(uint256 _newProtocolFeeRatio) external;\\n\\n    function _setController(IControllerInterface _newController) external;\\n\\n    function _setInterestRateModel(\\n        IInterestRateModelInterface _newInterestRateModel\\n    ) external;\\n\\n    function _withdrawReserves(uint256 _withdrawAmount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IRewardDistributorV3.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\ninterface IRewardDistributorV3 {\\n    function _setRewardToken(address newRewardToken) external;\\n\\n    /// @notice Emitted reward token address is changed by admin\\n    event NewRewardToken(address oldRewardToken, address newRewardToken);\\n\\n    function _addRecipient(address _iToken, uint256 _distributionFactor)\\n        external;\\n\\n    event NewRecipient(address iToken, uint256 distributionFactor);\\n\\n    /// @notice Emitted when mint is paused/unpaused by admin\\n    event Paused(bool paused);\\n\\n    function _pause() external;\\n\\n    function _unpause(\\n        address[] calldata _borrowiTokens,\\n        uint256[] calldata _borrowSpeeds,\\n        address[] calldata _supplyiTokens,\\n        uint256[] calldata _supplySpeeds\\n    ) external;\\n\\n    /// @notice Emitted when Global Distribution speed for both supply and borrow are updated\\n    event GlobalDistributionSpeedsUpdated(\\n        uint256 borrowSpeed,\\n        uint256 supplySpeed\\n    );\\n\\n    /// @notice Emitted when iToken's Distribution borrow speed is updated\\n    event DistributionBorrowSpeedUpdated(address iToken, uint256 borrowSpeed);\\n\\n    /// @notice Emitted when iToken's Distribution supply speed is updated\\n    event DistributionSupplySpeedUpdated(address iToken, uint256 supplySpeed);\\n\\n    /// @notice Emitted when iToken's Distribution factor is changed by admin\\n    event NewDistributionFactor(\\n        address iToken,\\n        uint256 oldDistributionFactorMantissa,\\n        uint256 newDistributionFactorMantissa\\n    );\\n\\n    function updateDistributionState(address _iToken, bool _isBorrow) external;\\n\\n    function updateReward(\\n        address _iToken,\\n        address _account,\\n        bool _isBorrow\\n    ) external;\\n\\n    function updateRewardBatch(\\n        address[] memory _holders,\\n        address[] memory _iTokens\\n    ) external;\\n\\n    function claimReward(address[] memory _holders, address[] memory _iTokens)\\n        external;\\n\\n    function claimAllReward(address[] memory _holders) external;\\n\\n    function claimRewards(address[] memory _holders, address[] memory _suppliediTokens, address[] memory _borrowediTokens) external;\\n\\n    /// @notice Emitted when reward of amount is distributed into account\\n    event RewardDistributed(\\n        address iToken,\\n        address account,\\n        uint256 amount,\\n        uint256 accountIndex\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IPriceOracle.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\nimport \\\"./IiToken.sol\\\";\\n\\ninterface IPriceOracle {\\n    /**\\n     * @notice Get the underlying price of a iToken asset\\n     * @param _iToken The iToken to get the underlying price of\\n     * @return The underlying asset price mantissa (scaled by 1e18).\\n     *  Zero means the price is unavailable.\\n     */\\n    function getUnderlyingPrice(address _iToken)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @notice Get the price of a underlying asset\\n     * @param _iToken The iToken to get the underlying price of\\n     * @return The underlying asset price mantissa (scaled by 1e18).\\n     *  Zero means the price is unavailable and whether the price is valid.\\n     */\\n    function getUnderlyingPriceAndStatus(address _iToken)\\n        external\\n        view\\n        returns (uint256, bool);\\n}\\n\"\r\n    },\r\n    \"contracts/library/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(\\n            !_initialized,\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n\\n        _;\\n\\n        _initialized = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/library/Ownable.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {_setPendingOwner} and {_acceptOwner}.\\n */\\ncontract Ownable {\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    address payable public owner;\\n\\n    /**\\n     * @dev Returns the address of the current pending owner.\\n     */\\n    address payable public pendingOwner;\\n\\n    event NewOwner(address indexed previousOwner, address indexed newOwner);\\n    event NewPendingOwner(\\n        address indexed oldPendingOwner,\\n        address indexed newPendingOwner\\n    );\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner == msg.sender, \\\"onlyOwner: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal {\\n        owner = msg.sender;\\n        emit NewOwner(address(0), msg.sender);\\n    }\\n\\n    /**\\n     * @notice Base on the inputing parameter `newPendingOwner` to check the exact error reason.\\n     * @dev Transfer contract control to a new owner. The newPendingOwner must call `_acceptOwner` to finish the transfer.\\n     * @param newPendingOwner New pending owner.\\n     */\\n    function _setPendingOwner(address payable newPendingOwner)\\n        external\\n        onlyOwner\\n    {\\n        require(\\n            newPendingOwner != address(0) && newPendingOwner != pendingOwner,\\n            \\\"_setPendingOwner: New owenr can not be zero address and owner has been set!\\\"\\n        );\\n\\n        // Gets current owner.\\n        address oldPendingOwner = pendingOwner;\\n\\n        // Sets new pending owner.\\n        pendingOwner = newPendingOwner;\\n\\n        emit NewPendingOwner(oldPendingOwner, newPendingOwner);\\n    }\\n\\n    /**\\n     * @dev Accepts the admin rights, but only for pendingOwenr.\\n     */\\n    function _acceptOwner() external {\\n        require(\\n            msg.sender == pendingOwner,\\n            \\\"_acceptOwner: Only for pending owner!\\\"\\n        );\\n\\n        // Gets current values for events.\\n        address oldOwner = owner;\\n        address oldPendingOwner = pendingOwner;\\n\\n        // Set the new contract owner.\\n        owner = pendingOwner;\\n\\n        // Clear the pendingOwner.\\n        pendingOwner = address(0);\\n\\n        emit NewOwner(oldOwner, owner);\\n        emit NewPendingOwner(oldPendingOwner, pendingOwner);\\n    }\\n\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/library/SafeRatioMath.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\\\";\\n\\nlibrary SafeRatioMath {\\n    using SafeMathUpgradeable for uint256;\\n\\n    uint256 private constant BASE = 10**18;\\n    uint256 private constant DOUBLE = 10**36;\\n\\n    function divup(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = x.add(y.sub(1)).div(y);\\n    }\\n\\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = x.mul(y).div(BASE);\\n    }\\n\\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = x.mul(BASE).div(y);\\n    }\\n\\n    function rdivup(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = x.mul(BASE).add(y.sub(1)).div(y);\\n    }\\n\\n    function tmul(\\n        uint256 x,\\n        uint256 y,\\n        uint256 z\\n    ) internal pure returns (uint256 result) {\\n        result = x.mul(y).mul(z).div(DOUBLE);\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 base\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            switch x\\n                case 0 {\\n                    switch n\\n                        case 0 {\\n                            z := base\\n                        }\\n                        default {\\n                            z := 0\\n                        }\\n                }\\n                default {\\n                    switch mod(n, 2)\\n                        case 0 {\\n                            z := base\\n                        }\\n                        default {\\n                            z := x\\n                        }\\n                    let half := div(base, 2) // for rounding.\\n\\n                    for {\\n                        n := div(n, 2)\\n                    } n {\\n                        n := div(n, 2)\\n                    } {\\n                        let xx := mul(x, x)\\n                        if iszero(eq(div(xx, x), x)) {\\n                            revert(0, 0)\\n                        }\\n                        let xxRound := add(xx, half)\\n                        if lt(xxRound, xx) {\\n                            revert(0, 0)\\n                        }\\n                        x := div(xxRound, base)\\n                        if mod(n, 2) {\\n                            let zx := mul(z, x)\\n                            if and(\\n                                iszero(iszero(x)),\\n                                iszero(eq(div(zx, x), z))\\n                            ) {\\n                                revert(0, 0)\\n                            }\\n                            let zxRound := add(zx, half)\\n                            if lt(zxRound, zx) {\\n                                revert(0, 0)\\n                            }\\n                            z := div(zxRound, base)\\n                        }\\n                    }\\n                }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Controller.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/EnumerableSetUpgradeable.sol\\\";\\n\\nimport \\\"./interface/IControllerInterface.sol\\\";\\nimport \\\"./interface/IPriceOracle.sol\\\";\\nimport \\\"./interface/IiToken.sol\\\";\\nimport \\\"./interface/IRewardDistributor.sol\\\";\\n\\nimport \\\"./library/Initializable.sol\\\";\\nimport \\\"./library/Ownable.sol\\\";\\nimport \\\"./library/SafeRatioMath.sol\\\";\\n\\n/**\\n * @title dForce's lending controller Contract\\n * @author dForce\\n */\\ncontract Controller is Initializable, Ownable, IControllerInterface {\\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\\n    using SafeRatioMath for uint256;\\n    using SafeMathUpgradeable for uint256;\\n    using SafeERC20Upgradeable for IERC20Upgradeable;\\n\\n    /// @dev EnumerableSet of all iTokens\\n    EnumerableSetUpgradeable.AddressSet internal iTokens;\\n\\n    struct Market {\\n        /*\\n         *  Multiplier representing the most one can borrow against their collateral in this market.\\n         *  For instance, 0.9 to allow borrowing 90% of collateral value.\\n         *  Must be in [0, 0.9], and stored as a mantissa.\\n         */\\n        uint256 collateralFactorMantissa;\\n        /*\\n         *  Multiplier representing the most one can borrow the asset.\\n         *  For instance, 0.5 to allow borrowing this asset 50% * collateral value * collateralFactor.\\n         *  When calculating equity, 0.5 with 100 borrow balance will produce 200 borrow value\\n         *  Must be between (0, 1], and stored as a mantissa.\\n         */\\n        uint256 borrowFactorMantissa;\\n        /*\\n         *  The borrow capacity of the asset, will be checked in beforeBorrow()\\n         *  -1 means there is no limit on the capacity\\n         *  0 means the asset can not be borrowed any more\\n         */\\n        uint256 borrowCapacity;\\n        /*\\n         *  The supply capacity of the asset, will be checked in beforeMint()\\n         *  -1 means there is no limit on the capacity\\n         *  0 means the asset can not be supplied any more\\n         */\\n        uint256 supplyCapacity;\\n        // Whether market's mint is paused\\n        bool mintPaused;\\n        // Whether market's redeem is paused\\n        bool redeemPaused;\\n        // Whether market's borrow is paused\\n        bool borrowPaused;\\n    }\\n\\n    /// @notice Mapping of iTokens to corresponding markets\\n    mapping(address => Market) public markets;\\n\\n    struct AccountData {\\n        // Account's collateral assets\\n        EnumerableSetUpgradeable.AddressSet collaterals;\\n        // Account's borrowed assets\\n        EnumerableSetUpgradeable.AddressSet borrowed;\\n    }\\n\\n    /// @dev Mapping of accounts' data, including collateral and borrowed assets\\n    mapping(address => AccountData) internal accountsData;\\n\\n    /**\\n     * @notice Oracle to query the price of a given asset\\n     */\\n    address public priceOracle;\\n\\n    /**\\n     * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\\n     */\\n    uint256 public closeFactorMantissa;\\n\\n    // closeFactorMantissa must be strictly greater than this value\\n    uint256 internal constant closeFactorMinMantissa = 0.05e18; // 0.05\\n\\n    // closeFactorMantissa must not exceed this value\\n    uint256 internal constant closeFactorMaxMantissa = 0.9e18; // 0.9\\n\\n    /**\\n     * @notice Multiplier representing the discount on collateral that a liquidator receives\\n     */\\n    uint256 public liquidationIncentiveMantissa;\\n\\n    // liquidationIncentiveMantissa must be no less than this value\\n    uint256 internal constant liquidationIncentiveMinMantissa = 1.0e18; // 1.0\\n\\n    // liquidationIncentiveMantissa must be no greater than this value\\n    uint256 internal constant liquidationIncentiveMaxMantissa = 1.5e18; // 1.5\\n\\n    // collateralFactorMantissa must not exceed this value\\n    uint256 internal constant collateralFactorMaxMantissa = 1e18; // 1.0\\n\\n    // borrowFactorMantissa must not exceed this value\\n    uint256 internal constant borrowFactorMaxMantissa = 1e18; // 1.0\\n\\n    /**\\n     * @notice Guardian who can pause mint/borrow/liquidate/transfer in case of emergency\\n     */\\n    address public pauseGuardian;\\n\\n    /// @notice whether global transfer is paused\\n    bool public transferPaused;\\n\\n    /// @notice whether global seize is paused\\n    bool public seizePaused;\\n\\n    /**\\n     * @notice the address of reward distributor\\n     */\\n    address public rewardDistributor;\\n\\n    /**\\n     * @dev Check if called by owner or pauseGuardian, and only owner can unpause\\n     */\\n    modifier checkPauser(bool _paused) {\\n        require(\\n            msg.sender == owner || (msg.sender == pauseGuardian && _paused),\\n            \\\"Only owner and guardian can pause and only owner can unpause\\\"\\n        );\\n\\n        _;\\n    }\\n\\n    /**\\n     * @notice Initializes the contract.\\n     */\\n    function initialize() external initializer {\\n        __Ownable_init();\\n    }\\n\\n    /*********************************/\\n    /******** Security Check *********/\\n    /*********************************/\\n\\n    /**\\n     * @notice Ensure this is a Controller contract.\\n     */\\n    function isController() external view override returns (bool) {\\n        return true;\\n    }\\n\\n    /*********************************/\\n    /******** Admin Operations *******/\\n    /*********************************/\\n\\n    /**\\n     * @notice Admin function to add iToken into supported markets\\n     * Checks if the iToken already exsits\\n     * Will `revert()` if any check fails\\n     * @param _iToken The _iToken to add\\n     * @param _collateralFactor The _collateralFactor of _iToken\\n     * @param _borrowFactor The _borrowFactor of _iToken\\n     * @param _supplyCapacity The _supplyCapacity of _iToken\\n     * @param _distributionFactor The _distributionFactor of _iToken\\n     */\\n    function _addMarket(\\n        address _iToken,\\n        uint256 _collateralFactor,\\n        uint256 _borrowFactor,\\n        uint256 _supplyCapacity,\\n        uint256 _borrowCapacity,\\n        uint256 _distributionFactor\\n    ) external override onlyOwner {\\n        require(IiToken(_iToken).isSupported(), \\\"Token is not supported\\\");\\n\\n        // Market must not have been listed, EnumerableSet.add() will return false if it exsits\\n        require(iTokens.add(_iToken), \\\"Token has already been listed\\\");\\n\\n        require(\\n            _collateralFactor <= collateralFactorMaxMantissa,\\n            \\\"Collateral factor invalid\\\"\\n        );\\n\\n        require(\\n            _borrowFactor > 0 && _borrowFactor <= borrowFactorMaxMantissa,\\n            \\\"Borrow factor invalid\\\"\\n        );\\n\\n        // Its value will be taken into account when calculate account equity\\n        // Check if the price is available for the calculation\\n        require(\\n            IPriceOracle(priceOracle).getUnderlyingPrice(_iToken) != 0,\\n            \\\"Underlying price is unavailable\\\"\\n        );\\n\\n        markets[_iToken] = Market({\\n            collateralFactorMantissa: _collateralFactor,\\n            borrowFactorMantissa: _borrowFactor,\\n            borrowCapacity: _borrowCapacity,\\n            supplyCapacity: _supplyCapacity,\\n            mintPaused: false,\\n            redeemPaused: false,\\n            borrowPaused: false\\n        });\\n\\n        IRewardDistributor(rewardDistributor)._addRecipient(\\n            _iToken,\\n            _distributionFactor\\n        );\\n\\n        emit MarketAdded(\\n            _iToken,\\n            _collateralFactor,\\n            _borrowFactor,\\n            _supplyCapacity,\\n            _borrowCapacity,\\n            _distributionFactor\\n        );\\n    }\\n\\n    /**\\n     * @notice Sets price oracle\\n     * @dev Admin function to set price oracle\\n     * @param _newOracle New oracle contract\\n     */\\n    function _setPriceOracle(address _newOracle) external override onlyOwner {\\n        address _oldOracle = priceOracle;\\n        require(\\n            _newOracle != address(0) && _newOracle != _oldOracle,\\n            \\\"Oracle address invalid\\\"\\n        );\\n        priceOracle = _newOracle;\\n        emit NewPriceOracle(_oldOracle, _newOracle);\\n    }\\n\\n    /**\\n     * @notice Sets the closeFactor used when liquidating borrows\\n     * @dev Admin function to set closeFactor\\n     * @param _newCloseFactorMantissa New close factor, scaled by 1e18\\n     */\\n    function _setCloseFactor(uint256 _newCloseFactorMantissa)\\n        external\\n        override\\n        onlyOwner\\n    {\\n        require(\\n            _newCloseFactorMantissa >= closeFactorMinMantissa &&\\n                _newCloseFactorMantissa <= closeFactorMaxMantissa,\\n            \\\"Close factor invalid\\\"\\n        );\\n\\n        uint256 _oldCloseFactorMantissa = closeFactorMantissa;\\n        closeFactorMantissa = _newCloseFactorMantissa;\\n        emit NewCloseFactor(_oldCloseFactorMantissa, _newCloseFactorMantissa);\\n    }\\n\\n    /**\\n     * @notice Sets liquidationIncentive\\n     * @dev Admin function to set liquidationIncentive\\n     * @param _newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\\n     */\\n    function _setLiquidationIncentive(uint256 _newLiquidationIncentiveMantissa)\\n        external\\n        override\\n        onlyOwner\\n    {\\n        require(\\n            _newLiquidationIncentiveMantissa >=\\n                liquidationIncentiveMinMantissa &&\\n                _newLiquidationIncentiveMantissa <=\\n                liquidationIncentiveMaxMantissa,\\n            \\\"Liquidation incentive invalid\\\"\\n        );\\n\\n        uint256 _oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\\n        liquidationIncentiveMantissa = _newLiquidationIncentiveMantissa;\\n\\n        emit NewLiquidationIncentive(\\n            _oldLiquidationIncentiveMantissa,\\n            _newLiquidationIncentiveMantissa\\n        );\\n    }\\n\\n    /**\\n     * @notice Sets the collateralFactor for a iToken\\n     * @dev Admin function to set collateralFactor for a iToken\\n     * @param _iToken The token to set the factor on\\n     * @param _newCollateralFactorMantissa The new collateral factor, scaled by 1e18\\n     */\\n    function _setCollateralFactor(\\n        address _iToken,\\n        uint256 _newCollateralFactorMantissa\\n    ) external override onlyOwner {\\n        _checkiTokenListed(_iToken);\\n\\n        require(\\n            _newCollateralFactorMantissa <= collateralFactorMaxMantissa,\\n            \\\"Collateral factor invalid\\\"\\n        );\\n\\n        // Its value will be taken into account when calculate account equity\\n        // Check if the price is available for the calculation\\n        require(\\n            IPriceOracle(priceOracle).getUnderlyingPrice(_iToken) != 0,\\n            \\\"Failed to set collateral factor, underlying price is unavailable\\\"\\n        );\\n\\n        Market storage _market = markets[_iToken];\\n        uint256 _oldCollateralFactorMantissa = _market.collateralFactorMantissa;\\n        _market.collateralFactorMantissa = _newCollateralFactorMantissa;\\n\\n        emit NewCollateralFactor(\\n            _iToken,\\n            _oldCollateralFactorMantissa,\\n            _newCollateralFactorMantissa\\n        );\\n    }\\n\\n    /**\\n     * @notice Sets the borrowFactor for a iToken\\n     * @dev Admin function to set borrowFactor for a iToken\\n     * @param _iToken The token to set the factor on\\n     * @param _newBorrowFactorMantissa The new borrow factor, scaled by 1e18\\n     */\\n    function _setBorrowFactor(address _iToken, uint256 _newBorrowFactorMantissa)\\n        external\\n        override\\n        onlyOwner\\n    {\\n        _checkiTokenListed(_iToken);\\n\\n        require(\\n            _newBorrowFactorMantissa > 0 &&\\n                _newBorrowFactorMantissa <= borrowFactorMaxMantissa,\\n            \\\"Borrow factor invalid\\\"\\n        );\\n\\n        // Its value will be taken into account when calculate account equity\\n        // Check if the price is available for the calculation\\n        require(\\n            IPriceOracle(priceOracle).getUnderlyingPrice(_iToken) != 0,\\n            \\\"Failed to set borrow factor, underlying price is unavailable\\\"\\n        );\\n\\n        Market storage _market = markets[_iToken];\\n        uint256 _oldBorrowFactorMantissa = _market.borrowFactorMantissa;\\n        _market.borrowFactorMantissa = _newBorrowFactorMantissa;\\n\\n        emit NewBorrowFactor(\\n            _iToken,\\n            _oldBorrowFactorMantissa,\\n            _newBorrowFactorMantissa\\n        );\\n    }\\n\\n    /**\\n     * @notice Sets the borrowCapacity for a iToken\\n     * @dev Admin function to set borrowCapacity for a iToken\\n     * @param _iToken The token to set the capacity on\\n     * @param _newBorrowCapacity The new borrow capacity\\n     */\\n    function _setBorrowCapacity(address _iToken, uint256 _newBorrowCapacity)\\n        external\\n        override\\n        onlyOwner\\n    {\\n        _checkiTokenListed(_iToken);\\n\\n        Market storage _market = markets[_iToken];\\n        uint256 oldBorrowCapacity = _market.borrowCapacity;\\n        _market.borrowCapacity = _newBorrowCapacity;\\n\\n        emit NewBorrowCapacity(_iToken, oldBorrowCapacity, _newBorrowCapacity);\\n    }\\n\\n    /**\\n     * @notice Sets the supplyCapacity for a iToken\\n     * @dev Admin function to set supplyCapacity for a iToken\\n     * @param _iToken The token to set the capacity on\\n     * @param _newSupplyCapacity The new supply capacity\\n     */\\n    function _setSupplyCapacity(address _iToken, uint256 _newSupplyCapacity)\\n        external\\n        override\\n        onlyOwner\\n    {\\n        _checkiTokenListed(_iToken);\\n\\n        Market storage _market = markets[_iToken];\\n        uint256 oldSupplyCapacity = _market.supplyCapacity;\\n        _market.supplyCapacity = _newSupplyCapacity;\\n\\n        emit NewSupplyCapacity(_iToken, oldSupplyCapacity, _newSupplyCapacity);\\n    }\\n\\n    /**\\n     * @notice Sets the pauseGuardian\\n     * @dev Admin function to set pauseGuardian\\n     * @param _newPauseGuardian The new pause guardian\\n     */\\n    function _setPauseGuardian(address _newPauseGuardian)\\n        external\\n        override\\n        onlyOwner\\n    {\\n        address _oldPauseGuardian = pauseGuardian;\\n\\n        require(\\n            _newPauseGuardian != address(0) &&\\n                _newPauseGuardian != _oldPauseGuardian,\\n            \\\"Pause guardian address invalid\\\"\\n        );\\n\\n        pauseGuardian = _newPauseGuardian;\\n\\n        emit NewPauseGuardian(_oldPauseGuardian, _newPauseGuardian);\\n    }\\n\\n    /**\\n     * @notice pause/unpause mint() for all iTokens\\n     * @dev Admin function, only owner and pauseGuardian can call this\\n     * @param _paused whether to pause or unpause\\n     */\\n    function _setAllMintPaused(bool _paused)\\n        external\\n        override\\n        checkPauser(_paused)\\n    {\\n        EnumerableSetUpgradeable.AddressSet storage _iTokens = iTokens;\\n        uint256 _len = _iTokens.length();\\n\\n        for (uint256 i = 0; i < _len; i++) {\\n            _setMintPausedInternal(_iTokens.at(i), _paused);\\n        }\\n    }\\n\\n    /**\\n     * @notice pause/unpause mint() for the iToken\\n     * @dev Admin function, only owner and pauseGuardian can call this\\n     * @param _iToken The iToken to pause/unpause\\n     * @param _paused whether to pause or unpause\\n     */\\n    function _setMintPaused(address _iToken, bool _paused)\\n        external\\n        override\\n        checkPauser(_paused)\\n    {\\n        _checkiTokenListed(_iToken);\\n\\n        _setMintPausedInternal(_iToken, _paused);\\n    }\\n\\n    function _setMintPausedInternal(address _iToken, bool _paused) internal {\\n        markets[_iToken].mintPaused = _paused;\\n        emit MintPaused(_iToken, _paused);\\n    }\\n\\n    /**\\n     * @notice pause/unpause redeem() for all iTokens\\n     * @dev Admin function, only owner and pauseGuardian can call this\\n     * @param _paused whether to pause or unpause\\n     */\\n    function _setAllRedeemPaused(bool _paused)\\n        external\\n        override\\n        checkPauser(_paused)\\n    {\\n        EnumerableSetUpgradeable.AddressSet storage _iTokens = iTokens;\\n        uint256 _len = _iTokens.length();\\n\\n        for (uint256 i = 0; i < _len; i++) {\\n            _setRedeemPausedInternal(_iTokens.at(i), _paused);\\n        }\\n    }\\n\\n    /**\\n     * @notice pause/unpause redeem() for the iToken\\n     * @dev Admin function, only owner and pauseGuardian can call this\\n     * @param _iToken The iToken to pause/unpause\\n     * @param _paused whether to pause or unpause\\n     */\\n    function _setRedeemPaused(address _iToken, bool _paused)\\n        external\\n        override\\n        checkPauser(_paused)\\n    {\\n        _checkiTokenListed(_iToken);\\n\\n        _setRedeemPausedInternal(_iToken, _paused);\\n    }\\n\\n    function _setRedeemPausedInternal(address _iToken, bool _paused) internal {\\n        markets[_iToken].redeemPaused = _paused;\\n        emit RedeemPaused(_iToken, _paused);\\n    }\\n\\n    /**\\n     * @notice pause/unpause borrow() for all iTokens\\n     * @dev Admin function, only owner and pauseGuardian can call this\\n     * @param _paused whether to pause or unpause\\n     */\\n    function _setAllBorrowPaused(bool _paused)\\n        external\\n        override\\n        checkPauser(_paused)\\n    {\\n        EnumerableSetUpgradeable.AddressSet storage _iTokens = iTokens;\\n        uint256 _len = _iTokens.length();\\n\\n        for (uint256 i = 0; i < _len; i++) {\\n            _setBorrowPausedInternal(_iTokens.at(i), _paused);\\n        }\\n    }\\n\\n    /**\\n     * @notice pause/unpause borrow() for the iToken\\n     * @dev Admin function, only owner and pauseGuardian can call this\\n     * @param _iToken The iToken to pause/unpause\\n     * @param _paused whether to pause or unpause\\n     */\\n    function _setBorrowPaused(address _iToken, bool _paused)\\n        external\\n        override\\n        checkPauser(_paused)\\n    {\\n        _checkiTokenListed(_iToken);\\n\\n        _setBorrowPausedInternal(_iToken, _paused);\\n    }\\n\\n    function _setBorrowPausedInternal(address _iToken, bool _paused) internal {\\n        markets[_iToken].borrowPaused = _paused;\\n        emit BorrowPaused(_iToken, _paused);\\n    }\\n\\n    /**\\n     * @notice pause/unpause global transfer()\\n     * @dev Admin function, only owner and pauseGuardian can call this\\n     * @param _paused whether to pause or unpause\\n     */\\n    function _setTransferPaused(bool _paused)\\n        external\\n        override\\n        checkPauser(_paused)\\n    {\\n        _setTransferPausedInternal(_paused);\\n    }\\n\\n    function _setTransferPausedInternal(bool _paused) internal {\\n        transferPaused = _paused;\\n        emit TransferPaused(_paused);\\n    }\\n\\n    /**\\n     * @notice pause/unpause global seize()\\n     * @dev Admin function, only owner and pauseGuardian can call this\\n     * @param _paused whether to pause or unpause\\n     */\\n    function _setSeizePaused(bool _paused)\\n        external\\n        override\\n        checkPauser(_paused)\\n    {\\n        _setSeizePausedInternal(_paused);\\n    }\\n\\n    function _setSeizePausedInternal(bool _paused) internal {\\n        seizePaused = _paused;\\n        emit SeizePaused(_paused);\\n    }\\n\\n    /**\\n     * @notice pause/unpause all actions iToken, including mint/redeem/borrow\\n     * @dev Admin function, only owner and pauseGuardian can call this\\n     * @param _paused whether to pause or unpause\\n     */\\n    function _setiTokenPaused(address _iToken, bool _paused)\\n        external\\n        override\\n        checkPauser(_paused)\\n    {\\n        _checkiTokenListed(_iToken);\\n\\n        _setiTokenPausedInternal(_iToken, _paused);\\n    }\\n\\n    function _setiTokenPausedInternal(address _iToken, bool _paused) internal {\\n        Market storage _market = markets[_iToken];\\n\\n        _market.mintPaused = _paused;\\n        emit MintPaused(_iToken, _paused);\\n\\n        _market.redeemPaused = _paused;\\n        emit RedeemPaused(_iToken, _paused);\\n\\n        _market.borrowPaused = _paused;\\n        emit BorrowPaused(_iToken, _paused);\\n    }\\n\\n    /**\\n     * @notice pause/unpause entire protocol, including mint/redeem/borrow/seize/transfer\\n     * @dev Admin function, only owner and pauseGuardian can call this\\n     * @param _paused whether to pause or unpause\\n     */\\n    function _setProtocolPaused(bool _paused)\\n        external\\n        override\\n        checkPauser(_paused)\\n    {\\n        EnumerableSetUpgradeable.AddressSet storage _iTokens = iTokens;\\n        uint256 _len = _iTokens.length();\\n\\n        for (uint256 i = 0; i < _len; i++) {\\n            address _iToken = _iTokens.at(i);\\n\\n            _setiTokenPausedInternal(_iToken, _paused);\\n        }\\n\\n        _setTransferPausedInternal(_paused);\\n        _setSeizePausedInternal(_paused);\\n    }\\n\\n    /**\\n     * @notice Sets Reward Distributor\\n     * @dev Admin function to set reward distributor\\n     * @param _newRewardDistributor new reward distributor\\n     */\\n    function _setRewardDistributor(address _newRewardDistributor)\\n        external\\n        override\\n        onlyOwner\\n    {\\n        address _oldRewardDistributor = rewardDistributor;\\n        require(\\n            _newRewardDistributor != address(0) &&\\n                _newRewardDistributor != _oldRewardDistributor,\\n            \\\"Reward Distributor address invalid\\\"\\n        );\\n\\n        rewardDistributor = _newRewardDistributor;\\n        emit NewRewardDistributor(_oldRewardDistributor, _newRewardDistributor);\\n    }\\n\\n    /*********************************/\\n    /******** Poclicy Hooks **********/\\n    /*********************************/\\n\\n    /**\\n     * @notice Hook function before iToken `mint()`\\n     * Checks if the account should be allowed to mint the given iToken\\n     * Will `revert()` if any check fails\\n     * @param _iToken The iToken to check the mint against\\n     * @param _minter The account which would get the minted tokens\\n     * @param _mintAmount The amount of underlying being minted to iToken\\n     */\\n    function beforeMint(\\n        address _iToken,\\n        address _minter,\\n        uint256 _mintAmount\\n    ) external override {\\n        _checkiTokenListed(_iToken);\\n\\n        Market storage _market = markets[_iToken];\\n        require(!_market.mintPaused, \\\"Token mint has been paused\\\");\\n\\n        // Check the iToken's supply capacity, -1 means no limit\\n        uint256 _totalSupplyUnderlying =\\n            IERC20Upgradeable(_iToken).totalSupply().rmul(\\n                IiToken(_iToken).exchangeRateStored()\\n            );\\n        require(\\n            _totalSupplyUnderlying.add(_mintAmount) <= _market.supplyCapacity,\\n            \\\"Token supply capacity reached\\\"\\n        );\\n\\n        // Update the Reward Distribution Supply state and distribute reward to suppplier\\n        IRewardDistributor(rewardDistributor).updateDistributionState(\\n            _iToken,\\n            false\\n        );\\n        IRewardDistributor(rewardDistributor).updateReward(\\n            _iToken,\\n            _minter,\\n            false\\n        );\\n    }\\n\\n    /**\\n     * @notice Hook function after iToken `mint()`\\n     * Will `revert()` if any operation fails\\n     * @param _iToken The iToken being minted\\n     * @param _minter The account which would get the minted tokens\\n     * @param _mintAmount The amount of underlying being minted to iToken\\n     * @param _mintedAmount The amount of iToken being minted\\n     */\\n    function afterMint(\\n        address _iToken,\\n        address _minter,\\n        uint256 _mintAmount,\\n        uint256 _mintedAmount\\n    ) external override {\\n        _iToken;\\n        _minter;\\n        _mintAmount;\\n        _mintedAmount;\\n    }\\n\\n    /**\\n     * @notice Hook function before iToken `redeem()`\\n     * Checks if the account should be allowed to redeem the given iToken\\n     * Will `revert()` if any check fails\\n     * @param _iToken The iToken to check the redeem against\\n     * @param _redeemer The account which would redeem iToken\\n     * @param _redeemAmount The amount of iToken to redeem\\n     */\\n    function beforeRedeem(\\n        address _iToken,\\n        address _redeemer,\\n        uint256 _redeemAmount\\n    ) external override {\\n        // _redeemAllowed below will check whether _iToken is listed\\n\\n        require(!markets[_iToken].redeemPaused, \\\"Token redeem has been paused\\\");\\n\\n        _redeemAllowed(_iToken, _redeemer, _redeemAmount);\\n\\n        // Update the Reward Distribution Supply state and distribute reward to suppplier\\n        IRewardDistributor(rewardDistributor).updateDistributionState(\\n            _iToken,\\n            false\\n        );\\n        IRewardDistributor(rewardDistributor).updateReward(\\n            _iToken,\\n            _redeemer,\\n            false\\n        );\\n    }\\n\\n    /**\\n     * @notice Hook function after iToken `redeem()`\\n     * Will `revert()` if any operation fails\\n     * @param _iToken The iToken being redeemed\\n     * @param _redeemer The account which redeemed iToken\\n     * @param _redeemAmount  The amount of iToken being redeemed\\n     * @param _redeemedUnderlying The amount of underlying being redeemed\\n     */\\n    function afterRedeem(\\n        address _iToken,\\n        address _redeemer,\\n        uint256 _redeemAmount,\\n        uint256 _redeemedUnderlying\\n    ) external override {\\n        _iToken;\\n        _redeemer;\\n        _redeemAmount;\\n        _redeemedUnderlying;\\n    }\\n\\n    /**\\n     * @notice Hook function before iToken `borrow()`\\n     * Checks if the account should be allowed to borrow the given iToken\\n     * Will `revert()` if any check fails\\n     * @param _iToken The iToken to check the borrow against\\n     * @param _borrower The account which would borrow iToken\\n     * @param _borrowAmount The amount of underlying to borrow\\n     */\\n    function beforeBorrow(\\n        address _iToken,\\n        address _borrower,\\n        uint256 _borrowAmount\\n    ) external override {\\n        _checkiTokenListed(_iToken);\\n\\n        Market storage _market = markets[_iToken];\\n        require(!_market.borrowPaused, \\\"Token borrow has been paused\\\");\\n\\n        if (!hasBorrowed(_borrower, _iToken)) {\\n            // Unlike collaterals, borrowed asset can only be added by iToken,\\n            // rather than enabled by user directly.\\n            require(msg.sender == _iToken, \\\"sender must be iToken\\\");\\n\\n            // Have checked _iToken is listed, just add it\\n            _addToBorrowed(_borrower, _iToken);\\n        }\\n\\n        // Check borrower's equity\\n        (, uint256 _shortfall, , ) =\\n            calcAccountEquityWithEffect(_borrower, _iToken, 0, _borrowAmount);\\n\\n        require(_shortfall == 0, \\\"Account has some shortfall\\\");\\n\\n        // Check the iToken's borrow capacity, -1 means no limit\\n        uint256 _totalBorrows = IiToken(_iToken).totalBorrows();\\n        require(\\n            _totalBorrows.add(_borrowAmount) <= _market.borrowCapacity,\\n            \\\"Token borrow capacity reached\\\"\\n        );\\n\\n        // Update the Reward Distribution Borrow state and distribute reward to borrower\\n        IRewardDistributor(rewardDistributor).updateDistributionState(\\n            _iToken,\\n            true\\n        );\\n        IRewardDistributor(rewardDistributor).updateReward(\\n            _iToken,\\n            _borrower,\\n            true\\n        );\\n    }\\n\\n    /**\\n     * @notice Hook function after iToken `borrow()`\\n     * Will `revert()` if any operation fails\\n     * @param _iToken The iToken being borrewd\\n     * @param _borrower The account which borrowed iToken\\n     * @param _borrowedAmount  The amount of underlying being borrowed\\n     */\\n    function afterBorrow(\\n        address _iToken,\\n        address _borrower,\\n        uint256 _borrowedAmount\\n    ) external override {\\n        _iToken;\\n        _borrower;\\n        _borrowedAmount;\\n    }\\n\\n    /**\\n     * @notice Hook function before iToken `repayBorrow()`\\n     * Checks if the account should be allowed to repay the given iToken\\n     * for the borrower. Will `revert()` if any check fails\\n     * @param _iToken The iToken to verify the repay against\\n     * @param _payer The account which would repay iToken\\n     * @param _borrower The account which has borrowed\\n     * @param _repayAmount The amount of underlying to repay\\n     */\\n    function beforeRepayBorrow(\\n        address _iToken,\\n        address _payer,\\n        address _borrower,\\n        uint256 _repayAmount\\n    ) external override {\\n        _checkiTokenListed(_iToken);\\n\\n        // Update the Reward Distribution Borrow state and distribute reward to borrower\\n        IRewardDistributor(rewardDistributor).updateDistributionState(\\n            _iToken,\\n            true\\n        );\\n        IRewardDistributor(rewardDistributor).updateReward(\\n            _iToken,\\n            _borrower,\\n            true\\n        );\\n\\n        _payer;\\n        _repayAmount;\\n    }\\n\\n    /**\\n     * @notice Hook function after iToken `repayBorrow()`\\n     * Will `revert()` if any operation fails\\n     * @param _iToken The iToken being repaid\\n     * @param _payer The account which would repay\\n     * @param _borrower The account which has borrowed\\n     * @param _repayAmount  The amount of underlying being repaied\\n     */\\n    function afterRepayBorrow(\\n        address _iToken,\\n        address _payer,\\n        address _borrower,\\n        uint256 _repayAmount\\n    ) external override {\\n        _checkiTokenListed(_iToken);\\n\\n        // Remove _iToken from borrowed list if new borrow balance is 0\\n        if (IiToken(_iToken).borrowBalanceStored(_borrower) == 0) {\\n            // Only allow called by iToken as we are going to remove this token from borrower's borrowed list\\n            require(msg.sender == _iToken, \\\"sender must be iToken\\\");\\n\\n            // Have checked _iToken is listed, just remove it\\n            _removeFromBorrowed(_borrower, _iToken);\\n        }\\n\\n        _payer;\\n        _repayAmount;\\n    }\\n\\n    /**\\n     * @notice Hook function before iToken `liquidateBorrow()`\\n     * Checks if the account should be allowed to liquidate the given iToken\\n     * for the borrower. Will `revert()` if any check fails\\n     * @param _iTokenBorrowed The iToken was borrowed\\n     * @param _iTokenCollateral The collateral iToken to be liqudate with\\n     * @param _liquidator The account which would repay the borrowed iToken\\n     * @param _borrower The account which has borrowed\\n     * @param _repayAmount The amount of underlying to repay\\n     */\\n    function beforeLiquidateBorrow(\\n        address _iTokenBorrowed,\\n        address _iTokenCollateral,\\n        address _liquidator,\\n        address _borrower,\\n        uint256 _repayAmount\\n    ) external override {\\n        // Tokens must have been listed\\n        require(\\n            iTokens.contains(_iTokenBorrowed) &&\\n                iTokens.contains(_iTokenCollateral),\\n            \\\"Tokens have not been listed\\\"\\n        );\\n\\n        (, uint256 _shortfall, , ) = calcAccountEquity(_borrower);\\n\\n        require(_shortfall > 0, \\\"Account does not have shortfall\\\");\\n\\n        // Only allowed to repay the borrow balance's close factor\\n        uint256 _borrowBalance =\\n            IiToken(_iTokenBorrowed).borrowBalanceStored(_borrower);\\n        uint256 _maxRepay = _borrowBalance.rmul(closeFactorMantissa);\\n\\n        require(_repayAmount <= _maxRepay, \\\"Repay exceeds max repay allowed\\\");\\n\\n        _liquidator;\\n    }\\n\\n    /**\\n     * @notice Hook function after iToken `liquidateBorrow()`\\n     * Will `revert()` if any operation fails\\n     * @param _iTokenBorrowed The iToken was borrowed\\n     * @param _iTokenCollateral The collateral iToken to be seized\\n     * @param _liquidator The account which would repay and seize\\n     * @param _borrower The account which has borrowed\\n     * @param _repaidAmount  The amount of underlying being repaied\\n     * @param _seizedAmount  The amount of collateral being seized\\n     */\\n    function afterLiquidateBorrow(\\n        address _iTokenBorrowed,\\n        address _iTokenCollateral,\\n        address _liquidator,\\n        address _borrower,\\n        uint256 _repaidAmount,\\n        uint256 _seizedAmount\\n    ) external override {\\n        _iTokenBorrowed;\\n        _iTokenCollateral;\\n        _liquidator;\\n        _borrower;\\n        _repaidAmount;\\n        _seizedAmount;\\n\\n        // Unlike repayBorrow, liquidateBorrow does not allow to repay all borrow balance\\n        // No need to check whether should remove from borrowed asset list\\n    }\\n\\n    /**\\n     * @notice Hook function before iToken `seize()`\\n     * Checks if the liquidator should be allowed to seize the collateral iToken\\n     * Will `revert()` if any check fails\\n     * @param _iTokenCollateral The collateral iToken to be seize\\n     * @param _iTokenBorrowed The iToken was borrowed\\n     * @param _liquidator The account which has repaid the borrowed iToken\\n     * @param _borrower The account which has borrowed\\n     * @param _seizeAmount The amount of collateral iToken to seize\\n     */\\n    function beforeSeize(\\n        address _iTokenCollateral,\\n        address _iTokenBorrowed,\\n        address _liquidator,\\n        address _borrower,\\n        uint256 _seizeAmount\\n    ) external override {\\n        require(!seizePaused, \\\"Seize has been paused\\\");\\n\\n        // Markets must have been listed\\n        require(\\n            iTokens.contains(_iTokenBorrowed) &&\\n                iTokens.contains(_iTokenCollateral),\\n            \\\"Tokens have not been listed\\\"\\n        );\\n\\n        // Sanity Check the controllers\\n        require(\\n            IiToken(_iTokenBorrowed).controller() ==\\n                IiToken(_iTokenCollateral).controller(),\\n            \\\"Controller mismatch between Borrowed and Collateral\\\"\\n        );\\n\\n        // Update the Reward Distribution Supply state on collateral\\n        IRewardDistributor(rewardDistributor).updateDistributionState(\\n            _iTokenCollateral,\\n            false\\n        );\\n\\n        // Update reward of liquidator and borrower on collateral\\n        IRewardDistributor(rewardDistributor).updateReward(\\n            _iTokenCollateral,\\n            _liquidator,\\n            false\\n        );\\n        IRewardDistributor(rewardDistributor).updateReward(\\n            _iTokenCollateral,\\n            _borrower,\\n            false\\n        );\\n\\n        _seizeAmount;\\n    }\\n\\n    /**\\n     * @notice Hook function after iToken `seize()`\\n     * Will `revert()` if any operation fails\\n     * @param _iTokenCollateral The collateral iToken to be seized\\n     * @param _iTokenBorrowed The iToken was borrowed\\n     * @param _liquidator The account which has repaid and seized\\n     * @param _borrower The account which has borrowed\\n     * @param _seizedAmount  The amount of collateral being seized\\n     */\\n    function afterSeize(\\n        address _iTokenCollateral,\\n        address _iTokenBorrowed,\\n        address _liquidator,\\n        address _borrower,\\n        uint256 _seizedAmount\\n    ) external override {\\n        _iTokenBorrowed;\\n        _iTokenCollateral;\\n        _liquidator;\\n        _borrower;\\n        _seizedAmount;\\n    }\\n\\n    /**\\n     * @notice Hook function before iToken `transfer()`\\n     * Checks if the transfer should be allowed\\n     * Will `revert()` if any check fails\\n     * @param _iToken The iToken to be transfered\\n     * @param _from The account to be transfered from\\n     * @param _to The account to be transfered to\\n     * @param _amount The amount to be transfered\\n     */\\n    function beforeTransfer(\\n        address _iToken,\\n        address _from,\\n        address _to,\\n        uint256 _amount\\n    ) external override {\\n        // _redeemAllowed below will check whether _iToken is listed\\n\\n        require(!transferPaused, \\\"Transfer has been paused\\\");\\n\\n        // Check account equity with this amount to decide whether the transfer is allowed\\n        _redeemAllowed(_iToken, _from, _amount);\\n\\n        // Update the Reward Distribution supply state\\n        IRewardDistributor(rewardDistributor).updateDistributionState(\\n            _iToken,\\n            false\\n        );\\n\\n        // Update reward of from and to\\n        IRewardDistributor(rewardDistributor).updateReward(\\n            _iToken,\\n            _from,\\n            false\\n        );\\n        IRewardDistributor(rewardDistributor).updateReward(_iToken, _to, false);\\n    }\\n\\n    /**\\n     * @notice Hook function after iToken `transfer()`\\n     * Will `revert()` if any operation fails\\n     * @param _iToken The iToken was transfered\\n     * @param _from The account was transfer from\\n     * @param _to The account was transfer to\\n     * @param _amount  The amount was transfered\\n     */\\n    function afterTransfer(\\n        address _iToken,\\n        address _from,\\n        address _to,\\n        uint256 _amount\\n    ) external override {\\n        _iToken;\\n        _from;\\n        _to;\\n        _amount;\\n    }\\n\\n    /**\\n     * @notice Hook function before iToken `flashloan()`\\n     * Checks if the flashloan should be allowed\\n     * Will `revert()` if any check fails\\n     * @param _iToken The iToken to be flashloaned\\n     * @param _to The account flashloaned transfer to\\n     * @param _amount The amount to be flashloaned\\n     */\\n    function beforeFlashloan(\\n        address _iToken,\\n        address _to,\\n        uint256 _amount\\n    ) external override {\\n        // Flashloan share the same pause state with borrow\\n        require(!markets[_iToken].borrowPaused, \\\"Token borrow has been paused\\\");\\n\\n        _checkiTokenListed(_iToken);\\n\\n        _to;\\n        _amount;\\n\\n        // Update the Reward Distribution Borrow state\\n        IRewardDistributor(rewardDistributor).updateDistributionState(\\n            _iToken,\\n            true\\n        );\\n    }\\n\\n    /**\\n     * @notice Hook function after iToken `flashloan()`\\n     * Will `revert()` if any operation fails\\n     * @param _iToken The iToken was flashloaned\\n     * @param _to The account flashloan transfer to\\n     * @param _amount  The amount was flashloaned\\n     */\\n    function afterFlashloan(\\n        address _iToken,\\n        address _to,\\n        uint256 _amount\\n    ) external override {\\n        _iToken;\\n        _to;\\n        _amount;\\n    }\\n\\n    /*********************************/\\n    /***** Internal  Functions *******/\\n    /*********************************/\\n\\n    function _redeemAllowed(\\n        address _iToken,\\n        address _redeemer,\\n        uint256 _amount\\n    ) private view {\\n        _checkiTokenListed(_iToken);\\n\\n        // No need to check liquidity if _redeemer has not used _iToken as collateral\\n        if (!accountsData[_redeemer].collaterals.contains(_iToken)) {\\n            return;\\n        }\\n\\n        (, uint256 _shortfall, , ) =\\n            calcAccountEquityWithEffect(_redeemer, _iToken, _amount, 0);\\n\\n        require(_shortfall == 0, \\\"Account has some shortfall\\\");\\n    }\\n\\n    /**\\n     * @dev Check if _iToken is listed\\n     */\\n    function _checkiTokenListed(address _iToken) private view {\\n        require(iTokens.contains(_iToken), \\\"Token has not been listed\\\");\\n    }\\n\\n    /*********************************/\\n    /** Account equity calculation ***/\\n    /*********************************/\\n\\n    /**\\n     * @notice Calculates current account equity\\n     * @param _account The account to query equity of\\n     * @return account equity, shortfall, collateral value, borrowed value.\\n     */\\n    function calcAccountEquity(address _account)\\n        public\\n        view\\n        override\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        return calcAccountEquityWithEffect(_account, address(0), 0, 0);\\n    }\\n\\n    /**\\n     * @dev Local vars for avoiding stack-depth limits in calculating account liquidity.\\n     *  Note that `iTokenBalance` is the number of iTokens the account owns in the collateral,\\n     *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\\n     */\\n    struct AccountEquityLocalVars {\\n        uint256 sumCollateral;\\n        uint256 sumBorrowed;\\n        uint256 iTokenBalance;\\n        uint256 borrowBalance;\\n        uint256 exchangeRateMantissa;\\n        uint256 underlyingPrice;\\n        uint256 collateralValue;\\n        uint256 borrowValue;\\n    }\\n\\n    /**\\n     * @notice Calculates current account equity plus some token and amount to effect\\n     * @param _account The account to query equity of\\n     * @param _tokenToEffect The token address to add some additional redeeem/borrow\\n     * @param _redeemAmount The additional amount to redeem\\n     * @param _borrowAmount The additional amount to borrow\\n     * @return account euqity, shortfall, collateral value, borrowed value plus the effect.\\n     */\\n    function calcAccountEquityWithEffect(\\n        address _account,\\n        address _tokenToEffect,\\n        uint256 _redeemAmount,\\n        uint256 _borrowAmount\\n    )\\n        internal\\n        view\\n        virtual\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        AccountEquityLocalVars memory _local;\\n        AccountData storage _accountData = accountsData[_account];\\n\\n        // Calculate value of all collaterals\\n        // collateralValuePerToken = underlyingPrice * exchangeRate * collateralFactor\\n        // collateralValue = balance * collateralValuePerToken\\n        // sumCollateral += collateralValue\\n        uint256 _len = _accountData.collaterals.length();\\n        for (uint256 i = 0; i < _len; i++) {\\n            IiToken _token = IiToken(_accountData.collaterals.at(i));\\n\\n            _local.iTokenBalance = IERC20Upgradeable(address(_token)).balanceOf(\\n                _account\\n            );\\n            _local.exchangeRateMantissa = _token.exchangeRateStored();\\n\\n            if (_tokenToEffect == address(_token) && _redeemAmount > 0) {\\n                _local.iTokenBalance = _local.iTokenBalance.sub(_redeemAmount);\\n            }\\n\\n            _local.underlyingPrice = IPriceOracle(priceOracle)\\n                .getUnderlyingPrice(address(_token));\\n\\n            require(\\n                _local.underlyingPrice != 0,\\n                \\\"Invalid price to calculate account equity\\\"\\n            );\\n\\n            _local.collateralValue = _local\\n                .iTokenBalance\\n                .mul(_local.underlyingPrice)\\n                .rmul(_local.exchangeRateMantissa)\\n                .rmul(markets[address(_token)].collateralFactorMantissa);\\n\\n            _local.sumCollateral = _local.sumCollateral.add(\\n                _local.collateralValue\\n            );\\n        }\\n\\n        // Calculate all borrowed value\\n        // borrowValue = underlyingPrice * underlyingBorrowed / borrowFactor\\n        // sumBorrowed += borrowValue\\n        _len = _accountData.borrowed.length();\\n        for (uint256 i = 0; i < _len; i++) {\\n            IiToken _token = IiToken(_accountData.borrowed.at(i));\\n\\n            _local.borrowBalance = _token.borrowBalanceStored(_account);\\n\\n            if (_tokenToEffect == address(_token) && _borrowAmount > 0) {\\n                _local.borrowBalance = _local.borrowBalance.add(_borrowAmount);\\n            }\\n\\n            _local.underlyingPrice = IPriceOracle(priceOracle)\\n                .getUnderlyingPrice(address(_token));\\n\\n            require(\\n                _local.underlyingPrice != 0,\\n                \\\"Invalid price to calculate account equity\\\"\\n            );\\n\\n            // borrowFactorMantissa can not be set to 0\\n            _local.borrowValue = _local\\n                .borrowBalance\\n                .mul(_local.underlyingPrice)\\n                .rdiv(markets[address(_token)].borrowFactorMantissa);\\n\\n            _local.sumBorrowed = _local.sumBorrowed.add(_local.borrowValue);\\n        }\\n\\n        // Should never underflow\\n        return\\n            _local.sumCollateral > _local.sumBorrowed\\n                ? (\\n                    _local.sumCollateral - _local.sumBorrowed,\\n                    uint256(0),\\n                    _local.sumCollateral,\\n                    _local.sumBorrowed\\n                )\\n                : (\\n                    uint256(0),\\n                    _local.sumBorrowed - _local.sumCollateral,\\n                    _local.sumCollateral,\\n                    _local.sumBorrowed\\n                );\\n    }\\n\\n    /**\\n     * @notice Calculate amount of collateral iToken to seize after repaying an underlying amount\\n     * @dev Used in liquidation\\n     * @param _iTokenBorrowed The iToken was borrowed\\n     * @param _iTokenCollateral The collateral iToken to be seized\\n     * @param _actualRepayAmount The amount of underlying token liquidator has repaied\\n     * @return _seizedTokenCollateral amount of iTokenCollateral tokens to be seized\\n     */\\n    function liquidateCalculateSeizeTokens(\\n        address _iTokenBorrowed,\\n        address _iTokenCollateral,\\n        uint256 _actualRepayAmount\\n    ) external view virtual override returns (uint256 _seizedTokenCollateral) {\\n        /* Read oracle prices for borrowed and collateral assets */\\n        uint256 _priceBorrowed =\\n            IPriceOracle(priceOracle).getUnderlyingPrice(_iTokenBorrowed);\\n        uint256 _priceCollateral =\\n            IPriceOracle(priceOracle).getUnderlyingPrice(_iTokenCollateral);\\n        require(\\n            _priceBorrowed != 0 && _priceCollateral != 0,\\n            \\\"Borrowed or Collateral asset price is invalid\\\"\\n        );\\n\\n        uint256 _valueRepayPlusIncentive =\\n            _actualRepayAmount.mul(_priceBorrowed).rmul(\\n                liquidationIncentiveMantissa\\n            );\\n\\n        // Use stored value here as it is view function\\n        uint256 _exchangeRateMantissa =\\n            IiToken(_iTokenCollateral).exchangeRateStored();\\n\\n        // seizedTokenCollateral = valueRepayPlusIncentive / valuePerTokenCollateral\\n        // valuePerTokenCollateral = exchangeRateMantissa * priceCollateral\\n        _seizedTokenCollateral = _valueRepayPlusIncentive\\n            .rdiv(_exchangeRateMantissa)\\n            .div(_priceCollateral);\\n    }\\n\\n    /*********************************/\\n    /*** Account Markets Operation ***/\\n    /*********************************/\\n\\n    /**\\n     * @notice Returns the markets list the account has entered\\n     * @param _account The address of the account to query\\n     * @return _accountCollaterals The markets list the account has entered\\n     */\\n    function getEnteredMarkets(address _account)\\n        external\\n        view\\n        override\\n        returns (address[] memory _accountCollaterals)\\n    {\\n        AccountData storage _accountData = accountsData[_account];\\n\\n        uint256 _len = _accountData.collaterals.length();\\n        _accountCollaterals = new address[](_len);\\n        for (uint256 i = 0; i < _len; i++) {\\n            _accountCollaterals[i] = _accountData.collaterals.at(i);\\n        }\\n    }\\n\\n    /**\\n     * @notice Add markets to `msg.sender`'s markets list for liquidity calculations\\n     * @param _iTokens The list of addresses of the iToken markets to be entered\\n     * @return _results Success indicator for whether each corresponding market was entered\\n     */\\n    function enterMarkets(address[] calldata _iTokens)\\n        external\\n        override\\n        returns (bool[] memory _results)\\n    {\\n        uint256 _len = _iTokens.length;\\n\\n        _results = new bool[](_len);\\n        for (uint256 i = 0; i < _len; i++) {\\n            _results[i] = _enterMarket(_iTokens[i], msg.sender);\\n        }\\n    }\\n\\n    /**\\n     * @notice Add the market to the account's markets list for liquidity calculations\\n     * @param _iToken The market to enter\\n     * @param _account The address of the account to modify\\n     * @return True if entered successfully, false for non-listed market or other errors\\n     */\\n    function _enterMarket(address _iToken, address _account)\\n        internal\\n        returns (bool)\\n    {\\n        // Market not listed, skip it\\n        if (!iTokens.contains(_iToken)) {\\n            return false;\\n        }\\n\\n        // add() will return false if iToken is in account's market list\\n        if (accountsData[_account].collaterals.add(_iToken)) {\\n            emit MarketEntered(_iToken, _account);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Returns whether the given account has entered the market\\n     * @param _account The address of the account to check\\n     * @param _iToken The iToken to check against\\n     * @return True if the account has entered the market, otherwise false.\\n     */\\n    function hasEnteredMarket(address _account, address _iToken)\\n        external\\n        view\\n        override\\n        returns (bool)\\n    {\\n        return accountsData[_account].collaterals.contains(_iToken);\\n    }\\n\\n    /**\\n     * @notice Remove markets from `msg.sender`'s collaterals for liquidity calculations\\n     * @param _iTokens The list of addresses of the iToken to exit\\n     * @return _results Success indicators for whether each corresponding market was exited\\n     */\\n    function exitMarkets(address[] calldata _iTokens)\\n        external\\n        override\\n        returns (bool[] memory _results)\\n    {\\n        uint256 _len = _iTokens.length;\\n        _results = new bool[](_len);\\n        for (uint256 i = 0; i < _len; i++) {\\n            _results[i] = _exitMarket(_iTokens[i], msg.sender);\\n        }\\n    }\\n\\n    /**\\n     * @notice Remove the market to the account's markets list for liquidity calculations\\n     * @param _iToken The market to exit\\n     * @param _account The address of the account to modify\\n     * @return True if exit successfully, false for non-listed market or other errors\\n     */\\n    function _exitMarket(address _iToken, address _account)\\n        internal\\n        returns (bool)\\n    {\\n        // Market not listed, skip it\\n        if (!iTokens.contains(_iToken)) {\\n            return true;\\n        }\\n\\n        // Account has not entered this market, skip it\\n        if (!accountsData[_account].collaterals.contains(_iToken)) {\\n            return true;\\n        }\\n\\n        // Get the iToken balance\\n        uint256 _balance = IERC20Upgradeable(_iToken).balanceOf(_account);\\n\\n        // Check account's equity if all balance are redeemed\\n        // which means iToken can be removed from collaterals\\n        _redeemAllowed(_iToken, _account, _balance);\\n\\n        // Have checked account has entered market before\\n        accountsData[_account].collaterals.remove(_iToken);\\n\\n        emit MarketExited(_iToken, _account);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Returns the asset list the account has borrowed\\n     * @param _account The address of the account to query\\n     * @return _borrowedAssets The asset list the account has borrowed\\n     */\\n    function getBorrowedAssets(address _account)\\n        external\\n        view\\n        override\\n        returns (address[] memory _borrowedAssets)\\n    {\\n        AccountData storage _accountData = accountsData[_account];\\n\\n        uint256 _len = _accountData.borrowed.length();\\n        _borrowedAssets = new address[](_len);\\n        for (uint256 i = 0; i < _len; i++) {\\n            _borrowedAssets[i] = _accountData.borrowed.at(i);\\n        }\\n    }\\n\\n    /**\\n     * @notice Add the market to the account's borrowed list for equity calculations\\n     * @param _iToken The iToken of underlying to borrow\\n     * @param _account The address of the account to modify\\n     */\\n    function _addToBorrowed(address _account, address _iToken) internal {\\n        // add() will return false if iToken is in account's market list\\n        if (accountsData[_account].borrowed.add(_iToken)) {\\n            emit BorrowedAdded(_iToken, _account);\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns whether the given account has borrowed the given iToken\\n     * @param _account The address of the account to check\\n     * @param _iToken The iToken to check against\\n     * @return True if the account has borrowed the iToken, otherwise false.\\n     */\\n    function hasBorrowed(address _account, address _iToken)\\n        public\\n        view\\n        override\\n        returns (bool)\\n    {\\n        return accountsData[_account].borrowed.contains(_iToken);\\n    }\\n\\n    /**\\n     * @notice Remove the iToken from the account's borrowed list\\n     * @param _iToken The iToken to remove\\n     * @param _account The address of the account to modify\\n     */\\n    function _removeFromBorrowed(address _account, address _iToken) internal {\\n        // remove() will return false if iToken does not exist in account's borrowed list\\n        if (accountsData[_account].borrowed.remove(_iToken)) {\\n            emit BorrowedRemoved(_iToken, _account);\\n        }\\n    }\\n\\n    /*********************************/\\n    /****** General Information ******/\\n    /*********************************/\\n\\n    /**\\n     * @notice Return all of the iTokens\\n     * @return _alliTokens The list of iToken addresses\\n     */\\n    function getAlliTokens()\\n        public\\n        view\\n        override\\n        returns (address[] memory _alliTokens)\\n    {\\n        EnumerableSetUpgradeable.AddressSet storage _iTokens = iTokens;\\n\\n        uint256 _len = _iTokens.length();\\n        _alliTokens = new address[](_len);\\n        for (uint256 i = 0; i < _len; i++) {\\n            _alliTokens[i] = _iTokens.at(i);\\n        }\\n    }\\n\\n    /**\\n     * @notice Check whether a iToken is listed in controller\\n     * @param _iToken The iToken to check for\\n     * @return true if the iToken is listed otherwise false\\n     */\\n    function hasiToken(address _iToken) public view override returns (bool) {\\n        return iTokens.contains(_iToken);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMathUpgradeable {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IInterestRateModelInterface.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\n/**\\n * @title dForce Lending Protocol's InterestRateModel Interface.\\n * @author dForce Team.\\n */\\ninterface IInterestRateModelInterface {\\n    function isInterestRateModel() external view returns (bool);\\n\\n    /**\\n     * @dev Calculates the current borrow interest rate per block.\\n     * @param cash The total amount of cash the market has.\\n     * @param borrows The total amount of borrows the market has.\\n     * @param reserves The total amnount of reserves the market has.\\n     * @return The borrow rate per block (as a percentage, and scaled by 1e18).\\n     */\\n    function getBorrowRate(\\n        uint256 cash,\\n        uint256 borrows,\\n        uint256 reserves\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @dev Calculates the current supply interest rate per block.\\n     * @param cash The total amount of cash the market has.\\n     * @param borrows The total amount of borrows the market has.\\n     * @param reserves The total amnount of reserves the market has.\\n     * @param reserveRatio The current reserve factor the market has.\\n     * @return The supply rate per block (as a percentage, and scaled by 1e18).\\n     */\\n    function getSupplyRate(\\n        uint256 cash,\\n        uint256 borrows,\\n        uint256 reserves,\\n        uint256 reserveRatio\\n    ) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IControllerInterface.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\ninterface IControllerAdminInterface {\\n    /// @notice Emitted when an admin supports a market\\n    event MarketAdded(\\n        address iToken,\\n        uint256 collateralFactor,\\n        uint256 borrowFactor,\\n        uint256 supplyCapacity,\\n        uint256 borrowCapacity,\\n        uint256 distributionFactor\\n    );\\n\\n    function _addMarket(\\n        address _iToken,\\n        uint256 _collateralFactor,\\n        uint256 _borrowFactor,\\n        uint256 _supplyCapacity,\\n        uint256 _borrowCapacity,\\n        uint256 _distributionFactor\\n    ) external;\\n\\n    /// @notice Emitted when new price oracle is set\\n    event NewPriceOracle(address oldPriceOracle, address newPriceOracle);\\n\\n    function _setPriceOracle(address newOracle) external;\\n\\n    /// @notice Emitted when close factor is changed by admin\\n    event NewCloseFactor(\\n        uint256 oldCloseFactorMantissa,\\n        uint256 newCloseFactorMantissa\\n    );\\n\\n    function _setCloseFactor(uint256 newCloseFactorMantissa) external;\\n\\n    /// @notice Emitted when liquidation incentive is changed by admin\\n    event NewLiquidationIncentive(\\n        uint256 oldLiquidationIncentiveMantissa,\\n        uint256 newLiquidationIncentiveMantissa\\n    );\\n\\n    function _setLiquidationIncentive(uint256 newLiquidationIncentiveMantissa)\\n        external;\\n\\n    /// @notice Emitted when iToken's collateral factor is changed by admin\\n    event NewCollateralFactor(\\n        address iToken,\\n        uint256 oldCollateralFactorMantissa,\\n        uint256 newCollateralFactorMantissa\\n    );\\n\\n    function _setCollateralFactor(\\n        address iToken,\\n        uint256 newCollateralFactorMantissa\\n    ) external;\\n\\n    /// @notice Emitted when iToken's borrow factor is changed by admin\\n    event NewBorrowFactor(\\n        address iToken,\\n        uint256 oldBorrowFactorMantissa,\\n        uint256 newBorrowFactorMantissa\\n    );\\n\\n    function _setBorrowFactor(address iToken, uint256 newBorrowFactorMantissa)\\n        external;\\n\\n    /// @notice Emitted when iToken's borrow capacity is changed by admin\\n    event NewBorrowCapacity(\\n        address iToken,\\n        uint256 oldBorrowCapacity,\\n        uint256 newBorrowCapacity\\n    );\\n\\n    function _setBorrowCapacity(address iToken, uint256 newBorrowCapacity)\\n        external;\\n\\n    /// @notice Emitted when iToken's supply capacity is changed by admin\\n    event NewSupplyCapacity(\\n        address iToken,\\n        uint256 oldSupplyCapacity,\\n        uint256 newSupplyCapacity\\n    );\\n\\n    function _setSupplyCapacity(address iToken, uint256 newSupplyCapacity)\\n        external;\\n\\n    /// @notice Emitted when pause guardian is changed by admin\\n    event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\\n\\n    function _setPauseGuardian(address newPauseGuardian) external;\\n\\n    /// @notice Emitted when mint is paused/unpaused by admin or pause guardian\\n    event MintPaused(address iToken, bool paused);\\n\\n    function _setMintPaused(address iToken, bool paused) external;\\n\\n    function _setAllMintPaused(bool paused) external;\\n\\n    /// @notice Emitted when redeem is paused/unpaused by admin or pause guardian\\n    event RedeemPaused(address iToken, bool paused);\\n\\n    function _setRedeemPaused(address iToken, bool paused) external;\\n\\n    function _setAllRedeemPaused(bool paused) external;\\n\\n    /// @notice Emitted when borrow is paused/unpaused by admin or pause guardian\\n    event BorrowPaused(address iToken, bool paused);\\n\\n    function _setBorrowPaused(address iToken, bool paused) external;\\n\\n    function _setAllBorrowPaused(bool paused) external;\\n\\n    /// @notice Emitted when transfer is paused/unpaused by admin or pause guardian\\n    event TransferPaused(bool paused);\\n\\n    function _setTransferPaused(bool paused) external;\\n\\n    /// @notice Emitted when seize is paused/unpaused by admin or pause guardian\\n    event SeizePaused(bool paused);\\n\\n    function _setSeizePaused(bool paused) external;\\n\\n    function _setiTokenPaused(address iToken, bool paused) external;\\n\\n    function _setProtocolPaused(bool paused) external;\\n\\n    event NewRewardDistributor(\\n        address oldRewardDistributor,\\n        address _newRewardDistributor\\n    );\\n\\n    function _setRewardDistributor(address _newRewardDistributor) external;\\n}\\n\\ninterface IControllerPolicyInterface {\\n    function beforeMint(\\n        address iToken,\\n        address account,\\n        uint256 mintAmount\\n    ) external;\\n\\n    function afterMint(\\n        address iToken,\\n        address minter,\\n        uint256 mintAmount,\\n        uint256 mintedAmount\\n    ) external;\\n\\n    function beforeRedeem(\\n        address iToken,\\n        address redeemer,\\n        uint256 redeemAmount\\n    ) external;\\n\\n    function afterRedeem(\\n        address iToken,\\n        address redeemer,\\n        uint256 redeemAmount,\\n        uint256 redeemedAmount\\n    ) external;\\n\\n    function beforeBorrow(\\n        address iToken,\\n        address borrower,\\n        uint256 borrowAmount\\n    ) external;\\n\\n    function afterBorrow(\\n        address iToken,\\n        address borrower,\\n        uint256 borrowedAmount\\n    ) external;\\n\\n    function beforeRepayBorrow(\\n        address iToken,\\n        address payer,\\n        address borrower,\\n        uint256 repayAmount\\n    ) external;\\n\\n    function afterRepayBorrow(\\n        address iToken,\\n        address payer,\\n        address borrower,\\n        uint256 repayAmount\\n    ) external;\\n\\n    function beforeLiquidateBorrow(\\n        address iTokenBorrowed,\\n        address iTokenCollateral,\\n        address liquidator,\\n        address borrower,\\n        uint256 repayAmount\\n    ) external;\\n\\n    function afterLiquidateBorrow(\\n        address iTokenBorrowed,\\n        address iTokenCollateral,\\n        address liquidator,\\n        address borrower,\\n        uint256 repaidAmount,\\n        uint256 seizedAmount\\n    ) external;\\n\\n    function beforeSeize(\\n        address iTokenBorrowed,\\n        address iTokenCollateral,\\n        address liquidator,\\n        address borrower,\\n        uint256 seizeAmount\\n    ) external;\\n\\n    function afterSeize(\\n        address iTokenBorrowed,\\n        address iTokenCollateral,\\n        address liquidator,\\n        address borrower,\\n        uint256 seizedAmount\\n    ) external;\\n\\n    function beforeTransfer(\\n        address iToken,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external;\\n\\n    function afterTransfer(\\n        address iToken,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external;\\n\\n    function beforeFlashloan(\\n        address iToken,\\n        address to,\\n        uint256 amount\\n    ) external;\\n\\n    function afterFlashloan(\\n        address iToken,\\n        address to,\\n        uint256 amount\\n    ) external;\\n}\\n\\ninterface IControllerAccountEquityInterface {\\n    function calcAccountEquity(address account)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function liquidateCalculateSeizeTokens(\\n        address iTokenBorrowed,\\n        address iTokenCollateral,\\n        uint256 actualRepayAmount\\n    ) external view returns (uint256);\\n}\\n\\ninterface IControllerAccountInterface {\\n    function hasEnteredMarket(address account, address iToken)\\n        external\\n        view\\n        returns (bool);\\n\\n    function getEnteredMarkets(address account)\\n        external\\n        view\\n        returns (address[] memory);\\n\\n    /// @notice Emitted when an account enters a market\\n    event MarketEntered(address iToken, address account);\\n\\n    function enterMarkets(address[] calldata iTokens)\\n        external\\n        returns (bool[] memory);\\n\\n    /// @notice Emitted when an account exits a market\\n    event MarketExited(address iToken, address account);\\n\\n    function exitMarkets(address[] calldata iTokens)\\n        external\\n        returns (bool[] memory);\\n\\n    /// @notice Emitted when an account add a borrow asset\\n    event BorrowedAdded(address iToken, address account);\\n\\n    /// @notice Emitted when an account remove a borrow asset\\n    event BorrowedRemoved(address iToken, address account);\\n\\n    function hasBorrowed(address account, address iToken)\\n        external\\n        view\\n        returns (bool);\\n\\n    function getBorrowedAssets(address account)\\n        external\\n        view\\n        returns (address[] memory);\\n}\\n\\ninterface IControllerInterface is\\n    IControllerAdminInterface,\\n    IControllerPolicyInterface,\\n    IControllerAccountEquityInterface,\\n    IControllerAccountInterface\\n{\\n    /**\\n     * @notice Security checks when updating the comptroller of a market, always expect to return true.\\n     */\\n    function isController() external view returns (bool);\\n\\n    /**\\n     * @notice Return all of the iTokens\\n     * @return The list of iToken addresses\\n     */\\n    function getAlliTokens() external view returns (address[] memory);\\n\\n    /**\\n     * @notice Check whether a iToken is listed in controller\\n     * @param _iToken The iToken to check for\\n     * @return true if the iToken is listed otherwise false\\n     */\\n    function hasiToken(address _iToken) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/EnumerableSetUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSetUpgradeable {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint256(_at(set._inner, index)));\\n    }\\n\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IRewardDistributor.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\ninterface IRewardDistributor {\\n    function _setRewardToken(address newRewardToken) external;\\n\\n    /// @notice Emitted reward token address is changed by admin\\n    event NewRewardToken(address oldRewardToken, address newRewardToken);\\n\\n    function _addRecipient(address _iToken, uint256 _distributionFactor)\\n        external;\\n\\n    event NewRecipient(address iToken, uint256 distributionFactor);\\n\\n    /// @notice Emitted when mint is paused/unpaused by admin\\n    event Paused(bool paused);\\n\\n    function _pause() external;\\n\\n    function _unpause(uint256 _borrowSpeed, uint256 _supplySpeed) external;\\n\\n    /// @notice Emitted when Global Distribution speed for both supply and borrow are updated\\n    event GlobalDistributionSpeedsUpdated(\\n        uint256 borrowSpeed,\\n        uint256 supplySpeed\\n    );\\n\\n    function _setGlobalDistributionSpeeds(\\n        uint256 borrowSpeed,\\n        uint256 supplySpeed\\n    ) external;\\n\\n    /// @notice Emitted when iToken's Distribution speed is updated\\n    event DistributionSpeedsUpdated(\\n        address iToken,\\n        uint256 borrowSpeed,\\n        uint256 supplySpeed\\n    );\\n\\n    function updateDistributionSpeed() external;\\n\\n    /// @notice Emitted when iToken's Distribution factor is changed by admin\\n    event NewDistributionFactor(\\n        address iToken,\\n        uint256 oldDistributionFactorMantissa,\\n        uint256 newDistributionFactorMantissa\\n    );\\n\\n    function _setDistributionFactors(\\n        address[] calldata iToken,\\n        uint256[] calldata distributionFactors\\n    ) external;\\n\\n    function updateDistributionState(address _iToken, bool _isBorrow) external;\\n\\n    function updateReward(\\n        address _iToken,\\n        address _account,\\n        bool _isBorrow\\n    ) external;\\n\\n    function updateRewardBatch(\\n        address[] memory _holders,\\n        address[] memory _iTokens\\n    ) external;\\n\\n    function claimReward(address[] memory _holders, address[] memory _iTokens)\\n        external;\\n\\n    function claimAllReward(address[] memory _holders) external;\\n\\n    /// @notice Emitted when reward of amount is distributed into account\\n    event RewardDistributed(\\n        address iToken,\\n        address account,\\n        uint256 amount,\\n        uint256 accountIndex\\n    );\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"iToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowSpeed\",\"type\":\"uint256\"}],\"name\":\"DistributionBorrowSpeedUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"iToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"supplySpeed\",\"type\":\"uint256\"}],\"name\":\"DistributionSupplySpeedUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowSpeed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"supplySpeed\",\"type\":\"uint256\"}],\"name\":\"GlobalDistributionSpeedsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"iToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldDistributionFactorMantissa\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDistributionFactorMantissa\",\"type\":\"uint256\"}],\"name\":\"NewDistributionFactor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"NewOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldPendingOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newPendingOwner\",\"type\":\"address\"}],\"name\":\"NewPendingOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"iToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"distributionFactor\",\"type\":\"uint256\"}],\"name\":\"NewRecipient\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldRewardToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newRewardToken\",\"type\":\"address\"}],\"name\":\"NewRewardToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"iToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accountIndex\",\"type\":\"uint256\"}],\"name\":\"RewardDistributed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_acceptOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_iToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_distributionFactor\",\"type\":\"uint256\"}],\"name\":\"_addRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_iTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_borrowSpeeds\",\"type\":\"uint256[]\"}],\"name\":\"_setDistributionBorrowSpeeds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_borrowiTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_borrowSpeeds\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"_supplyiTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_supplySpeeds\",\"type\":\"uint256[]\"}],\"name\":\"_setDistributionSpeeds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_iTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_supplySpeeds\",\"type\":\"uint256[]\"}],\"name\":\"_setDistributionSupplySpeeds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newPendingOwner\",\"type\":\"address\"}],\"name\":\"_setPendingOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newRewardToken\",\"type\":\"address\"}],\"name\":\"_setRewardToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_borrowiTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_borrowSpeeds\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"_supplyiTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_supplySpeeds\",\"type\":\"uint256[]\"}],\"name\":\"_unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_holders\",\"type\":\"address[]\"}],\"name\":\"claimAllReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_holders\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_iTokens\",\"type\":\"address[]\"}],\"name\":\"claimReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_holders\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_suppliediTokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_borrowediTokens\",\"type\":\"address[]\"}],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"contract Controller\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"distributionBorrowState\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"block\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"distributionBorrowerIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"distributionFactorMantissa\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"distributionSpeed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"distributionSupplierIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"distributionSupplySpeed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"distributionSupplyState\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"block\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globalDistributionSpeed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globalDistributionSupplySpeed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Controller\",\"name\":\"_controller\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"reward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_iToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isBorrow\",\"type\":\"bool\"}],\"name\":\"updateDistributionState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_iToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isBorrow\",\"type\":\"bool\"}],\"name\":\"updateReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_holders\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_iTokens\",\"type\":\"address[]\"}],\"name\":\"updateRewardBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"RewardDistributorV3","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}