{"status":"1","message":"OK","result":[{"SourceCode":"// File: lib/ReentrancyGuard.sol\r\n\r\n// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity ^0.6.12;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor () public {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n// File: iface/IPriceController.sol\r\n\r\npragma solidity ^0.6.12;\r\n\r\ninterface IPriceController {\r\n    function getPriceForPToken(address token, address uToken, address payback) external payable returns (uint256 tokenPrice, uint256 pTokenPrice);\r\n}\r\n// File: iface/IInsurancePool.sol\r\n\r\npragma solidity ^0.6.12;\r\n\r\ninterface IInsurancePool {\r\n    function setPTokenToIns(address pToken, address ins) external;\r\n    function destroyPToken(address pToken, uint256 amount, address token) external;\r\n    function eliminate(address pToken, address token) external;\r\n    function setLatestTime(address token) external;\r\n}\r\n// File: iface/IERC20.sol\r\n\r\npragma solidity ^0.6.12;\r\n\r\ninterface IERC20 {\r\n\tfunction decimals() external view returns (uint8);\r\n\tfunction name() external view returns (string memory);\r\n\tfunction symbol() external view returns (string memory);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address who) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n// File: lib/Address.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n        (bool success, ) = recipient.call{value:amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n// File: lib/SafeERC20.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(ERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(ERC20 token, address spender, uint256 value) internal {\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(ERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(ERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n    function callOptionalReturn(ERC20 token, bytes memory data) private {\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n// File: lib/TransferHelper.sol\r\n\r\npragma solidity ^0.6.12;\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n// File: iface/IPTokenFactory.sol\r\n\r\npragma solidity ^0.6.12;\r\n\r\ninterface IPTokenFactory {\r\n    function getGovernance() external view returns(address);\r\n    function getPTokenOperator(address contractAddress) external view returns(bool);\r\n    function getPTokenAuthenticity(address pToken) external view returns(bool);\r\n}\r\n// File: iface/IParasset.sol\r\n\r\npragma solidity ^0.6.12;\r\n\r\ninterface IParasset {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address who) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n    function destroy(uint256 amount, address account) external;\r\n    function issuance(uint256 amount, address account) external;\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n// File: lib/SafeMath.sol\r\n\r\npragma solidity ^0.6.12;\r\n\r\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\r\n\r\nlibrary SafeMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, 'ds-math-add-overflow');\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\r\n    }\r\n\r\n    function div(uint x, uint y) internal pure returns (uint z) {\r\n        require(y > 0, \"ds-math-div-zero\");\r\n        z = x / y;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    }\r\n}\r\n// File: PToken.sol\r\n\r\npragma solidity ^0.6.12;\r\n\r\ncontract PToken is IParasset {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n    mapping (address => mapping (address => uint256)) private _allowed;\r\n    uint256 public _totalSupply = 0;                                        \r\n    string public name = \"\";\r\n    string public symbol = \"\";\r\n    uint8 public decimals = 18;\r\n\r\n    IPTokenFactory pTokenFactory;\r\n\r\n    constructor (string memory _name, \r\n                 string memory _symbol) public {\r\n    \tname = _name;                                                               \r\n    \tsymbol = _symbol;\r\n    \tpTokenFactory = IPTokenFactory(address(msg.sender));\r\n    }\r\n\r\n    //---------modifier---------\r\n\r\n    modifier onlyGovernance() {\r\n        require(address(msg.sender) == pTokenFactory.getGovernance(), \"Log:PToken:!governance\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyPool() {\r\n    \trequire(pTokenFactory.getPTokenOperator(address(msg.sender)), \"Log:PToken:!Pool\");\r\n    \t_;\r\n    }\r\n\r\n    //---------view---------\r\n\r\n    // Query factory contract address\r\n    function getPTokenFactory() public view returns(address) {\r\n        return address(pTokenFactory);\r\n    }\r\n\r\n    /// @notice The view of totalSupply\r\n    /// @return The total supply of ntoken\r\n    function totalSupply() override public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /// @dev The view of balances\r\n    /// @param owner The address of an account\r\n    /// @return The balance of the account\r\n    function balanceOf(address owner) override public view returns (uint256) {\r\n        return _balances[owner];\r\n    }\r\n\r\n    function allowance(address owner, address spender) override public view returns (uint256) {\r\n        return _allowed[owner][spender];\r\n    }\r\n\r\n    //---------transaction---------\r\n\r\n    function changeFactory(address factory) public onlyGovernance {\r\n        pTokenFactory = IPTokenFactory(address(factory));\r\n    }\r\n\r\n    function rename(string memory _name, \r\n                    string memory _symbol) public onlyGovernance {\r\n        name = _name;                                                               \r\n        symbol = _symbol;\r\n    }\r\n\r\n    function transfer(address to, uint256 value) override public returns (bool) \r\n    {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint256 value) override public returns (bool) \r\n    {\r\n        require(spender != address(0));\r\n        _allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 value) override public returns (bool) \r\n    {\r\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\r\n        _transfer(from, to, value);\r\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) \r\n    {\r\n        require(spender != address(0));\r\n\r\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\r\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) \r\n    {\r\n        require(spender != address(0));\r\n\r\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\r\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address from, address to, uint256 value) internal {\r\n        _balances[from] = _balances[from].sub(value);\r\n        _balances[to] = _balances[to].add(value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    function destroy(uint256 amount, address account) override external onlyPool{\r\n    \trequire(_balances[account] >= amount, \"Log:PToken:!destroy\");\r\n    \t_balances[account] = _balances[account].sub(amount);\r\n    \t_totalSupply = _totalSupply.sub(amount);\r\n    \temit Transfer(account, address(0x0), amount);\r\n    }\r\n\r\n    function issuance(uint256 amount, address account) override external onlyPool{\r\n    \t_balances[account] = _balances[account].add(amount);\r\n    \t_totalSupply = _totalSupply.add(amount);\r\n    \temit Transfer(address(0x0), account, amount);\r\n    }\r\n}\r\n// File: MortgagePool.sol\r\n\r\npragma solidity ^0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\ncontract MortgagePool is ReentrancyGuard {\r\n\tusing SafeMath for uint256;\r\n\tusing SafeERC20 for ERC20;\r\n\r\n    // Governance address\r\n\taddress public governance;\r\n\t// Underlying asset address => PToken address\r\n\tmapping(address=>address) public underlyingToPToken;\r\n\t// PToken address => Underlying asset address\r\n\tmapping(address=>address) public pTokenToUnderlying;\r\n    // PToken address => Mortgage asset address => Bool\r\n\tmapping(address=>mapping(address=>bool)) mortgageAllow;\r\n    // PToken address => Mortgage asset address => User address => Debt data\r\n\tmapping(address=>mapping(address=>mapping(address=>PersonalLedger))) ledger;\r\n    // PToken address => Mortgage asset address => Users who have created debt positions(address)\r\n    mapping(address=>mapping(address=>address[])) ledgerArray;\r\n    // Mortgage asset address => Maximum mortgage rate\r\n    mapping(address=>uint256) maxRate;\r\n    // Mortgage asset address => Liquidation line\r\n    mapping(address=>uint256) liquidationLine;\r\n    // PriceController contract\r\n    IPriceController quary;\r\n    // Insurance pool contract\r\n    IInsurancePool insurancePool;\r\n    // PToken creation factory contract\r\n    IPTokenFactory pTokenFactory;\r\n\t// Market base interest rate\r\n\tuint256 r0 = 0.025 ether;\r\n\t// Amount of blocks produced in a year\r\n\tuint256 oneYear = 2400000;\r\n    // Status\r\n    uint8 public flag;      // = 0: pause\r\n                            // = 1: active\r\n                            // = 2: out only\r\n\r\n\tstruct PersonalLedger {\r\n        uint256 mortgageAssets;         // Amount of mortgaged assets\r\n        uint256 parassetAssets;         // Amount of debt(Ptoken,Stability fee not included)\r\n        uint256 blockHeight;            // The block height of the last operation\r\n        uint256 rate;                   // Mortgage rate(Initial mortgage rate,Mortgage rate after the last operation)\r\n        bool created;                   // Is it created\r\n    }\r\n\r\n    event FeeValue(address pToken, uint256 value);\r\n\r\n    /// @dev Initialization method\r\n    /// @param factoryAddress PToken creation factory contract\r\n\tconstructor (address factoryAddress) public {\r\n        pTokenFactory = IPTokenFactory(factoryAddress);\r\n        governance = pTokenFactory.getGovernance();\r\n        flag = 0;\r\n    }\r\n\r\n    //---------modifier---------\r\n\r\n    modifier onlyGovernance() {\r\n        require(msg.sender == governance, \"Log:MortgagePool:!gov\");\r\n        _;\r\n    }\r\n\r\n    modifier whenActive() {\r\n        require(flag == 1, \"Log:MortgagePool:!active\");\r\n        _;\r\n    }\r\n\r\n    modifier outOnly() {\r\n        require(flag != 0, \"Log:MortgagePool:!0\");\r\n        _;\r\n    }\r\n\r\n    //---------view---------\r\n\r\n    /// @dev Calculate the stability fee\r\n    /// @param parassetAssets Amount of debt(Ptoken,Stability fee not included)\r\n    /// @param blockHeight The block height of the last operation\r\n    /// @param rate Mortgage rate(Initial mortgage rate,Mortgage rate after the last operation)\r\n    /// @param nowRate Current mortgage rate (not including stability fee)\r\n    /// @return fee\r\n    function getFee(uint256 parassetAssets, \r\n    \t            uint256 blockHeight,\r\n    \t            uint256 rate,\r\n                    uint256 nowRate) public view returns(uint256) {\r\n        uint256 topOne = parassetAssets.mul(r0).mul(block.number.sub(blockHeight));\r\n        uint256 ratePlus = rate.add(nowRate);\r\n        uint256 topTwo = parassetAssets.mul(r0).mul(block.number.sub(blockHeight)).mul(uint256(3).mul(ratePlus));\r\n    \tuint256 bottom = oneYear.mul(1 ether);\r\n    \treturn topOne.div(bottom).add(topTwo.div(bottom.mul(1 ether).mul(2)));\r\n    }\r\n\r\n    /// @dev Calculate the mortgage rate\r\n    /// @param mortgageAssets Amount of mortgaged assets\r\n    /// @param parassetAssets Amount of debt\r\n    /// @param tokenPrice Mortgage asset price(1 ETH = ? token)\r\n    /// @param pTokenPrice PToken price(1 ETH = ? pToken)\r\n    /// @return mortgage rate\r\n    function getMortgageRate(uint256 mortgageAssets,\r\n    \t                     uint256 parassetAssets, \r\n    \t                     uint256 tokenPrice, \r\n    \t                     uint256 pTokenPrice) public pure returns(uint256) {\r\n        if (mortgageAssets == 0 || pTokenPrice == 0) {\r\n            return 0;\r\n        }\r\n    \treturn parassetAssets.mul(tokenPrice).mul(1 ether).div(pTokenPrice.mul(mortgageAssets));\r\n    }\r\n\r\n    /// @dev Get real-time data of the current debt warehouse\r\n    /// @param mortgageToken Mortgage asset address\r\n    /// @param pToken PToken address\r\n    /// @param tokenPrice Mortgage asset price(1 ETH = ? token)\r\n    /// @param uTokenPrice Underlying asset price(1 ETH = ? Underlying asset)\r\n    /// @param maxRateNum Maximum mortgage rate\r\n    /// @param owner Debt owner\r\n    /// @return fee Stability fee\r\n    /// @return mortgageRate Real-time mortgage rate(Including stability fee)\r\n    /// @return maxSubM The maximum amount of mortgage assets can be reduced\r\n    /// @return maxAddP Maximum number of coins that can be added\r\n    function getInfoRealTime(address mortgageToken, \r\n                             address pToken, \r\n                             uint256 tokenPrice, \r\n                             uint256 uTokenPrice,\r\n                             uint256 maxRateNum,\r\n                             uint256 owner) public view returns(uint256 fee, \r\n                                                                uint256 mortgageRate, \r\n                                                                uint256 maxSubM, \r\n                                                                uint256 maxAddP) {\r\n        PersonalLedger memory pLedger = ledger[pToken][mortgageToken][address(owner)];\r\n        if (pLedger.mortgageAssets == 0 && pLedger.parassetAssets == 0) {\r\n            return (0,0,0,0);\r\n        }\r\n        uint256 pTokenPrice = getDecimalConversion(pTokenToUnderlying[pToken], uTokenPrice, pToken);\r\n        uint256 tokenPriceAmount = tokenPrice;\r\n        fee = getFee(pLedger.parassetAssets, pLedger.blockHeight, pLedger.rate, getMortgageRate(pLedger.mortgageAssets, pLedger.parassetAssets, tokenPriceAmount, pTokenPrice));\r\n        mortgageRate = getMortgageRate(pLedger.mortgageAssets, pLedger.parassetAssets.add(fee), tokenPriceAmount, pTokenPrice);\r\n        uint256 maxRateEther = maxRateNum.mul(0.01 ether);\r\n        if (mortgageRate >= maxRateEther) {\r\n            maxSubM = 0;\r\n            maxAddP = 0;\r\n        } else {\r\n            maxSubM = pLedger.mortgageAssets.sub(pLedger.parassetAssets.mul(tokenPriceAmount).mul(1 ether).div(maxRateEther.mul(pTokenPrice)));\r\n            maxAddP = pLedger.mortgageAssets.mul(pTokenPrice).mul(maxRateEther).div(uint256(1 ether).mul(tokenPriceAmount)).sub(pLedger.parassetAssets);\r\n        }\r\n    }\r\n    \r\n    /// @dev Uniform accuracy\r\n    /// @param inputToken Initial token\r\n    /// @param inputTokenAmount Amount of token\r\n    /// @param outputToken Converted token\r\n    /// @return stability Amount of outputToken\r\n    function getDecimalConversion(address inputToken, \r\n    \t                          uint256 inputTokenAmount, \r\n    \t                          address outputToken) public view returns(uint256) {\r\n    \tuint256 inputTokenDec = 18;\r\n    \tuint256 outputTokenDec = 18;\r\n    \tif (inputToken != address(0x0)) {\r\n    \t\tinputTokenDec = IERC20(inputToken).decimals();\r\n    \t}\r\n\r\n    \tif (outputToken != address(0x0)) {\r\n    \t\toutputTokenDec = IERC20(outputToken).decimals();\r\n    \t}\r\n    \treturn inputTokenAmount.mul(10**outputTokenDec).div(10**inputTokenDec);\r\n    }\r\n\r\n    /// @dev View debt warehouse data\r\n    /// @param pToken pToken address\r\n    /// @param mortgageToken mortgage asset address\r\n    /// @param owner debt owner\r\n    /// @return mortgageAssets amount of mortgaged assets\r\n    /// @return parassetAssets amount of debt(Ptoken,Stability fee not included)\r\n    /// @return blockHeight the block height of the last operation\r\n    /// @return rate Mortgage rate(Initial mortgage rate,Mortgage rate after the last operation)\r\n    /// @return created is it created\r\n    function getLedger(address pToken, \r\n    \t               address mortgageToken,\r\n                       address owner) public view returns(uint256 mortgageAssets, \r\n    \t\t                                              uint256 parassetAssets, \r\n    \t\t                                              uint256 blockHeight,\r\n                                                          uint256 rate,\r\n                                                          bool created) {\r\n    \tPersonalLedger memory pLedger = ledger[pToken][mortgageToken][address(owner)];\r\n    \treturn (pLedger.mortgageAssets, pLedger.parassetAssets, pLedger.blockHeight, pLedger.rate, pLedger.created);\r\n    }\r\n\r\n    /// @dev View governance address\r\n    /// @return governance address\r\n    function getGovernance() external view returns(address) {\r\n        return governance;\r\n    }\r\n\r\n    /// @dev View insurance pool address\r\n    /// @return insurance pool address\r\n    function getInsurancePool() external view returns(address) {\r\n        return address(insurancePool);\r\n    }\r\n\r\n    /// @dev View the market base interest rate\r\n    /// @return market base interest rate\r\n    function getR0() external view returns(uint256) {\r\n    \treturn r0;\r\n    }\r\n\r\n    /// @dev View the amount of blocks produced in a year\r\n    /// @return amount of blocks produced in a year\r\n    function getOneYear() external view returns(uint256) {\r\n    \treturn oneYear;\r\n    }\r\n\r\n    /// @dev View the maximum mortgage rate\r\n    /// @param mortgageToken Mortgage asset address\r\n    /// @return maximum mortgage rate\r\n    function getMaxRate(address mortgageToken) external view returns(uint256) {\r\n    \treturn maxRate[mortgageToken];\r\n    }\r\n\r\n    /// @dev View the liquidation line\r\n    /// @param mortgageToken Mortgage asset address\r\n    /// @return liquidation line\r\n    function getLiquidationLine(address mortgageToken) external view returns(uint256) {\r\n        return liquidationLine[mortgageToken];\r\n    }\r\n\r\n    /// @dev View the priceController contract address\r\n    /// @return priceController contract address\r\n    function getPriceController() external view returns(address) {\r\n        return address(quary);\r\n    }\r\n\r\n    /// @dev View the ptoken address according to the underlying asset\r\n    /// @param uToken Underlying asset address\r\n    /// @return ptoken address\r\n    function getUnderlyingToPToken(address uToken) external view returns(address) {\r\n        return underlyingToPToken[uToken];\r\n    }\r\n\r\n    /// @dev View the underlying asset according to the ptoken address\r\n    /// @param pToken ptoken address\r\n    /// @return underlying asset\r\n    function getPTokenToUnderlying(address pToken) external view returns(address) {\r\n        return pTokenToUnderlying[pToken];\r\n    }\r\n\r\n    /// @dev View the debt array length\r\n    /// @param pToken ptoken address\r\n    /// @param mortgageToken mortgage asset address\r\n    /// @return debt array length\r\n    function getLedgerArrayNum(address pToken, \r\n                               address mortgageToken) external view returns(uint256) {\r\n        return ledgerArray[pToken][mortgageToken].length;\r\n    }\r\n\r\n    /// @dev View the debt owner\r\n    /// @param pToken ptoken address\r\n    /// @param mortgageToken mortgage asset address\r\n    /// @param index array subscript\r\n    /// @return debt owner\r\n    function getLedgerAddress(address pToken, \r\n                              address mortgageToken, \r\n                              uint256 index) external view returns(address) {\r\n        return ledgerArray[pToken][mortgageToken][index];\r\n    }\r\n\r\n    //---------governance----------\r\n\r\n    /// @dev Set contract status\r\n    /// @param num 0: pause, 1: active, 2: out only\r\n    function setFlag(uint8 num) public onlyGovernance {\r\n        flag = num;\r\n    }\r\n\r\n    /// @dev Allow asset mortgage to generate ptoken\r\n    /// @param pToken ptoken address\r\n    /// @param mortgageToken mortgage asset address\r\n    /// @param allow allow mortgage\r\n    function setMortgageAllow(address pToken, \r\n    \t                      address mortgageToken, \r\n    \t                      bool allow) public onlyGovernance {\r\n    \tmortgageAllow[pToken][mortgageToken] = allow;\r\n    }\r\n\r\n    /// @dev Set insurance pool contract\r\n    /// @param add insurance pool contract\r\n    function setInsurancePool(address add) public onlyGovernance {\r\n        insurancePool = IInsurancePool(add);\r\n    }\r\n\r\n    /// @dev Set market base interest rate\r\n    /// @param num market base interest rate(num = ? * 1 ether)\r\n    function setR0(uint256 num) public onlyGovernance {\r\n    \tr0 = num;\r\n    }\r\n\r\n    /// @dev Set the amount of blocks produced in a year\r\n    /// @param num amount of blocks produced in a year\r\n    function setOneYear(uint256 num) public onlyGovernance {\r\n    \toneYear = num;\r\n    }\r\n\r\n    /// @dev Set liquidation line\r\n    /// @param mortgageToken mortgage asset address\r\n    /// @param num liquidation line(num = ? * 100)\r\n    function setLiquidationLine(address mortgageToken, \r\n                                uint256 num) public onlyGovernance {\r\n        liquidationLine[mortgageToken] = num.mul(0.01 ether);\r\n    }\r\n\r\n    /// @dev Set the maximum mortgage rate\r\n    /// @param mortgageToken mortgage asset address\r\n    /// @param num maximum mortgage rate(num = ? * 100)\r\n    function setMaxRate(address mortgageToken, \r\n                        uint256 num) public onlyGovernance {\r\n    \tmaxRate[mortgageToken] = num.mul(0.01 ether);\r\n    }\r\n\r\n    /// @dev Set priceController contract address\r\n    /// @param add priceController contract address\r\n    function setPriceController(address add) public onlyGovernance {\r\n        quary = IPriceController(add);\r\n    }\r\n\r\n    /// @dev Set the underlying asset and ptoken mapping and\r\n    ///      Set the latest redemption time of ptoken insurance\r\n    /// @param uToken underlying asset address\r\n    /// @param pToken ptoken address\r\n    function setInfo(address uToken, \r\n                     address pToken) public onlyGovernance {\r\n        require(underlyingToPToken[uToken] == address(0x0), \"Log:MortgagePool:underlyingToPToken\");\r\n        require(address(insurancePool) != address(0x0), \"Log:MortgagePool:0x0\");\r\n        underlyingToPToken[uToken] = address(pToken);\r\n        pTokenToUnderlying[address(pToken)] = uToken;\r\n        insurancePool.setLatestTime(uToken);\r\n    }\r\n\r\n    //---------transaction---------\r\n\r\n    /// @dev Set governance address\r\n    function setGovernance() public {\r\n        governance = pTokenFactory.getGovernance();\r\n        require(governance != address(0x0), \"Log:MortgagePool:0x0\");\r\n    }\r\n\r\n    /// @dev Mortgage asset casting ptoken\r\n    /// @param mortgageToken mortgage asset address\r\n    /// @param pToken ptoken address\r\n    /// @param amount amount of mortgaged assets\r\n    /// @param rate custom mortgage rate\r\n    function coin(address mortgageToken, \r\n                  address pToken, \r\n                  uint256 amount, \r\n                  uint256 rate) public payable whenActive nonReentrant {\r\n\r\n    \trequire(mortgageAllow[pToken][mortgageToken], \"Log:MortgagePool:!mortgageAllow\");\r\n        require(rate > 0 && rate <= maxRate[mortgageToken], \"Log:MortgagePool:rate!=0\");\r\n        require(amount > 0, \"Log:MortgagePool:amount!=0\");\r\n    \tPersonalLedger storage pLedger = ledger[pToken][mortgageToken][address(msg.sender)];\r\n        uint256 parassetAssets = pLedger.parassetAssets;\r\n        uint256 mortgageAssets = pLedger.mortgageAssets;\r\n\r\n    \t// Get the price and transfer to the mortgage token\r\n        uint256 tokenPrice;\r\n        uint256 pTokenPrice;\r\n        if (mortgageToken != address(0x0)) {\r\n            ERC20(mortgageToken).safeTransferFrom(address(msg.sender), address(this), amount);\r\n            (tokenPrice, pTokenPrice) = getPriceForPToken(mortgageToken, pTokenToUnderlying[pToken], msg.value);\r\n        } else {\r\n            require(msg.value >= amount, \"Log:MortgagePool:!msg.value\");\r\n            (tokenPrice, pTokenPrice) = getPriceForPToken(mortgageToken, pTokenToUnderlying[pToken], uint256(msg.value).sub(amount));\r\n        }\r\n\r\n        // Calculate the stability fee\r\n        uint256 blockHeight = pLedger.blockHeight;\r\n        uint256 fee = 0;\r\n    \tif (parassetAssets > 0 && block.number > blockHeight && blockHeight != 0) {\r\n            fee = getFee(parassetAssets, blockHeight, pLedger.rate, getMortgageRate(mortgageAssets, parassetAssets, tokenPrice, pTokenPrice));\r\n            // The stability fee is transferred to the insurance pool\r\n            ERC20(pToken).safeTransferFrom(address(msg.sender), address(insurancePool), fee);\r\n            // Eliminate negative accounts\r\n            insurancePool.eliminate(pToken, pTokenToUnderlying[pToken]);\r\n            emit FeeValue(pToken, fee);\r\n    \t}\r\n\r\n        // Additional ptoken issuance\r\n        uint256 pTokenAmount = amount.mul(pTokenPrice).mul(rate).div(tokenPrice.mul(100));\r\n        PToken(pToken).issuance(pTokenAmount, address(msg.sender));\r\n\r\n        // Update debt information\r\n        pLedger.mortgageAssets = mortgageAssets.add(amount);\r\n        pLedger.parassetAssets = parassetAssets.add(pTokenAmount);\r\n        pLedger.blockHeight = block.number;\r\n        pLedger.rate = getMortgageRate(pLedger.mortgageAssets, pLedger.parassetAssets, tokenPrice, pTokenPrice);\r\n\r\n        // Tag created\r\n        if (pLedger.created == false) {\r\n            ledgerArray[pToken][mortgageToken].push(address(msg.sender));\r\n            pLedger.created = true;\r\n        }\r\n    }\r\n    \r\n    /// @dev Increase mortgage assets\r\n    /// @param mortgageToken mortgage asset address\r\n    /// @param pToken ptoken address\r\n    /// @param amount amount of mortgaged assets\r\n    function supplement(address mortgageToken, \r\n                        address pToken, \r\n                        uint256 amount) public payable outOnly nonReentrant {\r\n\r\n    \trequire(mortgageAllow[pToken][mortgageToken], \"Log:MortgagePool:!mortgageAllow\");\r\n        require(amount > 0, \"Log:MortgagePool:!amount\");\r\n    \tPersonalLedger storage pLedger = ledger[pToken][mortgageToken][address(msg.sender)];\r\n        uint256 parassetAssets = pLedger.parassetAssets;\r\n        uint256 mortgageAssets = pLedger.mortgageAssets;\r\n        require(pLedger.created, \"Log:MortgagePool:!created\");\r\n\r\n    \t// Get the price and transfer to the mortgage token\r\n        uint256 tokenPrice;\r\n        uint256 pTokenPrice;\r\n        if (mortgageToken != address(0x0)) {\r\n            ERC20(mortgageToken).safeTransferFrom(address(msg.sender), address(this), amount);\r\n            (tokenPrice, pTokenPrice) = getPriceForPToken(mortgageToken, pTokenToUnderlying[pToken], msg.value);\r\n        } else {\r\n            require(msg.value >= amount, \"Log:MortgagePool:!msg.value\");\r\n            (tokenPrice, pTokenPrice) = getPriceForPToken(mortgageToken, pTokenToUnderlying[pToken], uint256(msg.value).sub(amount));\r\n        }\r\n\r\n        // Calculate the stability fee\r\n        uint256 blockHeight = pLedger.blockHeight;\r\n        uint256 fee = 0;\r\n    \tif (parassetAssets > 0 && block.number > blockHeight && blockHeight != 0) {\r\n            fee = getFee(parassetAssets, blockHeight, pLedger.rate, getMortgageRate(mortgageAssets, parassetAssets, tokenPrice, pTokenPrice));\r\n            // The stability fee is transferred to the insurance pool\r\n            ERC20(pToken).safeTransferFrom(address(msg.sender), address(insurancePool), fee);\r\n            // Eliminate negative accounts\r\n            insurancePool.eliminate(pToken, pTokenToUnderlying[pToken]);\r\n            emit FeeValue(pToken, fee);\r\n    \t}\r\n\r\n        // Update debt information\r\n    \tpLedger.mortgageAssets = mortgageAssets.add(amount);\r\n    \tpLedger.blockHeight = block.number;\r\n        pLedger.rate = getMortgageRate(pLedger.mortgageAssets, parassetAssets, tokenPrice, pTokenPrice);\r\n    }\r\n\r\n    /// @dev Reduce mortgage assets\r\n    /// @param mortgageToken mortgage asset address\r\n    /// @param pToken ptoken address\r\n    /// @param amount amount of mortgaged assets\r\n    function decrease(address mortgageToken, \r\n                      address pToken, \r\n                      uint256 amount) public payable outOnly nonReentrant {\r\n\r\n    \trequire(mortgageAllow[pToken][mortgageToken], \"Log:MortgagePool:!mortgageAllow\");\r\n    \tPersonalLedger storage pLedger = ledger[pToken][mortgageToken][address(msg.sender)];\r\n        uint256 parassetAssets = pLedger.parassetAssets;\r\n        uint256 mortgageAssets = pLedger.mortgageAssets;\r\n        require(amount > 0 && amount <= mortgageAssets, \"Log:MortgagePool:!amount\");\r\n        require(pLedger.created, \"Log:MortgagePool:!created\");\r\n\r\n    \t// Get the price\r\n        (uint256 tokenPrice, uint256 pTokenPrice) = getPriceForPToken(mortgageToken, pTokenToUnderlying[pToken], msg.value);\r\n\r\n        // Calculate the stability fee\r\n        uint256 blockHeight = pLedger.blockHeight;\r\n        uint256 fee = 0;\r\n    \tif (parassetAssets > 0 && block.number > blockHeight && blockHeight != 0) {\r\n            fee = getFee(parassetAssets, blockHeight, pLedger.rate, getMortgageRate(mortgageAssets, parassetAssets, tokenPrice, pTokenPrice));\r\n            // The stability fee is transferred to the insurance pool\r\n            ERC20(pToken).safeTransferFrom(address(msg.sender), address(insurancePool), fee);\r\n            // Eliminate negative accounts\r\n            insurancePool.eliminate(pToken, pTokenToUnderlying[pToken]);\r\n            emit FeeValue(pToken, fee);\r\n    \t}\r\n\r\n        // Update debt information\r\n    \tpLedger.mortgageAssets = mortgageAssets.sub(amount);\r\n    \tpLedger.blockHeight = block.number;\r\n        pLedger.rate = getMortgageRate(pLedger.mortgageAssets, parassetAssets, tokenPrice, pTokenPrice);\r\n\r\n        // The debt warehouse mortgage rate cannot be greater than the maximum mortgage rate\r\n    \trequire(pLedger.rate <= maxRate[mortgageToken], \"Log:MortgagePool:!maxRate\");\r\n\r\n    \t// Transfer out mortgage assets\r\n    \tif (mortgageToken != address(0x0)) {\r\n    \t\tERC20(mortgageToken).safeTransfer(address(msg.sender), amount);\r\n    \t} else {\r\n            TransferHelper.safeTransferETH(address(msg.sender), amount);\r\n    \t}\r\n    }\r\n\r\n    /// @dev Increase debt (increase coinage)\r\n    /// @param mortgageToken mortgage asset address\r\n    /// @param pToken ptoken address\r\n    /// @param amount amount of debt\r\n    function increaseCoinage(address mortgageToken,\r\n                             address pToken,\r\n                             uint256 amount) public payable whenActive nonReentrant {\r\n\r\n        require(mortgageAllow[pToken][mortgageToken], \"Log:MortgagePool:!mortgageAllow\");\r\n        require(amount > 0, \"Log:MortgagePool:!amount\");\r\n        PersonalLedger storage pLedger = ledger[pToken][mortgageToken][address(msg.sender)];\r\n        uint256 parassetAssets = pLedger.parassetAssets;\r\n        uint256 mortgageAssets = pLedger.mortgageAssets;\r\n        require(pLedger.created, \"Log:MortgagePool:!created\");\r\n\r\n        // Get the price\r\n        (uint256 tokenPrice, uint256 pTokenPrice) = getPriceForPToken(mortgageToken, pTokenToUnderlying[pToken], msg.value);\r\n\r\n        // Calculate the stability fee\r\n        uint256 blockHeight = pLedger.blockHeight;\r\n        uint256 fee = 0;\r\n        if (parassetAssets > 0 && block.number > blockHeight && blockHeight != 0) {\r\n            fee = getFee(parassetAssets, blockHeight, pLedger.rate, getMortgageRate(mortgageAssets, parassetAssets, tokenPrice, pTokenPrice));\r\n            // The stability fee is transferred to the insurance pool\r\n            ERC20(pToken).safeTransferFrom(address(msg.sender), address(insurancePool), fee);\r\n            // Eliminate negative accounts\r\n            insurancePool.eliminate(pToken, pTokenToUnderlying[pToken]);\r\n            emit FeeValue(pToken, fee);\r\n        }\r\n\r\n        // Update debt information\r\n        pLedger.parassetAssets = parassetAssets.add(amount);\r\n        pLedger.blockHeight = block.number;\r\n        pLedger.rate = getMortgageRate(mortgageAssets, pLedger.parassetAssets, tokenPrice, pTokenPrice);\r\n\r\n        // The debt warehouse mortgage rate cannot be greater than the maximum mortgage rate\r\n        require(pLedger.rate <= maxRate[mortgageToken], \"Log:MortgagePool:!maxRate\");\r\n\r\n        // Additional ptoken issuance\r\n        PToken(pToken).issuance(amount, address(msg.sender));\r\n    }\r\n\r\n    /// @dev Reduce debt (increase coinage)\r\n    /// @param mortgageToken mortgage asset address\r\n    /// @param pToken ptoken address\r\n    /// @param amount amount of debt\r\n    function reducedCoinage(address mortgageToken,\r\n                            address pToken,\r\n                            uint256 amount) public payable outOnly nonReentrant {\r\n\r\n        require(mortgageAllow[pToken][mortgageToken], \"Log:MortgagePool:!mortgageAllow\");\r\n        PersonalLedger storage pLedger = ledger[pToken][mortgageToken][address(msg.sender)];\r\n        uint256 parassetAssets = pLedger.parassetAssets;\r\n        uint256 mortgageAssets = pLedger.mortgageAssets;\r\n        address uToken = pTokenToUnderlying[pToken];\r\n        require(amount > 0 && amount <= parassetAssets, \"Log:MortgagePool:!amount\");\r\n        require(pLedger.created, \"Log:MortgagePool:!created\");\r\n\r\n        // Get the price\r\n        (uint256 tokenPrice, uint256 pTokenPrice) = getPriceForPToken(mortgageToken, uToken, msg.value);\r\n\r\n        // Calculate the stability fee\r\n        uint256 blockHeight = pLedger.blockHeight;\r\n        uint256 fee = 0;\r\n        if (parassetAssets > 0 && block.number > blockHeight && blockHeight != 0) {\r\n            fee = getFee(parassetAssets, blockHeight, pLedger.rate, getMortgageRate(mortgageAssets, parassetAssets, tokenPrice, pTokenPrice));\r\n            // The stability fee is transferred to the insurance pool\r\n            ERC20(pToken).safeTransferFrom(address(msg.sender), address(insurancePool), amount.add(fee));\r\n            // Eliminate negative accounts\r\n            insurancePool.eliminate(pToken, uToken);\r\n            emit FeeValue(pToken, fee);\r\n        }\r\n\r\n        // Update debt information\r\n        pLedger.parassetAssets = parassetAssets.sub(amount);\r\n        pLedger.blockHeight = block.number;\r\n        pLedger.rate = getMortgageRate(mortgageAssets, pLedger.parassetAssets, tokenPrice, pTokenPrice);\r\n\r\n        // Destroy ptoken\r\n        insurancePool.destroyPToken(pToken, amount, uToken);\r\n    }\r\n\r\n    /// @dev Liquidation of debt\r\n    /// @param mortgageToken mortgage asset address\r\n    /// @param pToken ptoken address\r\n    /// @param account debt owner address\r\n    /// @param amount amount of mortgaged assets\r\n    function liquidation(address mortgageToken, \r\n                         address pToken,\r\n                         address account,\r\n                         uint256 amount) public payable outOnly nonReentrant {\r\n\r\n    \trequire(mortgageAllow[pToken][mortgageToken], \"Log:MortgagePool:!mortgageAllow\");\r\n    \tPersonalLedger storage pLedger = ledger[pToken][mortgageToken][account];\r\n        require(pLedger.created, \"Log:MortgagePool:!created\");\r\n        uint256 parassetAssets = pLedger.parassetAssets;\r\n        uint256 mortgageAssets = pLedger.mortgageAssets;\r\n        require(amount > 0 && amount <= mortgageAssets, \"Log:MortgagePool:!amount\");\r\n\r\n    \t// Get the price\r\n        address uToken = pTokenToUnderlying[pToken];\r\n    \t(uint256 tokenPrice, uint256 pTokenPrice) = getPriceForPToken(mortgageToken, uToken, msg.value);\r\n        \r\n        // Judging the liquidation line\r\n        checkLine(pLedger, tokenPrice, pTokenPrice, mortgageToken);\r\n\r\n        // Calculate the amount of ptoken\r\n        uint256 pTokenAmount = amount.mul(pTokenPrice).mul(90).div(tokenPrice.mul(100));\r\n    \t// Transfer to ptoken\r\n    \tERC20(pToken).safeTransferFrom(address(msg.sender), address(insurancePool), pTokenAmount);\r\n\r\n    \t// Eliminate negative accounts\r\n        insurancePool.eliminate(pToken, uToken);\r\n\r\n        // Calculate the debt for destruction\r\n        uint256 offset = parassetAssets.mul(amount).div(mortgageAssets);\r\n\r\n        // Destroy ptoken\r\n    \tinsurancePool.destroyPToken(pToken, offset, uToken);\r\n\r\n    \t// Update debt information\r\n    \tpLedger.mortgageAssets = mortgageAssets.sub(amount);\r\n        pLedger.parassetAssets = parassetAssets.sub(offset);\r\n        // MortgageAssets liquidation, mortgage rate and block number are not updated\r\n        if (pLedger.mortgageAssets == 0) {\r\n            pLedger.parassetAssets = 0;\r\n            pLedger.blockHeight = 0;\r\n            pLedger.rate = 0;\r\n        }\r\n\r\n    \t// Transfer out mortgage asset\r\n    \tif (mortgageToken != address(0x0)) {\r\n    \t\tERC20(mortgageToken).safeTransfer(address(msg.sender), amount);\r\n    \t} else {\r\n            TransferHelper.safeTransferETH(address(msg.sender), amount);\r\n    \t}\r\n    }\r\n\r\n    /// @dev Check the liquidation line\r\n    /// @param pLedger debt warehouse ledger\r\n    /// @param tokenPrice Mortgage asset price(1 ETH = ? token)\r\n    /// @param pTokenPrice PToken price(1 ETH = ? pToken)\r\n    /// @param mortgageToken mortgage asset address\r\n    function checkLine(PersonalLedger memory pLedger, \r\n                       uint256 tokenPrice, \r\n                       uint256 pTokenPrice, \r\n                       address mortgageToken) private view {\r\n        uint256 parassetAssets = pLedger.parassetAssets;\r\n        uint256 mortgageAssets = pLedger.mortgageAssets;\r\n        // The current mortgage rate cannot exceed the liquidation line\r\n        uint256 mortgageRate = getMortgageRate(pLedger.mortgageAssets, parassetAssets, tokenPrice, pTokenPrice);\r\n        uint256 fee = 0;\r\n        if (parassetAssets > 0 && block.number > pLedger.blockHeight && pLedger.blockHeight != 0) {\r\n            fee = getFee(parassetAssets, pLedger.blockHeight, pLedger.rate, mortgageRate);\r\n        }\r\n        require(getMortgageRate(mortgageAssets, parassetAssets.add(fee), tokenPrice, pTokenPrice) > liquidationLine[mortgageToken], \"Log:MortgagePool:!liquidationLine\");\r\n    }\r\n\r\n    /// @dev Get price\r\n    /// @param mortgageToken mortgage asset address\r\n    /// @param uToken underlying asset address\r\n    /// @param priceValue price fee\r\n    /// @return tokenPrice Mortgage asset price(1 ETH = ? token)\r\n    /// @return pTokenPrice PToken price(1 ETH = ? pToken)\r\n    function getPriceForPToken(address mortgageToken, \r\n                               address uToken,\r\n                               uint256 priceValue) private returns (uint256 tokenPrice, \r\n                                                                    uint256 pTokenPrice) {\r\n        (tokenPrice, pTokenPrice) = quary.getPriceForPToken{value:priceValue}(mortgageToken, uToken, msg.sender);   \r\n    }\r\n\r\n\r\n    // function takeOutERC20(address token, uint256 amount, address to) public onlyGovernance {\r\n    //     ERC20(token).safeTransfer(address(to), amount);\r\n    // }\r\n\r\n    // function takeOutETH(uint256 amount, address to) public onlyGovernance {\r\n    //     TransferHelper.safeTransferETH(address(to), amount);\r\n    // }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"factoryAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"FeeValue\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mortgageToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"coin\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mortgageToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"decrease\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flag\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"inputToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"inputTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"outputToken\",\"type\":\"address\"}],\"name\":\"getDecimalConversion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"parassetAssets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockHeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nowRate\",\"type\":\"uint256\"}],\"name\":\"getFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGovernance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mortgageToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"uTokenPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxRateNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"owner\",\"type\":\"uint256\"}],\"name\":\"getInfoRealTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mortgageRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSubM\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxAddP\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getInsurancePool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"mortgageToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getLedger\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mortgageAssets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"parassetAssets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockHeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"created\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"mortgageToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getLedgerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"mortgageToken\",\"type\":\"address\"}],\"name\":\"getLedgerArrayNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mortgageToken\",\"type\":\"address\"}],\"name\":\"getLiquidationLine\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mortgageToken\",\"type\":\"address\"}],\"name\":\"getMaxRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mortgageAssets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"parassetAssets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pTokenPrice\",\"type\":\"uint256\"}],\"name\":\"getMortgageRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOneYear\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pToken\",\"type\":\"address\"}],\"name\":\"getPTokenToUnderlying\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPriceController\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getR0\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"uToken\",\"type\":\"address\"}],\"name\":\"getUnderlyingToPToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mortgageToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"increaseCoinage\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mortgageToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"liquidation\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pTokenToUnderlying\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mortgageToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"reducedCoinage\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"num\",\"type\":\"uint8\"}],\"name\":\"setFlag\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"uToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pToken\",\"type\":\"address\"}],\"name\":\"setInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"add\",\"type\":\"address\"}],\"name\":\"setInsurancePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mortgageToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"setLiquidationLine\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mortgageToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"setMaxRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"mortgageToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"allow\",\"type\":\"bool\"}],\"name\":\"setMortgageAllow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"setOneYear\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"add\",\"type\":\"address\"}],\"name\":\"setPriceController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"setR0\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mortgageToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"supplement\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"underlyingToPToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"MortgagePool","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000be612b724b77038bc40a4e4a88335a93a9aa445b","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://18e55ce54b4670fcf69af0b5559a45cc61b1e8922fb694a8c765d214006c1483"}]}