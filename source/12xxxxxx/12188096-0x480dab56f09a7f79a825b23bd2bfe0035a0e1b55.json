{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/lib/math/SafeMath.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/interfaces/IUniswapV2Factory.sol\r\n\r\n\r\npragma solidity >=0.6.0;\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\n// File: contracts/lib/interfaces/IUniswapV2Pair.sol\r\n\r\n\r\npragma solidity >=0.6.0;\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\n// File: contracts/lib/utils/Babylonian.sol\r\n\r\n\r\npragma solidity >=0.6.0;\r\n\r\n// computes square roots using the babylonian method\r\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\r\nlibrary Babylonian {\r\n    function sqrt(uint y) internal pure returns (uint z) {\r\n        if (y > 3) {\r\n            z = y;\r\n            uint x = y / 2 + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n        // else z = 0\r\n    }\r\n}\r\n\r\n// File: contracts/lib/utils/FixedPoint.sol\r\n\r\n\r\npragma solidity >=0.6.0;\r\n\r\n\r\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\r\nlibrary FixedPoint {\r\n    // range: [0, 2**112 - 1]\r\n    // resolution: 1 / 2**112\r\n    struct uq112x112 {\r\n        uint224 _x;\r\n    }\r\n\r\n    // range: [0, 2**144 - 1]\r\n    // resolution: 1 / 2**112\r\n    struct uq144x112 {\r\n        uint _x;\r\n    }\r\n\r\n    uint8 private constant RESOLUTION = 112;\r\n    uint private constant Q112 = uint(1) << RESOLUTION;\r\n    uint private constant Q224 = Q112 << RESOLUTION;\r\n\r\n    // encode a uint112 as a UQ112x112\r\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\r\n        return uq112x112(uint224(x) << RESOLUTION);\r\n    }\r\n\r\n    // encodes a uint144 as a UQ144x112\r\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\r\n        return uq144x112(uint256(x) << RESOLUTION);\r\n    }\r\n\r\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\r\n    function div(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {\r\n        require(x != 0, 'FixedPoint: DIV_BY_ZERO');\r\n        return uq112x112(self._x / uint224(x));\r\n    }\r\n\r\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\r\n    // reverts on overflow\r\n    function mul(uq112x112 memory self, uint y) internal pure returns (uq144x112 memory) {\r\n        uint z;\r\n        require(y == 0 || (z = uint(self._x) * y) / y == uint(self._x), \"FixedPoint: MULTIPLICATION_OVERFLOW\");\r\n        return uq144x112(z);\r\n    }\r\n\r\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\r\n    // equivalent to encode(numerator).div(denominator)\r\n    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\r\n        require(denominator > 0, \"FixedPoint: DIV_BY_ZERO\");\r\n        return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\r\n    }\r\n\r\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\r\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\r\n        return uint112(self._x >> RESOLUTION);\r\n    }\r\n\r\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\r\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\r\n        return uint144(self._x >> RESOLUTION);\r\n    }\r\n\r\n    // take the reciprocal of a UQ112x112\r\n    function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\r\n        require(self._x != 0, 'FixedPoint: ZERO_RECIPROCAL');\r\n        return uq112x112(uint224(Q224 / self._x));\r\n    }\r\n\r\n    // square root of a UQ112x112\r\n    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\r\n        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x)) << 56));\r\n    }\r\n}\r\n\r\n// File: contracts/lib/oracle/UniswapV2OracleLibrary.sol\r\n\r\n\r\npragma solidity >=0.6.0;\r\n\r\n\r\n\r\n\r\n// library with helper methods for oracles that are concerned with computing average prices\r\nlibrary UniswapV2OracleLibrary {\r\n    using FixedPoint for *;\r\n\r\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\r\n    function currentBlockTimestamp() internal view returns (uint32) {\r\n        return uint32(block.timestamp % 2 ** 32);\r\n    }\r\n\r\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\r\n    function currentCumulativePrices(\r\n        address pair\r\n    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\r\n        blockTimestamp = currentBlockTimestamp();\r\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\r\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\r\n\r\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\r\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\r\n        if (blockTimestampLast != blockTimestamp) {\r\n            // subtraction overflow is desired\r\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\r\n            // addition overflow is desired\r\n            // counterfactual\r\n            price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\r\n            // counterfactual\r\n            price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/lib/oracle/AggregatorV3Interface.sol\r\n\r\npragma solidity >=0.6.0;\r\n\r\ninterface AggregatorV3Interface {\r\n\r\n  function decimals() external view returns (uint8);\r\n  function description() external view returns (string memory);\r\n  function version() external view returns (uint256);\r\n\r\n  // getRoundData and latestRoundData should both raise \"No data present\"\r\n  // if they do not have data to report, instead of returning unset values\r\n  // which could be misinterpreted as actual reported values.\r\n  function getRoundData(uint80 _roundId)\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n  function latestRoundData()\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n\r\n}\r\n\r\n// File: contracts/Oracle_pWING_chainlink.sol\r\n\r\npragma solidity >=0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/* \r\n*  This will be used with sushi pWING/ETH to get pWING/USDC price.\r\n*  It will use a TWAP of 1 hr and chainlink sport price to determine of there is recent\r\n*  change in price.  It chooses the lower price between spot and twap. \r\n*/\r\ncontract oracle_pWING_USD {\r\n    using SafeMath for uint256;\r\n    using FixedPoint for *;\r\n\r\n    uint public constant HOURLY = 1 hours;  // 1 hour price updates\r\n\r\n    uint PERIOD; //not used but needed for interface requirments since some oneTokens call update period\r\n\r\n    struct UniswapPair {\r\n        IUniswapV2Pair pair;\r\n        address token0;\r\n        address token1;\r\n        uint price0CumulativeLast;\r\n        uint price1CumulativeLast;\r\n        uint32 blockTimestampLast;\r\n        FixedPoint.uq112x112 price0Average;\r\n        FixedPoint.uq112x112 price1Average;\r\n        uint PERIOD;\r\n    }\r\n\r\n    uint constant numUniswapPairs = 2;\r\n    mapping (uint => UniswapPair) pairs;\r\n\r\n    enum PairTypes{ pWING_ETH_HOURLY, ETH_USDC_HOURLY }\r\n\r\n    address public pWING; \r\n    address public USDC; \r\n    address public WETH;\r\n\r\n    address public owner;  //oneToken address\r\n    uint256 public outputDecimals;\r\n\r\n    address public spotOracle;\r\n    uint256 public spotOracle_decimals;\r\n\r\n    /*\r\n     *  oneToken - will be the owner of this oracle which can run update\r\n     *  factory - sushi factory - mainnet 0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac\r\n     *  pWING - pWING token\r\n     *  USDC - USDC token\r\n     *  WETH - WETH token\r\n     *  chainlink - spotPrice - mainnet 0x134fE0a225Fb8e6683617C13cEB6B3319fB4fb82\r\n     */\r\n    constructor(\r\n        address oneToken, \r\n        address factory, \r\n        address pWING_, \r\n        address USDC_,\r\n        address WETH_, \r\n        uint256 outputDecimals_,\r\n        address spotOracle_) \r\n        public {\r\n\r\n            // spot check price oracle\r\n\r\n            spotOracle = spotOracle_;\r\n            spotOracle_decimals = AggregatorV3Interface(spotOracle)\r\n                .decimals();\r\n\r\n\r\n            IUniswapV2Pair _pair = IUniswapV2Pair(IUniswapV2Factory(factory).getPair(pWING_, WETH_));\r\n            uint112 reserve0;\r\n            uint112 reserve1;\r\n            uint32 blockTimestampLast;\r\n         \r\n            (reserve0, reserve1, blockTimestampLast) = _pair.getReserves();\r\n            require(reserve0 != 0 && reserve1 != 0, 'oracle_pWING_WETH: NO_RESERVES');\r\n\r\n            pairs[uint(PairTypes.pWING_ETH_HOURLY)] = UniswapPair(\r\n                _pair,\r\n                pWING_,\r\n                WETH_,\r\n                _pair.price0CumulativeLast(),\r\n                _pair.price1CumulativeLast(),\r\n                blockTimestampLast,\r\n                FixedPoint.uq112x112(0),\r\n                FixedPoint.uq112x112(0),\r\n                HOURLY\r\n            );\r\n\r\n            _pair = IUniswapV2Pair(IUniswapV2Factory(factory).getPair(USDC_, WETH_));\r\n            (reserve0, reserve1, blockTimestampLast) = _pair.getReserves();\r\n            require(reserve0 != 0 && reserve1 != 0, 'oracle_USDC_WETH: NO_RESERVES');\r\n\r\n            pairs[uint(PairTypes.ETH_USDC_HOURLY)] = UniswapPair(\r\n                _pair,\r\n                USDC_,\r\n                WETH_,\r\n                _pair.price0CumulativeLast(),\r\n                _pair.price1CumulativeLast(),\r\n                blockTimestampLast,\r\n                FixedPoint.uq112x112(0),\r\n                FixedPoint.uq112x112(0),\r\n                HOURLY\r\n            );\r\n\r\n            pWING = pWING_;\r\n            USDC = USDC_;\r\n            WETH = WETH_;\r\n            owner = oneToken;\r\n            outputDecimals = outputDecimals_;\r\n           \r\n    }\r\n\r\n    function changeInterval(uint256 period_) external {\r\n        require(msg.sender == owner, \"unauthorized\");\r\n        PERIOD = period_;\r\n    }\r\n\r\n    function update() external {\r\n        for (uint i = 0; i < numUniswapPairs; i++) {\r\n            (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) =\r\n            UniswapV2OracleLibrary.currentCumulativePrices(address(pairs[i].pair));\r\n            uint32 timeElapsed = blockTimestamp - pairs[i].blockTimestampLast; // overflow is desired\r\n\r\n            if (timeElapsed >= pairs[i].PERIOD || pairs[i].price0Average.mul(1).decode144() == uint(0)) {\r\n                pairs[i].price0Average = FixedPoint.uq112x112(uint224((price0Cumulative - pairs[i].price0CumulativeLast) / timeElapsed));\r\n                pairs[i].price1Average = FixedPoint.uq112x112(uint224((price1Cumulative - pairs[i].price1CumulativeLast) / timeElapsed));\r\n\r\n                pairs[i].price0CumulativeLast = price0Cumulative;\r\n                pairs[i].price1CumulativeLast = price1Cumulative;\r\n                \r\n                pairs[i].blockTimestampLast = blockTimestamp;\r\n            }\r\n        }\r\n    }\r\n\r\n    // note this will always return 0 before update has been called successfully for the first time.\r\n    function consult(uint i, address token, uint amountIn) internal view returns (uint256) {\r\n        uint256 amount;\r\n        if (token == pairs[i].token0) {\r\n            amount = pairs[i].price0Average.mul(amountIn).decode144();\r\n        } else {\r\n            require(token == pairs[i].token1, 'oracle_pWING_USDC: INVALID_TOKEN');\r\n            amount = pairs[i].price1Average.mul(amountIn).decode144();\r\n        }\r\n       return amount;\r\n    }\r\n\r\n    function getHourlyPrice() public view returns (uint256) {\r\n        uint256 pWING_ETH_HOURLY = consult(uint(PairTypes.pWING_ETH_HOURLY),WETH,10**18).div(10 ** 18);\r\n        uint256 ETH_USDC_HOURLY = consult(uint(PairTypes.ETH_USDC_HOURLY),WETH,10**18).mul(10 ** 3);\r\n\r\n        uint256 pWING_USDC_HOURLY = pWING_ETH_HOURLY.mul(ETH_USDC_HOURLY).div(10 ** 9);\r\n\r\n        return pWING_USDC_HOURLY;\r\n\r\n    }\r\n\r\n    function getSpotPrice() public view returns (uint256) {\r\n        (, int256 price, , , ) = AggregatorV3Interface(spotOracle)\r\n            .latestRoundData();\r\n        uint256 price_ = uint256(price);\r\n        if (outputDecimals > spotOracle_decimals) {\r\n            price_ = price_.mul(\r\n                10**(outputDecimals - spotOracle_decimals)\r\n            );\r\n        }\r\n        if (outputDecimals < spotOracle_decimals) {\r\n            price_ = price_.div(\r\n                10**(spotOracle_decimals - outputDecimals)\r\n            );\r\n        }\r\n        return price_;\r\n    }\r\n\r\n    function getLatestPrice() public view returns (uint256) {\r\n        uint256 pWING_USDC_HOURLY = getHourlyPrice(); \r\n        uint256 sport_price = getSpotPrice();\r\n\r\n        if (pWING_USDC_HOURLY < sport_price) return pWING_USDC_HOURLY;\r\n\r\n        return sport_price;\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oneToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pWING_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"USDC_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"WETH_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"outputDecimals_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"spotOracle_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"HOURLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDC\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"period_\",\"type\":\"uint256\"}],\"name\":\"changeInterval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getHourlyPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLatestPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSpotPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"outputDecimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pWING\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"spotOracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"spotOracle_decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"update\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"oracle_pWING_USD","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000008f041a3940a5e6fb580075c3774e15fcfa0e1618000000000000000000000000c0aee478e3658e2610c5f7a4a2e1777ce9e4f2ac000000000000000000000000db0f18081b505a7de20b18ac41856bcb4ba86a1a000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000000000009000000000000000000000000134fe0a225fb8e6683617c13ceb6b3319fb4fb82","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://00bd5c5fa35ba5378dd0217fde5352b54d0a9fe2e6da5700896e11b8ac3ba3b7"}]}