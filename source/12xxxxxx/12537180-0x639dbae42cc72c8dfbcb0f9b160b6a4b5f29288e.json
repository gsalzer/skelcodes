{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/PrivateSale.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../utils/Context.sol\\\";\\nimport \\\"../interfaces/IWhitelist.sol\\\";\\n\\ncontract PrivateSale is Context {\\n    /**\\n     * @dev `_usdt` represents the usdt smart contract address.\\n     * `_admin` is the account that controls the sale.\\n     */\\n    address private _usdt;\\n    address private _whitelist;\\n    address private _admin;\\n\\n    /**\\n     * @dev stores the total unique investement addresses.\\n     */\\n    uint256 private _investors;\\n    mapping(uint256 => address) private _investor;\\n\\n    /**\\n     * @dev stores the usdt invested by each account.\\n     */\\n    mapping(address => uint256) private _investment;\\n\\n    /**\\n     * @dev checks if `caller` is `_admin`\\n     * reverts if the `caller` is not the `_admin` account.\\n     */\\n    modifier onlyAdmin() {\\n        require(_admin == msgSender(), \\\"Error: caller not admin\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev is emitted when a successful investment is made.\\n     */\\n    event Investment(address indexed from, uint256 amount);\\n\\n    constructor(address _usdtAddress, address _whitelistOracle) {\\n        _admin = msgSender();\\n        _usdt = _usdtAddress;\\n        _whitelist = _whitelistOracle;\\n    }\\n\\n    /**\\n     * @dev invests `_usdtAmount` to the vesting smart contract.\\n     *\\n     * Requirements:\\n     * `_usdtAmount` should be approved by `caller` account.\\n     * `_usdtAmount` should be greater or equal to balance of `caller` account\\n     */\\n    function invest(uint256 _usdtAmount) public virtual returns (bool) {\\n        require(IWhiteList(_whitelist).whitelisted(msgSender()), \\\"Error: investor not elligible for purchase\\\");\\n\\n        uint256 balance = IERC20(_usdt).balanceOf(msgSender());\\n        uint256 allowance = IERC20(_usdt).allowance(msgSender(), address(this));\\n\\n        require(balance >= _usdtAmount, \\\"Error: insufficient USDT Balance\\\");\\n        require(\\n            allowance >= _usdtAmount,\\n            \\\"Error: allowance less than spending\\\"\\n        );\\n        \\n        if(_investment[msgSender()] == 0) { \\n            _investors += 1; \\n            _investor[_investors] = msgSender();\\n        }\\n        _investment[msgSender()] += _usdtAmount;\\n\\n        emit Investment(msgSender(), _usdtAmount);\\n        IERC20(_usdt).transferFrom(msgSender(), address(this), _usdtAmount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev returns the amount of usdt invested by `_user`\\n     */\\n    function investment(address _user) public view virtual returns (uint256) {\\n        return _investment[_user];\\n    }\\n\\n    /**\\n     * @dev returns the usdt smart contract used for purchase.\\n     */\\n    function usdt() public view returns (address) {\\n        return _usdt;\\n    }\\n\\n    /**\\n     * @dev returns the total number of investors.\\n     */\\n    function totalInvestors() public view returns (uint256) {\\n        return _investors;\\n    }\\n\\n    /**\\n     * @dev returns individual investor address.\\n     */\\n    function investor(uint256 investorId) public view returns (address) {\\n        return _investor[investorId];\\n    }\\n\\n    /**\\n     * @dev returns the admin account used for purchase.\\n     */\\n    function admin() public view returns (address) {\\n        return _admin;\\n    }\\n\\n    /**\\n     * @dev transfers ownership to a different account.\\n     *\\n     * Requirements:\\n     * `newAdmin` cannot be a zero address.\\n     * `caller` should be current admin.\\n     */\\n    function transferControl(address newAdmin) public virtual onlyAdmin {\\n        require(newAdmin != address(0), \\\"Error: owner cannot be zero\\\");\\n        _admin = newAdmin;\\n    }\\n\\n    /**\\n     * @dev updates the usdc sc address.\\n     *\\n     * Requirements:\\n     * `newAddress` cannot be a zero address.\\n     * `caller` should be current admin.\\n     */\\n    function updateUsdt(address newAddress) public virtual onlyAdmin {\\n        require(newAddress != address(0), \\\"Error: owner cannot be zero\\\");\\n        _usdt = newAddress;\\n    }\\n\\n    /**\\n     * @dev updates the whitelist oracle address.\\n     *\\n     * Requirements:\\n     * `newAddress` cannot be a zero address.\\n     * `caller` should be current admin.\\n     */\\n    function updateOracle(address newAddress) public virtual onlyAdmin {\\n        require(newAddress != address(0), \\\"Error: owner cannot be zero\\\");\\n        _whitelist = newAddress;\\n    }\\n\\n    /**\\n     * @dev send usdt from SC to any EOA.\\n     *\\n     * `caller` should be admin account.\\n     * `to` cannot be zero address.\\n     */\\n    function sendUsdt(address to, uint256 amount)\\n        public\\n        virtual\\n        onlyAdmin\\n        returns (bool)\\n    {\\n        require(to != address(0), \\\"Error: cannot send to zero addresss\\\");\\n        IERC20(_usdt).transfer(to, amount);\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.4;\\n\\ninterface IERC20 {\\n    /**\\n     * @dev returns the tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev returns the remaining number of tokens the `spender' can spend\\n     * on behalf of the owner.\\n     *\\n     * This value changes when {approve} or {transferFrom} is executed.\\n     */\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @dev transfers the `amount` of tokens from caller's account\\n     * to the `recipient` account.\\n     *\\n     * returns boolean value indicating the operation status.\\n     *\\n     * Emits a {Transfer} event\\n     */\\n    function transfer(address recipient, uint256 amount)\\n        external;\\n\\n    /**\\n     * @dev transfers the `amount` on behalf of `spender` to the `recipient` account.\\n     *\\n     * returns a boolean indicating the operation status.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address spender,\\n        address recipient,\\n        uint256 amount\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * Library Like Contract. Not Required for deployment\\n */\\nabstract contract Context {\\n\\n    function msgSender() internal view virtual returns(address) {\\n        return msg.sender;\\n    }\\n\\n    function msgData() internal view virtual returns(bytes calldata) {\\n        this;\\n        return msg.data;\\n    }\\n\\n    function msgValue() internal view virtual returns(uint256) {\\n        return msg.value;\\n    }\\n\\n}\"\r\n    },\r\n    \"interfaces/IWhitelist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev interface of Whitelist Contract.\\n */\\n\\ninterface IWhiteList {\\n    /**\\n     * @dev whitelist the `_user` for purchase.\\n     *\\n     * Requirements:\\n     * `_user` should not be a zero address.\\n     * `_user` should not be already whitelisted.\\n     *\\n     * returns a bool to represent the status of the transaction.\\n     */\\n    function whitelist(address _user) external returns (bool);\\n\\n    /**\\n     * @dev blacklists the `user` from sale.\\n     *\\n     * Requirements:\\n     * `_user` should be whitelisted before.\\n     * `_user` cannot be a zero address.\\n     *\\n     * returns a bool to represent the status of the transaction.\\n     */\\n    function blacklist(address _user) external returns (bool);\\n\\n    /**\\n     * @dev transfers the control of whitelisting to another wallet.\\n     *\\n     * Requirements:\\n     * `_newGovernor` should not be a zero address.\\n     * `caller` should be the current governor.\\n     *\\n     * returns a bool to represent the status of the transaction.\\n     */\\n    function transferGovernor(address _newGovernor) external returns (bool);\\n\\n    /**\\n     * @dev returns a bool to represent the whitelisting status of a wallet.\\n     *\\n     * true - address is whitelisted and can purchase tokens.\\n     * false - prevented from sale.\\n     */\\n    function whitelisted(address _user) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_usdtAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_whitelistOracle\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Investment\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_usdtAmount\",\"type\":\"uint256\"}],\"name\":\"invest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"investment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"investorId\",\"type\":\"uint256\"}],\"name\":\"investor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sendUsdt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalInvestors\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferControl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"updateOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"updateUsdt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdt\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"PrivateSale","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec700000000000000000000000052f93a192d4b760ea34b79f7a0ed22ddaa4f11e7","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}