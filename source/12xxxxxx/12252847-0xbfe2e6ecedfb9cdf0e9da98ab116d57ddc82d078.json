{"status":"1","message":"OK","result":[{"SourceCode":"// File: helpers/IUniswapV2Factory.sol\r\n\r\n// SPDX-License-Identifier: bsl-1.1\r\n\r\n/*\r\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\r\n*/\r\npragma solidity ^0.6.8;\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\n// File: helpers/AggregatorInterface.sol\r\n\r\n/*\r\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\r\n*/\r\npragma solidity ^0.6.8;\r\n\r\ninterface AggregatorInterface {\r\n    function latestAnswer() external view returns (int256); // deprecated\r\n    function latestTimestamp() external view returns (uint256); // deprecated\r\n    function latestRound() external view returns (uint256);\r\n    function decimals() external view returns (uint256);\r\n\r\n    function latestRoundData()\r\n    external\r\n    view\r\n    returns (\r\n        uint80 roundId,\r\n        int256 answer,\r\n        uint256 startedAt,\r\n        uint256 updatedAt,\r\n        uint80 answeredInRound\r\n    );\r\n}\r\n\r\n// File: helpers/IKeydonixOracleUsd.sol\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\ninterface IKeydonixOracleUsd {\r\n\r\n    // returns Q112-encoded value\r\n    function assetToUsd(address asset, uint amount, UniswapOracle.ProofData calldata proofData) external view returns (uint);\r\n}\r\n// File: @keydonix/uniswap-oracle-contracts/source/UQ112x112.sol\r\n\r\npragma solidity 0.6.8;\r\n\r\n// https://raw.githubusercontent.com/Uniswap/uniswap-v2-core/master/contracts/libraries/UQ112x112.sol\r\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\r\n\r\n// range: [0, 2**112 - 1]\r\n// resolution: 1 / 2**112\r\n\r\nlibrary UQ112x112 {\r\n\tuint224 constant Q112 = 2**112;\r\n\r\n\t// encode a uint112 as a UQ112x112\r\n\tfunction encode(uint112 y) internal pure returns (uint224 z) {\r\n\t\tz = uint224(y) * Q112; // never overflows\r\n\t}\r\n\r\n\t// divide a UQ112x112 by a uint112, returning a UQ112x112\r\n\tfunction uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\r\n\t\tz = x / uint224(y);\r\n\t}\r\n}\r\n\r\n// File: @keydonix/uniswap-oracle-contracts/source/IUniswapV2Pair.sol\r\n\r\npragma solidity 0.6.8;\r\n\r\ninterface IUniswapV2Pair {\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n\r\n    function price0CumulativeLast() external view returns (uint256);\r\n    function price1CumulativeLast() external view returns (uint256);\r\n\r\n\tfunction getReserves() external view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast);\r\n}\r\n\r\n// File: @keydonix/uniswap-oracle-contracts/source/Rlp.sol\r\n\r\npragma solidity 0.6.8;\r\n\r\nlibrary Rlp {\r\n\tuint constant DATA_SHORT_START = 0x80;\r\n\tuint constant DATA_LONG_START = 0xB8;\r\n\tuint constant LIST_SHORT_START = 0xC0;\r\n\tuint constant LIST_LONG_START = 0xF8;\r\n\r\n\tuint constant DATA_LONG_OFFSET = 0xB7;\r\n\tuint constant LIST_LONG_OFFSET = 0xF7;\r\n\r\n\r\n\tstruct Item {\r\n\t\tuint _unsafe_memPtr;    // Pointer to the RLP-encoded bytes.\r\n\t\tuint _unsafe_length;    // Number of bytes. This is the full length of the string.\r\n\t}\r\n\r\n\tstruct Iterator {\r\n\t\tItem _unsafe_item;   // Item that's being iterated over.\r\n\t\tuint _unsafe_nextPtr;   // Position of the next item in the list.\r\n\t}\r\n\r\n\t/* Iterator */\r\n\r\n\tfunction next(Iterator memory self) internal pure returns (Item memory subItem) {\r\n\t\trequire(hasNext(self), \"Rlp.sol:Rlp:next:1\");\r\n\t\tuint256 ptr = self._unsafe_nextPtr;\r\n\t\tuint256 itemLength = _itemLength(ptr);\r\n\t\tsubItem._unsafe_memPtr = ptr;\r\n\t\tsubItem._unsafe_length = itemLength;\r\n\t\tself._unsafe_nextPtr = ptr + itemLength;\r\n\t}\r\n\r\n\tfunction next(Iterator memory self, bool strict) internal pure returns (Item memory subItem) {\r\n\t\tsubItem = next(self);\r\n\t\trequire(!strict || _validate(subItem), \"Rlp.sol:Rlp:next:2\");\r\n\t}\r\n\r\n\tfunction hasNext(Iterator memory self) internal pure returns (bool) {\r\n\t\tRlp.Item memory item = self._unsafe_item;\r\n\t\treturn self._unsafe_nextPtr < item._unsafe_memPtr + item._unsafe_length;\r\n\t}\r\n\r\n\t/* Item */\r\n\r\n\t/// @dev Creates an Item from an array of RLP encoded bytes.\r\n\t/// @param self The RLP encoded bytes.\r\n\t/// @return An Item\r\n\tfunction toItem(bytes memory self) internal pure returns (Item memory) {\r\n\t\tuint len = self.length;\r\n\t\tif (len == 0) {\r\n\t\t\treturn Item(0, 0);\r\n\t\t}\r\n\t\tuint memPtr;\r\n\t\tassembly {\r\n\t\t\tmemPtr := add(self, 0x20)\r\n\t\t}\r\n\t\treturn Item(memPtr, len);\r\n\t}\r\n\r\n\t/// @dev Creates an Item from an array of RLP encoded bytes.\r\n\t/// @param self The RLP encoded bytes.\r\n\t/// @param strict Will throw if the data is not RLP encoded.\r\n\t/// @return An Item\r\n\tfunction toItem(bytes memory self, bool strict) internal pure returns (Item memory) {\r\n\t\tRlp.Item memory item = toItem(self);\r\n\t\tif(strict) {\r\n\t\t\tuint len = self.length;\r\n\t\t\trequire(_payloadOffset(item) <= len, \"Rlp.sol:Rlp:toItem4\");\r\n\t\t\trequire(_itemLength(item._unsafe_memPtr) == len, \"Rlp.sol:Rlp:toItem:5\");\r\n\t\t\trequire(_validate(item), \"Rlp.sol:Rlp:toItem:6\");\r\n\t\t}\r\n\t\treturn item;\r\n\t}\r\n\r\n\t/// @dev Check if the Item is null.\r\n\t/// @param self The Item.\r\n\t/// @return 'true' if the item is null.\r\n\tfunction isNull(Item memory self) internal pure returns (bool) {\r\n\t\treturn self._unsafe_length == 0;\r\n\t}\r\n\r\n\t/// @dev Check if the Item is a list.\r\n\t/// @param self The Item.\r\n\t/// @return 'true' if the item is a list.\r\n\tfunction isList(Item memory self) internal pure returns (bool) {\r\n\t\tif (self._unsafe_length == 0)\r\n\t\t\treturn false;\r\n\t\tuint memPtr = self._unsafe_memPtr;\r\n\t\tbool result;\r\n\t\tassembly {\r\n\t\t\tresult := iszero(lt(byte(0, mload(memPtr)), 0xC0))\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/// @dev Check if the Item is data.\r\n\t/// @param self The Item.\r\n\t/// @return 'true' if the item is data.\r\n\tfunction isData(Item memory self) internal pure returns (bool) {\r\n\t\tif (self._unsafe_length == 0)\r\n\t\t\treturn false;\r\n\t\tuint memPtr = self._unsafe_memPtr;\r\n\t\tbool result;\r\n\t\tassembly {\r\n\t\t\tresult := lt(byte(0, mload(memPtr)), 0xC0)\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/// @dev Check if the Item is empty (string or list).\r\n\t/// @param self The Item.\r\n\t/// @return result 'true' if the item is null.\r\n\tfunction isEmpty(Item memory self) internal pure returns (bool) {\r\n\t\tif(isNull(self))\r\n\t\t\treturn false;\r\n\t\tuint b0;\r\n\t\tuint memPtr = self._unsafe_memPtr;\r\n\t\tassembly {\r\n\t\t\tb0 := byte(0, mload(memPtr))\r\n\t\t}\r\n\t\treturn (b0 == DATA_SHORT_START || b0 == LIST_SHORT_START);\r\n\t}\r\n\r\n\t/// @dev Get the number of items in an RLP encoded list.\r\n\t/// @param self The Item.\r\n\t/// @return The number of items.\r\n\tfunction items(Item memory self) internal pure returns (uint) {\r\n\t\tif (!isList(self))\r\n\t\t\treturn 0;\r\n\t\tuint b0;\r\n\t\tuint memPtr = self._unsafe_memPtr;\r\n\t\tassembly {\r\n\t\t\tb0 := byte(0, mload(memPtr))\r\n\t\t}\r\n\t\tuint pos = memPtr + _payloadOffset(self);\r\n\t\tuint last = memPtr + self._unsafe_length - 1;\r\n\t\tuint itms;\r\n\t\twhile(pos <= last) {\r\n\t\t\tpos += _itemLength(pos);\r\n\t\t\titms++;\r\n\t\t}\r\n\t\treturn itms;\r\n\t}\r\n\r\n\t/// @dev Create an iterator.\r\n\t/// @param self The Item.\r\n\t/// @return An 'Iterator' over the item.\r\n\tfunction iterator(Item memory self) internal pure returns (Iterator memory) {\r\n\t\trequire(isList(self), \"Rlp.sol:Rlp:iterator:1\");\r\n\t\tuint ptr = self._unsafe_memPtr + _payloadOffset(self);\r\n\t\tIterator memory it;\r\n\t\tit._unsafe_item = self;\r\n\t\tit._unsafe_nextPtr = ptr;\r\n\t\treturn it;\r\n\t}\r\n\r\n\t/// @dev Return the RLP encoded bytes.\r\n\t/// @param self The Item.\r\n\t/// @return The bytes.\r\n\tfunction toBytes(Item memory self) internal pure returns (bytes memory) {\r\n\t\tuint256 len = self._unsafe_length;\r\n\t\trequire(len != 0, \"Rlp.sol:Rlp:toBytes:2\");\r\n\t\tbytes memory bts;\r\n\t\tbts = new bytes(len);\r\n\t\t_copyToBytes(self._unsafe_memPtr, bts, len);\r\n\t\treturn bts;\r\n\t}\r\n\r\n\t/// @dev Decode an Item into bytes. This will not work if the\r\n\t/// Item is a list.\r\n\t/// @param self The Item.\r\n\t/// @return The decoded string.\r\n\tfunction toData(Item memory self) internal pure returns (bytes memory) {\r\n\t\trequire(isData(self));\r\n\t\t(uint256 rStartPos, uint256 len) = _decode(self);\r\n\t\tbytes memory bts;\r\n\t\tbts = new bytes(len);\r\n\t\t_copyToBytes(rStartPos, bts, len);\r\n\t\treturn bts;\r\n\t}\r\n\r\n\t/// @dev Get the list of sub-items from an RLP encoded list.\r\n\t/// Warning: This is inefficient, as it requires that the list is read twice.\r\n\t/// @param self The Item.\r\n\t/// @return Array of Items.\r\n\tfunction toList(Item memory self) internal pure returns (Item[] memory) {\r\n\t\trequire(isList(self), \"Rlp.sol:Rlp:toList:1\");\r\n\t\tuint256 numItems = items(self);\r\n\t\tItem[] memory list = new Item[](numItems);\r\n\t\tRlp.Iterator memory it = iterator(self);\r\n\t\tuint idx;\r\n\t\twhile(hasNext(it)) {\r\n\t\t\tlist[idx] = next(it);\r\n\t\t\tidx++;\r\n\t\t}\r\n\t\treturn list;\r\n\t}\r\n\r\n\t/// @dev Decode an Item into an ascii string. This will not work if the\r\n\t/// Item is a list.\r\n\t/// @param self The Item.\r\n\t/// @return The decoded string.\r\n\tfunction toAscii(Item memory self) internal pure returns (string memory) {\r\n\t\trequire(isData(self), \"Rlp.sol:Rlp:toAscii:1\");\r\n\t\t(uint256 rStartPos, uint256 len) = _decode(self);\r\n\t\tbytes memory bts = new bytes(len);\r\n\t\t_copyToBytes(rStartPos, bts, len);\r\n\t\tstring memory str = string(bts);\r\n\t\treturn str;\r\n\t}\r\n\r\n\t/// @dev Decode an Item into a uint. This will not work if the\r\n\t/// Item is a list.\r\n\t/// @param self The Item.\r\n\t/// @return The decoded string.\r\n\tfunction toUint(Item memory self) internal pure returns (uint) {\r\n\t\trequire(isData(self), \"Rlp.sol:Rlp:toUint:1\");\r\n\t\t(uint256 rStartPos, uint256 len) = _decode(self);\r\n\t\trequire(len <= 32, \"Rlp.sol:Rlp:toUint:3\");\r\n\t\trequire(len != 0, \"Rlp.sol:Rlp:toUint:4\");\r\n\t\tuint data;\r\n\t\tassembly {\r\n\t\t\tdata := div(mload(rStartPos), exp(256, sub(32, len)))\r\n\t\t}\r\n\t\treturn data;\r\n\t}\r\n\r\n\t/// @dev Decode an Item into a boolean. This will not work if the\r\n\t/// Item is a list.\r\n\t/// @param self The Item.\r\n\t/// @return The decoded string.\r\n\tfunction toBool(Item memory self) internal pure returns (bool) {\r\n\t\trequire(isData(self), \"Rlp.sol:Rlp:toBool:1\");\r\n\t\t(uint256 rStartPos, uint256 len) = _decode(self);\r\n\t\trequire(len == 1, \"Rlp.sol:Rlp:toBool:3\");\r\n\t\tuint temp;\r\n\t\tassembly {\r\n\t\t\ttemp := byte(0, mload(rStartPos))\r\n\t\t}\r\n\t\trequire(temp <= 1, \"Rlp.sol:Rlp:toBool:8\");\r\n\t\treturn temp == 1 ? true : false;\r\n\t}\r\n\r\n\t/// @dev Decode an Item into a byte. This will not work if the\r\n\t/// Item is a list.\r\n\t/// @param self The Item.\r\n\t/// @return The decoded string.\r\n\tfunction toByte(Item memory self) internal pure returns (byte) {\r\n\t\trequire(isData(self), \"Rlp.sol:Rlp:toByte:1\");\r\n\t\t(uint256 rStartPos, uint256 len) = _decode(self);\r\n\t\trequire(len == 1, \"Rlp.sol:Rlp:toByte:3\");\r\n\t\tbyte temp;\r\n\t\tassembly {\r\n\t\t\ttemp := byte(0, mload(rStartPos))\r\n\t\t}\r\n\t\treturn byte(temp);\r\n\t}\r\n\r\n\t/// @dev Decode an Item into an int. This will not work if the\r\n\t/// Item is a list.\r\n\t/// @param self The Item.\r\n\t/// @return The decoded string.\r\n\tfunction toInt(Item memory self) internal pure returns (int) {\r\n\t\treturn int(toUint(self));\r\n\t}\r\n\r\n\t/// @dev Decode an Item into a bytes32. This will not work if the\r\n\t/// Item is a list.\r\n\t/// @param self The Item.\r\n\t/// @return The decoded string.\r\n\tfunction toBytes32(Item memory self) internal pure returns (bytes32) {\r\n\t\treturn bytes32(toUint(self));\r\n\t}\r\n\r\n\t/// @dev Decode an Item into an address. This will not work if the\r\n\t/// Item is a list.\r\n\t/// @param self The Item.\r\n\t/// @return The decoded string.\r\n\tfunction toAddress(Item memory self) internal pure returns (address) {\r\n\t\trequire(isData(self), \"Rlp.sol:Rlp:toAddress:1\");\r\n\t\t(uint256 rStartPos, uint256 len) = _decode(self);\r\n\t\trequire(len == 20, \"Rlp.sol:Rlp:toAddress:3\");\r\n\t\taddress data;\r\n\t\tassembly {\r\n\t\t\tdata := div(mload(rStartPos), exp(256, 12))\r\n\t\t}\r\n\t\treturn data;\r\n\t}\r\n\r\n\t// Get the payload offset.\r\n\tfunction _payloadOffset(Item memory self) private pure returns (uint) {\r\n\t\tif(self._unsafe_length == 0)\r\n\t\t\treturn 0;\r\n\t\tuint b0;\r\n\t\tuint memPtr = self._unsafe_memPtr;\r\n\t\tassembly {\r\n\t\t\tb0 := byte(0, mload(memPtr))\r\n\t\t}\r\n\t\tif(b0 < DATA_SHORT_START)\r\n\t\t\treturn 0;\r\n\t\tif(b0 < DATA_LONG_START || (b0 >= LIST_SHORT_START && b0 < LIST_LONG_START))\r\n\t\t\treturn 1;\r\n\t\tif(b0 < LIST_SHORT_START)\r\n\t\t\treturn b0 - DATA_LONG_OFFSET + 1;\r\n\t\treturn b0 - LIST_LONG_OFFSET + 1;\r\n\t}\r\n\r\n\t// Get the full length of an Item.\r\n\tfunction _itemLength(uint memPtr) private pure returns (uint len) {\r\n\t\tuint b0;\r\n\t\tassembly {\r\n\t\t\tb0 := byte(0, mload(memPtr))\r\n\t\t}\r\n\t\tif (b0 < DATA_SHORT_START)\r\n\t\t\tlen = 1;\r\n\t\telse if (b0 < DATA_LONG_START)\r\n\t\t\tlen = b0 - DATA_SHORT_START + 1;\r\n\t\telse if (b0 < LIST_SHORT_START) {\r\n\t\t\tassembly {\r\n\t\t\t\tlet bLen := sub(b0, 0xB7) // bytes length (DATA_LONG_OFFSET)\r\n\t\t\t\tlet dLen := div(mload(add(memPtr, 1)), exp(256, sub(32, bLen))) // data length\r\n\t\t\t\tlen := add(1, add(bLen, dLen)) // total length\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (b0 < LIST_LONG_START)\r\n\t\t\tlen = b0 - LIST_SHORT_START + 1;\r\n\t\telse {\r\n\t\t\tassembly {\r\n\t\t\t\tlet bLen := sub(b0, 0xF7) // bytes length (LIST_LONG_OFFSET)\r\n\t\t\t\tlet dLen := div(mload(add(memPtr, 1)), exp(256, sub(32, bLen))) // data length\r\n\t\t\t\tlen := add(1, add(bLen, dLen)) // total length\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Get start position and length of the data.\r\n\tfunction _decode(Item memory self) private pure returns (uint memPtr, uint len) {\r\n\t\trequire(isData(self), \"Rlp.sol:Rlp:_decode:1\");\r\n\t\tuint b0;\r\n\t\tuint start = self._unsafe_memPtr;\r\n\t\tassembly {\r\n\t\t\tb0 := byte(0, mload(start))\r\n\t\t}\r\n\t\tif (b0 < DATA_SHORT_START) {\r\n\t\t\tmemPtr = start;\r\n\t\t\tlen = 1;\r\n\t\t\treturn (memPtr, len);\r\n\t\t}\r\n\t\tif (b0 < DATA_LONG_START) {\r\n\t\t\tlen = self._unsafe_length - 1;\r\n\t\t\tmemPtr = start + 1;\r\n\t\t} else {\r\n\t\t\tuint bLen;\r\n\t\t\tassembly {\r\n\t\t\t\tbLen := sub(b0, 0xB7) // DATA_LONG_OFFSET\r\n\t\t\t}\r\n\t\t\tlen = self._unsafe_length - 1 - bLen;\r\n\t\t\tmemPtr = start + bLen + 1;\r\n\t\t}\r\n\t\treturn (memPtr, len);\r\n\t}\r\n\r\n\t// Assumes that enough memory has been allocated to store in target.\r\n\tfunction _copyToBytes(uint sourceBytes, bytes memory destinationBytes, uint btsLen) internal pure {\r\n\t\t// Exploiting the fact that 'tgt' was the last thing to be allocated,\r\n\t\t// we can write entire words, and just overwrite any excess.\r\n\t\tassembly {\r\n\t\t\tlet words := div(add(btsLen, 31), 32)\r\n\t\t\tlet sourcePointer := sourceBytes\r\n\t\t\tlet destinationPointer := add(destinationBytes, 32)\r\n\t\t\tfor { let i := 0 } lt(i, words) { i := add(i, 1) }\r\n\t\t\t{\r\n\t\t\t\tlet offset := mul(i, 32)\r\n\t\t\t\tmstore(add(destinationPointer, offset), mload(add(sourcePointer, offset)))\r\n\t\t\t}\r\n\t\t\tmstore(add(destinationBytes, add(32, mload(destinationBytes))), 0)\r\n\t\t}\r\n\t}\r\n\r\n\t// Check that an Item is valid.\r\n\tfunction _validate(Item memory self) private pure returns (bool ret) {\r\n\t\t// Check that RLP is well-formed.\r\n\t\tuint b0;\r\n\t\tuint b1;\r\n\t\tuint memPtr = self._unsafe_memPtr;\r\n\t\tassembly {\r\n\t\t\tb0 := byte(0, mload(memPtr))\r\n\t\t\tb1 := byte(1, mload(memPtr))\r\n\t\t}\r\n\t\tif(b0 == DATA_SHORT_START + 1 && b1 < DATA_SHORT_START)\r\n\t\t\treturn false;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction rlpBytesToUint256(bytes memory source) internal pure returns (uint256 result) {\r\n\t\treturn Rlp.toUint(Rlp.toItem(source));\r\n\t}\r\n}\r\n\r\n// File: @keydonix/uniswap-oracle-contracts/source/MerklePatriciaVerifier.sol\r\n\r\npragma solidity 0.6.8;\r\n\r\n\r\nlibrary MerklePatriciaVerifier {\r\n\t/*\r\n\t * @dev Extracts the value from a merkle proof\r\n\t * @param expectedRoot The expected hash of the root node of the trie.\r\n\t * @param path The path in the trie leading to value.\r\n\t * @param proofNodesRlp RLP encoded array of proof nodes.\r\n\t * @return The value proven to exist in the merkle patricia tree whose root is `expectedRoot` at the path `path`\r\n\t *\r\n\t * WARNING: Does not currently support validation of unset/0 values!\r\n\t */\r\n\tfunction getValueFromProof(bytes32 expectedRoot, bytes32 path, bytes memory proofNodesRlp) internal pure returns (bytes memory) {\r\n\t\tRlp.Item memory rlpParentNodes = Rlp.toItem(proofNodesRlp);\r\n\t\tRlp.Item[] memory parentNodes = Rlp.toList(rlpParentNodes);\r\n\r\n\t\tbytes memory currentNode;\r\n\t\tRlp.Item[] memory currentNodeList;\r\n\r\n\t\tbytes32 nodeKey = expectedRoot;\r\n\t\tuint pathPtr = 0;\r\n\r\n\t\t// our input is a 32-byte path, but we have to prepend a single 0 byte to that and pass it along as a 33 byte memory array since that is what getNibbleArray wants\r\n\t\tbytes memory nibblePath = new bytes(33);\r\n\t\tassembly { mstore(add(nibblePath, 33), path) }\r\n\t\tnibblePath = _getNibbleArray(nibblePath);\r\n\r\n\t\trequire(path.length != 0, \"empty path provided\");\r\n\r\n\t\tcurrentNode = Rlp.toBytes(parentNodes[0]);\r\n\r\n\t\tfor (uint i=0; i<parentNodes.length; i++) {\r\n\t\t\trequire(pathPtr <= nibblePath.length, \"Path overflow\");\r\n\r\n\t\t\tcurrentNode = Rlp.toBytes(parentNodes[i]);\r\n\t\t\trequire(nodeKey == keccak256(currentNode), \"node doesn't match key\");\r\n\t\t\tcurrentNodeList = Rlp.toList(parentNodes[i]);\r\n\r\n\t\t\tif(currentNodeList.length == 17) {\r\n\t\t\t\tif(pathPtr == nibblePath.length) {\r\n\t\t\t\t\treturn Rlp.toData(currentNodeList[16]);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tuint8 nextPathNibble = uint8(nibblePath[pathPtr]);\r\n\t\t\t\trequire(nextPathNibble <= 16, \"nibble too long\");\r\n\t\t\t\tnodeKey = Rlp.toBytes32(currentNodeList[nextPathNibble]);\r\n\t\t\t\tpathPtr += 1;\r\n\t\t\t} else if(currentNodeList.length == 2) {\r\n\t\t\t\tpathPtr += _nibblesToTraverse(Rlp.toData(currentNodeList[0]), nibblePath, pathPtr);\r\n\t\t\t\t// leaf node\r\n\t\t\t\tif(pathPtr == nibblePath.length) {\r\n\t\t\t\t\treturn Rlp.toData(currentNodeList[1]);\r\n\t\t\t\t}\r\n\t\t\t\t//extension node\r\n\t\t\t\trequire(_nibblesToTraverse(Rlp.toData(currentNodeList[0]), nibblePath, pathPtr) != 0, \"invalid extension node\");\r\n\r\n\t\t\t\tnodeKey = Rlp.toBytes32(currentNodeList[1]);\r\n\t\t\t} else {\r\n\t\t\t\trequire(false, \"unexpected length array\");\r\n\t\t\t}\r\n\t\t}\r\n\t\trequire(false, \"not enough proof nodes\");\r\n\t}\r\n\r\n\tfunction _nibblesToTraverse(bytes memory encodedPartialPath, bytes memory path, uint pathPtr) private pure returns (uint) {\r\n\t\tuint len;\r\n\t\t// encodedPartialPath has elements that are each two hex characters (1 byte), but partialPath\r\n\t\t// and slicedPath have elements that are each one hex character (1 nibble)\r\n\t\tbytes memory partialPath = _getNibbleArray(encodedPartialPath);\r\n\t\tbytes memory slicedPath = new bytes(partialPath.length);\r\n\r\n\t\t// pathPtr counts nibbles in path\r\n\t\t// partialPath.length is a number of nibbles\r\n\t\tfor(uint i=pathPtr; i<pathPtr+partialPath.length; i++) {\r\n\t\t\tbyte pathNibble = path[i];\r\n\t\t\tslicedPath[i-pathPtr] = pathNibble;\r\n\t\t}\r\n\r\n\t\tif(keccak256(partialPath) == keccak256(slicedPath)) {\r\n\t\t\tlen = partialPath.length;\r\n\t\t} else {\r\n\t\t\tlen = 0;\r\n\t\t}\r\n\t\treturn len;\r\n\t}\r\n\r\n\t// bytes byteArray must be hp encoded\r\n\tfunction _getNibbleArray(bytes memory byteArray) private pure returns (bytes memory) {\r\n\t\tbytes memory nibbleArray;\r\n\t\tif (byteArray.length == 0) return nibbleArray;\r\n\r\n\t\tuint8 offset;\r\n\t\tuint8 hpNibble = uint8(_getNthNibbleOfBytes(0,byteArray));\r\n\t\tif(hpNibble == 1 || hpNibble == 3) {\r\n\t\t\tnibbleArray = new bytes(byteArray.length*2-1);\r\n\t\t\tbyte oddNibble = _getNthNibbleOfBytes(1,byteArray);\r\n\t\t\tnibbleArray[0] = oddNibble;\r\n\t\t\toffset = 1;\r\n\t\t} else {\r\n\t\t\tnibbleArray = new bytes(byteArray.length*2-2);\r\n\t\t\toffset = 0;\r\n\t\t}\r\n\r\n\t\tfor(uint i=offset; i<nibbleArray.length; i++) {\r\n\t\t\tnibbleArray[i] = _getNthNibbleOfBytes(i-offset+2,byteArray);\r\n\t\t}\r\n\t\treturn nibbleArray;\r\n\t}\r\n\r\n\tfunction _getNthNibbleOfBytes(uint n, bytes memory str) private pure returns (byte) {\r\n\t\treturn byte(n%2==0 ? uint8(str[n/2])/0x10 : uint8(str[n/2])%0x10);\r\n\t}\r\n}\r\n\r\n// File: @keydonix/uniswap-oracle-contracts/source/BlockVerifier.sol\r\n\r\npragma solidity 0.6.8;\r\n\r\nlibrary BlockVerifier {\r\n\tfunction extractStateRootAndTimestamp(bytes memory rlpBytes) internal view returns (bytes32 stateRoot, uint256 blockTimestamp, uint256 blockNumber) {\r\n\t\tassembly {\r\n\t\t\tfunction revertWithReason(message, length) {\r\n\t\t\t\tmstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\r\n\t\t\t\tmstore(4, 0x20)\r\n\t\t\t\tmstore(0x24, length)\r\n\t\t\t\tmstore(0x44, message)\r\n\t\t\t\trevert(0, add(0x44, length))\r\n\t\t\t}\r\n\r\n\t\t\tfunction readDynamic(prefixPointer) -> dataPointer, dataLength {\r\n\t\t\t\tlet value := byte(0, mload(prefixPointer))\r\n\t\t\t\tswitch lt(value, 0x80)\r\n\t\t\t\tcase 1 {\r\n\t\t\t\t\tdataPointer := prefixPointer\r\n\t\t\t\t\tdataLength := 1\r\n\t\t\t\t}\r\n\t\t\t\tcase 0 {\r\n\t\t\t\t\tdataPointer := add(prefixPointer, 1)\r\n\t\t\t\t\tdataLength := sub(value, 0x80)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// get the length of the data\r\n\t\t\tlet rlpLength := mload(rlpBytes)\r\n\t\t\t// move pointer forward, ahead of length\r\n\t\t\trlpBytes := add(rlpBytes, 0x20)\r\n\r\n\t\t\t// we know the length of the block will be between 483 bytes and 709 bytes, which means it will have 2 length bytes after the prefix byte, so we can skip 3 bytes in\r\n\t\t\t// CONSIDER: we could save a trivial amount of gas by compressing most of this into a single add instruction\r\n\t\t\tlet parentHashPrefixPointer := add(rlpBytes, 3)\r\n\t\t\tlet parentHashPointer := add(parentHashPrefixPointer, 1)\r\n\t\t\tlet uncleHashPrefixPointer := add(parentHashPointer, 32)\r\n\t\t\tlet uncleHashPointer := add(uncleHashPrefixPointer, 1)\r\n\t\t\tlet minerAddressPrefixPointer := add(uncleHashPointer, 32)\r\n\t\t\tlet minerAddressPointer := add(minerAddressPrefixPointer, 1)\r\n\t\t\tlet stateRootPrefixPointer := add(minerAddressPointer, 20)\r\n\t\t\tlet stateRootPointer := add(stateRootPrefixPointer, 1)\r\n\t\t\tlet transactionRootPrefixPointer := add(stateRootPointer, 32)\r\n\t\t\tlet transactionRootPointer := add(transactionRootPrefixPointer, 1)\r\n\t\t\tlet receiptsRootPrefixPointer := add(transactionRootPointer, 32)\r\n\t\t\tlet receiptsRootPointer := add(receiptsRootPrefixPointer, 1)\r\n\t\t\tlet logsBloomPrefixPointer := add(receiptsRootPointer, 32)\r\n\t\t\tlet logsBloomPointer := add(logsBloomPrefixPointer, 3)\r\n\t\t\tlet difficultyPrefixPointer := add(logsBloomPointer, 256)\r\n\t\t\tlet difficultyPointer, difficultyLength := readDynamic(difficultyPrefixPointer)\r\n\t\t\tlet blockNumberPrefixPointer := add(difficultyPointer, difficultyLength)\r\n\t\t\tlet blockNumberPointer, blockNumberLength := readDynamic(blockNumberPrefixPointer)\r\n\t\t\tlet gasLimitPrefixPointer := add(blockNumberPointer, blockNumberLength)\r\n\t\t\tlet gasLimitPointer, gasLimitLength := readDynamic(gasLimitPrefixPointer)\r\n\t\t\tlet gasUsedPrefixPointer := add(gasLimitPointer, gasLimitLength)\r\n\t\t\tlet gasUsedPointer, gasUsedLength := readDynamic(gasUsedPrefixPointer)\r\n\t\t\tlet timestampPrefixPointer := add(gasUsedPointer, gasUsedLength)\r\n\t\t\tlet timestampPointer, timestampLength := readDynamic(timestampPrefixPointer)\r\n\r\n\t\t\tblockNumber := shr(sub(256, mul(blockNumberLength, 8)), mload(blockNumberPointer))\r\n\t\t\tlet blockHash := blockhash(blockNumber)\r\n\t\t\tlet rlpHash := keccak256(rlpBytes, rlpLength)\r\n\t\t\tif iszero(eq(blockHash, rlpHash)) { revertWithReason(\"blockHash != rlpHash\", 20) }\r\n\r\n\t\t\tstateRoot := mload(stateRootPointer)\r\n\t\t\tblockTimestamp := shr(sub(256, mul(timestampLength, 8)), mload(timestampPointer))\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// File: @keydonix/uniswap-oracle-contracts/source/UniswapOracle.sol\r\n\r\npragma solidity 0.6.8;\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract UniswapOracle {\r\n\tusing UQ112x112 for uint224;\r\n\r\n\tbytes32 public constant reserveTimestampSlotHash = keccak256(abi.encodePacked(uint256(8)));\r\n\tbytes32 public constant token0Slot = keccak256(abi.encodePacked(uint256(9)));\r\n\tbytes32 public constant token1Slot = keccak256(abi.encodePacked(uint256(10)));\r\n\r\n\tstruct ProofData {\r\n\t\tbytes block;\r\n\t\tbytes accountProofNodesRlp;\r\n\t\tbytes reserveAndTimestampProofNodesRlp;\r\n\t\tbytes priceAccumulatorProofNodesRlp;\r\n\t}\r\n\r\n\tfunction getAccountStorageRoot(address uniswapV2Pair, ProofData memory proofData) public view returns (bytes32 storageRootHash, uint256 blockNumber, uint256 blockTimestamp) {\r\n\t\tbytes32 stateRoot;\r\n\t\t(stateRoot, blockTimestamp, blockNumber) = BlockVerifier.extractStateRootAndTimestamp(proofData.block);\r\n\t\tbytes memory accountDetailsBytes = MerklePatriciaVerifier.getValueFromProof(stateRoot, keccak256(abi.encodePacked(uniswapV2Pair)), proofData.accountProofNodesRlp);\r\n\t\tRlp.Item[] memory accountDetails = Rlp.toList(Rlp.toItem(accountDetailsBytes));\r\n\t\treturn (Rlp.toBytes32(accountDetails[2]), blockNumber, blockTimestamp);\r\n\t}\r\n\r\n\t// This function verifies the full block is old enough (MIN_BLOCK_COUNT), not too old (or blockhash will return 0x0) and return the proof values for the two storage slots we care about\r\n\tfunction verifyBlockAndExtractReserveData(IUniswapV2Pair uniswapV2Pair, uint8 minBlocksBack, uint8 maxBlocksBack, bytes32 slotHash, ProofData memory proofData) public view returns\r\n\t(uint256 blockTimestamp, uint256 blockNumber, uint256 priceCumulativeLast, uint112 reserve0, uint112 reserve1, uint256 reserveTimestamp) {\r\n\t\tbytes32 storageRootHash;\r\n\t\t(storageRootHash, blockNumber, blockTimestamp) = getAccountStorageRoot(address(uniswapV2Pair), proofData);\r\n\t\trequire (blockNumber <= block.number - minBlocksBack, \"Proof does not span enough blocks\");\r\n\t\trequire (blockNumber >= block.number - maxBlocksBack, \"Proof spans too many blocks\");\r\n\r\n\t\tpriceCumulativeLast = Rlp.rlpBytesToUint256(MerklePatriciaVerifier.getValueFromProof(storageRootHash, slotHash, proofData.priceAccumulatorProofNodesRlp));\r\n\t\tuint256 reserve0Reserve1TimestampPacked = Rlp.rlpBytesToUint256(MerklePatriciaVerifier.getValueFromProof(storageRootHash, reserveTimestampSlotHash, proofData.reserveAndTimestampProofNodesRlp));\r\n\t\treserveTimestamp = reserve0Reserve1TimestampPacked >> (112 + 112);\r\n\t\treserve1 = uint112((reserve0Reserve1TimestampPacked >> 112) & (2**112 - 1));\r\n\t\treserve0 = uint112(reserve0Reserve1TimestampPacked & (2**112 - 1));\r\n\t}\r\n\r\n\tfunction getPrice(IUniswapV2Pair uniswapV2Pair, address denominationToken, uint8 minBlocksBack, uint8 maxBlocksBack, ProofData memory proofData) public view returns (uint256 price, uint256 blockNumber) {\r\n\t\t// exchange = the ExchangeV2Pair. check denomination token (USE create2 check?!) check gas cost\r\n\t\tbool denominationTokenIs0;\r\n\t\tif (uniswapV2Pair.token0() == denominationToken) {\r\n\t\t\tdenominationTokenIs0 = true;\r\n\t\t} else if (uniswapV2Pair.token1() == denominationToken) {\r\n\t\t\tdenominationTokenIs0 = false;\r\n\t\t} else {\r\n\t\t\trevert(\"denominationToken invalid\");\r\n\t\t}\r\n\t\treturn getPriceRaw(uniswapV2Pair, denominationTokenIs0, minBlocksBack, maxBlocksBack, proofData);\r\n\t}\r\n\r\n\tfunction getPriceRaw(IUniswapV2Pair uniswapV2Pair, bool denominationTokenIs0, uint8 minBlocksBack, uint8 maxBlocksBack, ProofData memory proofData) public view returns (uint256 price, uint256 blockNumber) {\r\n\t\tuint256 historicBlockTimestamp;\r\n\t\tuint256 historicPriceCumulativeLast;\r\n\t\t{\r\n\t\t\t// Stack-too-deep workaround, manual scope\r\n\t\t\t// Side-note: wtf Solidity?\r\n\t\t\tuint112 reserve0;\r\n\t\t\tuint112 reserve1;\r\n\t\t\tuint256 reserveTimestamp;\r\n\t\t\t(historicBlockTimestamp, blockNumber, historicPriceCumulativeLast, reserve0, reserve1, reserveTimestamp) = verifyBlockAndExtractReserveData(uniswapV2Pair, minBlocksBack, maxBlocksBack, denominationTokenIs0 ? token1Slot : token0Slot, proofData);\r\n\t\t\tuint256 secondsBetweenReserveUpdateAndHistoricBlock = historicBlockTimestamp - reserveTimestamp;\r\n\t\t\t// bring old record up-to-date, in case there was no cumulative update in provided historic block itself\r\n\t\t\tif (secondsBetweenReserveUpdateAndHistoricBlock > 0) {\r\n\t\t\t\thistoricPriceCumulativeLast += secondsBetweenReserveUpdateAndHistoricBlock * uint(UQ112x112\r\n\t\t\t\t\t.encode(denominationTokenIs0 ? reserve0 : reserve1)\r\n\t\t\t\t\t.uqdiv(denominationTokenIs0 ? reserve1 : reserve0)\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t}\r\n\t\tuint256 secondsBetweenProvidedBlockAndNow = block.timestamp - historicBlockTimestamp;\r\n\t\tprice = (getCurrentPriceCumulativeLast(uniswapV2Pair, denominationTokenIs0) - historicPriceCumulativeLast) / secondsBetweenProvidedBlockAndNow;\r\n\t\treturn (price, blockNumber);\r\n\t}\r\n\r\n\tfunction getCurrentPriceCumulativeLast(IUniswapV2Pair uniswapV2Pair, bool denominationTokenIs0) public view returns (uint256 priceCumulativeLast) {\r\n\t\t(uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = uniswapV2Pair.getReserves();\r\n\t\tpriceCumulativeLast = denominationTokenIs0 ? uniswapV2Pair.price1CumulativeLast() : uniswapV2Pair.price0CumulativeLast();\r\n\t\tuint256 timeElapsed = block.timestamp - blockTimestampLast;\r\n\t\tpriceCumulativeLast += timeElapsed * uint(UQ112x112\r\n\t\t\t.encode(denominationTokenIs0 ? reserve0 : reserve1)\r\n\t\t\t.uqdiv(denominationTokenIs0 ? reserve1 : reserve0)\r\n\t\t);\r\n\t}\r\n}\r\n\r\n// File: helpers/IKeydonixOracleEth.sol\r\n\r\n\r\ninterface IKeydonixOracleEth {\r\n\r\n    // returns Q112-encoded value\r\n    function assetToEth(address asset, uint amount, UniswapOracle.ProofData calldata proofData) external view returns (uint);\r\n}\r\n// File: helpers/IOracleEth.sol\r\n\r\ninterface IOracleEth {\r\n\r\n    // returns Q112-encoded value\r\n    function assetToEth(address asset, uint amount) external view returns (uint);\r\n\r\n    // returns the value \"as is\"\r\n    function ethToUsd(uint amount) external view returns (uint);\r\n\r\n    // returns the value \"as is\"\r\n    function usdToEth(uint amount) external view returns (uint);\r\n}\r\n// File: helpers/IOracleRegistry.sol\r\n\r\n\r\ninterface IOracleRegistry {\r\n\r\n    struct Oracle {\r\n        uint oracleType;\r\n        address oracleAddress;\r\n    }\r\n\r\n    function WETH (  ) external view returns ( address );\r\n    function getKeydonixOracleTypes (  ) external view returns ( uint256[] memory );\r\n    function getOracles (  ) external view returns ( Oracle[] memory foundOracles );\r\n    function keydonixOracleTypes ( uint256 ) external view returns ( uint256 );\r\n    function maxOracleType (  ) external view returns ( uint256 );\r\n    function oracleByAsset ( address asset ) external view returns ( address );\r\n    function oracleByType ( uint256 ) external view returns ( address );\r\n    function oracleTypeByAsset ( address ) external view returns ( uint256 );\r\n    function oracleTypeByOracle ( address ) external view returns ( uint256 );\r\n    function setKeydonixOracleTypes ( uint256[] calldata _keydonixOracleTypes ) external;\r\n    function setOracle ( uint256 oracleType, address oracle ) external;\r\n    function setOracleTypeForAsset ( address asset, uint256 oracleType ) external;\r\n    function setOracleTypeForAssets ( address[] calldata assets, uint256 oracleType ) external;\r\n    function unsetOracle ( uint256 oracleType ) external;\r\n    function unsetOracleForAsset ( address asset ) external;\r\n    function unsetOracleForAssets ( address[] calldata assets ) external;\r\n    function vaultParameters (  ) external view returns ( address );\r\n}\r\n\r\n// File: helpers/SafeMath.sol\r\n\r\n/*\r\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\r\n*/\r\npragma solidity ^0.6.8;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n// File: impl/ChainlinkedKeydonixOracleMainAsset.sol\r\n\r\n/*\r\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\r\n*/\r\npragma solidity 0.6.8;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ChainlinkedKeydonixOracleMainAsset\r\n * @dev Calculates the USD price of desired tokens\r\n **/\r\ncontract ChainlinkedKeydonixOracleMainAsset is UniswapOracle, IKeydonixOracleEth, IKeydonixOracleUsd {\r\n    using SafeMath for uint;\r\n\r\n    uint8 public constant MIN_BLOCKS_BACK = uint8(100);\r\n\r\n    uint8 public constant MAX_BLOCKS_BACK = uint8(255);\r\n\r\n    uint public constant ETH_USD_DENOMINATOR = 1e8;\r\n\r\n    uint public constant Q112 = 2 ** 112;\r\n\r\n    IUniswapV2Factory public immutable uniswapFactory;\r\n\r\n    IOracleRegistry public immutable oracleRegistry;\r\n\r\n    address public immutable WETH;\r\n\r\n    constructor(\r\n        IUniswapV2Factory uniFactory,\r\n        IOracleRegistry _oracleRegistry\r\n    )\r\n        public\r\n    {\r\n        require(address(uniFactory) != address(0), \"Unit Protocol: ZERO_ADDRESS\");\r\n        require(address(_oracleRegistry) != address(0), \"Unit Protocol: ZERO_ADDRESS\");\r\n\r\n        uniswapFactory = uniFactory;\r\n        WETH = _oracleRegistry.WETH();\r\n        oracleRegistry = _oracleRegistry;\r\n    }\r\n\r\n    /**\r\n     * @notice USD token's rate is UniswapV2 Token/WETH pool's average time weighted price between proofs' blockNumber and current block number\r\n     * @notice Merkle proof must be in range [MIN_BLOCKS_BACK ... MAX_BLOCKS_BACK] blocks ago\r\n     * @notice {Token}/WETH pair must exists on Uniswap\r\n     * @param asset The token address\r\n     * @param amount Amount of tokens\r\n     * @param proofData Merkle proof data\r\n     * @return Q112-encoded price of tokens in USD\r\n     **/\r\n    function assetToUsd(address asset, uint amount, UniswapOracle.ProofData memory proofData) public override view returns (uint) {\r\n        uint priceInEth = assetToEth(asset, amount, proofData);\r\n        return IOracleEth(oracleRegistry.oracleByAsset(WETH)).ethToUsd(priceInEth);\r\n    }\r\n\r\n    /**\r\n     * @notice USD token's rate is UniswapV2 Token/WETH pool's average price between proof's blockNumber and current block number\r\n     * @notice Merkle proof must be in range [MIN_BLOCKS_BACK ... MAX_BLOCKS_BACK] blocks ago\r\n     * @notice {Token}/WETH pair must be registered on Uniswap\r\n     * @param asset The token address\r\n     * @param amount Amount of tokens\r\n     * @param proofData Merkle proof data\r\n     * @return Q112-encoded price of asset in ETH\r\n     **/\r\n    function assetToEth(address asset, uint amount, UniswapOracle.ProofData memory proofData) public override view returns (uint) {\r\n        if (amount == 0) { return 0; }\r\n        if (asset == WETH) { return amount.mul(Q112); }\r\n        IUniswapV2Pair pair = IUniswapV2Pair(uniswapFactory.getPair(asset, WETH));\r\n        require(address(pair) != address(0), \"Unit Protocol: UNISWAP_PAIR_DOES_NOT_EXIST\");\r\n        (uint priceInEth, ) = getPrice(pair, WETH, MIN_BLOCKS_BACK, MAX_BLOCKS_BACK, proofData);\r\n        return priceInEth.mul(amount);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IUniswapV2Factory\",\"name\":\"uniFactory\",\"type\":\"address\"},{\"internalType\":\"contract IOracleRegistry\",\"name\":\"_oracleRegistry\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ETH_USD_DENOMINATOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_BLOCKS_BACK\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_BLOCKS_BACK\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Q112\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"block\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"accountProofNodesRlp\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"reserveAndTimestampProofNodesRlp\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"priceAccumulatorProofNodesRlp\",\"type\":\"bytes\"}],\"internalType\":\"struct UniswapOracle.ProofData\",\"name\":\"proofData\",\"type\":\"tuple\"}],\"name\":\"assetToEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"block\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"accountProofNodesRlp\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"reserveAndTimestampProofNodesRlp\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"priceAccumulatorProofNodesRlp\",\"type\":\"bytes\"}],\"internalType\":\"struct UniswapOracle.ProofData\",\"name\":\"proofData\",\"type\":\"tuple\"}],\"name\":\"assetToUsd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"uniswapV2Pair\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"block\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"accountProofNodesRlp\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"reserveAndTimestampProofNodesRlp\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"priceAccumulatorProofNodesRlp\",\"type\":\"bytes\"}],\"internalType\":\"struct UniswapOracle.ProofData\",\"name\":\"proofData\",\"type\":\"tuple\"}],\"name\":\"getAccountStorageRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"storageRootHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockTimestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"uniswapV2Pair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"denominationTokenIs0\",\"type\":\"bool\"}],\"name\":\"getCurrentPriceCumulativeLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"priceCumulativeLast\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"uniswapV2Pair\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"denominationToken\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"minBlocksBack\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"maxBlocksBack\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"block\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"accountProofNodesRlp\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"reserveAndTimestampProofNodesRlp\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"priceAccumulatorProofNodesRlp\",\"type\":\"bytes\"}],\"internalType\":\"struct UniswapOracle.ProofData\",\"name\":\"proofData\",\"type\":\"tuple\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"uniswapV2Pair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"denominationTokenIs0\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"minBlocksBack\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"maxBlocksBack\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"block\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"accountProofNodesRlp\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"reserveAndTimestampProofNodesRlp\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"priceAccumulatorProofNodesRlp\",\"type\":\"bytes\"}],\"internalType\":\"struct UniswapOracle.ProofData\",\"name\":\"proofData\",\"type\":\"tuple\"}],\"name\":\"getPriceRaw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracleRegistry\",\"outputs\":[{\"internalType\":\"contract IOracleRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserveTimestampSlotHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token0Slot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token1Slot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapFactory\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Factory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"uniswapV2Pair\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"minBlocksBack\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"maxBlocksBack\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"slotHash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"block\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"accountProofNodesRlp\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"reserveAndTimestampProofNodesRlp\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"priceAccumulatorProofNodesRlp\",\"type\":\"bytes\"}],\"internalType\":\"struct UniswapOracle.ProofData\",\"name\":\"proofData\",\"type\":\"tuple\"}],\"name\":\"verifyBlockAndExtractReserveData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"blockTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceCumulativeLast\",\"type\":\"uint256\"},{\"internalType\":\"uint112\",\"name\":\"reserve0\",\"type\":\"uint112\"},{\"internalType\":\"uint112\",\"name\":\"reserve1\",\"type\":\"uint112\"},{\"internalType\":\"uint256\",\"name\":\"reserveTimestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ChainlinkedKeydonixOracleMainAsset","CompilerVersion":"v0.6.8+commit.0bbfe453","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000005c69bee701ef814a2b6a3edd4b1652cb9cc5aa6f00000000000000000000000075fbfe26b21fd3ea008af0c764949f8214150c8f","EVMVersion":"Default","Library":"","LicenseType":"GNU LGPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://3fd9ccd55351f7378c20686406cb078e73ae79febe7e8011fc56961496dc1a5f"}]}