{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/Elena/Source/argent-contracts/contracts/infrastructure/dapp/BaseFilter.sol\": {\r\n      \"content\": \"// Copyright (C) 2021  Argent Labs Ltd. <https://argent.xyz>\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.3;\\n\\nimport \\\"./IFilter.sol\\\";\\n\\nabstract contract BaseFilter is IFilter {\\n    function getMethod(bytes memory _data) internal pure returns (bytes4 method) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            method := mload(add(_data, 0x20))\\n        }\\n    }\\n}\"\r\n    },\r\n    \"/Users/Elena/Source/argent-contracts/contracts/infrastructure/dapp/IFilter.sol\": {\r\n      \"content\": \"// Copyright (C) 2021  Argent Labs Ltd. <https://argent.xyz>\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.3;\\n\\ninterface IFilter {\\n    function isValid(address _wallet, address _spender, address _to, bytes calldata _data) external view returns (bool valid);\\n}\"\r\n    },\r\n    \"/Users/Elena/Source/argent-contracts/contracts/infrastructure/dapp/UniswapV2UniZapFilter.sol\": {\r\n      \"content\": \"// Copyright (C) 2021  Argent Labs Ltd. <https://argent.xyz>\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.3;\\n\\nimport \\\"./BaseFilter.sol\\\";\\n\\ncontract UniswapV2UniZapFilter is BaseFilter {\\n\\n    bytes4 private constant ERC20_APPROVE = bytes4(keccak256(\\\"approve(address,uint256)\\\"));\\n    bytes4 constant internal ADD_LIQUIDITY_WITH_ETH = bytes4(keccak256(\\\"swapExactETHAndAddLiquidity(address,uint256,address,uint256)\\\"));\\n    bytes4 constant internal REMOVE_LIQUIDITY_TO_ETH = bytes4(keccak256(\\\"removeLiquidityAndSwapToETH(address,uint256,uint256,address,uint256)\\\"));\\n    bytes4 constant internal ADD_LIQUIDITY_WITH_TOKEN = bytes4(\\n        keccak256(\\n            \\\"swapExactTokensAndAddLiquidity(address,address,uint256,uint256,address,uint256)\\\"\\n            )\\n        );\\n    bytes4 constant internal REMOVE_LIQUIDITY_TO_TOKEN = bytes4(\\n        keccak256(\\n            \\\"removeLiquidityAndSwapToToken(address,address,uint256,uint256,address,uint256)\\\"\\n            )\\n        );\\n\\n    // Token registry\\n    address public immutable tokenRegistry;\\n    // Uniswap V2 factory\\n    address public immutable uniFactory;\\n    // Uniswap v2 pair init code\\n    bytes32 public immutable uniInitCode;\\n    // WETH address\\n    address public immutable weth;\\n\\n    constructor (address _tokenRegistry, address _uniFactory, bytes32 _uniInitCode, address _weth) {\\n        tokenRegistry = _tokenRegistry;\\n        uniFactory = _uniFactory;\\n        uniInitCode = _uniInitCode;\\n        weth = _weth;\\n    }\\n\\n    function isValid(address _wallet, address _spender, address _to, bytes calldata _data) external view override returns (bool valid) {\\n        // not needed but detects failure early\\n        if (_data.length < 4) {\\n            return false;\\n        }\\n        bytes4 method = getMethod(_data);\\n        // UniZap method: check that pair is valid and recipient is the wallet\\n        if (_spender == _to) {\\n            if (method == ADD_LIQUIDITY_WITH_TOKEN || method == REMOVE_LIQUIDITY_TO_TOKEN) {\\n                (address tokenA, address tokenB, , , address recipient) = abi.decode(_data[4:], (address, address, uint256, uint256, address));\\n                return isValidPair(tokenA, tokenB) && recipient == _wallet;\\n            }\\n            if (method == ADD_LIQUIDITY_WITH_ETH) {\\n                (address token, , address recipient) = abi.decode(_data[4:], (address, uint256, address));\\n                return isValidPair(token, weth) && recipient == _wallet;\\n            }\\n            if (method == REMOVE_LIQUIDITY_TO_ETH) {\\n                (address token, , , address recipient) = abi.decode(_data[4:], (address, uint256, uint256, address));\\n                return isValidPair(token, weth) && recipient == _wallet;\\n            }\\n         // ERC20 methods\\n        } else {\\n            // only allow approve\\n            return (method == ERC20_APPROVE);\\n        }\\n    }\\n\\n    function isValidPair(address _tokenA, address _tokenB) internal view returns (bool) {\\n        address pair = pairFor(_tokenA, _tokenB);\\n        (bool success, bytes memory res) = tokenRegistry.staticcall(abi.encodeWithSignature(\\\"isTokenTradable(address)\\\", pair));\\n        return success && abi.decode(res, (bool));\\n    }\\n\\n    function pairFor(address _tokenA, address _tokenB) internal view returns (address) {\\n        (address token0, address token1) = _tokenA < _tokenB ? (_tokenA, _tokenB) : (_tokenB, _tokenA);\\n        return(address(uint160(uint256(keccak256(abi.encodePacked(\\n            hex\\\"ff\\\",\\n            uniFactory,\\n            keccak256(abi.encodePacked(token0, token1)),\\n            uniInitCode\\n        ))))));\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {\r\n      \"\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_uniFactory\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_uniInitCode\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"isValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"valid\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniInitCode\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"UniswapV2UniZapFilter","CompilerVersion":"v0.8.3+commit.8d00100c","OptimizationUsed":"1","Runs":"999","ConstructorArguments":"000000000000000000000000b0ec6c52f76574da1f1b2a20eb97e1eca75fd1170000000000000000000000005c69bee701ef814a2b6a3edd4b1652cb9cc5aa6f505fef446e85683f8d469f9a29612718156edbc931150eb74e2f3ffae9b35392000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}