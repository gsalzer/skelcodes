{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/arch/Hashing.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2019-2020, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nimport \\\"./Value.sol\\\";\\n\\nlibrary Hashing {\\n    using Hashing for Value.Data;\\n    using Value for Value.CodePoint;\\n\\n    function keccak1(bytes32 b) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(b));\\n    }\\n\\n    function keccak2(bytes32 a, bytes32 b) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(a, b));\\n    }\\n\\n    function bytes32FromArray(\\n        bytes memory arr,\\n        uint256 offset,\\n        uint256 arrLength\\n    ) internal pure returns (uint256) {\\n        uint256 res = 0;\\n        for (uint256 i = 0; i < 32; i++) {\\n            res = res << 8;\\n            bytes1 b = arrLength > offset + i ? arr[offset + i] : bytes1(0);\\n            res = res | uint256(uint8(b));\\n        }\\n        return res;\\n    }\\n\\n    /*\\n     * !! Note that dataLength must be a power of two !!\\n     *\\n     * If you have an arbitrary data length, you can round it up with roundUpToPow2.\\n     * The boolean return value tells if the data segment data[startOffset..startOffset+dataLength] only included zeroes.\\n     * If pack is true, the returned value is the merkle hash where trailing zeroes are ignored, that is,\\n     *   if h is the smallest height for which all data[startOffset+2**h..] are zero, merkle hash of data[startOffset..startOffset+2**h] is returned.\\n     * If all elements in the data segment are zero (and pack is true), keccak1(bytes32(0)) is returned.\\n     */\\n    function merkleRoot(\\n        bytes memory data,\\n        uint256 rawDataLength,\\n        uint256 startOffset,\\n        uint256 dataLength,\\n        bool pack\\n    ) internal pure returns (bytes32, bool) {\\n        if (dataLength <= 32) {\\n            if (startOffset >= rawDataLength) {\\n                return (keccak1(bytes32(0)), true);\\n            }\\n            bytes32 res = keccak1(bytes32(bytes32FromArray(data, startOffset, rawDataLength)));\\n            return (res, res == keccak1(bytes32(0)));\\n        }\\n        (bytes32 h2, bool zero2) =\\n            merkleRoot(data, rawDataLength, startOffset + dataLength / 2, dataLength / 2, false);\\n        if (zero2 && pack) {\\n            return merkleRoot(data, rawDataLength, startOffset, dataLength / 2, pack);\\n        }\\n        (bytes32 h1, bool zero1) =\\n            merkleRoot(data, rawDataLength, startOffset, dataLength / 2, false);\\n        return (keccak2(h1, h2), zero1 && zero2);\\n    }\\n\\n    function roundUpToPow2(uint256 len) internal pure returns (uint256) {\\n        if (len <= 1) return 1;\\n        else return 2 * roundUpToPow2((len + 1) / 2);\\n    }\\n\\n    function bytesToBufferHash(\\n        bytes memory buf,\\n        uint256 startOffset,\\n        uint256 length\\n    ) internal pure returns (bytes32) {\\n        (bytes32 mhash, ) =\\n            merkleRoot(buf, startOffset + length, startOffset, roundUpToPow2(length), true);\\n        return keccak2(bytes32(uint256(123)), mhash);\\n    }\\n\\n    function hashInt(uint256 val) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(val));\\n    }\\n\\n    function hashCodePoint(Value.CodePoint memory cp) internal pure returns (bytes32) {\\n        assert(cp.immediate.length < 2);\\n        if (cp.immediate.length == 0) {\\n            return\\n                keccak256(abi.encodePacked(Value.codePointTypeCode(), cp.opcode, cp.nextCodePoint));\\n        }\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    Value.codePointTypeCode(),\\n                    cp.opcode,\\n                    cp.immediate[0].hash(),\\n                    cp.nextCodePoint\\n                )\\n            );\\n    }\\n\\n    function hashTuplePreImage(bytes32 innerHash, uint256 valueSize)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(abi.encodePacked(uint8(Value.tupleTypeCode()), innerHash, valueSize));\\n    }\\n\\n    function hash(Value.Data memory val) internal pure returns (bytes32) {\\n        if (val.typeCode == Value.intTypeCode()) {\\n            return hashInt(val.intVal);\\n        } else if (val.typeCode == Value.codePointTypeCode()) {\\n            return hashCodePoint(val.cpVal);\\n        } else if (val.typeCode == Value.tuplePreImageTypeCode()) {\\n            return hashTuplePreImage(bytes32(val.intVal), val.size);\\n        } else if (val.typeCode == Value.tupleTypeCode()) {\\n            Value.Data memory preImage = getTuplePreImage(val.tupleVal);\\n            return preImage.hash();\\n        } else if (val.typeCode == Value.hashOnlyTypeCode()) {\\n            return bytes32(val.intVal);\\n        } else if (val.typeCode == Value.bufferTypeCode()) {\\n            return keccak256(abi.encodePacked(uint256(123), val.bufferHash));\\n        } else {\\n            require(false, \\\"Invalid type code\\\");\\n        }\\n    }\\n\\n    function getTuplePreImage(Value.Data[] memory vals) internal pure returns (Value.Data memory) {\\n        require(vals.length <= 8, \\\"Invalid tuple length\\\");\\n        bytes32[] memory hashes = new bytes32[](vals.length);\\n        uint256 hashCount = hashes.length;\\n        uint256 size = 1;\\n        for (uint256 i = 0; i < hashCount; i++) {\\n            hashes[i] = vals[i].hash();\\n            size += vals[i].size;\\n        }\\n        bytes32 firstHash = keccak256(abi.encodePacked(uint8(hashes.length), hashes));\\n        return Value.newTuplePreImage(firstHash, size);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/arch/IOneStepProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2020, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nimport \\\"../bridge/interfaces/IBridge.sol\\\";\\nimport \\\"../bridge/interfaces/ISequencerInbox.sol\\\";\\n\\ninterface IOneStepProof {\\n    // Bridges is sequencer bridge then delayed bridge\\n    function executeStep(\\n        address[2] calldata bridges,\\n        uint256 initialMessagesRead,\\n        bytes32[2] calldata accs,\\n        bytes calldata proof,\\n        bytes calldata bproof\\n    )\\n        external\\n        view\\n        returns (\\n            uint64 gas,\\n            uint256 afterMessagesRead,\\n            bytes32[4] memory fields\\n        );\\n\\n    function executeStepDebug(\\n        address[2] calldata bridges,\\n        uint256 initialMessagesRead,\\n        bytes32[2] calldata accs,\\n        bytes calldata proof,\\n        bytes calldata bproof\\n    ) external view returns (string memory startMachine, string memory afterMachine);\\n}\\n\"\r\n    },\r\n    \"contracts/arch/Machine.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2019-2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nimport \\\"./Marshaling.sol\\\";\\n\\nimport \\\"../libraries/DebugPrint.sol\\\";\\n\\nlibrary Machine {\\n    using Hashing for Value.Data;\\n\\n    // Make sure these don't conflict with Challenge.MACHINE_UNREACHABLE (currently 100)\\n    uint256 internal constant MACHINE_EXTENSIVE = 0;\\n    uint256 internal constant MACHINE_ERRORSTOP = 1;\\n    uint256 internal constant MACHINE_HALT = 2;\\n\\n    function addStackVal(Value.Data memory stackValHash, Value.Data memory valHash)\\n        internal\\n        pure\\n        returns (Value.Data memory)\\n    {\\n        Value.Data[] memory vals = new Value.Data[](2);\\n        vals[0] = valHash;\\n        vals[1] = stackValHash;\\n\\n        return Hashing.getTuplePreImage(vals);\\n    }\\n\\n    struct Data {\\n        bytes32 instructionStackHash;\\n        Value.Data dataStack;\\n        Value.Data auxStack;\\n        Value.Data registerVal;\\n        Value.Data staticVal;\\n        uint256 arbGasRemaining;\\n        bytes32 errHandlerHash;\\n        uint256 status;\\n    }\\n\\n    function toString(Data memory machine) internal pure returns (string memory) {\\n        return\\n            string(\\n                abi.encodePacked(\\n                    \\\"Machine(\\\",\\n                    DebugPrint.bytes32string(machine.instructionStackHash),\\n                    \\\", \\\\n\\\",\\n                    DebugPrint.bytes32string(machine.dataStack.hash()),\\n                    \\\", \\\\n\\\",\\n                    DebugPrint.bytes32string(machine.auxStack.hash()),\\n                    \\\", \\\\n\\\",\\n                    DebugPrint.bytes32string(machine.registerVal.hash()),\\n                    \\\", \\\\n\\\",\\n                    DebugPrint.bytes32string(machine.staticVal.hash()),\\n                    \\\", \\\\n\\\",\\n                    DebugPrint.uint2str(machine.arbGasRemaining),\\n                    \\\", \\\\n\\\",\\n                    DebugPrint.bytes32string(machine.errHandlerHash),\\n                    \\\")\\\\n\\\"\\n                )\\n            );\\n    }\\n\\n    function setErrorStop(Data memory machine) internal pure {\\n        machine.status = MACHINE_ERRORSTOP;\\n    }\\n\\n    function setHalt(Data memory machine) internal pure {\\n        machine.status = MACHINE_HALT;\\n    }\\n\\n    function addDataStackValue(Data memory machine, Value.Data memory val) internal pure {\\n        machine.dataStack = addStackVal(machine.dataStack, val);\\n    }\\n\\n    function addAuxStackValue(Data memory machine, Value.Data memory val) internal pure {\\n        machine.auxStack = addStackVal(machine.auxStack, val);\\n    }\\n\\n    function addDataStackInt(Data memory machine, uint256 val) internal pure {\\n        machine.dataStack = addStackVal(machine.dataStack, Value.newInt(val));\\n    }\\n\\n    function hash(Data memory machine) internal pure returns (bytes32) {\\n        if (machine.status == MACHINE_HALT) {\\n            return bytes32(uint256(0));\\n        } else if (machine.status == MACHINE_ERRORSTOP) {\\n            return bytes32(uint256(1));\\n        } else {\\n            return\\n                keccak256(\\n                    abi.encodePacked(\\n                        machine.instructionStackHash,\\n                        machine.dataStack.hash(),\\n                        machine.auxStack.hash(),\\n                        machine.registerVal.hash(),\\n                        machine.staticVal.hash(),\\n                        machine.arbGasRemaining,\\n                        machine.errHandlerHash\\n                    )\\n                );\\n        }\\n    }\\n\\n    function clone(Data memory machine) internal pure returns (Data memory) {\\n        return\\n            Data(\\n                machine.instructionStackHash,\\n                machine.dataStack,\\n                machine.auxStack,\\n                machine.registerVal,\\n                machine.staticVal,\\n                machine.arbGasRemaining,\\n                machine.errHandlerHash,\\n                machine.status\\n            );\\n    }\\n\\n    function deserializeMachine(bytes memory data, uint256 offset)\\n        internal\\n        pure\\n        returns (\\n            uint256, // offset\\n            Data memory // machine\\n        )\\n    {\\n        Data memory m;\\n        m.status = MACHINE_EXTENSIVE;\\n        uint256 instructionStack;\\n        uint256 errHandler;\\n        (offset, instructionStack) = Marshaling.deserializeInt(data, offset);\\n\\n        (offset, m.dataStack) = Marshaling.deserializeHashPreImage(data, offset);\\n        (offset, m.auxStack) = Marshaling.deserializeHashPreImage(data, offset);\\n        (offset, m.registerVal) = Marshaling.deserialize(data, offset);\\n        (offset, m.staticVal) = Marshaling.deserialize(data, offset);\\n        (offset, m.arbGasRemaining) = Marshaling.deserializeInt(data, offset);\\n        (offset, errHandler) = Marshaling.deserializeInt(data, offset);\\n\\n        m.instructionStackHash = bytes32(instructionStack);\\n        m.errHandlerHash = bytes32(errHandler);\\n        return (offset, m);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/arch/Marshaling.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2019-2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nimport \\\"./Value.sol\\\";\\nimport \\\"./Hashing.sol\\\";\\n\\nimport \\\"../libraries/BytesLib.sol\\\";\\n\\nlibrary Marshaling {\\n    using BytesLib for bytes;\\n    using Value for Value.Data;\\n\\n    // This depends on how it's implemented in arb-os\\n    function deserializeMessage(bytes memory data, uint256 startOffset)\\n        internal\\n        pure\\n        returns (\\n            bool,\\n            uint256,\\n            address,\\n            uint8,\\n            bytes memory\\n        )\\n    {\\n        require(data.length >= startOffset && data.length - startOffset >= 8, \\\"too short\\\");\\n        uint256 size = 0;\\n        for (uint256 i = 0; i < 8; i++) {\\n            size *= 256;\\n            size += uint8(data[startOffset + 7 - i]);\\n        }\\n        (, uint256 sender) = deserializeInt(data, startOffset + 8);\\n        (, uint256 kind) = deserializeInt(data, startOffset + 8 + 32);\\n        bytes memory res = new bytes(size - 64);\\n        for (uint256 i = 0; i < size - 64; i++) {\\n            res[i] = data[startOffset + 8 + 64 + i];\\n        }\\n        return (true, startOffset + 8 + size, address(uint160(sender)), uint8(kind), res);\\n    }\\n\\n    function deserializeRawMessage(bytes memory data, uint256 startOffset)\\n        internal\\n        pure\\n        returns (\\n            bool,\\n            uint256,\\n            bytes memory\\n        )\\n    {\\n        require(data.length >= startOffset && data.length - startOffset >= 8, \\\"too short\\\");\\n        uint256 size = 0;\\n        for (uint256 i = 0; i < 8; i++) {\\n            size *= 256;\\n            size += uint8(data[startOffset + 7 - i]);\\n        }\\n        bytes memory res = new bytes(size);\\n        for (uint256 i = 0; i < size; i++) {\\n            res[i] = data[startOffset + 8 + i];\\n        }\\n        return (true, startOffset + 8 + size, res);\\n    }\\n\\n    function deserializeHashPreImage(bytes memory data, uint256 startOffset)\\n        internal\\n        pure\\n        returns (uint256 offset, Value.Data memory value)\\n    {\\n        require(data.length >= startOffset && data.length - startOffset >= 64, \\\"too short\\\");\\n        bytes32 hashData;\\n        uint256 size;\\n        (offset, hashData) = extractBytes32(data, startOffset);\\n        (offset, size) = deserializeInt(data, offset);\\n        return (offset, Value.newTuplePreImage(hashData, size));\\n    }\\n\\n    function deserializeInt(bytes memory data, uint256 startOffset)\\n        internal\\n        pure\\n        returns (\\n            uint256, // offset\\n            uint256 // val\\n        )\\n    {\\n        require(data.length >= startOffset && data.length - startOffset >= 32, \\\"too short\\\");\\n        return (startOffset + 32, data.toUint(startOffset));\\n    }\\n\\n    function deserializeBytes32(bytes memory data, uint256 startOffset)\\n        internal\\n        pure\\n        returns (\\n            uint256, // offset\\n            bytes32 // val\\n        )\\n    {\\n        require(data.length >= startOffset && data.length - startOffset >= 32, \\\"too short\\\");\\n        return (startOffset + 32, data.toBytes32(startOffset));\\n    }\\n\\n    function deserializeCodePoint(bytes memory data, uint256 startOffset)\\n        internal\\n        pure\\n        returns (\\n            uint256, // offset\\n            Value.Data memory // val\\n        )\\n    {\\n        uint256 offset = startOffset;\\n        uint8 immediateType;\\n        uint8 opCode;\\n        Value.Data memory immediate;\\n        bytes32 nextHash;\\n\\n        (offset, immediateType) = extractUint8(data, offset);\\n        (offset, opCode) = extractUint8(data, offset);\\n        if (immediateType == 1) {\\n            (offset, immediate) = deserialize(data, offset);\\n        }\\n        (offset, nextHash) = extractBytes32(data, offset);\\n        if (immediateType == 1) {\\n            return (offset, Value.newCodePoint(opCode, nextHash, immediate));\\n        }\\n        return (offset, Value.newCodePoint(opCode, nextHash));\\n    }\\n\\n    function deserializeTuple(\\n        uint8 memberCount,\\n        bytes memory data,\\n        uint256 startOffset\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint256, // offset\\n            Value.Data[] memory // val\\n        )\\n    {\\n        uint256 offset = startOffset;\\n        Value.Data[] memory members = new Value.Data[](memberCount);\\n        for (uint8 i = 0; i < memberCount; i++) {\\n            (offset, members[i]) = deserialize(data, offset);\\n        }\\n        return (offset, members);\\n    }\\n\\n    function deserialize(bytes memory data, uint256 startOffset)\\n        internal\\n        pure\\n        returns (\\n            uint256, // offset\\n            Value.Data memory // val\\n        )\\n    {\\n        require(startOffset < data.length, \\\"invalid offset\\\");\\n        (uint256 offset, uint8 valType) = extractUint8(data, startOffset);\\n        if (valType == Value.intTypeCode()) {\\n            uint256 intVal;\\n            (offset, intVal) = deserializeInt(data, offset);\\n            return (offset, Value.newInt(intVal));\\n        } else if (valType == Value.codePointTypeCode()) {\\n            return deserializeCodePoint(data, offset);\\n        } else if (valType == Value.bufferTypeCode()) {\\n            bytes32 hashVal;\\n            (offset, hashVal) = deserializeBytes32(data, offset);\\n            return (offset, Value.newBuffer(hashVal));\\n        } else if (valType == Value.tuplePreImageTypeCode()) {\\n            return deserializeHashPreImage(data, offset);\\n        } else if (valType >= Value.tupleTypeCode() && valType < Value.valueTypeCode()) {\\n            uint8 tupLength = uint8(valType - Value.tupleTypeCode());\\n            Value.Data[] memory tupleVal;\\n            (offset, tupleVal) = deserializeTuple(tupLength, data, offset);\\n            return (offset, Value.newTuple(tupleVal));\\n        }\\n        require(false, \\\"invalid typecode\\\");\\n    }\\n\\n    function extractUint8(bytes memory data, uint256 startOffset)\\n        private\\n        pure\\n        returns (\\n            uint256, // offset\\n            uint8 // val\\n        )\\n    {\\n        return (startOffset + 1, uint8(data[startOffset]));\\n    }\\n\\n    function extractBytes32(bytes memory data, uint256 startOffset)\\n        private\\n        pure\\n        returns (\\n            uint256, // offset\\n            bytes32 // val\\n        )\\n    {\\n        return (startOffset + 32, data.toBytes32(startOffset));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/arch/OneStepProofCommon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2019-2020, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nimport \\\"./IOneStepProof.sol\\\";\\nimport \\\"./Value.sol\\\";\\nimport \\\"./Machine.sol\\\";\\nimport \\\"../bridge/interfaces/IBridge.sol\\\";\\nimport \\\"../bridge/interfaces/ISequencerInbox.sol\\\";\\n\\nabstract contract OneStepProofCommon is IOneStepProof {\\n    using Machine for Machine.Data;\\n    using Hashing for Value.Data;\\n    using Value for Value.Data;\\n\\n    uint256 internal constant MAX_UINT256 = ((1 << 128) + 1) * ((1 << 128) - 1);\\n\\n    uint64 internal constant ERROR_GAS_COST = 5;\\n\\n    string internal constant BAD_IMM_TYP = \\\"BAD_IMM_TYP\\\";\\n    string internal constant NO_IMM = \\\"NO_IMM\\\";\\n    string internal constant STACK_MISSING = \\\"STACK_MISSING\\\";\\n    string internal constant AUX_MISSING = \\\"AUX_MISSING\\\";\\n    string internal constant STACK_MANY = \\\"STACK_MANY\\\";\\n    string internal constant AUX_MANY = \\\"AUX_MANY\\\";\\n    string internal constant INBOX_VAL = \\\"INBOX_VAL\\\";\\n\\n    // Stop and arithmetic ops\\n    uint8 internal constant OP_ADD = 0x01;\\n    uint8 internal constant OP_MUL = 0x02;\\n    uint8 internal constant OP_SUB = 0x03;\\n    uint8 internal constant OP_DIV = 0x04;\\n    uint8 internal constant OP_SDIV = 0x05;\\n    uint8 internal constant OP_MOD = 0x06;\\n    uint8 internal constant OP_SMOD = 0x07;\\n    uint8 internal constant OP_ADDMOD = 0x08;\\n    uint8 internal constant OP_MULMOD = 0x09;\\n    uint8 internal constant OP_EXP = 0x0a;\\n    uint8 internal constant OP_SIGNEXTEND = 0x0b;\\n\\n    // Comparison & bitwise logic\\n    uint8 internal constant OP_LT = 0x10;\\n    uint8 internal constant OP_GT = 0x11;\\n    uint8 internal constant OP_SLT = 0x12;\\n    uint8 internal constant OP_SGT = 0x13;\\n    uint8 internal constant OP_EQ = 0x14;\\n    uint8 internal constant OP_ISZERO = 0x15;\\n    uint8 internal constant OP_AND = 0x16;\\n    uint8 internal constant OP_OR = 0x17;\\n    uint8 internal constant OP_XOR = 0x18;\\n    uint8 internal constant OP_NOT = 0x19;\\n    uint8 internal constant OP_BYTE = 0x1a;\\n    uint8 internal constant OP_SHL = 0x1b;\\n    uint8 internal constant OP_SHR = 0x1c;\\n    uint8 internal constant OP_SAR = 0x1d;\\n\\n    // SHA3\\n    uint8 internal constant OP_HASH = 0x20;\\n    uint8 internal constant OP_TYPE = 0x21;\\n    uint8 internal constant OP_ETHHASH2 = 0x22;\\n    uint8 internal constant OP_KECCAK_F = 0x23;\\n    uint8 internal constant OP_SHA256_F = 0x24;\\n\\n    // Stack, Memory, Storage and Flow Operations\\n    uint8 internal constant OP_POP = 0x30;\\n    uint8 internal constant OP_SPUSH = 0x31;\\n    uint8 internal constant OP_RPUSH = 0x32;\\n    uint8 internal constant OP_RSET = 0x33;\\n    uint8 internal constant OP_JUMP = 0x34;\\n    uint8 internal constant OP_CJUMP = 0x35;\\n    uint8 internal constant OP_STACKEMPTY = 0x36;\\n    uint8 internal constant OP_PCPUSH = 0x37;\\n    uint8 internal constant OP_AUXPUSH = 0x38;\\n    uint8 internal constant OP_AUXPOP = 0x39;\\n    uint8 internal constant OP_AUXSTACKEMPTY = 0x3a;\\n    uint8 internal constant OP_NOP = 0x3b;\\n    uint8 internal constant OP_ERRPUSH = 0x3c;\\n    uint8 internal constant OP_ERRSET = 0x3d;\\n\\n    // Duplication and Exchange operations\\n    uint8 internal constant OP_DUP0 = 0x40;\\n    uint8 internal constant OP_DUP1 = 0x41;\\n    uint8 internal constant OP_DUP2 = 0x42;\\n    uint8 internal constant OP_SWAP1 = 0x43;\\n    uint8 internal constant OP_SWAP2 = 0x44;\\n\\n    // Tuple operations\\n    uint8 internal constant OP_TGET = 0x50;\\n    uint8 internal constant OP_TSET = 0x51;\\n    uint8 internal constant OP_TLEN = 0x52;\\n    uint8 internal constant OP_XGET = 0x53;\\n    uint8 internal constant OP_XSET = 0x54;\\n\\n    // Logging operations\\n    uint8 internal constant OP_BREAKPOINT = 0x60;\\n    uint8 internal constant OP_LOG = 0x61;\\n\\n    // System operations\\n    uint8 internal constant OP_SEND = 0x70;\\n    // OP_INBOX_PEEK has been removed\\n    uint8 internal constant OP_INBOX = 0x72;\\n    uint8 internal constant OP_ERROR = 0x73;\\n    uint8 internal constant OP_STOP = 0x74;\\n    uint8 internal constant OP_SETGAS = 0x75;\\n    uint8 internal constant OP_PUSHGAS = 0x76;\\n    uint8 internal constant OP_ERR_CODE_POINT = 0x77;\\n    uint8 internal constant OP_PUSH_INSN = 0x78;\\n    uint8 internal constant OP_PUSH_INSN_IMM = 0x79;\\n    // uint8 private constant OP_OPEN_INSN = 0x7a;\\n    uint8 internal constant OP_SIDELOAD = 0x7b;\\n\\n    uint8 internal constant OP_ECRECOVER = 0x80;\\n    uint8 internal constant OP_ECADD = 0x81;\\n    uint8 internal constant OP_ECMUL = 0x82;\\n    uint8 internal constant OP_ECPAIRING = 0x83;\\n\\n    uint8 internal constant OP_DEBUGPRINT = 0x90;\\n\\n    // Buffer operations\\n    uint8 internal constant OP_NEWBUFFER = 0xa0;\\n    uint8 internal constant OP_GETBUFFER8 = 0xa1;\\n    uint8 internal constant OP_GETBUFFER64 = 0xa2;\\n    uint8 internal constant OP_GETBUFFER256 = 0xa3;\\n    uint8 internal constant OP_SETBUFFER8 = 0xa4;\\n    uint8 internal constant OP_SETBUFFER64 = 0xa5;\\n    uint8 internal constant OP_SETBUFFER256 = 0xa6;\\n\\n    uint8 internal constant CODE_POINT_TYPECODE = 1;\\n    bytes32 internal constant CODE_POINT_ERROR =\\n        keccak256(abi.encodePacked(CODE_POINT_TYPECODE, uint8(0), bytes32(0)));\\n\\n    uint256 internal constant SEND_SIZE_LIMIT = 10000;\\n\\n    // accs is [sendAcc, logAcc]\\n    function executeStep(\\n        address[2] calldata bridges,\\n        uint256 initialMessagesRead,\\n        bytes32[2] calldata accs,\\n        bytes calldata proof,\\n        bytes calldata bproof\\n    )\\n        external\\n        view\\n        override\\n        returns (\\n            uint64 gas,\\n            uint256 afterMessagesRead,\\n            bytes32[4] memory fields\\n        )\\n    {\\n        AssertionContext memory context =\\n            initializeExecutionContext(initialMessagesRead, accs, proof, bproof, bridges);\\n\\n        executeOp(context);\\n\\n        return returnContext(context);\\n    }\\n\\n    function executeStepDebug(\\n        address[2] calldata bridges,\\n        uint256 initialMessagesRead,\\n        bytes32[2] calldata accs,\\n        bytes calldata proof,\\n        bytes calldata bproof\\n    ) external view override returns (string memory startMachine, string memory afterMachine) {\\n        AssertionContext memory context =\\n            initializeExecutionContext(initialMessagesRead, accs, proof, bproof, bridges);\\n\\n        executeOp(context);\\n        startMachine = Machine.toString(context.startMachine);\\n        afterMachine = Machine.toString(context.afterMachine);\\n    }\\n\\n    // fields\\n    // startMachineHash,\\n    // endMachineHash,\\n    // afterInboxAcc,\\n    // afterMessagesHash,\\n    // afterLogsHash\\n\\n    function returnContext(AssertionContext memory context)\\n        internal\\n        pure\\n        returns (\\n            uint64 gas,\\n            uint256 afterMessagesRead,\\n            bytes32[4] memory fields\\n        )\\n    {\\n        return (\\n            context.gas,\\n            context.totalMessagesRead,\\n            [\\n                Machine.hash(context.startMachine),\\n                Machine.hash(context.afterMachine),\\n                context.sendAcc,\\n                context.logAcc\\n            ]\\n        );\\n    }\\n\\n    struct ValueStack {\\n        uint256 length;\\n        Value.Data[] values;\\n    }\\n\\n    function popVal(ValueStack memory stack) internal pure returns (Value.Data memory) {\\n        Value.Data memory val = stack.values[stack.length - 1];\\n        stack.length--;\\n        return val;\\n    }\\n\\n    function pushVal(ValueStack memory stack, Value.Data memory val) internal pure {\\n        stack.values[stack.length] = val;\\n        stack.length++;\\n    }\\n\\n    struct AssertionContext {\\n        ISequencerInbox sequencerBridge;\\n        IBridge delayedBridge;\\n        Machine.Data startMachine;\\n        Machine.Data afterMachine;\\n        uint256 totalMessagesRead;\\n        bytes32 sendAcc;\\n        bytes32 logAcc;\\n        uint64 gas;\\n        ValueStack stack;\\n        ValueStack auxstack;\\n        bool hadImmediate;\\n        uint8 opcode;\\n        bytes proof;\\n        uint256 offset;\\n        // merkle proofs for buffer\\n        bytes bufProof;\\n        bool errorOccurred;\\n    }\\n\\n    function handleError(AssertionContext memory context) internal pure {\\n        context.errorOccurred = true;\\n    }\\n\\n    function deductGas(AssertionContext memory context, uint64 amount)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        if (context.afterMachine.arbGasRemaining < amount) {\\n            // ERROR + GAS_SET\\n            context.gas += ERROR_GAS_COST;\\n            context.afterMachine.arbGasRemaining = MAX_UINT256;\\n            return true;\\n        } else {\\n            context.gas += amount;\\n            context.afterMachine.arbGasRemaining -= amount;\\n            return false;\\n        }\\n    }\\n\\n    function handleOpcodeError(AssertionContext memory context) internal pure {\\n        handleError(context);\\n    }\\n\\n    function initializeExecutionContext(\\n        uint256 initialMessagesRead,\\n        bytes32[2] calldata accs,\\n        bytes memory proof,\\n        bytes memory bproof,\\n        address[2] calldata bridges\\n    ) internal pure returns (AssertionContext memory) {\\n        uint8 opCode = uint8(proof[0]);\\n        uint8 stackCount = uint8(proof[1]);\\n        uint8 auxstackCount = uint8(proof[2]);\\n        uint256 offset = 3;\\n\\n        // Leave some extra space for values pushed on the stack in the proofs\\n        Value.Data[] memory stackVals = new Value.Data[](stackCount + 4);\\n        Value.Data[] memory auxstackVals = new Value.Data[](auxstackCount + 4);\\n        for (uint256 i = 0; i < stackCount; i++) {\\n            (offset, stackVals[i]) = Marshaling.deserialize(proof, offset);\\n        }\\n        for (uint256 i = 0; i < auxstackCount; i++) {\\n            (offset, auxstackVals[i]) = Marshaling.deserialize(proof, offset);\\n        }\\n        Machine.Data memory mach;\\n        (offset, mach) = Machine.deserializeMachine(proof, offset);\\n\\n        uint8 immediate = uint8(proof[offset]);\\n        offset += 1;\\n\\n        AssertionContext memory context;\\n        context.sequencerBridge = ISequencerInbox(bridges[0]);\\n        context.delayedBridge = IBridge(bridges[1]);\\n        context.startMachine = mach;\\n        context.afterMachine = mach.clone();\\n        context.totalMessagesRead = initialMessagesRead;\\n        context.sendAcc = accs[0];\\n        context.logAcc = accs[1];\\n        context.gas = 0;\\n        context.stack = ValueStack(stackCount, stackVals);\\n        context.auxstack = ValueStack(auxstackCount, auxstackVals);\\n        context.hadImmediate = immediate == 1;\\n        context.opcode = opCode;\\n        context.proof = proof;\\n        context.bufProof = bproof;\\n        context.errorOccurred = false;\\n        context.offset = offset;\\n\\n        require(immediate == 0 || immediate == 1, BAD_IMM_TYP);\\n        Value.Data memory cp;\\n        if (immediate == 0) {\\n            cp = Value.newCodePoint(uint8(opCode), context.startMachine.instructionStackHash);\\n        } else {\\n            // If we have an immediate, there must be at least one stack value\\n            require(stackVals.length > 0, NO_IMM);\\n            cp = Value.newCodePoint(\\n                uint8(opCode),\\n                context.startMachine.instructionStackHash,\\n                stackVals[stackCount - 1]\\n            );\\n        }\\n        context.startMachine.instructionStackHash = cp.hash();\\n\\n        // Add the stack and auxstack values to the start machine\\n        uint256 i = 0;\\n        for (i = 0; i < stackCount - immediate; i++) {\\n            context.startMachine.addDataStackValue(stackVals[i]);\\n        }\\n        for (i = 0; i < auxstackCount; i++) {\\n            context.startMachine.addAuxStackValue(auxstackVals[i]);\\n        }\\n\\n        return context;\\n    }\\n\\n    function executeOp(AssertionContext memory context) internal view {\\n        (\\n            uint256 dataPopCount,\\n            uint256 auxPopCount,\\n            uint64 gasCost,\\n            function(AssertionContext memory) internal view impl\\n        ) = opInfo(context.opcode);\\n\\n        // Require the prover to submit the minimal number of stack items\\n        require(\\n            ((dataPopCount > 0 || !context.hadImmediate) && context.stack.length <= dataPopCount) ||\\n                (context.hadImmediate && dataPopCount == 0 && context.stack.length == 1),\\n            STACK_MANY\\n        );\\n        require(context.auxstack.length <= auxPopCount, AUX_MANY);\\n\\n        // Update end machine gas remaining before running opcode\\n        if (context.stack.length < dataPopCount) {\\n            // If we have insufficient values, reject the proof unless the stack has been fully exhausted\\n            require(\\n                context.afterMachine.dataStack.hash() == Value.newEmptyTuple().hash(),\\n                STACK_MISSING\\n            );\\n            deductGas(context, ERROR_GAS_COST);\\n            // If the stack is empty, the instruction underflowed so we have hit an error\\n            handleError(context);\\n        } else if (context.auxstack.length < auxPopCount) {\\n            // If we have insufficient values, reject the proof unless the auxstack has been fully exhausted\\n            require(\\n                context.afterMachine.auxStack.hash() == Value.newEmptyTuple().hash(),\\n                AUX_MISSING\\n            );\\n            deductGas(context, ERROR_GAS_COST);\\n            // If the auxstack is empty, the instruction underflowed so we have hit an error\\n            handleError(context);\\n        } else if (deductGas(context, gasCost)) {\\n            handleError(context);\\n        } else {\\n            impl(context);\\n        }\\n\\n        if (context.errorOccurred) {\\n            if (context.afterMachine.errHandlerHash == CODE_POINT_ERROR) {\\n                context.afterMachine.setErrorStop();\\n            } else {\\n                // Clear error\\n                context.errorOccurred = false;\\n                context.afterMachine.instructionStackHash = context.afterMachine.errHandlerHash;\\n\\n                if (!(context.hadImmediate && dataPopCount == 0)) {\\n                    context.stack.length = 0;\\n                }\\n                context.auxstack.length = 0;\\n            }\\n        }\\n\\n        // Add the stack and auxstack values to the start machine\\n        uint256 i = 0;\\n\\n        for (i = 0; i < context.stack.length; i++) {\\n            context.afterMachine.addDataStackValue(context.stack.values[i]);\\n        }\\n\\n        for (i = 0; i < context.auxstack.length; i++) {\\n            context.afterMachine.addAuxStackValue(context.auxstack.values[i]);\\n        }\\n    }\\n\\n    function opInfo(uint256 opCode)\\n        internal\\n        pure\\n        virtual\\n        returns (\\n            uint256, // stack pops\\n            uint256, // auxstack pops\\n            uint64, // gas used\\n            function(AssertionContext memory) internal view // impl\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/arch/OneStepProofHash.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2019-2020, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nimport \\\"./OneStepProofCommon.sol\\\";\\n\\nimport \\\"../libraries/Precompiles.sol\\\";\\n\\n// Originally forked from https://github.com/leapdao/solEVM-enforcer/tree/master\\n\\ncontract OneStepProofHash is OneStepProofCommon {\\n    function executeHashInsn(AssertionContext memory context) internal pure {\\n        Value.Data memory val = popVal(context.stack);\\n        pushVal(context.stack, Value.newInt(uint256(val.hash())));\\n    }\\n\\n    function executeTypeInsn(AssertionContext memory context) internal pure {\\n        Value.Data memory val = popVal(context.stack);\\n        pushVal(context.stack, val.typeCodeVal());\\n    }\\n\\n    function executeEthHash2Insn(AssertionContext memory context) internal pure {\\n        Value.Data memory val1 = popVal(context.stack);\\n        Value.Data memory val2 = popVal(context.stack);\\n        if (!val1.isInt() || !val2.isInt()) {\\n            handleOpcodeError(context);\\n            return;\\n        }\\n        uint256 a = val1.intVal;\\n        uint256 b = val2.intVal;\\n        uint256 c = uint256(keccak256(abi.encodePacked(a, b)));\\n        pushVal(context.stack, Value.newInt(c));\\n    }\\n\\n    function executeKeccakFInsn(AssertionContext memory context) internal pure {\\n        Value.Data memory val = popVal(context.stack);\\n        if (!val.isTuple() || val.tupleVal.length != 7) {\\n            handleOpcodeError(context);\\n            return;\\n        }\\n\\n        Value.Data[] memory values = val.tupleVal;\\n        for (uint256 i = 0; i < 7; i++) {\\n            if (!values[i].isInt()) {\\n                handleOpcodeError(context);\\n                return;\\n            }\\n        }\\n        uint256[25] memory data;\\n        for (uint256 i = 0; i < 25; i++) {\\n            data[5 * (i % 5) + i / 5] = uint256(uint64(values[i / 4].intVal >> ((i % 4) * 64)));\\n        }\\n\\n        data = Precompiles.keccakF(data);\\n\\n        Value.Data[] memory outValues = new Value.Data[](7);\\n        for (uint256 i = 0; i < 7; i++) {\\n            outValues[i] = Value.newInt(0);\\n        }\\n\\n        for (uint256 i = 0; i < 25; i++) {\\n            outValues[i / 4].intVal |= data[5 * (i % 5) + i / 5] << ((i % 4) * 64);\\n        }\\n\\n        pushVal(context.stack, Value.newTuple(outValues));\\n    }\\n\\n    function executeSha256FInsn(AssertionContext memory context) internal pure {\\n        Value.Data memory val1 = popVal(context.stack);\\n        Value.Data memory val2 = popVal(context.stack);\\n        Value.Data memory val3 = popVal(context.stack);\\n        if (!val1.isInt() || !val2.isInt() || !val3.isInt()) {\\n            handleOpcodeError(context);\\n            return;\\n        }\\n        uint256 a = val1.intVal;\\n        uint256 b = val2.intVal;\\n        uint256 c = val3.intVal;\\n\\n        pushVal(context.stack, Value.newInt(Precompiles.sha256Block([b, c], a)));\\n    }\\n\\n    function opInfo(uint256 opCode)\\n        internal\\n        pure\\n        override\\n        returns (\\n            uint256, // stack pops\\n            uint256, // auxstack pops\\n            uint64, // gas used\\n            function(AssertionContext memory) internal view // impl\\n        )\\n    {\\n        if (opCode == OP_HASH) {\\n            return (1, 0, 7, executeHashInsn);\\n        } else if (opCode == OP_TYPE) {\\n            return (1, 0, 3, executeTypeInsn);\\n        } else if (opCode == OP_ETHHASH2) {\\n            return (2, 0, 8, executeEthHash2Insn);\\n        } else if (opCode == OP_KECCAK_F) {\\n            return (1, 0, 600, executeKeccakFInsn);\\n        } else if (opCode == OP_SHA256_F) {\\n            return (3, 0, 250, executeSha256FInsn);\\n        } else {\\n            revert(\\\"use another contract to handle other opcodes\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/arch/Value.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2019-2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nlibrary Value {\\n    uint8 internal constant INT_TYPECODE = 0;\\n    uint8 internal constant CODE_POINT_TYPECODE = 1;\\n    uint8 internal constant HASH_PRE_IMAGE_TYPECODE = 2;\\n    uint8 internal constant TUPLE_TYPECODE = 3;\\n    uint8 internal constant BUFFER_TYPECODE = TUPLE_TYPECODE + 9;\\n    // All values received from clients will have type codes less than the VALUE_TYPE_COUNT\\n    uint8 internal constant VALUE_TYPE_COUNT = TUPLE_TYPECODE + 10;\\n\\n    // The following types do not show up in the marshalled format and is\\n    // only used for internal tracking purposes\\n    uint8 internal constant HASH_ONLY = 100;\\n\\n    struct CodePoint {\\n        uint8 opcode;\\n        bytes32 nextCodePoint;\\n        Data[] immediate;\\n    }\\n\\n    struct Data {\\n        uint256 intVal;\\n        CodePoint cpVal;\\n        Data[] tupleVal;\\n        bytes32 bufferHash;\\n        uint8 typeCode;\\n        uint256 size;\\n    }\\n\\n    function tupleTypeCode() internal pure returns (uint8) {\\n        return TUPLE_TYPECODE;\\n    }\\n\\n    function tuplePreImageTypeCode() internal pure returns (uint8) {\\n        return HASH_PRE_IMAGE_TYPECODE;\\n    }\\n\\n    function intTypeCode() internal pure returns (uint8) {\\n        return INT_TYPECODE;\\n    }\\n\\n    function bufferTypeCode() internal pure returns (uint8) {\\n        return BUFFER_TYPECODE;\\n    }\\n\\n    function codePointTypeCode() internal pure returns (uint8) {\\n        return CODE_POINT_TYPECODE;\\n    }\\n\\n    function valueTypeCode() internal pure returns (uint8) {\\n        return VALUE_TYPE_COUNT;\\n    }\\n\\n    function hashOnlyTypeCode() internal pure returns (uint8) {\\n        return HASH_ONLY;\\n    }\\n\\n    function isValidTupleSize(uint256 size) internal pure returns (bool) {\\n        return size <= 8;\\n    }\\n\\n    function typeCodeVal(Data memory val) internal pure returns (Data memory) {\\n        if (val.typeCode == 2) {\\n            // Map HashPreImage to Tuple\\n            return newInt(TUPLE_TYPECODE);\\n        }\\n        return newInt(val.typeCode);\\n    }\\n\\n    function valLength(Data memory val) internal pure returns (uint8) {\\n        if (val.typeCode == TUPLE_TYPECODE) {\\n            return uint8(val.tupleVal.length);\\n        } else {\\n            return 1;\\n        }\\n    }\\n\\n    function isInt(Data memory val) internal pure returns (bool) {\\n        return val.typeCode == INT_TYPECODE;\\n    }\\n\\n    function isInt64(Data memory val) internal pure returns (bool) {\\n        return val.typeCode == INT_TYPECODE && val.intVal < (1 << 64);\\n    }\\n\\n    function isCodePoint(Data memory val) internal pure returns (bool) {\\n        return val.typeCode == CODE_POINT_TYPECODE;\\n    }\\n\\n    function isTuple(Data memory val) internal pure returns (bool) {\\n        return val.typeCode == TUPLE_TYPECODE;\\n    }\\n\\n    function isBuffer(Data memory val) internal pure returns (bool) {\\n        return val.typeCode == BUFFER_TYPECODE;\\n    }\\n\\n    function newEmptyTuple() internal pure returns (Data memory) {\\n        return newTuple(new Data[](0));\\n    }\\n\\n    function newBoolean(bool val) internal pure returns (Data memory) {\\n        if (val) {\\n            return newInt(1);\\n        } else {\\n            return newInt(0);\\n        }\\n    }\\n\\n    function newInt(uint256 _val) internal pure returns (Data memory) {\\n        return\\n            Data(_val, CodePoint(0, 0, new Data[](0)), new Data[](0), 0, INT_TYPECODE, uint256(1));\\n    }\\n\\n    function newHashedValue(bytes32 valueHash, uint256 valueSize)\\n        internal\\n        pure\\n        returns (Data memory)\\n    {\\n        return\\n            Data(\\n                uint256(valueHash),\\n                CodePoint(0, 0, new Data[](0)),\\n                new Data[](0),\\n                0,\\n                HASH_ONLY,\\n                valueSize\\n            );\\n    }\\n\\n    function newTuple(Data[] memory _val) internal pure returns (Data memory) {\\n        require(isValidTupleSize(_val.length), \\\"Tuple must have valid size\\\");\\n        uint256 size = 1;\\n\\n        for (uint256 i = 0; i < _val.length; i++) {\\n            size += _val[i].size;\\n        }\\n\\n        return Data(0, CodePoint(0, 0, new Data[](0)), _val, 0, TUPLE_TYPECODE, size);\\n    }\\n\\n    function newTuplePreImage(bytes32 preImageHash, uint256 size)\\n        internal\\n        pure\\n        returns (Data memory)\\n    {\\n        return\\n            Data(\\n                uint256(preImageHash),\\n                CodePoint(0, 0, new Data[](0)),\\n                new Data[](0),\\n                0,\\n                HASH_PRE_IMAGE_TYPECODE,\\n                size\\n            );\\n    }\\n\\n    function newCodePoint(uint8 opCode, bytes32 nextHash) internal pure returns (Data memory) {\\n        return newCodePoint(CodePoint(opCode, nextHash, new Data[](0)));\\n    }\\n\\n    function newCodePoint(\\n        uint8 opCode,\\n        bytes32 nextHash,\\n        Data memory immediate\\n    ) internal pure returns (Data memory) {\\n        Data[] memory imm = new Data[](1);\\n        imm[0] = immediate;\\n        return newCodePoint(CodePoint(opCode, nextHash, imm));\\n    }\\n\\n    function newCodePoint(CodePoint memory _val) private pure returns (Data memory) {\\n        return Data(0, _val, new Data[](0), 0, CODE_POINT_TYPECODE, uint256(1));\\n    }\\n\\n    function newBuffer(bytes32 bufHash) internal pure returns (Data memory) {\\n        return\\n            Data(\\n                uint256(0),\\n                CodePoint(0, 0, new Data[](0)),\\n                new Data[](0),\\n                bufHash,\\n                BUFFER_TYPECODE,\\n                uint256(1)\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/bridge/interfaces/IBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\ninterface IBridge {\\n    event MessageDelivered(\\n        uint256 indexed messageIndex,\\n        bytes32 indexed beforeInboxAcc,\\n        address inbox,\\n        uint8 kind,\\n        address sender,\\n        bytes32 messageDataHash\\n    );\\n\\n    function deliverMessageToInbox(\\n        uint8 kind,\\n        address sender,\\n        bytes32 messageDataHash\\n    ) external payable returns (uint256);\\n\\n    function executeCall(\\n        address destAddr,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bool success, bytes memory returnData);\\n\\n    // These are only callable by the admin\\n    function setInbox(address inbox, bool enabled) external;\\n\\n    function setOutbox(address inbox, bool enabled) external;\\n\\n    // View functions\\n\\n    function activeOutbox() external view returns (address);\\n\\n    function allowedInboxes(address inbox) external view returns (bool);\\n\\n    function allowedOutboxes(address outbox) external view returns (bool);\\n\\n    function inboxAccs(uint256 index) external view returns (bytes32);\\n\\n    function messageCount() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/bridge/interfaces/ISequencerInbox.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\ninterface ISequencerInbox {\\n    event SequencerBatchDelivered(\\n        uint256 indexed firstMessageNum,\\n        bytes32 indexed beforeAcc,\\n        uint256 newMessageCount,\\n        bytes32 afterAcc,\\n        bytes transactions,\\n        uint256[] lengths,\\n        uint256[] sectionsMetadata,\\n        uint256 seqBatchIndex,\\n        address sequencer\\n    );\\n\\n    event SequencerBatchDeliveredFromOrigin(\\n        uint256 indexed firstMessageNum,\\n        bytes32 indexed beforeAcc,\\n        uint256 newMessageCount,\\n        bytes32 afterAcc,\\n        uint256 seqBatchIndex\\n    );\\n\\n    event DelayedInboxForced(\\n        uint256 indexed firstMessageNum,\\n        bytes32 indexed beforeAcc,\\n        uint256 newMessageCount,\\n        uint256 totalDelayedMessagesRead,\\n        bytes32[2] afterAccAndDelayed,\\n        uint256 seqBatchIndex\\n    );\\n\\n    event SequencerAddressUpdated(address newAddress);\\n\\n    function setSequencer(address newSequencer) external;\\n\\n    function messageCount() external view returns (uint256);\\n\\n    function maxDelayBlocks() external view returns (uint256);\\n\\n    function maxDelaySeconds() external view returns (uint256);\\n\\n    function inboxAccs(uint256 index) external view returns (bytes32);\\n\\n    function proveBatchContainsSequenceNumber(bytes calldata proof, uint256 inboxCount)\\n        external\\n        view\\n        returns (uint256, bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/BytesLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n/*\\n * @title Solidity Bytes Arrays Utils\\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\\n *\\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\\n */\\n\\npragma solidity ^0.6.11;\\n\\n/* solhint-disable no-inline-assembly */\\nlibrary BytesLib {\\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\n        require(_bytes.length >= (_start + 20), \\\"Read out of bounds\\\");\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\\n        require(_bytes.length >= (_start + 1), \\\"Read out of bounds\\\");\\n        uint8 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\\n        require(_bytes.length >= (_start + 32), \\\"Read out of bounds\\\");\\n        uint256 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\\n        require(_bytes.length >= (_start + 32), \\\"Read out of bounds\\\");\\n        bytes32 tempBytes32;\\n\\n        assembly {\\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempBytes32;\\n    }\\n}\\n/* solhint-enable no-inline-assembly */\\n\"\r\n    },\r\n    \"contracts/libraries/DebugPrint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2019, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nlibrary DebugPrint {\\n    function char(bytes1 b) private pure returns (bytes1 c) {\\n        if (uint8(b) < 10) {\\n            return bytes1(uint8(b) + 0x30);\\n        } else {\\n            return bytes1(uint8(b) + 0x57);\\n        }\\n    }\\n\\n    function bytes32string(bytes32 b32) internal pure returns (string memory out) {\\n        bytes memory s = new bytes(64);\\n\\n        for (uint256 i = 0; i < 32; i++) {\\n            bytes1 b = bytes1(b32[i]);\\n            bytes1 hi = bytes1(uint8(b) / 16);\\n            bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\\n            s[i * 2] = char(hi);\\n            s[i * 2 + 1] = char(lo);\\n        }\\n\\n        out = string(s);\\n    }\\n\\n    // Taken from https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.5.sol\\n    function uint2str(uint256 _iParam) internal pure returns (string memory _uintAsString) {\\n        uint256 _i = _iParam;\\n        if (_i == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 j = _i;\\n        uint256 len;\\n        while (j != 0) {\\n            len++;\\n            j /= 10;\\n        }\\n        bytes memory bstr = new bytes(len);\\n        uint256 k = len - 1;\\n        while (_i != 0) {\\n            bstr[k--] = bytes1(uint8(48 + (_i % 10)));\\n            _i /= 10;\\n        }\\n        return string(bstr);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Precompiles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2020, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\n///      This algorithm has been extracted from the implementation of smart pool (https://github.com/smartpool)\\nlibrary Precompiles {\\n    function keccakF(uint256[25] memory a) internal pure returns (uint256[25] memory) {\\n        uint256[5] memory c;\\n        uint256[5] memory d;\\n        //uint D_0; uint D_1; uint D_2; uint D_3; uint D_4;\\n        uint256[25] memory b;\\n\\n        uint256[24] memory rc =\\n            [\\n                uint256(0x0000000000000001),\\n                0x0000000000008082,\\n                0x800000000000808A,\\n                0x8000000080008000,\\n                0x000000000000808B,\\n                0x0000000080000001,\\n                0x8000000080008081,\\n                0x8000000000008009,\\n                0x000000000000008A,\\n                0x0000000000000088,\\n                0x0000000080008009,\\n                0x000000008000000A,\\n                0x000000008000808B,\\n                0x800000000000008B,\\n                0x8000000000008089,\\n                0x8000000000008003,\\n                0x8000000000008002,\\n                0x8000000000000080,\\n                0x000000000000800A,\\n                0x800000008000000A,\\n                0x8000000080008081,\\n                0x8000000000008080,\\n                0x0000000080000001,\\n                0x8000000080008008\\n            ];\\n\\n        for (uint256 i = 0; i < 24; i++) {\\n            /*\\n            for( x = 0 ; x < 5 ; x++ ) {\\n                C[x] = A[5*x]^A[5*x+1]^A[5*x+2]^A[5*x+3]^A[5*x+4];\\n            }*/\\n\\n            c[0] = a[0] ^ a[1] ^ a[2] ^ a[3] ^ a[4];\\n            c[1] = a[5] ^ a[6] ^ a[7] ^ a[8] ^ a[9];\\n            c[2] = a[10] ^ a[11] ^ a[12] ^ a[13] ^ a[14];\\n            c[3] = a[15] ^ a[16] ^ a[17] ^ a[18] ^ a[19];\\n            c[4] = a[20] ^ a[21] ^ a[22] ^ a[23] ^ a[24];\\n\\n            /*\\n            for( x = 0 ; x < 5 ; x++ ) {\\n                D[x] = C[(x+4)%5]^((C[(x+1)%5] * 2)&0xffffffffffffffff | (C[(x+1)%5]/(2**63)));\\n            }*/\\n\\n            d[0] = c[4] ^ (((c[1] * 2) & 0xffffffffffffffff) | (c[1] / (2**63)));\\n            d[1] = c[0] ^ (((c[2] * 2) & 0xffffffffffffffff) | (c[2] / (2**63)));\\n            d[2] = c[1] ^ (((c[3] * 2) & 0xffffffffffffffff) | (c[3] / (2**63)));\\n            d[3] = c[2] ^ (((c[4] * 2) & 0xffffffffffffffff) | (c[4] / (2**63)));\\n            d[4] = c[3] ^ (((c[0] * 2) & 0xffffffffffffffff) | (c[0] / (2**63)));\\n\\n            /*\\n            for( x = 0 ; x < 5 ; x++ ) {\\n                for( y = 0 ; y < 5 ; y++ ) {\\n                    A[5*x+y] = A[5*x+y] ^ D[x];\\n                }\\n            }*/\\n\\n            a[0] = a[0] ^ d[0];\\n            a[1] = a[1] ^ d[0];\\n            a[2] = a[2] ^ d[0];\\n            a[3] = a[3] ^ d[0];\\n            a[4] = a[4] ^ d[0];\\n            a[5] = a[5] ^ d[1];\\n            a[6] = a[6] ^ d[1];\\n            a[7] = a[7] ^ d[1];\\n            a[8] = a[8] ^ d[1];\\n            a[9] = a[9] ^ d[1];\\n            a[10] = a[10] ^ d[2];\\n            a[11] = a[11] ^ d[2];\\n            a[12] = a[12] ^ d[2];\\n            a[13] = a[13] ^ d[2];\\n            a[14] = a[14] ^ d[2];\\n            a[15] = a[15] ^ d[3];\\n            a[16] = a[16] ^ d[3];\\n            a[17] = a[17] ^ d[3];\\n            a[18] = a[18] ^ d[3];\\n            a[19] = a[19] ^ d[3];\\n            a[20] = a[20] ^ d[4];\\n            a[21] = a[21] ^ d[4];\\n            a[22] = a[22] ^ d[4];\\n            a[23] = a[23] ^ d[4];\\n            a[24] = a[24] ^ d[4];\\n\\n            /*Rho and pi steps*/\\n            b[0] = a[0];\\n            b[8] = (((a[1] * (2**36)) & 0xffffffffffffffff) | (a[1] / (2**28)));\\n            b[11] = (((a[2] * (2**3)) & 0xffffffffffffffff) | (a[2] / (2**61)));\\n            b[19] = (((a[3] * (2**41)) & 0xffffffffffffffff) | (a[3] / (2**23)));\\n            b[22] = (((a[4] * (2**18)) & 0xffffffffffffffff) | (a[4] / (2**46)));\\n            b[2] = (((a[5] * (2**1)) & 0xffffffffffffffff) | (a[5] / (2**63)));\\n            b[5] = (((a[6] * (2**44)) & 0xffffffffffffffff) | (a[6] / (2**20)));\\n            b[13] = (((a[7] * (2**10)) & 0xffffffffffffffff) | (a[7] / (2**54)));\\n            b[16] = (((a[8] * (2**45)) & 0xffffffffffffffff) | (a[8] / (2**19)));\\n            b[24] = (((a[9] * (2**2)) & 0xffffffffffffffff) | (a[9] / (2**62)));\\n            b[4] = (((a[10] * (2**62)) & 0xffffffffffffffff) | (a[10] / (2**2)));\\n            b[7] = (((a[11] * (2**6)) & 0xffffffffffffffff) | (a[11] / (2**58)));\\n            b[10] = (((a[12] * (2**43)) & 0xffffffffffffffff) | (a[12] / (2**21)));\\n            b[18] = (((a[13] * (2**15)) & 0xffffffffffffffff) | (a[13] / (2**49)));\\n            b[21] = (((a[14] * (2**61)) & 0xffffffffffffffff) | (a[14] / (2**3)));\\n            b[1] = (((a[15] * (2**28)) & 0xffffffffffffffff) | (a[15] / (2**36)));\\n            b[9] = (((a[16] * (2**55)) & 0xffffffffffffffff) | (a[16] / (2**9)));\\n            b[12] = (((a[17] * (2**25)) & 0xffffffffffffffff) | (a[17] / (2**39)));\\n            b[15] = (((a[18] * (2**21)) & 0xffffffffffffffff) | (a[18] / (2**43)));\\n            b[23] = (((a[19] * (2**56)) & 0xffffffffffffffff) | (a[19] / (2**8)));\\n            b[3] = (((a[20] * (2**27)) & 0xffffffffffffffff) | (a[20] / (2**37)));\\n            b[6] = (((a[21] * (2**20)) & 0xffffffffffffffff) | (a[21] / (2**44)));\\n            b[14] = (((a[22] * (2**39)) & 0xffffffffffffffff) | (a[22] / (2**25)));\\n            b[17] = (((a[23] * (2**8)) & 0xffffffffffffffff) | (a[23] / (2**56)));\\n            b[20] = (((a[24] * (2**14)) & 0xffffffffffffffff) | (a[24] / (2**50)));\\n\\n            /*Xi state*/\\n            /*\\n            for( x = 0 ; x < 5 ; x++ ) {\\n                for( y = 0 ; y < 5 ; y++ ) {\\n                    A[5*x+y] = B[5*x+y]^((~B[5*((x+1)%5)+y]) & B[5*((x+2)%5)+y]);\\n                }\\n            }*/\\n\\n            a[0] = b[0] ^ ((~b[5]) & b[10]);\\n            a[1] = b[1] ^ ((~b[6]) & b[11]);\\n            a[2] = b[2] ^ ((~b[7]) & b[12]);\\n            a[3] = b[3] ^ ((~b[8]) & b[13]);\\n            a[4] = b[4] ^ ((~b[9]) & b[14]);\\n            a[5] = b[5] ^ ((~b[10]) & b[15]);\\n            a[6] = b[6] ^ ((~b[11]) & b[16]);\\n            a[7] = b[7] ^ ((~b[12]) & b[17]);\\n            a[8] = b[8] ^ ((~b[13]) & b[18]);\\n            a[9] = b[9] ^ ((~b[14]) & b[19]);\\n            a[10] = b[10] ^ ((~b[15]) & b[20]);\\n            a[11] = b[11] ^ ((~b[16]) & b[21]);\\n            a[12] = b[12] ^ ((~b[17]) & b[22]);\\n            a[13] = b[13] ^ ((~b[18]) & b[23]);\\n            a[14] = b[14] ^ ((~b[19]) & b[24]);\\n            a[15] = b[15] ^ ((~b[20]) & b[0]);\\n            a[16] = b[16] ^ ((~b[21]) & b[1]);\\n            a[17] = b[17] ^ ((~b[22]) & b[2]);\\n            a[18] = b[18] ^ ((~b[23]) & b[3]);\\n            a[19] = b[19] ^ ((~b[24]) & b[4]);\\n            a[20] = b[20] ^ ((~b[0]) & b[5]);\\n            a[21] = b[21] ^ ((~b[1]) & b[6]);\\n            a[22] = b[22] ^ ((~b[2]) & b[7]);\\n            a[23] = b[23] ^ ((~b[3]) & b[8]);\\n            a[24] = b[24] ^ ((~b[4]) & b[9]);\\n\\n            /*Last step*/\\n            a[0] = a[0] ^ rc[i];\\n        }\\n\\n        return a;\\n    }\\n\\n    function rightRotate(uint32 x, uint32 n) internal pure returns (uint32) {\\n        return ((x) >> (n)) | ((x) << (32 - (n)));\\n    }\\n\\n    function ch(\\n        uint32 e,\\n        uint32 f,\\n        uint32 g\\n    ) internal pure returns (uint32) {\\n        return ((e & f) ^ ((~e) & g));\\n    }\\n\\n    // SHA256 compression function that operates on a 512 bit chunk\\n    // Note that the input must be padded by the caller\\n    // For the initial chunk, the initial values from the SHA256 spec should be passed in as hashState\\n    // For subsequent rounds, hashState is the output from the previous round\\n    function sha256Block(uint256[2] memory inputChunk, uint256 hashState)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint32[64] memory k =\\n            [\\n                0x428a2f98,\\n                0x71374491,\\n                0xb5c0fbcf,\\n                0xe9b5dba5,\\n                0x3956c25b,\\n                0x59f111f1,\\n                0x923f82a4,\\n                0xab1c5ed5,\\n                0xd807aa98,\\n                0x12835b01,\\n                0x243185be,\\n                0x550c7dc3,\\n                0x72be5d74,\\n                0x80deb1fe,\\n                0x9bdc06a7,\\n                0xc19bf174,\\n                0xe49b69c1,\\n                0xefbe4786,\\n                0x0fc19dc6,\\n                0x240ca1cc,\\n                0x2de92c6f,\\n                0x4a7484aa,\\n                0x5cb0a9dc,\\n                0x76f988da,\\n                0x983e5152,\\n                0xa831c66d,\\n                0xb00327c8,\\n                0xbf597fc7,\\n                0xc6e00bf3,\\n                0xd5a79147,\\n                0x06ca6351,\\n                0x14292967,\\n                0x27b70a85,\\n                0x2e1b2138,\\n                0x4d2c6dfc,\\n                0x53380d13,\\n                0x650a7354,\\n                0x766a0abb,\\n                0x81c2c92e,\\n                0x92722c85,\\n                0xa2bfe8a1,\\n                0xa81a664b,\\n                0xc24b8b70,\\n                0xc76c51a3,\\n                0xd192e819,\\n                0xd6990624,\\n                0xf40e3585,\\n                0x106aa070,\\n                0x19a4c116,\\n                0x1e376c08,\\n                0x2748774c,\\n                0x34b0bcb5,\\n                0x391c0cb3,\\n                0x4ed8aa4a,\\n                0x5b9cca4f,\\n                0x682e6ff3,\\n                0x748f82ee,\\n                0x78a5636f,\\n                0x84c87814,\\n                0x8cc70208,\\n                0x90befffa,\\n                0xa4506ceb,\\n                0xbef9a3f7,\\n                0xc67178f2\\n            ];\\n\\n        uint32[64] memory w;\\n        uint32 i;\\n        for (i = 0; i < 8; i++) {\\n            w[i] = uint32(inputChunk[0] >> (224 - (32 * i)));\\n            w[i + 8] = uint32(inputChunk[1] >> (224 - (32 * i)));\\n        }\\n\\n        uint32 s0;\\n        uint32 s1;\\n        for (i = 16; i < 64; i++) {\\n            s0 = rightRotate(w[i - 15], 7) ^ rightRotate(w[i - 15], 18) ^ (w[i - 15] >> 3);\\n\\n            s1 = rightRotate(w[i - 2], 17) ^ rightRotate(w[i - 2], 19) ^ (w[i - 2] >> 10);\\n            w[i] = w[i - 16] + s0 + w[i - 7] + s1;\\n        }\\n\\n        uint32[8] memory state;\\n\\n        for (i = 0; i < 8; i++) {\\n            state[i] = uint32(hashState >> (224 - (32 * i)));\\n        }\\n\\n        uint32 temp1;\\n        uint32 temp2;\\n        uint32 maj;\\n\\n        for (i = 0; i < 64; i++) {\\n            s1 = rightRotate(state[4], 6) ^ rightRotate(state[4], 11) ^ rightRotate(state[4], 25);\\n            temp1 = state[7] + s1 + ch(state[4], state[5], state[6]) + k[i] + w[i];\\n            s0 = rightRotate(state[0], 2) ^ rightRotate(state[0], 13) ^ rightRotate(state[0], 22);\\n\\n            maj = (state[0] & (state[1] ^ state[2])) ^ (state[1] & state[2]);\\n            temp2 = s0 + maj;\\n\\n            state[7] = state[6];\\n            state[6] = state[5];\\n            state[5] = state[4];\\n            state[4] = state[3] + temp1;\\n            state[3] = state[2];\\n            state[2] = state[1];\\n            state[1] = state[0];\\n            state[0] = temp1 + temp2;\\n        }\\n\\n        for (i = 0; i < 8; i++) {\\n            state[i] += uint32(hashState >> (224 - (32 * i)));\\n        }\\n\\n        uint256 result;\\n\\n        for (i = 0; i < 8; i++) {\\n            result |= (uint256(state[i]) << (224 - (32 * i)));\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address[2]\",\"name\":\"bridges\",\"type\":\"address[2]\"},{\"internalType\":\"uint256\",\"name\":\"initialMessagesRead\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[2]\",\"name\":\"accs\",\"type\":\"bytes32[2]\"},{\"internalType\":\"bytes\",\"name\":\"proof\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"bproof\",\"type\":\"bytes\"}],\"name\":\"executeStep\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"gas\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"afterMessagesRead\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[4]\",\"name\":\"fields\",\"type\":\"bytes32[4]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[2]\",\"name\":\"bridges\",\"type\":\"address[2]\"},{\"internalType\":\"uint256\",\"name\":\"initialMessagesRead\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[2]\",\"name\":\"accs\",\"type\":\"bytes32[2]\"},{\"internalType\":\"bytes\",\"name\":\"proof\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"bproof\",\"type\":\"bytes\"}],\"name\":\"executeStepDebug\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"startMachine\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"afterMachine\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"OneStepProofHash","CompilerVersion":"v0.6.11+commit.5ef660b1","OptimizationUsed":"1","Runs":"100","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":""}]}