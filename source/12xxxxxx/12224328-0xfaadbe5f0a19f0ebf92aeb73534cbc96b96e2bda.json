{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/6/forwarder/ERC20ForwarderProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./ERC20ForwarderStorage.sol\\\";\\nimport \\\"../libs/Ownable.sol\\\";\\n\\n/**\\n * @title Proxy\\n * @dev Implements delegation of calls to other contracts, with proper\\n * forwarding of return values and bubbling of failures.\\n * It defines a fallback function that delegates all calls to the address\\n * returned by the abstract _implementation() internal function.\\n */\\n \\nabstract contract Proxy {\\n  /**\\n   * @dev Fallback function.\\n   * Implemented entirely in `_fallback`.\\n   */\\n  fallback() payable external {\\n    _fallback();\\n  }\\n  \\n  /**\\n   * @return The Address of the implementation.\\n   */\\n  function _implementation() internal virtual view returns (address);\\n  \\n   /**\\n   * @dev Delegates execution to an implementation contract.\\n   * This is a low level function that doesn't return to its internal call site.\\n   * It will return to the external caller whatever the implementation returns.\\n   * @param implementation Address to delegate.\\n   */\\n  function _delegate(address implementation) internal {\\n    assembly {\\n      // Copy msg.data. We take full control of memory in this inline assembly\\n      // block because it will not return to Solidity code. We overwrite the\\n      // Solidity scratch pad at memory position 0.\\n      calldatacopy(0, 0, calldatasize())\\n\\n      // Call the implementation.\\n      // out and outsize are 0 because we don't know the size yet.\\n      let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n      // Copy the returned data.\\n      returndatacopy(0, 0, returndatasize())\\n\\n      switch result\\n      // delegatecall returns 0 on error.\\n      case 0 { revert(0, returndatasize()) }\\n      default { return(0, returndatasize()) }\\n    }\\n  }\\n  \\n  \\n  /**\\n   * @dev Function that is run as the first thing in the fallback function.\\n   * Can be redefined in derived contracts to add functionality.\\n   * Redefinitions must call super._willFallback().\\n   */\\n  function _willFallback() virtual internal {\\n  }\\n\\n  /**\\n   * @dev fallback implementation.\\n   * Extracted to enable manual triggering.\\n   */\\n  function _fallback() internal {\\n    _willFallback();\\n    _delegate(_implementation());\\n  }\\n \\n}\\n\\n// File: openzeppelin-solidity/contracts/AddressUtils.sol\\n\\n/**\\n * Utility library of inline functions on addresses\\n */\\nlibrary AddressUtils {\\n\\n  /**\\n   * Returns whether the target address is a contract\\n   * @dev This function will return false if invoked during the constructor of a contract,\\n   * as the code is not actually created until after the constructor finishes.\\n   * @param addr address to check\\n   * @return whether the target address is a contract\\n   */\\n  function isContract(address addr) internal view returns (bool) {\\n    uint256 size;\\n    // XXX Currently there is no better way to check if there is a contract in an address\\n    // than to check the size of the code at that address.\\n    // See https://ethereum.stackexchange.com/a/14016/36603\\n    // for more details about how this works.\\n    // TODO Check this again before the Serenity release, because all addresses will be\\n    // contracts then.\\n    // solium-disable-next-line security/no-inline-assembly\\n    assembly { size := extcodesize(addr) }\\n    return size > 0;\\n  }\\n\\n}\\n\\n\\n/**\\n * @title UpgradeabilityProxy\\n * @dev This contract implements a proxy that allows to change the\\n * implementation address to which it will delegate.\\n * Such a change is called an implementation upgrade.\\n */\\ncontract UpgradeabilityProxy is Proxy {\\n  /**\\n   * @dev Emitted when the implementation is upgraded.\\n   * @param implementation Address of the new implementation.\\n   */\\n  event Upgraded(address implementation);\\n\\n  /**\\n   * @dev Storage slot with the address of the current implementation.\\n   * This is the keccak-256 hash of \\\"io.biconomy.ercfeeproxy.implementation\\\", and is\\n   * validated in the constructor.\\n   */\\n  bytes32 private constant IMPLEMENTATION_SLOT = 0x0b63f4b9f11e5ae2112641c92ed865d24a316fbdf51bbd102721d37df8b1f8e7;\\n\\n  /**\\n   * @dev Contract constructor.\\n   * @param _implementation Address of the initial implementation.\\n   */\\n  constructor(address _implementation) public {\\n    assert(IMPLEMENTATION_SLOT == keccak256(\\\"io.biconomy.ercfeeproxy.implementation\\\"));\\n\\n    _setImplementation(_implementation);\\n  }\\n\\n  /**\\n   * @dev Returns the current implementation.\\n   */\\n  function _implementation() internal override view returns (address impl) {\\n    bytes32 slot = IMPLEMENTATION_SLOT;\\n    assembly {\\n      impl := sload(slot)\\n    }\\n  }\\n\\n  /**\\n   * @dev Upgrades the proxy to a new implementation.\\n   * @param newImplementation Address of the new implementation.\\n   */\\n  function _upgradeTo(address newImplementation) internal {\\n    _setImplementation(newImplementation);\\n    emit Upgraded(newImplementation);\\n  }\\n\\n  /**\\n   * @dev Sets the implementation address of the proxy.\\n   * @param newImplementation Address of the new implementation.\\n   */\\n  function _setImplementation(address newImplementation) private {\\n    require(AddressUtils.isContract(newImplementation), \\\"Cannot set a proxy implementation to a non-contract address\\\");\\n\\n    bytes32 slot = IMPLEMENTATION_SLOT;\\n\\n    assembly {\\n      sstore(slot, newImplementation)\\n    }\\n  }\\n  \\n}\\n\\n\\n// File: zos-lib/contracts/upgradeability/AdminUpgradeabilityProxy.sol\\n\\n/**\\n * @title AdminUpgradeabilityProxy\\n * @dev This contract combines an upgradeability proxy with an authorization\\n * mechanism for administrative tasks.\\n * All external functions in this contract must be guarded by the\\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\\n * feature proposal that would enable this to be done automatically.\\n */\\ncontract AdminUpgradeabilityProxy is UpgradeabilityProxy {\\n  /**\\n   * @dev Emitted when the administration has been transferred.\\n   * @param previousAdmin Address of the previous admin.\\n   * @param newAdmin Address of the new admin.\\n   */\\n  event AdminChanged(address previousAdmin, address newAdmin);\\n\\n  /**\\n   * @dev Storage slot with the admin of the contract.\\n   * This is the keccak-256 hash of \\\"io.biconomy.ercfeeproxy.admin\\\", and is\\n   * validated in the constructor.\\n   */\\n  bytes32 private constant ADMIN_SLOT = 0x71d39ddb6ef9c6ab43d46265ce63a4cf0419f6c2e28ab0aa6a80f50f7d56dd54;\\n\\n  /**\\n   * @dev Modifier to check whether the `msg.sender` is the admin.\\n   * If it is, it will run the function. Otherwise, it will delegate the call\\n   * to the implementation.\\n   */\\n  modifier ifAdmin() {\\n    if (msg.sender == _admin()) {\\n      _;\\n    } else {\\n      _fallback();\\n    }\\n  }\\n\\n  /**\\n   * Contract constructor.\\n   * It sets the `msg.sender` as the proxy administrator.\\n   * @param _implementation address of the initial implementation.\\n   */\\n  constructor(address _implementation, address _admin) UpgradeabilityProxy(_implementation) public {\\n    require(\\n        _admin != address(0),\\n        \\\"admin address cannot be zero\\\"\\n       );\\n    assert(ADMIN_SLOT == keccak256(\\\"io.biconomy.ercfeeproxy.admin\\\"));\\n    _setAdmin(_admin);\\n  }\\n\\n  /**\\n   * @return The address of the proxy admin.\\n   */\\n  function admin() external view returns (address) {\\n    return _admin();\\n  }\\n\\n  /**\\n   * @return The address of the implementation.\\n   */\\n  function implementation() external view returns (address) {\\n    return _implementation();\\n  }\\n\\n  /**\\n   * @dev Changes the admin of the proxy.\\n   * Only the current admin can call this function.\\n   * @param newAdmin Address to transfer proxy administration to.\\n   */\\n  function changeAdmin(address newAdmin) external ifAdmin {\\n    require(newAdmin != address(0), \\\"Cannot change the admin of a proxy to the zero address\\\");\\n    emit AdminChanged(_admin(), newAdmin);\\n    _setAdmin(newAdmin);\\n  }\\n\\n  /**\\n   * @dev Upgrade the backing implementation of the proxy.\\n   * Only the admin can call this function.\\n   * @param newImplementation Address of the new implementation.\\n   */\\n  function upgradeTo(address newImplementation) external ifAdmin {\\n    _upgradeTo(newImplementation);\\n  }\\n\\n  /**\\n   * @dev Upgrade the backing implementation of the proxy and call a function\\n   * on the new implementation.\\n   * This is useful to initialize the proxied contract.\\n   * @param newImplementation Address of the new implementation.\\n   * @param data Data to send as msg.data in the low level call.\\n   * It should include the signature and the parameters of the function to be\\n   * called, as described in\\n   * https://solidity.readthedocs.io/en/develop/abi-spec.html#function-selector-and-argument-encoding.\\n   */\\n  function upgradeToAndCall(address newImplementation, bytes calldata data) payable external ifAdmin {\\n    _upgradeTo(newImplementation);\\n    bool success;\\n    bytes memory ret;\\n    (success,ret) = address(this).call{value : msg.value}(abi.encodePacked(data));\\n    require(success,\\\"call to new implementation did not succeed\\\");\\n  }\\n\\n  /**\\n   * @dev returns The admin slot.\\n   */\\n  function _admin() internal view returns (address adm) {\\n    bytes32 slot = ADMIN_SLOT;\\n    assembly {\\n      adm := sload(slot)\\n    }\\n  }\\n\\n  /**\\n   * @dev Sets the address of the proxy admin.\\n   * @param newAdmin Address of the new proxy admin.\\n   */\\n  function _setAdmin(address newAdmin) internal {\\n    bytes32 slot = ADMIN_SLOT;\\n\\n    assembly {\\n      sstore(slot, newAdmin)\\n    }\\n  }\\n\\n  /**\\n   * @dev Only fall back when the sender is not the admin.\\n   */\\n  function _willFallback() internal override {\\n    require(msg.sender != _admin(), \\\"Cannot call fallback function from the proxy admin\\\");\\n    super._willFallback();\\n  }\\n}\\n\\n/**\\n * @title ERC20ForwarderProxy\\n * @dev This contract proxies ERC20Forwarder calls and enables ERC20Forwarder upgrades\\n*/ \\ncontract ERC20ForwarderProxy is AdminUpgradeabilityProxy, Ownable, ERC20ForwarderStorage  {\\n    constructor(address _implementation, address _admin, address _owner) public AdminUpgradeabilityProxy(_implementation, _admin) Ownable(_owner) {\\n      require(\\n         _owner != address(0),\\n        \\\"_owner cannot be zero\\\"\\n       );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/6/forwarder/ERC20ForwarderStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./ERC20ForwardRequestTypes.sol\\\";\\n\\n/**\\n * @title ERC20 Forward Storage\\n *\\n * @notice A contract for dApps to coordinate meta transactions paid for with ERC20 transfers\\n *\\n * @dev Inherits the ERC20ForwarderRequest struct via the contract of same name - essential for compatibility with The BiconomyForwarder\\n * @dev Contract owner can set the feeManager contract & the feeReceiver address\\n * @dev Tx Flow : call BiconomyForwarder to handle forwarding, call _transferHandler() to charge fee after\\n *\\n */\\n\\ncontract ERC20ForwarderStorage is ERC20ForwardRequestTypes{\\n    mapping(address=>uint256) public transferHandlerGas;\\n    mapping(address=>bool) public safeTransferRequired;\\n    address public feeReceiver;\\n    address public oracleAggregator;\\n    address public feeManager;\\n    address public forwarder;\\n    //transaction base gas\\n    uint128 public baseGas=21000;\\n    /*gas refund given for each burned CHI token. This value is calcuated from 24000*80% (24000 is EVM gas refund for each burned CHI token) - 6150 (Biconomy's gas overhead for burning each CHI token)   */\\n    uint128 public gasRefund=13050; \\n    //gas token forwarder base gas \\n    uint128 public gasTokenForwarderBaseGas = 32330;\\n}\"\r\n    },\r\n    \"contracts/6/libs/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Ownable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n     * account.\\n     */\\n    constructor(address owner) public {\\n        _owner = owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(\\n            isOwner(),\\n            \\\"Only contract owner is allowed to perform this operation\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @return the address of the owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @return true if `msg.sender` is the owner of the contract.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == _owner;\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to relinquish control of the contract.\\n     * @notice Renouncing to ownership will leave the contract without an owner.\\n     * It will not be possible to call the functions with the `onlyOwner`\\n     * modifier anymore.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0));\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/6/forwarder/ERC20ForwardRequestTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\n/* deadline can be removed : GSN reference https://github.com/opengsn/gsn/blob/master/contracts/forwarder/IForwarder.sol (Saves 250 more gas)*/\\n/**\\n* This contract defines a struct which both ERC20FeeProxy and BiconomyForwarder inherit. ERC20ForwardRequest specifies all the fields present in the GSN V2 ForwardRequest struct, \\n* but adds the following :\\n* address token\\n* uint256 tokenGasPrice\\n* uint256 txGas\\n* uint256 batchNonce (can be removed)\\n* uint256 deadline \\n* Fields are placed in type order, to minimise storage used when executing transactions.\\n*/\\ncontract ERC20ForwardRequestTypes{\\n\\n/*allow the EVM to optimize for this, \\nensure that you try to order your storage variables and struct members such that they can be packed tightly*/\\n\\n    struct ERC20ForwardRequest {\\n        address from; \\n        address to; \\n        address token; \\n        uint256 txGas;\\n        uint256 tokenGasPrice;\\n        uint256 batchId; \\n        uint256 batchNonce; \\n        uint256 deadline; \\n        bytes data;\\n    }\\n\\n     struct PermitRequest {\\n        address holder; \\n        address spender;  \\n        uint256 value;\\n        uint256 nonce;\\n        uint256 expiry;\\n        bool allowed; \\n        uint8 v;\\n        bytes32 r; \\n        bytes32 s; \\n    }\\n\\n    \\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_implementation\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseGas\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"forwarder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasRefund\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasTokenForwarderBaseGas\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracleAggregator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"safeTransferRequired\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"transferHandlerGas\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"ERC20ForwarderProxy","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000fc46d3f2d7c005940e86a08725cfe4df2b88448a000000000000000000000000ccb9ba42d45ee6a7e3176b2f865fb53266b6384d0000000000000000000000009aafe3e7e4fe0e15281831f7d2f33effe18fc7d5","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}