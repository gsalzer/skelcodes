{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Vault.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: GPL-3.0-or-later\\\"\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Pausable.sol\\\";\\n\\nimport \\\"./tokens/EIP20NonStandardInterface.sol\\\";\\n\\nimport \\\"./IDerivativeSpecification.sol\\\";\\nimport \\\"./collateralSplits/ICollateralSplit.sol\\\";\\nimport \\\"./tokens/IERC20MintedBurnable.sol\\\";\\nimport \\\"./tokens/ITokenBuilder.sol\\\";\\nimport \\\"./IFeeLogger.sol\\\";\\n\\nimport \\\"./IPausableVault.sol\\\";\\n\\n/// @title Derivative implementation Vault\\n/// @notice A smart contract that references derivative specification and enables users to mint and redeem the derivative\\ncontract Vault is Ownable, Pausable, IPausableVault, ReentrancyGuard {\\n    using SafeMath for uint256;\\n    using SafeMath for uint8;\\n\\n    uint256 public constant FRACTION_MULTIPLIER = 10**12;\\n\\n    enum State { Created, Live, Settled }\\n\\n    event StateChanged(State oldState, State newState);\\n    event LiveStateSet(address primaryToken, address complementToken);\\n    event SettledStateSet(\\n        int256[] underlyingStarts,\\n        int256[] underlyingEnds,\\n        uint256 primaryConversion,\\n        uint256 complementConversion\\n    );\\n    event Minted(address indexed recipient, uint256 minted, uint256 collateral, uint256 fee);\\n    event Refunded(address indexed recipient, uint256 tokenAmount, uint256 collateral);\\n    event Redeemed(\\n        address indexed recipient,\\n        address tokenAddress,\\n        uint256 tokenAmount,\\n        uint256 conversion,\\n        uint256 collateral\\n    );\\n\\n    /// @notice start of live period\\n    uint256 public liveTime;\\n    /// @notice end of live period\\n    uint256 public settleTime;\\n\\n    /// @notice redeem function can only be called after the end of the Live period + delay\\n    uint256 public settlementDelay;\\n\\n    /// @notice underlying value at the start of live period\\n    int256[] public underlyingStarts;\\n    /// @notice underlying value at the end of live period\\n    int256[] public underlyingEnds;\\n\\n    /// @notice primary token conversion rate multiplied by 10 ^ 12\\n    uint256 public primaryConversion;\\n    /// @notice complement token conversion rate multiplied by 10 ^ 12\\n    uint256 public complementConversion;\\n\\n    /// @notice protocol fee multiplied by 10 ^ 12\\n    uint256 public protocolFee;\\n    /// @notice limit on author fee multiplied by 10 ^ 12\\n    uint256 public authorFeeLimit;\\n\\n    // @notice protocol's fee receiving wallet\\n    address public feeWallet;\\n\\n    // @notice current state of the vault\\n    State public state;\\n\\n    // @notice derivative specification address\\n    IDerivativeSpecification public derivativeSpecification;\\n    // @notice collateral token address\\n    IERC20 public collateralToken;\\n    // @notice oracle address\\n    address[] public oracles;\\n    address[] public oracleIterators;\\n    // @notice collateral split address\\n    ICollateralSplit public collateralSplit;\\n    // @notice derivative's token builder strategy address\\n    ITokenBuilder public tokenBuilder;\\n    IFeeLogger public feeLogger;\\n\\n    // @notice primary token address\\n    IERC20MintedBurnable public primaryToken;\\n    // @notice complement token address\\n    IERC20MintedBurnable public complementToken;\\n\\n    constructor(\\n        uint256 _liveTime,\\n        uint256 _protocolFee,\\n        address _feeWallet,\\n        address _derivativeSpecification,\\n        address _collateralToken,\\n        address[] memory _oracles,\\n        address[] memory _oracleIterators,\\n        address _collateralSplit,\\n        address _tokenBuilder,\\n        address _feeLogger,\\n        uint256 _authorFeeLimit,\\n        uint256 _settlementDelay\\n    ) public {\\n        require(_liveTime > 0, \\\"Live zero\\\");\\n        require(_liveTime <= block.timestamp, \\\"Live in future\\\");\\n        liveTime = _liveTime;\\n\\n        protocolFee = _protocolFee;\\n\\n        require(_feeWallet != address(0), \\\"Fee wallet\\\");\\n        feeWallet = _feeWallet;\\n\\n        require(_derivativeSpecification != address(0), \\\"Derivative\\\");\\n        derivativeSpecification = IDerivativeSpecification(\\n            _derivativeSpecification\\n        );\\n\\n        require(_collateralToken != address(0), \\\"Collateral token\\\");\\n        collateralToken = IERC20(_collateralToken);\\n\\n        require(_oracles.length > 0, \\\"Oracles\\\");\\n        require(_oracles[0] != address(0), \\\"First oracle is absent\\\");\\n        oracles = _oracles;\\n\\n        require(_oracleIterators.length > 0, \\\"OracleIterators\\\");\\n        require(\\n            _oracleIterators[0] != address(0),\\n            \\\"First oracle iterator is absent\\\"\\n        );\\n        oracleIterators = _oracleIterators;\\n\\n        require(_collateralSplit != address(0), \\\"Collateral split\\\");\\n        collateralSplit = ICollateralSplit(_collateralSplit);\\n\\n        require(_tokenBuilder != address(0), \\\"Token builder\\\");\\n        tokenBuilder = ITokenBuilder(_tokenBuilder);\\n\\n        require(_feeLogger != address(0), \\\"Fee logger\\\");\\n        feeLogger = IFeeLogger(_feeLogger);\\n\\n        authorFeeLimit = _authorFeeLimit;\\n\\n        settleTime = liveTime + derivativeSpecification.livePeriod();\\n        require(block.timestamp < settleTime, \\\"Settled time\\\");\\n\\n        settlementDelay = _settlementDelay;\\n    }\\n\\n    function pause() external override onlyOwner() {\\n        _pause();\\n    }\\n\\n    function unpause() external override onlyOwner() {\\n        _unpause();\\n    }\\n\\n    /// @notice Initialize vault by creating derivative token and switching to Live state\\n    /// @dev Extracted from constructor to reduce contract gas creation amount\\n    function initialize(int256[] calldata _underlyingStarts) external {\\n        require(state == State.Created, \\\"Incorrect state.\\\");\\n\\n        underlyingStarts = _underlyingStarts;\\n\\n        changeState(State.Live);\\n\\n        (primaryToken, complementToken) = tokenBuilder.buildTokens(\\n            derivativeSpecification,\\n            settleTime,\\n            address(collateralToken)\\n        );\\n\\n        emit LiveStateSet(address(primaryToken), address(complementToken));\\n    }\\n\\n    function changeState(State _newState) internal {\\n        state = _newState;\\n        emit StateChanged(state, _newState);\\n    }\\n\\n    /// @notice Switch to Settled state if appropriate time threshold is passed and\\n    /// set underlyingStarts value and set underlyingEnds value,\\n    /// calculate primaryConversion and complementConversion params\\n    /// @dev Reverts if underlyingEnds are not available\\n    /// Vault cannot settle when it paused\\n    function settle(uint256[] calldata _underlyingEndRoundHints)\\n        public\\n        whenNotPaused()\\n    {\\n        require(state == State.Live, \\\"Incorrect state\\\");\\n        require(\\n            block.timestamp >= (settleTime + settlementDelay),\\n            \\\"Incorrect time\\\"\\n        );\\n        changeState(State.Settled);\\n\\n        uint256 split;\\n        (split, underlyingEnds) = collateralSplit.split(\\n            oracles,\\n            oracleIterators,\\n            underlyingStarts,\\n            settleTime,\\n            _underlyingEndRoundHints\\n        );\\n        split = range(split);\\n\\n        uint256 collectedCollateral = collateralToken.balanceOf(address(this));\\n        uint256 mintedPrimaryTokenAmount = primaryToken.totalSupply();\\n\\n        if (mintedPrimaryTokenAmount > 0) {\\n            uint256 primaryCollateralPortion = collectedCollateral.mul(split);\\n            primaryConversion = primaryCollateralPortion.div(\\n                mintedPrimaryTokenAmount\\n            );\\n            complementConversion = collectedCollateral\\n                .mul(FRACTION_MULTIPLIER)\\n                .sub(primaryCollateralPortion)\\n                .div(mintedPrimaryTokenAmount);\\n        }\\n\\n        emit SettledStateSet(\\n            underlyingStarts,\\n            underlyingEnds,\\n            primaryConversion,\\n            complementConversion\\n        );\\n    }\\n\\n    function range(uint256 _split) public pure returns (uint256) {\\n        if (_split > FRACTION_MULTIPLIER) {\\n            return FRACTION_MULTIPLIER;\\n        }\\n        return _split;\\n    }\\n\\n    function performMint(address _recipient, uint256 _collateralAmount)\\n        internal\\n    {\\n        require(state == State.Live, \\\"Live is over\\\");\\n\\n        require(_collateralAmount > 0, \\\"Zero amount\\\");\\n        _collateralAmount = doTransferIn(msg.sender, _collateralAmount);\\n\\n        uint256 feeAmount = withdrawFee(_collateralAmount);\\n\\n        uint256 netAmount = _collateralAmount.sub(feeAmount);\\n\\n        uint256 tokenAmount = denominate(netAmount);\\n\\n        primaryToken.mint(_recipient, tokenAmount);\\n        complementToken.mint(_recipient, tokenAmount);\\n\\n        emit Minted(_recipient, tokenAmount, _collateralAmount, feeAmount);\\n    }\\n\\n    function mintTo(address _recipient, uint256 _collateralAmount)\\n        external\\n        nonReentrant()\\n    {\\n        performMint(_recipient, _collateralAmount);\\n    }\\n\\n    /// @notice Mints primary and complement derivative tokens\\n    /// @dev Checks and switches to the right state and does nothing if vault is not in Live state\\n    function mint(uint256 _collateralAmount) external nonReentrant() {\\n        performMint(msg.sender, _collateralAmount);\\n    }\\n\\n    function performRefund(address _recipient, uint256 _tokenAmount) internal {\\n        require(_tokenAmount > 0, \\\"Zero amount\\\");\\n        require(\\n            _tokenAmount <= primaryToken.balanceOf(msg.sender),\\n            \\\"Insufficient primary amount\\\"\\n        );\\n        require(\\n            _tokenAmount <= complementToken.balanceOf(msg.sender),\\n            \\\"Insufficient complement amount\\\"\\n        );\\n\\n        primaryToken.burnFrom(msg.sender, _tokenAmount);\\n        complementToken.burnFrom(msg.sender, _tokenAmount);\\n        uint256 unDenominated = unDenominate(_tokenAmount);\\n\\n        emit Refunded(_recipient, _tokenAmount, unDenominated);\\n        doTransferOut(_recipient, unDenominated);\\n    }\\n\\n    /// @notice Refund equal amounts of derivative tokens for collateral at any time\\n    function refund(uint256 _tokenAmount) external nonReentrant() {\\n        performRefund(msg.sender, _tokenAmount);\\n    }\\n\\n    function refundTo(address _recipient, uint256 _tokenAmount)\\n        external\\n        nonReentrant()\\n    {\\n        performRefund(_recipient, _tokenAmount);\\n    }\\n\\n    function performRedeem(\\n        address _recipient,\\n        uint256 _primaryTokenAmount,\\n        uint256 _complementTokenAmount,\\n        uint256[] calldata _underlyingEndRoundHints\\n    ) internal {\\n        require(\\n            _primaryTokenAmount > 0 || _complementTokenAmount > 0,\\n            \\\"Both tokens zero amount\\\"\\n        );\\n        require(\\n            _primaryTokenAmount <= primaryToken.balanceOf(msg.sender),\\n            \\\"Insufficient primary amount\\\"\\n        );\\n        require(\\n            _complementTokenAmount <= complementToken.balanceOf(msg.sender),\\n            \\\"Insufficient complement amount\\\"\\n        );\\n\\n        if (\\n            block.timestamp >= (settleTime + settlementDelay) &&\\n            state == State.Live\\n        ) {\\n            settle(_underlyingEndRoundHints);\\n        }\\n\\n        if (state == State.Settled) {\\n            uint collateral = redeemAsymmetric(\\n                _recipient,\\n                primaryToken,\\n                _primaryTokenAmount,\\n                primaryConversion\\n            );\\n            collateral = redeemAsymmetric(\\n                _recipient,\\n                complementToken,\\n                _complementTokenAmount,\\n                complementConversion\\n            ).add(collateral);\\n\\n            if (collateral > 0) {\\n                doTransferOut(_recipient, collateral);\\n            }\\n        }\\n    }\\n\\n    function redeemTo(\\n        address _recipient,\\n        uint256 _primaryTokenAmount,\\n        uint256 _complementTokenAmount,\\n        uint256[] calldata _underlyingEndRoundHints\\n    ) external nonReentrant() {\\n        performRedeem(\\n            _recipient,\\n            _primaryTokenAmount,\\n            _complementTokenAmount,\\n            _underlyingEndRoundHints\\n        );\\n    }\\n\\n    /// @notice Redeems unequal amounts previously calculated conversions if the vault is in Settled state\\n    function redeem(\\n        uint256 _primaryTokenAmount,\\n        uint256 _complementTokenAmount,\\n        uint256[] calldata _underlyingEndRoundHints\\n    ) external nonReentrant() {\\n        performRedeem(\\n            msg.sender,\\n            _primaryTokenAmount,\\n            _complementTokenAmount,\\n            _underlyingEndRoundHints\\n        );\\n    }\\n\\n    function redeemAsymmetric(\\n        address _recipient,\\n        IERC20MintedBurnable _derivativeToken,\\n        uint256 _amount,\\n        uint256 _conversion\\n    ) internal returns(uint256 collateral){\\n        if (_amount == 0) {\\n            return 0;\\n        }\\n\\n        _derivativeToken.burnFrom(msg.sender, _amount);\\n        collateral = _amount.mul(_conversion) / FRACTION_MULTIPLIER;\\n        emit Redeemed(_recipient, address(_derivativeToken),_amount, _conversion, collateral);\\n    }\\n\\n    function denominate(uint256 _collateralAmount)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return\\n            _collateralAmount.div(\\n                derivativeSpecification.primaryNominalValue() +\\n                    derivativeSpecification.complementNominalValue()\\n            );\\n    }\\n\\n    function unDenominate(uint256 _tokenAmount)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return\\n            _tokenAmount.mul(\\n                derivativeSpecification.primaryNominalValue() +\\n                    derivativeSpecification.complementNominalValue()\\n            );\\n    }\\n\\n    function withdrawFee(uint256 _amount) internal returns (uint256) {\\n        uint256 protocolFeeAmount =\\n            calcAndTransferFee(_amount, payable(feeWallet), protocolFee);\\n\\n        feeLogger.log(\\n            msg.sender,\\n            address(collateralToken),\\n            protocolFeeAmount,\\n            derivativeSpecification.author()\\n        );\\n\\n        uint256 authorFee = derivativeSpecification.authorFee();\\n        if (authorFee > authorFeeLimit) {\\n            authorFee = authorFeeLimit;\\n        }\\n        uint256 authorFeeAmount =\\n            calcAndTransferFee(\\n                _amount,\\n                payable(derivativeSpecification.author()),\\n                authorFee\\n            );\\n\\n        return protocolFeeAmount.add(authorFeeAmount);\\n    }\\n\\n    function calcAndTransferFee(\\n        uint256 _amount,\\n        address payable _beneficiary,\\n        uint256 _fee\\n    ) internal returns (uint256 _feeAmount) {\\n        _feeAmount = _amount.mul(_fee).div(FRACTION_MULTIPLIER);\\n        if (_feeAmount > 0) {\\n            doTransferOut(_beneficiary, _feeAmount);\\n        }\\n    }\\n\\n    /// @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\\n    /// This will revert due to insufficient balance or insufficient allowance.\\n    /// This function returns the actual amount received,\\n    /// which may be less than `amount` if there is a fee attached to the transfer.\\n    /// @notice This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\\n    /// See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\\n    function doTransferIn(address from, uint256 amount)\\n        internal\\n        returns (uint256)\\n    {\\n        uint256 balanceBefore = collateralToken.balanceOf(address(this));\\n        EIP20NonStandardInterface(address(collateralToken)).transferFrom(\\n            from,\\n            address(this),\\n            amount\\n        );\\n\\n        bool success;\\n        assembly {\\n            switch returndatasize()\\n                case 0 {\\n                    // This is a non-standard ERC-20\\n                    success := not(0) // set success to true\\n                }\\n                case 32 {\\n                    // This is a compliant ERC-20\\n                    returndatacopy(0, 0, 32)\\n                    success := mload(0) // Set `success = returndata` of external call\\n                }\\n                default {\\n                    // This is an excessively non-compliant ERC-20, revert.\\n                    revert(0, 0)\\n                }\\n        }\\n        require(success, \\\"TOKEN_TRANSFER_IN_FAILED\\\");\\n\\n        // Calculate the amount that was *actually* transferred\\n        uint256 balanceAfter = collateralToken.balanceOf(address(this));\\n        require(balanceAfter >= balanceBefore, \\\"TOKEN_TRANSFER_IN_OVERFLOW\\\");\\n        return balanceAfter - balanceBefore; // underflow already checked above, just subtract\\n    }\\n\\n    /// @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\\n    /// error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\\n    /// insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\\n    /// it is >= amount, this should not revert in normal conditions.\\n    /// @notice This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\\n    /// See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\\n    function doTransferOut(address to, uint256 amount) internal {\\n        EIP20NonStandardInterface(address(collateralToken)).transfer(\\n            to,\\n            amount\\n        );\\n\\n        bool success;\\n        assembly {\\n            switch returndatasize()\\n                case 0 {\\n                    // This is a non-standard ERC-20\\n                    success := not(0) // set success to true\\n                }\\n                case 32 {\\n                    // This is a complaint ERC-20\\n                    returndatacopy(0, 0, 32)\\n                    success := mload(0) // Set `success = returndata` of external call\\n                }\\n                default {\\n                    // This is an excessively non-compliant ERC-20, revert.\\n                    revert(0, 0)\\n                }\\n        }\\n        require(success, \\\"TOKEN_TRANSFER_OUT_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () internal {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor () internal {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/EIP20NonStandardInterface.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: GPL-3.0-or-later\\\"\\n\\npragma solidity 0.7.6;\\n\\n/// @title EIP20NonStandardInterface\\n/// @dev Version of ERC20 with no return values for `transfer` and `transferFrom`\\n/// See https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\\ninterface EIP20NonStandardInterface {\\n    /// @notice Get the total number of tokens in circulation\\n    /// @return The supply of tokens\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice Gets the balance of the specified address\\n    /// @param owner The address from which the balance will be retrieved\\n    /// @return balance The balance\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    //\\n    // !!!!!!!!!!!!!!\\n    // !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\\n    // !!!!!!!!!!!!!!\\n    //\\n\\n    /// @notice Transfer `amount` tokens from `msg.sender` to `dst`\\n    /// @param dst The address of the destination account\\n    /// @param amount The number of tokens to transfer\\n    function transfer(address dst, uint256 amount) external;\\n\\n    //\\n    // !!!!!!!!!!!!!!\\n    // !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\\n    // !!!!!!!!!!!!!!\\n    //\\n\\n    /// @notice Transfer `amount` tokens from `src` to `dst`\\n    /// @param src The address of the source account\\n    /// @param dst The address of the destination account\\n    /// @param amount The number of tokens to transfer\\n    function transferFrom(\\n        address src,\\n        address dst,\\n        uint256 amount\\n    ) external;\\n\\n    /// @notice Approve `spender` to transfer up to `amount` from `src`\\n    /// @dev This will overwrite the approval amount for `spender`\\n    ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\n    /// @param spender The address of the account which may transfer tokens\\n    /// @param amount The number of tokens that are approved\\n    /// @return success Whether or not the approval succeeded\\n    function approve(address spender, uint256 amount)\\n        external\\n        returns (bool success);\\n\\n    /// @notice Get the current allowance from `owner` for `spender`\\n    /// @param owner The address of the account which owns the tokens to be spent\\n    /// @param spender The address of the account which may transfer tokens\\n    /// @return remaining The number of tokens allowed to be spent\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256 remaining);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 amount\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/IDerivativeSpecification.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: GPL-3.0-or-later\\\"\\n\\npragma solidity 0.7.6;\\n\\n/// @title Derivative Specification interface\\n/// @notice Immutable collection of derivative attributes\\n/// @dev Created by the derivative's author and published to the DerivativeSpecificationRegistry\\ninterface IDerivativeSpecification {\\n    /// @notice Proof of a derivative specification\\n    /// @dev Verifies that contract is a derivative specification\\n    /// @return true if contract is a derivative specification\\n    function isDerivativeSpecification() external pure returns (bool);\\n\\n    /// @notice Set of oracles that are relied upon to measure changes in the state of the world\\n    /// between the start and the end of the Live period\\n    /// @dev Should be resolved through OracleRegistry contract\\n    /// @return oracle symbols\\n    function oracleSymbols() external view returns (bytes32[] memory);\\n\\n    /// @notice Algorithm that, for the type of oracle used by the derivative,\\n    /// finds the value closest to a given timestamp\\n    /// @dev Should be resolved through OracleIteratorRegistry contract\\n    /// @return oracle iterator symbols\\n    function oracleIteratorSymbols() external view returns (bytes32[] memory);\\n\\n    /// @notice Type of collateral that users submit to mint the derivative\\n    /// @dev Should be resolved through CollateralTokenRegistry contract\\n    /// @return collateral token symbol\\n    function collateralTokenSymbol() external view returns (bytes32);\\n\\n    /// @notice Mapping from the change in the underlying variable (as defined by the oracle)\\n    /// and the initial collateral split to the final collateral split\\n    /// @dev Should be resolved through CollateralSplitRegistry contract\\n    /// @return collateral split symbol\\n    function collateralSplitSymbol() external view returns (bytes32);\\n\\n    /// @notice Lifecycle parameter that define the length of the derivative's Live period.\\n    /// @dev Set in seconds\\n    /// @return live period value\\n    function livePeriod() external view returns (uint256);\\n\\n    /// @notice Parameter that determines starting nominal value of primary asset\\n    /// @dev Units of collateral theoretically swappable for 1 unit of primary asset\\n    /// @return primary nominal value\\n    function primaryNominalValue() external view returns (uint256);\\n\\n    /// @notice Parameter that determines starting nominal value of complement asset\\n    /// @dev Units of collateral theoretically swappable for 1 unit of complement asset\\n    /// @return complement nominal value\\n    function complementNominalValue() external view returns (uint256);\\n\\n    /// @notice Minting fee rate due to the author of the derivative specification.\\n    /// @dev Percentage fee multiplied by 10 ^ 12\\n    /// @return author fee\\n    function authorFee() external view returns (uint256);\\n\\n    /// @notice Symbol of the derivative\\n    /// @dev Should be resolved through DerivativeSpecificationRegistry contract\\n    /// @return derivative specification symbol\\n    function symbol() external view returns (string memory);\\n\\n    /// @notice Return optional long name of the derivative\\n    /// @dev Isn't used directly in the protocol\\n    /// @return long name\\n    function name() external view returns (string memory);\\n\\n    /// @notice Optional URI to the derivative specs\\n    /// @dev Isn't used directly in the protocol\\n    /// @return URI to the derivative specs\\n    function baseURI() external view returns (string memory);\\n\\n    /// @notice Derivative spec author\\n    /// @dev Used to set and receive author's fee\\n    /// @return address of the author\\n    function author() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/collateralSplits/ICollateralSplit.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: GPL-3.0-or-later\\\"\\n\\npragma solidity 0.7.6;\\n\\n/// @title Collateral Split interface\\n/// @notice Contains mathematical functions used to calculate relative claim\\n/// on collateral of primary and complement assets after settlement.\\n/// @dev Created independently from specification and published to the CollateralSplitRegistry\\ninterface ICollateralSplit {\\n    /// @notice Proof of collateral split contract\\n    /// @dev Verifies that contract is a collateral split contract\\n    /// @return true if contract is a collateral split contract\\n    function isCollateralSplit() external pure returns (bool);\\n\\n    /// @notice Symbol of the collateral split\\n    /// @dev Should be resolved through CollateralSplitRegistry contract\\n    /// @return collateral split specification symbol\\n    function symbol() external pure returns (string memory);\\n\\n    /// @notice Calcs primary asset class' share of collateral at settlement.\\n    /// @dev Returns ranged value between 0 and 1 multiplied by 10 ^ 12\\n    /// @param _underlyingStarts underlying values in the start of Live period\\n    /// @param _underlyingEndRoundHints specify for each oracle round of the end of Live period\\n    /// @return _split primary asset class' share of collateral at settlement\\n    /// @return _underlyingEnds underlying values in the end of Live period\\n    function split(\\n        address[] calldata _oracles,\\n        address[] calldata _oracleIterators,\\n        int256[] calldata _underlyingStarts,\\n        uint256 _settleTime,\\n        uint256[] calldata _underlyingEndRoundHints\\n    ) external view returns (uint256 _split, int256[] memory _underlyingEnds);\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/IERC20MintedBurnable.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: GPL-3.0-or-later\\\"\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IERC20MintedBurnable is IERC20 {\\n    function mint(address to, uint256 amount) external;\\n\\n    function burn(uint256 amount) external;\\n\\n    function burnFrom(address account, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/ITokenBuilder.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: GPL-3.0-or-later\\\"\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"./IERC20MintedBurnable.sol\\\";\\nimport \\\"../IDerivativeSpecification.sol\\\";\\n\\ninterface ITokenBuilder {\\n    function isTokenBuilder() external pure returns (bool);\\n\\n    function buildTokens(\\n        IDerivativeSpecification derivative,\\n        uint256 settlement,\\n        address _collateralToken\\n    ) external returns (IERC20MintedBurnable, IERC20MintedBurnable);\\n}\\n\"\r\n    },\r\n    \"contracts/IFeeLogger.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: GPL-3.0-or-later\\\"\\n\\npragma solidity 0.7.6;\\n\\ninterface IFeeLogger {\\n    function log(\\n        address _liquidityProvider,\\n        address _collateral,\\n        uint256 _protocolFee,\\n        address _author\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/IPausableVault.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: GPL-3.0-or-later\\\"\\n\\npragma solidity 0.7.6;\\n\\ninterface IPausableVault {\\n    function pause() external;\\n\\n    function unpause() external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liveTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_protocolFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_feeWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_derivativeSpecification\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collateralToken\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_oracles\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_oracleIterators\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_collateralSplit\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenBuilder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feeLogger\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_authorFeeLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_settlementDelay\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"primaryToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"complementToken\",\"type\":\"address\"}],\"name\":\"LiveStateSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minted\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"Minted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"conversion\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"}],\"name\":\"Redeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"}],\"name\":\"Refunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"int256[]\",\"name\":\"underlyingStarts\",\"type\":\"int256[]\"},{\"indexed\":false,\"internalType\":\"int256[]\",\"name\":\"underlyingEnds\",\"type\":\"int256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"primaryConversion\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"complementConversion\",\"type\":\"uint256\"}],\"name\":\"SettledStateSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum Vault.State\",\"name\":\"oldState\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"enum Vault.State\",\"name\":\"newState\",\"type\":\"uint8\"}],\"name\":\"StateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FRACTION_MULTIPLIER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authorFeeLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collateralSplit\",\"outputs\":[{\"internalType\":\"contract ICollateralSplit\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collateralToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"complementConversion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"complementToken\",\"outputs\":[{\"internalType\":\"contract IERC20MintedBurnable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"derivativeSpecification\",\"outputs\":[{\"internalType\":\"contract IDerivativeSpecification\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeLogger\",\"outputs\":[{\"internalType\":\"contract IFeeLogger\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256[]\",\"name\":\"_underlyingStarts\",\"type\":\"int256[]\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liveTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_collateralAmount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_collateralAmount\",\"type\":\"uint256\"}],\"name\":\"mintTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"oracleIterators\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"oracles\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"primaryConversion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"primaryToken\",\"outputs\":[{\"internalType\":\"contract IERC20MintedBurnable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_split\",\"type\":\"uint256\"}],\"name\":\"range\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_primaryTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_complementTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_underlyingEndRoundHints\",\"type\":\"uint256[]\"}],\"name\":\"redeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_primaryTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_complementTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_underlyingEndRoundHints\",\"type\":\"uint256[]\"}],\"name\":\"redeemTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"refund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"refundTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_underlyingEndRoundHints\",\"type\":\"uint256[]\"}],\"name\":\"settle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"settleTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"settlementDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"internalType\":\"enum Vault.State\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenBuilder\",\"outputs\":[{\"internalType\":\"contract ITokenBuilder\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"underlyingEnds\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"underlyingStarts\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Vault","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"000000000000000000000000000000000000000000000000000000006081654000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000fb21490a878aa2af08117c96f897095797bd91c000000000000000000000000dfc5e0b6fb483e6cbb3724efe4b0dfb41af3c742000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000000000000000000000000000000000000000018000000000000000000000000000000000000000000000000000000000000001c00000000000000000000000005431ad3ca7a0ef299eb6e4c26657f046c358c1e6000000000000000000000000029fac98fdc8fb0b74e0fdd3c2d356000c8cb23200000000000000000000000069dce1f77427a5d5c31c61cce6aa0a7a13da967600000000000000000000000000000000000000000000000000000002540be40000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000f4030086522a5beea4988f8ca5b36dbc97bee88c0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000fca05757a70154a8dc7b50064f1462142ee453d9","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}