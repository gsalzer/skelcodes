{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.4;\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n\taddress public owner;\r\n\taddress public newOwner;\r\n\r\n\tevent OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\r\n\r\n\tconstructor() {\r\n\t\towner = msg.sender;\r\n\t\tnewOwner = address(0);\r\n\t}\r\n\r\n\tmodifier onlyOwner() {\r\n\t\trequire(msg.sender == owner, \"only the owner can call this method\");\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction transferOwnership(address _newOwner) public onlyOwner {\r\n\t\trequire(address(0) != _newOwner, \"ownership cannot be transferred to address 0\");\r\n\t\tnewOwner = _newOwner;\r\n\t}\r\n\r\n\tfunction acceptOwnership() public {\r\n\t    require(newOwner != address(0), \"no new owner has been set up\");\r\n\t\trequire(msg.sender == newOwner, \"only the new owner can accept ownership\");\r\n\t\temit OwnershipTransferred(owner, msg.sender);\r\n\t\towner = msg.sender;\r\n\t\tnewOwner = address(0);\r\n\t}\r\n}\r\n\r\nabstract contract tokenInterface {\r\n\tfunction balanceOf(address _owner) public virtual view returns (uint256 balance);\r\n\tfunction transfer(address _to, uint256 _value) public virtual returns (bool);\r\n\tfunction transferFrom(address sender, address recipient, uint256 amount) public virtual returns (bool);\r\n}\r\n\r\nlibrary ArrayManager {\r\n    function add(bytes32[] storage arr, mapping(bytes32 => uint256) storage indexMapping, bytes32 element) internal {\r\n        require(indexMapping[element] == 0, \"The hash is already in the array.\");\r\n        arr.push(element);\r\n        indexMapping[element] = arr.length;\r\n    }\r\n\r\n    function remove(bytes32[] storage arr, mapping(bytes32 => uint256) storage indexMapping, bytes32 element) internal {\r\n        require(indexMapping[element] != 0, \"The address is not in the array.\");\r\n        uint256 index = indexMapping[element]-1;\r\n        \r\n        bytes32 assetMoved = arr[arr.length-1];\r\n        \r\n        arr[index] = assetMoved;\r\n        indexMapping[assetMoved] = index+1;\r\n        \r\n\t\tindexMapping[element] = 0;\r\n        arr.pop();\r\n    }\r\n}\r\n\r\n\r\ncontract AtomicBridge is Ownable {\r\n    using SafeMath for uint256;\r\n    using ArrayManager for bytes32[];\r\n    \r\n    uint256 public constant aliceRecoveryTime = 48 * 60 * 60;\r\n    uint256 public constant bobRecoveryTime = 24 * 60 * 60;\r\n    \r\n    uint256 public DOSMitigationFee;\r\n    uint256 public proposalDOSMitigationFee;\r\n    uint256 public newFeeActivationTime;\r\n    \r\n    mapping (address => mapping (address => uint256)) public tknLockedOf;\r\n    \r\n    function setDOSMitigationFee(uint256 _newFee) public onlyOwner {\r\n        proposalDOSMitigationFee = _newFee;\r\n        newFeeActivationTime = block.timestamp;\r\n    }\r\n    \r\n    function activeDOSMitigationFee() public onlyOwner {\r\n        require( newFeeActivationTime != 0, \"there is no new fee to be activated\");\r\n        uint256 activationDate = newFeeActivationTime + aliceRecoveryTime + bobRecoveryTime;\r\n        require( block.timestamp > activationDate, \"not enough time has passed not to change the rules\");\r\n        DOSMitigationFee = proposalDOSMitigationFee;\r\n        proposalDOSMitigationFee = 0;\r\n        newFeeActivationTime = 0;\r\n    }\r\n    \r\n    struct deposit { \r\n        address payable from;\r\n        address payable to;\r\n        uint256 msgValue;\r\n        address tokenAddress;\r\n        uint256 tokenAmount;\r\n        bool spent;\r\n        uint256 recoveryStarted;\r\n        bool isAlice;\r\n    }\r\n    mapping (bytes32 => deposit) public depositList;\r\n    \r\n    mapping (address => bytes32[]) public recoveryList;\r\n    mapping(bytes32 => uint256) public indexOfrecoveryList;\r\n    \r\n    function readRecovery(address _user) public view returns(bytes32[] memory) {\r\n        return recoveryList[_user];\r\n    }\r\n    \r\n    function depositTkn(bytes32 _secretHash, uint256 _tokenAmount, address _tokenAddress, address payable _to, bool _isAlice) internal returns (bool) {\r\n        require( depositList[_secretHash].from == address(0), \"secret already used\");\r\n        \r\n\r\n        tknLockedOf[msg.sender][_tokenAddress] = tknLockedOf[msg.sender][_tokenAddress].add(_tokenAmount);\r\n\r\n        \r\n        deposit memory d;\r\n        d.from = payable(msg.sender);\r\n        d.to = _to;\r\n        d.tokenAddress = _tokenAddress;\r\n        \r\n        if ( _tokenAddress != address(0) && _tokenAmount > 0 ) {\r\n            tokenInterface tkn = tokenInterface(_tokenAddress);\r\n            tkn.transferFrom(msg.sender, address(this), _tokenAmount);\r\n            d.tokenAmount = _tokenAmount;\r\n        }\r\n        \r\n        if ( msg.value > 0 ) {\r\n            d.msgValue = msg.value;\r\n        }\r\n        \r\n        d.isAlice = _isAlice;\r\n        depositList[_secretHash] = d;\r\n        \r\n        return true;\r\n    }\r\n    \r\n    event DepositStarted(bytes32 indexed secretHash, bytes msg);\r\n    function depositToken(bytes32 _secretHash, uint256 _tokenAmount, address _tokenAddress, address payable _to, bool _isAlice, bytes memory _msg) internal returns (bool) {\r\n        depositTkn(_secretHash, _tokenAmount, _tokenAddress, _to, _isAlice);\r\n        emit DepositStarted(_secretHash, _msg);\r\n        return true;\r\n    }\r\n    \r\n    event DepositStarted(bytes32 indexed secretHash);\r\n    function depositWithoutMsg(bytes32 _secretHash, uint256 _tokenAmount, address _tokenAddress, address payable _to, bool _isAlice) internal returns (bool) {\r\n        depositTkn(_secretHash, _tokenAmount, _tokenAddress, _to, _isAlice);\r\n        emit DepositStarted(_secretHash);\r\n        return true;\r\n    }\r\n    \r\n    \r\n    function depositTokenAlice(bytes32 _secretHash, uint256 _tokenAmount, address _tokenAddress, address payable _to, bytes memory _msg) public payable returns (bool) {\r\n        return depositToken(_secretHash, _tokenAmount, _tokenAddress, _to, true, _msg);\r\n    }\r\n    \r\n    function depositTokenBob(bytes32 _secretHash, uint256 _tokenAmount, address _tokenAddress, address payable _to, bytes memory _msg) public payable returns (bool) {\r\n        return depositToken(_secretHash, _tokenAmount, _tokenAddress, _to, false, _msg);\r\n    }\r\n    \r\n    function depositAliceWithoutMsg(bytes32 _secretHash, uint256 _tokenAmount, address _tokenAddress, address payable _to) public payable returns (bool) {\r\n        return depositWithoutMsg(_secretHash, _tokenAmount, _tokenAddress, _to, true);\r\n    }\r\n    \r\n    function depositBobWithoutMsg(bytes32 _secretHash, uint256 _tokenAmount, address _tokenAddress, address payable _to) public payable returns (bool) {\r\n        return depositWithoutMsg(_secretHash, _tokenAmount, _tokenAddress, _to, false);\r\n    }\r\n    \r\n    event withdrawStarted(bytes32 indexed secretHash, bytes32 secret);\r\n    function withdrawToken(bytes32 _secret) public returns (bool) {\r\n        bytes32 secretHash = keccak256(abi.encodePacked(_secret));\r\n        deposit memory d = depositList[secretHash];\r\n        \r\n        require( d.from != address(0), \"the secret hash does not exist\");\r\n        \r\n        require( !d.spent, \"withdrawal already done\" );\r\n        d.spent = true;\r\n\r\n        depositList[secretHash] = d;\r\n        \r\n        tknLockedOf[d.from][d.tokenAddress] = tknLockedOf[d.from][d.tokenAddress].sub(d.tokenAmount);\r\n\r\n        if (d.tokenAmount > 0) {\r\n            tokenInterface tkn = tokenInterface(d.tokenAddress);\r\n            tkn.transfer(d.to, d.tokenAmount);\r\n        }\r\n        \r\n        if ( d.msgValue > 0 ) {\r\n            d.to.transfer(d.msgValue);\r\n        }\r\n        \r\n        emit withdrawStarted(secretHash, _secret);\r\n        return true;\r\n    }\r\n    \r\n    event RecoveryStarted(bytes32 indexed secretHash);\r\n    function startRecovery(bytes32 _secretHash) public returns (bool) {\r\n        deposit memory d = depositList[_secretHash];\r\n        \r\n        require( d.from == msg.sender, \"only the same sender can start a recovery\" );\r\n        require( d.recoveryStarted == 0, \"recovery is already started\" );\r\n        \r\n        d.recoveryStarted = block.timestamp;\r\n        depositList[_secretHash] = d;\r\n        \r\n\t\trecoveryList[msg.sender].add(indexOfrecoveryList,_secretHash);\r\n        emit RecoveryStarted(_secretHash);\r\n        return true;\r\n    }\r\n    \r\n    function recoveryWithdraw(bytes32 _secretHash) public payable returns (bool) {\r\n        deposit memory d = depositList[_secretHash];\r\n        require( d.from == msg.sender, \"only the same sender can withdraw a recovery.\" );\r\n        \r\n        if( d.isAlice ) {\r\n            require( block.timestamp >= d.recoveryStarted + aliceRecoveryTime, \"You are not waiting long enough! You need to wait 48 hours\" ); \r\n            \r\n            require( msg.value >= DOSMitigationFee, \"Not enough DOSMitigationFee\");\r\n            d.to.send(msg.value);\r\n        } else {\r\n            require( msg.value == 0, \"only the creator of the secret has to pay the DOS Mitigation Fee\");\r\n            require( block.timestamp >= d.recoveryStarted + bobRecoveryTime, \"You are not waiting long enough! You need to wait 24 hours\" );\r\n        }\r\n        \r\n        require( !d.spent, \"deposit already spent\" );\r\n        d.spent = true;\r\n        depositList[_secretHash] = d;\r\n\r\n        tknLockedOf[d.from][d.tokenAddress] = tknLockedOf[d.from][d.tokenAddress].sub(d.tokenAmount);\r\n\t\trecoveryList[msg.sender].remove(indexOfrecoveryList,_secretHash);\r\n        \r\n        if (d.tokenAmount > 0) {\r\n            tokenInterface tkn = tokenInterface(d.tokenAddress);\r\n            tkn.transfer(d.from, d.tokenAmount);\r\n        }   \r\n        \r\n        if ( d.msgValue > 0 ) {\r\n            d.from.transfer(d.msgValue);\r\n        }    \r\n        \r\n        return true;\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"secretHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"msg\",\"type\":\"bytes\"}],\"name\":\"DepositStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"secretHash\",\"type\":\"bytes32\"}],\"name\":\"DepositStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"secretHash\",\"type\":\"bytes32\"}],\"name\":\"RecoveryStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"secretHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"secret\",\"type\":\"bytes32\"}],\"name\":\"withdrawStarted\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOSMitigationFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activeDOSMitigationFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"aliceRecoveryTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bobRecoveryTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_secretHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"depositAliceWithoutMsg\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_secretHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"depositBobWithoutMsg\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"depositList\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"msgValue\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"spent\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"recoveryStarted\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isAlice\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_secretHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_msg\",\"type\":\"bytes\"}],\"name\":\"depositTokenAlice\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_secretHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_msg\",\"type\":\"bytes\"}],\"name\":\"depositTokenBob\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"indexOfrecoveryList\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newFeeActivationTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposalDOSMitigationFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"readRecovery\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"recoveryList\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_secretHash\",\"type\":\"bytes32\"}],\"name\":\"recoveryWithdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newFee\",\"type\":\"uint256\"}],\"name\":\"setDOSMitigationFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_secretHash\",\"type\":\"bytes32\"}],\"name\":\"startRecovery\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tknLockedOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_secret\",\"type\":\"bytes32\"}],\"name\":\"withdrawToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"AtomicBridge","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://f76945873148729025c97c167458f8c8bd0680f1e2223732d2a33892231d8f9e"}]}