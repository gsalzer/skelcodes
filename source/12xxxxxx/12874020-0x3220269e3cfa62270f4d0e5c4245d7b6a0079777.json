{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity 0.8.6;\r\n\r\ninterface IERC20 {\r\n  function totalSupply() external view returns (uint);\r\n  function balanceOf(address account) external view returns (uint);\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n  function allowance(address owner, address spender) external view returns (uint);\r\n  function symbol() external view returns (string memory);\r\n  function decimals() external view returns (uint);\r\n  function approve(address spender, uint amount) external returns (bool);\r\n  function mint(address account, uint amount) external;\r\n  function burn(address account, uint amount) external;\r\n  function transferFrom(address sender, address recipient, uint amount) external returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract Ownable {\r\n\r\n  address public owner;\r\n  address public pendingOwner;\r\n\r\n  event OwnershipTransferInitiated(address indexed previousOwner, address indexed newOwner);\r\n  event OwnershipTransferConfirmed(address indexed previousOwner, address indexed newOwner);\r\n\r\n  constructor() {\r\n    owner = msg.sender;\r\n    emit OwnershipTransferConfirmed(address(0), owner);\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(isOwner(), \"Ownable: caller is not the owner\");\r\n    _;\r\n  }\r\n\r\n  function isOwner() public view returns (bool) {\r\n    return msg.sender == owner;\r\n  }\r\n\r\n  function transferOwnership(address _newOwner) external onlyOwner {\r\n    require(_newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n    emit OwnershipTransferInitiated(owner, _newOwner);\r\n    pendingOwner = _newOwner;\r\n  }\r\n\r\n  function acceptOwnership() external {\r\n    require(msg.sender == pendingOwner, \"Ownable: caller is not pending owner\");\r\n    emit OwnershipTransferConfirmed(owner, pendingOwner);\r\n    owner = pendingOwner;\r\n    pendingOwner = address(0);\r\n  }\r\n}\r\n\r\n// Calling setTotalRewardPerBlock, addPool or setReward, pending rewards will be changed.\r\n// Since all pools are likely to get accrued every hour or so, this is an acceptable deviation.\r\n// Accruing all pools here may consume too much gas.\r\n// up to the point of exceeding the gas limit if there are too many pools.\r\n\r\ncontract MasterPool is Ownable {\r\n\r\n  struct UserInfo {\r\n    uint amount;\r\n    uint rewardDebt;\r\n  }\r\n\r\n  // Info of each pool.\r\n  struct Pool {\r\n    IERC20 lpToken;        // Address of LP token contract.\r\n    uint points;      // How many allocation points assigned to this pool. RewardTokens to distribute per block.\r\n    uint lastRewardBlock;  // Last block number that RewardTokens distribution occurs.\r\n    uint accRewardTokenPerShare; // Accumulated RewardTokens per share, times 1e12. See below.\r\n  }\r\n\r\n  struct PoolPosition {\r\n    uint pid;\r\n    bool added; // To prevent duplicates.\r\n  }\r\n\r\n  IERC20 public rewardToken;\r\n  uint public totalRewardPerBlock;\r\n\r\n  // Info of each pool.\r\n  Pool[] public pools;\r\n  // Info of each user that stakes LP tokens.\r\n  mapping (uint => mapping (address => UserInfo)) public userInfo;\r\n  mapping (address => PoolPosition) public pidByToken;\r\n  // Total allocation poitns. Must be the sum of all allocation points in all pools.\r\n  uint public totalPoints;\r\n\r\n  event RewardRateUpdate(uint value);\r\n  event Deposit(address indexed user, uint indexed pid, uint amount);\r\n  event Withdraw(address indexed user, uint indexed pid, uint amount);\r\n  event EmergencyWithdraw(address indexed user, uint indexed pid, uint amount);\r\n\r\n  event PoolUpdate(\r\n    address indexed lpToken,\r\n    uint    indexed pid,\r\n    uint            points\r\n  );\r\n\r\n  constructor(\r\n    IERC20 _rewardToken,\r\n    uint _totalRewardPerBlock\r\n  ) {\r\n    rewardToken = _rewardToken;\r\n    totalRewardPerBlock = _totalRewardPerBlock;\r\n  }\r\n\r\n  function poolLength() external view returns (uint) {\r\n    return pools.length;\r\n  }\r\n\r\n  // Pending rewards will be changed. See class comments.\r\n  function addPool(address _lpToken, uint _points) external onlyOwner {\r\n\r\n    require(pidByToken[_lpToken].added == false, \"MasterPool: already added\");\r\n\r\n    totalPoints = totalPoints + _points;\r\n\r\n    pools.push(Pool({\r\n      lpToken: IERC20(_lpToken),\r\n      points: _points,\r\n      lastRewardBlock: block.number,\r\n      accRewardTokenPerShare: 0\r\n    }));\r\n\r\n    uint pid = pools.length - 1;\r\n\r\n    pidByToken[_lpToken] = PoolPosition({\r\n      pid: pid,\r\n      added: true\r\n    });\r\n\r\n    emit PoolUpdate(_lpToken, pid, _points);\r\n  }\r\n\r\n  // Pending rewards will be changed. See class comments.\r\n  function setReward(uint _pid, uint _points) external onlyOwner {\r\n\r\n    accruePool(_pid);\r\n\r\n    totalPoints = totalPoints - pools[_pid].points + _points;\r\n    pools[_pid].points = _points;\r\n\r\n    emit PoolUpdate(address(pools[_pid].lpToken), _pid, _points);\r\n  }\r\n\r\n  // Pending rewards will be changed. See class comments.\r\n  function setTotalRewardPerBlock(uint _value) external onlyOwner {\r\n    totalRewardPerBlock = _value;\r\n    emit RewardRateUpdate(_value);\r\n  }\r\n\r\n  // View function to see pending RewardTokens on frontend.\r\n  function pendingRewards(uint _pid, address _user) external view returns (uint) {\r\n\r\n    Pool storage pool = pools[_pid];\r\n    UserInfo storage user = userInfo[_pid][_user];\r\n    uint accRewardTokenPerShare = pool.accRewardTokenPerShare;\r\n    uint lpSupply = pool.lpToken.balanceOf(address(this));\r\n\r\n    if (block.number > pool.lastRewardBlock && lpSupply != 0) {\r\n      uint multiplier = block.number - pool.lastRewardBlock;\r\n      uint rewardTokenReward = multiplier * totalRewardPerBlock * pool.points / totalPoints;\r\n      accRewardTokenPerShare += rewardTokenReward * 1e12 / lpSupply;\r\n    }\r\n\r\n    return (user.amount * accRewardTokenPerShare / 1e12) - user.rewardDebt;\r\n  }\r\n\r\n  function accrueAllPools() public {\r\n      uint length = pools.length;\r\n      for (uint pid = 0; pid < length; ++pid) {\r\n        accruePool(pid);\r\n      }\r\n  }\r\n\r\n  // Update reward variables of the given pool to be up-to-date.\r\n  function accruePool(uint _pid) public {\r\n    Pool storage pool = pools[_pid];\r\n    if (block.number <= pool.lastRewardBlock) {\r\n      return;\r\n    }\r\n    uint lpSupply = pool.lpToken.balanceOf(address(this));\r\n    if (lpSupply == 0) {\r\n      pool.lastRewardBlock = block.number;\r\n      return;\r\n    }\r\n    uint multiplier = block.number - pool.lastRewardBlock;\r\n    uint rewardTokenReward = multiplier * totalRewardPerBlock * pool.points / totalPoints;\r\n    pool.accRewardTokenPerShare += rewardTokenReward * 1e12 / lpSupply;\r\n    pool.lastRewardBlock = block.number;\r\n  }\r\n\r\n  function deposit(uint _pid, uint _amount) external {\r\n    Pool storage pool = pools[_pid];\r\n    UserInfo storage user = userInfo[_pid][msg.sender];\r\n    accruePool(_pid);\r\n\r\n    if (user.amount > 0) {\r\n      uint pending = (user.amount * pool.accRewardTokenPerShare / 1e12) - user.rewardDebt;\r\n      _safeRewardTokenTransfer(msg.sender, pending);\r\n    }\r\n\r\n    pool.lpToken.transferFrom(address(msg.sender), address(this), _amount);\r\n    user.amount += _amount;\r\n    user.rewardDebt = user.amount * pool.accRewardTokenPerShare / 1e12;\r\n    emit Deposit(msg.sender, _pid, _amount);\r\n  }\r\n\r\n  function withdraw(uint _pid, uint _amount) external {\r\n    Pool storage pool = pools[_pid];\r\n    UserInfo storage user = userInfo[_pid][msg.sender];\r\n    require(user.amount >= _amount, \"MasterPool: user.amount >= _amount\");\r\n    accruePool(_pid);\r\n    uint pending = (user.amount * pool.accRewardTokenPerShare / 1e12) - user.rewardDebt;\r\n    _safeRewardTokenTransfer(msg.sender, pending);\r\n    user.amount = user.amount - _amount;\r\n    user.rewardDebt = user.amount * pool.accRewardTokenPerShare / 1e12;\r\n    pool.lpToken.transfer(address(msg.sender), _amount);\r\n    emit Withdraw(msg.sender, _pid, _amount);\r\n  }\r\n\r\n  function emergencyWithdraw(uint _pid) external {\r\n    Pool storage pool = pools[_pid];\r\n    UserInfo storage user = userInfo[_pid][msg.sender];\r\n    pool.lpToken.transfer(address(msg.sender), user.amount);\r\n    emit EmergencyWithdraw(msg.sender, _pid, user.amount);\r\n    user.amount = 0;\r\n    user.rewardDebt = 0;\r\n  }\r\n\r\n  // Allows to migrate rewards to a new staking contract.\r\n  function migrateRewards(address _recipient, uint _amount) external onlyOwner {\r\n    rewardToken.transfer(_recipient, _amount);\r\n  }\r\n\r\n  // Safe rewardToken transfer function, just in case if rounding error causes pool to not have enough RewardTokens.\r\n  function _safeRewardTokenTransfer(address _to, uint _amount) internal {\r\n    uint rewardTokenBal = rewardToken.balanceOf(address(this));\r\n    if (_amount > rewardTokenBal) {\r\n      rewardToken.transfer(_to, rewardTokenBal);\r\n    } else {\r\n      rewardToken.transfer(_to, _amount);\r\n    }\r\n  }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_totalRewardPerBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EmergencyWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferConfirmed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"points\",\"type\":\"uint256\"}],\"name\":\"PoolUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"RewardRateUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accrueAllPools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"accruePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_points\",\"type\":\"uint256\"}],\"name\":\"addPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"migrateRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pidByToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"added\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pools\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"points\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accRewardTokenPerShare\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_points\",\"type\":\"uint256\"}],\"name\":\"setReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setTotalRewardPerBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRewardPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MasterPool","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000008a75dbc7167714ceac1a8e43a8d643a4edd625a0000000000000000000000000000000000000000000000000000000000000001","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://7818a57613ca9dbb109f92c6882b9a083f3e29c4c2b4878179529b6e02d38319"}]}