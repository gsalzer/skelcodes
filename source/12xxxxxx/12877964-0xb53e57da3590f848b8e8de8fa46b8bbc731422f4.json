{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ClaimOpenEdition.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.6.7;\\n\\nlibrary SafeMath {\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n    \\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n    \\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n        return c;\\n    }\\n    \\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n    \\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n    \\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n        return c;\\n    }\\n    \\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n    \\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\\ninterface INFTSaleOpenEdition {\\n    function getBuyerQuantity(address _buyer) external view returns (uint256);\\n}\\n\\ninterface IERC1155 {\\n    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes calldata _data) external;\\n    function balanceOf(address _owner, uint256 _id) external view returns (uint256);\\n}\\n\\ncontract NFTSaleOpenEditionClaims {\\n    using SafeMath for uint256;\\n\\n    INFTSaleOpenEdition public openEditionSaleContract;\\n    IERC1155 public tokenContract;\\n    address public tokenAddress;\\n    uint256 public tokenId;\\n    address public controller;\\n\\n    uint256 public claimedCount = 0;\\n    mapping (address => uint256) public claimantToClaimCount;\\n    \\n    event Claim(address claimant, uint256 amount);\\n    \\n    constructor(address _openEditionSaleContract, address _tokenAddress, uint256 _tokenId) public {\\n        openEditionSaleContract = INFTSaleOpenEdition(_openEditionSaleContract);\\n        tokenAddress = _tokenAddress;\\n        tokenContract = IERC1155(_tokenAddress);\\n        tokenId = _tokenId;\\n        controller = msg.sender;\\n    }\\n\\n    function claim() public {\\n        uint256 entitledToCount = openEditionSaleContract.getBuyerQuantity(msg.sender);\\n        require(entitledToCount > 0, 'NFTSaleOpenEditionClaims::claim: msg.sender not entitled to any claims');\\n        require(entitledToCount > claimantToClaimCount[msg.sender], 'NFTSaleOpenEditionClaims::claim: msg.sender has no outstanding claims');\\n        uint256 remainingClaimCount = entitledToCount - claimantToClaimCount[msg.sender];\\n        require(tokenContract.balanceOf(address(this), tokenId) >= remainingClaimCount, 'NFTSaleOpenEditionClaims::claim: contract does not have enough NFTs to supply claim');\\n        tokenContract.safeTransferFrom(address(this), msg.sender, tokenId, remainingClaimCount, new bytes(0x0));\\n        claimantToClaimCount[msg.sender] = claimantToClaimCount[msg.sender].add(remainingClaimCount);\\n        claimedCount = claimedCount.add(remainingClaimCount);\\n        emit Claim(msg.sender, remainingClaimCount);\\n    }\\n\\n    function setOpenEditionSaleContract(address _openEditionSaleContract) public onlyController {\\n        openEditionSaleContract = INFTSaleOpenEdition(_openEditionSaleContract);\\n    }\\n\\n    function setTokenAddress(address _tokenAddress) public onlyController {\\n        tokenAddress = _tokenAddress;\\n        tokenContract = IERC1155(_tokenAddress);\\n    }\\n\\n    function setTokenId(uint256 _tokenId) public onlyController {\\n        tokenId = _tokenId;\\n    }\\n\\n    function pull() public onlyController {\\n        tokenContract.safeTransferFrom(address(this), msg.sender, tokenId, tokenContract.balanceOf(address(this), tokenId), new bytes(0x0));\\n    }\\n\\n    modifier onlyController {\\n      require(msg.sender == controller);\\n      _;\\n    }\\n\\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata) external pure returns(bytes4) {\\n        return bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"));\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_openEditionSaleContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"claimant\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimantToClaimCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimedCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openEditionSaleContract\",\"outputs\":[{\"internalType\":\"contract INFTSaleOpenEdition\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pull\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_openEditionSaleContract\",\"type\":\"address\"}],\"name\":\"setOpenEditionSaleContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"setTokenAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"setTokenId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenContract\",\"outputs\":[{\"internalType\":\"contract IERC1155\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"NFTSaleOpenEditionClaims","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000086856449981cab715cb3f324004faabbb248478100000000000000000000000013bab10a88fc5f6c77b87878d71c9f1707d2688a0000000000000000000000000000000000000000000000000000000000000096","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}