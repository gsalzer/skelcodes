{"status":"1","message":"OK","result":[{"SourceCode":"{\"AddressSet.sol\":{\"content\":\"pragma solidity ^0.5.13;\\n\\nlibrary AddressSet\\n{\\n    struct addrset\\n    {\\n        mapping(address =\\u003e uint) index;\\n        address[] elements;\\n    }\\n\\n    function insert(addrset storage self, address e)\\n        internal\\n        returns (bool success)\\n    {\\n        if (self.index[e] \\u003e 0) {\\n            return false;\\n        } else {\\n            self.index[e] = self.elements.push(e);\\n            return true;\\n        }\\n    }\\n\\n    function remove(addrset storage self, address e)\\n        internal\\n        returns (bool success)\\n    {\\n        uint index = self.index[e];\\n        if (index == 0) {\\n            return false;\\n        } else {\\n            address e0 = self.elements[self.elements.length - 1];\\n            self.elements[index - 1] = e0;\\n            self.elements.pop();\\n            self.index[e0] = index;\\n            delete self.index[e];\\n            return true;\\n        }\\n    }\\n\\n    function has(addrset storage self, address e)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return self.index[e] \\u003e 0;\\n    }\\n}\\n\"},\"BurnerRole.sol\":{\"content\":\"pragma solidity ^0.5.13;\\n\\nimport \\\"./AddressSet.sol\\\";\\n\\ncontract BurnerRole {\\n    using AddressSet for AddressSet.addrset;\\n\\n    AddressSet.addrset private burners;\\n\\n    event BurnerAddition(address indexed addr);\\n    event BurnerRemoval(address indexed addr);\\n\\n    modifier ifBurner(address _addr) {\\n        require(isBurner(_addr),\\n            \\\"BurnerRole: specified account does not have the Burner role\\\");\\n        _;\\n    }\\n\\n    modifier onlyBurner() {\\n        require(isBurner(msg.sender),\\n            \\\"BurnerRole: caller does not have the Burner role\\\");\\n        _;\\n    }\\n\\n    function getBurners()\\n        public\\n        view\\n        returns (address[] memory)\\n    {\\n        return burners.elements;\\n    }\\n\\n    function isBurner(address _addr)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return burners.has(_addr);\\n    }\\n\\n    function numBurners()\\n        public\\n        view\\n        returns (uint)\\n    {\\n        return burners.elements.length;\\n    }\\n\\n    function _addBurner(address _addr)\\n        internal\\n    {\\n        require(burners.insert(_addr),\\n            \\\"BurnerRole: duplicate bearer\\\");\\n        emit BurnerAddition(_addr);\\n    }\\n\\n    function _removeBurner(address _addr)\\n        internal\\n    {\\n        require(burners.remove(_addr),\\n            \\\"BurnerRole: not a bearer\\\");\\n        emit BurnerRemoval(_addr);\\n    }\\n}\\n\"},\"ERC20.sol\":{\"content\":\"pragma solidity ^0.5.13;\\n\\nimport \\\"./ERC20Interface.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./AddressSet.sol\\\";\\n\\ncontract ERC20 is ERC20Interface {\\n    using SafeMath for uint256;\\n    using AddressSet for AddressSet.addrset;\\n    AddressSet.addrset internal holders;\\n\\n    string  internal tokenName;\\n    string  internal tokenSymbol;\\n    uint8   internal tokenDecimals;\\n    uint256 internal tokenTotalSupply;\\n\\n    mapping(address =\\u003e uint256) internal balances;\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) internal allowed;\\n\\n    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 _totalSupply)\\n        internal\\n    {\\n        tokenName = _name;\\n        tokenSymbol = _symbol;\\n        tokenDecimals = _decimals;\\n        _mint(msg.sender, _totalSupply);\\n    }\\n\\n    function approve(address _spender, uint256 _amount)\\n        public\\n        returns (bool success)\\n    {\\n        _approve(msg.sender, _spender, _amount);\\n        return true;\\n    }\\n\\n    function decreaseAllowance(address _spender, uint256 _delta)\\n        public\\n        returns (bool success)\\n    {\\n        _approve(msg.sender, _spender, allowed[msg.sender][_spender].sub(_delta));\\n        return true;\\n    }\\n\\n    function increaseAllowance(address _spender, uint256 _delta)\\n        public\\n        returns (bool success)\\n    {\\n        _approve(msg.sender, _spender, allowed[msg.sender][_spender].add(_delta));\\n        return true;\\n    }\\n\\n    function transfer(address _to, uint256 _amount)\\n        public\\n        returns (bool success)\\n    {\\n        _transfer(msg.sender, _to, _amount);\\n        return true;\\n    }\\n\\n    function transferFrom(address _from, address _to, uint256 _amount)\\n        public\\n        returns (bool success)\\n    {\\n        _transfer(_from, _to, _amount);\\n        _approve(_from, msg.sender, allowed[_from][msg.sender].sub(_amount));\\n        return true;\\n    }\\n\\n    function allowance(address _owner, address _spender)\\n        public\\n        view\\n        returns (uint256 remaining)\\n    {\\n        return allowed[_owner][_spender];\\n    }\\n\\n    function balanceOf(address _owner)\\n        public\\n        view\\n        returns (uint256 balance)\\n    {\\n        return balances[_owner];\\n    }\\n\\n    function decimals()\\n        public\\n        view\\n        returns (uint8)\\n    {\\n        return tokenDecimals;\\n    }\\n\\n    function name()\\n        public\\n        view\\n        returns (string memory)\\n    {\\n        return tokenName;\\n    }\\n\\n    function symbol()\\n        public\\n        view\\n        returns (string memory)\\n    {\\n        return tokenSymbol;\\n    }\\n\\n    function totalSupply()\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return tokenTotalSupply;\\n    }\\n\\n    function _approve(address _owner, address _spender, uint256 _amount)\\n        internal\\n    {\\n        allowed[_owner][_spender] = _amount;\\n        emit Approval(_owner, _spender, _amount);\\n    }\\n\\n    function _burn(address _from, uint256 _amount)\\n        internal\\n    {\\n        balances[_from] = balances[_from].sub(_amount);\\n        tokenTotalSupply = tokenTotalSupply.sub(_amount);\\n\\n        emit Transfer(_from, address(0), _amount);\\n        emit Burn(_from, _amount);\\n    }\\n\\n    function _mint(address _to, uint256 _amount)\\n        internal\\n    {\\n        require(_to != address(0), \\\"ERC20: mint to the zero address\\\");\\n        require(_to != address(this), \\\"ERC20: mint to token contract\\\");\\n\\n        tokenTotalSupply = tokenTotalSupply.add(_amount);\\n        balances[_to] = balances[_to].add(_amount);\\n\\n        emit Transfer(address(0), _to, _amount);\\n        emit Mint(_to, _amount);\\n    }\\n\\n    function _transfer(address _from, address _to, uint256 _amount)\\n        internal\\n    {\\n        require(_to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n        require(_to != address(this), \\\"ERC20: transfer to token contract\\\");\\n\\n        balances[_from] = balances[_from].sub(_amount);\\n        balances[_to] = balances[_to].add(_amount);\\n        if (balances[_to] \\u003e 0) holders.insert(_to);\\n        if (balances[_from] == 0) holders.remove(_from);\\n        emit Transfer(_from, _to, _amount);\\n    }\\n\\n    function holderCount()\\n        public\\n        view\\n        returns (uint)\\n    {\\n        return holders.elements.length;\\n    }\\n}\\n\"},\"ERC20Burnable.sol\":{\"content\":\"pragma solidity ^0.5.13;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./MultiOwned.sol\\\";\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./BurnerRole.sol\\\";\\n\\ncontract ERC20Burnable is MultiOwned, ERC20, BurnerRole {\\n    function addBurner(address _addr)\\n        public\\n        onlySelf\\n    {\\n        _addBurner(_addr);\\n    }\\n\\n    function burn(uint256 _amount)\\n        public\\n        onlyBurner\\n        returns (bool success)\\n    {\\n        _burn(msg.sender, _amount);\\n        return true;\\n    }\\n\\n    function burnFrom(address _from, uint256 _amount)\\n        public\\n        ifBurner(_from)\\n        returns (bool success)\\n    {\\n        _burn(_from, _amount);\\n        _approve(_from, msg.sender, allowed[_from][msg.sender].sub(_amount));\\n        return true;\\n    }\\n\\n    function removeBurner(address _addr)\\n        public\\n        onlySelf\\n    {\\n        _removeBurner(_addr);\\n    }\\n\\n    function _burn(address _from, uint256 _amount)\\n        internal\\n    {\\n        balances[_from] = balances[_from].sub(_amount);\\n        if (balances[_from] == 0) holders.remove(_from);\\n        tokenTotalSupply = tokenTotalSupply.sub(_amount);\\n\\n        emit Transfer(_from, address(0), _amount);\\n        emit Burn(_from, _amount);\\n    }\\n}\\n\"},\"ERC20Interface.sol\":{\"content\":\"pragma solidity ^0.5.13;\\n\\ncontract ERC20Interface {\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n    event Burn(address indexed from, uint256 amount);\\n    event Mint(address indexed to, uint256 amount);\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\\n    function approve(address _spender, uint256 _amount) public returns (bool success);\\n    function balanceOf(address _owner) public view returns (uint256 balance);\\n    function transfer(address _to, uint256 _amount) public returns (bool success);\\n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success);\\n\\n    function decimals() public view returns (uint8);\\n    function name() public view returns (string memory);\\n    function symbol() public view returns (string memory);\\n    function totalSupply() public view returns (uint256);\\n}\\n\"},\"ERC20Mintable.sol\":{\"content\":\"pragma solidity ^0.5.13;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./MultiOwned.sol\\\";\\nimport \\\"./XAudTokenConfig.sol\\\";\\nimport \\\"./MinterRole.sol\\\";\\n\\ncontract ERC20Mintable is XAudTokenConfig, MultiOwned, ERC20, MinterRole {\\n    uint256 public mintCapacity;\\n    uint256 public amountMinted;\\n    uint public mintPeriod;\\n    uint public mintPeriodStart;\\n\\n    event MintCapacity(uint256 amount);\\n    event MintPeriod(uint duration);\\n\\n    constructor(uint256 _mintCapacity, uint _mintPeriod)\\n        public\\n    {\\n        _setMintCapacity(_mintCapacity);\\n        _setMintPeriod(_mintPeriod);\\n    }\\n\\n    function addMinter(address _addr)\\n        public\\n        onlySelf\\n    {\\n        _addMinter(_addr);\\n    }\\n\\n    function mint(address _to, uint256 _amount)\\n        public\\n    {\\n        if (msg.sender != address(this)) {\\n            require(isMinter(msg.sender), \\\"MinterRole: caller does not have the Minter role\\\");\\n            require(isUnderMintLimit(_amount), \\\"ERC20: exceeds minting capacity\\\");\\n        }\\n        _mint(_to, _amount);\\n    }\\n\\n    function removeMinter(address _addr)\\n        public\\n        onlySelf\\n    {\\n        _removeMinter(_addr);\\n    }\\n\\n    function renounceMinter()\\n        public\\n        returns (bool)\\n    {\\n        _removeMinter(msg.sender);\\n        return true;\\n    }\\n\\n    function setMintCapacity(uint256 _amount)\\n        public\\n        onlySelf\\n    {\\n        _setMintCapacity(_amount);\\n    }\\n\\n    function setMintPeriod(uint _duration)\\n        public\\n        onlySelf\\n    {\\n        _setMintPeriod(_duration);\\n    }\\n\\n    function _mint(address _to, uint256 _amount)\\n        internal\\n    {\\n        require(_to != address(0), \\\"ERC20: mint to the zero address\\\");\\n        require(_to != address(this), \\\"ERC20: mint to token contract\\\");\\n\\n        if (now \\u003e mintPeriodStart + mintPeriod) {\\n            amountMinted = 0;\\n            mintPeriodStart = now;\\n        }\\n        amountMinted = amountMinted.add(_amount);\\n        tokenTotalSupply = tokenTotalSupply.add(_amount);\\n        balances[_to] = balances[_to].add(_amount);\\n        if (balances[_to] \\u003e 0) holders.insert(_to);\\n        emit Transfer(address(0), _to, _amount);\\n        emit Mint(_to, _amount);\\n    }\\n\\n    function _setMintCapacity(uint256 _amount)\\n        internal\\n    {\\n        mintCapacity = _amount;\\n        emit MintCapacity(_amount);\\n    }\\n\\n    function _setMintPeriod(uint _duration)\\n        internal\\n    {\\n        require(_duration \\u003c (1 \\u003c\\u003c 64),\\n                \\\"ERC20: mint period must be less than 2^64 seconds\\\");\\n        mintPeriod = _duration;\\n        emit MintPeriod(_duration);\\n    }\\n\\n    function isUnderMintLimit(uint256 _amount)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        uint256 effAmountMinted = (now \\u003e mintPeriodStart + mintPeriod) ? 0 : amountMinted;\\n        if (effAmountMinted + _amount \\u003e mintCapacity\\n            || effAmountMinted + _amount \\u003c effAmountMinted) {\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    function remainingMintCapacity()\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        if (now \\u003e mintPeriodStart + mintPeriod)\\n            return mintCapacity;\\n        if (mintCapacity \\u003c amountMinted)\\n            return 0;\\n        return mintCapacity - amountMinted;\\n    }\\n}\\n\"},\"MinterRole.sol\":{\"content\":\"pragma solidity ^0.5.13;\\n\\nimport \\\"./AddressSet.sol\\\";\\n\\ncontract MinterRole {\\n    using AddressSet for AddressSet.addrset;\\n\\n    AddressSet.addrset private minters;\\n\\n    event MinterAddition(address indexed addr);\\n    event MinterRemoval(address indexed addr);\\n\\n    modifier ifMinter(address _addr) {\\n        require(isMinter(_addr),\\n            \\\"MinterRole: specified account does not have the Minter role\\\");\\n        _;\\n    }\\n\\n    modifier onlyMinter() {\\n        require(isMinter(msg.sender),\\n            \\\"MinterRole: caller does not have the Minter role\\\");\\n        _;\\n    }\\n\\n    function getMinters()\\n        public\\n        view\\n        returns (address[] memory)\\n    {\\n        return minters.elements;\\n    }\\n\\n    function isMinter(address _addr)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return minters.has(_addr);\\n    }\\n\\n    function numMinters()\\n        public\\n        view\\n        returns (uint)\\n    {\\n        return minters.elements.length;\\n    }\\n\\n    function _addMinter(address _addr)\\n        internal\\n    {\\n        require(minters.insert(_addr),\\n            \\\"MinterRole: duplicate bearer\\\");\\n        emit MinterAddition(_addr);\\n    }\\n\\n    function _removeMinter(address _addr)\\n        internal\\n    {\\n        require(minters.remove(_addr),\\n            \\\"MinterRole: not a bearer\\\");\\n        emit MinterRemoval(_addr);\\n    }\\n}\\n\"},\"MultiOwned.sol\":{\"content\":\"pragma solidity ^0.5.13;\\n\\nimport \\\"./OwnerRole.sol\\\";\\n\\ncontract MultiOwned is OwnerRole {\\n    uint constant public MAX_OWNER_COUNT = 50;\\n\\n    struct Transaction {\\n        bytes data;\\n        bool executed;\\n    }\\n\\n    mapping(bytes32 =\\u003e Transaction) public transactions;\\n    mapping(bytes32 =\\u003e mapping(address =\\u003e bool)) internal confirmations;\\n    uint public required;\\n\\n    event Confirmation(address indexed sender, bytes32 indexed transactionId);\\n    event Revocation(address indexed sender, bytes32 indexed transactionId);\\n    event Submission(bytes32 indexed transactionId);\\n    event Execution(bytes32 indexed transactionId);\\n    event ExecutionFailure(bytes32 indexed transactionId);\\n    event Requirement(uint required);\\n\\n    modifier confirmed(bytes32 _transactionId, address _owner) {\\n        require(confirmations[_transactionId][_owner]);\\n        _;\\n    }\\n\\n    modifier notConfirmed(bytes32 _transactionId, address _owner) {\\n        require(!confirmations[_transactionId][_owner]);\\n        _;\\n    }\\n\\n    modifier notExecuted(bytes32 _transactionId) {\\n        require(!transactions[_transactionId].executed);\\n        _;\\n    }\\n\\n    modifier onlySelf() {\\n        require(msg.sender == address(this));\\n        _;\\n    }\\n\\n    modifier transactionExists(bytes32 _transactionId) {\\n        require(transactions[_transactionId].data.length != 0);\\n        _;\\n    }\\n\\n    modifier validRequirement(uint _ownerCount, uint _required) {\\n        require(0 \\u003c _ownerCount\\n            \\u0026\\u0026 0 \\u003c _required\\n            \\u0026\\u0026 _required \\u003c= _ownerCount\\n            \\u0026\\u0026 _ownerCount \\u003c= MAX_OWNER_COUNT);\\n        _;\\n    }\\n\\n    constructor(address[] memory _owners, uint _required)\\n        public\\n        validRequirement(_owners.length, _required)\\n    {\\n        for (uint i = 0; i \\u003c _owners.length; ++i) {\\n            _addOwner(_owners[i]);\\n        }\\n        required = _required;\\n    }\\n\\n    function addOwner(address _owner)\\n        public\\n        onlySelf\\n        validRequirement(numOwners() + 1, required)\\n    {\\n        _addOwner(_owner);\\n    }\\n\\n    function addTransaction(bytes memory _data, uint _nonce)\\n        internal\\n        returns (bytes32 transactionId)\\n    {\\n        if (_nonce == 0) _nonce = block.number;\\n        transactionId = makeTransactionId(_data, _nonce);\\n        if (transactions[transactionId].data.length == 0) {\\n            transactions[transactionId] = Transaction({\\n                data: _data,\\n                executed: false\\n            });\\n            emit Submission(transactionId);\\n        }\\n    }\\n\\n    function confirmTransaction(bytes32 _transactionId)\\n        public\\n        onlyOwner\\n        transactionExists(_transactionId)\\n        notConfirmed(_transactionId, msg.sender)\\n    {\\n        confirmations[_transactionId][msg.sender] = true;\\n        emit Confirmation(msg.sender, _transactionId);\\n        executeTransaction(_transactionId);\\n    }\\n\\n    function executeTransaction(bytes32 _transactionId)\\n        public\\n        onlyOwner\\n        confirmed(_transactionId, msg.sender)\\n        notExecuted(_transactionId)\\n    {\\n        if (isConfirmed(_transactionId)) {\\n            Transaction storage txn = transactions[_transactionId];\\n            txn.executed = true;\\n            (bool success,) = address(this).call(txn.data);\\n            if (success) {\\n                emit Execution(_transactionId);\\n            } else {\\n                emit ExecutionFailure(_transactionId);\\n                txn.executed = false;\\n            }\\n        }\\n    }\\n\\n    function removeOwner(address _owner)\\n        public\\n        onlySelf\\n    {\\n        _removeOwner(_owner);\\n        if (required \\u003e numOwners()) {\\n            setRequirement(numOwners());\\n        }\\n    }\\n\\n    function renounceOwner()\\n        public\\n        validRequirement(numOwners() - 1, required)\\n    {\\n        _removeOwner(msg.sender);\\n    }\\n\\n    function replaceOwner(address _owner, address _newOwner)\\n        public\\n        onlySelf\\n    {\\n        _removeOwner(_owner);\\n        _addOwner(_newOwner);\\n    }\\n\\n    function revokeConfirmation(bytes32 _transactionId)\\n        public\\n        onlyOwner\\n        confirmed(_transactionId, msg.sender)\\n        notExecuted(_transactionId)\\n    {\\n        confirmations[_transactionId][msg.sender] = false;\\n        emit Revocation(msg.sender, _transactionId);\\n    }\\n\\n    function setRequirement(uint _required)\\n        public\\n        onlySelf\\n        validRequirement(numOwners(), _required)\\n    {\\n        required = _required;\\n        emit Requirement(_required);\\n    }\\n\\n    function submitTransaction(bytes memory _data, uint _nonce)\\n        public\\n        returns (bytes32 transactionId)\\n    {\\n        transactionId = addTransaction(_data, _nonce);\\n        confirmTransaction(transactionId);\\n    }\\n\\n    function getConfirmationCount(bytes32 _transactionId)\\n        public\\n        view\\n        returns (uint count)\\n    {\\n        address[] memory owners = getOwners();\\n        for (uint i = 0; i \\u003c numOwners(); ++i) {\\n            if (confirmations[_transactionId][owners[i]]) ++count;\\n        }\\n    }\\n\\n    function getConfirmations(bytes32 _transactionId)\\n        public\\n        view\\n        returns (address[] memory _confirmations)\\n    {\\n        address[] memory confirmationsTmp = new address[](numOwners());\\n        uint count = 0;\\n        uint i;\\n        address[] memory owners = getOwners();\\n        for (i = 0; i \\u003c numOwners(); ++i) {\\n            if (confirmations[_transactionId][owners[i]]) {\\n                confirmationsTmp[count] = owners[i];\\n                ++count;\\n            }\\n        }\\n        _confirmations = new address[](count);\\n        for (i = 0; i \\u003c count; ++i) {\\n            _confirmations[i] = confirmationsTmp[i];\\n        }\\n    }\\n\\n    function isConfirmed(bytes32 _transactionId)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        address[] memory owners = getOwners();\\n        uint count = 0;\\n        for (uint i = 0; i \\u003c numOwners(); ++i) {\\n            if (confirmations[_transactionId][owners[i]]) ++count;\\n            if (count == required) return true;\\n        }\\n    }\\n\\n    function makeTransactionId(bytes memory _data, uint _nonce)\\n        public\\n        pure\\n        returns (bytes32 transactionId)\\n    {\\n        transactionId = keccak256(abi.encode(_data, _nonce));\\n    }\\n}\\n\"},\"OwnerRole.sol\":{\"content\":\"pragma solidity ^0.5.13;\\n\\nimport \\\"./AddressSet.sol\\\";\\n\\ncontract OwnerRole {\\n    using AddressSet for AddressSet.addrset;\\n\\n    AddressSet.addrset private owners;\\n\\n    event OwnerAddition(address indexed addr);\\n    event OwnerRemoval(address indexed addr);\\n\\n    modifier ifOwner(address _addr) {\\n        require(isOwner(_addr),\\n            \\\"OwnerRole: specified account does not have the Owner role\\\");\\n        _;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(isOwner(msg.sender),\\n            \\\"OwnerRole: caller does not have the Owner role\\\");\\n        _;\\n    }\\n\\n    function getOwners()\\n        public\\n        view\\n        returns (address[] memory)\\n    {\\n        return owners.elements;\\n    }\\n\\n    function isOwner(address _addr)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return owners.has(_addr);\\n    }\\n\\n    function numOwners()\\n        public\\n        view\\n        returns (uint)\\n    {\\n        return owners.elements.length;\\n    }\\n\\n    function _addOwner(address _addr)\\n        internal\\n    {\\n        require(owners.insert(_addr),\\n            \\\"OwnerRole: duplicate bearer\\\");\\n        emit OwnerAddition(_addr);\\n    }\\n\\n    function _removeOwner(address _addr)\\n        internal\\n    {\\n        require(owners.remove(_addr),\\n            \\\"OwnerRole: not a bearer\\\");\\n        emit OwnerRemoval(_addr);\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003c= a, \\\"SafeMath: subtraction overflow\\\");\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b \\u003e 0, \\\"SafeMath: division by zero\\\");\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n}\\n\"},\"XAudToken.sol\":{\"content\":\"pragma solidity ^0.5.13;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./MultiOwned.sol\\\";\\nimport \\\"./ERC20Burnable.sol\\\";\\nimport \\\"./ERC20Mintable.sol\\\";\\nimport \\\"./XAudTokenConfig.sol\\\";\\n\\n\\n\\n\\ncontract XAudToken is XAudTokenConfig, ERC20Burnable, ERC20Mintable {\\n\\n    constructor()\\n        MultiOwned(\\n            makeAddressSingleton(msg.sender),\\n            1)\\n        ERC20(\\n            TOKEN_NAME,\\n            TOKEN_SYMBOL,\\n            TOKEN_DECIMALS,\\n            TOKEN_INITIALSUPPLY)\\n        ERC20Mintable(\\n            TOKEN_MINTCAPACITY,\\n            TOKEN_MINTPERIOD)\\n        public\\n    {}\\n}\\n\"},\"XAudTokenConfig.sol\":{\"content\":\"pragma solidity ^0.5.13;\\n\\ncontract XAudTokenConfig {\\n\\n    string internal constant TOKEN_SYMBOL = \\\"XAUD\\\";\\n    string internal constant TOKEN_NAME = \\\"XAUD Token\\\";\\n    uint8 internal constant TOKEN_DECIMALS = 5;\\n\\n    uint256 private constant DECIMALS_FACTOR = 10**uint256(TOKEN_DECIMALS);\\n    uint256 internal constant TOKEN_INITIALSUPPLY = 0;\\n\\n    uint256 internal constant TOKEN_MINTCAPACITY = 100 * DECIMALS_FACTOR;\\n    uint internal constant TOKEN_MINTPERIOD = 24 hours;\\n    \\n    function makeAddressSingleton(address _addr)\\n        internal\\n        pure\\n        returns (address[] memory addrs)\\n    {\\n        addrs = new address[](1);\\n        addrs[0] = _addr;\\n    }\\n    \\n}\\n\"}}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"BurnerAddition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"BurnerRemoval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"Execution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"ExecutionFailure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MintCapacity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"MintPeriod\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"MinterAddition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"MinterRemoval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"OwnerAddition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"OwnerRemoval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"Requirement\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"Revocation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"Submission\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_OWNER_COUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"addBurner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"addMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amountMinted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_transactionId\",\"type\":\"bytes32\"}],\"name\":\"confirmTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_delta\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_transactionId\",\"type\":\"bytes32\"}],\"name\":\"executeTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBurners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_transactionId\",\"type\":\"bytes32\"}],\"name\":\"getConfirmationCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_transactionId\",\"type\":\"bytes32\"}],\"name\":\"getConfirmations\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"_confirmations\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMinters\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"holderCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_delta\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isBurner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_transactionId\",\"type\":\"bytes32\"}],\"name\":\"isConfirmed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isMinter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"makeTransactionId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintCapacity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintPeriodStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numBurners\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numMinters\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numOwners\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"remainingMintCapacity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"removeBurner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"removeMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceMinter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"replaceOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"required\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_transactionId\",\"type\":\"bytes32\"}],\"name\":\"revokeConfirmation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setMintCapacity\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"setMintPeriod\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_required\",\"type\":\"uint256\"}],\"name\":\"setRequirement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"submitTransaction\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"transactions\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"XAudToken","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://4526fa751b7ef47ba694bf24ae404f13d1ca823d220dda213d91090fad83414b"}]}