{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/interface/ICoFiXFactory.sol\r\n\r\n// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity 0.6.12;\r\n\r\ninterface ICoFiXFactory {\r\n    // All pairs: {ETH <-> ERC20 Token}\r\n    event PairCreated(address indexed token, address pair, uint256);\r\n    event NewGovernance(address _new);\r\n    event NewController(address _new);\r\n    event NewFeeReceiver(address _new);\r\n    event NewFeeVaultForLP(address token, address feeVault);\r\n    event NewVaultForLP(address _new);\r\n    event NewVaultForTrader(address _new);\r\n    event NewVaultForCNode(address _new);\r\n\r\n    /// @dev Create a new token pair for trading\r\n    /// @param  token the address of token to trade\r\n    /// @return pair the address of new token pair\r\n    function createPair(\r\n        address token\r\n        )\r\n        external\r\n        returns (address pair);\r\n\r\n    function getPair(address token) external view returns (address pair);\r\n    function allPairs(uint256) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint256);\r\n\r\n    function getTradeMiningStatus(address token) external view returns (bool status);\r\n    function setTradeMiningStatus(address token, bool status) external;\r\n    function getFeeVaultForLP(address token) external view returns (address feeVault); // for LPs\r\n    function setFeeVaultForLP(address token, address feeVault) external;\r\n\r\n    function setGovernance(address _new) external;\r\n    function setController(address _new) external;\r\n    function setFeeReceiver(address _new) external;\r\n    function setVaultForLP(address _new) external;\r\n    function setVaultForTrader(address _new) external;\r\n    function setVaultForCNode(address _new) external;\r\n    function getController() external view returns (address controller);\r\n    function getFeeReceiver() external view returns (address feeReceiver); // For CoFi Holders\r\n    function getVaultForLP() external view returns (address vaultForLP);\r\n    function getVaultForTrader() external view returns (address vaultForTrader);\r\n    function getVaultForCNode() external view returns (address vaultForCNode);\r\n}\r\n// File: contracts/interface/ICoFiXERC20.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\ninterface ICoFiXERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    // function name() external pure returns (string memory);\r\n    // function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n}\r\n\r\n// File: contracts/interface/ICoFiXPair.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\ninterface ICoFiXPair is ICoFiXERC20 {\r\n\r\n    struct OraclePrice {\r\n        uint256 ethAmount;\r\n        uint256 erc20Amount;\r\n        uint256 blockNum;\r\n        uint256 K;\r\n        uint256 theta;\r\n    }\r\n\r\n    // All pairs: {ETH <-> ERC20 Token}\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, address outToken, uint outAmount, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amountIn,\r\n        uint amountOut,\r\n        address outToken,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1);\r\n\r\n    function mint(address to) external payable returns (uint liquidity, uint oracleFeeChange);\r\n    function burn(address outToken, address to) external payable returns (uint amountOut, uint oracleFeeChange);\r\n    function swapWithExact(address outToken, address to) external payable returns (uint amountIn, uint amountOut, uint oracleFeeChange, uint256[4] memory tradeInfo);\r\n    function swapForExact(address outToken, uint amountOutExact, address to) external payable returns (uint amountIn, uint amountOut, uint oracleFeeChange, uint256[4] memory tradeInfo);\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address, string memory, string memory) external;\r\n\r\n    /// @dev get Net Asset Value Per Share\r\n    /// @param  ethAmount ETH side of Oracle price {ETH <-> ERC20 Token}\r\n    /// @param  erc20Amount Token side of Oracle price {ETH <-> ERC20 Token}\r\n    /// @return navps The Net Asset Value Per Share (liquidity) represents\r\n    function getNAVPerShare(uint256 ethAmount, uint256 erc20Amount) external view returns (uint256 navps);\r\n}\r\n\r\n// File: contracts/interface/INestPriceFacade.sol\r\n\r\npragma solidity ^0.6.12;\r\n\r\n/// @dev This interface defines the methods for price call entry\r\ninterface INestPriceFacade {\r\n    \r\n    // /// @dev Price call entry configuration structure\r\n    // struct Config {\r\n\r\n    //     // Single query fee（0.0001 ether, DIMI_ETHER). 100\r\n    //     uint16 singleFee;\r\n\r\n    //     // Double query fee（0.0001 ether, DIMI_ETHER). 100\r\n    //     uint16 doubleFee;\r\n\r\n    //     // The normal state flag of the call address. 0\r\n    //     uint8 normalFlag;\r\n    // }\r\n\r\n    // /// @dev Modify configuration\r\n    // /// @param config Configuration object\r\n    // function setConfig(Config memory config) external;\r\n\r\n    // /// @dev Get configuration\r\n    // /// @return Configuration object\r\n    // function getConfig() external view returns (Config memory);\r\n\r\n    /// @dev Set the address flag. Only the address flag equals to config.normalFlag can the price be called\r\n    /// @param addr Destination address\r\n    /// @param flag Address flag\r\n    function setAddressFlag(address addr, uint flag) external;\r\n\r\n    /// @dev Get the flag. Only the address flag equals to config.normalFlag can the price be called\r\n    /// @param addr Destination address\r\n    /// @return Address flag\r\n    function getAddressFlag(address addr) external view returns(uint);\r\n\r\n    /// @dev Set INestQuery implemention contract address for token\r\n    /// @param tokenAddress Destination token address\r\n    /// @param nestQueryAddress INestQuery implemention contract address, 0 means delete\r\n    function setNestQuery(address tokenAddress, address nestQueryAddress) external;\r\n\r\n    /// @dev Get INestQuery implemention contract address for token\r\n    /// @param tokenAddress Destination token address\r\n    /// @return INestQuery implemention contract address, 0 means use default\r\n    function getNestQuery(address tokenAddress) external view returns (address);\r\n\r\n    /// @dev Get the latest trigger price\r\n    /// @param tokenAddress Destination token address\r\n    /// @param paybackAddress As the charging fee may change, it is suggested that the caller pay more fees, and the excess fees will be returned through this address\r\n    /// @return blockNumber The block number of price\r\n    /// @return price The token price. (1eth equivalent to (price) token)\r\n    function triggeredPrice(address tokenAddress, address paybackAddress) external payable returns (uint blockNumber, uint price);\r\n\r\n    /// @dev Get the full information of latest trigger price\r\n    /// @param tokenAddress Destination token address\r\n    /// @param paybackAddress As the charging fee may change, it is suggested that the caller pay more fees, and the excess fees will be returned through this address\r\n    /// @return blockNumber The block number of price\r\n    /// @return price The token price. (1eth equivalent to (price) token)\r\n    /// @return avgPrice Average price\r\n    /// @return sigmaSQ The square of the volatility (18 decimal places). The current implementation assumes that \r\n    ///         the volatility cannot exceed 1. Correspondingly, when the return value is equal to 999999999999996447,\r\n    ///         it means that the volatility has exceeded the range that can be expressed\r\n    function triggeredPriceInfo(address tokenAddress, address paybackAddress) external payable returns (uint blockNumber, uint price, uint avgPrice, uint sigmaSQ);\r\n\r\n    /// @dev Find the price at block number\r\n    /// @param tokenAddress Destination token address\r\n    /// @param height Destination block number\r\n    /// @param paybackAddress As the charging fee may change, it is suggested that the caller pay more fees, and the excess fees will be returned through this address\r\n    /// @return blockNumber The block number of price\r\n    /// @return price The token price. (1eth equivalent to (price) token)\r\n    function findPrice(address tokenAddress, uint height, address paybackAddress) external payable returns (uint blockNumber, uint price);\r\n\r\n    /// @dev Get the latest effective price\r\n    /// @param tokenAddress Destination token address\r\n    /// @param paybackAddress As the charging fee may change, it is suggested that the caller pay more fees, and the excess fees will be returned through this address\r\n    /// @return blockNumber The block number of price\r\n    /// @return price The token price. (1eth equivalent to (price) token)\r\n    function latestPrice(address tokenAddress, address paybackAddress) external payable returns (uint blockNumber, uint price);\r\n\r\n    /// @dev Get the last (num) effective price\r\n    /// @param tokenAddress Destination token address\r\n    /// @param count The number of prices that want to return\r\n    /// @param paybackAddress As the charging fee may change, it is suggested that the caller pay more fees, and the excess fees will be returned through this address\r\n    /// @return An array which length is num * 2, each two element expresses one price like blockNumber｜price\r\n    function lastPriceList(address tokenAddress, uint count, address paybackAddress) external payable returns (uint[] memory);\r\n\r\n    /// @dev Returns the results of latestPrice() and triggeredPriceInfo()\r\n    /// @param tokenAddress Destination token address\r\n    /// @param paybackAddress As the charging fee may change, it is suggested that the caller pay more fees, and the excess fees will be returned through this address\r\n    /// @return latestPriceBlockNumber The block number of latest price\r\n    /// @return latestPriceValue The token latest price. (1eth equivalent to (price) token)\r\n    /// @return triggeredPriceBlockNumber The block number of triggered price\r\n    /// @return triggeredPriceValue The token triggered price. (1eth equivalent to (price) token)\r\n    /// @return triggeredAvgPrice Average price\r\n    /// @return triggeredSigmaSQ The square of the volatility (18 decimal places). The current implementation assumes that \r\n    ///         the volatility cannot exceed 1. Correspondingly, when the return value is equal to 999999999999996447,\r\n    ///         it means that the volatility has exceeded the range that can be expressed\r\n    function latestPriceAndTriggeredPriceInfo(address tokenAddress, address paybackAddress) \r\n    external \r\n    payable \r\n    returns (\r\n        uint latestPriceBlockNumber, \r\n        uint latestPriceValue,\r\n        uint triggeredPriceBlockNumber,\r\n        uint triggeredPriceValue,\r\n        uint triggeredAvgPrice,\r\n        uint triggeredSigmaSQ\r\n    );\r\n\r\n    /// @dev Get the latest trigger price. (token and ntoken)\r\n    /// @param tokenAddress Destination token address\r\n    /// @param paybackAddress As the charging fee may change, it is suggested that the caller pay more fees, and the excess fees will be returned through this address\r\n    /// @return blockNumber The block number of price\r\n    /// @return price The token price. (1eth equivalent to (price) token)\r\n    /// @return ntokenBlockNumber The block number of ntoken price\r\n    /// @return ntokenPrice The ntoken price. (1eth equivalent to (price) ntoken)\r\n    function triggeredPrice2(address tokenAddress, address paybackAddress) external payable returns (uint blockNumber, uint price, uint ntokenBlockNumber, uint ntokenPrice);\r\n\r\n    /// @dev Get the full information of latest trigger price. (token and ntoken)\r\n    /// @param tokenAddress Destination token address\r\n    /// @param paybackAddress As the charging fee may change, it is suggested that the caller pay more fees, and the excess fees will be returned through this address\r\n    /// @return blockNumber The block number of price\r\n    /// @return price The token price. (1eth equivalent to (price) token)\r\n    /// @return avgPrice Average price\r\n    /// @return sigmaSQ The square of the volatility (18 decimal places). The current implementation assumes that \r\n    ///         the volatility cannot exceed 1. Correspondingly, when the return value is equal to 999999999999996447, \r\n    ///         it means that the volatility has exceeded the range that can be expressed\r\n    /// @return ntokenBlockNumber The block number of ntoken price\r\n    /// @return ntokenPrice The ntoken price. (1eth equivalent to (price) ntoken)\r\n    /// @return ntokenAvgPrice Average price of ntoken\r\n    /// @return ntokenSigmaSQ The square of the volatility (18 decimal places). The current implementation assumes that\r\n    ///         the volatility cannot exceed 1. Correspondingly, when the return value is equal to 999999999999996447,\r\n    ///         it means that the volatility has exceeded the range that can be expressed\r\n    function triggeredPriceInfo2(address tokenAddress, address paybackAddress) external payable returns (uint blockNumber, uint price, uint avgPrice, uint sigmaSQ, uint ntokenBlockNumber, uint ntokenPrice, uint ntokenAvgPrice, uint ntokenSigmaSQ);\r\n\r\n    /// @dev Get the latest effective price. (token and ntoken)\r\n    /// @param tokenAddress Destination token address\r\n    /// @param paybackAddress As the charging fee may change, it is suggested that the caller pay more fees, and the excess fees will be returned through this address\r\n    /// @return blockNumber The block number of price\r\n    /// @return price The token price. (1eth equivalent to (price) token)\r\n    /// @return ntokenBlockNumber The block number of ntoken price\r\n    /// @return ntokenPrice The ntoken price. (1eth equivalent to (price) ntoken)\r\n    function latestPrice2(address tokenAddress, address paybackAddress) external payable returns (uint blockNumber, uint price, uint ntokenBlockNumber, uint ntokenPrice);\r\n}\r\n// File: contracts/interface/ICoFiXController.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\ninterface ICoFiXController {\r\n\r\n    event NewK(address token, int128 K, int128 sigma, uint256 T, uint256 ethAmount, uint256 erc20Amount, uint256 blockNum, uint256 tIdx, uint256 sigmaIdx, int128 K0);\r\n    event NewGovernance(address _new);\r\n    event NewOracle(address _priceOracle);\r\n    event NewKTable(address _kTable);\r\n    event NewTimespan(uint256 _timeSpan);\r\n    event NewKRefreshInterval(uint256 _interval);\r\n    event NewKLimit(int128 maxK0);\r\n    event NewGamma(int128 _gamma);\r\n    event NewTheta(address token, uint32 theta);\r\n    event NewK(address token, uint32 k);\r\n\r\n    function addCaller(address caller) external;\r\n\r\n    function queryOracle(address token, uint8 op, bytes memory data) external payable returns (uint256 k, uint256 ethAmount, uint256 erc20Amount, uint256 blockNum, uint256 theta);\r\n}\r\n// File: contracts/lib/TransferHelper.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\n// File: contracts/interface/ICoFiXKTable.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\ninterface ICoFiXKTable {\r\n    function setK0(uint256 tIdx, uint256 sigmaIdx, int128 k0) external;\r\n    function setK0InBatch(uint256[] memory tIdxs, uint256[] memory sigmaIdxs, int128[] memory k0s) external;\r\n    function getK0(uint256 tIdx, uint256 sigmaIdx) external view returns (int128);\r\n}\r\n// File: contracts/lib/ABDKMath64x64.sol\r\n\r\n/*\r\n * ABDK Math 64.64 Smart Contract Library.  Copyright © 2019 by ABDK Consulting.\r\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\r\n */\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * Smart contract library of mathematical functions operating with signed\r\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\r\n * basically a simple fraction whose numerator is signed 128-bit integer and\r\n * denominator is 2^64.  As long as denominator is always the same, there is no\r\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\r\n * represented by int128 type holding only the numerator.\r\n */\r\nlibrary ABDKMath64x64 {\r\n  /**\r\n   * @dev Minimum value signed 64.64-bit fixed point number may have. \r\n   */\r\n  int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\r\n\r\n  /**\r\n   * @dev Maximum value signed 64.64-bit fixed point number may have. \r\n   */\r\n  int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n  /**\r\n   * Convert signed 256-bit integer number into signed 64.64-bit fixed point\r\n   * number.  Revert on overflow.\r\n   *\r\n   * @param x signed 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function fromInt (int256 x) internal pure returns (int128) {\r\n    require (x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\r\n    return int128 (x << 64);\r\n  }\r\n\r\n  /**\r\n   * Convert signed 64.64 fixed point number into signed 64-bit integer number\r\n   * rounding down.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64-bit integer number\r\n   */\r\n  function toInt (int128 x) internal pure returns (int64) {\r\n    return int64 (x >> 64);\r\n  }\r\n\r\n  /**\r\n   * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\r\n   * number.  Revert on overflow.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function fromUInt (uint256 x) internal pure returns (int128) {\r\n    require (x <= 0x7FFFFFFFFFFFFFFF);\r\n    return int128 (x << 64);\r\n  }\r\n\r\n  /**\r\n   * Convert signed 64.64 fixed point number into unsigned 64-bit integer\r\n   * number rounding down.  Revert on underflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return unsigned 64-bit integer number\r\n   */\r\n  function toUInt (int128 x) internal pure returns (uint64) {\r\n    require (x >= 0);\r\n    return uint64 (x >> 64);\r\n  }\r\n\r\n  /**\r\n   * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\r\n   * number rounding down.  Revert on overflow.\r\n   *\r\n   * @param x signed 128.128-bin fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function from128x128 (int256 x) internal pure returns (int128) {\r\n    int256 result = x >> 64;\r\n    require (result >= MIN_64x64 && result <= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Convert signed 64.64 fixed point number into signed 128.128 fixed point\r\n   * number.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 128.128 fixed point number\r\n   */\r\n  function to128x128 (int128 x) internal pure returns (int256) {\r\n    return int256 (x) << 64;\r\n  }\r\n\r\n  /**\r\n   * Calculate x + y.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function add (int128 x, int128 y) internal pure returns (int128) {\r\n    int256 result = int256(x) + y;\r\n    require (result >= MIN_64x64 && result <= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate x - y.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function sub (int128 x, int128 y) internal pure returns (int128) {\r\n    int256 result = int256(x) - y;\r\n    require (result >= MIN_64x64 && result <= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate x * y rounding down.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function mul (int128 x, int128 y) internal pure returns (int128) {\r\n    int256 result = int256(x) * y >> 64;\r\n    require (result >= MIN_64x64 && result <= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\r\n   * number and y is signed 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64 fixed point number\r\n   * @param y signed 256-bit integer number\r\n   * @return signed 256-bit integer number\r\n   */\r\n  function muli (int128 x, int256 y) internal pure returns (int256) {\r\n    if (x == MIN_64x64) {\r\n      require (y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\r\n        y <= 0x1000000000000000000000000000000000000000000000000);\r\n      return -y << 63;\r\n    } else {\r\n      bool negativeResult = false;\r\n      if (x < 0) {\r\n        x = -x;\r\n        negativeResult = true;\r\n      }\r\n      if (y < 0) {\r\n        y = -y; // We rely on overflow behavior here\r\n        negativeResult = !negativeResult;\r\n      }\r\n      uint256 absoluteResult = mulu (x, uint256 (y));\r\n      if (negativeResult) {\r\n        require (absoluteResult <=\r\n          0x8000000000000000000000000000000000000000000000000000000000000000);\r\n        return -int256 (absoluteResult); // We rely on overflow behavior here\r\n      } else {\r\n        require (absoluteResult <=\r\n          0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n        return int256 (absoluteResult);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x * y rounding down, where x is signed 64.64 fixed point number\r\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64 fixed point number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return unsigned 256-bit integer number\r\n   */\r\n  function mulu (int128 x, uint256 y) internal pure returns (uint256) {\r\n    if (y == 0) return 0;\r\n\r\n    require (x >= 0);\r\n\r\n    uint256 lo = (uint256 (x) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\r\n    uint256 hi = uint256 (x) * (y >> 128);\r\n\r\n    require (hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n    hi <<= 64;\r\n\r\n    require (hi <=\r\n      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\r\n    return hi + lo;\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero.  Revert on overflow or when y is\r\n   * zero.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function div (int128 x, int128 y) internal pure returns (int128) {\r\n    require (y != 0);\r\n    int256 result = (int256 (x) << 64) / y;\r\n    require (result >= MIN_64x64 && result <= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero, where x and y are signed 256-bit\r\n   * integer numbers.  Revert on overflow or when y is zero.\r\n   *\r\n   * @param x signed 256-bit integer number\r\n   * @param y signed 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function divi (int256 x, int256 y) internal pure returns (int128) {\r\n    require (y != 0);\r\n\r\n    bool negativeResult = false;\r\n    if (x < 0) {\r\n      x = -x; // We rely on overflow behavior here\r\n      negativeResult = true;\r\n    }\r\n    if (y < 0) {\r\n      y = -y; // We rely on overflow behavior here\r\n      negativeResult = !negativeResult;\r\n    }\r\n    uint128 absoluteResult = divuu (uint256 (x), uint256 (y));\r\n    if (negativeResult) {\r\n      require (absoluteResult <= 0x80000000000000000000000000000000);\r\n      return -int128 (absoluteResult); // We rely on overflow behavior here\r\n    } else {\r\n      require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n      return int128 (absoluteResult); // We rely on overflow behavior here\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\r\n   * integer numbers.  Revert on overflow or when y is zero.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function divu (uint256 x, uint256 y) internal pure returns (int128) {\r\n    require (y != 0);\r\n    uint128 result = divuu (x, y);\r\n    require (result <= uint128 (MAX_64x64));\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate -x.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function neg (int128 x) internal pure returns (int128) {\r\n    require (x != MIN_64x64);\r\n    return -x;\r\n  }\r\n\r\n  /**\r\n   * Calculate |x|.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function abs (int128 x) internal pure returns (int128) {\r\n    require (x != MIN_64x64);\r\n    return x < 0 ? -x : x;\r\n  }\r\n\r\n  /**\r\n   * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\r\n   * zero.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function inv (int128 x) internal pure returns (int128) {\r\n    require (x != 0);\r\n    int256 result = int256 (0x100000000000000000000000000000000) / x;\r\n    require (result >= MIN_64x64 && result <= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function avg (int128 x, int128 y) internal pure returns (int128) {\r\n    return int128 ((int256 (x) + int256 (y)) >> 1);\r\n  }\r\n\r\n  /**\r\n   * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\r\n   * Revert on overflow or in case x * y is negative.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function gavg (int128 x, int128 y) internal pure returns (int128) {\r\n    int256 m = int256 (x) * int256 (y);\r\n    require (m >= 0);\r\n    require (m <\r\n        0x4000000000000000000000000000000000000000000000000000000000000000);\r\n    return int128 (sqrtu (uint256 (m), uint256 (x) + uint256 (y) >> 1));\r\n  }\r\n\r\n  /**\r\n   * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\r\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y uint256 value\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function pow (int128 x, uint256 y) internal pure returns (int128) {\r\n    uint256 absoluteResult;\r\n    bool negativeResult = false;\r\n    if (x >= 0) {\r\n      absoluteResult = powu (uint256 (x) << 63, y);\r\n    } else {\r\n      // We rely on overflow behavior here\r\n      absoluteResult = powu (uint256 (uint128 (-x)) << 63, y);\r\n      negativeResult = y & 1 > 0;\r\n    }\r\n\r\n    absoluteResult >>= 63;\r\n\r\n    if (negativeResult) {\r\n      require (absoluteResult <= 0x80000000000000000000000000000000);\r\n      return -int128 (absoluteResult); // We rely on overflow behavior here\r\n    } else {\r\n      require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n      return int128 (absoluteResult); // We rely on overflow behavior here\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate sqrt (x) rounding down.  Revert if x < 0.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function sqrt (int128 x) internal pure returns (int128) {\r\n    require (x >= 0);\r\n    return int128 (sqrtu (uint256 (x) << 64, 0x10000000000000000));\r\n  }\r\n\r\n  /**\r\n   * Calculate binary logarithm of x.  Revert if x <= 0.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function log_2 (int128 x) internal pure returns (int128) {\r\n    require (x > 0);\r\n\r\n    int256 msb = 0;\r\n    int256 xc = x;\r\n    if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\r\n    if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\r\n    if (xc >= 0x10000) { xc >>= 16; msb += 16; }\r\n    if (xc >= 0x100) { xc >>= 8; msb += 8; }\r\n    if (xc >= 0x10) { xc >>= 4; msb += 4; }\r\n    if (xc >= 0x4) { xc >>= 2; msb += 2; }\r\n    if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\r\n\r\n    int256 result = msb - 64 << 64;\r\n    uint256 ux = uint256 (x) << 127 - msb;\r\n    for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\r\n      ux *= ux;\r\n      uint256 b = ux >> 255;\r\n      ux >>= 127 + b;\r\n      result += bit * int256 (b);\r\n    }\r\n\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate natural logarithm of x.  Revert if x <= 0.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function ln (int128 x) internal pure returns (int128) {\r\n    require (x > 0);\r\n\r\n    return int128 (\r\n        uint256 (log_2 (x)) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF >> 128);\r\n  }\r\n\r\n  /**\r\n   * Calculate binary exponent of x.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function exp_2 (int128 x) internal pure returns (int128) {\r\n    require (x < 0x400000000000000000); // Overflow\r\n\r\n    if (x < -0x400000000000000000) return 0; // Underflow\r\n\r\n    uint256 result = 0x80000000000000000000000000000000;\r\n\r\n    if (x & 0x8000000000000000 > 0)\r\n      result = result * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\r\n    if (x & 0x4000000000000000 > 0)\r\n      result = result * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\r\n    if (x & 0x2000000000000000 > 0)\r\n      result = result * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\r\n    if (x & 0x1000000000000000 > 0)\r\n      result = result * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\r\n    if (x & 0x800000000000000 > 0)\r\n      result = result * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\r\n    if (x & 0x400000000000000 > 0)\r\n      result = result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\r\n    if (x & 0x200000000000000 > 0)\r\n      result = result * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\r\n    if (x & 0x100000000000000 > 0)\r\n      result = result * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\r\n    if (x & 0x80000000000000 > 0)\r\n      result = result * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\r\n    if (x & 0x40000000000000 > 0)\r\n      result = result * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\r\n    if (x & 0x20000000000000 > 0)\r\n      result = result * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\r\n    if (x & 0x10000000000000 > 0)\r\n      result = result * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\r\n    if (x & 0x8000000000000 > 0)\r\n      result = result * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\r\n    if (x & 0x4000000000000 > 0)\r\n      result = result * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\r\n    if (x & 0x2000000000000 > 0)\r\n      result = result * 0x1000162E525EE054754457D5995292026 >> 128;\r\n    if (x & 0x1000000000000 > 0)\r\n      result = result * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\r\n    if (x & 0x800000000000 > 0)\r\n      result = result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\r\n    if (x & 0x400000000000 > 0)\r\n      result = result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\r\n    if (x & 0x200000000000 > 0)\r\n      result = result * 0x10000162E43F4F831060E02D839A9D16D >> 128;\r\n    if (x & 0x100000000000 > 0)\r\n      result = result * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\r\n    if (x & 0x80000000000 > 0)\r\n      result = result * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\r\n    if (x & 0x40000000000 > 0)\r\n      result = result * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\r\n    if (x & 0x20000000000 > 0)\r\n      result = result * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\r\n    if (x & 0x10000000000 > 0)\r\n      result = result * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\r\n    if (x & 0x8000000000 > 0)\r\n      result = result * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\r\n    if (x & 0x4000000000 > 0)\r\n      result = result * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\r\n    if (x & 0x2000000000 > 0)\r\n      result = result * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\r\n    if (x & 0x1000000000 > 0)\r\n      result = result * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\r\n    if (x & 0x800000000 > 0)\r\n      result = result * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\r\n    if (x & 0x400000000 > 0)\r\n      result = result * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\r\n    if (x & 0x200000000 > 0)\r\n      result = result * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\r\n    if (x & 0x100000000 > 0)\r\n      result = result * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\r\n    if (x & 0x80000000 > 0)\r\n      result = result * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\r\n    if (x & 0x40000000 > 0)\r\n      result = result * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\r\n    if (x & 0x20000000 > 0)\r\n      result = result * 0x100000000162E42FEFB2FED257559BDAA >> 128;\r\n    if (x & 0x10000000 > 0)\r\n      result = result * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\r\n    if (x & 0x8000000 > 0)\r\n      result = result * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\r\n    if (x & 0x4000000 > 0)\r\n      result = result * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\r\n    if (x & 0x2000000 > 0)\r\n      result = result * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\r\n    if (x & 0x1000000 > 0)\r\n      result = result * 0x10000000000B17217F7D20CF927C8E94C >> 128;\r\n    if (x & 0x800000 > 0)\r\n      result = result * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\r\n    if (x & 0x400000 > 0)\r\n      result = result * 0x100000000002C5C85FDF477B662B26945 >> 128;\r\n    if (x & 0x200000 > 0)\r\n      result = result * 0x10000000000162E42FEFA3AE53369388C >> 128;\r\n    if (x & 0x100000 > 0)\r\n      result = result * 0x100000000000B17217F7D1D351A389D40 >> 128;\r\n    if (x & 0x80000 > 0)\r\n      result = result * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\r\n    if (x & 0x40000 > 0)\r\n      result = result * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\r\n    if (x & 0x20000 > 0)\r\n      result = result * 0x100000000000162E42FEFA39FE95583C2 >> 128;\r\n    if (x & 0x10000 > 0)\r\n      result = result * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\r\n    if (x & 0x8000 > 0)\r\n      result = result * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\r\n    if (x & 0x4000 > 0)\r\n      result = result * 0x10000000000002C5C85FDF473E242EA38 >> 128;\r\n    if (x & 0x2000 > 0)\r\n      result = result * 0x1000000000000162E42FEFA39F02B772C >> 128;\r\n    if (x & 0x1000 > 0)\r\n      result = result * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\r\n    if (x & 0x800 > 0)\r\n      result = result * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\r\n    if (x & 0x400 > 0)\r\n      result = result * 0x100000000000002C5C85FDF473DEA871F >> 128;\r\n    if (x & 0x200 > 0)\r\n      result = result * 0x10000000000000162E42FEFA39EF44D91 >> 128;\r\n    if (x & 0x100 > 0)\r\n      result = result * 0x100000000000000B17217F7D1CF79E949 >> 128;\r\n    if (x & 0x80 > 0)\r\n      result = result * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\r\n    if (x & 0x40 > 0)\r\n      result = result * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\r\n    if (x & 0x20 > 0)\r\n      result = result * 0x100000000000000162E42FEFA39EF366F >> 128;\r\n    if (x & 0x10 > 0)\r\n      result = result * 0x1000000000000000B17217F7D1CF79AFA >> 128;\r\n    if (x & 0x8 > 0)\r\n      result = result * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\r\n    if (x & 0x4 > 0)\r\n      result = result * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\r\n    if (x & 0x2 > 0)\r\n      result = result * 0x1000000000000000162E42FEFA39EF358 >> 128;\r\n    if (x & 0x1 > 0)\r\n      result = result * 0x10000000000000000B17217F7D1CF79AB >> 128;\r\n\r\n    result >>= 63 - (x >> 64);\r\n    require (result <= uint256 (MAX_64x64));\r\n\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate natural exponent of x.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function exp (int128 x) internal pure returns (int128) {\r\n    require (x < 0x400000000000000000); // Overflow\r\n\r\n    if (x < -0x400000000000000000) return 0; // Underflow\r\n\r\n    return exp_2 (\r\n        int128 (int256 (x) * 0x171547652B82FE1777D0FFDA0D23A7D12 >> 128));\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\r\n   * integer numbers.  Revert on overflow or when y is zero.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return unsigned 64.64-bit fixed point number\r\n   */\r\n  function divuu (uint256 x, uint256 y) private pure returns (uint128) {\r\n    require (y != 0);\r\n\r\n    uint256 result;\r\n\r\n    if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n      result = (x << 64) / y;\r\n    else {\r\n      uint256 msb = 192;\r\n      uint256 xc = x >> 192;\r\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\r\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\r\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\r\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\r\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\r\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\r\n\r\n      result = (x << 255 - msb) / ((y - 1 >> msb - 191) + 1);\r\n      require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\r\n      uint256 hi = result * (y >> 128);\r\n      uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\r\n      uint256 xh = x >> 192;\r\n      uint256 xl = x << 64;\r\n\r\n      if (xl < lo) xh -= 1;\r\n      xl -= lo; // We rely on overflow behavior here\r\n      lo = hi << 128;\r\n      if (xl < lo) xh -= 1;\r\n      xl -= lo; // We rely on overflow behavior here\r\n\r\n      assert (xh == hi >> 128);\r\n\r\n      result += xl / y;\r\n    }\r\n\r\n    require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n    return uint128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate x^y assuming 0^0 is 1, where x is unsigned 129.127 fixed point\r\n   * number and y is unsigned 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x unsigned 129.127-bit fixed point number\r\n   * @param y uint256 value\r\n   * @return unsigned 129.127-bit fixed point number\r\n   */\r\n  function powu (uint256 x, uint256 y) private pure returns (uint256) {\r\n    if (y == 0) return 0x80000000000000000000000000000000;\r\n    else if (x == 0) return 0;\r\n    else {\r\n      int256 msb = 0;\r\n      uint256 xc = x;\r\n      if (xc >= 0x100000000000000000000000000000000) { xc >>= 128; msb += 128; }\r\n      if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\r\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\r\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\r\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\r\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\r\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\r\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\r\n\r\n      int256 xe = msb - 127;\r\n      if (xe > 0) x >>= xe;\r\n      else x <<= -xe;\r\n\r\n      uint256 result = 0x80000000000000000000000000000000;\r\n      int256 re = 0;\r\n\r\n      while (y > 0) {\r\n        if (y & 1 > 0) {\r\n          result = result * x;\r\n          y -= 1;\r\n          re += xe;\r\n          if (result >=\r\n            0x8000000000000000000000000000000000000000000000000000000000000000) {\r\n            result >>= 128;\r\n            re += 1;\r\n          } else result >>= 127;\r\n          if (re < -127) return 0; // Underflow\r\n          require (re < 128); // Overflow\r\n        } else {\r\n          x = x * x;\r\n          y >>= 1;\r\n          xe <<= 1;\r\n          if (x >=\r\n            0x8000000000000000000000000000000000000000000000000000000000000000) {\r\n            x >>= 128;\r\n            xe += 1;\r\n          } else x >>= 127;\r\n          if (xe < -127) return 0; // Underflow\r\n          require (xe < 128); // Overflow\r\n        }\r\n      }\r\n\r\n      if (re > 0) result <<= re;\r\n      else if (re < 0) result >>= -re;\r\n\r\n      return result;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\r\n   * number.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @return unsigned 128-bit integer number\r\n   */\r\n  function sqrtu (uint256 x, uint256 r) private pure returns (uint128) {\r\n    if (x == 0) return 0;\r\n    else {\r\n      require (r > 0);\r\n      while (true) {\r\n        uint256 rr = x / r;\r\n        if (r == rr || r + 1 == rr) return uint128 (r);\r\n        else if (r == rr + 1) return uint128 (rr);\r\n        r = r + rr + 1 >> 1;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        uint256 c = a + b;\r\n        if (c < a) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b > a) return (false, 0);\r\n        return (true, a - b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) return (true, 0);\r\n        uint256 c = a * b;\r\n        if (c / a != b) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a / b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a % b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/CoFiXController04.sol\r\n\r\n\r\npragma solidity 0.6.12;\r\n\r\n// Controller contract to call NEST Oracle for prices, managed by governance\r\n// Governance role of this contract should be the `Timelock` contract, which is further managed by a multisig contract\r\ncontract CoFiXController04 is ICoFiXController {  // ctrl-03: change contract name to avoid truffle complaint\r\n\r\n    using SafeMath for uint256;\r\n\r\n    enum CoFiX_OP { QUERY, MINT, BURN, SWAP_WITH_EXACT, SWAP_FOR_EXACT } // operations in CoFiX\r\n\r\n    uint256 constant public AONE = 1 ether;\r\n    uint256 constant public K_BASE = 1E8;\r\n    uint256 constant public NAVPS_BASE = 1E18; // NAVPS (Net Asset Value Per Share), need accuracy\r\n    uint256 internal T = 900; // ctrl-v2: V1 (900) -> V2 (600)\r\n    uint256 internal K_EXPECTED_VALUE = 0.005*1E8; // ctrl-v2: V1 (0.0025) -> V2 (0.005)\r\n    // impact cost params\r\n    uint256 constant internal C_BUYIN_ALPHA = 25700000000000; // α=2.570e-05*1e18\r\n    uint256 constant internal C_BUYIN_BETA = 854200000000; // β=8.542e-07*1e18\r\n    uint256 constant internal C_SELLOUT_ALPHA = 117100000000000; // α=-1.171e-04*1e18\r\n    uint256 constant internal C_SELLOUT_BETA = 838600000000; // β=8.386e-07*1e18\r\n\r\n    int128 constant internal SIGMA_STEP = 0x346DC5D638865; // (0.00005*2**64).toString(16), 0.00005 as 64.64-bit fixed point\r\n    int128 constant internal ZERO_POINT_FIVE = 0x8000000000000000; // (0.5*2**64).toString(16)\r\n    uint256 constant PRICE_DEVIATION = 10;  // price deviation < 10%\r\n\r\n    mapping(address => uint32[3]) internal KInfoMap; // gas saving, index [0] is k vlaue, index [1] is updatedAt, index [2] is theta\r\n    mapping(address => bool) public callerAllowed;\r\n\r\n    // managed by governance\r\n    address public governance;\r\n    address public immutable oracle;\r\n    address public immutable nestToken;\r\n    address public immutable factory;\r\n    address public kTable;\r\n    uint256 public timespan = 14;\r\n    uint256 public kRefreshInterval = 5 minutes;\r\n    uint256 public DESTRUCTION_AMOUNT = 0 ether; // from nest oracle\r\n    int128 public MAX_K0 = 0xCCCCCCCCCCCCD00; // (0.05*2**64).toString(16)\r\n    int128 public GAMMA = 0x8000000000000000; // (0.5*2**64).toString(16)\r\n\r\n    struct OracleParams {\r\n        uint256 ethAmount;\r\n        uint256 erc20Amount;\r\n        uint256 blockNum;\r\n        uint256 K;\r\n        uint256 T; // time offset\r\n        uint256 avgPrice; // average price\r\n        uint256 theta;\r\n        uint256 sigma;\r\n        uint256 tIdx;\r\n        uint256 sigmaIdx;\r\n    }\r\n\r\n    modifier onlyGovernance() {\r\n        require(msg.sender == governance, \"CoFiXCtrl: !governance\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _oracle, address _nest, address _factory, address _kTable) public {\r\n        governance = msg.sender;\r\n        oracle = _oracle;\r\n        nestToken = _nest;\r\n        factory = _factory;\r\n        kTable = _kTable;\r\n\r\n        // add previous pair as caller\r\n        ICoFiXFactory cFactory = ICoFiXFactory(_factory);\r\n        uint256 pairCnt = cFactory.allPairsLength();\r\n        for (uint256 i = 0; i < pairCnt; i++) {\r\n            address pair = cFactory.allPairs(i);\r\n            callerAllowed[pair] = true;\r\n        }\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    /* setters for protocol governance */\r\n    function setGovernance(address _new) external onlyGovernance {\r\n        governance = _new;\r\n        emit NewGovernance(_new);\r\n    }\r\n\r\n    function setKTable(address _kTable) external onlyGovernance {\r\n        kTable = _kTable;\r\n        emit NewKTable(_kTable);\r\n    }    \r\n\r\n    function setTimespan(uint256 _timeSpan) external onlyGovernance {\r\n        timespan = _timeSpan;\r\n        emit NewTimespan(_timeSpan);\r\n    }\r\n\r\n    function setKRefreshInterval(uint256 _interval) external onlyGovernance {\r\n        kRefreshInterval = _interval;\r\n        emit NewKRefreshInterval(_interval);\r\n    }\r\n\r\n    function setOracleDestructionAmount(uint256 _amount) external onlyGovernance {\r\n        DESTRUCTION_AMOUNT = _amount;\r\n    }\r\n\r\n    function setTLimit(uint256 _T) external onlyGovernance { // ctrl-v2: new setter for T\r\n        T = _T;\r\n    }\r\n\r\n    function setK(address token, uint32 k) external onlyGovernance { // ctrl-v2: new setter for K, adjustable by governance\r\n        K_EXPECTED_VALUE = uint256(k);\r\n        emit NewK(token, k); // new event for setting K\r\n    }\r\n\r\n    function setTheta(address token, uint32 theta) external onlyGovernance {\r\n        KInfoMap[token][2] = theta;\r\n        emit NewTheta(token, theta);\r\n    }\r\n\r\n    function addCaller(address caller) external override {\r\n        require(msg.sender == factory || msg.sender == governance, \"CoFiXCtrl: only factory or gov\");\r\n        callerAllowed[caller] = true;\r\n    }\r\n\r\n    // Calc variance of price and K in CoFiX is very expensive\r\n    // We use expected value of K based on statistical calculations here to save gas\r\n    // In the near future, NEST could provide the variance of price directly. We will adopt it then.\r\n    // We can make use of `data` bytes in the future\r\n    function queryOracle(address token, uint8 op, bytes memory data) external override payable returns (uint256 _k, uint256 _ethAmount, uint256 _erc20Amount, uint256 _blockNum, uint256 _theta) {\r\n        require(callerAllowed[msg.sender], \"CoFiXCtrl: caller not allowed\");\r\n        (_k, _ethAmount, _erc20Amount, _blockNum) = getLatestPrice(token);\r\n        CoFiX_OP cop = CoFiX_OP(op);\r\n        uint256 impactCost;\r\n        if (cop == CoFiX_OP.SWAP_WITH_EXACT) {\r\n            impactCost = calcImpactCostFor_SWAP_WITH_EXACT(token, data, _ethAmount, _erc20Amount);\r\n        } else if (cop == CoFiX_OP.SWAP_FOR_EXACT) {\r\n            revert(\"disabled experimental feature!\"); // ctrl-v2: disable swapForExact function\r\n         } else if (cop == CoFiX_OP.BURN) {\r\n            impactCost = calcImpactCostFor_BURN(token, data, _ethAmount, _erc20Amount);\r\n        }\r\n        _k = _k.add(impactCost); // ctrl-v2: adjustable K + impactCost is the final K\r\n        _theta = KInfoMap[token][2];\r\n        return (_k, _ethAmount, _erc20Amount, _blockNum, _theta);\r\n    }\r\n\r\n    function calcImpactCostFor_BURN(address token, bytes memory data, uint256 ethAmount, uint256 erc20Amount) public view returns (uint256 impactCost) {\r\n        // bytes memory data = abi.encode(msg.sender, outToken, to, liquidity);\r\n        (, address outToken, , uint256 liquidity) = abi.decode(data, (address, address, address, uint256));\r\n        // calc real vol by liquidity * np\r\n        uint256 navps = ICoFiXPair(msg.sender).getNAVPerShare(ethAmount, erc20Amount); // pair call controller, msg.sender is pair\r\n        uint256 vol = liquidity.mul(navps).div(NAVPS_BASE);\r\n        if (outToken != token) {\r\n            // buy in ETH, outToken is ETH\r\n            return impactCostForBuyInETH(vol);\r\n        }\r\n        // sell out liquidity, outToken is token, take this as sell out ETH and get token\r\n        return impactCostForSellOutETH(vol);\r\n    }\r\n\r\n    function calcImpactCostFor_SWAP_WITH_EXACT(address token, bytes memory data, uint256 ethAmount, uint256 erc20Amount) public pure returns (uint256 impactCost) {\r\n        (, address outToken, , uint256 amountIn) = abi.decode(data, (address, address, address, uint256));\r\n        if (outToken != token) {\r\n            // buy in ETH, outToken is ETH, amountIn is token\r\n            // convert to amountIn in ETH\r\n            uint256 vol = uint256(amountIn).mul(ethAmount).div(erc20Amount);\r\n            return impactCostForBuyInETH(vol);\r\n        }\r\n        // sell out ETH, amountIn is ETH\r\n        return impactCostForSellOutETH(amountIn);\r\n    }\r\n\r\n    function calcImpactCostFor_SWAP_FOR_EXACT(address token, bytes memory data, uint256 ethAmount, uint256 erc20Amount) public pure returns (uint256 impactCost) {\r\n        (, address outToken, uint256 amountOutExact,) = abi.decode(data, (address, address, uint256, address));\r\n        if (outToken != token) {\r\n            // buy in ETH, outToken is ETH, amountOutExact is ETH\r\n            return impactCostForBuyInETH(amountOutExact);\r\n        }\r\n        // sell out ETH, amountIn is ETH, amountOutExact is token\r\n        // convert to amountOutExact in ETH\r\n        uint256 vol = uint256(amountOutExact).mul(ethAmount).div(erc20Amount);\r\n        return impactCostForSellOutETH(vol);\r\n    }\r\n\r\n    // impact cost\r\n    // - C = 0, if VOL < 500\r\n    // - C = α + β * VOL, if VOL >= 500\r\n\r\n    // α=2.570e-05，β=8.542e-07\r\n    function impactCostForBuyInETH(uint256 vol) public pure returns (uint256 impactCost) {\r\n        if (vol < 500 ether) {\r\n            return 0;\r\n        }\r\n        // return C_BUYIN_ALPHA.add(C_BUYIN_BETA.mul(vol).div(1e18)).mul(1e8).div(1e18);\r\n        return C_BUYIN_ALPHA.add(C_BUYIN_BETA.mul(vol).div(1e18)).div(1e10); // combine mul div\r\n    }\r\n\r\n    // α=-1.171e-04，β=8.386e-07\r\n    function impactCostForSellOutETH(uint256 vol) public pure returns (uint256 impactCost) {\r\n        if (vol < 500 ether) {\r\n            return 0;\r\n        }\r\n        // return (C_SELLOUT_BETA.mul(vol).div(1e18)).sub(C_SELLOUT_ALPHA).mul(1e8).div(1e18);\r\n        return (C_SELLOUT_BETA.mul(vol).div(1e18)).sub(C_SELLOUT_ALPHA).div(1e10); // combine mul div\r\n    }\r\n\r\n    function getKInfo(address token) external view returns (uint32 k, uint32 updatedAt, uint32 theta) {\r\n        // ctrl-v3: load from storage instead of constant value\r\n        uint32 kStored = KInfoMap[token][0];\r\n        if (kStored != 0) {\r\n            k = kStored;\r\n        } else {\r\n            k = uint32(K_EXPECTED_VALUE);\r\n        }\r\n        updatedAt = KInfoMap[token][1];\r\n        theta = KInfoMap[token][2];\r\n    }\r\n\r\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\r\n    function sqrt(uint y) internal pure returns (uint z) {\r\n        if (y > 3) {\r\n            z = y;\r\n            uint x = y / 2 + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n    }\r\n\r\n    function getLatestPrice(address token) internal returns (uint256 _k, uint256 _ethAmount, uint256 _erc20Amount, uint256 _blockNum) {\r\n        uint256 _balanceBefore = address(this).balance;\r\n        OracleParams memory _op;\r\n        // query oracle\r\n        ///  latestPriceBlockNumber The block number of latest price\r\n        ///  latestPriceValue The token latest price. (1eth equivalent to (price) token)\r\n        ///  triggeredPriceBlockNumber The block number of triggered price\r\n        ///  triggeredPriceValue The token triggered price. (1eth equivalent to (price) token)\r\n        ///  triggeredAvgPrice Average price\r\n        ///  triggeredSigmaSQ The square of the volatility (18 decimal places).\r\n        (\r\n            _op.blockNum, \r\n            _op.erc20Amount,\r\n            /* uint triggeredPriceBlockNumber */,\r\n            /* uint triggeredPriceValue */,\r\n            _op.avgPrice,\r\n            _op.sigma \r\n        ) = INestPriceFacade(oracle).latestPriceAndTriggeredPriceInfo{value: msg.value}(token, address(this));\r\n        _op.sigma = sqrt(_op.sigma.mul(1e18));\r\n        _op.ethAmount = 1 ether;\r\n        \r\n        // validate T\r\n        _op.T = block.number.sub(_op.blockNum).mul(timespan);\r\n        require(_op.T < T, \"CoFiXCtrl: oralce price outdated\"); // ctrl-v2: adjustable T\r\n        \r\n        {\r\n            // check if the price is steady\r\n            uint256 price;\r\n            bool isDeviated;\r\n            price = _op.erc20Amount.mul(1e18).div(_op.ethAmount);\r\n            uint256 diff = price > _op.avgPrice? (price - _op.avgPrice) : (_op.avgPrice - price);\r\n            isDeviated = (diff.mul(100) < _op.avgPrice.mul(PRICE_DEVIATION))? false : true;\r\n            require(isDeviated == false, \"CoFiXCtrl: price deviation\"); // validate\r\n        }\r\n\r\n        // calc K\r\n        // int128 K0; // K0AndK[0]\r\n        // int128 K; // K0AndK[1]\r\n        int128[2] memory K0AndK;\r\n\r\n        {\r\n            _op.tIdx = (_op.T.add(5)).div(10); // rounding to the nearest\r\n            _op.sigmaIdx = ABDKMath64x64.toUInt(\r\n                        ABDKMath64x64.add(\r\n                            ABDKMath64x64.div(int128(_op.sigma), SIGMA_STEP), // _sigma / 0.00005, e.g. (0.00098/0.00005)=9.799 => 9\r\n                            ZERO_POINT_FIVE // e.g. (0.00098/0.00005)+0.5=20.0999 => 20\r\n                        )\r\n                    );\r\n            if (_op.sigmaIdx > 0) {\r\n                _op.sigmaIdx = _op.sigmaIdx.sub(1);\r\n            }\r\n\r\n            // getK0(uint256 tIdx, uint256 sigmaIdx)\r\n            // K0 is K0AndK[0]\r\n            K0AndK[0] = ICoFiXKTable(kTable).getK0(\r\n                _op.tIdx, \r\n                _op.sigmaIdx\r\n            );\r\n\r\n            // K = gamma * K0\r\n            K0AndK[1] = ABDKMath64x64.mul(GAMMA, K0AndK[0]);\r\n\r\n            emit NewK(token, K0AndK[1], int128(_op.sigma), _op.T, _op.ethAmount, _op.erc20Amount, _op.blockNum, _op.tIdx, _op.sigmaIdx, K0AndK[0]);\r\n        }\r\n\r\n        require(K0AndK[0] <= MAX_K0, \"CoFiXCtrl: K0\");\r\n\r\n        {\r\n            // return oracle fee change\r\n            // we could decode data in the future to pay the fee change and mining award token directly to reduce call cost\r\n            // TransferHelper.safeTransferETH(payback, msg.value.sub(_balanceBefore.sub(address(this).balance)));\r\n            uint256 oracleFeeChange = msg.value.sub(_balanceBefore.sub(address(this).balance));\r\n            if (oracleFeeChange > 0) TransferHelper.safeTransferETH(msg.sender, oracleFeeChange);\r\n            _k = ABDKMath64x64.toUInt(ABDKMath64x64.mul(K0AndK[1], ABDKMath64x64.fromUInt(K_BASE)));\r\n\r\n            KInfoMap[token][0] = uint32(_k); // k < MAX_K << uint32(-1)\r\n            KInfoMap[token][1] = uint32(block.timestamp); // 2106\r\n            return (_k, _op.ethAmount, _op.erc20Amount, _op.blockNum);\r\n        }\r\n    }\r\n    \r\n   /**\r\n    * @notice Calc K value\r\n    * @param vola The square of the volatility (18 decimal places).\r\n    * @param bn The block number when (ETH, TOKEN) price takes into effective\r\n    * @return k The K value\r\n    */\r\n    function calcK(uint256 vola, uint256 bn) external view returns (uint32 k) {\r\n        // int128 K0; // K0AndK[0]\r\n        // int128 K; // K0AndK[1]\r\n        vola = sqrt(vola.mul(1e18));\r\n        int128[2] memory K0AndK;\r\n        uint256 _T = block.number.sub(bn).mul(timespan);\r\n\r\n        uint256 tIdx = (_T.add(5)).div(10); // rounding to the nearest\r\n        uint256 sigmaIdx = ABDKMath64x64.toUInt(\r\n                    ABDKMath64x64.add(\r\n                        ABDKMath64x64.div(int128(vola), SIGMA_STEP), // _sigma / 0.00005, e.g. (0.00098/0.00005)=9.799 => 9\r\n                        ZERO_POINT_FIVE // e.g. (0.00098/0.00005)+0.5=20.0999 => 20\r\n                    )\r\n                );\r\n        if (sigmaIdx > 0) {\r\n            sigmaIdx = sigmaIdx.sub(1);\r\n        }\r\n\r\n        // getK0(uint256 tIdx, uint256 sigmaIdx)\r\n        // K0 is K0AndK[0]\r\n        K0AndK[0] = ICoFiXKTable(kTable).getK0(\r\n            tIdx, \r\n            sigmaIdx\r\n        );\r\n\r\n        // K = gamma * K0\r\n        K0AndK[1] = ABDKMath64x64.mul(GAMMA, K0AndK[0]);\r\n\r\n        k = uint32(ABDKMath64x64.toUInt(ABDKMath64x64.mul(K0AndK[1], ABDKMath64x64.fromUInt(K_BASE))));\r\n    }\r\n\r\n    // ctrl-v2: remove unused code bellow according to PeckShield's advice\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_nest\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_kTable\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"int128\",\"name\":\"_gamma\",\"type\":\"int128\"}],\"name\":\"NewGamma\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"NewGovernance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int128\",\"name\":\"K\",\"type\":\"int128\"},{\"indexed\":false,\"internalType\":\"int128\",\"name\":\"sigma\",\"type\":\"int128\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"T\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"erc20Amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tIdx\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sigmaIdx\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int128\",\"name\":\"K0\",\"type\":\"int128\"}],\"name\":\"NewK\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"k\",\"type\":\"uint32\"}],\"name\":\"NewK\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"int128\",\"name\":\"maxK0\",\"type\":\"int128\"}],\"name\":\"NewKLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_interval\",\"type\":\"uint256\"}],\"name\":\"NewKRefreshInterval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_kTable\",\"type\":\"address\"}],\"name\":\"NewKTable\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_priceOracle\",\"type\":\"address\"}],\"name\":\"NewOracle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"theta\",\"type\":\"uint32\"}],\"name\":\"NewTheta\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timeSpan\",\"type\":\"uint256\"}],\"name\":\"NewTimespan\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"AONE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DESTRUCTION_AMOUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GAMMA\",\"outputs\":[{\"internalType\":\"int128\",\"name\":\"\",\"type\":\"int128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"K_BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_K0\",\"outputs\":[{\"internalType\":\"int128\",\"name\":\"\",\"type\":\"int128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NAVPS_BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"addCaller\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"erc20Amount\",\"type\":\"uint256\"}],\"name\":\"calcImpactCostFor_BURN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"impactCost\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"erc20Amount\",\"type\":\"uint256\"}],\"name\":\"calcImpactCostFor_SWAP_FOR_EXACT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"impactCost\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"erc20Amount\",\"type\":\"uint256\"}],\"name\":\"calcImpactCostFor_SWAP_WITH_EXACT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"impactCost\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"vola\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bn\",\"type\":\"uint256\"}],\"name\":\"calcK\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"k\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"callerAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getKInfo\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"k\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"updatedAt\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"theta\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"vol\",\"type\":\"uint256\"}],\"name\":\"impactCostForBuyInETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"impactCost\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"vol\",\"type\":\"uint256\"}],\"name\":\"impactCostForSellOutETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"impactCost\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kRefreshInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kTable\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nestToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"op\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"queryOracle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_k\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_erc20Amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_blockNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_theta\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"setGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"k\",\"type\":\"uint32\"}],\"name\":\"setK\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_interval\",\"type\":\"uint256\"}],\"name\":\"setKRefreshInterval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_kTable\",\"type\":\"address\"}],\"name\":\"setKTable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setOracleDestructionAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_T\",\"type\":\"uint256\"}],\"name\":\"setTLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"theta\",\"type\":\"uint32\"}],\"name\":\"setTheta\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_timeSpan\",\"type\":\"uint256\"}],\"name\":\"setTimespan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timespan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"CoFiXController04","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"6666","ConstructorArguments":"000000000000000000000000b5d2890c061c321a5b6a4a4254bb1522425baf0a00000000000000000000000004abeda201850ac0124161f037efd70c74ddc74c00000000000000000000000066c64ecc3a6014733325a8f2ebee46b4ca3ed55000000000000000000000000075e360be6248bd46030c6818624a09403ef5ec21","EVMVersion":"istanbul","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://ac1e91be6db81d145c339901025f19f9d94ec07580a79652bade337cc2d7d3f4"}]}