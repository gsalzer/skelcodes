{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/AtomReader.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Licence to kill\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./interfaces/IPOWNFTPartial.sol\\\";\\r\\nimport \\\"./interfaces/IAtomReader.sol\\\";\\r\\n\\r\\n/// @title POWNFT Atom Reader\\r\\n/// @author AnAllergyToAnalogy\\r\\ncontract AtomReader is IAtomReader{\\r\\n\\r\\n\\r\\n    //Simplified version of POWNFT interface, with just the functions needed for this.\\r\\n    IPOWNFTPartial POWNFT;\\r\\n\\r\\n    /// @dev Takes POWNFT main contract address as only argument.\\r\\n    constructor(address mainContract){\\r\\n        POWNFT = IPOWNFTPartial(mainContract);\\r\\n    }\\r\\n\\r\\n    function getAtomData(uint _tokenId) override public view returns(uint atomicNumber, int8 ionCharge){\\r\\n        bytes32 _hash = POWNFT.hashOf(_tokenId);\\r\\n        atomicNumber = calculateAtomicNumber(_tokenId, _hash);\\r\\n        return (\\r\\n            atomicNumber,\\r\\n            calculateIonCharge(atomicNumber,_hash)\\r\\n        );\\r\\n    }\\r\\n    function getAtomicNumber(uint _tokenId) override  public view returns(uint){\\r\\n        bytes32 _hash = POWNFT.hashOf(_tokenId);\\r\\n\\r\\n        return calculateAtomicNumber(_tokenId,_hash);\\r\\n    }\\r\\n    function getIonCharge(uint _tokenId) override public view returns(int8){\\r\\n        bytes32 _hash = POWNFT.hashOf(_tokenId);\\r\\n        uint atomicNumber = getAtomicNumber(_tokenId);\\r\\n\\r\\n        return calculateIonCharge(atomicNumber,_hash);\\r\\n    }\\r\\n    function getIons(uint atomicNumber) override public pure returns(int8[] memory){\\r\\n        int8[] memory ions;\\r\\n\\r\\n        if(atomicNumber == 1 || atomicNumber == 3 || atomicNumber == 11 || atomicNumber == 19 || atomicNumber == 37 || atomicNumber == 47 || atomicNumber == 55 || atomicNumber == 87){\\r\\n            ions = new int8[](1);\\r\\n            ions[0] = 1;\\r\\n\\r\\n        }else if(atomicNumber == 4 || atomicNumber == 12 || atomicNumber == 20 || atomicNumber == 30 || atomicNumber == 38 || atomicNumber == 48 || atomicNumber == 56 || atomicNumber == 80 ||\\r\\n            atomicNumber == 88){\\r\\n            ions = new int8[](1);\\r\\n            ions[0] = 2;\\r\\n\\r\\n        }else if(atomicNumber == 13 || atomicNumber == 21 || atomicNumber == 31 || atomicNumber == 39 || atomicNumber == 45 || atomicNumber == 49 || atomicNumber == 57 || atomicNumber == 58 ||\\r\\n        atomicNumber == 59 || atomicNumber == 60 || atomicNumber == 61 || atomicNumber == 64 || atomicNumber == 65 || atomicNumber == 66 || atomicNumber == 67 || atomicNumber == 68 || atomicNumber == 69 || atomicNumber == 70 || atomicNumber == 71 || atomicNumber == 89 || atomicNumber == 96 || atomicNumber == 97 || atomicNumber == 98 || atomicNumber == 99 || atomicNumber ==\\r\\n        100 || atomicNumber == 103){\\r\\n            ions = new int8[](1);\\r\\n            ions[0] = 3;\\r\\n\\r\\n        }else if(atomicNumber == 32 || atomicNumber == 40 || atomicNumber == 72 || atomicNumber == 76 || atomicNumber == 77 || atomicNumber == 90 || atomicNumber == 94){\\r\\n            ions = new int8[](1);\\r\\n            ions[0] = 4;\\r\\n\\r\\n        }else if(atomicNumber == 73 || atomicNumber == 93){\\r\\n            ions = new int8[](1);\\r\\n            ions[0] = 5;\\r\\n\\r\\n        }else if(atomicNumber == 42 || atomicNumber == 74){\\r\\n            ions = new int8[](1);\\r\\n            ions[0] = 6;\\r\\n\\r\\n        }else if(atomicNumber == 43 || atomicNumber == 75){\\r\\n            ions = new int8[](1);\\r\\n            ions[0] = 7;\\r\\n\\r\\n        }else if(atomicNumber == 7 || atomicNumber == 15 || atomicNumber == 33){\\r\\n            ions = new int8[](1);\\r\\n            ions[0] = -3;\\r\\n\\r\\n        }else if(atomicNumber == 8 || atomicNumber == 16 || atomicNumber == 34 || atomicNumber == 52){\\r\\n            ions = new int8[](1);\\r\\n            ions[0] = -2;\\r\\n\\r\\n        }else if(atomicNumber == 9 || atomicNumber == 17 || atomicNumber == 35 || atomicNumber == 53 || atomicNumber == 85){\\r\\n            ions = new int8[](1);\\r\\n            ions[0] = -1;\\r\\n\\r\\n        }else if(atomicNumber == 22 || atomicNumber == 44 || atomicNumber == 95){\\r\\n            ions = new int8[](2);\\r\\n            ions[0] = 3;\\r\\n            ions[1] = 4;\\r\\n\\r\\n        }else if(atomicNumber == 23 || atomicNumber == 41 || atomicNumber == 51 || atomicNumber == 83){\\r\\n            ions = new int8[](2);\\r\\n            ions[0] = 3;\\r\\n            ions[1] = 5;\\r\\n\\r\\n        }else if(atomicNumber == 24 || atomicNumber == 26 || atomicNumber == 27 || atomicNumber == 28 || atomicNumber == 62 || atomicNumber == 63 || atomicNumber == 101 || atomicNumber == 102){\\r\\n            ions = new int8[](2);\\r\\n            ions[0] = 2;\\r\\n            ions[1] = 3;\\r\\n\\r\\n        }else if(atomicNumber == 25 || atomicNumber == 46 || atomicNumber == 50 || atomicNumber == 78 || atomicNumber == 82 || atomicNumber == 84){\\r\\n            ions = new int8[](2);\\r\\n            ions[0] = 2;\\r\\n            ions[1] = 4;\\r\\n\\r\\n        }else if(atomicNumber == 29){\\r\\n            ions = new int8[](2);\\r\\n            ions[0] = 1;\\r\\n            ions[1] = 2;\\r\\n\\r\\n        }else if(atomicNumber == 79 || atomicNumber == 81){\\r\\n            ions = new int8[](2);\\r\\n            ions[0] = 1;\\r\\n            ions[1] = 3;\\r\\n\\r\\n        }else if(atomicNumber == 91){\\r\\n            ions = new int8[](2);\\r\\n            ions[0] = 4;\\r\\n            ions[1] = 5;\\r\\n\\r\\n        }else if(atomicNumber == 92){\\r\\n            ions = new int8[](2);\\r\\n            ions[0] = 4;\\r\\n            ions[1] = 6;\\r\\n        }\\r\\n        return ions;\\r\\n    }\\r\\n    function isValidIonCharge(uint atomicNumber, int8 ionCharge) override public pure returns(bool){\\r\\n        int8[] memory ions = getIons(atomicNumber);\\r\\n\\r\\n        for(uint i = 0; i < ions.length; i++){\\r\\n            if(ions[i] == ionCharge){\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n    function canIonise(uint atomicNumber) override public pure returns(bool){\\r\\n        int8[] memory ions = getIons(atomicNumber);\\r\\n        return ions.length > 0;\\r\\n    }\\r\\n\\r\\n    /// @notice Calculate generation of specified Atom\\r\\n    /// @param _tokenId TokenId of the Atom\\r\\n    /// @return generation Generation of the Atom\\r\\n    function generationOf(uint _tokenId) private pure returns(uint generation){\\r\\n        for(generation = 0; _tokenId > 0; generation++){\\r\\n            _tokenId /= 2;\\r\\n        }\\r\\n        return generation - 1;\\r\\n    }\\r\\n\\r\\n    /// @notice Round up to calculate \\\"ceil\\\".\\r\\n    /// @dev Because the metadata uses Javascript's Math.ceil\\r\\n    /// @param a Number to round\\r\\n    /// @param m Round up to the nearest 'm'\\r\\n    /// @return Rounded up 'a'\\r\\n    function ceil(uint a, uint m) internal pure returns (uint ) {\\r\\n        return ((a + m - 1) / m) * m;\\r\\n    }\\r\\n\\r\\n    /// @notice Calculate ionic charge for a given Element and token hash\\r\\n    /// @dev The reason it needs both is that atomic number is partially based on tokenId, so just passing the hash would require recalculation in instances where it wasn't necessary.\\r\\n    /// @param atomicNumber Atomic number of Element\\r\\n    /// @param _hash Hash of Atom\\r\\n    /// @return Ionic charge for given Element for specified hash\\r\\n    function calculateIonCharge(uint atomicNumber, bytes32 _hash) private pure returns(int8){\\r\\n        bytes32 divisor1 = 0x0000000000010000000000000000000000000000000000000000000000000000;\\r\\n        uint salt1 = uint(_hash)/uint(divisor1);\\r\\n        salt1 %= 256;\\r\\n\\r\\n        if(salt1 % 3 != 0){\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        bytes32 divisor2 = 0x0000000000000100000000000000000000000000000000000000000000000000;\\r\\n        uint salt2 = uint(_hash)/uint(divisor2);\\r\\n        salt2 %= 256;\\r\\n\\r\\n        int8[] memory ions = getIons(atomicNumber);\\r\\n\\r\\n\\r\\n        if(ions.length == 0) return 0;\\r\\n\\r\\n        uint ion_index = salt2%ions.length;\\r\\n\\r\\n        return ions[ion_index];\\r\\n\\r\\n    }\\r\\n\\r\\n    /// @notice Calculate atomic number for a given tokenId and token hash\\r\\n    /// @dev The reason it needs both is that atomic number is partially based on tokenId.\\r\\n    /// @param _tokenId The tokenId of the Atom\\r\\n    /// @param _hash Hash of Atom\\r\\n    /// @return Atomic number of the given Atom\\r\\n    function calculateAtomicNumber(uint _tokenId, bytes32 _hash) private pure returns(uint){\\r\\n        if(_tokenId == 1) return 0;\\r\\n\\r\\n        bytes32 divisor = 0x0000000001000000000000000000000000000000000000000000000000000000;\\r\\n        uint salt = uint(_hash)/uint(divisor);\\r\\n\\r\\n        //                    0x111122223333444455556666777788889999AAAABBBBCCCCDDDDEEEEFFFFCCCC;\\r\\n        uint generation = generationOf(_tokenId);\\r\\n        uint max;\\r\\n        if(generation >= 13){\\r\\n            max = 118;\\r\\n        }else if(generation >= 11){\\r\\n            max = 86;\\r\\n        }else if(generation >= 9){\\r\\n            max = 54;\\r\\n        }else if(generation >= 7){\\r\\n            max = 36;\\r\\n        }else if(generation >= 5){\\r\\n            max = 18;\\r\\n        }else if(generation >= 3){\\r\\n            max = 10;\\r\\n        }else if(generation >= 1){\\r\\n            max = 2;\\r\\n        }\\r\\n\\r\\n        uint gg;\\r\\n        if(generation >= 8){\\r\\n            gg = 2;\\r\\n        }else{\\r\\n            gg = 1;\\r\\n        }\\r\\n\\r\\n\\r\\n        uint decimal = 10000000000000000;\\r\\n        uint divisor2 = uint(0xFFFFFFFFFF);\\r\\n\\r\\n\\r\\n        uint unrounded = max * decimal * (salt ** gg) / (divisor2 ** gg);\\r\\n        uint rounded = ceil(\\r\\n            unrounded,\\r\\n            decimal\\r\\n        );\\r\\n        return rounded/decimal;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IPOWNFTPartial.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Lapdog millionaire\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IPOWNFTPartial{\\r\\n    function UNMIGRATED() external view returns(uint);\\r\\n    function hashOf(uint _tokenId) external view returns(bytes32);\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function ownerOf(uint256 _tokenId) external view returns(address);\\r\\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IAtomReader.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Licence to thrill\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/// @title POWNFT Atom Reader\\r\\n/// @author AnAllergyToAnalogy\\r\\n/// @notice On-chain calculation atomic number and ionisation data about POWNFT Atoms. Replicates functionality done off-chain for metadata.\\r\\ninterface IAtomReader{\\r\\n\\r\\n    /// @notice Get atomic number and ionic charge of a specified POWNFT Atom\\r\\n    /// @dev Gets Atom hash from POWNFT contract, so will throw for _tokenId of non-existent token.\\r\\n    /// @param _tokenId TokenId of the Atom to query\\r\\n    /// @return atomicNumber Atomic number of the Atom\\r\\n    /// @return ionCharge Ionic charge of the Atom\\r\\n    function getAtomData(uint _tokenId) external view returns(uint atomicNumber, int8 ionCharge);\\r\\n\\r\\n    /// @notice Get atomic number of a specified POWNFT Atom\\r\\n    /// @dev Gets Atom hash from POWNFT contract, so will throw for _tokenId of non-existent token.\\r\\n    /// @param _tokenId TokenId of the Atom to query\\r\\n    /// @return Atomic number of the Atom\\r\\n    function getAtomicNumber(uint _tokenId) external view returns(uint);\\r\\n\\r\\n    /// @notice Get ionic charge of a specified POWNFT Atom\\r\\n    /// @dev Gets Atom hash from POWNFT contract, so will throw for _tokenId of non-existent token.\\r\\n    /// @param _tokenId TokenId of the Atom to query\\r\\n    /// @return ionic charge of the Atom\\r\\n    function getIonCharge(uint _tokenId) external view returns(int8);\\r\\n\\r\\n    /// @notice Get array of all possible ions for a specified element\\r\\n    /// @param atomicNumber Atomic number of element to query\\r\\n    /// @return Array of possible ionic charges\\r\\n    function getIons(uint atomicNumber) external pure returns(int8[] memory);\\r\\n\\r\\n    /// @notice Check if a given element can have a particular ionic charge\\r\\n    /// @param atomicNumber Atomic number of element to query\\r\\n    /// @param ionCharge Ionic charge to check\\r\\n    /// @return True if this element can have this ion, false otherwise.\\r\\n    function isValidIonCharge(uint atomicNumber, int8 ionCharge) external pure returns(bool);\\r\\n\\r\\n    /// @notice Check if a given element has any potential ions\\r\\n    /// @param atomicNumber Atomic number of element to query\\r\\n    /// @return True if this element can ionise, false otherwise.\\r\\n    function canIonise(uint atomicNumber) external pure returns(bool);\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mainContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"atomicNumber\",\"type\":\"uint256\"}],\"name\":\"canIonise\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getAtomData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"atomicNumber\",\"type\":\"uint256\"},{\"internalType\":\"int8\",\"name\":\"ionCharge\",\"type\":\"int8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getAtomicNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getIonCharge\",\"outputs\":[{\"internalType\":\"int8\",\"name\":\"\",\"type\":\"int8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"atomicNumber\",\"type\":\"uint256\"}],\"name\":\"getIons\",\"outputs\":[{\"internalType\":\"int8[]\",\"name\":\"\",\"type\":\"int8[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"atomicNumber\",\"type\":\"uint256\"},{\"internalType\":\"int8\",\"name\":\"ionCharge\",\"type\":\"int8\"}],\"name\":\"isValidIonCharge\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"AtomReader","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000009abb7bddc43fa67c76a62d8c016513827f59be1b","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}