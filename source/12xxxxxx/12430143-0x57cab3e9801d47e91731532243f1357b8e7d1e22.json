{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary EnumerableSet {\r\n    struct Set {\r\n        bytes32[] _values;\r\n        mapping(bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) {\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            bytes32 lastvalue = set._values[lastIndex];\r\n\r\n            set._values[toDeleteIndex] = lastvalue;\r\n\r\n            set._indexes[lastvalue] = toDeleteIndex + 1;\r\n\r\n            set._values.pop();\r\n\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function _contains(Set storage set, bytes32 value)\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n    function _at(Set storage set, uint256 index)\r\n        private\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        require(\r\n            set._values.length > index,\r\n            \"EnumerableSet: index out of bounds\"\r\n        );\r\n        return set._values[index];\r\n    }\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    function add(AddressSet storage set, address value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return _add(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n    function remove(AddressSet storage set, address value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return _remove(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n    function contains(AddressSet storage set, address value)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _contains(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    function at(AddressSet storage set, uint256 index)\r\n        internal\r\n        view\r\n        returns (address)\r\n    {\r\n        return address(uint256(_at(set._inner, index)));\r\n    }\r\n\r\n    // UintSet\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    function remove(UintSet storage set, uint256 value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    function contains(UintSet storage set, uint256 value)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    function at(UintSet storage set, uint256 index)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    // ERC20 Optional Views\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    // Views\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    // Mutative functions\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    // Events\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\ncontract PleStaking {\r\n    using SafeMath for uint256;\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n    event RewardsTransferred(address holder, uint256 amount);\r\n\r\n    IERC20 public tokenContract;\r\n\r\n    address public tokenFeeAddress;\r\n\r\n    // reward rate 40.00% per year\r\n    uint256 public constant rewardRate = 4000;\r\n    uint256 public constant rewardInterval = 365 days;\r\n\r\n    // staking fee 1.50 percent\r\n    uint256 public constant stakingFeeRate = 150;\r\n\r\n    // unstaking fee 0.50 percent\r\n    uint256 public constant unstakingFeeRate = 50;\r\n\r\n    uint256 public totalClaimedRewards = 0;\r\n\r\n    EnumerableSet.AddressSet private holders;\r\n\r\n    mapping(address => uint256) public depositedTokens;\r\n    mapping(address => uint256) public stakingTime;\r\n    mapping(address => uint256) public lastClaimedTime;\r\n    mapping(address => uint256) public totalEarnedTokens;\r\n\r\n    constructor(address _tokenAddress, address _tokenFeeAddress) public {\r\n        tokenContract = IERC20(_tokenAddress);\r\n        tokenFeeAddress = _tokenFeeAddress;\r\n    }\r\n\r\n    function getBalance() private view returns (uint256) {\r\n        return tokenContract.balanceOf(address(this));\r\n    }\r\n\r\n    function getRewardToken() private view returns (uint256) {\r\n        uint256 totalDepositedAmount = 0;\r\n        uint256 length = getNumberOfHolders();\r\n        for (uint256 i = 0; i < length; i = i.add(1)) {\r\n            uint256 depositedAmount = depositedTokens[holders.at(i)];\r\n            totalDepositedAmount = totalDepositedAmount.add(depositedAmount);\r\n        }\r\n\r\n        return tokenContract.balanceOf(address(this)).sub(totalDepositedAmount);\r\n    }\r\n\r\n    function distributeToken(address account) private {\r\n        uint256 pendingDivs = getPendingDivs(account);\r\n        if (pendingDivs > 0) {\r\n            tokenContract.balanceOf(address(this)).sub(pendingDivs);\r\n            tokenContract.balanceOf(account).add(pendingDivs);\r\n            require(\r\n                tokenContract.transfer(account, pendingDivs),\r\n                \"Could not transfer tokens.\"\r\n            );\r\n            totalEarnedTokens[account] = totalEarnedTokens[account].add(\r\n                pendingDivs\r\n            );\r\n            totalClaimedRewards = totalClaimedRewards.add(pendingDivs);\r\n            emit RewardsTransferred(account, pendingDivs);\r\n        }\r\n       lastClaimedTime[account] = now;\r\n    }\r\n  \r\n   \r\n    function getPendingDivs(address _holder) public view returns (uint256) {\r\n        if (!holders.contains(_holder)) return 0;\r\n        if (depositedTokens[_holder] == 0) return 0;\r\n        if (getRewardToken() == 0) return 0;\r\n\r\n        uint256 timeDiff = now.sub(lastClaimedTime[_holder]);\r\n        uint256 stakedAmount = depositedTokens[_holder];\r\n        \r\n        uint256 pendingDivs = stakedAmount.mul(timeDiff).mul(rewardRate).div(rewardInterval).div(1e4);\r\n\r\n        return pendingDivs;\r\n    }\r\n\r\n    function getNumberOfHolders() public view returns (uint256) {\r\n        return holders.length();\r\n    }\r\n\r\n    function stake(uint256 amountToStake) public {\r\n        require(amountToStake > 0, \"Cannot deposit 0 Tokens\");\r\n        require(\r\n            tokenContract.transferFrom(\r\n                msg.sender,\r\n                address(this),\r\n                amountToStake\r\n            ),\r\n            \"Insufficient Token Allowance\"\r\n        );\r\n        \r\n      \r\n\r\n        uint256 fee = amountToStake.mul(stakingFeeRate).div(1e4);\r\n        uint256 amountAfterFee = amountToStake.sub(fee);\r\n\r\n        require(\r\n            tokenContract.transfer(tokenFeeAddress, fee),\r\n            \"Could not transfer deposit fee.\"\r\n        );\r\n\r\n        depositedTokens[msg.sender] = depositedTokens[msg.sender].add(\r\n            amountAfterFee\r\n        );\r\n\r\n        if (!holders.contains(msg.sender)) {\r\n            holders.add(msg.sender);\r\n            stakingTime[msg.sender] = now;\r\n            lastClaimedTime[msg.sender] = now;\r\n        }\r\n    }\r\n\r\n    function unstake(uint256 amountToWithdraw) public {\r\n        require(\r\n            depositedTokens[msg.sender] >= amountToWithdraw,\r\n            \"Invalid amount to withdraw\"\r\n        );\r\n        \r\n     \r\n        \r\n        uint256 fee = amountToWithdraw.mul(unstakingFeeRate).div(1e4);\r\n        uint256 amountAfterFee = amountToWithdraw.sub(fee);\r\n        require(\r\n            tokenContract.transfer(tokenFeeAddress, fee),\r\n            \"Could not transfer unstaking fee.\"\r\n        );\r\n        require(\r\n            tokenContract.transfer(msg.sender, amountAfterFee),\r\n            \"Could not transfer tokens.\"\r\n        );\r\n\r\n        depositedTokens[msg.sender] = depositedTokens[msg.sender].sub(\r\n            amountToWithdraw\r\n        );\r\n\r\n        if (holders.contains(msg.sender) && depositedTokens[msg.sender] == 0) {\r\n            holders.remove(msg.sender);\r\n        }\r\n    }\r\n\r\n    function claimDivs() public {\r\n        distributeToken(msg.sender);\r\n    }\r\n\r\n    function getStakersList(uint256 startIndex, uint256 endIndex)\r\n        public\r\n        view\r\n        returns (\r\n            address[] memory stakers,\r\n            uint256[] memory stakingTimestamps,\r\n            uint256[] memory lastClaimedTimeStamps,\r\n            uint256[] memory stakedTokens\r\n        )\r\n    {\r\n        require(startIndex < endIndex);\r\n\r\n        uint256 length = endIndex.sub(startIndex);\r\n        address[] memory _stakers = new address[](length);\r\n        uint256[] memory _stakingTimestamps = new uint256[](length);\r\n        uint256[] memory _lastClaimedTimeStamps = new uint256[](length);\r\n        uint256[] memory _stakedTokens = new uint256[](length);\r\n\r\n        for (uint256 i = startIndex; i < endIndex; i = i.add(1)) {\r\n            address staker = holders.at(i);\r\n            uint256 listIndex = i.sub(startIndex);\r\n            _stakers[listIndex] = staker;\r\n            _stakingTimestamps[listIndex] = stakingTime[staker];\r\n            _lastClaimedTimeStamps[listIndex] = lastClaimedTime[staker];\r\n            _stakedTokens[listIndex] = depositedTokens[staker];\r\n        }\r\n\r\n        return (\r\n            _stakers,\r\n            _stakingTimestamps,\r\n            _lastClaimedTimeStamps,\r\n            _stakedTokens\r\n        );\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenFeeAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardsTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"claimDivs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"depositedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumberOfHolders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_holder\",\"type\":\"address\"}],\"name\":\"getPendingDivs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endIndex\",\"type\":\"uint256\"}],\"name\":\"getStakersList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"stakers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"stakingTimestamps\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"lastClaimedTimeStamps\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"stakedTokens\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastClaimedTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToStake\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingFeeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenContract\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenFeeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalClaimedRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalEarnedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToWithdraw\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstakingFeeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"PleStaking","CompilerVersion":"v0.6.0+commit.26b70077","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000aeeaa9c0ecd8d50ab7fcd159bddad0f52ce360c2000000000000000000000000d91a7fd564ea0469e0f2a366d0af9c6423b84f9f","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://20132327927fb357521d5b454f3a3424d3712e091e7936cce6cc992ccae5bc3d"}]}