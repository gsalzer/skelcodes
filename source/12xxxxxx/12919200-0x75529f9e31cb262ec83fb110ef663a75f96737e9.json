{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/CacheGoldLockedDataCronKeeper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\n\\n/// @author The Cache Gold Team\\n/// @title This contract is polled by the keepers in the Chainlink keepers network and if upKeep is required calls LockedCacheGoldAPIConsumer.sol\\ninterface KeeperCompatibleInterface {\\n    function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\\n    function performUpkeep(bytes calldata performData) external;\\n}\\n\\n\\ncontract CacheGoldLockedDataCronKeeper is KeeperCompatibleInterface {\\n    address private immutable _cacheGoldLockedOracle;\\n    uint256 private _lockedGold;\\n    address private immutable _cacheGoldLockedDataAPIConsumer;\\n\\n    /**\\n     * @param cacheGoldLockedOracleParam This is the address of the cache gold oracle which is updated by the gramchain.net service\\n     * @param cacheGoldLockedDataAPIConsumerParam This is the address of the Chain Link Cache Locked Data API fetch contract\\n     */\\n    constructor(address cacheGoldLockedOracleParam, address cacheGoldLockedDataAPIConsumerParam) {\\n      require(cacheGoldLockedOracleParam != address(0)); //Check that it is not the zeroth address\\n      require(cacheGoldLockedDataAPIConsumerParam != address(0)); //Check that it is not the zeroth address\\n      _cacheGoldLockedOracle = cacheGoldLockedOracleParam;\\n      _cacheGoldLockedDataAPIConsumer = cacheGoldLockedDataAPIConsumerParam;\\n    }\\n\\n    /**\\n     *  @notice Check Upkeep called by keepers to check if upkeep is required\\n     *  @dev If there is a change in the stored lockedAmount vs the actual in the Cache Gramchain Locked Gold Contract then perform upkeep\\n     */ \\n    function checkUpkeep(bytes calldata checkData) external view override returns  (bool upkeepNeeded, bytes memory performData)   {\\n        \\n        (bool success, bytes memory callData) = address(_cacheGoldLockedOracle).staticcall(abi.encodeWithSignature(\\\"lockedGold()\\\"));\\n        require(success, \\\"Unable to fetch locked gold oracle data\\\");\\n        (uint256 lockedGoldInCacheOracle) = abi.decode(callData, (uint256));\\n        if(lockedGoldInCacheOracle != _lockedGold){\\n            return(true, abi.encodeWithSignature(\\\"requestedLockedData(string)\\\", \\\"grams_locked\\\")); \\n        }\\n        else{\\n            return (false, checkData);\\n        }\\n    }\\n\\n    /**\\n     * @notice Perform the upkeep required\\n     * @param performData The upkeep that needs to be performed address(_cacheGoldLockedOracle).call(abi.encodeWithSignature(\\\"lockedGold()\\\"));\\n     */ \\n    function performUpkeep(bytes calldata performData) external override {\\n        (bool success, bytes memory callData) = address(_cacheGoldLockedOracle).staticcall(abi.encodeWithSignature(\\\"lockedGold()\\\"));\\n        require(success, \\\"Unable to fetch locked gold oracle data\\\");\\n        (uint256 lockedGoldInCacheOracle) = abi.decode(callData, (uint256));\\n        _lockedGold = lockedGoldInCacheOracle;\\n\\n        // performData is generated by the Keeper's call to your `checkUpkeep` function\\n        (bool successPerformData,) = address(_cacheGoldLockedDataAPIConsumer).call(performData);\\n        require(successPerformData, \\\"Unable to perform upkeep\\\");\\n    }\\n\\n    /**\\n     * @notice Retrieve the Cache Gold Locked Oracle Address\\n     */ \\n    function cacheGoldContractAddress() external view returns(address) {\\n        return _cacheGoldLockedOracle;\\n    }\\n\\n    /**\\n     * @notice  Retrieve the cache Cache Gold Locked Data APIConsumer Address\\n     */ \\n    function cacheGoldLockedDataAPIConsumer() external view returns(address) {\\n        return _cacheGoldLockedDataAPIConsumer;\\n    }\\n}\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n\\n  function decimals()\\n    external\\n    view\\n    returns (\\n      uint8\\n    );\\n\\n  function description()\\n    external\\n    view\\n    returns (\\n      string memory\\n    );\\n\\n  function version()\\n    external\\n    view\\n    returns (\\n      uint256\\n    );\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(\\n    uint80 _roundId\\n  )\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cacheGoldLockedOracleParam\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"cacheGoldLockedDataAPIConsumerParam\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"cacheGoldContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cacheGoldLockedDataAPIConsumer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"checkData\",\"type\":\"bytes\"}],\"name\":\"checkUpkeep\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"upkeepNeeded\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"performData\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"performData\",\"type\":\"bytes\"}],\"name\":\"performUpkeep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CacheGoldLockedDataCronKeeper","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"0000000000000000000000005b7820e62778c7317403d892f6501dd816f827300000000000000000000000003728597b436c55cf91f8558035600c907ebd308c","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}