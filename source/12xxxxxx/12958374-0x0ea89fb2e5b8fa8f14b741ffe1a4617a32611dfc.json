{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.2.15\r\n\"\"\"\r\n@title Boost Delegation\r\n@author Curve Finance\r\n@license MIT\r\n@notice Allows delegation of ve- boost within gauges\r\n\"\"\"\r\n\r\nfrom vyper.interfaces import ERC20\r\n\r\n\r\nevent NewDelegation:\r\n    delegator: indexed(address)\r\n    gauge: indexed(address)\r\n    receiver: indexed(address)\r\n    pct: uint256\r\n    cancel_time: uint256\r\n    expire_time: uint256\r\n\r\nevent CancelledDelegation:\r\n    delegator: indexed(address)\r\n    gauge: indexed(address)\r\n    receiver: indexed(address)\r\n    cancelled_by: address\r\n\r\n\r\nstruct ReceivedBoost:\r\n    length: uint256\r\n    data: uint256[10]\r\n\r\n\r\nadmin: public(address)\r\nfuture_admin: public(address)\r\nis_killed: public(bool)\r\n\r\n# user -> number of active boost delegations\r\ndelegation_count: public(HashMap[address, uint256])\r\n\r\n# user -> gauge -> data on boosts delegated to user\r\n# tightly packed as [address][uint16 pct][uint40 cancel time][uint40 expire time]\r\ndelegation_data: HashMap[address, HashMap[address, ReceivedBoost]]\r\n\r\n# user -> gauge -> data about delegation user has made for this gauge\r\ndelegated_to: HashMap[address, HashMap[address, uint256]]\r\n\r\noperator_of: public(HashMap[address, address])\r\n\r\nVOTING_ESCROW: constant(address) = 0x4D0518C9136025903751209dDDdf6C67067357b1\r\nMIN_VE: constant(uint256) = 2500 * 10**18\r\n\r\n\r\n@external\r\ndef __init__(_admin: address):\r\n    self.admin = _admin\r\n\r\n\r\n@view\r\n@external\r\ndef get_delegated_to(_delegator: address, _gauge: address) -> (address, uint256, uint256, uint256):\r\n    \"\"\"\r\n    @notice Get data about an accounts's boost delegation\r\n    @param _delegator Address to query delegation data for\r\n    @param _gauge Gauge address to query. Use ZERO_ADDRESS for global delegation.\r\n    @return address receiving the delegated boost\r\n            delegated boost pct (out of 10000)\r\n            cancellable timestamp\r\n            expiry timestamp\r\n    \"\"\"\r\n    data: uint256 = self.delegated_to[_delegator][_gauge]\r\n    return (\r\n        convert(shift(data, 96), address),\r\n        shift(data, 80) % 2**16,\r\n        shift(data, 40) % 2**40,\r\n        data % 2**40\r\n    )\r\n\r\n\r\n@view\r\n@external\r\ndef get_delegation_data(\r\n    _receiver: address,\r\n    _gauge: address,\r\n    _idx: uint256\r\n) -> (address, uint256, uint256, uint256):\r\n    \"\"\"\r\n    @notice Get data delegation toward an account\r\n    @param _receiver Address to query delegation data for\r\n    @param _gauge Gauge address to query. Use ZERO_ADDRESS for global delegation.\r\n    @param _idx Data index. Each account can receive a max of 10 delegations per pool.\r\n    @return address of the delegator\r\n            delegated boost pct (out of 10000)\r\n            cancellable timestamp\r\n            expiry timestamp\r\n    \"\"\"\r\n    data: uint256 = self.delegation_data[_receiver][_gauge].data[_idx]\r\n    return (\r\n        convert(shift(data, 96), address),\r\n        shift(data, 80) % 2**16,\r\n        shift(data, 40) % 2**40,\r\n        data % 2**40\r\n    )\r\n\r\n\r\n@external\r\ndef set_operator(_operator: address) -> bool:\r\n    \"\"\"\r\n    @notice Set the authorized operator for an address\r\n    @dev An operator can delegate boost, including creating delegations that\r\n         cannot be cancelled. This permission should only be given to trusted\r\n         3rd parties and smart contracts where the contract behavior is known\r\n         to be not malicious.\r\n    @param _operator Approved operator address. Set to `ZERO_ADDRESS` to revoke\r\n                     the currently active approval.\r\n    @return bool success\r\n    \"\"\"\r\n    self.operator_of[msg.sender] = _operator\r\n    return True\r\n\r\n\r\n@internal\r\ndef _delete_delegation_data(_delegator: address, _gauge: address, _delegation_data: uint256):\r\n    # delete record for the delegator\r\n    self.delegated_to[_delegator][_gauge] = 0\r\n    self.delegation_count[_delegator] -= 1\r\n\r\n    receiver: address = convert(shift(_delegation_data, 96), address)\r\n    length: uint256 = self.delegation_data[receiver][_gauge].length\r\n\r\n    # delete record for the receiver\r\n    for i in range(10):\r\n        if i == length - 1:\r\n            self.delegation_data[receiver][_gauge].data[i] = 0\r\n            break\r\n        if self.delegation_data[receiver][_gauge].data[i] == _delegation_data:\r\n            self.delegation_data[receiver][_gauge].data[i] = self.delegation_data[receiver][_gauge].data[length-1]\r\n            self.delegation_data[receiver][_gauge].data[length-1] = 0\r\n\r\n\r\n@external\r\ndef delegate_boost(\r\n    _delegator: address,\r\n    _gauge: address,\r\n    _receiver: address,\r\n    _pct: uint256,\r\n    _cancel_time: uint256,\r\n    _expire_time: uint256\r\n) -> bool:\r\n    \"\"\"\r\n    @notice Delegate per-gauge or global boost to another account\r\n    @param _delegator Address of the user delegating boost. The caller must be the\r\n                      delegator or the approved operator of the delegator.\r\n    @param _gauge Address of the gauge to delegate for. Set as ZERO_ADDRESS for\r\n                  global delegation. Global delegation is not possible if there is\r\n                  also one or more active per-gauge delegations.\r\n    @param _receiver Address to delegate boost to.\r\n    @param _pct Percentage of boost to delegate. 100% is expressed as 10000.\r\n    @param _cancel_time Delegation cannot be cancelled before this time.\r\n    @param _expire_time Delegation automatically expires at this time.\r\n    @return bool success\r\n    \"\"\"\r\n    assert not self.is_killed, \"Is killed\"\r\n    assert msg.sender in [_delegator, self.operator_of[_delegator]], \"Only owner or operator\"\r\n\r\n    assert _delegator != _receiver, \"Cannot delegate to self\"\r\n    assert _pct >= 100, \"Percent too low\"\r\n    assert _pct <= 10000, \"Percent too high\"\r\n    assert _expire_time < 2**40, \"Expiry time too high\"\r\n    assert _expire_time > block.timestamp, \"Already expired\"\r\n    assert _cancel_time <= _expire_time, \"Cancel time after expiry time\"\r\n\r\n    # check for minimum ve- balance, used to prevent 0 ve- delegation spam\r\n    assert ERC20(VOTING_ESCROW).balanceOf(_delegator) >= MIN_VE, \"Insufficient ve- to delegate\"\r\n\r\n    # check for an existing, expired delegation\r\n    data: uint256 = self.delegated_to[_delegator][_gauge]\r\n    if data != 0:\r\n        assert data % 2**40 <= block.timestamp, \"Existing delegation has not expired\"\r\n        self._delete_delegation_data(_delegator, _gauge, data)\r\n\r\n    if _gauge == ZERO_ADDRESS:\r\n        assert self.delegation_count[_delegator] == 0, \"Cannot delegate globally while per-gauge is active\"\r\n    else:\r\n        assert self.delegated_to[_delegator][ZERO_ADDRESS] == 0, \"Cannot delegate per-gauge while global is active\"\r\n\r\n    # tightly pack the delegation data\r\n    # [address][uint16 pct][uint40 cancel time][uint40 expire time]\r\n    data = shift(_pct, -80) + shift(_cancel_time, -40) + _expire_time\r\n    idx: uint256 = self.delegation_data[_receiver][_gauge].length\r\n\r\n    self.delegation_data[_receiver][_gauge].data[idx] = data + shift(convert(_delegator, uint256), -96)\r\n    self.delegated_to[_delegator][_gauge] = data + shift(convert(_receiver, uint256), -96)\r\n    self.delegation_data[_receiver][_gauge].length = idx + 1\r\n\r\n    log NewDelegation(_delegator, _gauge, _receiver, _pct, _cancel_time, _expire_time)\r\n    return True\r\n\r\n\r\n@external\r\ndef cancel_delegation(_delegator: address, _gauge: address) -> bool:\r\n    \"\"\"\r\n    @notice Cancel an existing boost delegation\r\n    @param _delegator Address of the user delegating boost. The caller can be the\r\n                      delegator, the receiver, the approved operator of the delegator\r\n                      or receiver. The delegator can cancel after the cancel time\r\n                      has passed, the receiver can cancel at any time.\r\n    @param _gauge Address of the gauge to cancel delegattion for. Set as ZERO_ADDRESS\r\n                  for global delegation.\r\n    @return bool success\r\n    \"\"\"\r\n    data: uint256 = self.delegated_to[_delegator][_gauge]\r\n    assert data != 0, \"No delegation for this pool\"\r\n\r\n    receiver: address = convert(shift(data, 96), address)\r\n    if msg.sender not in [receiver, self.operator_of[receiver]]:\r\n        assert msg.sender in [receiver, self.operator_of[receiver]], \"Only owner or operator\"\r\n        assert shift(data, 40) % 2**40 <= block.timestamp, \"Not yet cancellable\"\r\n\r\n    self._delete_delegation_data(_delegator, _gauge, data)\r\n\r\n    log CancelledDelegation(_delegator, _gauge, receiver, msg.sender)\r\n    return True\r\n\r\n\r\n@view\r\n@external\r\ndef get_adjusted_ve_balance(_user: address, _gauge: address) -> uint256:\r\n    \"\"\"\r\n    @notice Get the adjusted ve- balance of an account after delegation\r\n    @param _user Address to query a ve- balance for\r\n    @param _gauge Gauge address\r\n    @return Adjusted ve- balance after delegation\r\n    \"\"\"\r\n    # query the initial ve balance for `_user`\r\n    voting_balance: uint256 = ERC20(VOTING_ESCROW).balanceOf(_user)\r\n\r\n    # if the contract has been killed, return ve- without applying any delegation\r\n    if self.is_killed:\r\n        return voting_balance\r\n\r\n    # check if the user has delegated any ve and reduce the voting balance\r\n    delegation_count: uint256 = self.delegation_count[_user]\r\n    if delegation_count != 0:\r\n        is_global: bool = False\r\n        # apply global delegation\r\n        if delegation_count == 1:\r\n            data: uint256 = self.delegated_to[_user][ZERO_ADDRESS]\r\n            if data % 2**40 > block.timestamp:\r\n                voting_balance = voting_balance * (10000 - shift(data, 80) % 2**16) / 10000\r\n                is_global = True\r\n        # apply pool-specific delegation\r\n        if not is_global:\r\n            data: uint256 = self.delegated_to[_user][_gauge]\r\n            if data % 2**40 > block.timestamp:\r\n                voting_balance = voting_balance * (10000 - shift(data, 80) % 2**16) / 10000\r\n\r\n    # check for other ve delegated to `_user` and increase the voting balance\r\n    for target in [_gauge, ZERO_ADDRESS]:\r\n        length: uint256 = self.delegation_data[_user][target].length\r\n        if length > 0:\r\n            for i in range(10):\r\n                if i == length:\r\n                    break\r\n                data: uint256 = self.delegation_data[_user][target].data[i]\r\n                if data % 2**40 > block.timestamp:\r\n                    delegator: address = convert(shift(data, 96), address)\r\n                    delegator_balance: uint256 = ERC20(VOTING_ESCROW).balanceOf(delegator)\r\n                    voting_balance += delegator_balance * (shift(data, 80) % 2**16) / 10000\r\n\r\n    return voting_balance\r\n\r\n\r\n@external\r\ndef update_delegation_records(_user: address, _gauge: address) -> bool:\r\n    \"\"\"\r\n    @notice Remove data about any expired delegations for a user.\r\n    @dev Reduces gas costs when calling `get_adjusted_ve_balance` on\r\n         an address with expired delegations.\r\n    @param _user Address to update records for.\r\n    @param _gauge Gauge address. Use `ZERO_ADDRESS` for global delegations.\r\n    \"\"\"\r\n    length: uint256 = self.delegation_data[_user][_gauge].length - 1\r\n    adjusted_length: uint256 = length\r\n\r\n    # iterate in reverse over `delegation_data` and remove expired records\r\n    for i in range(10):\r\n        if i > length:\r\n            break\r\n        idx: uint256 = length - i\r\n        data: uint256 = self.delegation_data[_user][_gauge].data[idx]\r\n        if data % 2**40 <= block.timestamp:\r\n            # delete record for the delegator\r\n            delegator: address = convert(shift(data, 96), address)\r\n            self.delegated_to[delegator][_gauge] = 0\r\n            self.delegation_count[delegator] -= 1\r\n\r\n            # delete record for the receiver\r\n            if idx == adjusted_length:\r\n                self.delegation_data[_user][_gauge].data[idx] = 0\r\n            else:\r\n                self.delegation_data[_user][_gauge].data[idx] = self.delegation_data[_user][_gauge].data[adjusted_length]\r\n            adjusted_length -= 1\r\n\r\n    return True\r\n\r\n\r\n@external\r\ndef set_killed(_is_killed: bool):\r\n    \"\"\"\r\n    @notice Set the killed status for this contract\r\n    @dev When killed, all delegation is disabled\r\n    @param _is_killed Killed status to set\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: only owner\r\n\r\n    self.is_killed = _is_killed\r\n\r\n\r\n@external\r\ndef commit_transfer_ownership(_addr: address):\r\n    \"\"\"\r\n    @notice Transfer ownership of this contract to `addr`\r\n    @param _addr Address of the new owner\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin only\r\n\r\n    self.future_admin = _addr\r\n\r\n\r\n@external\r\ndef accept_transfer_ownership():\r\n    \"\"\"\r\n    @notice Accept a pending ownership transfer\r\n    @dev Only callable by the new owner\r\n    \"\"\"\r\n    _admin: address = self.future_admin\r\n    assert msg.sender == _admin  # dev: future admin only\r\n\r\n    self.admin = _admin\r\n    self.future_admin = ZERO_ADDRESS","ABI":"[{\"name\":\"NewDelegation\",\"inputs\":[{\"name\":\"delegator\",\"type\":\"address\",\"indexed\":true},{\"name\":\"gauge\",\"type\":\"address\",\"indexed\":true},{\"name\":\"receiver\",\"type\":\"address\",\"indexed\":true},{\"name\":\"pct\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"cancel_time\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"expire_time\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"CancelledDelegation\",\"inputs\":[{\"name\":\"delegator\",\"type\":\"address\",\"indexed\":true},{\"name\":\"gauge\",\"type\":\"address\",\"indexed\":true},{\"name\":\"receiver\",\"type\":\"address\",\"indexed\":true},{\"name\":\"cancelled_by\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_delegated_to\",\"inputs\":[{\"name\":\"_delegator\",\"type\":\"address\"},{\"name\":\"_gauge\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3668},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_delegation_data\",\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_gauge\",\"type\":\"address\"},{\"name\":\"_idx\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3749},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_operator\",\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":35568},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"delegate_boost\",\"inputs\":[{\"name\":\"_delegator\",\"type\":\"address\"},{\"name\":\"_gauge\",\"type\":\"address\"},{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_pct\",\"type\":\"uint256\"},{\"name\":\"_cancel_time\",\"type\":\"uint256\"},{\"name\":\"_expire_time\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":1001716},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"cancel_delegation\",\"inputs\":[{\"name\":\"_delegator\",\"type\":\"address\"},{\"name\":\"_gauge\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":886484},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_adjusted_ve_balance\",\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_gauge\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":135001},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"update_delegation_records\",\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_gauge\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":989054},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_killed\",\"inputs\":[{\"name\":\"_is_killed\",\"type\":\"bool\"}],\"outputs\":[],\"gas\":37755},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"commit_transfer_ownership\",\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"outputs\":[],\"gas\":37785},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"accept_transfer_ownership\",\"inputs\":[],\"outputs\":[],\"gas\":57736},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2688},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2718},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"is_killed\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":2748},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"delegation_count\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":2993},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"operator_of\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3023}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.15","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"0000000000000000000000002d407ddb06311396fe14d4b49da5f0471447d45c","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}