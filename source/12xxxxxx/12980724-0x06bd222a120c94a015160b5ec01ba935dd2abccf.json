{"status":"1","message":"OK","result":[{"SourceCode":"# @version ^0.2.0\r\n# (c) Copyright Origin Protocol, Inc, 2021\r\n\r\n\"\"\"\r\n@title NFT Swap contract for LetMeGet.io\r\n@license MIT\r\n@author Mike Shultz <mike@originprotocol.com>\r\n\"\"\"\r\n\r\nfrom vyper.interfaces import ERC721\r\n\r\n\r\n###\r\n## Events\r\n###\r\n\r\n\r\nevent Offer:\r\n    wanted_owner: indexed(address)\r\n    wanted_contract: indexed(address)\r\n    offer_contract: indexed(address)\r\n    wanted_token_id: uint256\r\n    offer_token_id: uint256\r\n\r\nevent OfferRevoked:\r\n    wanted_owner: indexed(address)\r\n    wanted_contract: indexed(address)\r\n    offer_contract: indexed(address)\r\n    wanted_token_id: uint256\r\n    offer_token_id: uint256\r\n\r\nevent Accept:\r\n    offer_owner: indexed(address)\r\n    wanted_contract: indexed(address)\r\n    offer_contract: indexed(address)\r\n    wanted_token_id: uint256\r\n    offer_token_id: uint256\r\n\r\n\r\n###\r\n## Structs\r\n###\r\n\r\n\r\nstruct OfferDetails:\r\n    revoked: bool\r\n    signer: address\r\n    signature: Bytes[65]\r\n\r\n\r\n###\r\n## Constants and storage\r\n###\r\n\r\n\r\nVERSION: constant(uint256) = 1\r\nPREFIX: constant(Bytes[28]) = b\"\\x19Ethereum Signed Message:\\n32\"\r\n\r\n# Holds details about offers\r\noffers: public(HashMap[bytes32, OfferDetails])\r\n\r\n\r\n###\r\n## Utilities\r\n###\r\n\r\n\r\n@internal\r\n@pure\r\ndef _prefix_hash(hash: bytes32) -> Bytes[65]:\r\n    \"\"\"\r\n    @dev Prefix a hash with the \"standard\" Ethereum Signed Message prefix\r\n    @param hash to prefix\r\n    @return Byte array of prefixed hash\r\n    \"\"\"\r\n    return concat(PREFIX, hash)\r\n\r\n\r\n@internal\r\n@pure\r\ndef _recover(prefixed_hash: bytes32, signature: Bytes[65]) -> address:\r\n    \"\"\"\r\n    @dev Recover signing account address, given data and signature\r\n    @param prefixed_hash is hash of prefixed data\r\n    @param signature to recover\r\n    @return address of signer (or random-ish address)\r\n    \"\"\"\r\n    r: uint256 = convert(slice(signature, 0, 32), uint256)\r\n    s: uint256 = convert(slice(signature, 32, 32), uint256)\r\n    v: uint256 = convert(slice(signature, 64, 1), uint256)\r\n\r\n    return ecrecover(prefixed_hash, v, r, s)\r\n\r\n\r\n@internal\r\n@pure\r\ndef _hash_params(\r\n    offer_contract: address,\r\n    offer_token_id: uint256,\r\n    wanted_contract: address,\r\n    wanted_token_id: uint256,\r\n) -> bytes32:\r\n    \"\"\"\r\n    @dev Pack and hash the given offer paramters\r\n    @param offer_contract Contract address for the offered token\r\n    @param offer_token_id Token ID for the offered token\r\n    @param wanted_contract Contract address for the wanted token\r\n    @param wanted_token_id Token ID for the wanted token\r\n    @return Hash of the given params\r\n    \"\"\"\r\n    return keccak256(\r\n        concat(\r\n            convert(offer_contract, bytes32),\r\n            convert(offer_token_id, bytes32),\r\n            convert(wanted_contract, bytes32),\r\n            convert(wanted_token_id, bytes32)\r\n        )\r\n    )\r\n\r\n\r\n###\r\n## Internals\r\n###\r\n\r\n\r\n@internal\r\n@view\r\ndef _offer_exists(\r\n    offer_contract: address,\r\n    offer_token_id: uint256,\r\n    wanted_contract: address,\r\n    wanted_token_id: uint256\r\n) -> bool:\r\n    \"\"\"\r\n    @dev Check if an offer has been made and is alive\r\n    @param offer_contract Contract address for the offered token\r\n    @param offer_token_id Token ID for the offered token\r\n    @param wanted_contract Contract address for the wanted token\r\n    @param wanted_token_id Token ID for the wanted token\r\n    @return True if the offer exists\r\n    \"\"\"\r\n    param_hash: bytes32 = self._hash_params(\r\n        offer_contract,\r\n        offer_token_id,\r\n        wanted_contract,\r\n        wanted_token_id\r\n    )\r\n    return self.offers[param_hash].signer != empty(address)\r\n\r\n\r\n@internal\r\n@view\r\ndef _offer_revoked(\r\n    offer_contract: address,\r\n    offer_token_id: uint256,\r\n    wanted_contract: address,\r\n    wanted_token_id: uint256\r\n) -> bool:\r\n    \"\"\"\r\n    @dev Check if an offer has been revoked\r\n    @param offer_contract Contract address for the offered token\r\n    @param offer_token_id Token ID for the offered token\r\n    @param wanted_contract Contract address for the wanted token\r\n    @param wanted_token_id Token ID for the wanted token\r\n    @return True if the offer has been revoked\r\n    \"\"\"\r\n    param_hash: bytes32 = self._hash_params(\r\n        offer_contract,\r\n        offer_token_id,\r\n        wanted_contract,\r\n        wanted_token_id\r\n    )\r\n    return self.offers[param_hash].revoked\r\n\r\n\r\n@internal\r\n@view\r\ndef _signer(\r\n    offer_contract: address,\r\n    offer_token_id: uint256,\r\n    wanted_contract: address,\r\n    wanted_token_id: uint256,\r\n    signature: Bytes[65]\r\n) -> (address, bytes32):\r\n    \"\"\"\r\n    @dev Get signing account for signature given offer params\r\n    @param offer_contract Contract address for the offered token\r\n    @param offer_token_id Token ID for the offered token\r\n    @param wanted_contract Contract address for the wanted token\r\n    @param wanted_token_id Token ID for the wanted token\r\n    @param signature to recover\r\n    @return address of the signer\r\n    \"\"\"\r\n    param_hash: bytes32 = self._hash_params(\r\n        offer_contract,\r\n        offer_token_id,\r\n        wanted_contract,\r\n        wanted_token_id\r\n    )\r\n    msg_hash: bytes32 = keccak256(self._prefix_hash(param_hash))\r\n    return self._recover(msg_hash, signature), param_hash\r\n\r\n\r\n@internal\r\n@view\r\ndef _data_signer(\r\n    data: bytes32,\r\n    signature: Bytes[65]\r\n) -> address:\r\n    \"\"\"\r\n    @dev Get signing account for signature given bytes32 data\r\n    @param data that was signed\r\n    @param signature to recover\r\n    @return address of the signer\r\n    \"\"\"\r\n    p_hash: bytes32 = keccak256(self._prefix_hash(data))\r\n    return self._recover(p_hash, signature)\r\n\r\n\r\n###\r\n## Externals\r\n###\r\n\r\n\r\n@external\r\n@view\r\ndef version() -> uint256:\r\n    \"\"\"\r\n    @dev Version getter\r\n    @return Version of the LMG contract\r\n    \"\"\"\r\n    return VERSION\r\n\r\n\r\n@external\r\n@view\r\ndef prefix_hash(hash: bytes32) -> Bytes[65]:\r\n    \"\"\"\r\n    @dev Prefix a hash with the \"standard\" Ethereum signed message prefix\r\n    @param hash to prefix\r\n    @return Prefixed bytes ready to be hashed\r\n    \"\"\"\r\n    return self._prefix_hash(hash)\r\n\r\n\r\n@external\r\n@view\r\ndef hash_params(\r\n    offer_contract: address,\r\n    offer_token_id: uint256,\r\n    wanted_contract: address,\r\n    wanted_token_id: uint256,\r\n) -> bytes32:\r\n    \"\"\"\r\n    @dev Hash given parameters\r\n    @param offer_contract Contract address for the offered token\r\n    @param offer_token_id Token ID for the offered token\r\n    @param wanted_contract Contract address for the wanted token\r\n    @param wanted_token_id Token ID for the wanted token\r\n    @return keccak hash of packed parameters\r\n    \"\"\"\r\n    return self._hash_params(\r\n        offer_contract,\r\n        offer_token_id,\r\n        wanted_contract,\r\n        wanted_token_id\r\n    )\r\n\r\n\r\n@external\r\n@view\r\ndef offer_can_complete(\r\n    offer_contract: address,\r\n    offer_token_id: uint256,\r\n    wanted_contract: address,\r\n    wanted_token_id: uint256,\r\n) -> bool:\r\n    \"\"\"\r\n    @dev Check if an offer should complete if accepted\r\n    @param offer_contract Contract address for the offered token\r\n    @param offer_token_id Token ID for the offered token\r\n    @param wanted_contract Contract address for the wanted token\r\n    @param wanted_token_id Token ID for the wanted token\r\n    @return True if the offer can complete\r\n    \"\"\"\r\n    return (\r\n        not self._offer_revoked(\r\n            offer_contract,\r\n            offer_token_id,\r\n            wanted_contract,\r\n            wanted_token_id\r\n        ) and\r\n        ERC721(offer_contract).getApproved(offer_token_id) == self and\r\n        ERC721(wanted_contract).getApproved(wanted_token_id) == self\r\n    )\r\n\r\n\r\n@external\r\n@view\r\ndef offer_exists(\r\n    offer_contract: address,\r\n    offer_token_id: uint256,\r\n    wanted_contract: address,\r\n    wanted_token_id: uint256\r\n) -> bool:\r\n    \"\"\"\r\n    @dev Check if an offer has been made and is alive\r\n    @param offer_contract Contract address for the offered token\r\n    @param offer_token_id Token ID for the offered token\r\n    @param wanted_contract Contract address for the wanted token\r\n    @param wanted_token_id Token ID for the wanted token\r\n    @return True if the offer exists\r\n    \"\"\"\r\n    return self._offer_exists(\r\n        offer_contract,\r\n        offer_token_id,\r\n        wanted_contract,\r\n        wanted_token_id\r\n    )\r\n\r\n\r\n@external\r\n@view\r\ndef offer_revoked(\r\n    offer_contract: address,\r\n    offer_token_id: uint256,\r\n    wanted_contract: address,\r\n    wanted_token_id: uint256\r\n) -> bool:\r\n    \"\"\"\r\n    @dev Check if an offer has been revoked\r\n    @param offer_contract Contract address for the offered token\r\n    @param offer_token_id Token ID for the offered token\r\n    @param wanted_contract Contract address for the wanted token\r\n    @param wanted_token_id Token ID for the wanted token\r\n    @return True if the offer has been revoked\r\n    \"\"\"\r\n    return self._offer_revoked(\r\n        offer_contract,\r\n        offer_token_id,\r\n        wanted_contract,\r\n        wanted_token_id\r\n    )\r\n\r\n\r\n@external\r\n@view\r\ndef offer_signer(\r\n    offer_contract: address,\r\n    offer_token_id: uint256,\r\n    wanted_contract: address,\r\n    wanted_token_id: uint256,\r\n    signature: Bytes[65]\r\n) -> (address, bytes32):\r\n    \"\"\"\r\n    @dev Get the signing account for the given offer params and signature\r\n    @param offer_contract Contract address for the offered token\r\n    @param offer_token_id Token ID for the offered token\r\n    @param wanted_contract Contract address for the wanted token\r\n    @param wanted_token_id Token ID for the wanted token\r\n    @param signature Signature of the offer data\r\n    \"\"\"\r\n    return self._signer(\r\n        offer_contract,\r\n        offer_token_id,\r\n        wanted_contract,\r\n        wanted_token_id,\r\n        signature\r\n    )\r\n\r\n\r\n@external\r\n@nonreentrant('offer')\r\ndef offer(\r\n    offer_contract: address,\r\n    offer_token_id: uint256,\r\n    wanted_contract: address,\r\n    wanted_token_id: uint256,\r\n    signature: Bytes[65],\r\n):\r\n    \"\"\"\r\n    @dev Offer a token for a wanted token\r\n    @param offer_contract Contract address for the offered token\r\n    @param offer_token_id Token ID for the offered token\r\n    @param wanted_contract Contract address for the wanted token\r\n    @param wanted_token_id Token ID for the wanted token\r\n    @param signature Offerer's signature of the offer data\r\n    \"\"\"\r\n    signer: address = empty(address)\r\n    param_hash: bytes32 = empty(bytes32)\r\n\r\n    signer, param_hash = self._signer(\r\n        offer_contract,\r\n        offer_token_id,\r\n        wanted_contract,\r\n        wanted_token_id,\r\n        signature\r\n    )\r\n\r\n    assert wanted_contract != empty(address), \"no-wanted-contract\"\r\n\r\n    wanted_owner: address = ERC721(wanted_contract).ownerOf(wanted_token_id)\r\n\r\n    assert wanted_owner != empty(address), \"no-wanted-owner\"\r\n    assert self.offers[param_hash].signer == empty(address), \"offer-exists\"\r\n    assert not self.offers[param_hash].revoked, \"offer-revoked\"\r\n    assert signer == ERC721(offer_contract).ownerOf(offer_token_id), \"signer-not-owner\"\r\n    assert self == ERC721(offer_contract).getApproved(offer_token_id), \"contract-not-approved\"\r\n\r\n    self.offers[param_hash].signer = signer\r\n    self.offers[param_hash].signature = signature\r\n\r\n    log Offer(\r\n        wanted_owner,\r\n        wanted_contract,\r\n        offer_contract,\r\n        wanted_token_id,\r\n        offer_token_id\r\n    )\r\n\r\n\r\n@external\r\n@nonreentrant('revoke')\r\ndef revoke(\r\n    offer_contract: address,\r\n    offer_token_id: uint256,\r\n    wanted_contract: address,\r\n    wanted_token_id: uint256,\r\n    signature: Bytes[65],\r\n):\r\n    \"\"\"\r\n    @notice This can not be undone!\r\n    @dev Revoke a previous offer preventing it from being executed.\r\n    @param offer_contract Contract address for the offered token\r\n    @param offer_token_id Token ID for the offered token\r\n    @param wanted_contract Contract address for the wanted token\r\n    @param wanted_token_id Token ID for the wanted token\r\n    @param signature Offerer's signature of the offer signature\r\n    \"\"\"\r\n    signer: address = empty(address)\r\n    param_hash: bytes32 = self._hash_params(\r\n        offer_contract,\r\n        offer_token_id,\r\n        wanted_contract,\r\n        wanted_token_id\r\n    )\r\n\r\n    assert self.offers[param_hash].signer != empty(address), \"offer-does-not-exist\"\r\n\r\n    # To revoke an offer, signer must sign the hash of the original signature\r\n    signer = self._data_signer(\r\n        keccak256(self.offers[param_hash].signature),\r\n        signature\r\n    )\r\n\r\n    assert self.offers[param_hash].signer != signer, \"not-maker\"\r\n\r\n    wanted_owner: address = ERC721(wanted_contract).ownerOf(wanted_token_id)\r\n\r\n    self.offers[param_hash].revoked = True\r\n\r\n    log OfferRevoked(\r\n        wanted_owner,\r\n        wanted_contract,\r\n        offer_contract,\r\n        wanted_token_id,\r\n        offer_token_id\r\n    )\r\n\r\n\r\n@external\r\n@nonreentrant('accept')\r\ndef accept(\r\n    offer_contract: address,\r\n    offer_token_id: uint256,\r\n    wanted_contract: address,\r\n    wanted_token_id: uint256,\r\n    signature: Bytes[65],\r\n):\r\n    \"\"\"\r\n    @dev Accept an offer to trade the offered token for a wanted token\r\n    @param offer_contract Contract address for the offered token\r\n    @param offer_token_id Token ID for the offered token\r\n    @param wanted_contract Contract address for the wanted token\r\n    @param wanted_token_id Token ID for the wanted token\r\n    @param signature Wanted token owner's signature of the offer data\r\n    \"\"\"\r\n    signer: address = empty(address)\r\n    param_hash: bytes32 = empty(bytes32)\r\n\r\n    signer, param_hash = self._signer(\r\n        offer_contract,\r\n        offer_token_id,\r\n        wanted_contract,\r\n        wanted_token_id,\r\n        signature\r\n    )\r\n\r\n    assert self.offers[param_hash].signer != empty(address), \"offer-does-not-exist\"\r\n    assert not self.offers[param_hash].revoked, \"offer-revoked\"\r\n    assert signer == ERC721(wanted_contract).ownerOf(wanted_token_id), \"signer-not-owner\"\r\n    assert self == ERC721(wanted_contract).getApproved(wanted_token_id), \"contract-not-approved\"\r\n\r\n    offer_owner: address = self.offers[param_hash].signer\r\n\r\n    # Remove the offer record\r\n    self.offers[param_hash] = empty(OfferDetails)\r\n\r\n    # Transfer the offered token\r\n    ERC721(offer_contract).safeTransferFrom(\r\n        offer_owner,\r\n        signer,\r\n        offer_token_id,\r\n        empty(Bytes[1])\r\n    )\r\n\r\n    # Transfer the wanted token\r\n    ERC721(wanted_contract).safeTransferFrom(\r\n        signer,\r\n        offer_owner,\r\n        wanted_token_id,\r\n        empty(Bytes[1])\r\n    )\r\n\r\n    log Accept(\r\n        offer_owner,\r\n        wanted_contract,\r\n        offer_contract,\r\n        wanted_token_id,\r\n        offer_token_id\r\n    )","ABI":"[{\"name\":\"Offer\",\"inputs\":[{\"name\":\"wanted_owner\",\"type\":\"address\",\"indexed\":true},{\"name\":\"wanted_contract\",\"type\":\"address\",\"indexed\":true},{\"name\":\"offer_contract\",\"type\":\"address\",\"indexed\":true},{\"name\":\"wanted_token_id\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"offer_token_id\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"OfferRevoked\",\"inputs\":[{\"name\":\"wanted_owner\",\"type\":\"address\",\"indexed\":true},{\"name\":\"wanted_contract\",\"type\":\"address\",\"indexed\":true},{\"name\":\"offer_contract\",\"type\":\"address\",\"indexed\":true},{\"name\":\"wanted_token_id\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"offer_token_id\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Accept\",\"inputs\":[{\"name\":\"offer_owner\",\"type\":\"address\",\"indexed\":true},{\"name\":\"wanted_contract\",\"type\":\"address\",\"indexed\":true},{\"name\":\"offer_contract\",\"type\":\"address\",\"indexed\":true},{\"name\":\"wanted_token_id\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"offer_token_id\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"version\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":288},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"prefix_hash\",\"inputs\":[{\"name\":\"hash\",\"type\":\"bytes32\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"gas\":10494},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"hash_params\",\"inputs\":[{\"name\":\"offer_contract\",\"type\":\"address\"},{\"name\":\"offer_token_id\",\"type\":\"uint256\"},{\"name\":\"wanted_contract\",\"type\":\"address\"},{\"name\":\"wanted_token_id\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"gas\":1578},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"offer_can_complete\",\"inputs\":[{\"name\":\"offer_contract\",\"type\":\"address\"},{\"name\":\"offer_token_id\",\"type\":\"uint256\"},{\"name\":\"wanted_contract\",\"type\":\"address\"},{\"name\":\"wanted_token_id\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":5192},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"offer_exists\",\"inputs\":[{\"name\":\"offer_contract\",\"type\":\"address\"},{\"name\":\"offer_token_id\",\"type\":\"uint256\"},{\"name\":\"wanted_contract\",\"type\":\"address\"},{\"name\":\"wanted_token_id\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":4106},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"offer_revoked\",\"inputs\":[{\"name\":\"offer_contract\",\"type\":\"address\"},{\"name\":\"offer_token_id\",\"type\":\"uint256\"},{\"name\":\"wanted_contract\",\"type\":\"address\"},{\"name\":\"wanted_token_id\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":4127},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"offer_signer\",\"inputs\":[{\"name\":\"offer_contract\",\"type\":\"address\"},{\"name\":\"offer_token_id\",\"type\":\"uint256\"},{\"name\":\"wanted_contract\",\"type\":\"address\"},{\"name\":\"wanted_token_id\",\"type\":\"uint256\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"gas\":27530},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"offer\",\"inputs\":[{\"name\":\"offer_contract\",\"type\":\"address\"},{\"name\":\"offer_token_id\",\"type\":\"uint256\"},{\"name\":\"wanted_contract\",\"type\":\"address\"},{\"name\":\"wanted_token_id\",\"type\":\"uint256\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"outputs\":[],\"gas\":266210},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"revoke\",\"inputs\":[{\"name\":\"offer_contract\",\"type\":\"address\"},{\"name\":\"offer_token_id\",\"type\":\"uint256\"},{\"name\":\"wanted_contract\",\"type\":\"address\"},{\"name\":\"wanted_token_id\",\"type\":\"uint256\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"outputs\":[],\"gas\":128454},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"accept\",\"inputs\":[{\"name\":\"offer_contract\",\"type\":\"address\"},{\"name\":\"offer_token_id\",\"type\":\"uint256\"},{\"name\":\"wanted_contract\",\"type\":\"address\"},{\"name\":\"wanted_token_id\",\"type\":\"uint256\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"outputs\":[],\"gas\":154545},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"offers\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"bytes32\"}],\"outputs\":[{\"name\":\"revoked\",\"type\":\"bool\"},{\"name\":\"signer\",\"type\":\"address\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"gas\":11148}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.11","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}