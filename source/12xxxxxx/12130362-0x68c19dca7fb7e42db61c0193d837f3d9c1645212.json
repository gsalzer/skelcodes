{"status":"1","message":"OK","result":[{"SourceCode":"\"\"\"\r\n@title Greenwood CompoundEscrow\r\n@notice Compound integrations for the Greenwood Protocol\r\n@author Greenwood Labs\r\n\"\"\"\r\n\r\n# define the interfaces used by the contract\r\nfrom vyper.interfaces import ERC20\r\n\r\ninterface COMPOUND_CALCULATOR:\r\n    def calculateBorrow(_borrow_ticker: String[10], _collateral_ticker: String[10], _borrow_context: AssetContext, _collateral_context: AssetContext, _amount: uint256, _collateralization_ratio: uint256, _version: String[11]) -> CompoundBorrowCalculation: nonpayable\r\n    def calculateWithdraw(_borrow_ticker: String[10], _collateral_ticker: String[10], _borrow_context: AssetContext, _collateral_context: AssetContext, _loan: Loan, _version: String[11]) -> CompoundWithdrawCalculation: nonpayable\r\n    def calculateRepay(_borrow_ticker: String[10], _collateral_ticker: String[10], _borrow_context: AssetContext, _collateral_context: AssetContext, _amount: uint256, _loan: Loan, _version: String[11]) -> CompoundRepayCalculation: nonpayable\r\n\r\ninterface CTOKEN:\r\n    def mint(_mint_amount: uint256) -> uint256: nonpayable\r\n    def borrow(_borrow_amount: uint256) -> uint256: nonpayable\r\n    def repayBorrow(_repay_amount: uint256) -> uint256: nonpayable\r\n    def borrowIndex() -> uint256: nonpayable\r\n    def redeemUnderlying(_redeem_amount: uint256) -> uint256: nonpayable\r\n    def exchangeRateStored() -> uint256: nonpayable\r\n    def borrowRatePerBlock() -> uint256: nonpayable\r\n    def borrowBalanceCurrent(_account: address) -> uint256: nonpayable\r\n    def accrualBlockNumber() -> uint256: nonpayable\r\n\r\ninterface REGISTRY:\r\n    def getAddress(_contract: String[20], _version: String[11]) -> address: nonpayable\r\n    def governance() -> address: nonpayable\r\n\r\ninterface STORE:\r\n    def getAssetContext(_ticker: String[10]) -> AssetContext: view\r\n    def recordLoan(_borrower: address, _borrow_asset: address, _collateral_asset: address, _collateralization_ratio: uint256, _collateral_locked: uint256, _index: uint256, _principal: uint256, _protocol: String[10], _version: String[11]): nonpayable\r\n    def updateLoan(_collateral_locked: uint256, _index: uint256, _loan_key: bytes32, _outstanding: uint256, _version: String[11]): nonpayable\r\n    def getLoan(_loan_key: bytes32) -> Loan: view\r\n    def getLoanProtocol(_loan_key: bytes32) -> String[10]: view\r\n\r\n# define the events emitted by the contract\r\nevent AddCollateral:\r\n    loanKey: bytes32\r\n    depositor: address\r\n    amount: uint256\r\n    collateralAsset: address\r\n    blockNumber: uint256\r\n\r\nevent Borrow:\r\n    borrower: address\r\n    amount: uint256\r\n    borrowAsset: address\r\n    collateralAsset: address\r\n    blockNumber: uint256\r\n\r\nevent Fallback:\r\n    value: uint256\r\n    sender: address\r\n    blockNumber: uint256\r\n\r\nevent Liquidate:\r\n    loanKey: bytes32\r\n    outstanding: uint256\r\n    borrowAsset: address\r\n    collateralAsset: address\r\n    blockNumber: uint256\r\n\r\nevent Liquidation:\r\n    borrowAsset: address\r\n    collateralAsset: address\r\n    liquidator: address\r\n    loanKeys: bytes32[100]\r\n    redemptionAmount: uint256\r\n    repayAmount: uint256\r\n    blockNumber: uint256\r\n\r\nevent Repay:\r\n    borrower: address\r\n    repaymentAmount: uint256\r\n    repaymentAsset: address\r\n    redemptionAmount: uint256\r\n    redemptionAsset: address\r\n    blockNumber: uint256\r\n\r\nevent SetRegistry:\r\n    previousRegistry: address\r\n    newRegistry: address\r\n    governance: address\r\n    blockNumber: uint256\r\n\r\nevent WithdrawCollateral:\r\n    loanKey: bytes32\r\n    amount: uint256\r\n    collateralAsset: address\r\n    collateralLocked: uint256\r\n    blockNumber: uint256\r\n\r\n# define the constants used by the contract\r\nLOOP_LIMIT: constant(uint256) = 100\r\n\r\n# define the structs used by the contract\r\nstruct AssetContext:\r\n    aToken: address\r\n    aaveV2PriceFeed: address\r\n    aaveV2LendingPool: address\r\n    cToken: address\r\n    compoundPriceFeed: address\r\n    comptroller: address\r\n    decimals: uint256\r\n    underlying: address\r\n\r\nstruct CompoundBorrowCalculation:\r\n    requiredCollateral: uint256\r\n    borrowAmount: uint256\r\n    originationFee: uint256\r\n\r\nstruct CompoundRepayCalculation:\r\n    repayAmount: uint256\r\n    redemptionAmount: int128\r\n    requiredCollateral: uint256\r\n    outstanding: int128\r\n\r\nstruct CompoundWithdrawCalculation:\r\n    requiredCollateral: uint256\r\n    outstanding: uint256\r\n\r\nstruct Loan:\r\n    collateralAsset: address\r\n    borrowAsset: address\r\n    outstanding: uint256\r\n    collateralizationRatio: uint256\r\n    collateralLocked: uint256\r\n    borrower: address\r\n    lastBorrowIndex: uint256\r\n    repaymentTime: uint256\r\n\r\n# define the storage variables used by the contract\r\nregistry: public(address)\r\n\r\n@external\r\ndef __init__(_registry: address):\r\n    \"\"\"\r\n    @notice Contract constructor\r\n    @param _registry The address of the Greenwood Registry\r\n    \"\"\"\r\n\r\n    # set the address of the Escrow\r\n    self.registry = _registry\r\n\r\n@internal\r\ndef isAuthorized(_caller: address, _role: String[20], _version: String[11]) -> bool:\r\n    \"\"\"\r\n    @notice Method for role-based security\r\n    @param _caller The address that called the permissioned method\r\n    @param _role The requested authorization level\r\n    @param _version The version of Greenwood to use\r\n    @return True if the caller is authorized, False otherwise\r\n    \"\"\"\r\n\r\n    # check if the requested role is \"controller\"\r\n    if keccak256(_role) == keccak256(\"controller\"):\r\n\r\n        # get the address of the Controller from the Registry\r\n        escrow: address = REGISTRY(self.registry).getAddress(\"controller\", _version)\r\n\r\n        # return the equality comparison\r\n        return escrow == _caller\r\n    \r\n    # check if the requested role is \"governance\"\r\n    elif keccak256(_role) == keccak256(\"governance\"):\r\n\r\n        # get the address of the Governance from the Registry\r\n        governance: address = REGISTRY(self.registry).governance()\r\n\r\n        # return the equality comparison\r\n        return governance == _caller\r\n\r\n    # check if the requested role is \"liquidator\"\r\n    elif keccak256(_role) == keccak256(\"liquidator\"):\r\n\r\n        # get the address of the Liquidator from the Registry\r\n        liquidator: address = REGISTRY(self.registry).getAddress(\"liquidator\", _version)\r\n\r\n        # return the equality comparison\r\n        return liquidator == _caller\r\n\r\n    # catch extraneous role arguments\r\n    else:\r\n\r\n        # revert\r\n        raise \"Unhandled role argument\"\r\n\r\n@internal\r\ndef handleEnterMarketsResponse(_byte_arr: Bytes[96]) -> uint256:\r\n  \"\"\"\r\n  @notice Converts 96 byte array to a uint256\r\n  @param _byte_arr Byte array of length 96\r\n  @return uint256\r\n  @dev This assumes it is the output from a raw_call that takes form of offset + length + response\r\n  \"\"\"\r\n\r\n  # assumes output is coming from an uint[], therefore start at byte 64\r\n  # because first two sets of 32 are offset & length\r\n  start: int128 = 32 * 2\r\n\r\n  # extract32 bytes of data\r\n  extracted: bytes32 = extract32(_byte_arr, start, output_type=bytes32)\r\n\r\n  # return converted 32 bytes to uint256\r\n  return convert(extracted, uint256)\r\n\r\n@external\r\n@payable\r\ndef borrow(_borrow_ticker: String[10], _collateral_ticker: String[10], _borrow_context: AssetContext, _collateral_context: AssetContext, _amount: uint256, _borrower: address, _calculator: address, _collateralization_ratio: uint256, _store: address, _version: String[11]):\r\n    \"\"\"\r\n    @notice Borrow assets from Compound\r\n    @param _borrow_ticker The ticker string of the asset being borrowed\r\n    @param _collateral_ticker The ticker string of the asset being used as collateral\r\n    @param _borrow_context The AssetContext struct of the asset being borrowed\r\n    @param _collateral_context The AssetContext struct of the asset being used as collateral\r\n    @param _amount The amount of asset being borrowed scaled by the asset's decimals\r\n    @param _borrower The address of the borrower\r\n    @param _calculator The address of the Grenwood Calculator to use\r\n    @param _collateralization_ratio The collateralization ratio for the loan as a percentage\r\n    @param _store The address of the Greenwood Store to use\r\n    @param _version The version of Greenwood to use\r\n    @dev Only the Controller or the Governance can call this method\r\n    \"\"\"\r\n\r\n    # require that the method is being called by the Controller or the Governance\r\n    assert self.isAuthorized(msg.sender, \"controller\", _version) == True or self.isAuthorized(msg.sender, \"governance\", _version) == True\r\n\r\n    # require that the borrow amount is greater than 0 after scaling it down\r\n    assert convert(_amount, decimal) / convert(10 ** _borrow_context.decimals, decimal) > 0.0\r\n\r\n    # get required collateral, borrow index, borrow amount, and the origination fee from the Calculator\r\n    borrowCalculations: CompoundBorrowCalculation = COMPOUND_CALCULATOR(_calculator).calculateBorrow(_borrow_ticker, _collateral_ticker, _borrow_context, _collateral_context, _amount, _collateralization_ratio, _version)\r\n\r\n    # check if the collateral asset is ETH\r\n    if keccak256(_collateral_ticker) == keccak256(\"ETH\"):\r\n\r\n        # check if the origination fee is greater than 0\r\n        if borrowCalculations.originationFee > 0:\r\n\r\n            # get the address of the Treasury from the Registry\r\n            treasury: address = REGISTRY(self.registry).getAddress(\"treasury\", _version)\r\n\r\n            # require that a Treasury address was returned from the Store\r\n            assert treasury != ZERO_ADDRESS\r\n\r\n            # send the origination fee to the Treasury\r\n            send(treasury, borrowCalculations.originationFee)\r\n\r\n        # call mint() on the cEther contract and send msg.value, less the origination fee, in wei\r\n        raw_call(\r\n            _collateral_context.cToken,\r\n            method_id(\"mint()\"),\r\n            value = msg.value - borrowCalculations.originationFee\r\n        )\r\n\r\n    else:\r\n\r\n        # check if the origination fee is greater than 0\r\n        if borrowCalculations.originationFee > 0:\r\n\r\n            # get the address of the Treasury from the Registry\r\n            treasury: address = REGISTRY(self.registry).getAddress(\"treasury\", _version)\r\n\r\n            # require that a Treasury address was returned from the Store\r\n            assert treasury != ZERO_ADDRESS\r\n\r\n            # transfer the origination fee to the Treasury\r\n            transferResponse: Bytes[32] = raw_call(\r\n                _collateral_context.underlying,\r\n                concat(\r\n                    method_id(\"transferFrom(address,address,uint256)\"),\r\n                    convert(_borrower, bytes32),\r\n                    convert(treasury, bytes32),\r\n                    convert(borrowCalculations.originationFee, bytes32),\r\n                ),\r\n                max_outsize=32,\r\n            )\r\n            if len(transferResponse) > 0:\r\n                assert convert(transferResponse, bool)\r\n\r\n        # move collateral from the borrower to Escrow \r\n        transferFromResponse: Bytes[32] = raw_call(\r\n            _collateral_context.underlying,\r\n            concat(\r\n                method_id(\"transferFrom(address,address,uint256)\"),\r\n                convert(_borrower, bytes32),\r\n                convert(self, bytes32),\r\n                convert(borrowCalculations.requiredCollateral, bytes32),\r\n            ),\r\n            max_outsize=32,\r\n        ) \r\n        if len(transferFromResponse) > 0:\r\n            assert convert(transferFromResponse, bool)\r\n\r\n        # approve the collateral transfer from Escrow to Compound\r\n        approveResponse: Bytes[32] = raw_call(\r\n            _collateral_context.underlying,\r\n            concat(\r\n                method_id(\"approve(address,uint256)\"),\r\n                convert(_collateral_context.cToken, bytes32),\r\n                convert(borrowCalculations.requiredCollateral, bytes32),\r\n            ),\r\n            max_outsize=32,\r\n        )\r\n        if len(approveResponse) > 0:\r\n            assert convert(approveResponse, bool)\r\n\r\n        # require that the cTokens were minted successfully\r\n        assert CTOKEN(_collateral_context.cToken).mint(borrowCalculations.requiredCollateral) == 0\r\n\r\n    # allow for the usage of the collateral asset as collateral in Compound\r\n    enterMarketsResponse: Bytes[96] = raw_call(\r\n        _collateral_context.comptroller,                                # compound comptroller address\r\n        concat(\r\n            method_id(\"enterMarkets(address[])\", output_type=Bytes[4]), # enterMarkets() method signature (4 bytes)\r\n            convert(32, bytes32),                                       # offset (32 bytes)\r\n            convert(1, bytes32),                                        # arrayLength (32 bytes)\r\n            convert(_collateral_context.cToken, bytes32)                # addressArray (32 * 1 bytes)\r\n        ),\r\n        max_outsize=96,                                                 # outsize = offset + arrayLength + addressArray\r\n    )\r\n\r\n    # require that the market was entered successfully\r\n    assert self.handleEnterMarketsResponse(enterMarketsResponse) == 0\r\n\r\n    # require that the Compound borrow was successful\r\n    assert CTOKEN(_borrow_context.cToken).borrow(_amount) == 0\r\n\r\n    # get the current borrow index from the cToken\r\n    borrowIndex: uint256 = CTOKEN(_borrow_context.cToken).borrowIndex()\r\n\r\n    # check if the borrow asset is ETH\r\n    if keccak256(_borrow_ticker) == keccak256(\"ETH\"):\r\n\r\n        # transfer ETH to the borrower\r\n        send(_borrower, _amount)\r\n\r\n    else:\r\n\r\n        # transfer the borrow asset to the borrower\r\n        transferResponse: Bytes[32] = raw_call(\r\n            _borrow_context.underlying,\r\n            concat(\r\n                method_id(\"transfer(address,uint256)\"),\r\n                convert(_borrower, bytes32),\r\n                convert(_amount, bytes32),\r\n            ),\r\n            max_outsize=32,\r\n        )\r\n        if len(transferResponse) > 0:\r\n            assert convert(transferResponse, bool)\r\n\r\n    # pass loan data to the Store for storage\r\n    STORE(_store).recordLoan(_borrower, _borrow_context.underlying, _collateral_context.underlying, _collateralization_ratio, borrowCalculations.requiredCollateral, borrowIndex, _amount, \"compound\", _version)\r\n\r\n    # emit a Borrow event\r\n    log Borrow(_borrower, _amount, _borrow_context.underlying, _collateral_context.underlying, block.number)\r\n\r\n@external\r\n@payable\r\ndef repay(_borrow_ticker: String[10], _collateral_ticker: String[10], _amount: uint256, _calculator: address, _loan_key: bytes32, _store: address, _version: String[11]):\r\n    \"\"\"\r\n    @notice Repay a Compound loan\r\n    @param _borrow_ticker The ticker string of the asset that was borrowed\r\n    @param _collateral_ticker The ticker string of the asset that is being used as collateral\r\n    @param _amount The amount of the repayment scaled by the asset's decimals\r\n    @param _calculator The address of the Greenwood Calculator to use\r\n    @param _loan_key The uinque identifier for the loan\r\n    @param _store The address of the Greenwood Store to use\r\n    @param _version The version of Greenwood to use\r\n    @dev Only the Controller or the Governance can call this method\r\n    \"\"\"\r\n\r\n    # require that the method is being called by the controller or the governance\r\n    assert self.isAuthorized(msg.sender, \"controller\", _version) == True or self.isAuthorized(msg.sender, \"governance\", _version) == True\r\n\r\n    # get the loan protocol from the Store\r\n    loanProtocol: String[10] = STORE(_store).getLoanProtocol(_loan_key)\r\n\r\n    # get the rest of the loan data from the Store\r\n    loan: Loan = STORE(_store).getLoan(_loan_key)\r\n\r\n    # require that the outstanding balance of the loan is greater than\r\n    assert loan.outstanding > 0\r\n\r\n    # get the asset contexts for the borrow asset and the collateral asset from the Store\r\n    borrowContext: AssetContext = STORE(_store).getAssetContext(_borrow_ticker)\r\n    collateralContext: AssetContext = STORE(_store).getAssetContext(_collateral_ticker)\r\n\r\n    # require the the loan assets match the underlying assets of the contexts\r\n    assert borrowContext.underlying == loan.borrowAsset\r\n    assert collateralContext.underlying == loan.collateralAsset\r\n\r\n    # check if this is a full repayment\r\n    if _amount != MAX_UINT256:\r\n\r\n        # require that the repay amount is greater than 0 after scaling it down\r\n        assert convert(_amount, decimal) / convert(10 ** borrowContext.decimals, decimal) > 0.0\r\n        \r\n    # check that this loan was originated with Aave V2\r\n    if keccak256(loanProtocol) == keccak256(\"compound\"):\r\n\r\n        # get the redemption amount from the Calculator\r\n        repayCalculations: CompoundRepayCalculation = COMPOUND_CALCULATOR(_calculator).calculateRepay(_borrow_ticker, _collateral_ticker, borrowContext, collateralContext, _amount, loan, _version)\r\n\r\n        # check if the borrow asset is ETH\r\n        if keccak256(_borrow_ticker) == keccak256(\"ETH\"):\r\n\r\n            # call repayBorrow() on the cEther contract and send msg.value in wei\r\n            raw_call(\r\n                borrowContext.cToken,\r\n                method_id(\"repayBorrow()\"),\r\n                value=msg.value\r\n            )\r\n\r\n        else:\r\n            # move repayment asset (borrow asset) from borrower to Greenwood\r\n            transferFromResponse: Bytes[32] = raw_call(\r\n                borrowContext.underlying,\r\n                concat(\r\n                    method_id(\"transferFrom(address,address,uint256)\"),\r\n                    convert(loan.borrower, bytes32),\r\n                    convert(self, bytes32),\r\n                    convert(repayCalculations.repayAmount, bytes32),\r\n                ),\r\n                max_outsize=32,\r\n            ) \r\n            if len(transferFromResponse) > 0:\r\n                assert convert(transferFromResponse, bool)\r\n\r\n            # approve the cToken of the borrow asset to access the token balance of Escrow\r\n            approveResponse: Bytes[32] = raw_call(\r\n                borrowContext.underlying,\r\n                concat(\r\n                    method_id(\"approve(address,uint256)\"),\r\n                    convert(borrowContext.cToken, bytes32),\r\n                    convert(repayCalculations.repayAmount, bytes32),\r\n                ),\r\n                max_outsize=32,\r\n            )\r\n            if len(approveResponse) > 0:\r\n                assert convert(approveResponse, bool)\r\n\r\n            # require that the repayment was successful\r\n            assert CTOKEN(borrowContext.cToken).repayBorrow(repayCalculations.repayAmount) == 0\r\n            \r\n        # if redemption amount is positive, redeem redemptionAmount of the collateral cToken for the underlying,\r\n        if repayCalculations.redemptionAmount < 0:\r\n\r\n            # emit a Liquidate event\r\n            log Liquidate(_loan_key, loan.outstanding, borrowContext.underlying, collateralContext.underlying, block.number)\r\n\r\n        elif repayCalculations.redemptionAmount > 0:\r\n\r\n            # get the current borrowIndex from the cToken\r\n            borrowIndex: uint256 = CTOKEN(borrowContext.cToken).borrowIndex()\r\n\r\n            # require that the redemption was successful\r\n            assert CTOKEN(collateralContext.cToken).redeemUnderlying(convert(repayCalculations.redemptionAmount, uint256)) == 0\r\n\r\n            # check if the collateral asset is ETH\r\n            if keccak256(_collateral_ticker) == keccak256(\"ETH\"):\r\n\r\n                # send the redeemed ETH back to the borrower\r\n                send(loan.borrower, convert(repayCalculations.redemptionAmount, uint256))\r\n\r\n            else:\r\n            \r\n                # transfer the redeemed collateral asset back to the borrower\r\n                transferResponse: Bytes[32] = raw_call(\r\n                    collateralContext.underlying,\r\n                    concat(\r\n                        method_id(\"transfer(address,uint256)\"),\r\n                        convert(loan.borrower, bytes32),\r\n                        convert(convert(repayCalculations.redemptionAmount, uint256), bytes32),\r\n                    ),\r\n                    max_outsize=32,\r\n                )\r\n                if len(transferResponse) > 0:\r\n                    assert convert(transferResponse, bool)\r\n\r\n            # update the loan with outstanding balance and collateral needed\r\n            STORE(_store).updateLoan(repayCalculations.requiredCollateral, borrowIndex, _loan_key, convert(repayCalculations.outstanding, uint256), _version)\r\n            \r\n            # emit a Repay event\r\n            log Repay(loan.borrower, repayCalculations.repayAmount, borrowContext.underlying, convert(repayCalculations.redemptionAmount, uint256), collateralContext.underlying, block.number)\r\n\r\n        elif repayCalculations.redemptionAmount == 0:\r\n\r\n            # emit a Repay event\r\n            log Repay(loan.borrower, repayCalculations.repayAmount, borrowContext.underlying, convert(repayCalculations.redemptionAmount, uint256), collateralContext.underlying, block.number)\r\n\r\n\r\n@external\r\n@payable\r\ndef addCollateral(_collateral_ticker: String[10], _amount: uint256, _depositor: address, _loan_key: bytes32, _store: address, _version: String[11]):\r\n    \"\"\"\r\n    @notice Add collateral to Compound\r\n    @param _collateral_ticker The ticker string of the asset that is being used as collateral\r\n    @param _amount The amount of the deposit scaled by the asset's decimals\r\n    @param _depositor The address of the depositor\r\n    @param _loan_key The uinque identifier for the loan\r\n    @param _store The address of the Greenwood Store contract to use\r\n    @param _version The version of Greenwood to use\r\n    @dev Only the Controller or the Governance can call this method\r\n    \"\"\"\r\n\r\n\r\n    # require that the method is being called by the Controller or the Governance\r\n    assert self.isAuthorized(msg.sender, \"controller\", _version) == True or self.isAuthorized(msg.sender, \"governance\", _version) == True\r\n\r\n    # get the loan's protocol from the Store\r\n    protocol: String[10] = STORE(_store).getLoanProtocol(_loan_key)\r\n\r\n    # require that a protocol was returned from the Store\r\n    assert keccak256(protocol) != keccak256(\"\")\r\n\r\n    # get the loan data from the Store\r\n    loan: Loan = STORE(_store).getLoan(_loan_key)\r\n\r\n    # get the context of the collateral asset from the Store\r\n    collateralContext: AssetContext = STORE(_store).getAssetContext(_collateral_ticker)\r\n\r\n    # require that the loan's collateral asset and underlying asset of the collateral context match\r\n    assert loan.collateralAsset == collateralContext.underlying\r\n\r\n    # require that the deposit amount is greater than 0 adter scaling it dow# require that the deposit amount is greater than 0 after scaling it down\r\n    assert convert(_amount, decimal) / convert(10 ** collateralContext.decimals, decimal) > 0.0\r\n\r\n    # check if this loan was originated with Compound\r\n    if keccak256(protocol) == keccak256(\"compound\"):\r\n\r\n        # check if the collateral asset is ETH\r\n        if keccak256(_collateral_ticker) == keccak256(\"ETH\"):\r\n\r\n            # require that the _value sent matches the _amount to add\r\n            assert _amount == msg.value\r\n\r\n            # call mint() on the cEther contract and send msg.value in wei\r\n            raw_call(\r\n                collateralContext.cToken,\r\n                method_id(\"mint()\"),\r\n                value=msg.value\r\n            )\r\n        \r\n        else:\r\n\r\n            # move collateral from user to Escrow \r\n            transferFromResponse: Bytes[32] = raw_call(\r\n                collateralContext.underlying,\r\n                concat(\r\n                    method_id(\"transferFrom(address,address,uint256)\"),\r\n                    convert(_depositor, bytes32),\r\n                    convert(self, bytes32),\r\n                    convert(_amount, bytes32),\r\n                ),\r\n                max_outsize=32,\r\n            ) \r\n            if len(transferFromResponse) > 0:\r\n                assert convert(transferFromResponse, bool)\r\n\r\n            # approve the collateral transfer from Escrow to Compound\r\n            approveResponse: Bytes[32] = raw_call(\r\n                collateralContext.underlying,\r\n                concat(\r\n                    method_id(\"approve(address,uint256)\"),\r\n                    convert(collateralContext.cToken, bytes32),\r\n                    convert(_amount, bytes32),\r\n                ),\r\n                max_outsize=32,\r\n            )\r\n            if len(approveResponse) > 0:\r\n                assert convert(approveResponse, bool)\r\n\r\n            # require that the cToken minst was successful\r\n            assert CTOKEN(collateralContext.cToken).mint(_amount) == 0\r\n\r\n        # add the amount of collateral to the existing amount of collateralLocked\r\n        collateralLocked: uint256 = loan.collateralLocked + _amount\r\n\r\n        # pass borrowIndex of 0 so this member of the struct is not updated\r\n        borrowIndex: uint256 = 0\r\n\r\n        # update the loan with the new value of collateral locked\r\n        STORE(_store).updateLoan(collateralLocked, borrowIndex, _loan_key, loan.outstanding, _version)\r\n\r\n        # emit an AddCollateral event\r\n        log AddCollateral(_loan_key, _depositor, _amount, collateralContext.underlying, block.number)\r\n        \r\n    else:\r\n        raise \"malformed protocol string\"\r\n\r\n@external\r\ndef withdrawCollateral(_borrow_ticker: String[10], _collateral_ticker: String[10], _amount: uint256, _calculator: address, _loan_key: bytes32, _store: address, _version: String[11]):\r\n    \"\"\"\r\n    @notice Withdraw collateral from Compound\r\n    @param _borrow_ticker The ticker string of the asset that was borrowed\r\n    @param _collateral_ticker The ticker string of the asset that is being used as collateral\r\n    @param _amount The amount to withdraw scaled by the asset's decimals\r\n    @param _calculator The address of the Greenwood Calculator to use\r\n    @param _loan_key The uinque identifier for the loan\r\n    @param _store The address of the Greenwood Store to use\r\n    @param _version The version of Greenwood to use\r\n    @dev Only the Controller or the Governance can call this method\r\n    \"\"\"\r\n\r\n    # require that the method is being called by the Controller or the Governance\r\n    assert self.isAuthorized(msg.sender, \"controller\", _version) == True or self.isAuthorized(msg.sender, \"governance\", _version) == True\r\n\r\n    # get the loan's protocol from the Store \r\n    protocol: String[10] = STORE(_store).getLoanProtocol(_loan_key)\r\n\r\n    # require that a protocol was returned from the Store\r\n    assert keccak256(protocol) != keccak256(\"\")\r\n\r\n    # get the loan data from the Store \r\n    loan: Loan = STORE(_store).getLoan(_loan_key)\r\n\r\n    # get the asset contexts for the borrow asset and the collateral asset from the Store\r\n    collateralContext: AssetContext = STORE(_store).getAssetContext(_collateral_ticker)\r\n    borrowContext: AssetContext = STORE(_store).getAssetContext(_borrow_ticker)\r\n\r\n    # require the the loan assets match the underlying assets of the contexts\r\n    assert loan.borrowAsset == borrowContext.underlying\r\n    assert loan.collateralAsset == collateralContext.underlying\r\n\r\n    # require that the withdraw amount is greater than 0 after scaling it down\r\n    assert convert(_amount, decimal) / convert(10 ** collateralContext.decimals, decimal) > 0.0\r\n\r\n    # check if this loan was originated with Compound\r\n    if keccak256(protocol) == keccak256(\"compound\"):\r\n\r\n        # get the withdraw calculations from the Calculator\r\n        withdrawCalculations: CompoundWithdrawCalculation = COMPOUND_CALCULATOR(_calculator).calculateWithdraw(_borrow_ticker, _collateral_ticker, borrowContext, collateralContext, loan, _version)\r\n\r\n        # require that this withdraw does not violate collateral requirements\r\n        assert loan.collateralLocked - _amount >= withdrawCalculations.requiredCollateral\r\n\r\n        # redeem the collateral and require that the redemption was successful\r\n        assert CTOKEN(collateralContext.cToken).redeemUnderlying(_amount) == 0\r\n\r\n        # recalculate collateral locked by subtracting the withdraw amount from collateralLocked\r\n        collateralLocked: uint256 = loan.collateralLocked - _amount\r\n\r\n        # check if the collateral asset is ETH\r\n        if keccak256(_collateral_ticker) == keccak256(\"ETH\"):\r\n\r\n            # send the redeemed ETH back to the borrower\r\n            send(loan.borrower, _amount)\r\n\r\n        else:\r\n\r\n            # transfer the redeemed collateral asset back to the borrower\r\n            transferResponse: Bytes[32] = raw_call(\r\n                collateralContext.underlying,\r\n                concat(\r\n                    method_id(\"transfer(address,uint256)\"),\r\n                    convert(loan.borrower, bytes32),\r\n                    convert(_amount, bytes32),\r\n                ),\r\n                max_outsize=32,\r\n            )\r\n            if len(transferResponse) > 0:\r\n                assert convert(transferResponse, bool)\r\n\r\n        # pass borrowIndex of 0 so this member of the struct is not updated\r\n        borrowIndex: uint256 = 0\r\n\r\n        # update the loan with outstanding balance and collateral needed\r\n        STORE(_store).updateLoan(collateralLocked, borrowIndex, _loan_key, withdrawCalculations.outstanding, _version)\r\n\r\n        # emit a WithdrawCollateral event\r\n        log WithdrawCollateral(_loan_key, _amount, collateralContext.underlying, collateralLocked, block.number)\r\n        \r\n    # revert, unhandled loan.protocol\r\n    else:\r\n        raise \"malformed protocol string\"\r\n\r\n@external\r\n@payable\r\ndef liquidate(_borrow_ticker: String[10], _collateral_ticker: String[10], _borrow_index: uint256, _key_count: uint256, _loan_keys: bytes32[100], _liquidator: address, _redeem_amount: uint256, _repay_amount: uint256, _store: address, _version: String[11]):\r\n    \"\"\"\r\n    @notice Liquidate undercollateralized loans\r\n    @param _borrow_ticker The ticker string of the asset that was borrowed\r\n    @param _collateral_ticker The ticker string of the asset that is being used as collateral\r\n    @param _borrow_index The latest borrow index from the underlying lending protocol\r\n    @param _key_count The number of keys in the _loan_keys array\r\n    @param _liquidator The address of the liquidator\r\n    @param _redeem_amount The amount of collateral asset to redeem\r\n    @param _repay_amount The amount of borrowed asset to repay\r\n    @param _store The address of the Greenwood Store to use\r\n    @param _version The version of Greenwood to use\r\n    @dev Only the Controller or the Governance can call this method\r\n    \"\"\"\r\n\r\n    # require that the method is being called by the Liquidator or the Governance\r\n    assert self.isAuthorized(msg.sender, \"liquidator\", _version) == True or self.isAuthorized(msg.sender, \"governance\", _version) == True\r\n\r\n    # get the asset contexts for the borrow asset and the collateral asset from the Store\r\n    borrowContext: AssetContext = STORE(_store).getAssetContext(_borrow_ticker)\r\n    collateralContext: AssetContext = STORE(_store).getAssetContext(_collateral_ticker)\r\n\r\n    # require that the liquidation redemption amount is greater than 0\r\n    assert _redeem_amount > 0\r\n\r\n    # require that the liquidation repayment amount is greater than 0\r\n    assert _repay_amount > 0\r\n\r\n    # check if the borrow asset is ETH\r\n    if keccak256(_borrow_ticker) == keccak256(\"ETH\"):\r\n\r\n        # call repayBorrow() on the cEther contract and send msg.value in wei\r\n        raw_call(\r\n            borrowContext.cToken,\r\n            method_id(\"repayBorrow()\"),\r\n            value=msg.value\r\n        )\r\n\r\n    else:\r\n\r\n        # move repayment asset (borrow asset) from borrower to Escrow\r\n        transferFromResponse: Bytes[32] = raw_call(\r\n            borrowContext.underlying,\r\n            concat(\r\n                method_id(\"transferFrom(address,address,uint256)\"),\r\n                convert(_liquidator, bytes32),\r\n                convert(self, bytes32),\r\n                convert(_repay_amount, bytes32),\r\n            ),\r\n            max_outsize=32,\r\n        ) \r\n        if len(transferFromResponse) > 0:\r\n            assert convert(transferFromResponse, bool)\r\n\r\n        # approve the cToken of the borrow asset to access the token balance of Escrow\r\n        approveResponse: Bytes[32] = raw_call(\r\n            borrowContext.underlying,\r\n            concat(\r\n                method_id(\"approve(address,uint256)\"),\r\n                convert(borrowContext.cToken, bytes32),\r\n                convert(_repay_amount, bytes32),\r\n            ),\r\n            max_outsize=32,\r\n        )\r\n        if len(approveResponse) > 0:\r\n            assert convert(approveResponse, bool)\r\n\r\n        # require that the repay was successful\r\n        assert CTOKEN(borrowContext.cToken).repayBorrow(_repay_amount) == 0\r\n\r\n    # require that the redemption was successful\r\n    assert CTOKEN(collateralContext.cToken).redeemUnderlying(_redeem_amount) == 0\r\n\r\n    # declare memory variable to store the number of loan keys that have been processed\r\n    loanKeyCounter: uint256 = 0\r\n\r\n    # update the outstanding balance and collateral needed for the loan\r\n    for i in range(LOOP_LIMIT):\r\n\r\n        # check if all loans have been liquidated\r\n        if loanKeyCounter < _key_count:\r\n            STORE(_store).updateLoan(0, _borrow_index, _loan_keys[i], 0, _version)\r\n\r\n            # increment the loan key counter\r\n            loanKeyCounter += 1\r\n        \r\n        # all loan keys have been liquidated\r\n        elif loanKeyCounter == _key_count:\r\n\r\n            # halt loop execution\r\n            break\r\n\r\n        else:\r\n\r\n            # halt loop execution as a fallback case\r\n            break\r\n\r\n    # check if the collateral asset is ETH\r\n    if keccak256(_collateral_ticker) == keccak256(\"ETH\"):\r\n\r\n        # send the redeemed ETH to the liquidator\r\n        send(_liquidator, _redeem_amount)\r\n\r\n    else:\r\n    \r\n        # transfer the redeemed collateral asset back to the borrower\r\n        transferResponse: Bytes[32] = raw_call(\r\n            collateralContext.underlying,\r\n            concat(\r\n                method_id(\"transfer(address,uint256)\"),\r\n                convert(_liquidator, bytes32),\r\n                convert(_redeem_amount, bytes32),\r\n            ),\r\n            max_outsize=32,\r\n        )\r\n        if len(transferResponse) > 0:\r\n            assert convert(transferResponse, bool)\r\n\r\n    # emit a Liquidation event\r\n    log Liquidation(borrowContext.underlying, collateralContext.underlying, _liquidator, _loan_keys, _redeem_amount, _repay_amount, block.number)\r\n\r\n@external\r\ndef claimComp(_comp: address, _comptroller: address, _version: String[11]):\r\n    \"\"\"\r\n    @notice Claims COMP rewards\r\n    @param _comp The address of COMP\r\n    @param _comptroller The address of the Compound Comptroller\r\n    @param _treasury The address of the Greenwood Treasury\r\n    @dev Only the Governance can call this method\r\n    \"\"\"\r\n\r\n    # require that the method caller is the Governance\r\n    assert self.isAuthorized(msg.sender, \"governance\", \"\") == True\r\n\r\n    # call claimComp on the Compound Comptroller\r\n    raw_call(\r\n        _comptroller,\r\n        concat(\r\n            method_id(\"claimComp(address)\"),\r\n            convert(self, bytes32)\r\n        )\r\n    )\r\n\r\n    # get the COMP balance of the Escrow\r\n    compBalance: uint256 = ERC20(_comp).balanceOf(self)\r\n\r\n\r\n    # get the address of the Treasury from the Registry\r\n    treasury: address = REGISTRY(self.registry).getAddress(\"treasury\", _version)\r\n\r\n\r\n    # transfer the claimed COMP to the Treasury\r\n    transferResponse: Bytes[32] = raw_call(\r\n        _comp,\r\n        concat(\r\n            method_id(\"transfer(address,uint256)\"),\r\n            convert(treasury, bytes32),\r\n            convert(compBalance, bytes32),\r\n        ),\r\n        max_outsize=32,\r\n    )\r\n    if len(transferResponse) > 0:\r\n        assert convert(transferResponse, bool)\r\n\r\n@external\r\ndef setRegistry(_new_registry: address):\r\n    \"\"\"\r\n    @notice Updates the address of the Registry\r\n    @param _new_registry The address of the new Greenwood Registry\r\n    @dev Only the Governance can call this method\r\n    @dev Only call this method with a valid Greenwood Registry or subsequent calls will fail!\r\n    \"\"\"\r\n\r\n    # require that the method caller is the Governance\r\n    assert self.isAuthorized(msg.sender, \"governance\", \"\") == True\r\n\r\n    # get the previous Registry\r\n    previousRegistry: address = self.registry\r\n\r\n    # update the address of the Registry\r\n    self.registry = _new_registry\r\n\r\n    # emit a SetRegistry event\r\n    log SetRegistry(previousRegistry, _new_registry, msg.sender, block.number)\r\n\r\n\r\n@external\r\n@payable\r\ndef __default__():\r\n    \"\"\"\r\n    @notice Fallback function for receiving ETH\r\n    \"\"\"\r\n\r\n    log Fallback(msg.value, msg.sender, block.number)","ABI":"[{\"name\":\"AddCollateral\",\"inputs\":[{\"type\":\"bytes32\",\"name\":\"loanKey\",\"indexed\":false},{\"type\":\"address\",\"name\":\"depositor\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"amount\",\"indexed\":false},{\"type\":\"address\",\"name\":\"collateralAsset\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"blockNumber\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Borrow\",\"inputs\":[{\"type\":\"address\",\"name\":\"borrower\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"amount\",\"indexed\":false},{\"type\":\"address\",\"name\":\"borrowAsset\",\"indexed\":false},{\"type\":\"address\",\"name\":\"collateralAsset\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"blockNumber\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Fallback\",\"inputs\":[{\"type\":\"uint256\",\"name\":\"value\",\"indexed\":false},{\"type\":\"address\",\"name\":\"sender\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"blockNumber\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Liquidate\",\"inputs\":[{\"type\":\"bytes32\",\"name\":\"loanKey\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"outstanding\",\"indexed\":false},{\"type\":\"address\",\"name\":\"borrowAsset\",\"indexed\":false},{\"type\":\"address\",\"name\":\"collateralAsset\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"blockNumber\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Liquidation\",\"inputs\":[{\"type\":\"address\",\"name\":\"borrowAsset\",\"indexed\":false},{\"type\":\"address\",\"name\":\"collateralAsset\",\"indexed\":false},{\"type\":\"address\",\"name\":\"liquidator\",\"indexed\":false},{\"type\":\"bytes32[100]\",\"name\":\"loanKeys\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"redemptionAmount\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"repayAmount\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"blockNumber\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Repay\",\"inputs\":[{\"type\":\"address\",\"name\":\"borrower\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"repaymentAmount\",\"indexed\":false},{\"type\":\"address\",\"name\":\"repaymentAsset\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"redemptionAmount\",\"indexed\":false},{\"type\":\"address\",\"name\":\"redemptionAsset\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"blockNumber\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetRegistry\",\"inputs\":[{\"type\":\"address\",\"name\":\"previousRegistry\",\"indexed\":false},{\"type\":\"address\",\"name\":\"newRegistry\",\"indexed\":false},{\"type\":\"address\",\"name\":\"governance\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"blockNumber\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"WithdrawCollateral\",\"inputs\":[{\"type\":\"bytes32\",\"name\":\"loanKey\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"amount\",\"indexed\":false},{\"type\":\"address\",\"name\":\"collateralAsset\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"collateralLocked\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"blockNumber\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_registry\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"name\":\"borrow\",\"outputs\":[],\"inputs\":[{\"type\":\"string\",\"name\":\"_borrow_ticker\"},{\"type\":\"string\",\"name\":\"_collateral_ticker\"},{\"type\":\"tuple\",\"name\":\"_borrow_context\",\"components\":[{\"type\":\"address\",\"name\":\"aToken\"},{\"type\":\"address\",\"name\":\"aaveV2PriceFeed\"},{\"type\":\"address\",\"name\":\"aaveV2LendingPool\"},{\"type\":\"address\",\"name\":\"cToken\"},{\"type\":\"address\",\"name\":\"compoundPriceFeed\"},{\"type\":\"address\",\"name\":\"comptroller\"},{\"type\":\"uint256\",\"name\":\"decimals\"},{\"type\":\"address\",\"name\":\"underlying\"}]},{\"type\":\"tuple\",\"name\":\"_collateral_context\",\"components\":[{\"type\":\"address\",\"name\":\"aToken\"},{\"type\":\"address\",\"name\":\"aaveV2PriceFeed\"},{\"type\":\"address\",\"name\":\"aaveV2LendingPool\"},{\"type\":\"address\",\"name\":\"cToken\"},{\"type\":\"address\",\"name\":\"compoundPriceFeed\"},{\"type\":\"address\",\"name\":\"comptroller\"},{\"type\":\"uint256\",\"name\":\"decimals\"},{\"type\":\"address\",\"name\":\"underlying\"}]},{\"type\":\"uint256\",\"name\":\"_amount\"},{\"type\":\"address\",\"name\":\"_borrower\"},{\"type\":\"address\",\"name\":\"_calculator\"},{\"type\":\"uint256\",\"name\":\"_collateralization_ratio\"},{\"type\":\"address\",\"name\":\"_store\"},{\"type\":\"string\",\"name\":\"_version\"}],\"stateMutability\":\"payable\",\"type\":\"function\",\"gas\":147590},{\"name\":\"repay\",\"outputs\":[],\"inputs\":[{\"type\":\"string\",\"name\":\"_borrow_ticker\"},{\"type\":\"string\",\"name\":\"_collateral_ticker\"},{\"type\":\"uint256\",\"name\":\"_amount\"},{\"type\":\"address\",\"name\":\"_calculator\"},{\"type\":\"bytes32\",\"name\":\"_loan_key\"},{\"type\":\"address\",\"name\":\"_store\"},{\"type\":\"string\",\"name\":\"_version\"}],\"stateMutability\":\"payable\",\"type\":\"function\",\"gas\":107742},{\"name\":\"addCollateral\",\"outputs\":[],\"inputs\":[{\"type\":\"string\",\"name\":\"_collateral_ticker\"},{\"type\":\"uint256\",\"name\":\"_amount\"},{\"type\":\"address\",\"name\":\"_depositor\"},{\"type\":\"bytes32\",\"name\":\"_loan_key\"},{\"type\":\"address\",\"name\":\"_store\"},{\"type\":\"string\",\"name\":\"_version\"}],\"stateMutability\":\"payable\",\"type\":\"function\",\"gas\":63347},{\"name\":\"withdrawCollateral\",\"outputs\":[],\"inputs\":[{\"type\":\"string\",\"name\":\"_borrow_ticker\"},{\"type\":\"string\",\"name\":\"_collateral_ticker\"},{\"type\":\"uint256\",\"name\":\"_amount\"},{\"type\":\"address\",\"name\":\"_calculator\"},{\"type\":\"bytes32\",\"name\":\"_loan_key\"},{\"type\":\"address\",\"name\":\"_store\"},{\"type\":\"string\",\"name\":\"_version\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":70501},{\"name\":\"liquidate\",\"outputs\":[],\"inputs\":[{\"type\":\"string\",\"name\":\"_borrow_ticker\"},{\"type\":\"string\",\"name\":\"_collateral_ticker\"},{\"type\":\"uint256\",\"name\":\"_borrow_index\"},{\"type\":\"uint256\",\"name\":\"_key_count\"},{\"type\":\"bytes32[100]\",\"name\":\"_loan_keys\"},{\"type\":\"address\",\"name\":\"_liquidator\"},{\"type\":\"uint256\",\"name\":\"_redeem_amount\"},{\"type\":\"uint256\",\"name\":\"_repay_amount\"},{\"type\":\"address\",\"name\":\"_store\"},{\"type\":\"string\",\"name\":\"_version\"}],\"stateMutability\":\"payable\",\"type\":\"function\",\"gas\":460789},{\"name\":\"claimComp\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_comp\"},{\"type\":\"address\",\"name\":\"_comptroller\"},{\"type\":\"string\",\"name\":\"_version\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":19431},{\"name\":\"setRegistry\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_new_registry\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":47193},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"name\":\"registry\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1421}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.3","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"0000000000000000000000001ddbb7a21905c6a8dbd76b20b7c6b3a55d1af24f","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":""}]}