{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ZONE.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity >=0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"./lib/Ownable.sol\\\";\\nimport \\\"./lib/Global.sol\\\";\\n\\ncontract CompBase is Ownable {\\n    using SafeMath for uint256;\\n\\n    /// @notice EIP-20 token name for this token\\n    string public constant name = \\\"GridZone.io\\\";\\n\\n    /// @notice EIP-20 token symbol for this token\\n    string public constant symbol = \\\"ZONE\\\";\\n\\n    /// @notice EIP-20 token decimals for this token\\n    uint8 public constant decimals = 18;\\n\\n    // Total number of tokens in circulation\\n    uint256 internal constant _teamSupply = 3360000 * (10 ** uint256(decimals)); // 12%\\n    uint256 internal constant _advisorsSupply = 980000 * (10 ** uint256(decimals)); // 3.5%\\n    uint256 internal constant _genesisSupply = 2800000 * (10 ** uint256(decimals)); // 10%\\n    uint256 internal constant _publicSupply = 420000 * (10 ** uint256(decimals)); // 1.5%\\n    uint256 internal constant _treasurySupply = 3640000 * (10 ** uint256(decimals)); // 13%\\n    uint256 internal constant _airdropSupply = 420000 * (10 ** uint256(decimals)); // 1.5%\\n    uint256 internal constant _ecosystemSupply = 16380000 * (10 ** uint256(decimals)); // 58.5%\\n\\n    uint256 internal constant _genesisEthCapacity = 100e18; // 100 ETH\\n    uint256 internal _publicEthCapacity = 2000e18; // 2000 ETH\\n\\n    uint256 private _totalSupply = 0;\\n    uint256 private _totalLockedTokens = 0;\\n\\n    /**\\n     * @dev Sets the value of the `cap`. This value is immutable, it can only be\\n     * set once during construction.\\n     */\\n    uint256 private constant _cap = _teamSupply + _advisorsSupply + _genesisSupply\\n        + _publicSupply + _treasurySupply + _airdropSupply + _ecosystemSupply;\\n\\n    // Allowance amounts on behalf of others\\n    mapping (address => mapping (address => uint256)) internal allowances;\\n\\n    // Official record of token balances for each account\\n    mapping (address => uint256) internal _balances;\\n\\n    /// @notice A record of each accounts delegate\\n    mapping (address => address) public delegates;\\n\\n    /// @notice A checkpoint for marking number of votes from a given block\\n    struct Checkpoint {\\n        uint32 fromBlock;\\n        uint256 votes;\\n    }\\n\\n    /// @notice A record of votes checkpoints for each account, by index\\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\\n\\n    /// @notice The number of checkpoints for each account\\n    mapping (address => uint32) public numCheckpoints;\\n\\n    // A record of the locked token\\n    uint8 internal constant LOCK_TYPE_GENESIS = 0;\\n    uint8 internal constant LOCK_TYPE_BLACKLIST = 1;\\n    struct LockedToken {\\n        uint256 id;\\n        uint8 lockType;\\n        uint256 amount;\\n        uint256 start;\\n        uint256 end;\\n    }\\n    mapping(address => LockedToken[]) internal _lockedTokens;\\n    uint256 private lastLockId = 0;\\n\\n    /// @notice The EIP-712 typehash for the contract's domain\\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\");\\n\\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\\\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\\\");\\n\\n    /// @notice A record of states for signing / validating signatures\\n    mapping (address => uint) public nonces;\\n\\n    /// @notice An event thats emitted when an account changes its delegate\\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\\n\\n    /// @notice An event thats emitted when a delegate account's vote balance changes\\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\\n\\n    /// @notice The standard EIP-20 transfer event\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    /// @notice The standard EIP-20 approval event\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /// @notice token locked event\\n    event TokenLocked(address indexed account, uint256 amount, uint8 lockType, uint256 end);\\n    event TokenUnlocked(address indexed account, uint256 amount, uint8 lockType);\\n\\n    /**\\n     * @notice Construct a new GridZone token\\n     * @param ownerAddress Owner address of the GridZone token\\n     */\\n    constructor(address ownerAddress) Ownable(ownerAddress) public {\\n    }\\n\\n    function totalSupply() public view returns (uint256) {\\n        return _totalSupply.add(_totalLockedTokens);\\n    }\\n\\n    /**\\n     * @dev Returns the cap on the token's total supply.\\n     */\\n    function cap() public pure returns (uint256) {\\n        return _cap;\\n    }\\n\\n    /**\\n     * @notice Get the number of tokens held by the `account`\\n     * @param account The address of the account to get the balance of\\n     * @return The number of tokens held\\n     */\\n    function balanceOf(address account) external view returns (uint256) {\\n        uint256 amount = _balances[account];\\n        return amount.add(getLockedAmount(account));\\n    }\\n\\n    function getLockedAmount(address account) public view returns (uint256) {\\n        LockedToken[] memory lockedTokensRef = _lockedTokens[account];\\n        uint256 length = lockedTokensRef.length;\\n\\n        uint256 amount = 0;\\n        for (uint256 i = 0; i < length; i ++) {\\n            amount = amount.add(lockedTokensRef[i].amount);\\n        }\\n        return amount;\\n    }\\n\\n    /**\\n     * @notice Gets the available votes balance for `account` regarding locked token\\n     * @param account The address to get votes balance\\n     * @return The number of available votes balance for `account`\\n     */\\n    function voteBalanceOf(address account) public view returns (uint256) {\\n        uint256 amount = _balances[account];\\n\\n        LockedToken[] memory lockedTokensRef = _lockedTokens[account];\\n        uint256 length = lockedTokensRef.length;\\n        for (uint256 i = 0; i < length; i ++) {\\n            if (lockedTokensRef[i].lockType != LOCK_TYPE_BLACKLIST) {\\n                amount = amount.add(lockedTokensRef[i].amount);\\n            }\\n        }\\n\\n        return amount;\\n    }\\n\\n    /**\\n     * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\\n     * @param account The address of the account holding the funds\\n     * @param spender The address of the account spending the funds\\n     * @return The number of tokens approved\\n     */\\n    function allowance(address account, address spender) external view returns (uint256) {\\n        return allowances[account][spender];\\n    }\\n\\n    /**\\n     * @notice Approve `spender` to transfer up to `amount` from `src`\\n     * @dev This will overwrite the approval amount for `spender`\\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\n     * @param spender The address of the account which may transfer tokens\\n     * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\\n     * @return Whether or not the approval succeeded\\n     */\\n    function approve(address spender, uint rawAmount) external returns (bool) {\\n        _approve(_msgSender(), spender, rawAmount);\\n        return true;\\n    }\\n\\n    function _approve(address owner, address spender, uint256 amount) internal {\\n        require(owner != address(0), \\\"ZONE: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ZONE: approve to the zero address\\\");\\n\\n        allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\n     * @param dst The address of the destination account\\n     * @param rawAmount The number of tokens to transfer\\n     * @return Whether or not the transfer succeeded\\n     */\\n    function transfer(address dst, uint256 rawAmount) external returns (bool) {\\n        _transferTokens(msg.sender, dst, rawAmount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Transfer `amount` tokens from `src` to `dst`\\n     * @param src The address of the source account\\n     * @param dst The address of the destination account\\n     * @param rawAmount The number of tokens to transfer\\n     * @return Whether or not the transfer succeeded\\n     */\\n    function transferFrom(address src, address dst, uint256 rawAmount) external returns (bool) {\\n        address spender = msg.sender;\\n        uint256 spenderAllowance = allowances[src][spender];\\n\\n        if (spender != src && spenderAllowance != uint256(-1)) {\\n            uint256 newAllowance = spenderAllowance.sub(rawAmount);\\n            allowances[src][spender] = newAllowance;\\n\\n            emit Approval(src, spender, newAllowance);\\n        }\\n\\n        _transferTokens(src, dst, rawAmount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Delegate votes from `msg.sender` to `delegatee`\\n     * @param delegatee The address to delegate votes to\\n     */\\n    function delegate(address delegatee) public {\\n        return _delegate(msg.sender, delegatee);\\n    }\\n\\n    /**\\n     * @notice Delegates votes from signatory to `delegatee`\\n     * @param delegatee The address to delegate votes to\\n     * @param nonce The contract state required to match the signature\\n     * @param expiry The time at which to expire the signature\\n     * @param v The recovery byte of the signature\\n     * @param r Half of the ECDSA signature pair\\n     * @param s Half of the ECDSA signature pair\\n     */\\n    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) public {\\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\\n        bytes32 digest = keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n        address signatory = ecrecover(digest, v, r, s);\\n        require(signatory != address(0), \\\"ZONE::delegateBySig: invalid signature\\\");\\n        require(nonce == nonces[signatory]++, \\\"ZONE::delegateBySig: invalid nonce\\\");\\n        require(now <= expiry, \\\"ZONE::delegateBySig: signature expired\\\");\\n        return _delegate(signatory, delegatee);\\n    }\\n\\n    /**\\n     * @notice Gets the current votes balance for `account`\\n     * @param account The address to get votes balance\\n     * @return The number of current votes for `account`\\n     */\\n    function getCurrentVotes(address account) external view returns (uint256) {\\n        uint32 nCheckpoints = numCheckpoints[account];\\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\\n    }\\n\\n    /**\\n     * @notice Determine the prior number of votes for an account as of a block number\\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\\n     * @param account The address of the account to check\\n     * @param blockNumber The block number to get the vote balance at\\n     * @return The number of votes the account had as of the given block\\n     */\\n    function getPriorVotes(address account, uint blockNumber) public view returns (uint256) {\\n        require(blockNumber < block.number, \\\"ZONE::getPriorVotes: not yet determined\\\");\\n\\n        uint32 nCheckpoints = numCheckpoints[account];\\n        if (nCheckpoints == 0) {\\n            return 0;\\n        }\\n\\n        // First check most recent balance\\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\\n            return checkpoints[account][nCheckpoints - 1].votes;\\n        }\\n\\n        // Next check implicit zero balance\\n        if (checkpoints[account][0].fromBlock > blockNumber) {\\n            return 0;\\n        }\\n\\n        uint32 lower = 0;\\n        uint32 upper = nCheckpoints - 1;\\n        while (upper > lower) {\\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\\n            Checkpoint memory cp = checkpoints[account][center];\\n            if (cp.fromBlock == blockNumber) {\\n                return cp.votes;\\n            } else if (cp.fromBlock < blockNumber) {\\n                lower = center;\\n            } else {\\n                upper = center - 1;\\n            }\\n        }\\n        return checkpoints[account][lower].votes;\\n    }\\n\\n    function _delegate(address delegator, address delegatee) internal {\\n        address currentDelegate = delegates[delegator];\\n        uint256 delegatorBalance = voteBalanceOf(delegator);\\n        delegates[delegator] = delegatee;\\n\\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\\n\\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\\n    }\\n\\n    function _transferTokens(address src, address dst, uint256 amount) internal {\\n        require(src != address(0), \\\"ZONE::_transferTokens: cannot transfer from the zero address\\\");\\n        require(dst != address(0), \\\"ZONE::_transferTokens: cannot transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(src, dst, amount);\\n\\n        _balances[src] = _balances[src].sub(amount);\\n        _balances[dst] = _balances[dst].add(amount);\\n        emit Transfer(src, dst, amount);\\n\\n        _moveDelegates(delegates[src], delegates[dst], amount);\\n    }\\n\\n    function _moveDelegates(address srcRep, address dstRep, uint256 amount) internal {\\n        if (srcRep != dstRep && amount > 0) {\\n            if (srcRep != address(0)) {\\n                uint32 srcRepNum = numCheckpoints[srcRep];\\n                uint256 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\\n                uint256 srcRepNew = srcRepOld.sub(amount);\\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\\n            }\\n\\n            if (dstRep != address(0)) {\\n                uint32 dstRepNum = numCheckpoints[dstRep];\\n                uint256 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\\n                uint256 dstRepNew = dstRepOld.add(amount);\\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\\n            }\\n        }\\n    }\\n\\n    function _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint256 oldVotes, uint256 newVotes) internal {\\n      uint32 blockNumber = safe32(block.number, \\\"ZONE::_writeCheckpoint: block number exceeds 32 bits\\\");\\n\\n      if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\\n          checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\\n      } else {\\n          checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\\n          numCheckpoints[delegatee] = nCheckpoints + 1;\\n      }\\n\\n      emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\\n    }\\n\\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\\n        require(n < 2**32, errorMessage);\\n        return uint32(n);\\n    }\\n\\n    function getChainId() internal pure returns (uint) {\\n        uint256 chainId;\\n        assembly { chainId := chainid() }\\n        return chainId;\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal {\\n        require(account != address(0), \\\"ZONE: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n\\n        _moveDelegates(address(0), delegates[account], amount);\\n    }\\n\\n    function _mintLockedToken(address account, uint256 amount, uint8 lockType, uint256 end) internal {\\n        require(account != address(0), \\\"ZONE: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalLockedTokens = _totalLockedTokens.add(amount);\\n\\n        LockedToken memory lockedToken = LockedToken({\\n            id: lastLockId++,\\n            lockType: lockType,\\n            amount: amount,\\n            start: now,\\n            end: end\\n        });\\n        _lockedTokens[account].push(lockedToken);\\n\\n        emit Transfer(address(0), account, amount);\\n\\n        if (lockType != LOCK_TYPE_BLACKLIST) {\\n            _moveDelegates(address(0), delegates[account], amount);\\n        }\\n        emit TokenLocked(account, amount, lockType, end);\\n    }\\n\\n    function _unlockToken(address account, uint256 lockId) internal {\\n        LockedToken[] storage lockedTokensRef = _lockedTokens[account];\\n        uint256 length = lockedTokensRef.length;\\n        require(0 < length, \\\"ZONE: No locked token\\\");\\n\\n        bool found = false;\\n        uint256 index = 0;\\n        for (uint256 i = 0; i < length; i++) {\\n            if (lockedTokensRef[i].id == lockId) {\\n                index = i;\\n                found = true;\\n                break;\\n            }\\n        }\\n        require(found == true, \\\"ZONE: lockId invalid\\\");\\n\\n        uint256 amount = lockedTokensRef[index].amount;\\n        uint8 lockType = lockedTokensRef[index].lockType;\\n\\n        _totalLockedTokens = _totalLockedTokens.sub(amount);\\n        _totalSupply = _totalSupply.add(amount);\\n\\n        // remove item from list\\n        uint256 lastIndex = length - 1;\\n        if (index < lastIndex) {\\n            lockedTokensRef[index] = lockedTokensRef[lastIndex];\\n        }\\n        lockedTokensRef.pop();\\n        _balances[account] = _balances[account].add(amount);\\n\\n        if (lockType == LOCK_TYPE_BLACKLIST) {\\n            _moveDelegates(address(0), delegates[account], amount);\\n        }\\n        emit TokenUnlocked(account, amount, lockType);\\n    }\\n\\n    function getLockedTokens(address account) external view returns (LockedToken[] memory) {\\n        LockedToken[] memory lockedTokensRef = _lockedTokens[account];\\n        return lockedTokensRef;\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal {\\n        require(account != address(0), \\\"ZONE: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ZONE: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n\\n        _moveDelegates(delegates[account], address(0), amount);\\n    }\\n\\n    /**\\n     * @dev See {ERC20-_beforeTokenTransfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - minted tokens must not cause the total supply to go over the cap.\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) view internal {\\n        if (from == address(0)) { // When minting tokens\\n            require(totalSupply().add(amount) <= _cap, \\\"Capped: cap exceeded\\\");\\n        }\\n    }\\n}\\n\\n\\n/**\\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\\n * tokens and those that they have an allowance for, in a way that can be\\n * recognized off-chain (via event analysis).\\n */\\nabstract contract ERC20Burnable is CompBase {\\n    /**\\n     * @dev Destroys `amount` tokens from the caller.\\n     *\\n     * See {ERC20-_burn}.\\n     */\\n    function burn(uint256 amount) public {\\n        _burn(_msgSender(), amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\\n     * allowance.\\n     *\\n     * See {ERC20-_burn} and {ERC20-allowance}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have allowance for ``accounts``'s tokens of at least\\n     * `amount`.\\n     */\\n    function burnFrom(address account, uint256 amount) public {\\n        address spender = _msgSender();\\n        uint256 spenderAllowance = allowances[account][spender];\\n        uint256 decreasedAllowance = spenderAllowance.sub(amount, \\\"ZONE::burnFrom: burn amount exceeds allowance\\\");\\n\\n        _approve(account, spender, decreasedAllowance);\\n        _burn(account, amount);\\n    }\\n}\\n\\ncontract ZONE is CompBase, ERC20Burnable {\\n    using SafeMath for uint256;\\n\\n    uint256 public immutable launchTime;\\n\\n    address public immutable vault;\\n\\n    uint256 private _genesisRate;\\n    uint256 private _publicRate;\\n    uint256 public immutable genesisSaleEndTime;\\n    uint256 public immutable genesisSaleUnlockTime;\\n\\n    // total purchased eth amount during ICO. The unit is wei\\n    uint256 public genesisSaleBoughtEth = 0;\\n    uint256 public publicSaleBoughtEth = 0;\\n\\n    uint256 public genesisSaleSoldToken = 0;\\n    uint256 public publicSaleSoldToken = 0;\\n\\n    bool private _genesisSaleFinished = false;\\n    bool private _publicSaleFinished = false;\\n\\n    struct Vest {\\n        address beneficiary;\\n        uint256 start;\\n        uint256 cliff;\\n        uint256 duration;\\n        uint256 amount;\\n        uint256 claimedAmount;\\n        bool revoked;\\n    }\\n    mapping (address => Vest) public vests;\\n\\n    uint16[] private quarterlyRate; // sum is same with quarterlyRateDenominator\\n    uint16 private constant quarterlyRateDenominator = 10000;\\n    uint256 public claimedEcosystemVest = 0;\\n\\n    address private governorTimelock;\\n\\n    event VestAdded(address indexed beneficiary, uint256 start, uint256 cliff, uint256 duration, uint256 amount);\\n    event VestClaimed(address indexed beneficiary, uint256 amount);\\n    event EcosystemVestClaimed(address indexed account, uint256 amount);\\n    event SoldOnGenesisSale(address indexed buyer, uint256 ethAmount, uint256 tokenAmount);\\n    event SoldOnPublicSale(address indexed buyer, uint256 ethAmount, uint256 tokenAmount);\\n    event GenesisSaleFinished(uint256 boughtEth, uint256 soldToken);\\n    event PublicSaleFinished(uint256 boughtEth, uint256 soldToken);\\n    event GenesisSaleRateChanged(uint256 newRate);\\n    event PublicSaleRateChanged(uint256 newRate);\\n    event PublicSaleEthCapacityChanged(uint256 newRate, uint256 newEthCapacity);\\n\\n    constructor(address owner_, address vault_, address advisors_, address treasury_) CompBase(owner_) public {\\n        require(owner_ != vault_, \\\"ZONE: You specified owner address as an vault address\\\");\\n        launchTime = now;\\n        quarterlyRate = [3182, 2676, 2250, 1892];\\n\\n        vault = vault_;\\n\\n        _genesisRate = _genesisSupply.mul(10).div(_genesisEthCapacity).div(12); // 2/12 is for bonuses\\n        _publicRate = _publicSupply.div(_publicEthCapacity);\\n        genesisSaleEndTime = now + GLOBAL.SECONDS_IN_MONTH * 3;\\n        genesisSaleUnlockTime = now + GLOBAL.SECONDS_IN_MONTH * 4;\\n\\n        AddVest(owner_, now, 0, GLOBAL.SECONDS_IN_YEAR * 2, _teamSupply);\\n        AddVest(advisors_, now, 0, GLOBAL.SECONDS_IN_YEAR, _advisorsSupply);\\n\\n        _mintLockedToken(treasury_, _treasurySupply, LOCK_TYPE_BLACKLIST, now + GLOBAL.SECONDS_IN_YEAR);\\n        _mint(vault_, _airdropSupply);\\n    }\\n\\n    modifier onlyCommunity() {\\n        require(msg.sender == governorTimelock, \\\"ZONE: The caller is not the governance timelock contract.\\\");\\n        _;\\n    }\\n\\n    modifier onlyEndUser {\\n        require(msg.sender == tx.origin, \\\"ZONE: Only end-user\\\");\\n        _;\\n    }\\n\\n    function setGovernorTimelock(address governorTimelock_) external onlyOwner  {\\n        governorTimelock = governorTimelock_;\\n    }\\n\\n    /**\\n    * @param beneficiary address of the beneficiary to whom vested tokens are transferred\\n    * @param cliff duration in seconds of the cliff in which tokens will begin to vest\\n    * @param duration duration in seconds of the period in which the tokens will vest\\n    */\\n    function AddVest(address beneficiary, uint256 start, uint256 cliff, uint256 duration, uint256 amount) internal {\\n        require(beneficiary != address(0), \\\"ZONE::AddVest Invalid beneficiary\\\");\\n        require(cliff <= duration, \\\"ZONE::AddVest cliff > duration\\\");\\n\\n        Vest memory vest = Vest({\\n            beneficiary: beneficiary,\\n            start: start,\\n            cliff: start.add(cliff),\\n            duration: duration,\\n            amount: amount,\\n            claimedAmount: 0,\\n            revoked: false\\n        });\\n\\n        vests[beneficiary] = vest;\\n        emit VestAdded(beneficiary, start, cliff, duration, amount);\\n    }\\n\\n    function calculateVestClaim(address beneficiary) public view returns (uint256 vestedAmount, uint256 claimedAmount) {\\n        Vest storage vest = vests[beneficiary];\\n        if (vest.beneficiary != beneficiary) {\\n            // Invalid beneficiary\\n            return (0, 0);\\n        }\\n\\n        if (now < vest.cliff) {\\n            // For vest created with a future start date, that hasn't been reached, return 0, 0\\n            return (0, vest.claimedAmount);\\n        } else if (vest.revoked == true) {\\n            return (vest.claimedAmount, vest.claimedAmount);\\n        } else if (vest.start.add(vest.duration) <= now) {\\n            return (vest.amount, vest.claimedAmount);\\n        } else {\\n            vestedAmount = vest.amount.mul(now.sub(vest.start)).div(vest.duration);\\n            return (vestedAmount, vest.claimedAmount);\\n        }\\n    }\\n\\n    function claimVestedToken(address beneficiary) external {\\n        (uint256 vested, uint256 claimed) = calculateVestClaim(beneficiary);\\n        require(claimed < vested, \\\"ZONE: No claimable token\\\");\\n\\n        uint256 fund = vested.sub(claimed);\\n        vests[beneficiary].claimedAmount = vested;\\n        _mint(beneficiary, fund);\\n        emit VestClaimed(beneficiary, fund);\\n    }\\n\\n    function revokeVest(address beneficiary) external onlyCommunity {\\n        Vest storage vest = vests[beneficiary];\\n        require(vest.beneficiary == beneficiary, \\\"ZONE: Invalid beneficiary\\\");\\n        require(vest.revoked == false, \\\"ZONE: Already revoked\\\");\\n\\n        uint256 fund = vest.amount.sub(vest.claimedAmount);\\n        if (0 < fund) {\\n            vest.claimedAmount = vest.amount;\\n            _mint(beneficiary, fund);\\n            emit VestClaimed(beneficiary, fund);\\n        }\\n        vest.revoked = true;\\n    }\\n\\n    //\\n    // Unlock token\\n    //\\n    function getUnlockableAmount(address account) public view returns (uint256) {\\n        LockedToken[] memory lockedTokensRef = _lockedTokens[account];\\n        uint256 length = lockedTokensRef.length;\\n\\n        uint256 amount = 0;\\n        for (uint256 i = 0; i < length; i ++) {\\n            if (_isUnlockable(lockedTokensRef[i].lockType, lockedTokensRef[i].end) == true) {\\n                amount = amount.add(lockedTokensRef[i].amount);\\n            }\\n        }\\n        return amount;\\n    }\\n\\n    function Unlock(address account) public returns (uint256) {\\n        LockedToken[] memory lockedTokensRef = _lockedTokens[account];\\n        uint256 length = lockedTokensRef.length;\\n        bool unlocked = false;\\n\\n        for (uint256 i = 0; i < length; i ++) {\\n            if (_isUnlockable(lockedTokensRef[i].lockType, lockedTokensRef[i].end) == true) {\\n                _unlockToken(account, lockedTokensRef[i].id);\\n                unlocked = true;\\n            }\\n        }\\n        require(unlocked, \\\"ZONE: No unlockable token.\\\");\\n    }\\n\\n    function _isUnlockable(uint8 lockType, uint256 end) internal view returns (bool) {\\n        if (end <= now) {\\n            return true;\\n        }\\n        if ((lockType == LOCK_TYPE_GENESIS) && _publicSaleFinished) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    function revokeBlacklistLock(address account) external onlyCommunity {\\n        LockedToken[] memory lockedTokensRef = _lockedTokens[account];\\n        uint256 length = lockedTokensRef.length;\\n\\n        for (uint256 i = 0; i < length; i ++) {\\n            if (lockedTokensRef[i].lockType == LOCK_TYPE_BLACKLIST) {\\n                _unlockToken(account, lockedTokensRef[i].id);\\n            }\\n        }\\n    }\\n\\n    //\\n    // Quarterly vesting for ecosystem\\n    //\\n    function calculateEcosystemVested() public view returns (uint256 vestedAmount) {\\n        uint256 quartersCount = now.sub(launchTime).div(GLOBAL.SECONDS_IN_QUARTER);\\n        uint256 yearsCount = quartersCount.div(GLOBAL.QUARTERS_IN_YEAR);\\n        uint256 currentQurter = quartersCount.mod(GLOBAL.QUARTERS_IN_YEAR);\\n        uint256 yearSupply = _ecosystemSupply >> (yearsCount + 1);\\n\\n        if (0 < yearsCount) {\\n            // _ecosystemSupply * (1 - 1 / (2*yearsCount))\\n            vestedAmount =  _ecosystemSupply.sub(_ecosystemSupply.div(2).div(yearsCount));\\n        } else {\\n            vestedAmount = 0;\\n        }\\n\\n        for (uint8 quarter = 0; quarter <= currentQurter; quarter ++) {\\n            uint256 vestedInQuarter = yearSupply.mul(quarterlyRate[quarter]).div(quarterlyRateDenominator);\\n            vestedAmount = vestedAmount.add(vestedInQuarter);\\n        }\\n        return vestedAmount;\\n    }\\n\\n    function claimEcosystemVest() external {\\n        uint256 vested = calculateEcosystemVested();\\n        require (claimedEcosystemVest < vested, \\\"ZONE: No claimable token for the ecosystem.\\\");\\n\\n        uint256 fund = vested.sub(claimedEcosystemVest);\\n        claimedEcosystemVest = vested;\\n        _mint(vault, fund);\\n        emit EcosystemVestClaimed(vault, fund);\\n    }\\n\\n    function revokeEcosystemVest() external onlyCommunity {\\n        require (claimedEcosystemVest < _ecosystemSupply, \\\"ZONE: All tokens already have been claimed for the ecosystem.\\\");\\n\\n        uint256 fund = _ecosystemSupply.sub(claimedEcosystemVest);\\n        claimedEcosystemVest = _ecosystemSupply;\\n        _mint(vault, fund);\\n        emit EcosystemVestClaimed(vault, fund);\\n    }\\n\\n    //\\n    // Genesis and Public sale\\n    //\\n    function isGenesisSaleFinished() external view returns (bool) {\\n        if (_genesisSaleFinished == true || genesisSaleEndTime <= now) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    function isPublicSaleFinished() external view returns (bool) {\\n        return _publicSaleFinished;\\n    }\\n\\n    // Crowds Sale contains both the Genesis sale and the Public sale\\n    function isCrowdsaleFinished() external view returns (bool) {\\n        if (_publicSaleFinished) return true;\\n        if (genesisSaleEndTime <= now) return false;\\n        if (_genesisSaleFinished) return true;\\n        return false;\\n    }\\n\\n    function rate() public view returns (uint256) {\\n        return (now < genesisSaleEndTime) ? _genesisRate : _publicRate;\\n    }\\n\\n    function getGenesisSaleRate() external view returns(uint256) {\\n        return _genesisRate;\\n    }\\n\\n    function setGenesisSaleRate(uint256 newRate) external onlyOwner {\\n        require(0 < newRate, \\\"ZONE: The rate can't be 0.\\\");\\n        _genesisRate = newRate;\\n        emit GenesisSaleRateChanged(_genesisRate);\\n    }\\n\\n    function getPublicSaleRate() external view returns(uint256) {\\n        return _publicRate;\\n    }\\n\\n    function setPublicSaleRate(uint256 newRate) public onlyOwner {\\n        require(0 < newRate, \\\"ZONE: The rate can't be 0.\\\");\\n        _publicRate = newRate;\\n        emit PublicSaleRateChanged(_publicRate);\\n    }\\n\\n    function getPublicSaleEthCapacity() external view returns(uint256) {\\n        return _publicEthCapacity;\\n    }\\n\\n    function setPublicSaleEthCapacity(uint256 newEthCapacity) public onlyOwner {\\n        require(publicSaleBoughtEth < newEthCapacity, \\\"ZONE: The capacity must be greater than the already bought amount in the public sale.\\\");\\n\\n        _publicRate = _publicSupply.sub(publicSaleSoldToken).div(newEthCapacity.sub(publicSaleBoughtEth));\\n        _publicEthCapacity = newEthCapacity;\\n        emit PublicSaleEthCapacityChanged(_publicRate, _publicEthCapacity);\\n    }\\n\\n    function finishCrowdsale() external onlyOwner  {\\n        _finishGenesisSale();\\n       if (genesisSaleEndTime <= now) {\\n           _finishPublicSale();\\n       }\\n    }\\n    \\n    function _finishGenesisSale() private {\\n        if (_genesisSaleFinished) return;\\n        _genesisSaleFinished = true;\\n\\n        uint256 leftOver = _genesisSupply.sub(genesisSaleSoldToken);\\n        if (leftOver > 0) {\\n            _mint(owner(), leftOver);\\n        }\\n        emit GenesisSaleFinished(genesisSaleBoughtEth, genesisSaleSoldToken);\\n    }\\n\\n    function _finishPublicSale() private {\\n        if (_publicSaleFinished) return;\\n        _publicSaleFinished = true;\\n\\n        uint256 leftOver = _publicSupply.sub(publicSaleSoldToken);\\n        if (leftOver > 0) {\\n            _mint(owner(), leftOver);\\n        }\\n        emit PublicSaleFinished(publicSaleBoughtEth, publicSaleSoldToken);\\n    }\\n\\n    function _sellOnGenesisSale(address payable buyer, uint256 ethAmount) private {\\n        uint256 capacity = _genesisEthCapacity.sub(genesisSaleBoughtEth);\\n        uint256 _ethAmount = (ethAmount < capacity) ? ethAmount : capacity;\\n        uint256 refund = ethAmount - _ethAmount;\\n        require(0 < _ethAmount, \\\"ZONE: The amount can't be 0.\\\");\\n\\n        uint256 amount = _ethAmount.mul(_genesisRate);\\n        uint256 genesisBonus = amount.div(10);   // when buying during Genesis sale, 10% bonus\\n        uint256 purchaseBonus = 0;\\n\\n        if (_ethAmount >= 10e18) {\\n            // when buying for over 10eth, 10% bonus\\n            purchaseBonus = amount.div(10);\\n        }\\n\\n        // total token amount\\n        amount = amount.add(genesisBonus).add(purchaseBonus);\\n\\n        genesisSaleBoughtEth = genesisSaleBoughtEth.add(_ethAmount);\\n        genesisSaleSoldToken = genesisSaleSoldToken.add(amount);\\n        require(genesisSaleSoldToken <= _genesisSupply, \\\"ZONE: Genesis supply is insufficient.\\\");\\n\\n        // mint token amount and bonuses to buyer\\n        _mintLockedToken(buyer, amount, LOCK_TYPE_GENESIS, genesisSaleUnlockTime);\\n\\n        address payable ownerAddress = address(uint160(owner()));\\n        ownerAddress.transfer(_ethAmount);\\n        emit SoldOnGenesisSale(buyer, _ethAmount, amount);\\n\\n        if (0 < refund) {\\n            buyer.transfer(refund);\\n        }\\n        if (_genesisEthCapacity <= genesisSaleBoughtEth) {\\n            _finishGenesisSale();\\n        }\\n    }\\n\\n    function _sellOnPublicSale(address payable buyer, uint256 ethAmount) private {\\n        uint256 capacity = _publicEthCapacity.sub(publicSaleBoughtEth);\\n        uint256 _ethAmount = (ethAmount < capacity) ? ethAmount : capacity;\\n        uint256 refund = ethAmount - _ethAmount;\\n        require(0 < _ethAmount, \\\"ZONE: The amount can't be 0.\\\");\\n\\n        uint256 amount = _ethAmount.mul(_publicRate);\\n\\n        publicSaleBoughtEth = publicSaleBoughtEth.add(_ethAmount);\\n        publicSaleSoldToken = publicSaleSoldToken.add(amount);\\n        require(publicSaleSoldToken <= _publicSupply, \\\"ZONE: Public supply is insufficient.\\\");\\n\\n        // mint token amount to buyer\\n        _mint(buyer, amount);\\n\\n        address payable ownerAddress = address(uint160(owner()));\\n        ownerAddress.transfer(_ethAmount);\\n        emit SoldOnPublicSale(buyer, _ethAmount, amount);\\n\\n        if (0 < refund) {\\n            buyer.transfer(refund);\\n        }\\n        if (_publicEthCapacity <= publicSaleBoughtEth) {\\n            _finishPublicSale();\\n        }\\n    }\\n\\n    // low level token purchase function\\n    function purchase() external payable onlyEndUser {\\n        address payable buyer = _msgSender();\\n        require(buyer != address(0));\\n        require(msg.value >= 1e16, \\\"ZONE: The purchase minimum amount is 0.01 ETH\\\");\\n\\n        if (now < genesisSaleEndTime) {\\n            require(_genesisSaleFinished == false, \\\"ZONE: Genesis sale already finished\\\");\\n            _sellOnGenesisSale(buyer, msg.value);\\n        } else {\\n            _finishGenesisSale();\\n\\n            require(_publicSaleFinished == false, \\\"ZONE: Public sale already finished\\\");\\n            _sellOnPublicSale(buyer, msg.value);\\n        }\\n    }\\n\\n    receive() external payable {\\n        require(false, \\\"ZONE: Use the purchase function to buy the ZONE token.\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n    address private _pendingOwner;\\n\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor (address owner) internal {\\n        _owner = owner;\\n        emit OwnershipTransferred(address(0), owner);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the pending owner.\\n     */\\n    function pendingOwner() public view virtual returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _pendingOwner = newOwner;\\n    }\\n\\n    function acceptOwnership() external {\\n        require(msg.sender == _pendingOwner, \\\"acceptOwnership: Call must come from pendingOwner.\\\");\\n        emit OwnershipTransferred(_owner, _pendingOwner);\\n        _owner = _pendingOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Global.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity >=0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nlibrary GLOBAL {\\n    uint256 constant SECONDS_IN_YEAR = 365 * 24 * 3600; // 365 days * 24 hours * 60 minutes * 60 seconds\\n    uint256 constant SECONDS_IN_QUARTER = SECONDS_IN_YEAR / 4;\\n    uint256 constant SECONDS_IN_MONTH = 30 * 24 * 3600; // 30 days * 24 hours * 60 minutes * 60 seconds\\n\\n    uint8 constant QUARTERS_IN_YEAR = 4;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vault_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"advisors_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"treasury_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fromDelegate\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"toDelegate\",\"type\":\"address\"}],\"name\":\"DelegateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBalance\",\"type\":\"uint256\"}],\"name\":\"DelegateVotesChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EcosystemVestClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"boughtEth\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"soldToken\",\"type\":\"uint256\"}],\"name\":\"GenesisSaleFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRate\",\"type\":\"uint256\"}],\"name\":\"GenesisSaleRateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newEthCapacity\",\"type\":\"uint256\"}],\"name\":\"PublicSaleEthCapacityChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"boughtEth\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"soldToken\",\"type\":\"uint256\"}],\"name\":\"PublicSaleFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRate\",\"type\":\"uint256\"}],\"name\":\"PublicSaleRateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"SoldOnGenesisSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"SoldOnPublicSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"lockType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"TokenLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"lockType\",\"type\":\"uint8\"}],\"name\":\"TokenUnlocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cliff\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"VestAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"VestClaimed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DELEGATION_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rawAmount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calculateEcosystemVested\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"vestedAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"calculateVestClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"vestedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"checkpoints\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"fromBlock\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"votes\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimEcosystemVest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"claimVestedToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimedEcosystemVest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"}],\"name\":\"delegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"delegateBySig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"delegates\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finishCrowdsale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"genesisSaleBoughtEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"genesisSaleEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"genesisSaleSoldToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"genesisSaleUnlockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getCurrentVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGenesisSaleRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getLockedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getLockedTokens\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"lockType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"internalType\":\"struct CompBase.LockedToken[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"getPriorVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPublicSaleEthCapacity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPublicSaleRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getUnlockableAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isCrowdsaleFinished\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isGenesisSaleFinished\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPublicSaleFinished\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launchTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"numCheckpoints\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicSaleBoughtEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicSaleSoldToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"purchase\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeBlacklistLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revokeEcosystemVest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"revokeVest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newRate\",\"type\":\"uint256\"}],\"name\":\"setGenesisSaleRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governorTimelock_\",\"type\":\"address\"}],\"name\":\"setGovernorTimelock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newEthCapacity\",\"type\":\"uint256\"}],\"name\":\"setPublicSaleEthCapacity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newRate\",\"type\":\"uint256\"}],\"name\":\"setPublicSaleRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rawAmount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rawAmount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"vests\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cliff\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"revoked\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"voteBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"ZONE","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"000000000000000000000000a6052fdc72332408d9fbfdb2226b5bbdeb24fac3000000000000000000000000e136b97a1def10f2b23ae078932e57e07d77b9140000000000000000000000000c33655ee1cdb297be354de317d4bfd07a3766190000000000000000000000005b12180c56ef949a73254c895fc61431882f8f04","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}