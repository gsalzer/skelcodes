{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"cache/solpp-generated-contracts/Governance.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\nimport \\\"./Config.sol\\\";\\nimport \\\"./Utils.sol\\\";\\nimport \\\"./NFTFactory.sol\\\";\\nimport \\\"./TokenGovernance.sol\\\";\\n\\n/// @title Governance Contract\\n/// @author Matter Labs\\ncontract Governance is Config {\\n    /// @notice Token added to Franklin net\\n    event NewToken(address indexed token, uint16 indexed tokenId);\\n\\n    /// @notice Default nft factory has set\\n    event SetDefaultNFTFactory(address indexed factory);\\n\\n    /// @notice NFT factory registered new creator account\\n    event NFTFactoryRegisteredCreator(\\n        uint32 indexed creatorAccountId,\\n        address indexed creatorAddress,\\n        address factoryAddress\\n    );\\n\\n    /// @notice Governor changed\\n    event NewGovernor(address newGovernor);\\n\\n    /// @notice Token Governance changed\\n    event NewTokenGovernance(TokenGovernance newTokenGovernance);\\n\\n    /// @notice Validator's status changed\\n    event ValidatorStatusUpdate(address indexed validatorAddress, bool isActive);\\n\\n    event TokenPausedUpdate(address indexed token, bool paused);\\n\\n    /// @notice Address which will exercise governance over the network i.e. add tokens, change validator set, conduct upgrades\\n    address public networkGovernor;\\n\\n    /// @notice Total number of ERC20 tokens registered in the network (excluding ETH, which is hardcoded as tokenId = 0)\\n    uint16 public totalTokens;\\n\\n    /// @notice List of registered tokens by tokenId\\n    mapping(uint16 => address) public tokenAddresses;\\n\\n    /// @notice List of registered tokens by address\\n    mapping(address => uint16) public tokenIds;\\n\\n    /// @notice List of permitted validators\\n    mapping(address => bool) public validators;\\n\\n    /// @notice Paused tokens list, deposits are impossible to create for paused tokens\\n    mapping(uint16 => bool) public pausedTokens;\\n\\n    /// @notice Address that is authorized to add tokens to the Governance.\\n    TokenGovernance public tokenGovernance;\\n\\n    /// @notice NFT Creator address to factory address mapping\\n    mapping(uint32 => mapping(address => NFTFactory)) public nftFactories;\\n\\n    /// @notice Address which will be used if NFT token has no factories\\n    NFTFactory public defaultFactory;\\n\\n    /// @notice Governance contract initialization. Can be external because Proxy contract intercepts illegal calls of this function.\\n    /// @param initializationParameters Encoded representation of initialization parameters:\\n    ///     _networkGovernor The address of network governor\\n    function initialize(bytes calldata initializationParameters) external {\\n        address _networkGovernor = abi.decode(initializationParameters, (address));\\n\\n        networkGovernor = _networkGovernor;\\n    }\\n\\n    /// @notice Governance contract upgrade. Can be external because Proxy contract intercepts illegal calls of this function.\\n    /// @param upgradeParameters Encoded representation of upgrade parameters\\n    // solhint-disable-next-line no-empty-blocks\\n    function upgrade(bytes calldata upgradeParameters) external {}\\n\\n    /// @notice Change current governor\\n    /// @param _newGovernor Address of the new governor\\n    function changeGovernor(address _newGovernor) external {\\n        requireGovernor(msg.sender);\\n        if (networkGovernor != _newGovernor) {\\n            networkGovernor = _newGovernor;\\n            emit NewGovernor(_newGovernor);\\n        }\\n    }\\n\\n    /// @notice Change current token governance\\n    /// @param _newTokenGovernance Address of the new token governor\\n    function changeTokenGovernance(TokenGovernance _newTokenGovernance) external {\\n        requireGovernor(msg.sender);\\n        if (tokenGovernance != _newTokenGovernance) {\\n            tokenGovernance = _newTokenGovernance;\\n            emit NewTokenGovernance(_newTokenGovernance);\\n        }\\n    }\\n\\n    /// @notice Add token to the list of networks tokens\\n    /// @param _token Token address\\n    function addToken(address _token) external {\\n        require(msg.sender == address(tokenGovernance), \\\"1E\\\");\\n        require(tokenIds[_token] == 0, \\\"1e\\\"); // token exists\\n        require(totalTokens < MAX_AMOUNT_OF_REGISTERED_TOKENS, \\\"1f\\\"); // no free identifiers for tokens\\n\\n        totalTokens++;\\n        uint16 newTokenId = totalTokens; // it is not `totalTokens - 1` because tokenId = 0 is reserved for eth\\n\\n        tokenAddresses[newTokenId] = _token;\\n        tokenIds[_token] = newTokenId;\\n        emit NewToken(_token, newTokenId);\\n    }\\n\\n    /// @notice Pause token deposits for the given token\\n    /// @param _tokenAddr Token address\\n    /// @param _tokenPaused Token paused status\\n    function setTokenPaused(address _tokenAddr, bool _tokenPaused) external {\\n        requireGovernor(msg.sender);\\n\\n        uint16 tokenId = this.validateTokenAddress(_tokenAddr);\\n        if (pausedTokens[tokenId] != _tokenPaused) {\\n            pausedTokens[tokenId] = _tokenPaused;\\n            emit TokenPausedUpdate(_tokenAddr, _tokenPaused);\\n        }\\n    }\\n\\n    /// @notice Change validator status (active or not active)\\n    /// @param _validator Validator address\\n    /// @param _active Active flag\\n    function setValidator(address _validator, bool _active) external {\\n        requireGovernor(msg.sender);\\n        if (validators[_validator] != _active) {\\n            validators[_validator] = _active;\\n            emit ValidatorStatusUpdate(_validator, _active);\\n        }\\n    }\\n\\n    /// @notice Check if specified address is is governor\\n    /// @param _address Address to check\\n    function requireGovernor(address _address) public view {\\n        require(_address == networkGovernor, \\\"1g\\\"); // only by governor\\n    }\\n\\n    /// @notice Checks if validator is active\\n    /// @param _address Validator address\\n    function requireActiveValidator(address _address) external view {\\n        require(validators[_address], \\\"1h\\\"); // validator is not active\\n    }\\n\\n    /// @notice Validate token id (must be less than or equal to total tokens amount)\\n    /// @param _tokenId Token id\\n    /// @return bool flag that indicates if token id is less than or equal to total tokens amount\\n    function isValidTokenId(uint16 _tokenId) external view returns (bool) {\\n        return _tokenId <= totalTokens;\\n    }\\n\\n    /// @notice Validate token address\\n    /// @param _tokenAddr Token address\\n    /// @return tokens id\\n    function validateTokenAddress(address _tokenAddr) external view returns (uint16) {\\n        uint16 tokenId = tokenIds[_tokenAddr];\\n        require(tokenId != 0, \\\"1i\\\"); // 0 is not a valid token\\n        return tokenId;\\n    }\\n\\n    function packRegisterNFTFactoryMsg(\\n        uint32 _creatorAccountId,\\n        address _creatorAddress,\\n        address _factoryAddress\\n    ) internal pure returns (bytes memory) {\\n        return\\n            abi.encodePacked(\\n                \\\"\\\\x19Ethereum Signed Message:\\\\n141\\\",\\n                \\\"\\\\nCreator's account ID in zkSync: \\\",\\n                Bytes.bytesToHexASCIIBytes(abi.encodePacked((_creatorAccountId))),\\n                \\\"\\\\nCreator: \\\",\\n                Bytes.bytesToHexASCIIBytes(abi.encodePacked((_creatorAddress))),\\n                \\\"\\\\nFactory: \\\",\\n                Bytes.bytesToHexASCIIBytes(abi.encodePacked((_factoryAddress)))\\n            );\\n    }\\n\\n    /// @notice Register creator corresponding to the factory\\n    /// @param _creatorAccountId Creator's zkSync account ID\\n    /// @param _creatorAddress NFT creator address\\n    /// @param _signature Creator's signature\\n    function registerNFTFactoryCreator(\\n        uint32 _creatorAccountId,\\n        address _creatorAddress,\\n        bytes memory _signature\\n    ) external {\\n        require(address(nftFactories[_creatorAccountId][_creatorAddress]) == address(0), \\\"Q\\\");\\n        bytes32 messageHash = keccak256(packRegisterNFTFactoryMsg(_creatorAccountId, _creatorAddress, msg.sender));\\n\\n        address recoveredAddress = Utils.recoverAddressFromEthSignature(_signature, messageHash);\\n        require(recoveredAddress == _creatorAddress && recoveredAddress != address(0), \\\"ws\\\");\\n        nftFactories[_creatorAccountId][_creatorAddress] = NFTFactory(msg.sender);\\n        emit NFTFactoryRegisteredCreator(_creatorAccountId, _creatorAddress, msg.sender);\\n    }\\n\\n    //@notice Set default factory for our contract. This factory will be used to mint an NFT token that has no factory\\n    //@param _factory Address of NFT factory\\n    function setDefaultNFTFactory(address _factory) external {\\n        requireGovernor(msg.sender);\\n        require(address(_factory) != address(0), \\\"mb1\\\"); // Factory should be non zero\\n        require(address(defaultFactory) == address(0), \\\"mb2\\\"); // NFTFactory is already set\\n        defaultFactory = NFTFactory(_factory);\\n        emit SetDefaultNFTFactory(_factory);\\n    }\\n\\n    function getNFTFactory(uint32 _creatorAccountId, address _creatorAddress) external view returns (NFTFactory) {\\n        NFTFactory _factory = nftFactories[_creatorAccountId][_creatorAddress];\\n        if (address(_factory) == address(0)) {\\n            require(address(defaultFactory) != address(0), \\\"fs\\\"); // NFTFactory does not set\\n            return defaultFactory;\\n        } else {\\n            return _factory;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/Config.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n/// @title zkSync configuration constants\\n/// @author Matter Labs\\ncontract Config {\\n    /// @dev ERC20 tokens and ETH withdrawals gas limit, used only for complete withdrawals\\n    uint256 internal constant WITHDRAWAL_GAS_LIMIT = 100000;\\n\\n    /// @dev NFT withdrawals gas limit, used only for complete withdrawals\\n    uint256 internal constant WITHDRAWAL_NFT_GAS_LIMIT = 300000;\\n\\n    /// @dev Bytes in one chunk\\n    uint8 internal constant CHUNK_BYTES = 10;\\n\\n    /// @dev zkSync address length\\n    uint8 internal constant ADDRESS_BYTES = 20;\\n\\n    uint8 internal constant PUBKEY_HASH_BYTES = 20;\\n\\n    /// @dev Public key bytes length\\n    uint8 internal constant PUBKEY_BYTES = 32;\\n\\n    /// @dev Ethereum signature r/s bytes length\\n    uint8 internal constant ETH_SIGN_RS_BYTES = 32;\\n\\n    /// @dev Success flag bytes length\\n    uint8 internal constant SUCCESS_FLAG_BYTES = 1;\\n\\n    /// @dev Max amount of tokens registered in the network (excluding ETH, which is hardcoded as tokenId = 0)\\n    uint16 internal constant MAX_AMOUNT_OF_REGISTERED_TOKENS = 1023;\\n\\n    /// @dev Max account id that could be registered in the network\\n    uint32 internal constant MAX_ACCOUNT_ID = 16777215;\\n\\n    /// @dev Expected average period of block creation\\n    uint256 internal constant BLOCK_PERIOD = 15 seconds;\\n\\n    /// @dev ETH blocks verification expectation\\n    /// @dev Blocks can be reverted if they are not verified for at least EXPECT_VERIFICATION_IN.\\n    /// @dev If set to 0 validator can revert blocks at any time.\\n    uint256 internal constant EXPECT_VERIFICATION_IN = 0 hours / BLOCK_PERIOD;\\n\\n    uint256 internal constant NOOP_BYTES = 1 * CHUNK_BYTES;\\n    uint256 internal constant DEPOSIT_BYTES = 6 * CHUNK_BYTES;\\n    uint256 internal constant MINT_NFT_BYTES = 5 * CHUNK_BYTES;\\n    uint256 internal constant TRANSFER_TO_NEW_BYTES = 6 * CHUNK_BYTES;\\n    uint256 internal constant PARTIAL_EXIT_BYTES = 6 * CHUNK_BYTES;\\n    uint256 internal constant TRANSFER_BYTES = 2 * CHUNK_BYTES;\\n    uint256 internal constant FORCED_EXIT_BYTES = 6 * CHUNK_BYTES;\\n    uint256 internal constant WITHDRAW_NFT_BYTES = 10 * CHUNK_BYTES;\\n\\n    /// @dev Full exit operation length\\n    uint256 internal constant FULL_EXIT_BYTES = 11 * CHUNK_BYTES;\\n\\n    /// @dev ChangePubKey operation length\\n    uint256 internal constant CHANGE_PUBKEY_BYTES = 6 * CHUNK_BYTES;\\n\\n    /// @dev Expiration delta for priority request to be satisfied (in seconds)\\n    /// @dev NOTE: Priority expiration should be > (EXPECT_VERIFICATION_IN * BLOCK_PERIOD)\\n    /// @dev otherwise incorrect block with priority op could not be reverted.\\n    uint256 internal constant PRIORITY_EXPIRATION_PERIOD = 3 days;\\n\\n    /// @dev Expiration delta for priority request to be satisfied (in ETH blocks)\\n    uint256 internal constant PRIORITY_EXPIRATION =\\n        PRIORITY_EXPIRATION_PERIOD/BLOCK_PERIOD;\\n\\n    /// @dev Maximum number of priority request to clear during verifying the block\\n    /// @dev Cause deleting storage slots cost 5k gas per each slot it's unprofitable to clear too many slots\\n    /// @dev Value based on the assumption of ~750k gas cost of verifying and 5 used storage slots per PriorityOperation structure\\n    uint64 internal constant MAX_PRIORITY_REQUESTS_TO_DELETE_IN_VERIFY = 6;\\n\\n    /// @dev Reserved time for users to send full exit priority operation in case of an upgrade (in seconds)\\n    uint256 internal constant MASS_FULL_EXIT_PERIOD = 9 days;\\n\\n    /// @dev Reserved time for users to withdraw funds from full exit priority operation in case of an upgrade (in seconds)\\n    uint256 internal constant TIME_TO_WITHDRAW_FUNDS_FROM_FULL_EXIT = 2 days;\\n\\n    /// @dev Notice period before activation preparation status of upgrade mode (in seconds)\\n    /// @dev NOTE: we must reserve for users enough time to send full exit operation, wait maximum time for processing this operation and withdraw funds from it.\\n    uint256 internal constant UPGRADE_NOTICE_PERIOD =\\n        MASS_FULL_EXIT_PERIOD+PRIORITY_EXPIRATION_PERIOD+TIME_TO_WITHDRAW_FUNDS_FROM_FULL_EXIT;\\n\\n    /// @dev Timestamp - seconds since unix epoch\\n    uint256 internal constant COMMIT_TIMESTAMP_NOT_OLDER = 24 hours;\\n\\n    /// @dev Maximum available error between real commit block timestamp and analog used in the verifier (in seconds)\\n    /// @dev Must be used cause miner's `block.timestamp` value can differ on some small value (as we know - 15 seconds)\\n    uint256 internal constant COMMIT_TIMESTAMP_APPROXIMATION_DELTA = 15 minutes;\\n\\n    /// @dev Bit mask to apply for verifier public input before verifying.\\n    uint256 internal constant INPUT_MASK = 14474011154664524427946373126085988481658748083205070504932198000989141204991;\\n\\n    /// @dev Auth fact reset timelock.\\n    uint256 internal constant AUTH_FACT_RESET_TIMELOCK = 1 days;\\n\\n    /// @dev Max deposit of ERC20 token that is possible to deposit\\n    uint128 internal constant MAX_DEPOSIT_AMOUNT = 20282409603651670423947251286015;\\n\\n    uint32 internal constant SPECIAL_ACCOUNT_ID = 16777215;\\n    address internal constant SPECIAL_ACCOUNT_ADDRESS = address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF);\\n    uint32 internal constant SPECIAL_NFT_TOKEN_ID = 2147483646;\\n\\n    uint32 internal constant MAX_FUNGIBLE_TOKEN_ID = 65535;\\n\\n    uint256 internal constant SECURITY_COUNCIL_MEMBERS_NUMBER = 15;\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/Utils.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./Bytes.sol\\\";\\n\\nlibrary Utils {\\n    /// @notice Returns lesser of two values\\n    function minU32(uint32 a, uint32 b) internal pure returns (uint32) {\\n        return a < b ? a : b;\\n    }\\n\\n    /// @notice Returns lesser of two values\\n    function minU64(uint64 a, uint64 b) internal pure returns (uint64) {\\n        return a < b ? a : b;\\n    }\\n\\n    /// @notice Sends tokens\\n    /// @dev NOTE: this function handles tokens that have transfer function not strictly compatible with ERC20 standard\\n    /// @dev NOTE: call `transfer` to this token may return (bool) or nothing\\n    /// @param _token Token address\\n    /// @param _to Address of recipient\\n    /// @param _amount Amount of tokens to transfer\\n    /// @return bool flag indicating that transfer is successful\\n    function sendERC20(\\n        IERC20 _token,\\n        address _to,\\n        uint256 _amount\\n    ) internal returns (bool) {\\n        (bool callSuccess, bytes memory callReturnValueEncoded) =\\n            address(_token).call(abi.encodeWithSignature(\\\"transfer(address,uint256)\\\", _to, _amount));\\n        // `transfer` method may return (bool) or nothing.\\n        bool returnedSuccess = callReturnValueEncoded.length == 0 || abi.decode(callReturnValueEncoded, (bool));\\n        return callSuccess && returnedSuccess;\\n    }\\n\\n    /// @notice Transfers token from one address to another\\n    /// @dev NOTE: this function handles tokens that have transfer function not strictly compatible with ERC20 standard\\n    /// @dev NOTE: call `transferFrom` to this token may return (bool) or nothing\\n    /// @param _token Token address\\n    /// @param _from Address of sender\\n    /// @param _to Address of recipient\\n    /// @param _amount Amount of tokens to transfer\\n    /// @return bool flag indicating that transfer is successful\\n    function transferFromERC20(\\n        IERC20 _token,\\n        address _from,\\n        address _to,\\n        uint256 _amount\\n    ) internal returns (bool) {\\n        (bool callSuccess, bytes memory callReturnValueEncoded) =\\n            address(_token).call(abi.encodeWithSignature(\\\"transferFrom(address,address,uint256)\\\", _from, _to, _amount));\\n        // `transferFrom` method may return (bool) or nothing.\\n        bool returnedSuccess = callReturnValueEncoded.length == 0 || abi.decode(callReturnValueEncoded, (bool));\\n        return callSuccess && returnedSuccess;\\n    }\\n\\n    /// @notice Recovers signer's address from ethereum signature for given message\\n    /// @param _signature 65 bytes concatenated. R (32) + S (32) + V (1)\\n    /// @param _messageHash signed message hash.\\n    /// @return address of the signer\\n    function recoverAddressFromEthSignature(bytes memory _signature, bytes32 _messageHash)\\n        internal\\n        pure\\n        returns (address)\\n    {\\n        require(_signature.length == 65, \\\"P\\\"); // incorrect signature length\\n\\n        bytes32 signR;\\n        bytes32 signS;\\n        uint8 signV;\\n        assembly {\\n            signR := mload(add(_signature, 32))\\n            signS := mload(add(_signature, 64))\\n            signV := byte(0, mload(add(_signature, 96)))\\n        }\\n\\n        return ecrecover(_messageHash, signV, signR, signS);\\n    }\\n\\n    /// @notice Returns new_hash = hash(old_hash + bytes)\\n    function concatHash(bytes32 _hash, bytes memory _bytes) internal pure returns (bytes32) {\\n        bytes32 result;\\n        assembly {\\n            let bytesLen := add(mload(_bytes), 32)\\n            mstore(_bytes, _hash)\\n            result := keccak256(_bytes, bytesLen)\\n        }\\n        return result;\\n    }\\n\\n    function hashBytesToBytes20(bytes memory _bytes) internal pure returns (bytes20) {\\n        return bytes20(uint160(uint256(keccak256(_bytes))));\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/NFTFactory.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: UNLICENSED\\n\\n\\ninterface NFTFactory {\\n    function mintNFTFromZkSync(\\n        address creator,\\n        address recipient,\\n        uint32 creatorAccountId,\\n        uint32 serialId,\\n        bytes32 contentHash,\\n        // Even though the token id can fit into the uint32, we still use\\n        // the uint256 to preserve consistency with the ERC721 parent contract\\n        uint256 tokenId\\n    ) external;\\n\\n    event MintNFTFromZkSync(\\n        address indexed creator,\\n        address indexed recipient,\\n        uint32 creatorAccountId,\\n        uint32 serialId,\\n        bytes32 contentHash,\\n        uint256 tokenId\\n    );\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/TokenGovernance.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\nimport \\\"./Governance.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./Utils.sol\\\";\\n\\n/// @title Token Governance Contract\\n/// @author Matter Labs\\n/// @notice Contract is used to allow anyone to add new ERC20 tokens to zkSync given sufficient payment\\ncontract TokenGovernance {\\n    /// @notice Token lister added or removed (see `tokenLister`)\\n    event TokenListerUpdate(address indexed tokenLister, bool isActive);\\n\\n    /// @notice Listing fee token set\\n    event ListingFeeTokenUpdate(IERC20 indexed newListingFeeToken);\\n\\n    /// @notice Listing fee set\\n    event ListingFeeUpdate(uint256 newListingFee);\\n\\n    /// @notice Maximum number of listed tokens updated\\n    event ListingCapUpdate(uint16 newListingCap);\\n\\n    /// @notice The treasury (the account which will receive the fee) was updated\\n    event TreasuryUpdate(address newTreasury);\\n\\n    /// @notice zkSync governance contract\\n    Governance public governance;\\n\\n    /// @notice Token used to collect listing fee for addition of new token to zkSync network\\n    IERC20 public listingFeeToken;\\n\\n    /// @notice Token listing fee\\n    uint256 public listingFee;\\n\\n    /// @notice Max number of tokens that can be listed using this contract\\n    uint16 public listingCap;\\n\\n    /// @notice Addresses that can list tokens without fee\\n    mapping(address => bool) public tokenLister;\\n\\n    /// @notice Address that collects listing payments\\n    address public treasury;\\n\\n    constructor(\\n        Governance _governance,\\n        IERC20 _listingFeeToken,\\n        uint256 _listingFee,\\n        uint16 _listingCap,\\n        address _treasury\\n    ) {\\n        governance = _governance;\\n        listingFeeToken = _listingFeeToken;\\n        listingFee = _listingFee;\\n        listingCap = _listingCap;\\n        treasury = _treasury;\\n\\n        address governor = governance.networkGovernor();\\n        // We add zkSync governor as a first token lister.\\n        tokenLister[governor] = true;\\n        emit TokenListerUpdate(governor, true);\\n    }\\n\\n    /// @notice Adds new ERC20 token to zkSync network.\\n    /// @notice If caller is not present in the `tokenLister` map payment of `listingFee` in `listingFeeToken` should be made.\\n    /// @notice NOTE: before calling this function make sure to approve `listingFeeToken` transfer for this contract.\\n    function addToken(address _token) external {\\n        require(governance.totalTokens() < listingCap, \\\"can't add more tokens\\\"); // Impossible to add more tokens using this contract\\n        if (!tokenLister[msg.sender]) {\\n            // Collect fees\\n            bool feeTransferOk = Utils.transferFromERC20(listingFeeToken, msg.sender, treasury, listingFee);\\n            require(feeTransferOk, \\\"fee transfer failed\\\"); // Failed to receive payment for token addition.\\n        }\\n        governance.addToken(_token);\\n    }\\n\\n    /// Governance functions (this contract is governed by zkSync governor)\\n\\n    /// @notice Set new listing token and fee\\n    /// @notice Can be called only by zkSync governor\\n    function setListingFeeToken(IERC20 _newListingFeeToken, uint256 _newListingFee) external {\\n        governance.requireGovernor(msg.sender);\\n        listingFeeToken = _newListingFeeToken;\\n        listingFee = _newListingFee;\\n\\n        emit ListingFeeTokenUpdate(_newListingFeeToken);\\n    }\\n\\n    /// @notice Set new listing fee\\n    /// @notice Can be called only by zkSync governor\\n    function setListingFee(uint256 _newListingFee) external {\\n        governance.requireGovernor(msg.sender);\\n        listingFee = _newListingFee;\\n\\n        emit ListingFeeUpdate(_newListingFee);\\n    }\\n\\n    /// @notice Enable or disable token lister. If enabled new tokens can be added by that address without payment\\n    /// @notice Can be called only by zkSync governor\\n    function setLister(address _listerAddress, bool _active) external {\\n        governance.requireGovernor(msg.sender);\\n        if (tokenLister[_listerAddress] != _active) {\\n            tokenLister[_listerAddress] = _active;\\n            emit TokenListerUpdate(_listerAddress, _active);\\n        }\\n    }\\n\\n    /// @notice Change maximum amount of tokens that can be listed using this method\\n    /// @notice Can be called only by zkSync governor\\n    function setListingCap(uint16 _newListingCap) external {\\n        governance.requireGovernor(msg.sender);\\n        listingCap = _newListingCap;\\n\\n        emit ListingCapUpdate(_newListingCap);\\n    }\\n\\n    /// @notice Change address that collects payments for listing tokens.\\n    /// @notice Can be called only by zkSync governor\\n    function setTreasury(address _newTreasury) external {\\n        governance.requireGovernor(msg.sender);\\n        treasury = _newTreasury;\\n\\n        emit TreasuryUpdate(_newTreasury);\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: UNLICENSED\\n\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see {ERC20Detailed}.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/Bytes.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n// Functions named bytesToX, except bytesToBytes20, where X is some type of size N < 32 (size of one word)\\n// implements the following algorithm:\\n// f(bytes memory input, uint offset) -> X out\\n// where byte representation of out is N bytes from input at the given offset\\n// 1) We compute memory location of the word W such that last N bytes of W is input[offset..offset+N]\\n// W_address = input + 32 (skip stored length of bytes) + offset - (32 - N) == input + offset + N\\n// 2) We load W from memory into out, last N bytes of W are placed into out\\n\\nlibrary Bytes {\\n    function toBytesFromUInt16(uint16 self) internal pure returns (bytes memory _bts) {\\n        return toBytesFromUIntTruncated(uint256(self), 2);\\n    }\\n\\n    function toBytesFromUInt24(uint24 self) internal pure returns (bytes memory _bts) {\\n        return toBytesFromUIntTruncated(uint256(self), 3);\\n    }\\n\\n    function toBytesFromUInt32(uint32 self) internal pure returns (bytes memory _bts) {\\n        return toBytesFromUIntTruncated(uint256(self), 4);\\n    }\\n\\n    function toBytesFromUInt128(uint128 self) internal pure returns (bytes memory _bts) {\\n        return toBytesFromUIntTruncated(uint256(self), 16);\\n    }\\n\\n    // Copies 'len' lower bytes from 'self' into a new 'bytes memory'.\\n    // Returns the newly created 'bytes memory'. The returned bytes will be of length 'len'.\\n    function toBytesFromUIntTruncated(uint256 self, uint8 byteLength) private pure returns (bytes memory bts) {\\n        require(byteLength <= 32, \\\"Q\\\");\\n        bts = new bytes(byteLength);\\n        // Even though the bytes will allocate a full word, we don't want\\n        // any potential garbage bytes in there.\\n        uint256 data = self << ((32 - byteLength) * 8);\\n        assembly {\\n            mstore(\\n                add(bts, 32), // BYTES_HEADER_SIZE\\n                data\\n            )\\n        }\\n    }\\n\\n    // Copies 'self' into a new 'bytes memory'.\\n    // Returns the newly created 'bytes memory'. The returned bytes will be of length '20'.\\n    function toBytesFromAddress(address self) internal pure returns (bytes memory bts) {\\n        bts = toBytesFromUIntTruncated(uint256(self), 20);\\n    }\\n\\n    // See comment at the top of this file for explanation of how this function works.\\n    // NOTE: theoretically possible overflow of (_start + 20)\\n    function bytesToAddress(bytes memory self, uint256 _start) internal pure returns (address addr) {\\n        uint256 offset = _start + 20;\\n        require(self.length >= offset, \\\"R\\\");\\n        assembly {\\n            addr := mload(add(self, offset))\\n        }\\n    }\\n\\n    // Reasoning about why this function works is similar to that of other similar functions, except NOTE below.\\n    // NOTE: that bytes1..32 is stored in the beginning of the word unlike other primitive types\\n    // NOTE: theoretically possible overflow of (_start + 20)\\n    function bytesToBytes20(bytes memory self, uint256 _start) internal pure returns (bytes20 r) {\\n        require(self.length >= (_start + 20), \\\"S\\\");\\n        assembly {\\n            r := mload(add(add(self, 0x20), _start))\\n        }\\n    }\\n\\n    // See comment at the top of this file for explanation of how this function works.\\n    // NOTE: theoretically possible overflow of (_start + 0x2)\\n    function bytesToUInt16(bytes memory _bytes, uint256 _start) internal pure returns (uint16 r) {\\n        uint256 offset = _start + 0x2;\\n        require(_bytes.length >= offset, \\\"T\\\");\\n        assembly {\\n            r := mload(add(_bytes, offset))\\n        }\\n    }\\n\\n    // See comment at the top of this file for explanation of how this function works.\\n    // NOTE: theoretically possible overflow of (_start + 0x3)\\n    function bytesToUInt24(bytes memory _bytes, uint256 _start) internal pure returns (uint24 r) {\\n        uint256 offset = _start + 0x3;\\n        require(_bytes.length >= offset, \\\"U\\\");\\n        assembly {\\n            r := mload(add(_bytes, offset))\\n        }\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_start + 0x4)\\n    function bytesToUInt32(bytes memory _bytes, uint256 _start) internal pure returns (uint32 r) {\\n        uint256 offset = _start + 0x4;\\n        require(_bytes.length >= offset, \\\"V\\\");\\n        assembly {\\n            r := mload(add(_bytes, offset))\\n        }\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_start + 0x10)\\n    function bytesToUInt128(bytes memory _bytes, uint256 _start) internal pure returns (uint128 r) {\\n        uint256 offset = _start + 0x10;\\n        require(_bytes.length >= offset, \\\"W\\\");\\n        assembly {\\n            r := mload(add(_bytes, offset))\\n        }\\n    }\\n\\n    // See comment at the top of this file for explanation of how this function works.\\n    // NOTE: theoretically possible overflow of (_start + 0x14)\\n    function bytesToUInt160(bytes memory _bytes, uint256 _start) internal pure returns (uint160 r) {\\n        uint256 offset = _start + 0x14;\\n        require(_bytes.length >= offset, \\\"X\\\");\\n        assembly {\\n            r := mload(add(_bytes, offset))\\n        }\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_start + 0x20)\\n    function bytesToBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32 r) {\\n        uint256 offset = _start + 0x20;\\n        require(_bytes.length >= offset, \\\"Y\\\");\\n        assembly {\\n            r := mload(add(_bytes, offset))\\n        }\\n    }\\n\\n    // Original source code: https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol#L228\\n    // Get slice from bytes arrays\\n    // Returns the newly created 'bytes memory'\\n    // NOTE: theoretically possible overflow of (_start + _length)\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    ) internal pure returns (bytes memory) {\\n        require(_bytes.length >= (_start + _length), \\\"Z\\\"); // bytes length is less then start byte + length bytes\\n\\n        bytes memory tempBytes = new bytes(_length);\\n\\n        if (_length != 0) {\\n            assembly {\\n                let slice_curr := add(tempBytes, 0x20)\\n                let slice_end := add(slice_curr, _length)\\n\\n                for {\\n                    let array_current := add(_bytes, add(_start, 0x20))\\n                } lt(slice_curr, slice_end) {\\n                    slice_curr := add(slice_curr, 0x20)\\n                    array_current := add(array_current, 0x20)\\n                } {\\n                    mstore(slice_curr, mload(array_current))\\n                }\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    /// Reads byte stream\\n    /// @return newOffset - offset + amount of bytes read\\n    /// @return data - actually read data\\n    // NOTE: theoretically possible overflow of (_offset + _length)\\n    function read(\\n        bytes memory _data,\\n        uint256 _offset,\\n        uint256 _length\\n    ) internal pure returns (uint256 newOffset, bytes memory data) {\\n        data = slice(_data, _offset, _length);\\n        newOffset = _offset + _length;\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 1)\\n    function readBool(bytes memory _data, uint256 _offset) internal pure returns (uint256 newOffset, bool r) {\\n        newOffset = _offset + 1;\\n        r = uint8(_data[_offset]) != 0;\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 1)\\n    function readUint8(bytes memory _data, uint256 _offset) internal pure returns (uint256 newOffset, uint8 r) {\\n        newOffset = _offset + 1;\\n        r = uint8(_data[_offset]);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 2)\\n    function readUInt16(bytes memory _data, uint256 _offset) internal pure returns (uint256 newOffset, uint16 r) {\\n        newOffset = _offset + 2;\\n        r = bytesToUInt16(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 3)\\n    function readUInt24(bytes memory _data, uint256 _offset) internal pure returns (uint256 newOffset, uint24 r) {\\n        newOffset = _offset + 3;\\n        r = bytesToUInt24(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 4)\\n    function readUInt32(bytes memory _data, uint256 _offset) internal pure returns (uint256 newOffset, uint32 r) {\\n        newOffset = _offset + 4;\\n        r = bytesToUInt32(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 16)\\n    function readUInt128(bytes memory _data, uint256 _offset) internal pure returns (uint256 newOffset, uint128 r) {\\n        newOffset = _offset + 16;\\n        r = bytesToUInt128(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 20)\\n    function readUInt160(bytes memory _data, uint256 _offset) internal pure returns (uint256 newOffset, uint160 r) {\\n        newOffset = _offset + 20;\\n        r = bytesToUInt160(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 20)\\n    function readAddress(bytes memory _data, uint256 _offset) internal pure returns (uint256 newOffset, address r) {\\n        newOffset = _offset + 20;\\n        r = bytesToAddress(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 20)\\n    function readBytes20(bytes memory _data, uint256 _offset) internal pure returns (uint256 newOffset, bytes20 r) {\\n        newOffset = _offset + 20;\\n        r = bytesToBytes20(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 32)\\n    function readBytes32(bytes memory _data, uint256 _offset) internal pure returns (uint256 newOffset, bytes32 r) {\\n        newOffset = _offset + 32;\\n        r = bytesToBytes32(_data, _offset);\\n    }\\n\\n    /// Trim bytes into single word\\n    function trim(bytes memory _data, uint256 _newLength) internal pure returns (uint256 r) {\\n        require(_newLength <= 0x20, \\\"10\\\"); // new_length is longer than word\\n        require(_data.length >= _newLength, \\\"11\\\"); // data is to short\\n\\n        uint256 a;\\n        assembly {\\n            a := mload(add(_data, 0x20)) // load bytes into uint256\\n        }\\n\\n        return a >> ((0x20 - _newLength) * 8);\\n    }\\n\\n    // Helper function for hex conversion.\\n    function halfByteToHex(bytes1 _byte) internal pure returns (bytes1 _hexByte) {\\n        require(uint8(_byte) < 0x10, \\\"hbh11\\\"); // half byte's value is out of 0..15 range.\\n\\n        // \\\"FEDCBA9876543210\\\" ASCII-encoded, shifted and automatically truncated.\\n        return bytes1(uint8(0x66656463626139383736353433323130 >> (uint8(_byte) * 8)));\\n    }\\n\\n    // Convert bytes to ASCII hex representation\\n    function bytesToHexASCIIBytes(bytes memory _input) internal pure returns (bytes memory _output) {\\n        bytes memory outStringBytes = new bytes(_input.length * 2);\\n\\n        // code in `assembly` construction is equivalent of the next code:\\n        // for (uint i = 0; i < _input.length; ++i) {\\n        //     outStringBytes[i*2] = halfByteToHex(_input[i] >> 4);\\n        //     outStringBytes[i*2+1] = halfByteToHex(_input[i] & 0x0f);\\n        // }\\n        assembly {\\n            let input_curr := add(_input, 0x20)\\n            let input_end := add(input_curr, mload(_input))\\n\\n            for {\\n                let out_curr := add(outStringBytes, 0x20)\\n            } lt(input_curr, input_end) {\\n                input_curr := add(input_curr, 0x01)\\n                out_curr := add(out_curr, 0x02)\\n            } {\\n                let curr_input_byte := shr(0xf8, mload(input_curr))\\n                // here outStringByte from each half of input byte calculates by the next:\\n                //\\n                // \\\"FEDCBA9876543210\\\" ASCII-encoded, shifted and automatically truncated.\\n                // outStringByte = byte (uint8 (0x66656463626139383736353433323130 >> (uint8 (_byteHalf) * 8)))\\n                mstore(\\n                    out_curr,\\n                    shl(0xf8, shr(mul(shr(0x04, curr_input_byte), 0x08), 0x66656463626139383736353433323130))\\n                )\\n                mstore(\\n                    add(out_curr, 0x01),\\n                    shl(0xf8, shr(mul(and(0x0f, curr_input_byte), 0x08), 0x66656463626139383736353433323130))\\n                )\\n            }\\n        }\\n        return outStringBytes;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"creatorAccountId\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creatorAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"factoryAddress\",\"type\":\"address\"}],\"name\":\"NFTFactoryRegisteredCreator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newGovernor\",\"type\":\"address\"}],\"name\":\"NewGovernor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"}],\"name\":\"NewToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract TokenGovernance\",\"name\":\"newTokenGovernance\",\"type\":\"address\"}],\"name\":\"NewTokenGovernance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"}],\"name\":\"SetDefaultNFTFactory\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"}],\"name\":\"TokenPausedUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"validatorAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"name\":\"ValidatorStatusUpdate\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"addToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newGovernor\",\"type\":\"address\"}],\"name\":\"changeGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract TokenGovernance\",\"name\":\"_newTokenGovernance\",\"type\":\"address\"}],\"name\":\"changeTokenGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultFactory\",\"outputs\":[{\"internalType\":\"contract NFTFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_creatorAccountId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"_creatorAddress\",\"type\":\"address\"}],\"name\":\"getNFTFactory\",\"outputs\":[{\"internalType\":\"contract NFTFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"initializationParameters\",\"type\":\"bytes\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_tokenId\",\"type\":\"uint16\"}],\"name\":\"isValidTokenId\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"networkGovernor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nftFactories\",\"outputs\":[{\"internalType\":\"contract NFTFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"pausedTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_creatorAccountId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"_creatorAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"registerNFTFactoryCreator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"requireActiveValidator\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"requireGovernor\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"name\":\"setDefaultNFTFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_tokenPaused\",\"type\":\"bool\"}],\"name\":\"setTokenPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_validator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_active\",\"type\":\"bool\"}],\"name\":\"setValidator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"tokenAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenGovernance\",\"outputs\":[{\"internalType\":\"contract TokenGovernance\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenIds\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTokens\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"upgradeParameters\",\"type\":\"bytes\"}],\"name\":\"upgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"}],\"name\":\"validateTokenAddress\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"validators\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Governance","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}