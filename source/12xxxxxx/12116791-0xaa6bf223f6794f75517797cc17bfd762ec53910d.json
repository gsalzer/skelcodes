{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.6.2;\r\n\r\n\r\n/**\r\n * @title TokenVesting\r\n * @dev A token holder contract that can release its token balance gradually like a\r\n * typical vesting scheme, with a cliff and vesting period.\r\n */\r\ncontract CookDistribution  {\r\n\r\n\r\n    event AllocationRegistered(address indexed beneficiary, uint256 amount);\r\n    event TokensWithdrawal(address userAddress, uint256 amount);\r\n\r\n    struct Allocation {\r\n        uint256 amount;\r\n        uint256 released;\r\n        bool blackListed;\r\n        bool isRegistered;\r\n    }\r\n\r\n    // beneficiary of tokens after they are released\r\n    mapping(address => Allocation) private _beneficiaryAllocations;\r\n\r\n    // oracle price data (dayNumber => price)\r\n    mapping(uint256 => uint256) private _oraclePriceFeed;\r\n\r\n    // all beneficiary address1\r\n    address[] private _allBeneficiary;\r\n\r\n \r\n    function addAddressWithAllocation(address beneficiaryAddress, uint256 amount ) public  {\r\n\r\n        require(\r\n            _beneficiaryAllocations[beneficiaryAddress].isRegistered == false,\r\n            \"The address to be added already exisits in the distribution contact, please use a new one\"\r\n        );\r\n\r\n        _beneficiaryAllocations[beneficiaryAddress].isRegistered = true;\r\n        _beneficiaryAllocations[beneficiaryAddress] = Allocation( amount, 0, false, true\r\n        );\r\n\r\n        emit AllocationRegistered(beneficiaryAddress, amount);\r\n    }\r\n\r\n    \r\n    function addMultipleAddressWithAllocations(address[] memory beneficiaryAddresses, uint256[] memory amounts) public {\r\n\r\n        require(beneficiaryAddresses.length > 0 && amounts.length > 0 && beneficiaryAddresses.length == amounts.length,\r\n            \"The length of user addressed and amounts should be matched and cannot be empty\"\r\n        );\r\n\r\n        for (uint256 i = 0; i < beneficiaryAddresses.length; i++) {\r\n            require(_beneficiaryAllocations[beneficiaryAddresses[i]].isRegistered == false,\r\n                \"The address to be added already exisits in the distribution contact, please use a new one\"\r\n            );\r\n        }\r\n\r\n        for (uint256 i = 0; i < beneficiaryAddresses.length; i++) {\r\n            _beneficiaryAllocations[beneficiaryAddresses[i]].isRegistered = true;\r\n            _beneficiaryAllocations[beneficiaryAddresses[i]] = Allocation(amounts[i], 0, false, true);\r\n\r\n            emit AllocationRegistered(beneficiaryAddresses[i], amounts[i]);\r\n        }\r\n    }\r\n\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AllocationRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensWithdrawal\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiaryAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addAddressWithAllocation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"beneficiaryAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"addMultipleAddressWithAllocations\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CookDistribution","CompilerVersion":"v0.6.2+commit.bacdbe57","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://0c92e9eace292dd90f22117df85fdfbfab682209e6a00a1e72c5af9ad8d8122f"}]}