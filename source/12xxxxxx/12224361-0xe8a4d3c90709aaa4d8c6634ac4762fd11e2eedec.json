{"status":"1","message":"OK","result":[{"SourceCode":"{\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"},\"ERC1155Holder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\nimport \\\"./ERC1155Receiver.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ncontract ERC1155Holder is ERC1155Receiver {\\n    function onERC1155Received(address, address, uint256, uint256, bytes memory) public virtual override returns (bytes4) {\\n        return this.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) public virtual override returns (bytes4) {\\n        return this.onERC1155BatchReceived.selector;\\n    }\\n}\\n\"},\"ERC1155Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\nimport \\\"./IERC1155Receiver.sol\\\";\\nimport \\\"./ERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\\n    constructor() internal {\\n        _registerInterface(\\n            ERC1155Receiver(address(0)).onERC1155Received.selector ^\\n            ERC1155Receiver(address(0)).onERC1155BatchReceived.selector\\n        );\\n    }\\n}\\n\"},\"ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts may inherit from this and call {_registerInterface} to declare\\n * their support of an interface.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /*\\n     * bytes4(keccak256(\\u0027supportsInterface(bytes4)\\u0027)) == 0x01ffc9a7\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\\n\\n    /**\\n     * @dev Mapping of interface ids to whether or not it\\u0027s supported.\\n     */\\n    mapping(bytes4 =\\u003e bool) private _supportedInterfaces;\\n\\n    constructor () internal {\\n        // Derived contracts need only register support for their own interfaces,\\n        // we register support for ERC165 itself here\\n        _registerInterface(_INTERFACE_ID_ERC165);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     *\\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return _supportedInterfaces[interfaceId];\\n    }\\n\\n    /**\\n     * @dev Registers the contract as an implementer of the interface defined by\\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\\n     * registering its interface id is not required.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * Requirements:\\n     *\\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\\n     */\\n    function _registerInterface(bytes4 interfaceId) internal virtual {\\n        require(interfaceId != 0xffffffff, \\\"ERC165: invalid interface id\\\");\\n        _supportedInterfaces[interfaceId] = true;\\n    }\\n}\\n\"},\"ERC721Holder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\nimport \\\"./IERC721Receiver.sol\\\";\\n\\n  /**\\n   * @dev Implementation of the {IERC721Receiver} interface.\\n   *\\n   * Accepts all token transfers. \\n   * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\\n   */\\ncontract ERC721Holder is IERC721Receiver {\\n\\n    /**\\n     * @dev See {IERC721Receiver-onERC721Received}.\\n     *\\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n}\\n\"},\"IERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.4;\\n\\n\\ninterface IERC1155 {\\n\\n  /****************************************|\\n  |                 Events                 |\\n  |_______________________________________*/\\n\\n  /**\\n   * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\\n   *   Operator MUST be msg.sender\\n   *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\\n   *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\\n   *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the \\\"circulating supply\\\" for a given token ID\\n   *   To broadcast the existence of a token ID with no initial balance, the contract SHOULD emit the TransferSingle event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\\n   */\\n  event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _amount);\\n\\n  /**\\n   * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\\n   *   Operator MUST be msg.sender\\n   *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\\n   *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\\n   *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the \\\"circulating supply\\\" for a given token ID\\n   *   To broadcast the existence of multiple token IDs with no initial balance, this SHOULD emit the TransferBatch event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\\n   */\\n  event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _amounts);\\n\\n  /**\\n   * @dev MUST emit when an approval is updated\\n   */\\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\\n\\n\\n  /****************************************|\\n  |                Functions               |\\n  |_______________________________________*/\\n\\n  /**\\n    * @notice Transfers amount of an _id from the _from address to the _to address specified\\n    * @dev MUST emit TransferSingle event on success\\n    * Caller must be approved to manage the _from account\\u0027s tokens (see isApprovedForAll)\\n    * MUST throw if `_to` is the zero address\\n    * MUST throw if balance of sender for token `_id` is lower than the `_amount` sent\\n    * MUST throw on any other error\\n    * When transfer is complete, this function MUST check if `_to` is a smart contract (code size \\u003e 0). If so, it MUST call `onERC1155Received` on `_to` and revert if the return amount is not `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n    * @param _from    Source address\\n    * @param _to      Target address\\n    * @param _id      ID of the token type\\n    * @param _amount  Transfered amount\\n    * @param _data    Additional data with no specified format, sent in call to `_to`\\n    */\\n  function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes calldata _data) external;\\n\\n  /**\\n    * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\\n    * @dev MUST emit TransferBatch event on success\\n    * Caller must be approved to manage the _from account\\u0027s tokens (see isApprovedForAll)\\n    * MUST throw if `_to` is the zero address\\n    * MUST throw if length of `_ids` is not the same as length of `_amounts`\\n    * MUST throw if any of the balance of sender for token `_ids` is lower than the respective `_amounts` sent\\n    * MUST throw on any other error\\n    * When transfer is complete, this function MUST check if `_to` is a smart contract (code size \\u003e 0). If so, it MUST call `onERC1155BatchReceived` on `_to` and revert if the return amount is not `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n    * Transfers and events MUST occur in the array order they were submitted (_ids[0] before _ids[1], etc)\\n    * @param _from     Source addresses\\n    * @param _to       Target addresses\\n    * @param _ids      IDs of each token type\\n    * @param _amounts  Transfer amounts per token type\\n    * @param _data     Additional data with no specified format, sent in call to `_to`\\n  */\\n  function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external;\\n\\n  /**\\n   * @notice Get the balance of an account\\u0027s Tokens\\n   * @param _owner  The address of the token holder\\n   * @param _id     ID of the Token\\n   * @return        The _owner\\u0027s balance of the Token type requested\\n   */\\n  function balanceOf(address _owner, uint256 _id) external view returns (uint256);\\n\\n  /**\\n   * @notice Get the balance of multiple account/token pairs\\n   * @param _owners The addresses of the token holders\\n   * @param _ids    ID of the Tokens\\n   * @return        The _owner\\u0027s balance of the Token types requested (i.e. balance for each (owner, id) pair)\\n   */\\n  function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory);\\n\\n  /**\\n   * @notice Enable or disable approval for a third party (\\\"operator\\\") to manage all of caller\\u0027s tokens\\n   * @dev MUST emit the ApprovalForAll event on success\\n   * @param _operator  Address to add to the set of authorized operators\\n   * @param _approved  True if the operator is approved, false to revoke approval\\n   */\\n  function setApprovalForAll(address _operator, bool _approved) external;\\n\\n  /**\\n   * @notice Queries the approval status of an operator for a given owner\\n   * @param _owner     The owner of the Tokens\\n   * @param _operator  Address of authorized operator\\n   * @return isOperator True if the operator is approved, false if not\\n   */\\n  function isApprovedForAll(address _owner, address _operator) external view returns (bool isOperator);\\n}\\n\"},\"IERC1155Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n\\n    /**\\n        @dev Handles the receipt of a single ERC1155 token type. This function is\\n        called at the end of a `safeTransferFrom` after the balance has been updated.\\n        To accept the transfer, this must return\\n        `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n        (i.e. 0xf23a6e61, or its own function selector).\\n        @param operator The address which initiated the transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param id The ID of the token being transferred\\n        @param value The amount of tokens being transferred\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    )\\n        external\\n        returns(bytes4);\\n\\n    /**\\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\\n        is called at the end of a `safeBatchTransferFrom` after the balances have\\n        been updated. To accept the transfer(s), this must return\\n        `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n        (i.e. 0xbc197c81, or its own function selector).\\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    )\\n        external\\n        returns(bytes4);\\n}\\n\"},\"IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.2 \\u003c0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``\\u0027s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\\n      *\\n      * Requirements:\\n      *\\n      * - `from` cannot be the zero address.\\n      * - `to` cannot be the zero address.\\n      * - `tokenId` token must exist and be owned by `from`.\\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n      *\\n      * Emits a {Transfer} event.\\n      */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n}\\n\"},\"IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\\n}\\n\"},\"LendingData.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.7.4;\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./IERC721.sol\\\";\\r\\nimport \\\"./ERC721Holder.sol\\\";\\r\\nimport \\\"./IERC1155.sol\\\";\\r\\nimport \\\"./ERC1155Holder.sol\\\";\\r\\nimport \\\"./Ownable.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\ninterface Geyser{ function totalStakedFor(address addr) external view returns(uint256); }\\r\\n\\r\\n/**\\r\\n * @title Stater Lending Contract\\r\\n * @notice Contract that allows users to leverage their NFT assets\\r\\n * @author Stater\\r\\n */\\r\\ncontract LendingData is ERC721Holder, ERC1155Holder, Ownable {\\r\\n\\r\\n  // @notice OpenZeppelin\\u0027s SafeMath library\\r\\n  using SafeMath for uint256;\\r\\n  enum TimeScale{ MINUTES, HOURS, DAYS, WEEKS }\\r\\n\\r\\n  // The address of the Stater NFT collection\\r\\n  address public nftAddress; //0xcb13DC836C2331C669413352b836F1dA728ce21c\\r\\n\\r\\n  // The address of the Stater Geyser Contract \\r\\n  address[] public geyserAddressArray; //[0xf1007ACC8F0229fCcFA566522FC83172602ab7e3]\\r\\n\\r\\n  // The address of the Stater Promissory Note Contract\\r\\n  address public promissoryNoteContractAddress;\\r\\n  \\r\\n  uint256[] public staterNftTokenIdArray; //[0, 1]\\r\\n  \\r\\n  // 50=50%\\r\\n  uint32 public discountNft = 50;\\r\\n  \\r\\n  // 50=50%\\r\\n  uint32 public discountGeyser = 50;\\r\\n  \\r\\n  // 100 = 1%\\r\\n  uint32 public lenderFee = 100;\\r\\n  \\r\\n  // Incremental value used for loan ids\\r\\n  uint256 public loanID;\\r\\n\\r\\n  // Loan to value(ltv). 600=60%\\r\\n  uint256 public ltv = 600;\\r\\n  \\r\\n  uint256 public installmentFrequency = 1;\\r\\n  TimeScale public installmentTimeScale = TimeScale.WEEKS;\\r\\n  \\r\\n  // 20 =20%\\r\\n  uint256 public interestRate = 20;\\r\\n  \\r\\n  // 40=40% out of intersetRate\\r\\n  uint256 public interestRateToStater = 40;\\r\\n\\r\\n  event NewLoan(uint256 indexed loanId, address indexed owner, uint256 creationDate, address indexed currency, Status status, string creationId);\\r\\n  event LoanApproved(uint256 indexed loanId, address indexed lender, uint256 approvalDate, uint256 loanPaymentEnd, Status status);\\r\\n  event LoanCancelled(uint256 indexed loanId, uint256 cancellationDate, Status status);\\r\\n  event ItemsWithdrawn(uint256 indexed loanId, address indexed requester, Status status);\\r\\n  event LoanPayment(uint256 indexed loanId, uint256 paymentDate, uint256 installmentAmount, uint256 amountPaidAsInstallmentToLender, uint256 interestPerInstallement, uint256 interestToStaterPerInstallement, Status status);\\r\\n  \\r\\n  enum Status{\\r\\n      UNINITIALIZED, // will be removed in the future -- not used\\r\\n      LISTED, // after the loan have been created --\\u003e the next status will be APPROVED\\r\\n      APPROVED, // in this status the loan has a lender -- will be set after approveLoan()\\r\\n      DEFAULTED, // will be removed in the future -- not used\\r\\n      LIQUIDATED, // the loan will have this status after all installments have been paid\\r\\n      CANCELLED, // only if loan is LISTED \\r\\n      WITHDRAWN // the final status, the collateral returned to the borrower or to the lender\\r\\n  }\\r\\n  enum TokenType{ ERC721, ERC1155 }\\r\\n  struct Loan {\\r\\n    address[] nftAddressArray; // the adderess of the ERC721\\r\\n    address payable borrower; // the address who receives the loan\\r\\n    address payable lender; // the address who gives/offers the loan to the borrower\\r\\n    address currency; // the token that the borrower lends, address(0) for ETH\\r\\n    Status status; // the loan status\\r\\n    uint256[] nftTokenIdArray; // the unique identifier of the NFT token that the borrower uses as collateral\\r\\n    uint256 loanAmount; // the amount, denominated in tokens (see next struct entry), the borrower lends\\r\\n    uint256 assetsValue; // important for determintng LTV which has to be under 50-60%\\r\\n    uint256 loanStart; // the point when the loan is approved\\r\\n    uint256 loanEnd; // the point when the loan is approved to the point when it must be paid back to the lender\\r\\n    uint256 nrOfInstallments; // the number of installments that the borrower must pay.\\r\\n    uint256 installmentAmount; // amount expected for each installment\\r\\n    uint256 amountDue; // loanAmount + interest that needs to be paid back by borrower\\r\\n    uint256 paidAmount; // the amount that has been paid back to the lender to date\\r\\n    uint256 defaultingLimit; // the number of installments allowed to be missed without getting defaulted\\r\\n    uint256 nrOfPayments; // the number of installments paid\\r\\n    TokenType[] nftTokenTypeArray; // the token types : ERC721 , ERC1155 , ...\\r\\n  }\\r\\n\\r\\n  // @notice Mapping for all the loans\\r\\n  mapping(uint256 =\\u003e Loan) public loans;\\r\\n\\r\\n  // @notice Mapping for all the loans that are approved by the owner in order to be used in the promissory note\\r\\n  mapping(uint256 =\\u003e address) public promissoryPermissions;\\r\\n\\r\\n  /**\\r\\n   * @notice Construct a new lending contract\\r\\n   * @param _nftAddress The address of the Stater nft collection\\r\\n   * @param _promissoryNoteContractAddress The address of the Stater Promissory Note contract\\r\\n   * @param _geyserAddressArray The address of the Stater geyser contract\\r\\n   * @param _staterNftTokenIdArray Array of the stater nft token IDs\\r\\n   */\\r\\n  constructor(address _nftAddress, address _promissoryNoteContractAddress, address[] memory _geyserAddressArray, uint256[] memory _staterNftTokenIdArray) {\\r\\n    nftAddress = _nftAddress;\\r\\n    geyserAddressArray = _geyserAddressArray;\\r\\n    staterNftTokenIdArray = _staterNftTokenIdArray;\\r\\n    promissoryNoteContractAddress = _promissoryNoteContractAddress;\\r\\n  }\\r\\n\\r\\n  // Borrower creates a loan\\r\\n  /**\\r\\n   * @notice The borrower creates the loan using the NFT as collateral\\r\\n   * @param loanAmount The amount of the loan\\r\\n   * @param nrOfInstallments Loan\\u0027s number of installments\\r\\n   * @param currency ETH or custom ERC20\\r\\n   * @param assetsValue The value of the assets\\r\\n   * @param nftAddressArray Array of nft addresses in the loan bundle.\\r\\n   * @param nftTokenIdArray Array of nft token IDs in the loan bundle.\\r\\n   * @param creationId ID used to identify loan creation event in the stater database.\\r\\n   * @param nftTokenTypeArray The token types : ERC721 , ERC115\\r\\n   */\\r\\n  function createLoan(\\r\\n    uint256 loanAmount,\\r\\n    uint256 nrOfInstallments,\\r\\n    address currency,\\r\\n    uint256 assetsValue, \\r\\n    address[] calldata nftAddressArray, \\r\\n    uint256[] calldata nftTokenIdArray,\\r\\n    string calldata creationId,\\r\\n    TokenType[] memory nftTokenTypeArray\\r\\n  ) external {\\r\\n    require(nrOfInstallments \\u003e 0, \\\"Loan must have at least 1 installment\\\");\\r\\n    require(loanAmount \\u003e 0, \\\"Loan amount must be higher than 0\\\");\\r\\n    require(nftAddressArray.length \\u003e 0, \\\"Loan must have atleast 1 NFT\\\");\\r\\n    require(nftAddressArray.length == nftTokenIdArray.length \\u0026\\u0026 nftTokenIdArray.length == nftTokenTypeArray.length, \\\"NFT provided informations are missing or incomplete\\\");\\r\\n\\r\\n    // Compute loan to value ratio for current loan application\\r\\n    require(_percent(loanAmount, assetsValue) \\u003c= ltv, \\\"LTV exceeds maximum limit allowed\\\");\\r\\n\\r\\n    // Computing the defaulting limit\\r\\n    if ( nrOfInstallments \\u003c= 3 )\\r\\n        loans[loanID].defaultingLimit = 1;\\r\\n    else if ( nrOfInstallments \\u003c= 5 )\\r\\n        loans[loanID].defaultingLimit = 2;\\r\\n    else if ( nrOfInstallments \\u003e= 6 )\\r\\n        loans[loanID].defaultingLimit = 3;\\r\\n\\r\\n    // Set loan fields\\r\\n    loans[loanID].nftTokenIdArray = nftTokenIdArray;\\r\\n    loans[loanID].loanAmount = loanAmount;\\r\\n    loans[loanID].assetsValue = assetsValue;\\r\\n    loans[loanID].amountDue = loanAmount.mul(interestRate.add(100)).div(100); // interest rate \\u003e\\u003e 20%\\r\\n    loans[loanID].nrOfInstallments = nrOfInstallments;\\r\\n    loans[loanID].installmentAmount = loans[loanID].amountDue.mod(nrOfInstallments) \\u003e 0 ? loans[loanID].amountDue.div(nrOfInstallments).add(1) : loans[loanID].amountDue.div(nrOfInstallments);\\r\\n    loans[loanID].status = Status.LISTED;\\r\\n    loans[loanID].nftAddressArray = nftAddressArray;\\r\\n    loans[loanID].borrower = msg.sender;\\r\\n    loans[loanID].currency = currency;\\r\\n    loans[loanID].nftTokenTypeArray = nftTokenTypeArray;\\r\\n \\r\\n    // Transfer the items from lender to stater contract\\r\\n    _transferItems(\\r\\n        msg.sender, \\r\\n        address(this), \\r\\n        nftAddressArray, \\r\\n        nftTokenIdArray,\\r\\n        nftTokenTypeArray\\r\\n    );\\r\\n\\r\\n    // Fire event\\r\\n    emit NewLoan(loanID, msg.sender, block.timestamp, currency, Status.LISTED, creationId);\\r\\n    ++loanID;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice The lender will approve the loan\\r\\n   * @param loanId The id of the loan \\r\\n   */\\r\\n  function approveLoan(uint256 loanId) external payable {\\r\\n    require(loans[loanId].lender == address(0), \\\"Someone else payed for this loan before you\\\");\\r\\n    require(loans[loanId].paidAmount == 0, \\\"This loan is currently not ready for lenders\\\");\\r\\n    require(loans[loanId].status == Status.LISTED, \\\"This loan is not currently ready for lenders, check later\\\");\\r\\n    \\r\\n    uint256 discount = calculateDiscount(msg.sender);\\r\\n    \\r\\n    // We check if currency is ETH\\r\\n    if ( loans[loanId].currency == address(0) )\\r\\n      require(msg.value \\u003e= loans[loanId].loanAmount.add(loans[loanId].loanAmount.div(lenderFee).div(discount)),\\\"Not enough currency\\\");\\r\\n\\r\\n    // Borrower assigned , status is 1 , first installment ( payment ) completed\\r\\n    loans[loanId].lender = msg.sender;\\r\\n    loans[loanId].loanEnd = block.timestamp.add(loans[loanId].nrOfInstallments.mul(generateInstallmentFrequency()));\\r\\n    loans[loanId].status = Status.APPROVED;\\r\\n    loans[loanId].loanStart = block.timestamp;\\r\\n\\r\\n    // We send the tokens here\\r\\n    _transferTokens(msg.sender,loans[loanId].borrower,loans[loanId].currency,loans[loanId].loanAmount,loans[loanId].loanAmount.div(lenderFee).div(discount));\\r\\n\\r\\n    emit LoanApproved(\\r\\n      loanId,\\r\\n      msg.sender,\\r\\n      block.timestamp,\\r\\n      loans[loanId].loanEnd,\\r\\n      Status.APPROVED\\r\\n    );\\r\\n  }\\r\\n\\r\\n  // Borrower cancels a loan\\r\\n  function cancelLoan(uint256 loanId) external {\\r\\n    require(loans[loanId].lender == address(0), \\\"The loan has a lender , it cannot be cancelled\\\");\\r\\n    require(loans[loanId].borrower == msg.sender, \\\"You\\u0027re not the borrower of this loan\\\");\\r\\n    require(loans[loanId].status != Status.CANCELLED, \\\"This loan is already cancelled\\\");\\r\\n    require(loans[loanId].status == Status.LISTED, \\\"This loan is no longer cancellable\\\");\\r\\n    \\r\\n    // We set its validity date as block.timestamp\\r\\n    loans[loanId].loanEnd = block.timestamp;\\r\\n    loans[loanId].status = Status.CANCELLED;\\r\\n\\r\\n    // We send the items back to him\\r\\n    _transferItems(\\r\\n      address(this), \\r\\n      loans[loanId].borrower, \\r\\n      loans[loanId].nftAddressArray, \\r\\n      loans[loanId].nftTokenIdArray,\\r\\n      loans[loanId].nftTokenTypeArray\\r\\n    );\\r\\n\\r\\n    emit LoanCancelled(\\r\\n      loanId,\\r\\n      block.timestamp,\\r\\n      Status.CANCELLED\\r\\n    );\\r\\n  }\\r\\n  \\r\\n  /**\\r\\n   * @notice Borrower pays installments for the loan\\r\\n   * @param loanId The id of the loan\\r\\n   */\\r\\n  function payLoan(uint256 loanId) external payable {\\r\\n    require(loans[loanId].borrower == msg.sender, \\\"You\\u0027re not the borrower of this loan\\\");\\r\\n    require(loans[loanId].status == Status.APPROVED, \\\"This loan is no longer in the approval phase, check its status\\\");\\r\\n    require(loans[loanId].loanEnd \\u003e= block.timestamp, \\\"Loan validity expired\\\");\\r\\n    require((msg.value \\u003e 0 \\u0026\\u0026 loans[loanId].currency == address(0) ) || ( loans[loanId].currency != address(0) \\u0026\\u0026 msg.value == 0), \\\"Insert the correct tokens\\\");\\r\\n    \\r\\n    uint256 paidByBorrower = msg.value \\u003e 0 ? msg.value : loans[loanId].installmentAmount;\\r\\n    uint256 amountPaidAsInstallmentToLender = paidByBorrower; // \\u003e\\u003e amount of installment that goes to lender\\r\\n    uint256 interestPerInstallement = paidByBorrower.mul(interestRate).div(100); // entire interest for installment\\r\\n    uint256 discount = calculateDiscount(msg.sender);\\r\\n    uint256 interestToStaterPerInstallement = interestPerInstallement.mul(interestRateToStater).div(100);\\r\\n\\r\\n    if ( discount != 1 ){\\r\\n        if ( loans[loanId].currency == address(0) ){\\r\\n            require(msg.sender.send(interestToStaterPerInstallement.div(discount)), \\\"Discount returnation failed\\\");\\r\\n            amountPaidAsInstallmentToLender = amountPaidAsInstallmentToLender.sub(interestToStaterPerInstallement.div(discount));\\r\\n        }\\r\\n        interestToStaterPerInstallement = interestToStaterPerInstallement.sub(interestToStaterPerInstallement.div(discount));\\r\\n    }\\r\\n    amountPaidAsInstallmentToLender = amountPaidAsInstallmentToLender.sub(interestToStaterPerInstallement);\\r\\n\\r\\n    loans[loanId].paidAmount = loans[loanId].paidAmount.add(paidByBorrower);\\r\\n    loans[loanId].nrOfPayments = loans[loanId].nrOfPayments.add(paidByBorrower.div(loans[loanId].installmentAmount));\\r\\n\\r\\n    if (loans[loanId].paidAmount \\u003e= loans[loanId].amountDue)\\r\\n      loans[loanId].status = Status.LIQUIDATED;\\r\\n\\r\\n    // We transfer the tokens to borrower here\\r\\n    _transferTokens(msg.sender,loans[loanId].lender,loans[loanId].currency,amountPaidAsInstallmentToLender,interestToStaterPerInstallement);\\r\\n\\r\\n    emit LoanPayment(\\r\\n      loanId,\\r\\n      block.timestamp,\\r\\n      msg.value,\\r\\n      amountPaidAsInstallmentToLender,\\r\\n      interestPerInstallement,\\r\\n      interestToStaterPerInstallement,\\r\\n      loans[loanId].status\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice Borrwoer can withdraw loan items if loan is LIQUIDATED\\r\\n   * @notice Lender can withdraw loan items if loan is DEFAULTED\\r\\n   * @param loanId The id of the loan\\r\\n   */\\r\\n  function terminateLoan(uint256 loanId) external {\\r\\n    require(msg.sender == loans[loanId].borrower || msg.sender == loans[loanId].lender, \\\"You can\\u0027t access this loan\\\");\\r\\n    require((block.timestamp \\u003e= loans[loanId].loanEnd || loans[loanId].paidAmount \\u003e= loans[loanId].amountDue) || lackOfPayment(loanId), \\\"Not possible to finish this loan yet\\\");\\r\\n    require(loans[loanId].status == Status.LIQUIDATED || loans[loanId].status == Status.APPROVED, \\\"Incorrect state of loan\\\");\\r\\n    require(loans[loanId].status != Status.WITHDRAWN, \\\"Loan NFTs already withdrawn\\\");\\r\\n\\r\\n    if ( lackOfPayment(loanId) ) {\\r\\n      loans[loanId].status = Status.WITHDRAWN;\\r\\n      loans[loanId].loanEnd = block.timestamp;\\r\\n      // We send the items back to lender\\r\\n      _transferItems(\\r\\n        address(this),\\r\\n        loans[loanId].lender,\\r\\n        loans[loanId].nftAddressArray,\\r\\n        loans[loanId].nftTokenIdArray,\\r\\n        loans[loanId].nftTokenTypeArray\\r\\n      );\\r\\n    } else {\\r\\n      if ( block.timestamp \\u003e= loans[loanId].loanEnd \\u0026\\u0026 loans[loanId].paidAmount \\u003c loans[loanId].amountDue ) {\\r\\n        loans[loanId].status = Status.WITHDRAWN;\\r\\n        // We send the items back to lender\\r\\n        _transferItems(\\r\\n          address(this),\\r\\n          loans[loanId].lender,\\r\\n          loans[loanId].nftAddressArray,\\r\\n          loans[loanId].nftTokenIdArray,\\r\\n          loans[loanId].nftTokenTypeArray\\r\\n        );\\r\\n      } else if ( loans[loanId].paidAmount \\u003e= loans[loanId].amountDue ){\\r\\n        loans[loanId].status = Status.WITHDRAWN;\\r\\n        // We send the items back to borrower\\r\\n        _transferItems(\\r\\n          address(this),\\r\\n          loans[loanId].borrower,\\r\\n          loans[loanId].nftAddressArray,\\r\\n          loans[loanId].nftTokenIdArray,\\r\\n          loans[loanId].nftTokenTypeArray\\r\\n        );\\r\\n      }\\r\\n    }\\r\\n    \\r\\n    emit ItemsWithdrawn(\\r\\n      loanId,\\r\\n      msg.sender,\\r\\n      loans[loanId].status\\r\\n    );\\r\\n  }\\r\\n  \\r\\n  /**\\r\\n   * @notice Used by the Promissory Note contract to change the ownership of the loan when the Promissory Note NFT is sold \\r\\n   * @param loanIds The ids of the loans that will be transferred to the new owner\\r\\n   * @param newOwner The address of the new owner\\r\\n   */\\r\\n  function promissoryExchange(uint256[] calldata loanIds, address payable newOwner) external {\\r\\n      require(msg.sender == promissoryNoteContractAddress, \\\"You\\u0027re not whitelisted to access this method\\\");\\r\\n      for (uint256 i = 0; i \\u003c loanIds.length; ++i) {\\r\\n        require(loans[loanIds[i]].lender != address(0), \\\"One of the loans is not approved yet\\\");\\r\\n        require(promissoryPermissions[loanIds[i]] == msg.sender, \\\"You\\u0027re not allowed to perform this operation on loan\\\");\\r\\n        loans[loanIds[i]].lender = newOwner;\\r\\n      }\\r\\n  }\\r\\n  \\r\\n  /**\\r\\n   * @notice Used by the Promissory Note contract to approve a list of loans to be used as a Promissory Note NFT\\r\\n   * @param loanIds The ids of the loans that will be approved\\r\\n   */\\r\\n  function setPromissoryPermissions(uint256[] calldata loanIds) external {\\r\\n      for (uint256 i = 0; i \\u003c loanIds.length; ++i) {\\r\\n          require(loans[loanIds[i]].lender == msg.sender, \\\"You\\u0027re not the lender of this loan\\\");\\r\\n          promissoryPermissions[loanIds[i]] = promissoryNoteContractAddress;\\r\\n      }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice Liquidity mining participants or Stater NFT holders will be able to get some discount\\r\\n   * @param requester The address of the requester\\r\\n   */\\r\\n  function calculateDiscount(address requester) public view returns(uint256){\\r\\n    for (uint i = 0; i \\u003c staterNftTokenIdArray.length; ++i)\\r\\n\\t    if ( IERC1155(nftAddress).balanceOf(requester,staterNftTokenIdArray[i]) \\u003e 0 )\\r\\n\\t\\t    return uint256(100).div(discountNft);\\r\\n\\t  for (uint256 i = 0; i \\u003c geyserAddressArray.length; ++i)\\r\\n\\t    if ( Geyser(geyserAddressArray[i]).totalStakedFor(requester) \\u003e 0 )\\r\\n\\t\\t    return uint256(100).div(discountGeyser);\\r\\n\\t  return 1;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice This function returns total price (+ fees)\\r\\n   * @param loanId The id of the loan\\r\\n   */\\r\\n  function getLoanApprovalCost(uint256 loanId) external view returns(uint256) {\\r\\n    return loans[loanId].loanAmount.add(loans[loanId].loanAmount.div(lenderFee).div(calculateDiscount(msg.sender)));\\r\\n  }\\r\\n  \\r\\n  \\r\\n  /**\\r\\n   * @notice\\r\\n   * @param loanId The id of the loan\\r\\n   */\\r\\n  function getLoanRemainToPay(uint256 loanId) external view returns(uint256) {\\r\\n    return loans[loanId].amountDue.sub(loans[loanId].paidAmount);\\r\\n  }\\r\\n  \\r\\n  \\r\\n  /**\\r\\n   * @notice\\r\\n   * @param loanId The id of the loan\\r\\n   * @param nrOfInstallments The id of the loan\\r\\n   */\\r\\n  function getLoanInstallmentCost(\\r\\n      uint256 loanId,\\r\\n      uint256 nrOfInstallments\\r\\n  ) external view returns(\\r\\n      uint256 overallInstallmentAmount,\\r\\n      uint256 interestPerInstallement,\\r\\n      uint256 interestDiscounted,\\r\\n      uint256 interestToStaterPerInstallement,\\r\\n      uint256 amountPaidAsInstallmentToLender\\r\\n  ) {\\r\\n    require(nrOfInstallments \\u003c= loans[loanId].nrOfInstallments, \\\"Number of installments too high\\\");\\r\\n    uint256 discount = calculateDiscount(msg.sender);\\r\\n    interestDiscounted = 0;\\r\\n    \\r\\n    overallInstallmentAmount = uint256(loans[loanId].installmentAmount.mul(nrOfInstallments));\\r\\n    interestPerInstallement = uint256(overallInstallmentAmount.mul(interestRate).div(100).div(loans[loanId].nrOfInstallments));\\r\\n    interestDiscounted = interestPerInstallement.mul(interestRateToStater).div(100).div(discount); // amount of interest saved per installment\\r\\n    interestToStaterPerInstallement = interestPerInstallement.mul(interestRateToStater).div(100).sub(interestDiscounted);\\r\\n    amountPaidAsInstallmentToLender = interestPerInstallement.mul(uint256(100).sub(interestRateToStater)).div(100); \\r\\n  }\\r\\n  \\r\\n  /**\\r\\n   * @notice This function checks for unpaid installments\\r\\n   * @param loanId The id of the loan\\r\\n   */\\r\\n  function lackOfPayment(uint256 loanId) public view returns(bool) {\\r\\n    return loans[loanId].status == Status.APPROVED \\u0026\\u0026 loans[loanId].loanStart.add(loans[loanId].nrOfPayments.mul(generateInstallmentFrequency())) \\u003c= block.timestamp.sub(loans[loanId].defaultingLimit.mul(generateInstallmentFrequency()));\\r\\n  }\\r\\n\\r\\n  function generateInstallmentFrequency() public view returns(uint256){\\r\\n    if (installmentTimeScale == TimeScale.MINUTES) {\\r\\n      return 1 minutes;  \\r\\n    } else if (installmentTimeScale == TimeScale.HOURS) {\\r\\n      return 1 hours;\\r\\n    } else if (installmentTimeScale == TimeScale.DAYS) {\\r\\n      return 1 days;\\r\\n    }\\r\\n    return 1 weeks;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice Setter function for the discounts\\r\\n   * @param _discountNft Discount value for the Stater NFT holders\\r\\n   * @param _discountGeyser Discount value for the Stater liquidity mining participants\\r\\n   * @param _geyserAddressArray List of the Stater Geyser contracts \\r\\n   * @param _staterNftTokenIdArray Array of stater nft token IDs.\\r\\n   * @param _nftAddress List of the Stater NFT collections\\r\\n   */\\r\\n  function setDiscounts(uint32 _discountNft, uint32 _discountGeyser, address[] calldata _geyserAddressArray, uint256[] calldata _staterNftTokenIdArray, address _nftAddress) external onlyOwner {\\r\\n    discountNft = _discountNft;\\r\\n    discountGeyser = _discountGeyser;\\r\\n    geyserAddressArray = _geyserAddressArray;\\r\\n    staterNftTokenIdArray = _staterNftTokenIdArray;\\r\\n    nftAddress = _nftAddress;\\r\\n  }\\r\\n  \\r\\n  /**\\r\\n   * @notice Setter function\\r\\n   * @param _promissoryNoteContractAddress The address of the Stater promissory Note contract\\r\\n   * @param _ltv Value of Loan to value \\r\\n   * @param _installmentFrequency Value of installment frequency\\r\\n   * @param _installmentTimeScale The timescale of all loans.\\r\\n   * @param _interestRate Value of interest rate\\r\\n   * @param _interestRateToStater Value of interest rate to stater\\r\\n   * @param _lenderFee Value of the lender fee\\r\\n   */\\r\\n  function setGlobalVariables(address _promissoryNoteContractAddress, uint256 _ltv, uint256 _installmentFrequency, TimeScale _installmentTimeScale, uint256 _interestRate, uint256 _interestRateToStater, uint32 _lenderFee) external onlyOwner {\\r\\n    ltv = _ltv;\\r\\n    installmentFrequency = _installmentFrequency;\\r\\n    installmentTimeScale = _installmentTimeScale;\\r\\n    interestRate = _interestRate;\\r\\n    interestRateToStater = _interestRateToStater;\\r\\n    lenderFee = _lenderFee;\\r\\n    promissoryNoteContractAddress = _promissoryNoteContractAddress;\\r\\n  }\\r\\n  \\r\\n  /**\\r\\n   * @notice Adds a new geyser address to the list\\r\\n   * @param geyserAddress The new geyser address\\r\\n   */\\r\\n  function addGeyserAddress(address geyserAddress) external onlyOwner {\\r\\n      geyserAddressArray.push(geyserAddress);\\r\\n  }\\r\\n  \\r\\n  /**\\r\\n   * @notice Adds a new nft to the list\\r\\n   * @param nftId The id of the new nft\\r\\n   */\\r\\n  function addNftTokenId(uint256 nftId) external onlyOwner {\\r\\n      staterNftTokenIdArray.push(nftId);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice Calculates loan to value ration\\r\\n   * @param numerator Numerator.\\r\\n   * @param denominator Denominator.\\r\\n   */\\r\\n  function _percent(uint256 numerator, uint256 denominator) internal pure returns(uint256) {\\r\\n    return numerator.mul(10000).div(denominator).add(5).div(10);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice Transfer items fron an account to another\\r\\n   * @param from From account address.\\r\\n   * @param to To account address.\\r\\n   * @param nftAddressArray Array of addresses of the nfts to be transfered.\\r\\n   * @param nftTokenIdArray Array of token IDs of the nfts to be transfered. \\r\\n   * @param nftTokenTypeArray Array of token type of the nfts to be transfered.\\r\\n   */\\r\\n  function _transferItems(\\r\\n    address from, \\r\\n    address to, \\r\\n    address[] memory nftAddressArray, \\r\\n    uint256[] memory nftTokenIdArray,\\r\\n    TokenType[] memory nftTokenTypeArray\\r\\n  ) internal {\\r\\n    uint256 length = nftAddressArray.length;\\r\\n    require(length == nftTokenIdArray.length \\u0026\\u0026 nftTokenTypeArray.length == length, \\\"Token infos provided are invalid\\\");\\r\\n    for(uint256 i = 0; i \\u003c length; ++i) \\r\\n        if ( nftTokenTypeArray[i] == TokenType.ERC721 )\\r\\n            IERC721(nftAddressArray[i]).safeTransferFrom(\\r\\n                from,\\r\\n                to,\\r\\n                nftTokenIdArray[i]\\r\\n            );\\r\\n        else\\r\\n            IERC1155(nftAddressArray[i]).safeTransferFrom(\\r\\n                from,\\r\\n                to,\\r\\n                nftTokenIdArray[i],\\r\\n                1,\\r\\n                \\u00270x00\\u0027\\r\\n            );\\r\\n  }\\r\\n  \\r\\n  /**\\r\\n   * @notice Transfer eth or erc20 tokens fron an account to another\\r\\n   * @param from From account address.\\r\\n   * @param to To account address.\\r\\n   * @param currency Address of erc20 token to be transfered, 0x00 for eth.\\r\\n   * @param qty1 Amount of tokens to be transfered to relevant party account.\\r\\n   * @param qty2 Amount of tokens to be transfered to this contract\\u0027s author.\\r\\n   */\\r\\n  function _transferTokens(\\r\\n      address from,\\r\\n      address payable to,\\r\\n      address currency,\\r\\n      uint256 qty1,\\r\\n      uint256 qty2\\r\\n  ) internal {\\r\\n      if ( currency != address(0) ){\\r\\n          require(IERC20(currency).transferFrom(\\r\\n              from,\\r\\n              to, \\r\\n              qty1\\r\\n          ), \\\"Transfer of tokens to receiver failed\\\");\\r\\n          require(IERC20(currency).transferFrom(\\r\\n              from,\\r\\n              owner(), \\r\\n              qty2\\r\\n          ), \\\"Transfer of tokens to Stater failed\\\");\\r\\n      }else{\\r\\n          require(to.send(qty1), \\\"Transfer of ETH to receiver failed\\\");\\r\\n          require(payable(owner()).send(qty2), \\\"Transfer of ETH to Stater failed\\\");\\r\\n      }\\r\\n  }\\r\\n\\r\\n}\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\nimport \\\"./Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c \\u003c a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b \\u003e a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003c= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003e 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003e 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nftAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_promissoryNoteContractAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_geyserAddressArray\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_staterNftTokenIdArray\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum LendingData.Status\",\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"ItemsWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"approvalDate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanPaymentEnd\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum LendingData.Status\",\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"LoanApproved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cancellationDate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum LendingData.Status\",\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"LoanCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"paymentDate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"installmentAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountPaidAsInstallmentToLender\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"interestPerInstallement\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"interestToStaterPerInstallement\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum LendingData.Status\",\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"LoanPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"creationDate\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum LendingData.Status\",\"name\":\"status\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"creationId\",\"type\":\"string\"}],\"name\":\"NewLoan\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"geyserAddress\",\"type\":\"address\"}],\"name\":\"addGeyserAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"}],\"name\":\"addNftTokenId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"}],\"name\":\"approveLoan\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"}],\"name\":\"calculateDiscount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"}],\"name\":\"cancelLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loanAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nrOfInstallments\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"assetsValue\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"nftAddressArray\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"nftTokenIdArray\",\"type\":\"uint256[]\"},{\"internalType\":\"string\",\"name\":\"creationId\",\"type\":\"string\"},{\"internalType\":\"enum LendingData.TokenType[]\",\"name\":\"nftTokenTypeArray\",\"type\":\"uint8[]\"}],\"name\":\"createLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"discountGeyser\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"discountNft\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"generateInstallmentFrequency\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"}],\"name\":\"getLoanApprovalCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nrOfInstallments\",\"type\":\"uint256\"}],\"name\":\"getLoanInstallmentCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"overallInstallmentAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestPerInstallement\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestDiscounted\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestToStaterPerInstallement\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountPaidAsInstallmentToLender\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"}],\"name\":\"getLoanRemainToPay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"geyserAddressArray\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"installmentFrequency\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"installmentTimeScale\",\"outputs\":[{\"internalType\":\"enum LendingData.TimeScale\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interestRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interestRateToStater\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"}],\"name\":\"lackOfPayment\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lenderFee\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"loanID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"loans\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"enum LendingData.Status\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"loanAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetsValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nrOfInstallments\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"installmentAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountDue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"paidAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"defaultingLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nrOfPayments\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ltv\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"}],\"name\":\"payLoan\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"loanIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address payable\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"promissoryExchange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"promissoryNoteContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"promissoryPermissions\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_discountNft\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_discountGeyser\",\"type\":\"uint32\"},{\"internalType\":\"address[]\",\"name\":\"_geyserAddressArray\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_staterNftTokenIdArray\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_nftAddress\",\"type\":\"address\"}],\"name\":\"setDiscounts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_promissoryNoteContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_ltv\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_installmentFrequency\",\"type\":\"uint256\"},{\"internalType\":\"enum LendingData.TimeScale\",\"name\":\"_installmentTimeScale\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_interestRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_interestRateToStater\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_lenderFee\",\"type\":\"uint32\"}],\"name\":\"setGlobalVariables\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"loanIds\",\"type\":\"uint256[]\"}],\"name\":\"setPromissoryPermissions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"staterNftTokenIdArray\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"}],\"name\":\"terminateLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LendingData","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000004100670ee2f8aef6c47a4ed13c7f246e621228ec0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000010000000000000000000000001a08a4be4c59d808ee730d57a369b1c09ed6235200000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000005","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://8e63dd1b1fb4543a5fbd98ec64ab1e00c439e62160a5507e89bb5e9b9c55776c"}]}