{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMathUpgradeable {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@solv/solv-vnft-core/contracts/interface/IVNFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\ninterface IVNFT /* is IERC721 */{\\n    event PartialTransfer(address indexed from, address indexed to, uint256 indexed tokenId, uint256 targetTokenId,\\n        uint256 transferUnits);\\n    event Split(address indexed owner, uint256 indexed tokenId, uint256 newTokenId, uint256 splitUnits);\\n    event Merge(address indexed owner, uint256 indexed tokenId, uint256 indexed targetTokenId, uint256 mergeUnits);\\n    event ApprovalUnits(address indexed owner, address indexed approved, uint256 indexed tokenId, uint256 approvalUnits);\\n\\n    //function decimals() external view returns (uint8);\\n    function slotOf(uint256 tokenId)  external view returns(uint256 slot);\\n\\n    function balanceOfSlot(uint256 slot) external view returns (uint256 balance);\\n    function tokenOfSlotByIndex(uint256 slot, uint256 index) external view returns (uint256 tokenId);\\n    function unitsInToken(uint256 tokenId) external view returns (uint256 units);\\n\\n    function approve(address to, uint256 tokenId, uint256 units) external;\\n    function allowance(uint256 tokenId, address spender) external view returns (uint256 allowed);\\n\\n    function split(uint256 tokenId, uint256[] calldata units) external returns (uint256[] memory newTokenIds);\\n    function merge(uint256[] calldata tokenIds, uint256 targetTokenId) external;\\n\\n    function transferFrom(address from, address to, uint256 tokenId,\\n        uint256 units) external returns (uint256 newTokenId);\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId,\\n        uint256 units, bytes calldata data) external returns (uint256 newTokenId);\\n\\n    function transferFrom(address from, address to, uint256 tokenId, uint256 targetTokenId,\\n        uint256 units) external;\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId, uint256 targetTokenId,\\n        uint256 units, bytes calldata data) external;\\n}\\n\\ninterface IVNFTReceiver {\\n    function onVNFTReceived(address operator, address from, uint256 tokenId,\\n        uint256 units, bytes calldata data) external returns (bytes4);\\n}\"\r\n    },\r\n    \"contracts/VestingPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./interface/IVestingPool.sol\\\";\\nimport \\\"./interface/IVNFTErc20Container.sol\\\";\\nimport \\\"./library/VestingLibrary.sol\\\";\\nimport \\\"./library/EthAddressLib.sol\\\";\\nimport \\\"./library/ERC20TransferHelper.sol\\\";\\n\\ncontract VestingPool is IVestingPool {\\n    using SafeMathUpgradeable for uint256;\\n    using SafeMathUpgradeable for uint64;\\n    using VestingLibrary for VestingLibrary.Vesting;\\n    event NewManager(address oldManager, address newManager);\\n\\n    address internal _underlying;\\n    bool internal _initialized;\\n\\n    address public admin;\\n    address public pendingAdmin;\\n    address public manager;\\n    uint256 internal _totalAmount;\\n\\n    //tokenId => Vault\\n    mapping(uint256 => VestingLibrary.Vesting) public vestingById;\\n\\n    modifier onlyAdmin() {\\n        require(msg.sender == admin, \\\"only admin\\\");\\n        _;\\n    }\\n\\n    modifier onlyManager() {\\n        require(msg.sender == manager, \\\"only manager\\\");\\n        _;\\n    }\\n\\n    function initialize(address underlying_) public {\\n        require(_initialized == false, \\\"already initialized\\\");\\n        admin = msg.sender;\\n\\n        if (underlying_ != EthAddressLib.ethAddress()) {\\n            IERC20(underlying_).totalSupply();\\n        }\\n\\n        _underlying = underlying_;\\n        _initialized = true;\\n    }\\n\\n    function isVestingPool() external pure override returns (bool) {\\n        return true;\\n    }\\n\\n    function _setManager(address newManager_) public onlyAdmin {\\n        address oldManager = manager;\\n        manager = newManager_;\\n        emit NewManager(oldManager, newManager_);\\n    }\\n\\n    function mint(\\n        uint8 claimType_,\\n        address minter_,\\n        uint256 tokenId_,\\n        uint64 term_,\\n        uint256 amount_,\\n        uint64[] calldata maturities_,\\n        uint32[] calldata percentages_,\\n        string memory originalInvestor_\\n    ) external virtual override onlyManager returns (uint256) {\\n        return _mint(claimType_, minter_, tokenId_, term_, amount_, maturities_, percentages_, originalInvestor_);\\n    }\\n\\n    struct MintLocalVar {\\n        uint64 term;\\n        uint256 sumPercentages;\\n        uint256 mintPrincipal;\\n        uint256 mintUnits;\\n    }\\n    function _mint(\\n        uint8 claimType_,\\n        address minter_,\\n        uint256 tokenId_,\\n        uint64 term_,\\n        uint256 amount_,\\n        uint64[] memory maturities_,\\n        uint32[] memory percentages_,\\n        string memory originalInvestor_\\n    ) internal virtual returns (uint256) {\\n        MintLocalVar memory vars;\\n        require(maturities_.length > 0 && maturities_.length == percentages_.length, \\\"maturities or percentages error\\\");\\n\\n        if (claimType_ == VestingLibrary.CLAIM_TYPE_MULTI) {\\n            vars.term = _sub(maturities_[maturities_.length - 1], maturities_[0]);\\n            require(vars.term == term_, \\\"term error\\\");\\n        }\\n\\n        for (uint256 i = 0; i < percentages_.length; i++) {\\n            vars.sumPercentages = vars.sumPercentages.add(percentages_[i]);\\n        }\\n        require(vars.sumPercentages == VestingLibrary.FULL_PERCENTAGE, \\\"percentages error\\\");\\n\\n        ERC20TransferHelper.doTransferIn(_underlying, minter_, amount_);\\n        VestingLibrary.Vesting storage vesting = vestingById[tokenId_];\\n        (, vars.mintPrincipal) = vesting.mint(claimType_, term_, amount_, maturities_, percentages_, originalInvestor_);\\n\\n        vars.mintUnits = amount2units(vars.mintPrincipal);\\n\\n        emit MintVesting(\\n            claimType_,\\n            minter_,\\n            tokenId_,\\n            term_,\\n            maturities_,\\n            percentages_,\\n            amount_,\\n            amount_\\n        );\\n\\n        _totalAmount = _totalAmount.add(amount_);\\n\\n        return vars.mintUnits;\\n    }\\n\\n    function claim(address payable payee, uint256 tokenId, uint256 amount)\\n        external\\n        virtual\\n        override\\n        onlyManager\\n        returns (uint256)\\n    {\\n        return _claim(payee, tokenId, amount);\\n    }\\n\\n    function claimableAmount(uint256 tokenId_)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256)\\n    {\\n        VestingLibrary.Vesting memory vesting = vestingById[tokenId_];\\n\\n        if (vesting.claimType == VestingLibrary.CLAIM_TYPE_LINEAR \\n            || vesting.claimType == VestingLibrary.CLAIM_TYPE_SINGLE) {\\n            if (block.timestamp >= vesting.maturities[0]) {\\n                // 到期或过期\\n                return vesting.principal;\\n            } \\n            uint256 timeRemained = vesting.maturities[0] - block.timestamp;\\n            // 尚未开始解锁\\n            if (timeRemained >= vesting.term) {\\n                return 0;\\n            }\\n\\n            uint256 lockedAmount = vesting.vestingAmount.mul(timeRemained).div(vesting.term);\\n            return vesting.principal.sub(lockedAmount, \\\"claimable amount error\\\");\\n\\n        } else if (vesting.claimType == VestingLibrary.CLAIM_TYPE_MULTI) {  \\n            //尚未开始解锁\\n            if (block.timestamp < vesting.maturities[0]) {\\n                return 0;\\n            }\\n\\n            uint256 lockedPercentage;\\n            for (uint256 i = vesting.maturities.length - 1; i >= 0; i--) {\\n                if (vesting.maturities[i] <= block.timestamp) {\\n                    break;\\n                }\\n                lockedPercentage = lockedPercentage.add(vesting.percentages[i]);\\n            }\\n\\n            uint256 lockedAmount = \\n                    vesting.vestingAmount.mul(lockedPercentage)\\n                    .div(VestingLibrary.FULL_PERCENTAGE, \\\"locked amount error\\\");\\n            return vesting.principal.sub(lockedAmount, \\\"claimable amount error\\\");\\n        } else {\\n            revert(\\\"not support claimType\\\");\\n        }\\n    }\\n\\n    function _claim(\\n        address payable payee_,\\n        uint256 tokenId_,\\n        uint256 claimAmount_\\n    ) internal virtual returns (uint256) {\\n        require(claimAmount_ > 0, \\\"only more than 0\\\");\\n        require(\\n            claimAmount_ <= claimableAmount(tokenId_),\\n            \\\"withdraw amount exceeds limit\\\"\\n        );\\n\\n        VestingLibrary.Vesting storage v = vestingById[tokenId_];\\n\\n        require(\\n            claimAmount_ <= v.principal,\\n            \\\"withdraw amount too much\\\"\\n        );\\n\\n        v.claim(claimAmount_);\\n\\n        ERC20TransferHelper.doTransferOut(_underlying, payee_, claimAmount_);\\n\\n        _totalAmount = _totalAmount.sub(claimAmount_);\\n\\n        emit ClaimVesting(\\n            payee_,\\n            tokenId_,\\n            claimAmount_\\n        );\\n        return amount2units(claimAmount_);\\n    }\\n\\n    function transferVesting( address from_, uint256 tokenId_,\\n        address to_,\\n        uint256 targetTokenId_,\\n        uint256 transferUnits_) public override virtual onlyManager {\\n        uint256 transferAmount = units2amount(transferUnits_);\\n        (uint256 transferVestingAmount, uint256 transferPrincipal) =\\n            vestingById[tokenId_].transfer(vestingById[targetTokenId_], transferAmount);\\n        emit TransferVesting(\\n            from_,\\n            tokenId_,\\n            to_,\\n            targetTokenId_,\\n            transferVestingAmount,\\n            transferPrincipal\\n        );\\n    }\\n\\n    function splitVesting(address owner_, uint256 tokenId_, uint256 newTokenId_,\\n        uint256 splitUnits_) public  virtual override onlyManager {\\n        uint256 splitAmount = units2amount(splitUnits_);\\n        (uint256 splitVestingAmount, uint256 splitPrincipal) = vestingById[tokenId_].split(vestingById[newTokenId_], splitAmount);\\n        emit SplitVesting(owner_, tokenId_, newTokenId_, splitVestingAmount, splitPrincipal);\\n    }\\n\\n    function mergeVesting(address owner_, uint256 tokenId_,\\n        uint256 targetTokenId_) public  virtual override onlyManager {\\n        (uint256 mergeVestingAmount, uint256 mergePrincipal) = vestingById[tokenId_].merge(vestingById[targetTokenId_]);\\n        delete vestingById[tokenId_];\\n        emit MergeVesting(owner_, tokenId_, targetTokenId_, mergeVestingAmount, mergePrincipal);\\n    }\\n\\n    function units2amount(uint256 units_)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256)\\n    {\\n        return units_ * 1;\\n    }\\n\\n    function amount2units(uint256 amount_)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256)\\n    {\\n        return amount_ / 1;\\n    }\\n\\n    function totalAmount() public view override returns(uint256) {\\n        return _totalAmount;\\n    }\\n\\n    struct VestingSnapShot {\\n        uint256 vestingAmount_;\\n        uint256 principal_;\\n        uint64[] maturities_;\\n        uint32[] percentages_;\\n        uint64 term_;\\n        uint8 claimType_;\\n        uint256 claimableAmount;\\n        bool isValid_;\\n        string originalInvestor_;\\n    }\\n\\n    function getVestingSnapshot(uint256 tokenId_)\\n    public\\n    view\\n    override\\n    returns (\\n        uint8,\\n        uint64,\\n        uint256,\\n        uint256,\\n        uint64[] memory,\\n        uint32[] memory,\\n        uint256,\\n        string memory,\\n        bool\\n    )\\n    {\\n        VestingSnapShot memory vars;\\n        vars.vestingAmount_ = vestingById[tokenId_].vestingAmount;\\n        vars.principal_ = vestingById[tokenId_].principal;\\n        vars.maturities_ = vestingById[tokenId_].maturities;\\n        vars.percentages_ = vestingById[tokenId_].percentages;\\n        vars.term_ = vestingById[tokenId_].term;\\n        vars.claimType_ = vestingById[tokenId_].claimType;\\n        vars.claimableAmount = claimableAmount(tokenId_);\\n        vars.isValid_ = vestingById[tokenId_].isValid;\\n        vars.originalInvestor_ = vestingById[tokenId_].originalInvestor;\\n        return (\\n            vars.claimType_,\\n            vars.term_,\\n            vars.vestingAmount_,\\n            vars.principal_,\\n            vars.maturities_,\\n            vars.percentages_,\\n            vars.claimableAmount,\\n            vars.originalInvestor_,\\n            vars.isValid_\\n        );\\n    }\\n\\n    function underlying() public view override returns (address) {\\n        return _underlying;\\n    }\\n\\n    function _setPendingAdmin(address newPendingAdmin) public {\\n        require(msg.sender == admin, \\\"only admin\\\");\\n\\n        // Save current value, if any, for inclusion in log\\n        address oldPendingAdmin = pendingAdmin;\\n\\n        // Store pendingAdmin with value newPendingAdmin\\n        pendingAdmin = newPendingAdmin;\\n\\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\\n    }\\n\\n    function _acceptAdmin() public {\\n        require(\\n            msg.sender == pendingAdmin && msg.sender != address(0),\\n            \\\"only pending admin\\\"\\n        );\\n\\n        // Save current values for inclusion in log\\n        address oldAdmin = admin;\\n        address oldPendingAdmin = pendingAdmin;\\n\\n        // Store admin with value pendingAdmin\\n        admin = pendingAdmin;\\n\\n        // Clear the pending value\\n        pendingAdmin = address(0);\\n\\n        emit NewAdmin(oldAdmin, admin);\\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\\n    }\\n\\n    function _add(uint64 a, uint64 b) internal pure returns (uint64) {\\n        uint64 c = a + b;\\n        require(c >= a, \\\"addition overflow\\\");\\n        return c;\\n    }\\n\\n    function _sub(uint64 a, uint64 b) internal pure returns (uint64) {\\n        require(b <= a, \\\"subtraction overflow\\\");\\n        return a - b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IUnderlyingContainer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\ninterface IUnderlyingContainer {\\n    function totalUnderlyingAmount() external view returns (uint256);\\n    function underlying() external view returns (address);\\n}\"\r\n    },\r\n    \"contracts/interface/IVNFTErc20Container.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"@solv/solv-vnft-core/contracts/interface/IVNFT.sol\\\";\\nimport \\\"./IUnderlyingContainer.sol\\\";\\n\\ninterface IVNFTErc20Container is IVNFT, IUnderlyingContainer {\\n    function getUnderlyingAmount(uint256 units) external view returns (uint256 underlyingAmount);\\n    function getUnits(uint256 underlyingAmount) external view returns (uint256 units);\\n}\"\r\n    },\r\n    \"contracts/interface/IVestingPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\ninterface IVestingPool {\\n   event NewAdmin(address oldAdmin, address newAdmin);\\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\\n    event MintVesting(\\n        uint8 indexed claimType,\\n        address indexed minter,\\n        uint256 indexed tokenId,\\n        uint64 term,\\n        uint64[] maturities,\\n        uint32[] percentages,\\n        uint256 vestingAmount,\\n        uint256 principal\\n    );\\n    event ClaimVesting(\\n        address indexed payee,\\n        uint256 indexed tokenId,\\n        uint256 claimAmount\\n    );\\n    event TransferVesting(\\n        address from,\\n        uint256 tokenId,\\n        address to,\\n        uint256 targetTokenId,\\n        uint256 transferVestingAmount,\\n        uint256 transferPrincipal\\n    );\\n    event SplitVesting(\\n        address owner,\\n        uint256 tokenId,\\n        uint256 newTokenId,\\n        uint256 splitVestingAmount,\\n        uint256 splitPricipal\\n    );\\n    event MergeVesting(\\n        address owner,\\n        uint256 tokenId,\\n        uint256 targetTokenId,\\n        uint256 mergeVestingAmount,\\n        uint256 mergePrincipal\\n    );\\n\\n    function isVestingPool() external pure returns (bool);\\n\\n    function mint(\\n        uint8 claimType_,\\n        address minter_,\\n        uint256 tokenId_,\\n        uint64 term_,\\n        uint256 amount_,\\n        uint64[] calldata maturities_,\\n        uint32[] calldata percentages_,\\n        string memory originalInvestor_\\n    ) external returns (uint256 mintUnits);\\n\\n    function claim(address payable payee, uint256 tokenId,\\n        uint256 amount) external returns(uint256 claimUnit);\\n\\n    function claimableAmount(uint256 tokenId_)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function transferVesting(\\n        address from_,\\n        uint256 tokenId_,\\n        address to_,\\n        uint256 targetTokenId_,\\n        uint256 transferUnits_\\n    ) external;\\n\\n    function splitVesting(address owner_, uint256 tokenId_, uint256 newTokenId_,\\n        uint256 splitUnits_) external;\\n\\n    function mergeVesting(address owner_, uint256 tokenId_,\\n        uint256 targetTokenId_) external;\\n\\n    function units2amount(uint256 units_) external view returns (uint256);\\n    function amount2units(uint256 units_) external view returns (uint256);\\n    function totalAmount() external view returns(uint256);\\n\\n    function getVestingSnapshot(uint256 tokenId_)\\n    external\\n    view\\n    returns (\\n        uint8 claimType_,\\n        uint64 term_,\\n        uint256 vestingAmount_,\\n        uint256 principal_,\\n        uint64[] memory maturities_,\\n        uint32[] memory percentages_,\\n        uint256 availableWithdrawAmount_,\\n        string memory originalInvestor_,\\n        bool isValid_\\n    );\\n\\n    function underlying() external view returns (address) ;\\n}\\n\"\r\n    },\r\n    \"contracts/library/ERC20TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./EthAddressLib.sol\\\";\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary ERC20TransferHelper {\\n    function doTransferIn(address underlying, address from, uint amount) internal returns (uint) {\\n        if (underlying == EthAddressLib.ethAddress()) {\\n            // Sanity checks\\n            require(tx.origin == from, \\\"sender mismatch\\\");\\n            require(msg.value == amount, \\\"value mismatch\\\");\\n\\n            return amount;\\n        } else {\\n            require(msg.value == 0, \\\"don't support msg.value\\\");\\n            IERC20 token = IERC20(underlying);\\n            uint balanceBefore = IERC20(underlying).balanceOf(address(this));\\n            token.transferFrom(from, address(this), amount);\\n\\n            bool success;\\n            assembly {\\n                switch returndatasize()\\n                case 0 {                       // This is a non-standard ERC-20\\n                    success := not(0)          // set success to true\\n                }\\n                case 32 {                      // This is a compliant ERC-20\\n                    returndatacopy(0, 0, 32)\\n                    success := mload(0)        // Set `success = returndata` of external call\\n                }\\n                default {                      // This is an excessively non-compliant ERC-20, revert.\\n                    revert(0, 0)\\n                }\\n            }\\n            require(success, \\\"TOKEN_TRANSFER_IN_FAILED\\\");\\n\\n            // Calculate the amount that was *actually* transferred\\n            uint balanceAfter = IERC20(underlying).balanceOf(address(this));\\n            require(balanceAfter >= balanceBefore, \\\"TOKEN_TRANSFER_IN_OVERFLOW\\\");\\n            return balanceAfter - balanceBefore;   // underflow already checked above, just subtract\\n        }\\n    }\\n    function doTransferOut(address underlying, address payable to, uint amount) internal {\\n        if (underlying == EthAddressLib.ethAddress()) {\\n            to.transfer(amount);\\n        } else {\\n            IERC20 token = IERC20(underlying);\\n            token.transfer(to, amount);\\n\\n            bool success;\\n            assembly {\\n                switch returndatasize()\\n                case 0 {                      // This is a non-standard ERC-20\\n                    success := not(0)          // set success to true\\n                }\\n                case 32 {                     // This is a complaint ERC-20\\n                    returndatacopy(0, 0, 32)\\n                    success := mload(0)        // Set `success = returndata` of external call\\n                }\\n                default {                     // This is an excessively non-compliant ERC-20, revert.\\n                    revert(0, 0)\\n                }\\n            }\\n            require(success, \\\"TOKEN_TRANSFER_OUT_FAILED\\\");\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/library/EthAddressLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\nlibrary EthAddressLib {\\n\\n    /**\\n    * @dev returns the address used within the protocol to identify ETH\\n    * @return the address assigned to ETH\\n     */\\n    function ethAddress() internal pure returns(address) {\\n        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    }\\n}\"\r\n    },\r\n    \"contracts/library/VestingLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nlibrary VestingLibrary {\\n    using SafeMath for uint256;\\n\\n    uint32 constant internal FULL_PERCENTAGE = 10000;  // 释放比例基数，精确到小数点后两位\\n    uint8 constant internal CLAIM_TYPE_LINEAR = 0;\\n    uint8 constant internal CLAIM_TYPE_SINGLE = 1;\\n    uint8 constant internal CLAIM_TYPE_MULTI = 2;\\n\\n    struct Vesting {\\n        uint8 claimType; //0: 线性释放, 1: 单点释放, 2: 多点释放\\n        uint64 term; // 0 : Non-fixed term , 1 - N : fixed term in seconds\\n        uint64[] maturities; //到期时间（秒）\\n        uint32[] percentages;  //到期释放比例\\n        bool isValid; //是否有效\\n        uint256 vestingAmount;\\n        uint256 principal;\\n        string originalInvestor;\\n    }\\n\\n     function mint(\\n        Vesting storage self,\\n        uint8 claimType,\\n        uint64 term,\\n        uint256 amount,\\n        uint64[] memory maturities,\\n        uint32[] memory percentages,\\n        string memory originalInvestor\\n    ) internal returns (uint256, uint256) {\\n        require(! self.isValid, \\\"vesting exists\\\");\\n        self.term = term;\\n        self.maturities = maturities;\\n        self.percentages = percentages;\\n        self.claimType = claimType;\\n        self.vestingAmount = amount;\\n        self.principal = amount;\\n        self.originalInvestor = originalInvestor;\\n        self.isValid = true;\\n        return (self.vestingAmount, self.principal);\\n    }\\n\\n\\n    function claim(Vesting storage self, uint256 amount) internal {\\n        require(self.isValid, \\\"Vesting: token invalid\\\");\\n        self.principal = self.principal.sub(amount, \\\"claim amount exceeds balance\\\");\\n    }\\n\\n    function merge(Vesting storage self, Vesting storage target) internal returns (uint256 mergeVestingAmount, uint256 mergePrincipal) {\\n        require(self.isValid && target.isValid, \\\"Vesting: token invalid\\\");\\n        mergeVestingAmount = self.vestingAmount;\\n        mergePrincipal = self.principal;\\n        require(mergePrincipal <= mergeVestingAmount, \\\"Vesting: merge amount error\\\");\\n        self.vestingAmount = 0;\\n        self.principal = 0;\\n        target.vestingAmount = target.vestingAmount.add(mergeVestingAmount);\\n        target.principal = target.principal.add(mergePrincipal);\\n        self.isValid = false;\\n        return (mergeVestingAmount, mergePrincipal);\\n    }\\n\\n    function split(Vesting storage source, Vesting storage create, uint256 amount) internal returns (uint256 splitVestingAmount, uint256 splitPrincipal){\\n        require(source.isValid, \\\"Vesting: token invalid\\\");\\n        require(source.principal <= source.vestingAmount, \\\"balance exception\\\");\\n        splitVestingAmount = source.vestingAmount.mul(amount).div(source.principal);\\n        source.vestingAmount = source.vestingAmount.sub(splitVestingAmount, \\\"split vesting amount exceeds balance\\\");\\n        source.principal = source.principal.sub(amount, \\\"split principal exceeds balance\\\");\\n        mint(create, source.claimType, source.term, 0, source.maturities, source.percentages, source.originalInvestor);\\n        create.vestingAmount = splitVestingAmount;\\n        create.principal = amount;\\n        return (splitVestingAmount, amount);\\n    }\\n\\n    function transfer(Vesting storage source, Vesting storage target, uint256 amount ) internal returns (uint256 transferVestingAmount, uint256 transferPrincipal){\\n        require(source.isValid, \\\"Vesting: token invalid\\\");\\n        transferPrincipal = amount;\\n        transferVestingAmount = source.vestingAmount.mul(transferPrincipal).div(source.principal);\\n        source.principal = source.principal.sub(transferPrincipal, \\\"transfer principal exceeds balance\\\");\\n        source.vestingAmount = source.vestingAmount.sub(transferVestingAmount, \\\"transfer amount exceeds balance\\\");\\n        if (! target.isValid) {\\n            mint(target, source.claimType, source.term, 0, source.maturities, source.percentages, \\\"\\\");\\n        }\\n        target.vestingAmount = target.vestingAmount.add(transferVestingAmount);\\n        target.principal = target.principal.add(transferPrincipal);\\n        return (transferVestingAmount, transferPrincipal);\\n    }\\n}\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"payee\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimAmount\",\"type\":\"uint256\"}],\"name\":\"ClaimVesting\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"targetTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mergeVestingAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mergePrincipal\",\"type\":\"uint256\"}],\"name\":\"MergeVesting\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"claimType\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"term\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64[]\",\"name\":\"maturities\",\"type\":\"uint64[]\"},{\"indexed\":false,\"internalType\":\"uint32[]\",\"name\":\"percentages\",\"type\":\"uint32[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vestingAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"}],\"name\":\"MintVesting\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"NewAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldManager\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"NewManager\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldPendingAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newPendingAdmin\",\"type\":\"address\"}],\"name\":\"NewPendingAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"splitVestingAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"splitPricipal\",\"type\":\"uint256\"}],\"name\":\"SplitVesting\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"targetTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"transferVestingAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"transferPrincipal\",\"type\":\"uint256\"}],\"name\":\"TransferVesting\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_acceptAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newManager_\",\"type\":\"address\"}],\"name\":\"_setManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPendingAdmin\",\"type\":\"address\"}],\"name\":\"_setPendingAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"amount2units\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"payee\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"claimableAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"getVestingSnapshot\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint64[]\",\"name\":\"\",\"type\":\"uint64[]\"},{\"internalType\":\"uint32[]\",\"name\":\"\",\"type\":\"uint32[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying_\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isVestingPool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetTokenId_\",\"type\":\"uint256\"}],\"name\":\"mergeVesting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"claimType_\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"minter_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"term_\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"},{\"internalType\":\"uint64[]\",\"name\":\"maturities_\",\"type\":\"uint64[]\"},{\"internalType\":\"uint32[]\",\"name\":\"percentages_\",\"type\":\"uint32[]\"},{\"internalType\":\"string\",\"name\":\"originalInvestor_\",\"type\":\"string\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newTokenId_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"splitUnits_\",\"type\":\"uint256\"}],\"name\":\"splitVesting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"targetTokenId_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"transferUnits_\",\"type\":\"uint256\"}],\"name\":\"transferVesting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlying\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"units_\",\"type\":\"uint256\"}],\"name\":\"units2amount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"vestingById\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"claimType\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"term\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"vestingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"originalInvestor\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"VestingPool","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"1","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}