{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ALCXRewarder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\nimport \\\"./interfaces/sushi/IRewarder.sol\\\";\\nimport \\\"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\\\";\\nimport \\\"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\\\";\\nimport \\\"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\\\";\\nimport \\\"./MasterChefV2.sol\\\";\\n\\n/// @author @0xKeno\\ncontract ALCXRewarder is IRewarder,  BoringOwnable{\\n    using BoringMath for uint256;\\n    using BoringMath128 for uint128;\\n    using BoringERC20 for IERC20;\\n\\n    IERC20 private immutable rewardToken;\\n\\n    /// @notice Info of each MCV2 user.\\n    /// `amount` LP token amount the user has provided.\\n    /// `rewardDebt` The amount of SUSHI entitled to the user.\\n    struct UserInfo {\\n        uint256 amount;\\n        uint256 rewardDebt;\\n    }\\n\\n    /// @notice Info of each MCV2 pool.\\n    /// `allocPoint` The amount of allocation points assigned to the pool.\\n    /// Also known as the amount of SUSHI to distribute per block.\\n    struct PoolInfo {\\n        uint128 accSushiPerShare;\\n        uint64 lastRewardBlock;\\n        uint64 allocPoint;\\n    }\\n\\n    /// @notice Info of each pool.\\n    mapping (uint256 => PoolInfo) public poolInfo;\\n\\n    uint256[] public poolIds;\\n\\n    /// @notice Info of each user that stakes LP tokens.\\n    mapping (uint256 => mapping (address => UserInfo)) public userInfo;\\n    /// @dev Total allocation points. Must be the sum of all allocation points in all pools.\\n    uint256 totalAllocPoint;\\n\\n    uint256 public tokenPerBlock;\\n    uint256 private constant ACC_TOKEN_PRECISION = 1e12;\\n\\n    address private immutable MASTERCHEF_V2;\\n\\n    event LogOnReward(address indexed user, uint256 indexed pid, uint256 amount, address indexed to);\\n    event LogPoolAddition(uint256 indexed pid, uint256 allocPoint);\\n    event LogSetPool(uint256 indexed pid, uint256 allocPoint);\\n    event LogUpdatePool(uint256 indexed pid, uint64 lastRewardBlock, uint256 lpSupply, uint256 accSushiPerShare);\\n    event LogInit();\\n    event RewardRateUpdated(uint256 oldRate, uint256 newRate);\\n\\n    constructor (IERC20 _rewardToken, uint256 _tokenPerBlock, address _MASTERCHEF_V2) public {\\n        rewardToken = _rewardToken;\\n        tokenPerBlock = _tokenPerBlock;\\n        MASTERCHEF_V2 = _MASTERCHEF_V2;\\n    }\\n\\n\\n    function onSushiReward (uint256 pid, address _user, address to, uint256, uint256 lpToken) onlyMCV2 override external {\\n        PoolInfo memory pool = updatePool(pid);\\n        UserInfo storage user = userInfo[pid][_user];\\n        uint256 pending;\\n        if (user.amount > 0) {\\n            pending =\\n                (user.amount.mul(pool.accSushiPerShare) / ACC_TOKEN_PRECISION).sub(\\n                    user.rewardDebt\\n                );\\n            rewardToken.safeTransfer(to, pending);\\n        }\\n        user.amount = lpToken;\\n        user.rewardDebt = lpToken.mul(pool.accSushiPerShare) / ACC_TOKEN_PRECISION;\\n        emit LogOnReward(_user, pid, pending, to);\\n    }\\n    \\n    function pendingTokens(uint256 pid, address user, uint256) override external view returns (IERC20[] memory rewardTokens, uint256[] memory rewardAmounts) {\\n        IERC20[] memory _rewardTokens = new IERC20[](1);\\n        _rewardTokens[0] = (rewardToken);\\n        uint256[] memory _rewardAmounts = new uint256[](1);\\n        _rewardAmounts[0] = pendingToken(pid, user);\\n        return (_rewardTokens, _rewardAmounts);\\n    }\\n\\n    modifier onlyMCV2 {\\n        require(\\n            msg.sender == MASTERCHEF_V2,\\n            \\\"Only MCV2 can call this function.\\\"\\n        );\\n        _;\\n    }\\n\\n    /// @notice Returns the number of MCV2 pools.\\n    function poolLength() public view returns (uint256 pools) {\\n        pools = poolIds.length;\\n    }\\n\\n    /// @notice Add a new LP to the pool.  Can only be called by the owner.\\n    /// DO NOT add the same LP token more than once. Rewards will be messed up if you do.\\n    /// @param allocPoint AP of the new pool.\\n    /// @param _pid Pid on MCV2\\n    function add(uint256 allocPoint, uint256 _pid) public onlyOwner {\\n        require(poolInfo[_pid].lastRewardBlock == 0, \\\"Pool already exists\\\");\\n        uint256 lastRewardBlock = block.number;\\n        totalAllocPoint = totalAllocPoint.add(allocPoint);\\n\\n        poolInfo[_pid] = PoolInfo({\\n            allocPoint: allocPoint.to64(),\\n            lastRewardBlock: lastRewardBlock.to64(),\\n            accSushiPerShare: 0\\n        });\\n        poolIds.push(_pid);\\n        emit LogPoolAddition(_pid, allocPoint);\\n    }\\n\\n    /// @notice Update the given pool's SUSHI allocation point and `IRewarder` contract. Can only be called by the owner.\\n    /// @param _pid The index of the pool. See `poolInfo`.\\n    /// @param _allocPoint New AP of the pool.\\n    function set(uint256 _pid, uint256 _allocPoint) public onlyOwner {\\n        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint);\\n        poolInfo[_pid].allocPoint = _allocPoint.to64();\\n        emit LogSetPool(_pid, _allocPoint);\\n    }\\n\\n    /// @notice View function to see pending Token\\n    /// @param _pid The index of the pool. See `poolInfo`.\\n    /// @param _user Address of user.\\n    /// @return pending SUSHI reward for a given user.\\n    function pendingToken(uint256 _pid, address _user) public view returns (uint256 pending) {\\n        PoolInfo memory pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][_user];\\n        uint256 accSushiPerShare = pool.accSushiPerShare;\\n        uint256 lpSupply = MasterChefV2(MASTERCHEF_V2).lpToken(_pid).balanceOf(MASTERCHEF_V2);\\n        if (block.number > pool.lastRewardBlock && lpSupply != 0) {\\n            uint256 blocks = block.number.sub(pool.lastRewardBlock);\\n            uint256 sushiReward = blocks.mul(tokenPerBlock).mul(pool.allocPoint) / totalAllocPoint;\\n            accSushiPerShare = accSushiPerShare.add(sushiReward.mul(ACC_TOKEN_PRECISION) / lpSupply);\\n        }\\n        pending = (user.amount.mul(accSushiPerShare) / ACC_TOKEN_PRECISION).sub(user.rewardDebt);\\n    }\\n\\n    /// @notice Update reward variables for all pools. Be careful of gas spending!\\n    /// @param pids Pool IDs of all to be updated. Make sure to update all active pools.\\n    function massUpdatePools(uint256[] calldata pids) public {\\n        uint256 len = pids.length;\\n        for (uint256 i = 0; i < len; ++i) {\\n            updatePool(pids[i]);\\n        }\\n    }\\n\\n    /// @notice Update reward variables of the given pool.\\n    /// @param pid The index of the pool. See `poolInfo`.\\n    /// @return pool Returns the pool that was updated.\\n    function updatePool(uint256 pid) public returns (PoolInfo memory pool) {\\n        pool = poolInfo[pid];\\n        require(pool.lastRewardBlock != 0, \\\"Pool does not exist\\\");\\n        if (block.number > pool.lastRewardBlock) {\\n            uint256 lpSupply = MasterChefV2(MASTERCHEF_V2).lpToken(pid).balanceOf(MASTERCHEF_V2);\\n\\n            if (lpSupply > 0) {\\n                uint256 blocks = block.number.sub(pool.lastRewardBlock);\\n                uint256 sushiReward = blocks.mul(tokenPerBlock).mul(pool.allocPoint) / totalAllocPoint;\\n                pool.accSushiPerShare = pool.accSushiPerShare.add((sushiReward.mul(ACC_TOKEN_PRECISION) / lpSupply).to128());\\n            }\\n            pool.lastRewardBlock = block.number.to64();\\n            poolInfo[pid] = pool;\\n            emit LogUpdatePool(pid, pool.lastRewardBlock, lpSupply, pool.accSushiPerShare);\\n        }\\n    }\\n\\n    /// @dev Sets the distribution reward rate. This will also update all of the pools.\\n\\t/// @param _tokenPerBlock The number of tokens to distribute per block\\n\\tfunction setRewardRate(uint256 _tokenPerBlock, uint256[] calldata _pids) external onlyOwner {\\n\\t\\tmassUpdatePools(_pids);\\n\\n\\t\\tuint256 oldRate = tokenPerBlock;\\n\\t\\ttokenPerBlock = _tokenPerBlock;\\n\\n\\t\\temit RewardRateUpdated(oldRate, _tokenPerBlock);\\n\\t}\\n}\"\r\n    },\r\n    \"contracts/interfaces/sushi/IRewarder.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\nimport \\\"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\\\";\\ninterface IRewarder {\\n    using BoringERC20 for IERC20;\\n    function onSushiReward(uint256 pid, address user, address recipient, uint256 sushiAmount, uint256 newLpAmount) external;\\n    function pendingTokens(uint256 pid, address user, uint256 sushiAmount) external view returns (IERC20[] memory, uint256[] memory);\\n}\"\r\n    },\r\n    \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport \\\"../interfaces/IERC20.sol\\\";\\r\\n\\r\\nlibrary BoringERC20 {\\r\\n    function safeSymbol(IERC20 token) internal view returns(string memory) {\\r\\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x95d89b41));\\r\\n        return success && data.length > 0 ? abi.decode(data, (string)) : \\\"???\\\";\\r\\n    }\\r\\n\\r\\n    function safeName(IERC20 token) internal view returns(string memory) {\\r\\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x06fdde03));\\r\\n        return success && data.length > 0 ? abi.decode(data, (string)) : \\\"???\\\";\\r\\n    }\\r\\n\\r\\n    function safeDecimals(IERC20 token) internal view returns (uint8) {\\r\\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x313ce567));\\r\\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\\r\\n    }\\r\\n\\r\\n    function safeTransfer(IERC20 token, address to, uint256 amount) internal {\\r\\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0xa9059cbb, to, amount));\\r\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"BoringERC20: Transfer failed\\\");\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 amount) internal {\\r\\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0x23b872dd, from, to, amount));\\r\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"BoringERC20: TransferFrom failed\\\");\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.6.12;\\r\\n// a library for performing overflow-safe math, updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math)\\r\\nlibrary BoringMath {\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {require((c = a + b) >= b, \\\"BoringMath: Add Overflow\\\");}\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {require((c = a - b) <= a, \\\"BoringMath: Underflow\\\");}\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {require(b == 0 || (c = a * b)/b == a, \\\"BoringMath: Mul Overflow\\\");}\\r\\n    function to128(uint256 a) internal pure returns (uint128 c) {\\r\\n        require(a <= uint128(-1), \\\"BoringMath: uint128 Overflow\\\");\\r\\n        c = uint128(a);\\r\\n    }\\r\\n    function to64(uint256 a) internal pure returns (uint64 c) {\\r\\n        require(a <= uint64(-1), \\\"BoringMath: uint64 Overflow\\\");\\r\\n        c = uint64(a);\\r\\n    }\\r\\n    function to32(uint256 a) internal pure returns (uint32 c) {\\r\\n        require(a <= uint32(-1), \\\"BoringMath: uint32 Overflow\\\");\\r\\n        c = uint32(a);\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary BoringMath128 {\\r\\n    function add(uint128 a, uint128 b) internal pure returns (uint128 c) {require((c = a + b) >= b, \\\"BoringMath: Add Overflow\\\");}\\r\\n    function sub(uint128 a, uint128 b) internal pure returns (uint128 c) {require((c = a - b) <= a, \\\"BoringMath: Underflow\\\");}\\r\\n}\\r\\n\\r\\nlibrary BoringMath64 {\\r\\n    function add(uint64 a, uint64 b) internal pure returns (uint64 c) {require((c = a + b) >= b, \\\"BoringMath: Add Overflow\\\");}\\r\\n    function sub(uint64 a, uint64 b) internal pure returns (uint64 c) {require((c = a - b) <= a, \\\"BoringMath: Underflow\\\");}\\r\\n}\\r\\n\\r\\nlibrary BoringMath32 {\\r\\n    function add(uint32 a, uint32 b) internal pure returns (uint32 c) {require((c = a + b) >= b, \\\"BoringMath: Add Overflow\\\");}\\r\\n    function sub(uint32 a, uint32 b) internal pure returns (uint32 c) {require((c = a - b) <= a, \\\"BoringMath: Underflow\\\");}\\r\\n}\"\r\n    },\r\n    \"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// Audit on 5-Jan-2021 by Keno and BoringCrypto\\r\\n\\r\\n// P1 - P3: OK\\r\\npragma solidity 0.6.12;\\r\\n\\r\\n// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol\\r\\n// Edited by BoringCrypto\\r\\n\\r\\n// T1 - T4: OK\\r\\ncontract BoringOwnableData {\\r\\n    // V1 - V5: OK\\r\\n    address public owner;\\r\\n    // V1 - V5: OK\\r\\n    address public pendingOwner;\\r\\n}\\r\\n\\r\\n// T1 - T4: OK\\r\\ncontract BoringOwnable is BoringOwnableData {\\r\\n    // E1: OK\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    constructor () public {\\r\\n        owner = msg.sender;\\r\\n        emit OwnershipTransferred(address(0), msg.sender);\\r\\n    }\\r\\n\\r\\n    // F1 - F9: OK\\r\\n    // C1 - C21: OK\\r\\n    function transferOwnership(address newOwner, bool direct, bool renounce) public onlyOwner {\\r\\n        if (direct) {\\r\\n            // Checks\\r\\n            require(newOwner != address(0) || renounce, \\\"Ownable: zero address\\\");\\r\\n\\r\\n            // Effects\\r\\n            emit OwnershipTransferred(owner, newOwner);\\r\\n            owner = newOwner;\\r\\n            pendingOwner = address(0);\\r\\n        } else {\\r\\n            // Effects\\r\\n            pendingOwner = newOwner;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // F1 - F9: OK\\r\\n    // C1 - C21: OK\\r\\n    function claimOwnership() public {\\r\\n        address _pendingOwner = pendingOwner;\\r\\n        \\r\\n        // Checks\\r\\n        require(msg.sender == _pendingOwner, \\\"Ownable: caller != pending owner\\\");\\r\\n\\r\\n        // Effects\\r\\n        emit OwnershipTransferred(owner, _pendingOwner);\\r\\n        owner = _pendingOwner;\\r\\n        pendingOwner = address(0);\\r\\n    }\\r\\n\\r\\n    // M1 - M5: OK\\r\\n    // C1 - C21: OK\\r\\n    modifier onlyOwner() {\\r\\n        require(msg.sender == owner, \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/MasterChefV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\\\";\\nimport \\\"@boringcrypto/boring-solidity/contracts/BoringBatchable.sol\\\";\\nimport \\\"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\\\";\\nimport \\\"./libraries/math/SignedSafeMath.sol\\\";\\nimport \\\"./interfaces/sushi/IRewarder.sol\\\";\\nimport \\\"./interfaces/sushi/IMasterChef.sol\\\";\\n\\ninterface IMigratorChef {\\n\\t// Take the current LP token address and return the new LP token address.\\n\\t// Migrator should have full access to the caller's LP token.\\n\\tfunction migrate(IERC20 token) external returns (IERC20);\\n}\\n\\n/// @notice The (older) MasterChef contract gives out a constant number of SUSHI tokens per block.\\n/// It is the only address with minting rights for SUSHI.\\n/// The idea for this MasterChef V2 (MCV2) contract is therefore to be the owner of a dummy token\\n/// that is deposited into the MasterChef V1 (MCV1) contract.\\n/// The allocation point for this pool on MCV1 is the total allocation point for all pools that receive double incentives.\\ncontract MasterChefV2 is BoringOwnable {\\n\\tusing BoringMath for uint256;\\n\\tusing BoringMath128 for uint128;\\n\\tusing BoringERC20 for IERC20;\\n\\tusing SignedSafeMath for int256;\\n\\n\\t/// @notice Info of each MCV2 user.\\n\\t/// `amount` LP token amount the user has provided.\\n\\t/// `rewardDebt` The amount of SUSHI entitled to the user.\\n\\tstruct UserInfo {\\n\\t\\tuint256 amount;\\n\\t\\tint256 rewardDebt;\\n\\t}\\n\\n\\t/// @notice Info of each MCV2 pool.\\n\\t/// `allocPoint` The amount of allocation points assigned to the pool.\\n\\t/// Also known as the amount of SUSHI to distribute per block.\\n\\tstruct PoolInfo {\\n\\t\\tuint128 accSushiPerShare;\\n\\t\\tuint64 lastRewardBlock;\\n\\t\\tuint64 allocPoint;\\n\\t}\\n\\n\\t/// @notice Address of MCV1 contract.\\n\\tIMasterChef public immutable MASTER_CHEF;\\n\\t/// @notice Address of SUSHI contract.\\n\\tIERC20 public immutable SUSHI;\\n\\t/// @notice The index of MCV2 master pool in MCV1.\\n\\tuint256 public immutable MASTER_PID;\\n\\t// @notice The migrator contract. It has a lot of power. Can only be set through governance (owner).\\n\\tIMigratorChef public migrator;\\n\\n\\t/// @notice Info of each MCV2 pool.\\n\\tPoolInfo[] public poolInfo;\\n\\t/// @notice Address of the LP token for each MCV2 pool.\\n\\tIERC20[] public lpToken;\\n\\t/// @notice Address of each `IRewarder` contract in MCV2.\\n\\tIRewarder[] public rewarder;\\n\\n\\t/// @notice Info of each user that stakes LP tokens.\\n\\tmapping(uint256 => mapping(address => UserInfo)) public userInfo;\\n\\t/// @dev Total allocation points. Must be the sum of all allocation points in all pools.\\n\\tuint256 public totalAllocPoint;\\n\\n\\tuint256 private constant MASTERCHEF_SUSHI_PER_BLOCK = 1e20;\\n\\tuint256 private constant ACC_SUSHI_PRECISION = 1e12;\\n\\n\\tevent Deposit(address indexed user, uint256 indexed pid, uint256 amount, address indexed to);\\n\\tevent Withdraw(address indexed user, uint256 indexed pid, uint256 amount, address indexed to);\\n\\tevent EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount, address indexed to);\\n\\tevent Harvest(address indexed user, uint256 indexed pid, uint256 amount);\\n\\tevent LogPoolAddition(uint256 indexed pid, uint256 allocPoint, IERC20 indexed lpToken, IRewarder indexed rewarder);\\n\\tevent LogSetPool(uint256 indexed pid, uint256 allocPoint, IRewarder indexed rewarder, bool overwrite);\\n\\tevent LogUpdatePool(uint256 indexed pid, uint64 lastRewardBlock, uint256 lpSupply, uint256 accSushiPerShare);\\n\\tevent LogInit();\\n\\n\\t/// @param _MASTER_CHEF The SushiSwap MCV1 contract address.\\n\\t/// @param _sushi The SUSHI token contract address.\\n\\t/// @param _MASTER_PID The pool ID of the dummy token on the base MCV1 contract.\\n\\tconstructor(\\n\\t\\tIMasterChef _MASTER_CHEF,\\n\\t\\tIERC20 _sushi,\\n\\t\\tuint256 _MASTER_PID\\n\\t) public {\\n\\t\\tMASTER_CHEF = _MASTER_CHEF;\\n\\t\\tSUSHI = _sushi;\\n\\t\\tMASTER_PID = _MASTER_PID;\\n\\t}\\n\\n\\t/// @notice Deposits a dummy token to `MASTER_CHEF` MCV1. This is required because MCV1 holds the minting rights for SUSHI.\\n\\t/// Any balance of transaction sender in `dummyToken` is transferred.\\n\\t/// The allocation point for the pool on MCV1 is the total allocation point for all pools that receive double incentives.\\n\\t/// @param dummyToken The address of the ERC-20 token to deposit into MCV1.\\n\\tfunction init(IERC20 dummyToken) external {\\n\\t\\tuint256 balance = dummyToken.balanceOf(msg.sender);\\n\\t\\trequire(balance != 0, \\\"MasterChefV2: Balance must exceed 0\\\");\\n\\t\\tdummyToken.safeTransferFrom(msg.sender, address(this), balance);\\n\\t\\tdummyToken.approve(address(MASTER_CHEF), balance);\\n\\t\\tMASTER_CHEF.deposit(MASTER_PID, balance);\\n\\t\\temit LogInit();\\n\\t}\\n\\n\\t/// @notice Returns the number of MCV2 pools.\\n\\tfunction poolLength() public view returns (uint256 pools) {\\n\\t\\tpools = poolInfo.length;\\n\\t}\\n\\n\\t/// @notice Add a new LP to the pool. Can only be called by the owner.\\n\\t/// DO NOT add the same LP token more than once. Rewards will be messed up if you do.\\n\\t/// @param allocPoint AP of the new pool.\\n\\t/// @param _lpToken Address of the LP ERC-20 token.\\n\\t/// @param _rewarder Address of the rewarder delegate.\\n\\tfunction add(\\n\\t\\tuint256 allocPoint,\\n\\t\\tIERC20 _lpToken,\\n\\t\\tIRewarder _rewarder\\n\\t) public onlyOwner {\\n\\t\\tuint256 lastRewardBlock = block.number;\\n\\t\\ttotalAllocPoint = totalAllocPoint.add(allocPoint);\\n\\t\\tlpToken.push(_lpToken);\\n\\t\\trewarder.push(_rewarder);\\n\\n\\t\\tpoolInfo.push(\\n\\t\\t\\tPoolInfo({ allocPoint: allocPoint.to64(), lastRewardBlock: lastRewardBlock.to64(), accSushiPerShare: 0 })\\n\\t\\t);\\n\\t\\temit LogPoolAddition(lpToken.length.sub(1), allocPoint, _lpToken, _rewarder);\\n\\t}\\n\\n\\t/// @notice Update the given pool's SUSHI allocation point and `IRewarder` contract. Can only be called by the owner.\\n\\t/// @param _pid The index of the pool. See `poolInfo`.\\n\\t/// @param _allocPoint New AP of the pool.\\n\\t/// @param _rewarder Address of the rewarder delegate.\\n\\t/// @param overwrite True if _rewarder should be `set`. Otherwise `_rewarder` is ignored.\\n\\tfunction set(\\n\\t\\tuint256 _pid,\\n\\t\\tuint256 _allocPoint,\\n\\t\\tIRewarder _rewarder,\\n\\t\\tbool overwrite\\n\\t) public onlyOwner {\\n\\t\\ttotalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint);\\n\\t\\tpoolInfo[_pid].allocPoint = _allocPoint.to64();\\n\\t\\tif (overwrite) {\\n\\t\\t\\trewarder[_pid] = _rewarder;\\n\\t\\t}\\n\\t\\temit LogSetPool(_pid, _allocPoint, overwrite ? _rewarder : rewarder[_pid], overwrite);\\n\\t}\\n\\n\\t/// @notice Set the `migrator` contract. Can only be called by the owner.\\n\\t/// @param _migrator The contract address to set.\\n\\tfunction setMigrator(IMigratorChef _migrator) public onlyOwner {\\n\\t\\tmigrator = _migrator;\\n\\t}\\n\\n\\t/// @notice Migrate LP token to another LP contract through the `migrator` contract.\\n\\t/// @param _pid The index of the pool. See `poolInfo`.\\n\\tfunction migrate(uint256 _pid) public {\\n\\t\\trequire(address(migrator) != address(0), \\\"MasterChefV2: no migrator set\\\");\\n\\t\\tIERC20 _lpToken = lpToken[_pid];\\n\\t\\tuint256 bal = _lpToken.balanceOf(address(this));\\n\\t\\t_lpToken.approve(address(migrator), bal);\\n\\t\\tIERC20 newLpToken = migrator.migrate(_lpToken);\\n\\t\\trequire(bal == newLpToken.balanceOf(address(this)), \\\"MasterChefV2: migrated balance must match\\\");\\n\\t\\tlpToken[_pid] = newLpToken;\\n\\t}\\n\\n\\t/// @notice View function to see pending SUSHI on frontend.\\n\\t/// @param _pid The index of the pool. See `poolInfo`.\\n\\t/// @param _user Address of user.\\n\\t/// @return pending SUSHI reward for a given user.\\n\\tfunction pendingSushi(uint256 _pid, address _user) external view returns (uint256 pending) {\\n\\t\\tPoolInfo memory pool = poolInfo[_pid];\\n\\t\\tUserInfo storage user = userInfo[_pid][_user];\\n\\t\\tuint256 accSushiPerShare = pool.accSushiPerShare;\\n\\t\\tuint256 lpSupply = lpToken[_pid].balanceOf(address(this));\\n\\t\\tif (block.number > pool.lastRewardBlock && lpSupply != 0) {\\n\\t\\t\\tuint256 blocks = block.number.sub(pool.lastRewardBlock);\\n\\t\\t\\tuint256 sushiReward = blocks.mul(sushiPerBlock()).mul(pool.allocPoint) / totalAllocPoint;\\n\\t\\t\\taccSushiPerShare = accSushiPerShare.add(sushiReward.mul(ACC_SUSHI_PRECISION) / lpSupply);\\n\\t\\t}\\n\\t\\tpending = int256(user.amount.mul(accSushiPerShare) / ACC_SUSHI_PRECISION).sub(user.rewardDebt).toUInt256();\\n\\t}\\n\\n\\t/// @notice Update reward variables for all pools. Be careful of gas spending!\\n\\t/// @param pids Pool IDs of all to be updated. Make sure to update all active pools.\\n\\tfunction massUpdatePools(uint256[] calldata pids) external {\\n\\t\\tuint256 len = pids.length;\\n\\t\\tfor (uint256 i = 0; i < len; ++i) {\\n\\t\\t\\tupdatePool(pids[i]);\\n\\t\\t}\\n\\t}\\n\\n\\t/// @notice Calculates and returns the `amount` of SUSHI per block.\\n\\tfunction sushiPerBlock() public view returns (uint256 amount) {\\n\\t\\tamount =\\n\\t\\t\\tuint256(MASTERCHEF_SUSHI_PER_BLOCK).mul(MASTER_CHEF.poolInfo(MASTER_PID).allocPoint) /\\n\\t\\t\\tMASTER_CHEF.totalAllocPoint();\\n\\t}\\n\\n\\t/// @notice Update reward variables of the given pool.\\n\\t/// @param pid The index of the pool. See `poolInfo`.\\n\\t/// @return pool Returns the pool that was updated.\\n\\tfunction updatePool(uint256 pid) public returns (PoolInfo memory pool) {\\n\\t\\tpool = poolInfo[pid];\\n\\t\\tif (block.number > pool.lastRewardBlock) {\\n\\t\\t\\tuint256 lpSupply = lpToken[pid].balanceOf(address(this));\\n\\t\\t\\tif (lpSupply > 0) {\\n\\t\\t\\t\\tuint256 blocks = block.number.sub(pool.lastRewardBlock);\\n\\t\\t\\t\\tuint256 sushiReward = blocks.mul(sushiPerBlock()).mul(pool.allocPoint) / totalAllocPoint;\\n\\t\\t\\t\\tpool.accSushiPerShare = pool.accSushiPerShare.add(\\n\\t\\t\\t\\t\\t(sushiReward.mul(ACC_SUSHI_PRECISION) / lpSupply).to128()\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t\\tpool.lastRewardBlock = block.number.to64();\\n\\t\\t\\tpoolInfo[pid] = pool;\\n\\t\\t\\temit LogUpdatePool(pid, pool.lastRewardBlock, lpSupply, pool.accSushiPerShare);\\n\\t\\t}\\n\\t}\\n\\n\\t/// @notice Deposit LP tokens to MCV2 for SUSHI allocation.\\n\\t/// @param pid The index of the pool. See `poolInfo`.\\n\\t/// @param amount LP token amount to deposit.\\n\\t/// @param to The receiver of `amount` deposit benefit.\\n\\tfunction deposit(\\n\\t\\tuint256 pid,\\n\\t\\tuint256 amount,\\n\\t\\taddress to\\n\\t) public {\\n\\t\\tPoolInfo memory pool = updatePool(pid);\\n\\t\\tUserInfo storage user = userInfo[pid][to];\\n\\n\\t\\t// Effects\\n\\t\\tuser.amount = user.amount.add(amount);\\n\\t\\tuser.rewardDebt = user.rewardDebt.add(int256(amount.mul(pool.accSushiPerShare) / ACC_SUSHI_PRECISION));\\n\\n\\t\\t// Interactions\\n\\t\\tIRewarder _rewarder = rewarder[pid];\\n\\t\\tif (address(_rewarder) != address(0)) {\\n\\t\\t\\t_rewarder.onSushiReward(pid, to, to, 0, user.amount);\\n\\t\\t}\\n\\n\\t\\tlpToken[pid].safeTransferFrom(msg.sender, address(this), amount);\\n\\n\\t\\temit Deposit(msg.sender, pid, amount, to);\\n\\t}\\n\\n\\t/// @notice Withdraw LP tokens from MCV2.\\n\\t/// @param pid The index of the pool. See `poolInfo`.\\n\\t/// @param amount LP token amount to withdraw.\\n\\t/// @param to Receiver of the LP tokens.\\n\\tfunction withdraw(\\n\\t\\tuint256 pid,\\n\\t\\tuint256 amount,\\n\\t\\taddress to\\n\\t) public {\\n\\t\\tPoolInfo memory pool = updatePool(pid);\\n\\t\\tUserInfo storage user = userInfo[pid][msg.sender];\\n\\n\\t\\t// Effects\\n\\t\\tuser.rewardDebt = user.rewardDebt.sub(int256(amount.mul(pool.accSushiPerShare) / ACC_SUSHI_PRECISION));\\n\\t\\tuser.amount = user.amount.sub(amount);\\n\\n\\t\\t// Interactions\\n\\t\\tIRewarder _rewarder = rewarder[pid];\\n\\t\\tif (address(_rewarder) != address(0)) {\\n\\t\\t\\t_rewarder.onSushiReward(pid, msg.sender, to, 0, user.amount);\\n\\t\\t}\\n\\n\\t\\tlpToken[pid].safeTransfer(to, amount);\\n\\n\\t\\temit Withdraw(msg.sender, pid, amount, to);\\n\\t}\\n\\n\\t/// @notice Harvest proceeds for transaction sender to `to`.\\n\\t/// @param pid The index of the pool. See `poolInfo`.\\n\\t/// @param to Receiver of SUSHI rewards.\\n\\tfunction harvest(uint256 pid, address to) public {\\n\\t\\tPoolInfo memory pool = updatePool(pid);\\n\\t\\tUserInfo storage user = userInfo[pid][msg.sender];\\n\\t\\tint256 accumulatedSushi = int256(user.amount.mul(pool.accSushiPerShare) / ACC_SUSHI_PRECISION);\\n\\t\\tuint256 _pendingSushi = accumulatedSushi.sub(user.rewardDebt).toUInt256();\\n\\n\\t\\t// Effects\\n\\t\\tuser.rewardDebt = accumulatedSushi;\\n\\n\\t\\t// Interactions\\n\\t\\tif (_pendingSushi != 0) {\\n\\t\\t\\tSUSHI.safeTransfer(to, _pendingSushi);\\n\\t\\t}\\n\\n\\t\\tIRewarder _rewarder = rewarder[pid];\\n\\t\\tif (address(_rewarder) != address(0)) {\\n\\t\\t\\t_rewarder.onSushiReward(pid, msg.sender, to, _pendingSushi, user.amount);\\n\\t\\t}\\n\\n\\t\\temit Harvest(msg.sender, pid, _pendingSushi);\\n\\t}\\n\\n\\t/// @notice Withdraw LP tokens from MCV2 and harvest proceeds for transaction sender to `to`.\\n\\t/// @param pid The index of the pool. See `poolInfo`.\\n\\t/// @param amount LP token amount to withdraw.\\n\\t/// @param to Receiver of the LP tokens and SUSHI rewards.\\n\\tfunction withdrawAndHarvest(\\n\\t\\tuint256 pid,\\n\\t\\tuint256 amount,\\n\\t\\taddress to\\n\\t) public {\\n\\t\\tPoolInfo memory pool = updatePool(pid);\\n\\t\\tUserInfo storage user = userInfo[pid][msg.sender];\\n\\t\\tint256 accumulatedSushi = int256(user.amount.mul(pool.accSushiPerShare) / ACC_SUSHI_PRECISION);\\n\\t\\tuint256 _pendingSushi = accumulatedSushi.sub(user.rewardDebt).toUInt256();\\n\\n\\t\\t// Effects\\n\\t\\tuser.rewardDebt = accumulatedSushi.sub(int256(amount.mul(pool.accSushiPerShare) / ACC_SUSHI_PRECISION));\\n\\t\\tuser.amount = user.amount.sub(amount);\\n\\n\\t\\t// Interactions\\n\\t\\tSUSHI.safeTransfer(to, _pendingSushi);\\n\\n\\t\\tIRewarder _rewarder = rewarder[pid];\\n\\t\\tif (address(_rewarder) != address(0)) {\\n\\t\\t\\t_rewarder.onSushiReward(pid, msg.sender, to, _pendingSushi, user.amount);\\n\\t\\t}\\n\\n\\t\\tlpToken[pid].safeTransfer(to, amount);\\n\\n\\t\\temit Withdraw(msg.sender, pid, amount, to);\\n\\t\\temit Harvest(msg.sender, pid, _pendingSushi);\\n\\t}\\n\\n\\t/// @notice Harvests SUSHI from `MASTER_CHEF` MCV1 and pool `MASTER_PID` to this MCV2 contract.\\n\\tfunction harvestFromMasterChef() public {\\n\\t\\tMASTER_CHEF.deposit(MASTER_PID, 0);\\n\\t}\\n\\n\\t/// @notice Withdraw without caring about rewards. EMERGENCY ONLY.\\n\\t/// @param pid The index of the pool. See `poolInfo`.\\n\\t/// @param to Receiver of the LP tokens.\\n\\tfunction emergencyWithdraw(uint256 pid, address to) public {\\n\\t\\tUserInfo storage user = userInfo[pid][msg.sender];\\n\\t\\tuint256 amount = user.amount;\\n\\t\\tuser.amount = 0;\\n\\t\\tuser.rewardDebt = 0;\\n\\n\\t\\tIRewarder _rewarder = rewarder[pid];\\n\\t\\tif (address(_rewarder) != address(0)) {\\n\\t\\t\\t_rewarder.onSushiReward(pid, msg.sender, to, 0, 0);\\n\\t\\t}\\n\\n\\t\\t// Note: transfer can fail or succeed if `amount` is zero.\\n\\t\\tlpToken[pid].safeTransfer(to, amount);\\n\\t\\temit EmergencyWithdraw(msg.sender, pid, amount, to);\\n\\t}\\n}\\n\"\r\n    },\r\n    \"@boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.6.12;\\r\\n\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n    // EIP 2612\\r\\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n}\"\r\n    },\r\n    \"@boringcrypto/boring-solidity/contracts/BoringBatchable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\n// Audit on 5-Jan-2021 by Keno and BoringCrypto\\r\\n\\r\\n// P1 - P3: OK\\r\\npragma solidity 0.6.12;\\r\\npragma experimental ABIEncoderV2;\\r\\n// solhint-disable avoid-low-level-calls\\r\\n\\r\\nimport \\\"./libraries/BoringERC20.sol\\\";\\r\\n\\r\\n// T1 - T4: OK\\r\\ncontract BaseBoringBatchable {\\r\\n    function _getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {\\r\\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\\r\\n        if (_returnData.length < 68) return \\\"Transaction reverted silently\\\";\\r\\n\\r\\n        assembly {\\r\\n            // Slice the sighash.\\r\\n            _returnData := add(_returnData, 0x04)\\r\\n        }\\r\\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\\r\\n    }    \\r\\n    \\r\\n    // F3 - F9: OK\\r\\n    // F1: External is ok here because this is the batch function, adding it to a batch makes no sense\\r\\n    // F2: Calls in the batch may be payable, delegatecall operates in the same context, so each call in the batch has access to msg.value\\r\\n    // C1 - C21: OK\\r\\n    // C3: The length of the loop is fully under user control, so can't be exploited\\r\\n    // C7: Delegatecall is only used on the same contract, so it's safe\\r\\n    function batch(bytes[] calldata calls, bool revertOnFail) external payable returns(bool[] memory successes, bytes[] memory results) {\\r\\n        // Interactions\\r\\n        successes = new bool[](calls.length);\\r\\n        results = new bytes[](calls.length);\\r\\n        for (uint256 i = 0; i < calls.length; i++) {\\r\\n            (bool success, bytes memory result) = address(this).delegatecall(calls[i]);\\r\\n            require(success || !revertOnFail, _getRevertMsg(result));\\r\\n            successes[i] = success;\\r\\n            results[i] = result;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n// T1 - T4: OK\\r\\ncontract BoringBatchable is BaseBoringBatchable {\\r\\n    // F1 - F9: OK\\r\\n    // F6: Parameters can be used front-run the permit and the user's permit will fail (due to nonce or other revert)\\r\\n    //     if part of a batch this could be used to grief once as the second call would not need the permit\\r\\n    // C1 - C21: OK\\r\\n    function permitToken(IERC20 token, address from, address to, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\\r\\n        // Interactions\\r\\n        // X1 - X5\\r\\n        token.permit(from, to, amount, deadline, v, r, s);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/libraries/math/SignedSafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nlibrary SignedSafeMath {\\n\\tint256 private constant _INT256_MIN = -2**255;\\n\\n\\t/**\\n\\t * @dev Returns the multiplication of two signed integers, reverting on\\n\\t * overflow.\\n\\t *\\n\\t * Counterpart to Solidity's `*` operator.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - Multiplication cannot overflow.\\n\\t */\\n\\tfunction mul(int256 a, int256 b) internal pure returns (int256) {\\n\\t\\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n\\t\\t// benefit is lost if 'b' is also tested.\\n\\t\\t// See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n\\t\\tif (a == 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\trequire(!(a == -1 && b == _INT256_MIN), \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n\\t\\tint256 c = a * b;\\n\\t\\trequire(c / a == b, \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n\\t\\treturn c;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the integer division of two signed integers. Reverts on\\n\\t * division by zero. The result is rounded towards zero.\\n\\t *\\n\\t * Counterpart to Solidity's `/` operator. Note: this function uses a\\n\\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n\\t * uses an invalid opcode to revert (consuming all remaining gas).\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - The divisor cannot be zero.\\n\\t */\\n\\tfunction div(int256 a, int256 b) internal pure returns (int256) {\\n\\t\\trequire(b != 0, \\\"SignedSafeMath: division by zero\\\");\\n\\t\\trequire(!(b == -1 && a == _INT256_MIN), \\\"SignedSafeMath: division overflow\\\");\\n\\n\\t\\tint256 c = a / b;\\n\\n\\t\\treturn c;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the subtraction of two signed integers, reverting on\\n\\t * overflow.\\n\\t *\\n\\t * Counterpart to Solidity's `-` operator.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - Subtraction cannot overflow.\\n\\t */\\n\\tfunction sub(int256 a, int256 b) internal pure returns (int256) {\\n\\t\\tint256 c = a - b;\\n\\t\\trequire((b >= 0 && c <= a) || (b < 0 && c > a), \\\"SignedSafeMath: subtraction overflow\\\");\\n\\n\\t\\treturn c;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the addition of two signed integers, reverting on\\n\\t * overflow.\\n\\t *\\n\\t * Counterpart to Solidity's `+` operator.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - Addition cannot overflow.\\n\\t */\\n\\tfunction add(int256 a, int256 b) internal pure returns (int256) {\\n\\t\\tint256 c = a + b;\\n\\t\\trequire((b >= 0 && c >= a) || (b < 0 && c < a), \\\"SignedSafeMath: addition overflow\\\");\\n\\n\\t\\treturn c;\\n\\t}\\n\\n\\tfunction toUInt256(int256 a) internal pure returns (uint256) {\\n\\t\\trequire(a >= 0, \\\"Integer < 0\\\");\\n\\t\\treturn uint256(a);\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/sushi/IMasterChef.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport { BoringERC20, IERC20 } from \\\"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\\\";\\n\\ninterface IMasterChef {\\n\\tusing BoringERC20 for IERC20;\\n\\tstruct UserInfo {\\n\\t\\tuint256 amount; // How many LP tokens the user has provided.\\n\\t\\tuint256 rewardDebt; // Reward debt. See explanation below.\\n\\t}\\n\\n\\tstruct PoolInfo {\\n\\t\\tIERC20 lpToken; // Address of LP token contract.\\n\\t\\tuint256 allocPoint; // How many allocation points assigned to this pool. SUSHI to distribute per block.\\n\\t\\tuint256 lastRewardBlock; // Last block number that SUSHI distribution occurs.\\n\\t\\tuint256 accSushiPerShare; // Accumulated SUSHI per share, times 1e12. See below.\\n\\t}\\n\\n\\tfunction poolInfo(uint256 pid) external view returns (IMasterChef.PoolInfo memory);\\n\\n\\tfunction totalAllocPoint() external view returns (uint256);\\n\\n\\tfunction deposit(uint256 _pid, uint256 _amount) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_MASTERCHEF_V2\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogInit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"LogOnReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"}],\"name\":\"LogPoolAddition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"}],\"name\":\"LogSetPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"lastRewardBlock\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accSushiPerShare\",\"type\":\"uint256\"}],\"name\":\"LogUpdatePool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRate\",\"type\":\"uint256\"}],\"name\":\"RewardRateUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"add\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"pids\",\"type\":\"uint256[]\"}],\"name\":\"massUpdatePools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpToken\",\"type\":\"uint256\"}],\"name\":\"onSushiReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pending\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pendingTokens\",\"outputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"rewardTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"rewardAmounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolInfo\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"accSushiPerShare\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"lastRewardBlock\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"allocPoint\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pools\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_allocPoint\",\"type\":\"uint256\"}],\"name\":\"set\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_pids\",\"type\":\"uint256[]\"}],\"name\":\"setRewardRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"direct\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"renounce\",\"type\":\"bool\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"}],\"name\":\"updatePool\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"accSushiPerShare\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"lastRewardBlock\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"allocPoint\",\"type\":\"uint64\"}],\"internalType\":\"struct ALCXRewarder.PoolInfo\",\"name\":\"pool\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ALCXRewarder","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"000000000000000000000000dbdb4d16eda451d0503b854cf79d55697f90c8df0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ef0881ec094552b2e128cf945ef17a6752b4ec5d","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}