{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.4 <0.9.0;\r\ninterface I {\r\n\tfunction balanceOf(address a) external view returns (uint);\r\n\tfunction transfer(address recipient, uint amount) external returns (bool);\r\n\tfunction transferFrom(address sender,address recipient, uint amount) external returns (bool);\r\n\tfunction totalSupply() external view returns (uint);\r\n//\tfunction getLastVoted(address account) external view returns (uint lastVoted); function changeAddress(address acc,address acc1) external;\r\n\tfunction getRewards(address a,uint rewToClaim) external returns(bool);\r\n\tfunction contributions(address a) external view returns(uint);\r\n//\tfunction providerMigr(address a,uint lpShare,uint lastClaim,uint lastEpoch,uint tknAmount,bool status) external;function lockerMigr(address a,uint amount,uint lockUpTo) external;\r\n}\r\n\r\n// did change it a small bit: founders are unable to stake generic liquidity on top of their share, or it will be too expensive to sload\r\n// for that they will have to use another address\r\n\r\ncontract StakingContract {\r\n\tuint128 private _foundingETHDeposited;\r\n\tuint128 private _foundingLPtokensMinted;\r\n\taddress private _tokenETHLP;\r\n\tbool private _init;\r\n\tuint88 private _genLPtokens;\r\n\r\n\tstruct LPProvider {uint32 lastClaim; uint16 lastEpoch; bool founder; uint128 tknAmount; uint128 lpShare;uint128 lockedAmount;uint128 lockUpTo;}\r\n\tstruct TokenLocker {uint128 amount;uint128 lockUpTo;}\r\n\r\n\tbytes32[] private _epochs;\r\n\tbytes32[] private _founderEpochs;\r\n\r\n\tmapping(address => LPProvider) private _ps;\r\n\tmapping(address => TokenLocker) private _ls;\r\n//\tmapping(address => address) public newAddresses;\r\n//\tmapping(address => bool) private _takenNew;\r\n\r\n\tfunction init(uint foundingETH, address tkn) public {\r\n\t\trequire(msg.sender == 0x901628CF11454AFF335770e8a9407CccAb3675BE && _init == false);\r\n\t\t_foundingETHDeposited = uint128(foundingETH);\r\n\t\t_foundingLPtokensMinted = uint128(I(tkn).balanceOf(address(this)));\r\n\t\t_tokenETHLP = tkn;\r\n\t\t_init = true;\r\n\t\t_createEpoch(0,false);\r\n\t\t_createEpoch(1e24,true);\r\n\t}\r\n\r\n\tfunction claimFounderStatus() public {\r\n\t\tuint ethContributed = I(0x901628CF11454AFF335770e8a9407CccAb3675BE).contributions(msg.sender);\r\n\t\trequire(ethContributed > 0);\r\n\t\trequire(_init == true && _ps[msg.sender].founder == false);\r\n\t\t_ps[msg.sender].founder = true;\r\n\t\tuint foundingETH = _foundingETHDeposited;\r\n\t\tuint lpShare = _foundingLPtokensMinted*ethContributed/foundingETH;\r\n\t\tuint tknAmount = ethContributed*1e24/foundingETH;\r\n\t\t_ps[msg.sender].lpShare = uint128(lpShare);\r\n\t\t_ps[msg.sender].tknAmount = uint128(tknAmount);\r\n\t\t_ps[msg.sender].lastClaim = 1264e4;\r\n\t}\r\n\r\n\tfunction unstakeLp(bool ok,uint amount) public {\r\n\t\t(uint lastClaim,bool status,uint tknAmount,uint lpShare,uint lockedAmount) = getProvider(msg.sender);\r\n\t\trequire(lpShare-lockedAmount >= amount && ok == true);\r\n\t\tif (lastClaim != block.number) {_getRewards(msg.sender);}\r\n\t\t_ps[msg.sender].lpShare = uint128(lpShare - amount);\r\n\t\tuint toSubtract = tknAmount*amount/lpShare; // not an array of deposits. if a provider stakes and then stakes again, and then unstakes - he loses share as if he staked only once at lowest price he had\r\n\t\t_ps[msg.sender].tknAmount = uint128(tknAmount-toSubtract);\r\n\t\tbytes32 epoch; uint length;\r\n\t\tif (status == true) {length = _founderEpochs.length; epoch = _founderEpochs[length-1];}\r\n\t\telse{length = _epochs.length; epoch = _epochs[length-1];_genLPtokens -= uint88(amount/1e10);}\r\n\t\t(uint80 eBlock,uint96 eAmount,) = _extractEpoch(epoch);\r\n\t\teAmount -= uint96(toSubtract);\r\n\t\t_storeEpoch(eBlock,eAmount,status,length);\r\n\t\tI(_tokenETHLP).transfer(address(msg.sender), amount);\r\n\t}\r\n\r\n\tfunction getRewards() public {_getRewards(msg.sender);}\r\n\r\n\tfunction _getRewards(address a) internal {\r\n\t\tuint lastClaim = _ps[a].lastClaim;\r\n\t\tuint epochToClaim = _ps[a].lastEpoch;\r\n\t\tbool status = _ps[a].founder;\r\n\t\tuint tknAmount = _ps[a].tknAmount;\r\n\t\trequire(block.number>lastClaim);\r\n\t\t_ps[a].lastClaim = uint32(block.number);\r\n\t\tuint rate = _getRate();\r\n\t\tuint eBlock; uint eAmount; uint eEnd; bytes32 epoch; uint length; uint toClaim;\r\n\t\tif (status) {length = _founderEpochs.length;} else {length = _epochs.length;}\r\n\t\tif (length>0 && epochToClaim < length-1) {\r\n\t\t\tfor (uint i = epochToClaim; i<length;i++) {\r\n\t\t\t\tif (status) {epoch = _founderEpochs[i];} else {epoch = _epochs[i];}\r\n\t\t\t\t(eBlock,eAmount,eEnd) = _extractEpoch(epoch);\r\n\t\t\t\tif(i == length-1) {eBlock = lastClaim;}\r\n\t\t\t\ttoClaim += _computeRewards(eBlock,eAmount,eEnd,tknAmount,rate);\r\n\t\t\t}\r\n\t\t\t_ps[a].lastEpoch = uint16(length-1);\r\n\t\t} else {\r\n\t\t\tif(status){epoch = _founderEpochs[length-1];} else {epoch = _epochs[length-1];}\r\n\t\t\teAmount = uint96(bytes12(epoch << 80)); toClaim = _computeRewards(lastClaim,eAmount,block.number,tknAmount,rate);\r\n\t\t}\r\n\t\tbool success = I(0x3E6AE87673424B1a1111E7F8180294B57be36476).getRewards(a, toClaim); require(success == true);\r\n\t}\r\n\r\n\tfunction _getRate() internal view returns(uint){uint rate = 84e15; uint halver = block.number/1e7;if (halver>1) {for (uint i=1;i<halver;i++) {rate=rate*3/4;}}return rate;}\r\n\r\n\tfunction _computeRewards(uint eBlock, uint eAmount, uint eEnd, uint tknAmount, uint rate) internal view returns(uint){\r\n\t\tif(eEnd==0){eEnd = block.number;} uint blocks = eEnd - eBlock; return (blocks*tknAmount*rate/eAmount);\r\n\t}\r\n\r\n// this function has to be expensive as an alert of something fishy just in case\r\n// metamask has to somehow provide more info about a transaction\r\n/*\tfunction newAddress(address a) public {\r\n\t\trequire(_takenNew[a] == false && _ps[a].lpShare == 0 && _ls[a].amount == 0);\r\n\t\tif(_ps[msg.sender].lockedAmount>0||_ls[msg.sender].amount>0){require(_isContract(msg.sender) == false);}\r\n\t\t_takenNew[a] = true;\r\n\t\tnewAddresses[msg.sender] = a;\r\n\t}\r\n// nobody should trust dapp interface. maybe a function like this should not be provided through dapp at all\r\n\tfunction changeAddress(address ad) public { // while user can confirm newAddress by public method, still has to enter the same address second time\r\n\t\taddress S = msg.sender;\taddress a = newAddresses[S];\r\n\t\trequire(a != address(0) && a == ad && a != msg.sender && block.number - 172800 > I(0xaE9564269B75f67510Bf20a512632869e3d42217).getLastVoted(S));\r\n\t\tif (_ps[S].lpShare > 0) {\r\n\t\t\t_ps[a].lastClaim = _ps[S].lastClaim;_ps[a].lastEpoch = _ps[S].lastEpoch;_ps[a].founder = _ps[S].founder;_ps[a].tknAmount = _ps[S].tknAmount;\r\n\t\t\t_ps[a].lpShare = _ps[S].lpShare;_ps[a].lockUpTo = _ps[S].lockUpTo;_ps[a].lockedAmount = _ps[S].lockedAmount;delete _ps[S];\r\n\t\t}\r\n\t\tif (_ls[S].amount > 0) {_ls[a].amount=_ls[S].amount;_ls[a].lockUpTo=_ls[S].lockUpTo;delete _ls[S];}\r\n\t}*/\r\n\r\n\tfunction lockFor6Months(bool ok, address tkn, uint amount) public {\r\n\t\trequire(ok==true && amount>0);\r\n\t\tif(tkn ==_tokenETHLP) {\r\n\t\t\trequire(_ps[msg.sender].lpShare-_ps[msg.sender].lockedAmount>=amount); _ps[msg.sender].lockUpTo=uint128(block.number+1e6);_ps[msg.sender].lockedAmount+=uint128(amount);\t\r\n\t\t}\r\n\t\tif(tkn == 0x1565616E3994353482Eb032f7583469F5e0bcBEC) {\r\n\t\t\trequire(I(tkn).balanceOf(msg.sender)>=amount);\r\n\t\t\t_ls[msg.sender].lockUpTo=uint128(block.number+1e6);\r\n\t\t\t_ls[msg.sender].amount+=uint128(amount);\r\n\t\t\tI(tkn).transferFrom(msg.sender,address(this),amount);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction unlock() public {\r\n\t\tif (_ps[msg.sender].lockedAmount > 0 && block.number>=_ps[msg.sender].lockUpTo) {_ps[msg.sender].lockedAmount = 0;}\r\n\t\tuint amount = _ls[msg.sender].amount;\r\n\t\tif (amount > 0 && block.number>=_ls[msg.sender].lockUpTo) {I(0x1565616E3994353482Eb032f7583469F5e0bcBEC).transfer(msg.sender,amount);_ls[msg.sender].amount = 0;}\r\n\t}\r\n\r\n\tfunction stake(uint amount) public {\r\n\t\taddress tkn = _tokenETHLP;\r\n\t\tuint length = _epochs.length;\r\n\t\tuint lastClaim = _ps[msg.sender].lastClaim;\r\n\t\trequire(_ps[msg.sender].founder==false && I(tkn).balanceOf(msg.sender)>=amount);\r\n\t\tI(tkn).transferFrom(msg.sender,address(this),amount);\r\n\t\tif(lastClaim==0){_ps[msg.sender].lastClaim = uint32(block.number);}\r\n\t\telse if (lastClaim != block.number) {_getRewards(msg.sender);}\r\n\t\tbytes32 epoch = _epochs[length-1];\r\n\t\t(uint80 eBlock,uint96 eAmount,) = _extractEpoch(epoch);\r\n\t\teAmount += uint96(amount);\r\n\t\t_storeEpoch(eBlock,eAmount,false,length);\r\n\t\t_ps[msg.sender].lastEpoch = uint16(_epochs.length);\r\n\t\tuint genLPtokens = _genLPtokens*1e10;\r\n\t\tgenLPtokens += amount;\r\n\t\t_genLPtokens = uint88(genLPtokens/1e10);\r\n\t\tuint share = amount*I(0x1565616E3994353482Eb032f7583469F5e0bcBEC).balanceOf(tkn)/genLPtokens;\r\n\t\t_ps[msg.sender].tknAmount += uint128(share);\r\n\t\t_ps[msg.sender].lpShare += uint128(amount);\r\n\t}\r\n\r\n\tfunction _extractEpoch(bytes32 epoch) internal pure returns (uint80,uint96,uint80){\r\n\t\tuint80 eBlock = uint80(bytes10(epoch));\r\n\t\tuint96 eAmount = uint96(bytes12(epoch << 80));\r\n\t\tuint80 eEnd = uint80(bytes10(epoch << 176));\r\n\t\treturn (eBlock,eAmount,eEnd);\r\n\t}\r\n \r\n\tfunction _storeEpoch(uint80 eBlock, uint96 eAmount, bool founder, uint length) internal {\r\n\t\tuint eEnd;\r\n\t\tif(block.number-80640>eBlock){eEnd = block.number-1;}// so an epoch can be bigger than 2 weeks, it's normal behavior and even desirable\r\n\t\tbytes memory by = abi.encodePacked(eBlock,eAmount,uint80(eEnd));\r\n\t\tbytes32 epoch; assembly {epoch := mload(add(by, 32))}\r\n\t\tif (founder) {_founderEpochs[length-1] = epoch;} else {_epochs[length-1] = epoch;}\r\n\t\tif (eEnd>0) {_createEpoch(eAmount,founder);}\r\n\t}\r\n\r\n\tfunction _createEpoch(uint amount, bool founder) internal {\r\n\t\tbytes memory by = abi.encodePacked(uint80(block.number),uint96(amount),uint80(0));\r\n\t\tbytes32 epoch; assembly {epoch := mload(add(by, 32))}\r\n\t\tif (founder == true){_founderEpochs.push(epoch);} else {_epochs.push(epoch);}\r\n\t}\r\n\r\n/*\tfunction migrate(address contr,address tkn,uint amount) public lock {//can support any amount of bridges\r\n\t\tif (tkn == _tokenETHLP) {\r\n\t\t\t(uint lastClaim,bool status,uint tknAmount,uint lpShare,uint lockedAmount) = getProvider(msg.sender);\r\n\t\t\tif (lastClaim != block.number) {_getRewards(msg.sender);}\r\n\t\t\trequire(lpShare-lockedAmount >= amount);\r\n\t\t\t_ps[msg.sender].lpShare = uint128(lpShare - amount);\r\n\t\t\tuint toSubtract = amount*tknAmount/lpShare;\r\n\t\t\t_ps[msg.sender].tknAmount = uint128(tknAmount-toSubtract);\r\n\t\t\tuint length; bytes32 epoch;\r\n\t\t\tif (status == true){length = _founderEpochs.length; epoch = _founderEpochs[length-1];}\r\n\t\t\telse{length = _epochs.length; epoch = _epochs[length-1]; _genLPtokens -= uint88(amount/1e10);}\r\n\t\t\t(uint80 eBlock, uint96 eAmount,) = _extractEpoch(epoch);\r\n\t\t\teAmount -= uint96(toSubtract);\r\n\t\t\t_storeEpoch(eBlock,eAmount,status,length);\r\n\t\t\tI(tkn).transfer(contr, amount);\r\n\t\t\tI(contr).provider(msg.sender,amount,_ps[msg.sender].lastClaim,_ps[msg.sender].lastEpoch,toSubtract,status);\r\n\t\t}\r\n\t\tif (tkn == 0x1565616E3994353482Eb032f7583469F5e0bcBEC) {\r\n\t\t\tuint lockedAmount = _ls[msg.sender].amount;\r\n\t\t\trequire(lockedAmount >= amount);\r\n\t\t\tI(tkn).transfer(contr, amount);\r\n\t\t\t_ls[msg.sender].amount = uint128(lockedAmount-amount);\r\n\t\t\tI(contr).locker(msg.sender,amount,_ls[msg.sender].lockUpTo);\r\n\t\t}\r\n\t}*/\r\n// VIEW FUNCTIONS ==================================================\r\n\tfunction getVoter(address a) external view returns (uint128,uint128,uint128,uint128,uint128,uint128) {\r\n\t\treturn (_ps[a].tknAmount,_ps[a].lpShare,_ps[a].lockedAmount,_ps[a].lockUpTo,_ls[a].amount,_ls[a].lockUpTo);\r\n\t}\r\n\r\n\tfunction getProvider(address a)public view returns(uint,bool,uint,uint,uint){return(_ps[a].lastClaim,_ps[a].founder,_ps[a].tknAmount,_ps[a].lpShare,_ps[a].lockedAmount);}\r\n}","ABI":"[{\"inputs\":[],\"name\":\"claimFounderStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"getProvider\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"getVoter\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"foundingETH\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tkn\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"ok\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"tkn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"lockFor6Months\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"ok\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unstakeLp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"StakingContract","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://559c6a66014221f85d34f83fd1866a9809cf564ed40944b2c905d4fb27f9804e"}]}