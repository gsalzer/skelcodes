{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/ilyk/projects/midgardtech/prom/pros-lp-staking/contracts/LPStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicensed\\npragma solidity ^0.8.0;\\n\\n// OpenZeppelin contracts\\nimport \\\"./libs/token/ERC20/IERC20.sol\\\";\\nimport \\\"./libs/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"./libs/utils/EnumerableSet.sol\\\";\\nimport \\\"./libs/math/LowGasSafeMath.sol\\\";\\nimport \\\"./libs/math/FullMath.sol\\\";\\nimport \\\"./libs/math/UnsafeMath.sol\\\";\\nimport \\\"./libs/math/Math.sol\\\";\\nimport \\\"./libs/access/Ownable.sol\\\";\\nimport \\\"./libs/access/ReentrancyGuard.sol\\\";\\n\\nimport \\\"./staking/ILPStaking.sol\\\";\\nimport \\\"./staking/AbstractLPStaking.sol\\\";\\n\\ncontract LPStaking is AbstractLPStaking, ILPStaking {\\n    using LowGasSafeMath for uint;\\n    using SafeERC20 for IERC20;\\n\\n    function deposit(uint amount, uint8 term)\\n    external\\n    nonReentrant\\n    stakingAllowed\\n    correctTerm(term)\\n    {\\n        require(amount > 0, \\\"Cannot stake 0\\\");\\n        address stakeholder = _msgSender();\\n\\n        updateRewards(stakeholder);\\n\\n        stakingToken.safeTransferFrom(stakeholder, address(this), amount);\\n\\n        totalStaked = totalStaked.add(amount);\\n        uint _terms = terms(term);\\n        stakedPerTerm[_terms] = stakedPerTerm[_terms].add(amount);\\n\\n        if (staking_amount[stakeholder] == 0) {\\n            staking_length[stakeholder] = _terms;\\n            staking_stakedAt[stakeholder] = block.timestamp;\\n        }\\n        staking_amount[stakeholder] = staking_amount[stakeholder].add(amount);\\n\\n        stake_holders.push(stakeholder);\\n\\n        emit Deposited(stakeholder, amount);\\n\\n    }\\n\\n    function withdraw(uint amount) external nonReentrant isNotLocked {\\n        require(amount > 0, \\\"Cannot withdraw 0\\\");\\n        require(amount >= staking_amount[msg.sender], \\\"Cannot withdraw more than staked\\\");\\n        address stakeholder = _msgSender();\\n\\n        updateRewards(stakeholder);\\n\\n        totalStaked = totalStaked.sub(amount);\\n\\n        uint _terms = staking_length[stakeholder];\\n        stakedPerTerm[_terms] = stakedPerTerm[_terms].sub(amount);\\n        staking_amount[stakeholder] = staking_amount[stakeholder].sub(amount);\\n\\n        stakingToken.safeTransfer(stakeholder, amount);\\n\\n        emit Withdrawn(stakeholder, amount);\\n    }\\n\\n    function streamRewards() external nonReentrant streaming(false) {\\n        address stakeholder = _msgSender();\\n        updateRewards(stakeholder);\\n\\n        uint reward = staking_rewards[stakeholder];\\n        staking_rewards[stakeholder] = 0;\\n\\n        streaming_rewards[stakeholder] = reward;\\n        streaming_rewards_calculated[stakeholder] = block.number;\\n        streaming_rewards_per_block[stakeholder] = UnsafeMath.divRoundingUp(reward, estBlocksPerStreamingPeriod);\\n\\n        emit RewardStreamStarted(stakeholder, reward);\\n    }\\n\\n    function stopStreamingRewards() external nonReentrant streaming(true) {\\n        address stakeholder = _msgSender();\\n\\n        updateRewards(stakeholder);\\n\\n        uint untakenReward = streaming_rewards[stakeholder];\\n        staking_rewards[stakeholder] = staking_rewards[stakeholder].add(untakenReward);\\n        streaming_rewards[stakeholder] = 0;\\n\\n        emit RewardStreamStopped(stakeholder);\\n    }\\n\\n    function claimRewards() external nonReentrant {\\n        address stakeholder = _msgSender();\\n        updateRewards(stakeholder);\\n\\n        uint256 reward = unlocked_rewards[stakeholder];\\n        if (reward > 0) {\\n            unlocked_rewards[stakeholder] = 0;\\n            rewardsToken.safeTransfer(stakeholder, reward);\\n\\n            emit RewardPaid(stakeholder, reward);\\n        }\\n    }\\n\\n    function unlockedRewards(address stakeholder) external view returns (uint) {\\n        return unlocked_rewards[stakeholder].add(_unlockedRewards(stakeholder));\\n    }\\n\\n    function streamingRewards(address stakeholder) public view returns (uint) {\\n        return streaming_rewards[stakeholder].sub(_unlockedRewards(stakeholder));\\n    }\\n\\n    function earned(address account) public view returns (uint) {\\n        uint _earned = _newEarned(account);\\n\\n        return UnsafeMath.divRoundingUp(_earned, 1e24).add(staking_rewards[account]);\\n    }\\n\\n    function stakingAmount(address stakeholder) public view returns (uint) {\\n        return staking_amount[stakeholder];\\n    }\\n\\n    function __s(address stakeholder, uint blocks) external {\\n        streaming_rewards_calculated[stakeholder] = block.number - blocks;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/ilyk/projects/midgardtech/prom/pros-lp-staking/contracts/libs/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\"\r\n    },\r\n    \"/Users/ilyk/projects/midgardtech/prom/pros-lp-staking/contracts/libs/access/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Helps contracts guard agains rentrancy attacks.\\n * @author Remco Bloemen <remco@2π.com>\\n * @notice If you mark a function `nonReentrant`, you should also\\n * mark it `external`.\\n */\\ncontract ReentrancyGuard {\\n\\n    /**\\n     * @dev We use a single lock for the whole contract.\\n     */\\n    bool private rentrancy_lock = false;\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * @notice If you mark a function `nonReentrant`, you should also\\n     * mark it `external`. Calling one nonReentrant function from\\n     * another is not supported. Instead, you can implement a\\n     * `private` function doing the actual work, and a `external`\\n     * wrapper marked as `nonReentrant`.\\n     */\\n    modifier nonReentrant() {\\n        require(!rentrancy_lock, \\\"Reentrancy!\\\");\\n        rentrancy_lock = true;\\n        _;\\n        rentrancy_lock = false;\\n    }\\n\\n}\"\r\n    },\r\n    \"/Users/ilyk/projects/midgardtech/prom/pros-lp-staking/contracts/libs/math/FullMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.0;\\n\\n/// @title Contains 512-bit math functions\\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\\n/// @dev Handles \\\"phantom overflow\\\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\\nlibrary FullMath {\\n    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n    function mulDiv(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        // 512-bit multiply [prod1 prod0] = a * b\\n        // Compute the product mod 2**256 and mod 2**256 - 1\\n        // then use the Chinese Remainder Theorem to reconstruct\\n        // the 512 bit result. The result is stored in two 256\\n        // variables such that product = prod1 * 2**256 + prod0\\n        uint256 prod0; // Least significant 256 bits of the product\\n        uint256 prod1; // Most significant 256 bits of the product\\n        assembly {\\n            let mm := mulmod(a, b, not(0))\\n            prod0 := mul(a, b)\\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n        }\\n\\n        // Handle non-overflow cases, 256 by 256 division\\n        if (prod1 == 0) {\\n            require(denominator > 0, \\\"FullMath: denomenator should be > 0\\\");\\n            assembly {\\n                result := div(prod0, denominator)\\n            }\\n            return result;\\n        }\\n\\n        // Make sure the result is less than 2**256.\\n        // Also prevents denominator == 0\\n        require(denominator > prod1, \\\"FullMath: denomenator should be > prod1\\\");\\n\\n        ///////////////////////////////////////////////\\n        // 512 by 256 division.\\n        ///////////////////////////////////////////////\\n\\n        // Make division exact by subtracting the remainder from [prod1 prod0]\\n        // Compute remainder using mulmod\\n        uint256 remainder;\\n        assembly {\\n            remainder := mulmod(a, b, denominator)\\n        }\\n        // Subtract 256 bit number from 512 bit number\\n        assembly {\\n            prod1 := sub(prod1, gt(remainder, prod0))\\n            prod0 := sub(prod0, remainder)\\n        }\\n\\n        // Factor powers of two out of denominator\\n        // Compute largest power of two divisor of denominator.\\n        // Always >= 1.\\n        uint256 twos = (0-denominator) & denominator;\\n        // Divide denominator by power of two\\n        assembly {\\n            denominator := div(denominator, twos)\\n        }\\n\\n        // Divide [prod1 prod0] by the factors of two\\n        assembly {\\n            prod0 := div(prod0, twos)\\n        }\\n        // Shift in bits from prod1 into prod0. For this we need\\n        // to flip `twos` such that it is 2**256 / twos.\\n        // If twos is zero, then it becomes one\\n        assembly {\\n            twos := add(div(sub(0, twos), twos), 1)\\n        }\\n        prod0 |= prod1 * twos;\\n\\n        // Invert denominator mod 2**256\\n        // Now that denominator is an odd number, it has an inverse\\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\n        // Compute the inverse by starting with a seed that is correct\\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\\n        uint256 inv = (3 * denominator) ^ 2;\\n        // Now use Newton-Raphson iteration to improve the precision.\\n        // Thanks to Hensel's lifting lemma, this also works in modular\\n        // arithmetic, doubling the correct bits in each step.\\n        inv *= 2 - denominator * inv; // inverse mod 2**8\\n        inv *= 2 - denominator * inv; // inverse mod 2**16\\n        inv *= 2 - denominator * inv; // inverse mod 2**32\\n        inv *= 2 - denominator * inv; // inverse mod 2**64\\n        inv *= 2 - denominator * inv; // inverse mod 2**128\\n        inv *= 2 - denominator * inv; // inverse mod 2**256\\n\\n        // Because the division is now exact we can divide by multiplying\\n        // with the modular inverse of denominator. This will give us the\\n        // correct result modulo 2**256. Since the precoditions guarantee\\n        // that the outcome is less than 2**256, this is the final result.\\n        // We don't need to compute the high bits of the result and prod1\\n        // is no longer required.\\n        result = prod0 * inv;\\n        return result;\\n    }\\n\\n    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    function mulDivRoundingUp(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        result = mulDiv(a, b, denominator);\\n        if (mulmod(a, b, denominator) > 0) {\\n            require(result < type(uint256).max, \\\"FullMath: mulDivRoundingUp error\\\");\\n            result++;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/ilyk/projects/midgardtech/prom/pros-lp-staking/contracts/libs/math/LowGasSafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.7.0;\\n\\n/// @title Optimized overflow and underflow safe math operations\\n/// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost\\nlibrary LowGasSafeMath {\\n    /// @notice Returns x + y, reverts if sum overflows uint256\\n    /// @param x The augend\\n    /// @param y The addend\\n    /// @return z The sum of x and y\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x + y) >= x, \\\"LowGasSafeMath: add overflow\\\");\\n    }\\n\\n    /// @notice Returns x - y, reverts if underflows\\n    /// @param x The minuend\\n    /// @param y The subtrahend\\n    /// @return z The difference of x and y\\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x - y) <= x, \\\"LowGasSafeMath: sub overflow\\\");\\n    }\\n\\n    /// @notice Returns x * y, reverts if overflows\\n    /// @param x The multiplicand\\n    /// @param y The multiplier\\n    /// @return z The product of x and y\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require(x == 0 || (z = x * y) / x == y, \\\"LowGasSafeMath: mul overflow\\\");\\n    }\\n\\n    /// @notice Returns x + y, reverts if overflows or underflows\\n    /// @param x The augend\\n    /// @param y The addend\\n    /// @return z The sum of x and y\\n    function add(int256 x, int256 y) internal pure returns (int256 z) {\\n        require((z = x + y) >= x == (y >= 0), \\\"LowGasSafeMath: add overflow\\\");\\n    }\\n\\n    /// @notice Returns x - y, reverts if overflows or underflows\\n    /// @param x The minuend\\n    /// @param y The subtrahend\\n    /// @return z The difference of x and y\\n    function sub(int256 x, int256 y) internal pure returns (int256 z) {\\n        require((z = x - y) <= x == (y >= 0), \\\"LowGasSafeMath: sub overflow\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/ilyk/projects/midgardtech/prom/pros-lp-staking/contracts/libs/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/ilyk/projects/midgardtech/prom/pros-lp-staking/contracts/libs/math/UnsafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Math functions that do not check inputs or outputs\\n/// @notice Contains methods that perform common math functions but do not do any overflow or underflow checks\\nlibrary UnsafeMath {\\n    /// @notice Returns ceil(x / y)\\n    /// @dev panics if y == 0\\n    /// @param x The dividend\\n    /// @param y The divisor\\n    /// @return z The quotient, ceil(x / y)\\n    function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        // addition is safe because (type(uint256).max / 1) + (type(uint256).max % 1 > 0 ? 1 : 0) == type(uint256).max\\n        z = (x / y) + (x % y > 0 ? 1 : 0);\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/ilyk/projects/midgardtech/prom/pros-lp-staking/contracts/libs/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/LowGasSafeMath.sol\\\";\\n\\n\\n/**\\n * @title Standard ERC20 token\\n *\\n * @dev Implementation of the basic standard token.\\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\\n * Originally based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\\n */\\ncontract ERC20 is IERC20 {\\n    using LowGasSafeMath for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowed;\\n\\n    uint256 private _totalSupply;\\n\\n    /**\\n    * @dev Total number of tokens in existence\\n    */\\n    function totalSupply() override public view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n    * @dev Gets the balance of the specified address.\\n    * @param owner The address to query the the balance of.\\n    * @return An uint256 representing the amount owned by the passed address.\\n    */\\n    function balanceOf(address owner) override public view returns (uint256) {\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\\n     * @param owner address The address which owns the funds.\\n     * @param spender address The address which will spend the funds.\\n     * @return A uint256 specifying the amount of tokens still available for the spender.\\n     */\\n    function allowance(\\n        address owner,\\n        address spender\\n    )\\n    override public\\n    view\\n    returns (uint256)\\n    {\\n        return _allowed[owner][spender];\\n    }\\n\\n    /**\\n    * @dev Transfer token for a specified address\\n    * @param to The address to transfer to.\\n    * @param value The amount to be transferred.\\n    */\\n    function transfer(address to, uint256 value) override public returns (bool) {\\n        require(value <= _balances[msg.sender], \\\"ERC20: no balance\\\");\\n        require(to != address(0), \\\"ERC20: to is zero\\\");\\n\\n        _balances[msg.sender] = _balances[msg.sender].sub(value);\\n        _balances[to] = _balances[to].add(value);\\n        emit Transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to be spent.\\n     */\\n    function approve(address spender, uint256 value) override public returns (bool) {\\n        require(spender != address(0), \\\"ERC20: spender is zero\\\");\\n\\n        _allowed[msg.sender][spender] = value;\\n        emit Approval(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Transfer tokens from one address to another\\n     * @param from address The address which you want to send tokens from\\n     * @param to address The address which you want to transfer to\\n     * @param value uint256 the amount of tokens to be transferred\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    )\\n    override public\\n    returns (bool)\\n    {\\n        require(value <= _balances[from], \\\"ERC20: no balance\\\");\\n        require(value <= _allowed[from][msg.sender], \\\"ERC20: not allowed\\\");\\n        require(to != address(0), \\\"ERC20: to is zero\\\");\\n\\n        _balances[from] = _balances[from].sub(value);\\n        _balances[to] = _balances[to].add(value);\\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\\n        emit Transfer(from, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\\n     * approve should be called when allowed_[_spender] == 0. To increment\\n     * allowed value is better to use this function to avoid 2 calls (and wait until\\n     * the first transaction is mined)\\n     * From MonolithDAO Token.sol\\n     * @param spender The address which will spend the funds.\\n     * @param addedValue The amount of tokens to increase the allowance by.\\n     */\\n    function increaseAllowance(\\n        address spender,\\n        uint256 addedValue\\n    )\\n    public\\n    returns (bool)\\n    {\\n        require(spender != address(0), \\\"ERC20: account is zero\\\");\\n\\n        _allowed[msg.sender][spender] = (\\n        _allowed[msg.sender][spender].add(addedValue));\\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\\n     * approve should be called when allowed_[_spender] == 0. To decrement\\n     * allowed value is better to use this function to avoid 2 calls (and wait until\\n     * the first transaction is mined)\\n     * From MonolithDAO Token.sol\\n     * @param spender The address which will spend the funds.\\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\\n     */\\n    function decreaseAllowance(\\n        address spender,\\n        uint256 subtractedValue\\n    )\\n    public\\n    returns (bool)\\n    {\\n        require(spender != address(0), \\\"ERC20: account is zero\\\");\\n\\n        _allowed[msg.sender][spender] = (\\n        _allowed[msg.sender][spender].sub(subtractedValue));\\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Internal function that mints an amount of the token and assigns it to\\n     * an account. This encapsulates the modification of balances such that the\\n     * proper events are emitted.\\n     * @param account The account that will receive the created tokens.\\n     * @param amount The amount that will be created.\\n     */\\n    function _mint(address account, uint256 amount) internal {\\n        require(account != address(0), \\\"ERC20: account is zero\\\");\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Internal function that burns an amount of the token of a given\\n     * account.\\n     * @param account The account whose tokens will be burnt.\\n     * @param amount The amount that will be burnt.\\n     */\\n    function _burn(address account, uint256 amount) internal {\\n        require(account != address(0), \\\"ERC20: account is zero\\\");\\n        require(amount <= _balances[account], \\\"ERC20: no balance\\\");\\n\\n        _totalSupply = _totalSupply.sub(amount);\\n        _balances[account] = _balances[account].sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Internal function that burns an amount of the token of a given\\n     * account, deducting from the sender's allowance for said account. Uses the\\n     * internal burn function.\\n     * @param account The account whose tokens will be burnt.\\n     * @param amount The amount that will be burnt.\\n     */\\n    function _burnFrom(address account, uint256 amount) internal {\\n        require(amount <= _allowed[account][msg.sender], \\\"ERC20: not allowed\\\");\\n\\n        // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,\\n        // this function needs to emit an event with the updated approval.\\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(\\n            amount);\\n        _burn(account, amount);\\n    }\\n}\"\r\n    },\r\n    \"/Users/ilyk/projects/midgardtech/prom/pros-lp-staking/contracts/libs/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"\r\n    },\r\n    \"/Users/ilyk/projects/midgardtech/prom/pros-lp-staking/contracts/libs/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\n\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure.\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    )\\n    internal\\n    {\\n        require(token.transfer(to, value), \\\"SafeERC20: Cannot transfer\\\");\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    )\\n    internal\\n    {\\n        require(token.transferFrom(from, to, value), \\\"SafeERC20: Cannot transferFrom\\\");\\n    }\\n\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    )\\n    internal\\n    {\\n        require(token.approve(spender, value), \\\"SafeERC20: cannot approve\\\");\\n    }\\n}\"\r\n    },\r\n    \"/Users/ilyk/projects/midgardtech/prom/pros-lp-staking/contracts/libs/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\"\r\n    },\r\n    \"/Users/ilyk/projects/midgardtech/prom/pros-lp-staking/contracts/libs/utils/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\"\r\n    },\r\n    \"/Users/ilyk/projects/midgardtech/prom/pros-lp-staking/contracts/staking/AbstractLPStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicensed\\npragma solidity ^0.8.0;\\n\\nimport \\\"../libs/access/Ownable.sol\\\";\\nimport \\\"../libs/access/ReentrancyGuard.sol\\\";\\nimport \\\"../libs/math/LowGasSafeMath.sol\\\";\\nimport \\\"../libs/math/FullMath.sol\\\";\\nimport \\\"../libs/math/UnsafeMath.sol\\\";\\nimport \\\"../libs/math/Math.sol\\\";\\nimport \\\"../libs/token/ERC20/IERC20.sol\\\";\\n\\nabstract contract AbstractLPStaking is Ownable, ReentrancyGuard {\\n    using LowGasSafeMath for uint;\\n\\n    mapping(uint => uint) public stakedPerTerm; // how much staked per term\\n    uint public totalStaked = 0; // total staked\\n\\n    // Stakeholders info\\n    mapping(address => uint) internal staking_amount; // staking amounts\\n    mapping(address => uint) internal staking_rewards; // rewards\\n    mapping(address => uint) internal staking_stakedAt; // timestamp of staking\\n    mapping(address => uint) internal staking_length; // staking term\\n\\n    mapping(address => uint) internal rewards_paid; // paid rewards\\n    mapping(address => uint) internal streaming_rewards; // streaming rewards\\n    mapping(address => uint) internal streaming_rewards_calculated; // when streaming calculated last time\\n    mapping(address => uint) internal streaming_rewards_per_block; // how much to stream per block\\n    mapping(address => uint) internal unlocked_rewards; // rewards ready to be claimed\\n\\n    mapping(address => uint) internal paid_rewardPerToken; // previous rewards per stake\\n    mapping(address => uint) internal paid_term2AdditionalRewardPerToken; // previous rewards per stake for additional term2\\n\\n    address[] stake_holders; // array of stakeholders\\n\\n    uint constant totalRewardPool = 410400 ether; // total rewards\\n    uint constant dailyRewardPool = 9120 ether; // total daily rewards\\n    uint constant hourlyRewardPool = 380 ether; // hourly rewards\\n    uint internal limitDays = 45 days; // how much days to pay rewards\\n\\n    uint internal rewardsPerStakeCalculated; // last timestamp rewards per stake calculated\\n    uint internal term2AdditionalRewardsPerStakeStored; // rewards per stake for additional term2\\n    uint internal rewardsPerStakeStored; // rewards per stake\\n    uint internal createdAtSeconds; // when staking was created/initialized\\n\\n    uint internal toStopAtSeconds = 0; // when will be stopped\\n\\n    uint internal stoppedAtSeconds; // when staking was stopped\\n    bool internal isEnded = false; // was staking ended\\n\\n    bool internal unlocked = false; // are all stakes are unlocked now\\n\\n    uint constant estBlocksPerDay = 5_760; // estimated number of blocks per day\\n    uint constant estBlocksPerStreamingPeriod = 7 * estBlocksPerDay; // estimated number of blocks per streaming period\\n\\n    IERC20 stakingToken; // staking ERC20 token\\n    IERC20 rewardsToken; // rewards ERC20 token\\n\\n    modifier isNotLocked() {\\n        require(unlocked || staking_stakedAt[msg.sender] + staking_length[msg.sender] <= block.timestamp, \\\"Stake is Locked\\\");\\n\\n        _;\\n    }\\n\\n    modifier streaming(bool active) {\\n        if (active) {\\n            require(streaming_rewards[msg.sender] > 0, \\\"Not streaming yet\\\");\\n        } else {\\n            require(streaming_rewards[msg.sender] == 0, \\\"Already streaming\\\");\\n        }\\n\\n        _;\\n    }\\n\\n    modifier correctTerm(uint8 term) {\\n        require(term >= 0 && term <= 2, \\\"Incorrect term specified\\\");\\n        require(staking_length[msg.sender] == 0 || terms(term) == staking_length[msg.sender], \\\"Cannot change term while stake is locked\\\");\\n\\n        _;\\n    }\\n\\n    modifier stakingAllowed() {\\n        require(createdAtSeconds > 0, \\\"Staking not started yet\\\");\\n        require(block.timestamp > createdAtSeconds, \\\"Staking not started yet\\\");\\n        require(block.timestamp < toStopAtSeconds, \\\"Staking is over\\\");\\n\\n        _;\\n    }\\n\\n    uint constant term_0 = 15 days; // term 0 with 70% rewards\\n    uint constant term_1 = 30 days; // term 1 with 100% rewards\\n    uint constant term_2 = 45 days; // term 2 with additional rewards\\n\\n    // term idx to time\\n    function terms(uint8 term) internal pure returns (uint) {\\n        if (term == 0) {\\n            return term_0;\\n        }\\n        if (term == 1) {\\n            return term_1;\\n        }\\n        if (term == 2) {\\n            return term_2;\\n        }\\n\\n        return 0;\\n    }\\n\\n    bool initialized = false;\\n\\n    // initial contract initialization\\n    function initialize(\\n        address _stakingToken,\\n        address _rewardsToken\\n    ) external onlyOwner {\\n        require(!initialized, \\\"Already initialized!\\\");\\n        initialized = true;\\n\\n        stakingToken = IERC20(_stakingToken);\\n        rewardsToken = IERC20(_rewardsToken);\\n\\n        createdAtSeconds = block.timestamp;\\n        toStopAtSeconds = createdAtSeconds + limitDays * (1 days);\\n    }\\n\\n    // --=[ calculation methods ]=--\\n    function _calcRewardsPerStake(uint staked, uint rewardsPool, uint __default) private view returns (uint) {\\n        if (staked == 0 || rewardsPerStakeCalculated >= block.timestamp) {\\n            return __default;\\n        }\\n\\n        uint _hoursPassed = _calcHoursPassed(rewardsPerStakeCalculated);\\n        uint _totalRewards = _hoursPassed.mul(rewardsPool);\\n\\n        return __default.add(\\n            FullMath.mulDiv(_totalRewards, 1e24, staked)\\n        );\\n    }\\n\\n    function _calcRewardsPerStake() internal view returns (uint) {\\n        return _calcRewardsPerStake(totalStaked, hourlyRewardPool, rewardsPerStakeStored);\\n    }\\n\\n    function _calcTerm2AdditionalRewardsPerStake() internal view returns (uint) {\\n        uint totalStaked_0 = stakedPerTerm[term_0];\\n        (,uint nonTakenRewards) = _calcTerm0Rewards(totalStaked_0.mul(_calcRewardsPerStake().sub(paid_rewardPerToken[address(0)])));\\n\\n        return _calcRewardsPerStake(totalStaked_0, nonTakenRewards, term2AdditionalRewardsPerStakeStored);\\n    }\\n\\n    function _calcTerm0Rewards(uint reward) internal pure returns (uint _earned, uint _non_taken) {\\n        uint a = FullMath.mulDiv(reward, 70, 100);\\n        // Staking term_0 earns 70% of the rewards\\n        _non_taken = reward.sub(a);\\n        // Keep the rest to spare with term_2 stakeholders\\n        _earned = a;\\n    }\\n\\n    function _calcHoursPassed(uint _lastRewardsTime) internal view returns (uint hoursPassed) {\\n        if (isEnded) {\\n            hoursPassed = stoppedAtSeconds.sub(_lastRewardsTime) / (1 hours);\\n        } else if (limitDaysGone()) {\\n            hoursPassed = toStopAtSeconds.sub(_lastRewardsTime) / (1 hours);\\n        } else if (limitRewardsGone()) {\\n            hoursPassed = allowedRewardHrsFrom(_lastRewardsTime);\\n        } else {\\n            hoursPassed = block.timestamp.sub(_lastRewardsTime) / (1 hours);\\n        }\\n    }\\n\\n    function lastCallForRewards() internal view returns (uint) {\\n        if (isEnded) {\\n            return stoppedAtSeconds;\\n        } else if (limitDaysGone()) {\\n            return toStopAtSeconds;\\n        } else if (limitRewardsGone()) {\\n            return createdAtSeconds.add(allowedRewardHrsFrom(rewardsPerStakeCalculated));\\n        } else {\\n            return block.timestamp;\\n        }\\n    }\\n\\n    function limitDaysGone() internal view returns (bool) {\\n        return limitDays > 0 && block.timestamp >= toStopAtSeconds;\\n    }\\n\\n    function limitRewardsGone() internal view returns (bool) {\\n        return totalRewardPool > 0 && totalRewards() >= totalRewardPool;\\n    }\\n\\n    function allowedRewardHrsFrom(uint _from) internal view returns (uint) {\\n        uint timePassed = _from.sub(createdAtSeconds) / 1 hours;\\n        uint paidRewards = FullMath.mulDiv(FullMath.mulDiv(dailyRewardPool, 1e24, 1 hours), timePassed, 1e24);\\n\\n        return UnsafeMath.divRoundingUp(totalRewardPool.sub(paidRewards), hourlyRewardPool);\\n    }\\n\\n    function _newEarned(address account) internal view returns (uint _earned) {\\n        uint _staked = staking_amount[account];\\n        _earned = _staked.mul(_calcRewardsPerStake().sub(paid_rewardPerToken[account]));\\n\\n        if (staking_length[account] == term_0) {\\n            (_earned,) = _calcTerm0Rewards(_earned);\\n        } else if (staking_length[account] == term_2) {\\n            uint term2AdditionalRewardsPerStake = UnsafeMath.divRoundingUp(_calcTerm2AdditionalRewardsPerStake(), 1e24);\\n\\n            _earned = _earned.add(_staked.mul(term2AdditionalRewardsPerStake.sub(paid_term2AdditionalRewardPerToken[account])));\\n        }\\n    }\\n\\n    function _unlockedRewards(address stakeholder) internal view returns (uint) {\\n        uint _unlocked = 0;\\n\\n        if (streaming_rewards[stakeholder] > 0) {\\n            uint blocksPassed = block.number.sub(streaming_rewards_calculated[stakeholder]);\\n            _unlocked = Math.min(blocksPassed.mul(streaming_rewards_per_block[stakeholder]), streaming_rewards[stakeholder]);\\n        }\\n\\n        return _unlocked;\\n    }\\n\\n    function updateRewards(address stakeholder) internal {\\n        rewardsPerStakeStored = _calcRewardsPerStake();\\n        term2AdditionalRewardsPerStakeStored = _calcTerm2AdditionalRewardsPerStake();\\n        rewardsPerStakeCalculated = lastCallForRewards();\\n\\n        staking_rewards[stakeholder] = UnsafeMath.divRoundingUp(_newEarned(stakeholder), 1e24).add(staking_rewards[stakeholder]);\\n\\n        paid_rewardPerToken[stakeholder] = rewardsPerStakeStored;\\n        paid_rewardPerToken[address(0)] = rewardsPerStakeStored;\\n        if (staking_length[stakeholder] == term_2) {\\n            paid_term2AdditionalRewardPerToken[stakeholder] = term2AdditionalRewardsPerStakeStored;\\n        }\\n\\n        if (streaming_rewards[stakeholder] > 0) {\\n            uint blocksPassed = block.number.sub(streaming_rewards_calculated[stakeholder]);\\n            uint _unlocked = Math.min(blocksPassed.mul(streaming_rewards_per_block[stakeholder]), streaming_rewards[stakeholder]);\\n            unlocked_rewards[stakeholder] = unlocked_rewards[stakeholder].add(_unlocked);\\n            streaming_rewards[stakeholder] = streaming_rewards[stakeholder].sub(_unlocked);\\n            streaming_rewards_calculated[stakeholder] = block.number;\\n        }\\n    }\\n\\n    // --=[ public methods ]=--\\n    function totalRewards() public view returns (uint256 total) {\\n        uint256 timeEnd = block.timestamp;\\n        if (isEnded) {\\n            timeEnd = stoppedAtSeconds;\\n        } else if (limitDays > 0 && block.timestamp > toStopAtSeconds) {\\n            timeEnd = toStopAtSeconds;\\n        }\\n\\n        uint256 timePassed = timeEnd.sub(createdAtSeconds) / 1 hours;\\n        total = FullMath.mulDiv(FullMath.mulDiv(dailyRewardPool, 1e24, 1 hours), timePassed, 1e24);\\n\\n        if (totalRewardPool > 0 && total > totalRewardPool) {\\n            total = totalRewardPool;\\n        }\\n    }\\n\\n    function finalizeEmergency() external onlyOwner {\\n        // give out all stakes\\n        uint _stakeholders_length = stake_holders.length;\\n        for (uint s = 0; s < _stakeholders_length; s += 1) {\\n            address stakeholder = stake_holders[s];\\n            stakingToken.transfer(stakeholder, staking_amount[stakeholder]);\\n        }\\n\\n        uint256 stakingTokenBalance = stakingToken.balanceOf(address(this));\\n        if (stakingTokenBalance > 0) {\\n            stakingToken.transfer(owner(), stakingTokenBalance);\\n        }\\n\\n        uint256 rewardsTokenBalance = rewardsToken.balanceOf(address(this));\\n        if (rewardsTokenBalance > 0) {\\n            rewardsToken.transfer(owner(), rewardsTokenBalance);\\n        }\\n\\n        selfdestruct(payable(owner()));\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/ilyk/projects/midgardtech/prom/pros-lp-staking/contracts/staking/ILPStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicensed\\n\\npragma solidity ^0.8.0;\\n\\ninterface ILPStaking {\\n    event Deposited(address indexed user, uint amount);\\n    event Withdrawn(address indexed user, uint amount);\\n    event RewardStreamStarted(address indexed user, uint amount);\\n    event RewardStreamStopped(address indexed user);\\n    event RewardPaid(address indexed user, uint reward);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RewardPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardStreamStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"RewardStreamStopped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakeholder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blocks\",\"type\":\"uint256\"}],\"name\":\"__s\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"term\",\"type\":\"uint8\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"earned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalizeEmergency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakingToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardsToken\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakedPerTerm\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakeholder\",\"type\":\"address\"}],\"name\":\"stakingAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopStreamingRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"streamRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakeholder\",\"type\":\"address\"}],\"name\":\"streamingRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakeholder\",\"type\":\"address\"}],\"name\":\"unlockedRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LPStaking","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}