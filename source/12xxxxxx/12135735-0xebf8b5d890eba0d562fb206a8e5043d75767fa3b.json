{"status":"1","message":"OK","result":[{"SourceCode":"// File: @openzeppelin/contracts/utils/Create2.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\r\n * `CREATE2` can be used to compute in advance the address where a smart\r\n * contract will be deployed, which allows for interesting new mechanisms known\r\n * as 'counterfactual interactions'.\r\n *\r\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\r\n * information.\r\n */\r\nlibrary Create2 {\r\n    /**\r\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\r\n     * will be deployed can be known in advance via {computeAddress}.\r\n     *\r\n     * The bytecode for a contract can be obtained from Solidity with\r\n     * `type(contractName).creationCode`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `bytecode` must not be empty.\r\n     * - `salt` must have not been used for `bytecode` already.\r\n     * - the factory must have a balance of at least `amount`.\r\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\r\n     */\r\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address) {\r\n        address addr;\r\n        require(address(this).balance >= amount, \"Create2: insufficient balance\");\r\n        require(bytecode.length != 0, \"Create2: bytecode length is zero\");\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\r\n        }\r\n        require(addr != address(0), \"Create2: Failed on deploy\");\r\n        return addr;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\r\n     * `bytecodeHash` or `salt` will result in a new destination address.\r\n     */\r\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\r\n        return computeAddress(salt, bytecodeHash, address(this));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\r\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\r\n     */\r\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address) {\r\n        bytes32 _data = keccak256(\r\n            abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash)\r\n        );\r\n        return address(uint160(uint256(_data)));\r\n    }\r\n}\r\n\r\n// File: contracts/helpers/MinimalProxyFactory.sol\r\n\r\npragma solidity 0.6.2;\r\n\r\n\r\ncontract MinimalProxyFactory {\r\n    event MinimalProxyCreated(address minimalProxy);\r\n\r\n    function computeAddress(uint256 salt, address implementation)\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        return\r\n            Create2.computeAddress(\r\n                keccak256(abi.encodePacked(salt)),\r\n                keccak256(getContractCreationCode(implementation)),\r\n                address(this)\r\n            );\r\n    }\r\n\r\n    function deploy(\r\n        uint256 salt,\r\n        address implementation\r\n    ) public returns(address) {\r\n        address minimalProxy = Create2.deploy(\r\n            0,\r\n            keccak256(abi.encodePacked(salt)),\r\n            getContractCreationCode(implementation)\r\n        );\r\n        emit MinimalProxyCreated(minimalProxy);\r\n        return minimalProxy;\r\n    }\r\n\r\n    function getContractCreationCode(address logic)\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        bytes10 creation = 0x3d602d80600a3d3981f3;\r\n        bytes10 prefix = 0x363d3d373d3d3d363d73;\r\n        bytes20 targetBytes = bytes20(logic);\r\n        bytes15 suffix = 0x5af43d82803e903d91602b57fd5bf3;\r\n        return abi.encodePacked(creation, prefix, targetBytes, suffix);\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"minimalProxy\",\"type\":\"address\"}],\"name\":\"MinimalProxyCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"computeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"deploy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MinimalProxyFactory","CompilerVersion":"v0.6.2+commit.bacdbe57","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://d2cfd8528d05ab17336d63ce6a47d6b94303ed74fcf66d8ed623f10f001da833"}]}