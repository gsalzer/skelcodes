{"status":"1","message":"OK","result":[{"SourceCode":"{\"Erc20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity \\u003e=0.7.0;\\r\\n\\r\\ninterface Erc20\\r\\n{\\r\\n    function symbol() view external returns (string memory _symbol);\\r\\n    function decimals() view external returns (uint8 _decimals);\\r\\n    \\r\\n    function balanceOf(address _owner) \\r\\n        view\\r\\n        external\\r\\n        returns (uint256 _balance);\\r\\n        \\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    function transfer(address _to, uint256 _amount) \\r\\n        external\\r\\n        returns (bool _success);\\r\\n    function transferFrom(address _from, address _to, uint256 _amount)\\r\\n        external\\r\\n        returns (bool _success);\\r\\n\\r\\n    function approve(address _spender, uint256 _amount) \\r\\n        external\\r\\n        returns (bool _success);\\r\\n}\"},\"EthToDaiFacilitator.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\n// This code is the property of the Aardbanq DAO.\\r\\n// The Aardbanq DAO is located at 0x829c094f5034099E91AB1d553828F8A765a3DaA1 on the Ethereum Main Net.\\r\\n// It is the author\\u0027s wish that this code should be open sourced under the MIT license, but the final \\r\\n// decision on this would be taken by the Aardbanq DAO with a vote once sufficient ABQ tokens have been \\r\\n// distributed.\\r\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\\r\\n\\r\\npragma solidity \\u003e=0.7.0;\\r\\nimport \\\"./SafeMathTyped.sol\\\";\\r\\nimport \\\"./ScaleBuying.sol\\\";\\r\\nimport \\u0027./InitialLiquidityOffering.sol\\u0027;\\r\\nimport \\\"./IUniswapV2Router02.sol\\\";\\r\\nimport \\\"./Erc20.sol\\\";\\r\\n\\r\\n/// @notice A contract to help convert ETH to DAI with uniswap, and then buy into the Aardbanq DAO ICO or ILO.\\r\\ncontract EthToDaiFacilitator\\r\\n{\\r\\n    IUniswapV2Router02 public immutable uniswapRouter;\\r\\n    Erc20 public immutable dai;\\r\\n    ScaleBuying public immutable ico;\\r\\n    InitialLiquidityOffering public immutable ilo;\\r\\n\\r\\n    /// @notice Construct a EthToDaiFacilitator.\\r\\n    /// @param _router The uniswap router to use.\\r\\n    /// @param _dai The DAI contract address.\\r\\n    /// @param _ico The Aardbanq DAO ICO.\\r\\n    /// @param _ilo The Aardbanq DAO ILO.\\r\\n    constructor(IUniswapV2Router02 _router, Erc20 _dai, ScaleBuying _ico, InitialLiquidityOffering _ilo)\\r\\n    {\\r\\n        uniswapRouter = _router;\\r\\n        dai = _dai;\\r\\n        ico = _ico;\\r\\n        ilo = _ilo;\\r\\n    }\\r\\n\\r\\n    /// @notice Converts the ETH sent into the function to DAI and buy into the Aardbanq DAO ICO.\\r\\n    /// @param _for The address that should be awarded the ABQ tokens.\\r\\n    function BuyInIco(address _for)\\r\\n        payable\\r\\n        external\\r\\n    {\\r\\n        // CG: Trade ETH for DAI via uniswap.\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = uniswapRouter.WETH();\\r\\n        path[1] =  address(dai);\\r\\n        uniswapRouter.swapExactETHForTokens{value: address(this).balance}(0, path, address(this), block.timestamp);\\r\\n\\r\\n        // CG: Buy in the ICO\\r\\n        uint256 paymentAmount = dai.balanceOf(address(this));\\r\\n        dai.approve(address(ico), paymentAmount);\\r\\n        uint256 paymentLeft = ico.buy(paymentAmount, _for);\\r\\n\\r\\n        // CG: if there is more than 10 DAI left send it back. If less than 10 DAI is left don\\u0027t sent it back, the gas cost will be more than returning the change costing the client.\\r\\n        if (paymentLeft \\u003e 10 ether)\\r\\n        {\\r\\n            bool isSuccess = dai.transfer(msg.sender, paymentLeft);\\r\\n            require(isSuccess, \\\"ABQICO/could-not-refund-change\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Converts the ETH sent into the function to DAI and buy into the Aardbanq DAO ILO.\\r\\n    /// @param _for The address that should be awarded the liquidity pool tokens and the ABQ reward tokens.\\r\\n    function BuyInIlo(address _for)\\r\\n        payable\\r\\n        external\\r\\n    {\\r\\n        // CG: Trade ETH for DAI via uniswap.\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = uniswapRouter.WETH();\\r\\n        path[1] =  address(dai);\\r\\n        uniswapRouter.swapExactETHForTokens{value: address(this).balance}(0, path, address(this), block.timestamp);\\r\\n\\r\\n        // CG: Buy in the ILO\\r\\n        uint256 paymentAmount = dai.balanceOf(address(this));\\r\\n        dai.approve(address(ilo), paymentAmount);\\r\\n        ilo.provideLiquidity(_for, paymentAmount);\\r\\n        uint256 paymentLeft = dai.balanceOf(address(this));\\r\\n\\r\\n        // CG: if there is more than 10 DAI left send it back. If less than 10 DAI is left don\\u0027t sent it back, the gas cost will be more than returning the change costing the client.\\r\\n        if (paymentLeft \\u003e 10 ether)\\r\\n        {\\r\\n            bool isSuccess = dai.transfer(msg.sender, paymentLeft);\\r\\n            require(isSuccess, \\\"ABQICO/could-not-refund-change\\\");\\r\\n        }\\r\\n    }\\r\\n}\"},\"ILiquidityEstablisher.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\n// This code is the property of the Aardbanq DAO.\\r\\n// The Aardbanq DAO is located at 0x829c094f5034099E91AB1d553828F8A765a3DaA1 on the Ethereum Main Net.\\r\\n// It is the author\\u0027s wish that this code should be open sourced under the MIT license, but the final \\r\\n// decision on this would be taken by the Aardbanq DAO with a vote once sufficient ABQ tokens have been \\r\\n// distributed.\\r\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\\r\\npragma solidity \\u003e=0.7.0;\\r\\n\\r\\ninterface ILiquidityEstablisher\\r\\n{\\r\\n    function isLiquidityEstablishedOrExpired()\\r\\n        external\\r\\n        view\\r\\n        returns (bool _isEstablishedOrExpired);\\r\\n}\"},\"InitialLiquidityOffering.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\n// This code is the property of the Aardbanq DAO.\\r\\n// The Aardbanq DAO is located at 0x829c094f5034099E91AB1d553828F8A765a3DaA1 on the Ethereum Main Net.\\r\\n// It is the author\\u0027s wish that this code should be open sourced under the MIT license, but the final \\r\\n// decision on this would be taken by the Aardbanq DAO with a vote once sufficient ABQ tokens have been \\r\\n// distributed.\\r\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\\r\\n\\r\\npragma solidity \\u003e=0.7.0;\\r\\nimport \\\"./Minter.sol\\\";\\r\\nimport \\\"./Erc20.sol\\\";\\r\\nimport \\\"./IUniswapV2Router02.sol\\\";\\r\\nimport \\\"./IUniswapV2Factory.sol\\\";\\r\\nimport \\\"./IUniswapV2Pair.sol\\\";\\r\\nimport \\\"./IPricer.sol\\\";\\r\\nimport \\\"./SafeMathTyped.sol\\\";\\r\\nimport \\\"./ILiquidityEstablisher.sol\\\";\\r\\n\\r\\n/// @notice A contract to offer initial liquidity purchase and an reward.\\r\\ncontract InitialLiquidityOffering is ILiquidityEstablisher\\r\\n{\\r\\n    /// @notice The time in unix (seconds) timestamp that the offer closes.\\r\\n    uint64 public offerCloseTime;\\r\\n    /// @notice The address funds are sent to.\\r\\n    address public treasury;\\r\\n    /// @notice The token that is offered.\\r\\n    Erc20 public tokenOffer;\\r\\n    /// @notice The time in unix (seconds) timestamp that the liquidity may be claimed.\\r\\n    uint64 public liquidityReleaseTime;\\r\\n    /// @notice The token liquidity will be established with.\\r\\n    Erc20 public liquidityToken;\\r\\n    /// @notice Flag to indicate if liquidity has been established.\\r\\n    bool public isLiquidityEstablished;\\r\\n    /// @notice The minter of the token on offer.\\r\\n    Minter public minter;\\r\\n    /// @notice The uniswap router used to establish liquidity.\\r\\n    IUniswapV2Router02 public uniswapRouter;\\r\\n    /// @notice The ICO used to establish the price at which liquidity will be established.\\r\\n    IPricer public pricer;\\r\\n    /// @notice The maximum liquidity (priced in liquidityToken) up for sale.\\r\\n    uint256 public maxLiquidityAllowed;\\r\\n    /// @notice The total liquidity sold so far.\\r\\n    uint256 public totalLiquidityProvided;\\r\\n\\r\\n    /// @notice The total liquidity provided by each address (priced in liquidityToken).\\r\\n    mapping(address =\\u003e uint256) public liquidityBalances;\\r\\n\\r\\n    /// @notice Constructs an initial liquidity token offering.\\r\\n    /// @param _offerCloseTime The time in unix (seconds) timestamp that the offer closes.\\r\\n    /// @param _tokenOffer The token on offer.\\r\\n    /// @param _liquidityReleaseTime The time in unix (secods) timestamp that the liquidity will be released.\\r\\n    /// @param _liquidityToken The token liquidity will be sold in. (like DAI)\\r\\n    /// @param _minter The minter that can mint _tokenOffer tokens.\\r\\n    /// @param _uniswapRouter The uniswap router to use.\\r\\n    /// @param _maxLiquidityAllowed The maximum liquidity (priced in _liquidityToken) on sale.\\r\\n    constructor (uint64 _offerCloseTime, address _treasury, Erc20 _tokenOffer, uint64 _liquidityReleaseTime, Erc20 _liquidityToken, \\r\\n        Minter _minter, IUniswapV2Router02 _uniswapRouter, uint256 _maxLiquidityAllowed)\\r\\n    {\\r\\n        offerCloseTime = _offerCloseTime;\\r\\n        treasury = _treasury;\\r\\n        tokenOffer = _tokenOffer;\\r\\n        liquidityReleaseTime = _liquidityReleaseTime;\\r\\n        liquidityToken = _liquidityToken;\\r\\n        minter = _minter;\\r\\n        uniswapRouter = _uniswapRouter;\\r\\n        maxLiquidityAllowed = _maxLiquidityAllowed;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns true if either liquidity has been established or the ILO has been closed for more than 7 days. False otherwise.\\r\\n    /// @return _isEstablishedOrExpired True if either liquidity has been established or the ILO has been closed for more than 7 days. False otherwise.\\r\\n    function isLiquidityEstablishedOrExpired()\\r\\n        external\\r\\n        override\\r\\n        view\\r\\n        returns (bool _isEstablishedOrExpired)\\r\\n    {\\r\\n        return isLiquidityEstablished || (offerCloseTime + 7 days \\u003c= block.timestamp); \\r\\n    }\\r\\n\\r\\n    /// @notice Set the ICO address to use to establish the price of the token on offer.\\r\\n    function setPricer(IPricer _pricer) \\r\\n        external\\r\\n    {\\r\\n        require(address(pricer) == address(0), \\\"ABQICO/pricer-already-set\\\");\\r\\n        pricer = _pricer;\\r\\n    }\\r\\n\\r\\n    /// @notice Event emitted when liquidity was provided.\\r\\n    /// @param to The address that provided the liquidity.\\r\\n    /// @param amount The amount of liquidity (priced in liquidityToken) that was provided.\\r\\n    event LiquidityOfferReceipt(address to, uint256 amount);\\r\\n    /// @notice Provide liquidity. Liquidity is paid for from the msg.sender.\\r\\n    /// @param _target The address that will own and receive the liquidity pool tokens and reward.\\r\\n    /// @param _amount The amount of liquidity to offer (priced in liquidityToken).\\r\\n    function provideLiquidity(address _target, uint256 _amount)\\r\\n        external\\r\\n    {\\r\\n        require(offerCloseTime \\u003e= block.timestamp \\u0026\\u0026 maxLiquidityAllowed \\u003e totalLiquidityProvided, \\\"ABQILO/offer-closed\\\");\\r\\n\\r\\n        // CG: ensure only whole token amounts have no values in the last 18 places\\r\\n        _amount = (_amount / 1 ether) * 1 ether;\\r\\n        require(_amount \\u003e= 1 ether, \\\"ABQILO/amount-too-small\\\");\\r\\n\\r\\n        // CG: ensure amounts don\\u0027t go above max allowed\\r\\n        uint256 amountLeft = SafeMathTyped.sub256(maxLiquidityAllowed, totalLiquidityProvided);\\r\\n        if (_amount \\u003e amountLeft)\\r\\n        {\\r\\n            _amount = amountLeft;\\r\\n        }\\r\\n\\r\\n        // CG: transfer funds\\r\\n        bool couldTransfer = liquidityToken.transferFrom(msg.sender, address(this), _amount);\\r\\n        require(couldTransfer, \\\"ABQILO/could-not-transfer\\\");\\r\\n\\r\\n        // CG: account for funds\\r\\n        totalLiquidityProvided = SafeMathTyped.add256(totalLiquidityProvided, _amount);\\r\\n        liquidityBalances[_target] = SafeMathTyped.add256(liquidityBalances[_target], _amount);\\r\\n\\r\\n        emit LiquidityOfferReceipt(_target, _amount);\\r\\n    }\\r\\n\\r\\n    /// @notice Event emitted when liquidity is established.\\r\\n    /// @param liquidityAssetAmount The amount of liquidityToken that was contributed.\\r\\n    /// @param offerTokenAmount The amount of the token on offer that was added as liquidity.\\r\\n    /// @param liquidityTokenAmount The amount of liquidity pool tokens that was minted.\\r\\n    event LiquidityEstablishment(uint256 liquidityAssetAmount, uint256 offerTokenAmount, uint256 liquidityTokenAmount);\\r\\n    /// @notice Establish liquidity if the sale period ended or the liquidity sale has been sold out.\\r\\n    function establishLiquidity()\\r\\n        external\\r\\n    {\\r\\n        require(offerCloseTime \\u003c block.timestamp || maxLiquidityAllowed == totalLiquidityProvided, \\\"ABQILO/offer-still-open\\\");\\r\\n        require(!isLiquidityEstablished, \\\"ABQILO/liquidity-already-established\\\");\\r\\n\\r\\n        if (totalLiquidityProvided \\u003e 0)\\r\\n        {\\r\\n            uint256 currentPrice = pricer.currentPrice();\\r\\n            if (currentPrice \\u003e 10 ether)\\r\\n            {\\r\\n                // CG: in the event the ICO was sold out.\\r\\n                currentPrice = 10 ether;\\r\\n            }\\r\\n            uint256 totalOfferProvided = SafeMathTyped.mul256(totalLiquidityProvided / currentPrice, 1 ether);\\r\\n            minter.mint(address(this), totalOfferProvided);\\r\\n\\r\\n            bool isOfferApproved = tokenOffer.approve(address(uniswapRouter), totalOfferProvided);\\r\\n            require(isOfferApproved, \\\"ABQICO/could-not-approve-offer\\\");\\r\\n            bool isLiquidityApproved = liquidityToken.approve(address(uniswapRouter), totalLiquidityProvided);\\r\\n            require(isLiquidityApproved, \\\"ABQICO/could-not-approve-liquidity\\\");\\r\\n\\r\\n            (, , uint256 liquidityTokensCount) = uniswapRouter.addLiquidity(address(liquidityToken), address(tokenOffer), totalLiquidityProvided, totalOfferProvided, 0, 0, address(this), block.timestamp);\\r\\n\\r\\n            IUniswapV2Factory factory = IUniswapV2Factory(uniswapRouter.factory());\\r\\n            IUniswapV2Pair pair = IUniswapV2Pair(factory.getPair(address(tokenOffer), address(liquidityToken)));\\r\\n            require(address(pair) != address(0), \\\"ABQILO/pair-not-created\\\");\\r\\n            bool couldSendDaoShare = pair.transfer(treasury, liquidityTokensCount / 2);\\r\\n            require(couldSendDaoShare, \\\"ABQILO/could-not-send\\\");\\r\\n\\r\\n            emit LiquidityEstablishment(totalLiquidityProvided, totalOfferProvided, liquidityTokensCount);\\r\\n        }\\r\\n\\r\\n        isLiquidityEstablished = true;\\r\\n    }\\r\\n\\r\\n    /// @notice Event emitted when liquidity pool tokens are claimed.\\r\\n    /// @param to The address the claim was for.\\r\\n    /// @param amount The amount of liquidity pool tokens that was claimed.\\r\\n    /// @param reward The reward (in the token on offer) that was also claimed.\\r\\n    event Claim(address to, uint256 amount, uint256 reward);\\r\\n    /// @notice Claim liquidity pool tokens and the reward after liquidity has been released.\\r\\n    /// @param _for The address to release the liquidity pool tokens and the reward for.\\r\\n    function claim(address _for)\\r\\n        external\\r\\n    {\\r\\n        require(liquidityReleaseTime \\u003c= block.timestamp, \\\"ABQILO/liquidity-locked\\\");\\r\\n        require(isLiquidityEstablished, \\\"ABQILO/liquidity-not-established\\\");\\r\\n\\r\\n        // CG: we can divide be 1 ether since we made sure values does not include any values in the last 18 decimals. See the provideLiquidity token.\\r\\n        uint256 claimShareFull = liquidityBalances[_for];\\r\\n        if (claimShareFull == 0)\\r\\n        {\\r\\n            return;\\r\\n        }\\r\\n        uint256 claimShare = (claimShareFull / 1 ether);\\r\\n        uint256 claimPool = (totalLiquidityProvided / 1 ether);\\r\\n\\r\\n        // CG: remove claim share from accounts\\r\\n        totalLiquidityProvided = SafeMathTyped.sub256(totalLiquidityProvided, claimShareFull);\\r\\n        liquidityBalances[_for] = 0;\\r\\n\\r\\n        // CG: get uniswap pair\\r\\n        IUniswapV2Factory factory = IUniswapV2Factory(uniswapRouter.factory());\\r\\n        IUniswapV2Pair pair = IUniswapV2Pair(factory.getPair(address(tokenOffer), address(liquidityToken)));\\r\\n        require(address(pair) != address(0), \\\"ABQILO/pair-not-created\\\");\\r\\n        uint256 pairBalance = pair.balanceOf(address(this));\\r\\n\\r\\n        // CG: transfer claim\\r\\n        uint256 claimTotal = SafeMathTyped.mul256(pairBalance, claimShare) / claimPool;\\r\\n        bool couldTransfer = pair.transfer(_for, claimTotal);\\r\\n        require(couldTransfer, \\\"ABQILO/could-not-transfer\\\");\\r\\n\\r\\n        // CG: mint reward: 25% of original contribution as reward tokens.\\r\\n        uint256 reward = SafeMathTyped.mul256(claimShareFull, 25) / 100;\\r\\n        minter.mint(_for, reward);\\r\\n\\r\\n        emit Claim(_for, claimTotal, reward);\\r\\n    }\\r\\n}\"},\"IPricer.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\n// This code is the property of the Aardbanq DAO.\\r\\n// The Aardbanq DAO is located at 0x829c094f5034099E91AB1d553828F8A765a3DaA1 on the Ethereum Main Net.\\r\\n// It is the author\\u0027s wish that this code should be open sourced under the MIT license, but the final \\r\\n// decision on this would be taken by the Aardbanq DAO with a vote once sufficient ABQ tokens have been \\r\\n// distributed.\\r\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\\r\\npragma solidity \\u003e=0.7.0;\\r\\n\\r\\ninterface IPricer\\r\\n{\\r\\n    function currentPrice()\\r\\n        view\\r\\n        external\\r\\n        returns (uint256 _currentPrice);\\r\\n}\"},\"IUniswapV2Factory.sol\":{\"content\":\"pragma solidity \\u003e=0.5.0;\\r\\n\\r\\ninterface IUniswapV2Factory {\\r\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\r\\n\\r\\n    function feeTo() external view returns (address);\\r\\n    function feeToSetter() external view returns (address);\\r\\n\\r\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n    function allPairs(uint) external view returns (address pair);\\r\\n    function allPairsLength() external view returns (uint);\\r\\n\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n\\r\\n    function setFeeTo(address) external;\\r\\n    function setFeeToSetter(address) external;\\r\\n}\"},\"IUniswapV2Pair.sol\":{\"content\":\"pragma solidity \\u003e=0.5.0;\\r\\n\\r\\ninterface IUniswapV2Pair {\\r\\n    event Approval(address indexed owner, address indexed spender, uint value);\\r\\n    event Transfer(address indexed from, address indexed to, uint value);\\r\\n\\r\\n    function name() external pure returns (string memory);\\r\\n    function symbol() external pure returns (string memory);\\r\\n    function decimals() external pure returns (uint8);\\r\\n    function totalSupply() external view returns (uint);\\r\\n    function balanceOf(address owner) external view returns (uint);\\r\\n    function allowance(address owner, address spender) external view returns (uint);\\r\\n\\r\\n    function approve(address spender, uint value) external returns (bool);\\r\\n    function transfer(address to, uint value) external returns (bool);\\r\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\r\\n\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n    function nonces(address owner) external view returns (uint);\\r\\n\\r\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n\\r\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\r\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\r\\n    event Swap(\\r\\n        address indexed sender,\\r\\n        uint amount0In,\\r\\n        uint amount1In,\\r\\n        uint amount0Out,\\r\\n        uint amount1Out,\\r\\n        address indexed to\\r\\n    );\\r\\n    event Sync(uint112 reserve0, uint112 reserve1);\\r\\n\\r\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\r\\n    function factory() external view returns (address);\\r\\n    function token0() external view returns (address);\\r\\n    function token1() external view returns (address);\\r\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n    function price0CumulativeLast() external view returns (uint);\\r\\n    function price1CumulativeLast() external view returns (uint);\\r\\n    function kLast() external view returns (uint);\\r\\n\\r\\n    function mint(address to) external returns (uint liquidity);\\r\\n    function burn(address to) external returns (uint amount0, uint amount1);\\r\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\r\\n    function skim(address to) external;\\r\\n    function sync() external;\\r\\n\\r\\n    function initialize(address, address) external;\\r\\n}\"},\"IUniswapV2Router01.sol\":{\"content\":\"pragma solidity \\u003e=0.6.2;\\r\\n\\r\\ninterface IUniswapV2Router01 {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETH(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function removeLiquidityWithPermit(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETHWithPermit(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function swapExactTokensForTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapTokensForExactTokens(\\r\\n        uint amountOut,\\r\\n        uint amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n\\r\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\r\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\r\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\r\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n}\"},\"IUniswapV2Router02.sol\":{\"content\":\"pragma solidity \\u003e=0.6.2;\\r\\n\\r\\nimport \\u0027./IUniswapV2Router01.sol\\u0027;\\r\\n\\r\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\r\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountETH);\\r\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountETH);\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n}\"},\"Minter.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\n// This code is the property of the Aardbanq DAO.\\r\\n// The Aardbanq DAO is located at 0x829c094f5034099E91AB1d553828F8A765a3DaA1 on the Ethereum Main Net.\\r\\n// It is the author\\u0027s wish that this code should be open sourced under the MIT license, but the final \\r\\n// decision on this would be taken by the Aardbanq DAO with a vote once sufficient ABQ tokens have been \\r\\n// distributed.\\r\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\\r\\npragma solidity \\u003e=0.7.0;\\r\\n\\r\\ninterface Minter\\r\\n{\\r\\n    function mint(address _target, uint256 _amount) external;\\r\\n}\"},\"SafeMathTyped.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\n/**\\r\\n * @title SafeMath\\r\\n * @dev Unsigned math operations with safety checks that revert on error\\r\\n */\\r\\nlibrary SafeMathTyped {\\r\\n    /**\\r\\n    * @dev Multiplies two unsigned integers, reverts on overflow.\\r\\n    */\\r\\n    function mul256(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"uint256 overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\\r\\n    */\\r\\n    function div256(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b \\u003e 0, \\\"Can\\u0027t divide by 0\\\");\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\r\\n    */\\r\\n    function sub256(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, \\\"uint256 underflow\\\");\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Adds two unsigned integers, reverts on overflow.\\r\\n    */\\r\\n    function add256(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"uint256 overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\\r\\n    * reverts when dividing by zero.\\r\\n    */\\r\\n    function mod256(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b != 0, \\\"Can\\u0027t mod by 0\\\");\\r\\n        return a % b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev returns the greater of two numbers\\r\\n    */\\r\\n    function max256(uint256 a, uint256 b) internal pure returns (uint) {\\r\\n        return a \\u003e b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev returns the lesser of two numbers\\r\\n    */\\r\\n    function min256(uint256 a, uint256 b) internal pure returns (uint) {\\r\\n        return a \\u003c b ? a : b;\\r\\n    }\\r\\n}\"},\"ScaleBuying.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\n// This code is the property of the Aardbanq DAO.\\r\\n// The Aardbanq DAO is located at 0x829c094f5034099E91AB1d553828F8A765a3DaA1 on the Ethereum Main Net.\\r\\n// It is the author\\u0027s wish that this code should be open sourced under the MIT license, but the final \\r\\n// decision on this would be taken by the Aardbanq DAO with a vote once sufficient ABQ tokens have been \\r\\n// distributed.\\r\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\\r\\n\\r\\npragma solidity \\u003e=0.7.0;\\r\\nimport \\\"./SafeMathTyped.sol\\\";\\r\\nimport \\\"./Erc20.sol\\\";\\r\\nimport \\u0027./Minter.sol\\u0027;\\r\\nimport \\\"./IPricer.sol\\\";\\r\\nimport \\\"./ILiquidityEstablisher.sol\\\";\\r\\n\\r\\n/// @notice Allow buying of tokens in batches of increasing price.\\r\\ncontract ScaleBuying is IPricer\\r\\n{\\r\\n    /// @notice The token to use for purchasing\\r\\n    Erc20 public paymentAsset;\\r\\n    /// @notice The token that is being bought\\r\\n    Erc20 public boughtAsset;\\r\\n    /// @notice The minter for the token being bought\\r\\n    Minter public minter;\\r\\n    /// @notice The date in unix timestamp (seconds) when the sale closes.\\r\\n    uint64 public closingDate;\\r\\n    /// @notice The address to which the funds should be sent to.\\r\\n    address public treasury;\\r\\n    /// @notice The location of the ILO, used to know when tokens can be claimed.\\r\\n    ILiquidityEstablisher public liquidityEstablisher;\\r\\n    /// @notice The amount that has been awarded so far.\\r\\n    uint256 public amountAwarded;\\r\\n    /// @notice The initial price for the sale.\\r\\n    uint256 public initialPrice;\\r\\n    /// @notice The price increase for each token block.\\r\\n    uint256 public priceIncrease;\\r\\n    /// @notice The amount of tokens per block.\\r\\n    uint256 public tokensPerPriceBlock;\\r\\n    /// @notice The number of blocks up for sale.\\r\\n    uint256 public maxBlocks;\\r\\n\\r\\n    /// @notice The amounts of tokens claimable by an address.\\r\\n    mapping(address =\\u003e uint256) public amountsClaimable;\\r\\n\\r\\n    /// @notice Constructs a ScaleBuying\\r\\n    /// @param _paymentAsset The token address to be used for payment.\\r\\n    /// @param _boughtAsset The token address to be issued.\\r\\n    /// @param _minter The minter for the issued token.\\r\\n    /// @param _treasury The address to receive all funds.\\r\\n    /// @param _initialPrice The initial price per token.\\r\\n    /// @param _priceIncrease The increase of the price per token for each block.\\r\\n    /// @param _tokensPerPriceBlock The tokens in each block.\\r\\n    /// @param _maxBlocks The maximum number of blocks on sale.\\r\\n    /// @param _closingDate The date in unix (seconds) timestamp that the sale will close.\\r\\n    constructor (Erc20 _paymentAsset, Erc20 _boughtAsset, Minter _minter, address _treasury, uint256 _initialPrice, \\r\\n        uint256 _priceIncrease, uint256 _tokensPerPriceBlock, uint256 _maxBlocks, uint64 _closingDate)\\r\\n    {\\r\\n        paymentAsset = _paymentAsset;\\r\\n        boughtAsset = _boughtAsset;\\r\\n        minter = _minter;\\r\\n        treasury = _treasury;\\r\\n        amountAwarded = 0;\\r\\n        initialPrice = _initialPrice;\\r\\n        priceIncrease = _priceIncrease;\\r\\n        tokensPerPriceBlock = _tokensPerPriceBlock;\\r\\n        maxBlocks = _maxBlocks;\\r\\n        closingDate = _closingDate;\\r\\n\\r\\n        allocateTokensRaisedByAuction();\\r\\n    }\\r\\n\\r\\n    // CG: This allocates the amount of tokens that was already bought on auction before\\\\\\r\\n    //     switching over to this Scale Buying.\\r\\n    function allocateTokensRaisedByAuction() \\r\\n        private\\r\\n    {\\r\\n        uint256 price = initialPrice;\\r\\n        \\r\\n        uint256 buyerAAmount = 7165 ether;\\r\\n        amountsClaimable[0xEE779e4b3e7b11454ed80cFE12Cf48ee3Ff4579E] = buyerAAmount;\\r\\n        emit Bought(0xEE779e4b3e7b11454ed80cFE12Cf48ee3Ff4579E, buyerAAmount, price);\\r\\n        \\r\\n        uint256 buyerBAmount = 4065 ether;\\r\\n        amountsClaimable[0x6C4f3Db0E743A9e8f44A756b6585192B358D7664] = buyerBAmount;\\r\\n        emit Bought(0x6C4f3Db0E743A9e8f44A756b6585192B358D7664, buyerAAmount, price);\\r\\n\\r\\n        uint256 buyerCAmount = 355 ether;\\r\\n        amountsClaimable[0x0FB79E6C0F5447ffe36a0050221275Da487b0E09] = buyerCAmount;\\r\\n        emit Bought(0x0FB79E6C0F5447ffe36a0050221275Da487b0E09, buyerAAmount, price);\\r\\n\\r\\n        amountAwarded = buyerAAmount + buyerBAmount + buyerCAmount;\\r\\n    }\\r\\n\\r\\n    /// @notice Set the ILO to use to track if liquidity has been astablished and thus claims can be allowed.\\r\\n    /// @param _liquidityEstablisher The ILO.\\r\\n    function setLiquidityEstablisher(ILiquidityEstablisher _liquidityEstablisher)\\r\\n        external\\r\\n    {\\r\\n        require(address(liquidityEstablisher) == address(0), \\\"ABQDAO/already-set\\\");\\r\\n\\r\\n        liquidityEstablisher = _liquidityEstablisher;\\r\\n    }\\r\\n\\r\\n    /// @notice The event emitted when a claim is executed.\\r\\n    /// @param claimer The address the claim has been processed for.\\r\\n    /// @param amount The amount that was claimed.\\r\\n    event Claimed(address indexed claimer, uint256 amount);\\r\\n    /// @notice Claim ABQ bought for the given address. Claims can only be processed after liquidity has been established.\\r\\n    /// @param _target The address to process claims for.\\r\\n    function claim(address _target)\\r\\n        external\\r\\n    {\\r\\n        // CG: Claims cannot be executed before liquidity is established or closed more than a week ago.\\r\\n        require(liquidityEstablisher.isLiquidityEstablishedOrExpired(), \\\"ABQDAO/cannot-claim-yet\\\");\\r\\n\\r\\n        uint256 amountClaimable = amountsClaimable[_target];\\r\\n        if (amountClaimable \\u003e 0)\\r\\n        {\\r\\n            bool isSuccess = boughtAsset.transfer(_target, amountClaimable);\\r\\n            require(isSuccess, \\\"ABQDAO/could-not-transfer-claim\\\");\\r\\n            amountsClaimable[_target] = 0;\\r\\n            emit Claimed(_target, amountClaimable);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice The event emitted when tokens are bought.\\r\\n    /// @param buyer The address that may claim the tokens.\\r\\n    /// @param amount The amount of token bought.\\r\\n    /// @param pricePerToken The price per token that the tokens were bought for.\\r\\n    event Bought(address indexed buyer, uint256 amount, uint256 pricePerToken);\\r\\n    /// @notice Buy tokens in the current block.\\r\\n    /// @param _paymentAmount The amount to spend. This will be transfered from msg.sender who should approved this amount first.\\r\\n    /// @param _target The address that the amounts would be bought for. Tokens are distributed after calling the claim method.\\r\\n    function buy(uint256 _paymentAmount, address _target) \\r\\n        external\\r\\n        returns (uint256 _paymentLeft)\\r\\n    {\\r\\n        // CG: only allow buys before the ico closes.\\r\\n        require(block.timestamp \\u003c= closingDate, \\\"ABQDAO/ico-concluded\\\");\\r\\n\\r\\n        (uint256 paymentLeft, uint256 paymentDue) = buyInBlock(_paymentAmount, _target);\\r\\n        // CG: transfer payment\\r\\n        if (paymentDue \\u003e 0)\\r\\n        {\\r\\n            bool isSuccess = paymentAsset.transferFrom(msg.sender, treasury, paymentDue);\\r\\n            require(isSuccess, \\\"ABQDAO/could-not-pay\\\");\\r\\n        }\\r\\n        return paymentLeft;\\r\\n    }\\r\\n\\r\\n    function buyInBlock(uint256 _paymentAmount, address _target)\\r\\n        private\\r\\n        returns (uint256 _paymentLeft, uint256 _paymentDue)\\r\\n    {\\r\\n        uint256 currentBlockIndex = currentBlock();\\r\\n        uint256 tokensLeft = tokensLeftInBlock(currentBlockIndex);\\r\\n\\r\\n        if (currentBlockIndex \\u003e= maxBlocks)\\r\\n        {\\r\\n            // CG: If all block are sold out, then amount bought should be zero.\\r\\n            return (_paymentAmount, 0);\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            uint256 currentPriceLocal = currentPrice();\\r\\n            uint256 tokensCanPayFor = _paymentAmount / currentPriceLocal;\\r\\n            if (tokensCanPayFor == 0)\\r\\n            {\\r\\n                return (_paymentAmount, 0);\\r\\n            }\\r\\n            if (tokensCanPayFor \\u003e (tokensLeft / 1 ether))\\r\\n            {\\r\\n                tokensCanPayFor = tokensLeft / 1 ether;\\r\\n            }\\r\\n\\r\\n            // CG: Get the amount of tokens that can be bought in this block.\\r\\n            uint256 paymentDue = SafeMathTyped.mul256(tokensCanPayFor, currentPriceLocal);\\r\\n            tokensCanPayFor = SafeMathTyped.mul256(tokensCanPayFor, 1 ether);\\r\\n            amountsClaimable[_target] = SafeMathTyped.add256(amountsClaimable[_target], tokensCanPayFor);\\r\\n            amountAwarded = SafeMathTyped.add256(amountAwarded, tokensCanPayFor);\\r\\n            minter.mint(address(this), tokensCanPayFor);\\r\\n            emit Bought(_target, tokensCanPayFor, currentPriceLocal);\\r\\n            uint256 paymentLeft = SafeMathTyped.sub256(_paymentAmount, paymentDue);\\r\\n            \\r\\n            if (paymentLeft \\u003c= currentPriceLocal)\\r\\n            {\\r\\n                return (paymentLeft, paymentDue);\\r\\n            }\\r\\n            else\\r\\n            {\\r\\n                // CG: should this block be sold out, buy the remainder in the next box.\\r\\n                (uint256 subcallPaymentLeft, uint256 subcallPaymentDue) = buyInBlock(paymentLeft, _target);\\r\\n                paymentDue = SafeMathTyped.add256(paymentDue, subcallPaymentDue);\\r\\n                return (subcallPaymentLeft, paymentDue);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Get the current price per token.\\r\\n    /// @return _currentPrice The current price per token.\\r\\n    function currentPrice()\\r\\n        view\\r\\n        public\\r\\n        override\\r\\n        returns (uint256 _currentPrice)\\r\\n    {\\r\\n        return SafeMathTyped.add256(initialPrice, SafeMathTyped.mul256(currentBlock(), priceIncrease));\\r\\n    }\\r\\n\\r\\n    /// @notice Get the current block number, starting at 0.\\r\\n    function currentBlock() \\r\\n        view\\r\\n        public\\r\\n        returns (uint256 _currentBlock)\\r\\n    {\\r\\n        return amountAwarded / tokensPerPriceBlock;\\r\\n    }\\r\\n\\r\\n    /// @notice Get the amount of tokens left in a given block.\\r\\n    /// @param _block The block to get the number of tokens left for.\\r\\n    /// @return _tokensLeft The number of tokens left in the given _block.\\r\\n    function tokensLeftInBlock(uint256 _block)\\r\\n        view\\r\\n        public\\r\\n        returns (uint256 _tokensLeft)\\r\\n    {\\r\\n        uint256 currentBlockIndex = currentBlock();\\r\\n\\r\\n        if (_block \\u003e maxBlocks || _block \\u003c currentBlockIndex)\\r\\n        {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        if (_block == currentBlockIndex)\\r\\n        {\\r\\n            //CG: non overflow code: return ((currentBlockIndex + 1) * tokensPerPriceBlock) - amountAwarded;\\r\\n            return SafeMathTyped.sub256(SafeMathTyped.mul256(SafeMathTyped.add256(currentBlockIndex, 1), tokensPerPriceBlock), amountAwarded);\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            return tokensPerPriceBlock;\\r\\n        }\\r\\n    }\\r\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"contract Erc20\",\"name\":\"_dai\",\"type\":\"address\"},{\"internalType\":\"contract ScaleBuying\",\"name\":\"_ico\",\"type\":\"address\"},{\"internalType\":\"contract InitialLiquidityOffering\",\"name\":\"_ilo\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_for\",\"type\":\"address\"}],\"name\":\"BuyInIco\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_for\",\"type\":\"address\"}],\"name\":\"BuyInIlo\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dai\",\"outputs\":[{\"internalType\":\"contract Erc20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ico\",\"outputs\":[{\"internalType\":\"contract ScaleBuying\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ilo\",\"outputs\":[{\"internalType\":\"contract InitialLiquidityOffering\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapRouter\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"EthToDaiFacilitator","CompilerVersion":"v0.7.0+commit.9e61f92b","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d0000000000000000000000006b175474e89094c44da98b954eedeac495271d0f000000000000000000000000c52765256ccfe1e9cd73bb7800c890ae7fe07748000000000000000000000000a1503e865e4dd7b86227279de8a7db529f359a06","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://78ad8cee031ce0e0ec869c9894a5cd4ccf16135789cbbd38ecf8f6d20fa9cae1"}]}