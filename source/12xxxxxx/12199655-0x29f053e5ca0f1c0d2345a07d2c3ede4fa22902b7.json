{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2021-04-08\r\n*/\r\n\r\npragma solidity 0.6.0;\r\n\r\ninterface IERC777 {\r\n    function name() external view returns(string memory);\r\n    function symbol() external view returns(string memory);\r\n    function decimals() external view returns(uint8);\r\n    function totalSupply() external view returns(uint256);\r\n    function balanceOf(address owner) external view returns(uint256);\r\n    function transfer(address to, uint256 amount) external returns(bool);\r\n    function transferFrom(address from, address to, uint256 amount) external returns(bool);\r\n    function approve(address spender, uint256 amount) external returns(bool);\r\n    function allowance(address owner, address spender) external view returns(uint256);\r\n    function burnBalance(address _addr, uint _amount) external;\r\n    function mint(address _tokenHolder, uint256 _amount, bytes calldata _data, bytes calldata _operatorData) external;\r\n    function defaultOperators() external view returns(address[] memory);\r\n\r\n    // solhint-disable-next-line no-simple-event-func-name\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns(uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns(uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers.\r\n     * (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. \r\n     * (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns(uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\ncontract SeekReward {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    // Investor details\r\n    struct user {\r\n        uint256 cycle;\r\n        address upline;\r\n        uint256 referrals;\r\n        uint256 payouts;\r\n        uint256 referalBonus;\r\n        uint256 matchBonus;\r\n        uint256 depositAmount;\r\n        uint256 depositPayouts;\r\n        uint40 depositTime;\r\n        uint256 totalDeposits;\r\n        uint256 totalStructure;\r\n    }\r\n    \r\n    // Token instance\r\n    IERC777 public token;\r\n\r\n    // Mapping users details by address\r\n    mapping(address => user)public users;\r\n\r\n    // Contract status\r\n    bool public lockStatus;\r\n    // Admin1 address\r\n    address public admin1;\r\n    // Admin2 address\r\n    address public admin2;\r\n    // Total levels\r\n    uint[]public Levels;\r\n    // Total users count\r\n    uint256 public totalUsers = 1;\r\n    // Total deposit amount.\r\n    uint256 public totalDeposited;\r\n    // Total withdraw amount\r\n    uint256 public totalWithdraw;\r\n\r\n    // Matching bonus event\r\n    event MatchBonus(address indexed from, address indexed to, uint value, uint time);\r\n    // Withdraw event\r\n    event Withdraw(address indexed from, uint value, uint time);\r\n    // Deposit event\r\n    event Deposit(address indexed from, address indexed refer, uint value, uint time);\r\n    // Admin withdraw event\r\n    event AdminEarnings(address indexed user, uint value, uint time);\r\n    // User withdraw limt event\r\n    event LimitReached(address indexed from, uint value, uint time);\r\n    // Inject User\r\n    event Inject(address indexed user,address indexed upline,uint amount,uint time);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the owners and token.\r\n     */\r\n    constructor(address  _owner1, address  _owner2, address _token) public {\r\n        admin1 = _owner1;\r\n        admin2 = _owner2;\r\n        token = IERC777(_token);\r\n\r\n        //Levels maximum amount\r\n        Levels.push(150e18);\r\n        Levels.push(450e18);\r\n        Levels.push(1350e18);\r\n        Levels.push(3000e18);\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == admin1, \"SeekReward: Only Owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if lockStatus is true\r\n     */\r\n    modifier isLock() {\r\n        require(lockStatus == false, \"SeekReward: Contract Locked\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by other contract\r\n     */\r\n    modifier isContractCheck(address _user) {\r\n        require(!isContract(_user), \"SeekReward: Invalid address\");\r\n        _;\r\n    }\r\n\r\n    function _setUpline(address _addr, address _upline) private {\r\n        if (users[_addr].upline == address(0) && _upline != _addr && _addr != admin1 && \r\n           (users[_upline].depositTime > 0 || _upline == admin1)) {\r\n            users[_addr].upline = _upline;\r\n            users[_upline].referrals = users[_upline].referrals.add(1);\r\n            totalUsers++;\r\n            for (uint8 i = 0; i < 21; i++) { // For update total structure for uplines\r\n                if (_upline == address(0)) break;\r\n                users[_upline].totalStructure++;\r\n                _upline = users[_upline].upline;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _deposit(address _addr, uint256 _amount) private {\r\n        require(users[_addr].upline != address(0) || _addr == admin1, \"No upline\");\r\n        if (users[_addr].depositTime > 0) {\r\n            users[_addr].cycle++;\r\n            require(users[_addr].payouts >= this.maxPayoutOf(users[_addr].depositAmount),\r\n            \"SeekReward: Deposit already exists\");\r\n            require(_amount >= users[_addr].depositAmount && _amount <= Levels[users[_addr].cycle > Levels.length - 1 ?Levels.length - 1 : users[_addr].cycle], \"SeekReward: Bad amount\");\r\n        }\r\n        else {\r\n            require(_amount >= 1e18 && _amount <= Levels[0], \"SeekReward: Bad amount\");\r\n        }\r\n        require(token.transferFrom(msg.sender, address(this), _amount), \"Seekreward: transaction failed\");\r\n\r\n        users[_addr].payouts = 0;\r\n        users[_addr].depositAmount = _amount;\r\n        users[_addr].depositPayouts = 0;\r\n        users[_addr].depositTime = uint40(block.timestamp);\r\n        users[_addr].referalBonus = 0;\r\n        users[_addr].matchBonus = 0;\r\n        users[_addr].totalDeposits = users[_addr].totalDeposits.add(_amount);\r\n        totalDeposited = totalDeposited.add(_amount);\r\n\r\n        address upline = users[_addr].upline;\r\n        address up = users[users[_addr].upline].upline;\r\n\r\n        if (upline != address(0)) {\r\n            token.transfer(upline, _amount.mul(10e18).div(100e18)); // 10% for direct referer\r\n            users[upline].referalBonus = users[upline].referalBonus.add(_amount.mul(10e18).div(100e18));\r\n        }\r\n        if (up != address(0)) {\r\n            token.transfer(up, _amount.mul(5e18).div(100e18)); // 5% for indirect referer\r\n            users[up].referalBonus = users[up].referalBonus.add(_amount.mul(5e18).div(100e18));\r\n        }\r\n\r\n        uint adminFee = _amount.mul(5e18).div(100e18);\r\n        token.transfer(admin1, adminFee.div(2)); // 2.5% admin1\r\n        token.transfer(admin2, adminFee.div(2)); // 2.5% admin2\r\n        adminFee = 0;\r\n        emit Deposit(_addr, users[_addr].upline, _amount, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @dev deposit: User deposit with 1 seek token\r\n     * 5% adminshare split into 2 accounts\r\n     * @param _upline: Referal address\r\n     * @param amount:1st deposit minimum 1 seek & maximum 150 for cycle 1\r\n     * Next depsoit amount based on previous deposit amount and maximum amount based on cycles\r\n     */\r\n    function deposit(address _upline, uint amount) external isLock isContractCheck(msg.sender) {\r\n        _setUpline(msg.sender, _upline);\r\n        _deposit(msg.sender, amount);\r\n    }\r\n    \r\n    function injectUser(address[] memory _user,address[] memory _upline,uint[] memory _amount)public onlyOwner{\r\n        for (uint i = 0;i<_user.length;i++){\r\n            users[_user[i]].cycle = 1;\r\n            users[_user[i]].upline = _upline[i];\r\n            users[_upline[i]].referrals = users[_upline[i]].referrals.add(1);\r\n            users[_user[i]].payouts = 0;\r\n            users[_user[i]].depositAmount = _amount[i];\r\n            users[_user[i]].depositPayouts = 0;\r\n            users[_user[i]].depositTime = uint40(block.timestamp);\r\n            users[_user[i]].referalBonus = 0;\r\n            users[_user[i]].matchBonus = 0;\r\n            users[_upline[i]].totalStructure++;\r\n            users[_user[i]].totalDeposits = users[_user[i]].totalDeposits.add(_amount[i]);\r\n            emit Inject(_user[i],_upline[i],_amount[i],block.timestamp);\r\n        }\r\n    }\r\n   \r\n    function _matchBonus(address _user, uint _amount) private {\r\n        address up = users[_user].upline;\r\n        for (uint i = 1; i <= 21; i++) { // For matching bonus\r\n            if (up == address(0)) break;\r\n            if (i <= 3) {\r\n                users[up].matchBonus = users[up].matchBonus.add(_amount); \r\n                emit MatchBonus(_user, up, _amount, block.timestamp);\r\n            }\r\n            else if (i <= 6) {\r\n                if (users[up].referrals >= 2) {\r\n                    users[up].matchBonus = users[up].matchBonus.add(_amount);\r\n                    emit MatchBonus(_user, up, _amount, block.timestamp);\r\n                }\r\n            }\r\n            else if (i <= 10) {\r\n                if (users[up].referrals >= 4) {\r\n                    users[up].matchBonus = users[up].matchBonus.add(_amount);\r\n                    emit MatchBonus(_user, up, _amount, block.timestamp);\r\n                }\r\n            }\r\n            else if (i <= 14) {\r\n                if (users[up].referrals >= 8) {\r\n                    users[up].matchBonus = users[up].matchBonus.add(_amount);\r\n                    emit MatchBonus(_user, up, _amount, block.timestamp);\r\n                }\r\n            }\r\n            else if (i <= 21) {\r\n                if (users[up].referrals >= 16) {\r\n                    users[up].matchBonus = users[up].matchBonus.add(_amount);\r\n                    emit MatchBonus(_user, up, _amount, block.timestamp);\r\n                }\r\n            }\r\n            up = users[up].upline;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev withdraw: User can get amount till maximum payout reach.\r\n     * maximum payout based on(daily ROI,matchbonus)\r\n     * maximum payout limit 210 percentage\r\n     */\r\n    function withdraw() external isLock {\r\n        (uint256 to_payout, uint256 max_payout) = this.payoutOf(msg.sender);\r\n        require(msg.sender != admin1, \"SeekReward: only for users\");\r\n        require(users[msg.sender].payouts < max_payout, \"SeekReward: Full payouts\");\r\n        // Deposit payout\r\n        if (to_payout > 0) {\r\n            if (users[msg.sender].payouts.add(to_payout) > max_payout) {\r\n                to_payout = max_payout.sub(users[msg.sender].payouts);\r\n            }\r\n            users[msg.sender].depositPayouts = users[msg.sender].depositPayouts.add(to_payout);\r\n            users[msg.sender].payouts = users[msg.sender].payouts.add(to_payout);\r\n            _matchBonus(msg.sender, to_payout.mul(3e18).div(100e18));\r\n        }\r\n        // matching bonus\r\n        if (users[msg.sender].payouts < max_payout && users[msg.sender].matchBonus > 0) {\r\n            if (users[msg.sender].payouts.add(users[msg.sender].matchBonus) > max_payout) {\r\n                users[msg.sender].matchBonus = max_payout.sub(users[msg.sender].payouts);\r\n            }\r\n            users[msg.sender].payouts = users[msg.sender].payouts.add(users[msg.sender].matchBonus);\r\n            to_payout = to_payout.add(users[msg.sender].matchBonus);\r\n            users[msg.sender].matchBonus = users[msg.sender].matchBonus.sub(users[msg.sender].matchBonus);\r\n        }\r\n        totalWithdraw = totalWithdraw.add(to_payout);\r\n        token.transfer(msg.sender, to_payout); // Daily roi and matching bonus\r\n        emit Withdraw(msg.sender, to_payout, block.timestamp);\r\n\r\n        if (users[msg.sender].payouts >= max_payout) {\r\n            emit LimitReached(msg.sender, users[msg.sender].payouts, block.timestamp);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev adminWithdraw: owner invokes the function\r\n     * owner can get referbonus, matchbonus \r\n     */\r\n    function adminWithdraw() external onlyOwner {\r\n        uint amount;\r\n        if (users[admin1].referalBonus > 0) {\r\n            amount = amount.add(users[admin1].referalBonus);\r\n            users[admin1].referalBonus = 0;\r\n        }\r\n        if (users[admin1].matchBonus > 0) {\r\n            amount = amount.add(users[admin1].matchBonus);\r\n            users[admin1].matchBonus = 0;\r\n        }\r\n        token.transfer(admin1, amount); //Referal bonus and matching bonus\r\n        emit AdminEarnings(admin1, amount, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @dev maxPayoutOf: Amount calculate by 210 percentage\r\n     */\r\n    function maxPayoutOf(uint256 _amount) external pure returns(uint256) {\r\n        return _amount.mul(210).div(100);\r\n    }\r\n\r\n    /**\r\n     * @dev payoutOf: Users daily ROI and maximum payout will be show\r\n     */\r\n    function payoutOf(address _addr) external view returns(uint256 payout, uint256 max_payout) {\r\n        max_payout = this.maxPayoutOf(users[_addr].depositAmount);\r\n        if (users[_addr].depositPayouts < max_payout) {\r\n            payout = ((users[_addr].depositAmount.mul(1e18).div(100e18)).mul((block.timestamp\r\n            .sub(users[_addr].depositTime)).div(1 days))).sub(users[_addr].depositPayouts); // Daily roi\r\n            if (users[_addr].depositPayouts.add(payout) > max_payout) {\r\n                payout = max_payout.sub(users[_addr].depositPayouts);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev userInfo: Returns upline,depositTime,depositAmount,payouts,match_bonus\r\n     */\r\n    function userInfo(address _addr) external view returns(address upline, uint40 deposit_time,\r\n    uint256 deposit_amount, uint256 payouts, uint256 match_bonus) {\r\n        return (users[_addr].upline, users[_addr].depositTime, users[_addr].depositAmount,\r\n                users[_addr].payouts, users[_addr].matchBonus);\r\n    }\r\n\r\n    /**\r\n     * @dev userInfoTotals: Returns users referrals count, totalDeposit, totalStructure\r\n     */\r\n    function userInfoTotals(address _addr) external view returns(uint256 referrals,\r\n    uint256 total_deposits, uint256 total_structure) {\r\n        return (users[_addr].referrals, users[_addr].totalDeposits, users[_addr].totalStructure);\r\n    }\r\n\r\n    /**\r\n     * @dev contractInfo: Returns total users, totalDeposited, totalWithdraw\r\n     */\r\n    function contractInfo() external view returns(uint256 _total_users, uint256 _total_deposited,\r\n    uint256 _total_withdraw) {\r\n        return (totalUsers, totalDeposited, totalWithdraw);\r\n    }\r\n\r\n    /**\r\n     * @dev contractLock: For contract status\r\n     */\r\n    function contractLock(bool _lockStatus) public onlyOwner returns(bool) {\r\n        lockStatus = _lockStatus;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev failSafe: Returns transfer token\r\n     */\r\n    function failSafe(address _toUser, uint _amount) external onlyOwner returns(bool) {\r\n        require(_toUser != address(0), \"Invalid Address\");\r\n        require(token.balanceOf(address(this)) >= _amount, \"SeekReward: insufficient amount\");\r\n        token.transfer(_toUser, _amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev isContract: Returns true if account is a contract\r\n     */\r\n    function isContract(address _account) public view returns(bool) {\r\n        uint32 size;\r\n        assembly {\r\n            size:= extcodesize(_account)\r\n        }\r\n        if (size != 0)\r\n            return true;\r\n        return false;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"AdminEarnings\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"refer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"upline\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"Inject\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"LimitReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"MatchBonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Levels\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_total_users\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_total_deposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_total_withdraw\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_lockStatus\",\"type\":\"bool\"}],\"name\":\"contractLock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_upline\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_toUser\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"failSafe\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_user\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_upline\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amount\",\"type\":\"uint256[]\"}],\"name\":\"injectUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"maxPayoutOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"payoutOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max_payout\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC777\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDeposited\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalUsers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"upline\",\"type\":\"address\"},{\"internalType\":\"uint40\",\"name\":\"deposit_time\",\"type\":\"uint40\"},{\"internalType\":\"uint256\",\"name\":\"deposit_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payouts\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"match_bonus\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"userInfoTotals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"referrals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total_deposits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total_structure\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cycle\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"upline\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"referrals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payouts\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referalBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"matchBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositPayouts\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"depositTime\",\"type\":\"uint40\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStructure\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"SeekReward","CompilerVersion":"v0.6.0+commit.26b70077","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000004cb3f201e4bc7ce4d99deb93008940d3848386e60000000000000000000000004cb3f201e4bc7ce4d99deb93008940d3848386e6000000000000000000000000b128fcdf9c5e2404ccad8bb175cd0791e0b7c57f","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://73359dd000fe0bc8788d5e300aa2a4fd8b98caafa4cd9719638291050c00480d"}]}