{"status":"1","message":"OK","result":[{"SourceCode":"{\"ConflictResolution.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./ConflictResolutionInterface.sol\\\";\\nimport \\\"./MathUtil.sol\\\";\\nimport \\\"./SafeCast.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Games.sol\\\";\\n\\n\\n/**\\n * @title Conflict Resolution\\n * @dev Contract used for conflict resolution. Only needed if server or\\n * user stops responding during game session.\\n * @author dicether\\n */\\ncontract ConflictResolution is ConflictResolutionInterface, Games {\\n    using SafeCast for int;\\n    using SafeCast for uint;\\n    using SafeMath for int;\\n    using SafeMath for uint;\\n\\n    uint public constant SERVER_TIMEOUT = 6 hours;\\n    uint public constant USER_TIMEOUT = 6 hours;\\n\\n    uint public constant MIN_BET_VALUE = 1e13; /// min 0.00001 ether bet\\n    uint public constant MIN_BANKROLL = 50e18;\\n\\n    int public constant NOT_ENDED_FINE = 1e16; /// 0.01 ether\\n\\n    int public constant CONFLICT_END_FINE = 5e15; /// 0.005 ether\\n\\n    int public constant MAX_BALANCE = int(MIN_BANKROLL / 2);\\n\\n    modifier onlyValidBet(uint8 _gameType, uint _betNum, uint _betValue) {\\n        require(isValidBet(_gameType, _betNum, _betValue), \\\"inv bet\\\");\\n        _;\\n    }\\n\\n    modifier onlyValidBalance(int _balance, uint _gameStake) {\\n        require(-_gameStake.castToInt() \\u003c= _balance \\u0026\\u0026 _balance \\u003c= MAX_BALANCE, \\\"inv balance\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev constructor\\n     * @param games the games specific contracts.\\n     */\\n    constructor(address[] memory games) Games(games) public {\\n        // Nothing to do\\n    }\\n\\n    /**\\n     * @return Conflict end fine.\\n     */\\n    function conflictEndFine() public pure returns(int) {\\n        return CONFLICT_END_FINE;\\n    }\\n\\n    /**\\n     * @return Max balance.\\n     */\\n    function maxBalance() public view returns(int) {\\n        return MAX_BALANCE;\\n    }\\n\\n    /**\\n     * Calculate minimum needed house stake.\\n     */\\n    function minHouseStake(uint activeGames) public view returns(uint) {\\n        return  MathUtil.min(activeGames, 1) * MIN_BANKROLL;\\n    }\\n\\n    /**\\n     * @dev Check if bet is valid.\\n     * @param _gameType Game type.\\n     * @param _betNum Number of bet.\\n     * @param _betValue Value of bet.\\n     * @return True if bet is valid false otherwise.\\n     */\\n    function isValidBet(uint8 _gameType, uint _betNum, uint _betValue) public view returns(bool) {\\n        bool validMinBetValue = MIN_BET_VALUE \\u003c= _betValue;\\n        bool validMaxBetValue = _betValue \\u003c= Games.maxBet(_gameType, _betNum, MIN_BANKROLL);\\n        return validMinBetValue \\u0026\\u0026 validMaxBetValue;\\n    }\\n\\n\\n    /**\\n     * @dev Calculates game result and returns new balance.\\n     * @param _gameType Type of game.\\n     * @param _betNum Bet number.\\n     * @param _betValue Value of bet.\\n     * @param _balance Current balance.\\n     * @param _serverSeed Server\\u0027s seed of current round.\\n     * @param _userSeed User\\u0027s seed of current round.\\n     * @return New game session balance.\\n     */\\n    function endGameConflict(\\n        uint8 _gameType,\\n        uint _betNum,\\n        uint _betValue,\\n        int _balance,\\n        uint _stake,\\n        bytes32 _serverSeed,\\n        bytes32 _userSeed\\n    )\\n        public\\n        view\\n        onlyValidBet(_gameType, _betNum, _betValue)\\n        onlyValidBalance(_balance, _stake)\\n        returns(int)\\n    {\\n        require(_serverSeed != 0 \\u0026\\u0026 _userSeed != 0, \\\"inv seeds\\\");\\n\\n        int newBalance =  processBet(_gameType, _betNum, _betValue, _balance, _serverSeed, _userSeed);\\n\\n        // user need to pay a fee when conflict ended.\\n        // this ensures a malicious, rich user can not just generate game sessions and then wait\\n        // for us to end the game session and then confirm the session status, so\\n        // we would have to pay a high gas fee without profit.\\n        newBalance = newBalance.sub(CONFLICT_END_FINE);\\n\\n        // do not allow balance below user stake\\n        int stake = _stake.castToInt();\\n        if (newBalance \\u003c -stake) {\\n            newBalance = -stake;\\n        }\\n\\n        return newBalance;\\n    }\\n\\n    /**\\n     * @dev Force end of game if user does not respond. Only possible after a time period.\\n     * to give the user a chance to respond.\\n     * @param _gameType Game type.\\n     * @param _betNum Bet number.\\n     * @param _betValue Bet value.\\n     * @param _balance Current balance.\\n     * @param _stake User stake.\\n     * @param _endInitiatedTime Time server initiated end.\\n     * @return New game session balance.\\n     */\\n    function serverForceGameEnd(\\n        uint8 _gameType,\\n        uint _betNum,\\n        uint _betValue,\\n        int _balance,\\n        uint _stake,\\n        bytes32 _serverSeed,\\n        bytes32 _userSeed,\\n        uint _endInitiatedTime\\n    )\\n        public\\n        view\\n        onlyValidBalance(_balance, _stake)\\n        returns(int)\\n    {\\n        require(_endInitiatedTime + SERVER_TIMEOUT \\u003c= block.timestamp, \\\"too low timeout\\\");\\n        require((_gameType == 0 \\u0026\\u0026 _betNum == 0 \\u0026\\u0026 _betValue == 0 \\u0026\\u0026 _balance == 0)\\n                || isValidBet(_gameType, _betNum, _betValue), \\\"inv bet\\\");\\n\\n\\n        // if no bet was placed (cancelActiveGame) set new balance to 0\\n        int newBalance = 0;\\n\\n        // a bet was placed calculate new balance\\n        if (_gameType != 0) {\\n            newBalance = processBet(_gameType, _betNum, _betValue, _balance, _serverSeed, _userSeed);\\n        }\\n\\n        // penalize user as he didn\\u0027t end game\\n        newBalance = newBalance.sub(NOT_ENDED_FINE);\\n\\n        // do not allow balance below user stake\\n        int stake = _stake.castToInt();\\n        if (newBalance \\u003c -stake) {\\n            newBalance = -stake;\\n        }\\n\\n        return newBalance;\\n    }\\n\\n    /**\\n     * @dev Force end of game if server does not respond. Only possible after a time period\\n     * to give the server a chance to respond.\\n     * @param _gameType Game type.\\n     * @param _betNum Bet number.\\n     * @param _betValue Value of bet.\\n     * @param _balance Current balance.\\n     * @param _endInitiatedTime Time server initiated end.\\n     * @return New game session balance.\\n     */\\n    function userForceGameEnd(\\n        uint8 _gameType,\\n        uint _betNum,\\n        uint _betValue,\\n        int _balance,\\n        uint  _stake,\\n        uint _endInitiatedTime\\n    )\\n        public\\n        view\\n        onlyValidBalance(_balance, _stake)\\n        returns(int)\\n    {\\n        require(_endInitiatedTime + USER_TIMEOUT \\u003c= block.timestamp, \\\"too low timeout\\\");\\n        require((_gameType == 0 \\u0026\\u0026 _betNum == 0 \\u0026\\u0026 _betValue == 0 \\u0026\\u0026 _balance == 0)\\n                || isValidBet(_gameType, _betNum, _betValue), \\\"inv bet\\\");\\n\\n        int profit = 0;\\n        if (_gameType == 0 \\u0026\\u0026 _betNum == 0 \\u0026\\u0026 _betValue == 0 \\u0026\\u0026 _balance == 0) {\\n            // user cancelled game without playing\\n            profit = 0;\\n        } else {\\n            profit = Games.maxUserProfit(_gameType, _betNum, _betValue);\\n        }\\n\\n        // penalize server as it didn\\u0027t end game\\n        profit = profit.add(NOT_ENDED_FINE);\\n\\n        return _balance.add(profit);\\n    }\\n\\n    /**\\n     * @dev Calculate new balance after executing bet.\\n     * @param _gameType game type.\\n     * @param _betNum Bet Number.\\n     * @param _betValue Value of bet.\\n     * @param _balance Current balance.\\n     * @param _serverSeed Server\\u0027s seed\\n     * @param _userSeed User\\u0027s seed\\n     * return new balance.\\n     */\\n    function processBet(\\n        uint8 _gameType,\\n        uint _betNum,\\n        uint _betValue,\\n        int _balance,\\n        bytes32 _serverSeed,\\n        bytes32 _userSeed\\n    )\\n        public\\n        view\\n        returns (int)\\n    {\\n        uint resNum = Games.resultNumber(_gameType, _serverSeed, _userSeed, _betNum);\\n        int profit = Games.userProfit(_gameType, _betNum, _betValue, resNum);\\n        return _balance.add(profit);\\n    }\\n}\\n\"},\"ConflictResolutionInterface.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n\\n/**\\n * @title Conflict Resolution Interface\\n * @dev interface to contract used for conflict resolution. Only needed if server or\\n * user stops responding during game session. For documentation consult implementation\\n * contract.\\n * @author dicether\\n */\\ninterface ConflictResolutionInterface {\\n    function minHouseStake(uint activeGames) external view returns(uint);\\n\\n    function maxBalance() external view returns(int);\\n\\n    function conflictEndFine() external pure returns(int);\\n\\n    function isValidBet(uint8 _gameType, uint _betNum, uint _betValue) external view returns(bool);\\n\\n    function endGameConflict(\\n        uint8 _gameType,\\n        uint _betNum,\\n        uint _betValue,\\n        int _balance,\\n        uint _stake,\\n        bytes32 _serverSeed,\\n        bytes32 _userSeed\\n    )\\n        external\\n        view\\n        returns(int);\\n\\n    function serverForceGameEnd(\\n        uint8 gameType,\\n        uint _betNum,\\n        uint _betValue,\\n        int _balance,\\n        uint _stake,\\n        bytes32 _serverSeed,\\n        bytes32 _userSeed,\\n        uint _endInitiatedTime\\n    )\\n        external\\n        view\\n        returns(int);\\n\\n    function userForceGameEnd(\\n        uint8 _gameType,\\n        uint _betNum,\\n        uint _betValue,\\n        int _balance,\\n        uint _stake,\\n        uint _endInitiatedTime\\n    )\\n        external\\n        view\\n        returns(int);\\n}\\n\"},\"GameInterface.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\ninterface GameInterface {\\n    function maxBet(uint _num, uint _bankRoll) external view returns(uint);\\n\\n    function resultNumber(bytes32 _serverSeed, bytes32 _userSeed, uint _num) external view returns(uint);\\n\\n    function userProfit(uint _num, uint _betValue, uint _resultNum) external view returns(int);\\n\\n    function maxUserProfit(uint _num, uint _betValue) external view returns(int);\\n}\\n\"},\"Games.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"../SafeMath.sol\\\";\\nimport \\\"./GameInterface.sol\\\";\\n\\n\\ncontract Games {\\n    using SafeMath for int;\\n    using SafeMath for uint;\\n\\n    mapping (uint =\\u003e GameInterface) public games;\\n\\n    /**\\n     * @dev constructor\\n     * @param gameContracts addresses of different game implementations.\\n     */\\n    constructor(address[] memory gameContracts) public {\\n        for (uint i = 0; i \\u003c gameContracts.length; i++) {\\n            // set first GameInterface to 0 0 =\\u003e start with i + 1\\n            games[i + 1] = GameInterface(gameContracts[i]);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the max allowed bet for a specific game.\\n     * @param _gameType game identifier.\\n     * @param _num game specific bet number.\\n     * @param _bankRoll bank roll size.\\n     * @return max allowed bet.\\n     */\\n    function maxBet(uint8 _gameType, uint _num, uint _bankRoll) public view returns(uint) {\\n        uint maxBetVal = getGameImplementation(_gameType).maxBet(_num, _bankRoll);\\n        return maxBetVal.add(5e14).div(1e15).mul(1e15); // round to multiple of 0.001 Ether\\n    }\\n\\n    /**\\n     * @dev Calculates the result of the bet.\\n     * @param _gameType game identifier.\\n     * @param _serverSeed server seed.\\n     * @param _userSeed user seed.\\n     * @param _num game specific bet number.\\n     * @return result number.\\n     */\\n    function resultNumber(uint8 _gameType, bytes32 _serverSeed, bytes32 _userSeed, uint _num) public view returns(uint) {\\n        return getGameImplementation(_gameType).resultNumber(_serverSeed, _userSeed, _num);\\n    }\\n\\n    /**\\n     * @dev Calculates the user profit for the bet.\\n     * @param _gameType game identifier.\\n     * @param _num game specific bet number.\\n     * @param _betValue bet value.\\n     * @param _resultNum bet result.\\n     * @return user profit.\\n     */\\n    function userProfit(uint8 _gameType, uint _num, uint _betValue, uint _resultNum) public view returns(int) {\\n        uint betValue = _betValue / 1e9; // convert to gwei\\n\\n        int res = getGameImplementation(_gameType).userProfit(_num, betValue, _resultNum);\\n\\n        return res.mul(1e9); // convert to wei\\n    }\\n\\n    /**\\n     * @dev Calculates the maximal posible user profit for the given bet.\\n     * @param _gameType game identifier.\\n     * @param _num game specific bet number e.g. 0 or 1 for RollADice.\\n     * @param _betValue bet value.\\n     * @return max user profit.\\n     */\\n    function maxUserProfit(uint8 _gameType, uint _num, uint _betValue) public view returns(int) {\\n        uint betValue = _betValue / 1e9; // convert to gwei\\n\\n        int res = getGameImplementation(_gameType).maxUserProfit(_num, betValue);\\n\\n        return res.mul(1e9); // convert to wei\\n    }\\n\\n    /**\\n     * @dev Returns the game implementation contract for the given game type.\\n     * @param _gameType game identifier.\\n     * @return game implementation contract.\\n     */\\n    function getGameImplementation(uint8 _gameType) private view returns(GameInterface) {\\n        require(games[_gameType] != GameInterface(0), \\\"Invalid game type\\\");\\n        return games[_gameType];\\n\\n    }\\n}\\n\"},\"MathUtil.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n\\n/**\\n * @title Math utils\\n * @author dicether\\n */\\nlibrary MathUtil {\\n    /**\\n     * @dev Returns the absolute value of _val.\\n     * @param _val value\\n     * @return The absolute value of _val.\\n     */\\n    function abs(int _val) internal pure returns(uint) {\\n        if (_val \\u003c 0) {\\n            return uint(-_val);\\n        } else {\\n            return uint(_val);\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculate maximum.\\n     */\\n    function max(uint _val1, uint _val2) internal pure returns(uint) {\\n        return _val1 \\u003e= _val2 ? _val1 : _val2;\\n    }\\n\\n    /**\\n     * @dev Calculate minimum.\\n     */\\n    function min(uint _val1, uint _val2) internal pure returns(uint) {\\n        return _val1 \\u003c= _val2 ? _val1 : _val2;\\n    }\\n}\\n\"},\"SafeCast.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nlibrary SafeCast {\\n    /**\\n     * Cast unsigned a to signed a.\\n     */\\n    function castToInt(uint a) internal pure returns(int) {\\n        assert(a \\u003c (1 \\u003c\\u003c 255));\\n        return int(a);\\n    }\\n\\n    /**\\n     * Cast signed a to unsigned a.\\n     */\\n    function castToUint(int a) internal pure returns(uint) {\\n        assert(a \\u003e= 0);\\n        return uint(a);\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error.\\n * From zeppelin-solidity\\n */\\nlibrary SafeMath {\\n\\n    /**\\n    * @dev Multiplies two unsigned integers, throws on overflow.\\n    */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        // Gas optimization: this is cheaper than asserting \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        c = a * b;\\n        assert(c / a == b);\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Multiplies two signed integers, throws on overflow.\\n    */\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\n        // Gas optimization: this is cheaper than asserting \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n        int256 c = a * b;\\n        assert(c / a == b);\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Integer division of two unsigned integers, truncating the quotient.\\n    */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // assert(b \\u003e 0); // Solidity automatically throws when dividing by 0\\n        // uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n        return a / b;\\n    }\\n\\n    /**\\n    * @dev Integer division of two signed integers, truncating the quotient.\\n    */\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\n        // assert(b \\u003e 0); // Solidity automatically throws when dividing by 0\\n        // Overflow only happens when the smallest negative int is multiplied by -1.\\n        int256 INT256_MIN = int256((uint256(1) \\u003c\\u003c 255));\\n        assert(a != INT256_MIN || b != - 1);\\n        return a / b;\\n    }\\n\\n    /**\\n    * @dev Subtracts two unsigned integers, throws on overflow (i.e. if subtrahend is greater than minuend).\\n    */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        assert(b \\u003c= a);\\n        return a - b;\\n    }\\n\\n    /**\\n    * @dev Subtracts two signed integers, throws on overflow.\\n    */\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a - b;\\n        assert((b \\u003e= 0 \\u0026\\u0026 c \\u003c= a) || (b \\u003c 0 \\u0026\\u0026 c \\u003e a));\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Adds two unsigned integers, throws on overflow.\\n    */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        c = a + b;\\n        assert(c \\u003e= a);\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Adds two signed integers, throws on overflow.\\n    */\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a + b;\\n        assert((b \\u003e= 0 \\u0026\\u0026 c \\u003e= a) || (b \\u003c 0 \\u0026\\u0026 c \\u003c a));\\n        return c;\\n    }\\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"games\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONFLICT_END_FINE\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_BALANCE\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_BANKROLL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_BET_VALUE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NOT_ENDED_FINE\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SERVER_TIMEOUT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"USER_TIMEOUT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"conflictEndFine\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_gameType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_betNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_betValue\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"_balance\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"_stake\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_serverSeed\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_userSeed\",\"type\":\"bytes32\"}],\"name\":\"endGameConflict\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"games\",\"outputs\":[{\"internalType\":\"contract GameInterface\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_gameType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_betNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_betValue\",\"type\":\"uint256\"}],\"name\":\"isValidBet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxBalance\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_gameType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_num\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bankRoll\",\"type\":\"uint256\"}],\"name\":\"maxBet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_gameType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_num\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_betValue\",\"type\":\"uint256\"}],\"name\":\"maxUserProfit\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"activeGames\",\"type\":\"uint256\"}],\"name\":\"minHouseStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_gameType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_betNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_betValue\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"_balance\",\"type\":\"int256\"},{\"internalType\":\"bytes32\",\"name\":\"_serverSeed\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_userSeed\",\"type\":\"bytes32\"}],\"name\":\"processBet\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_gameType\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_serverSeed\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_userSeed\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_num\",\"type\":\"uint256\"}],\"name\":\"resultNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_gameType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_betNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_betValue\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"_balance\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"_stake\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_serverSeed\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_userSeed\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_endInitiatedTime\",\"type\":\"uint256\"}],\"name\":\"serverForceGameEnd\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_gameType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_betNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_betValue\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"_balance\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"_stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endInitiatedTime\",\"type\":\"uint256\"}],\"name\":\"userForceGameEnd\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_gameType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_num\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_betValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_resultNum\",\"type\":\"uint256\"}],\"name\":\"userProfit\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ConflictResolution","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000070000000000000000000000000210cdefd7f06cd44d93d054b5f597d834cfaed70000000000000000000000007502ebf9c736fbc72a2492cd515660dce14dab5a0000000000000000000000005db7b2ca5ee413d78960a1ae62ba053a3aeb1d790000000000000000000000000d0af3ddd5fdabae72859bfb6a2135a7349cb820000000000000000000000000db7b25bc934d815af76aba0beb9b047f36e891c2000000000000000000000000efca63a6e6fb1d9e7d1e04be8949efbc999f17b70000000000000000000000007ec102b705437adfe4420cc6c58c336a3589cfa5","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"bzzr://70b43345088cfd6bf5066d2bc08775f4de77f584a57e5e9f97b6fb352e9ee71e"}]}