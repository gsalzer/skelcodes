{"status":"1","message":"OK","result":[{"SourceCode":"\"\"\"\r\n@title Greenwood Controller\r\n@notice An entry point for the Greenwood Protocol\r\n@author Greenwood Labs\r\n\"\"\"\r\n\r\n# define the interfaces used by the contract\r\ninterface ESCROW:\r\n    def borrow(_borrow_ticker: String[10], _collateral_ticker: String[10], _borrow_context: AssetContext, _collateral_context: AssetContext, _amount: uint256, _borrower: address, _calculator: address, _collateralization_ratio: uint256, _store: address, _version: String[11]): payable\r\n    def repay(_borrow_ticker: String[10], _collateral_ticker: String[10], _amount: uint256, _calculator: address, _loan_key: bytes32, _store: address, _version: String[11]): payable\r\n    def addCollateral(_collateral_ticker: String[10], _amount: uint256, _depositor: address, _loan_key: bytes32, _store: address, _version: String[11]): payable\r\n    def withdrawCollateral(_borrow_ticker: String[10], _collateral_ticker: String[10], _amount: uint256, _calculator: address, _loan_key: bytes32,  _store: address, _version: String[11]): nonpayable\r\n\r\ninterface LIQUIDATOR:\r\n    def liquidate(_borrow_ticker: String[10], _collateral_ticker: String[10], _aave_V2_escrow: address, _compound_escrow: address, _key_count: uint256, _liquidator: address, _loan_keys: bytes32[100], _aave_v2_loan_keys: bytes32[100], _compound_loan_keys: bytes32[100], _store: address, _version: String[11]): nonpayable\r\n\r\ninterface REGISTRY:\r\n    def getAddress(_contract: String[20], _version: String[11], ) -> address: nonpayable\r\n    def governance() -> address: nonpayable\r\n\r\ninterface ROUTER:\r\n    def split(_borrow_ticker: String[10], _collateral_ticker: String[10], _amount: uint256, _protocol: String[10], _store: address, _version: String[11]) -> Split: nonpayable\r\n\r\ninterface STORE:\r\n    def getAssetContext(_ticker: String[10]) -> AssetContext: view\r\n    def recordLoan(_borrower: address, _borrow_asset: address, _collateral_asset: address, _collateralization_ratio: uint256, _collateral_locked: uint256, _index: uint256, _principal: uint256, _protocol: String[10], _version: String[11]): nonpayable\r\n    def updateLoan(_collateral_locked: uint256, _index: uint256, _loan_key: bytes32, _outstanding: uint256, _version: String[11]): nonpayable\r\n    def getLoan(_loan_key: bytes32) -> Loan: view\r\n    def getLoanProtocol(_loan_key: bytes32) -> String[10]: view\r\n\r\n# define the events used by the contract\r\nevent SetRegistry:\r\n    previousRegistry: address\r\n    newRegistry: address\r\n    governance: address\r\n    blockNumber: uint256\r\n\r\nevent TogglePauseBorrow:\r\n    previousIsBorrowPaused: bool\r\n    newIsBorrowPaused: bool\r\n    governance: address\r\n    blockNumber: uint256\r\n\r\n# define the structs used by the contract\r\nstruct AssetContext:\r\n    aToken: address\r\n    aaveV2PriceFeed: address\r\n    aaveV2LendingPool: address\r\n    cToken: address\r\n    compoundPriceFeed: address\r\n    comptroller: address\r\n    decimals: uint256\r\n    underlying: address\r\n\r\nstruct Loan:\r\n    collateralAsset: address\r\n    borrowAsset: address\r\n    outstanding: uint256\r\n    collateralizationRatio: uint256\r\n    collateralLocked: uint256\r\n    borrower: address\r\n    lastBorrowIndex: uint256\r\n    repaymentTime: uint256\r\n\r\nstruct Split:\r\n    compoundSplit: uint256\r\n    aaveV2Split: uint256\r\n    borrowContext: AssetContext\r\n    collateralContext: AssetContext\r\n\r\n# define the storage variables used by the contract\r\nisBorrowPaused: public(bool)\r\nregistry: public(address)\r\n\r\n@external\r\ndef __init__(_registry: address):\r\n    \"\"\"\r\n    @notice Contract constructor\r\n    @param _registry The address of the Greenwood Registry\r\n    \"\"\"\r\n\r\n    # set the address of the Escrow\r\n    self.registry = _registry\r\n\r\n@internal\r\ndef isGovernance(_caller: address, _role: String[20]) -> bool:\r\n    \"\"\"\r\n    @notice Method for role-based security\r\n    @param _caller The address that called the permissioned method\r\n    @param _role The requested authorization level\r\n    @return True if the caller is the Governance, False otherwise\r\n    \"\"\"\r\n\r\n    # check if the requested role is \"governance\"\r\n    if keccak256(_role) == keccak256(\"governance\"):\r\n\r\n        # get the address of the Governance from the Registry\r\n        governance: address = REGISTRY(self.registry).governance()\r\n\r\n        # return the equality comparison boolean\r\n        return governance == _caller\r\n\r\n    # catch extraneous role arguments\r\n    else:\r\n\r\n        # revert\r\n        raise \"Unhandled role argument\"\r\n\r\n@external\r\n@payable\r\n@nonreentrant(\"controller_lock\")\r\ndef borrow(_borrow_ticker: String[10], _collateral_ticker: String[10], _amount: uint256, _collateralization_ratio: uint256, _protocol: String[10], _version: String[11]):\r\n    \"\"\"\r\n    @notice Borrow assets from AaveV2 or Compound at the lowest instantaneous APR\r\n    @param _borrow_ticker The ticker string of the asset that is being borrowed\r\n    @param _collateral_ticker The ticker string of the asset that is being used as collateral\r\n    @param _amount The amount of asset being borrowed scaled by the asset's decimals\r\n    @param _collateralization_ratio The collateralization ratio for the loan\r\n    @param _protocol The name of the underlying lending protocol for the loan\r\n    @param _version The version of the Greenwood protocol to use\r\n    \"\"\"\r\n\r\n    # require that borrowing is not paused\r\n    assert self.isBorrowPaused == False, \"Borrowing is paused\"\r\n\r\n    # require that the collateralization ratio is at least 100%\r\n    assert _collateralization_ratio >= 100, \"Collateralization ratio too low\"\r\n\r\n    # cache the Registry address into memory\r\n    cachedRegistry: address = self.registry\r\n\r\n    # get the addresses of the Greenwood Router and Store for the specified version from the Registry\r\n    store: address = REGISTRY(cachedRegistry).getAddress(\"store\", _version)\r\n    router: address = REGISTRY(cachedRegistry).getAddress(\"router\", _version)\r\n\r\n    # find the protocol with the lowest instantaneous APR\r\n    split: Split = ROUTER(router).split(_borrow_ticker, _collateral_ticker, _amount, _protocol, store, _version)\r\n\r\n    # check if the loan should be routed to Aave V2\r\n    if split.aaveV2Split == 100 and split.compoundSplit == 0:\r\n\r\n        # get the addresses of the Greenwood Aave V2 Escrow and Calculator for the specified version from the Registry\r\n        aaveV2Escrow: address = REGISTRY(cachedRegistry).getAddress(\"aaveV2Escrow\", _version)\r\n        aaveV2Calculator: address = REGISTRY(cachedRegistry).getAddress(\"aaveV2Calculator\", _version)\r\n\r\n        # call borrow() on the Aave V2 Escrow to initiate the borrow\r\n        ESCROW(aaveV2Escrow).borrow(_borrow_ticker, _collateral_ticker, split.borrowContext, split.collateralContext, _amount, msg.sender, aaveV2Calculator, _collateralization_ratio, store, _version)\r\n\r\n    # check if the loan should be routed to Compound\r\n    elif split.compoundSplit == 100 and split.aaveV2Split == 0:\r\n\r\n        # get the addresses of the Greenwood Compound Escrow and Calculator for the specified version from the Registry\r\n        compoundEscrow: address = REGISTRY(cachedRegistry).getAddress(\"compoundEscrow\", _version)\r\n        compoundCalculator: address = REGISTRY(cachedRegistry).getAddress(\"compoundCalculator\", _version)\r\n\r\n        # call borrow() on the Compound Escrow to initiate the borrow\r\n        ESCROW(compoundEscrow).borrow(_borrow_ticker, _collateral_ticker, split.borrowContext, split.collateralContext, _amount, msg.sender, compoundCalculator, _collateralization_ratio, store, _version, value=msg.value)\r\n\r\n    # catch unsupported borrow splits\r\n    else:\r\n\r\n        # revert\r\n        raise \"Unhandled split values for borrow\"\r\n         \r\n@external\r\n@payable\r\n@nonreentrant(\"controller_lock\")\r\ndef repay(_borrow_ticker: String[10], _collateral_ticker: String[10], _amount: uint256, _loan_key: bytes32, _version: String[11]):\r\n    \"\"\"\r\n    @notice Repay borrowed assets to Aave V2 or Compound\r\n    @param _borrow_ticker The ticker string of the asset that was being borrowed\r\n    @param _collateral_ticker The ticker string of the asset that is being used as collateral\r\n    @param _amount The amount of the repayment scaled by the asset's decimals\r\n    @param _loan_key The uinque identifier for the loan\r\n    @param _version The version of the Greenwood protocol to use\r\n    @dev Passing 2 ** 256 - 1 as _amount triggers a full repayment\r\n    \"\"\"\r\n\r\n    # cache the Registry address into memory\r\n    cachedRegistry: address = self.registry\r\n\r\n    # get the addresses of the Greenwood Store for the specified version from the Registry\r\n    store: address = REGISTRY(cachedRegistry).getAddress(\"store\", _version)\r\n\r\n    # get the loan protocol from the Store\r\n    protocol: String[10] = STORE(store).getLoanProtocol(_loan_key)\r\n\r\n    # require that a protocol string was returned\r\n    assert keccak256(protocol) != keccak256(\"\"), \"No loan protocol returned from the Store\"\r\n\r\n    # check if the loan was originated with Aave V2\r\n    if keccak256(protocol) == keccak256(\"aavev2\"):\r\n\r\n        # get the addresses of the Greenwood Aave V2 Escrow and Calculator for the specified version from the Registry\r\n        aaveV2Escrow: address = REGISTRY(cachedRegistry).getAddress(\"aaveV2Escrow\", _version)\r\n        aaveV2Calculator: address = REGISTRY(cachedRegistry).getAddress(\"aaveV2Calculator\", _version)\r\n\r\n        # call repay() on Escrow to initiate the repayment of the loan\r\n        ESCROW(aaveV2Escrow).repay(_borrow_ticker, _collateral_ticker, _amount, aaveV2Calculator, _loan_key, store, _version)\r\n    \r\n    # check if the loan was originated with Compound\r\n    elif keccak256(protocol) == keccak256(\"compound\"):\r\n\r\n        # get the addresses of the Greenwood Compound escrow and Calculator for the specified version from the Registry\r\n        compoundEscrow: address = REGISTRY(cachedRegistry).getAddress(\"compoundEscrow\", _version)\r\n        compoundCalculator: address = REGISTRY(cachedRegistry).getAddress(\"compoundCalculator\", _version)\r\n\r\n        # call repay() on Escrow to initiate the repayment of the loan\r\n        ESCROW(compoundEscrow).repay(_borrow_ticker, _collateral_ticker, _amount, compoundCalculator, _loan_key, store, _version, value=msg.value)\r\n\r\n    # catch unsupported lending protocols\r\n    else:\r\n\r\n        # revert\r\n        raise \"Unhandled protocol for repay\"\r\n\r\n@external\r\n@payable\r\n@nonreentrant(\"controller_lock\")\r\ndef addCollateral(_collateral_ticker: String[10], _amount: uint256, _loan_key: bytes32, _version: String[11]):\r\n    \"\"\"\r\n    @notice Add collateral to an underlying lending protocol\r\n    @param _collateral_ticker The ticker string of the asset that is being used as collateral\r\n    @param _amount The amount of the deposit scaled by the asset's decimals\r\n    @param _loan_key The uinque identifier for the loan\r\n    @param _version The version of the Greenwood protocol to use\r\n    \"\"\"\r\n\r\n    # cache the Registry address into memory\r\n    cachedRegistry: address = self.registry\r\n\r\n    # get the address of the Greenwood Store for the specified version from the Registry\r\n    store: address = REGISTRY(cachedRegistry).getAddress(\"store\", _version)\r\n\r\n    # get the loan protocol from the Store\r\n    protocol: String[10] = STORE(store).getLoanProtocol(_loan_key)\r\n\r\n    # require that a protocol string was returned\r\n    assert keccak256(protocol) != keccak256(\"\"), \"No loan protocol returned from the Store\"\r\n\r\n    # check if the loan was originated with Aave V2\r\n    if keccak256(protocol) == keccak256(\"aavev2\"):\r\n\r\n        # get the address of the Greenwood Aave V2 Escrow for the specified version from the Registry\r\n        aaveV2Escrow: address = REGISTRY(cachedRegistry).getAddress(\"aaveV2Escrow\", _version)\r\n\r\n        # call addCollateral() on the Aave V2 Escrow to initiate the addition of collateral\r\n        ESCROW(aaveV2Escrow).addCollateral(_collateral_ticker, _amount, msg.sender, _loan_key, store, _version)\r\n\r\n    # check if the loan was originated with Compound\r\n    elif keccak256(protocol) == keccak256(\"compound\"):\r\n\r\n        # get the address of the Greenwood Compound Escrow for the specified version from the Registry\r\n        compoundEscrow: address = REGISTRY(cachedRegistry).getAddress(\"compoundEscrow\", _version)\r\n\r\n        # call addCollateral() on the Compound Escrow to initiate the addition of collateral\r\n        ESCROW(compoundEscrow).addCollateral(_collateral_ticker, _amount, msg.sender, _loan_key, store, _version, value=msg.value)\r\n\r\n    # catch unsupported lending protocols\r\n    else:\r\n\r\n        # revert\r\n        raise \"Unhandled protocol for addCollateral\"\r\n\r\n@external\r\n@nonreentrant(\"controller_lock\")\r\ndef withdrawCollateral(_borrow_ticker: String[10], _collateral_ticker: String[10], _amount: uint256, _loan_key: bytes32, _version: String[11]):\r\n    \"\"\"\r\n    @notice Withdraw collateral from an underlying lending protocol\r\n    @param _borrow_ticker The ticker string of the asset that was borrowed\r\n    @param _collateral_ticker The ticker string of the asset that is being used as collateral\r\n    @param _amount The amount of the withdrawal scaled by the asset's decimals\r\n    @param _loan_key The uinque identifier for the loan\r\n    @param _version The version of the Greenwood protocol to use\r\n    \"\"\"\r\n\r\n    # cache the Registry address into memory\r\n    cachedRegistry: address = self.registry\r\n\r\n    # get the address of the Greenwood Store for the specified version from the Registry\r\n    store: address = REGISTRY(cachedRegistry).getAddress(\"store\", _version)\r\n\r\n    # get the loan protocol from the Store\r\n    protocol: String[10] = STORE(store).getLoanProtocol(_loan_key)\r\n\r\n    # require that a protocol string was returned\r\n    assert keccak256(protocol) != keccak256(\"\"), \"No loan protocol returned from the Store\"\r\n\r\n    # check if the loan was originated with Aave V2\r\n    if keccak256(protocol) == keccak256(\"aavev2\"):\r\n\r\n        # get the addresses of the Greenwood Aave V2 Escrow and Calculator for the specified version from the Registry\r\n        aaveV2Escrow: address = REGISTRY(cachedRegistry).getAddress(\"aaveV2Escrow\", _version)\r\n        aaveV2Calculator: address = REGISTRY(cachedRegistry).getAddress(\"aaveV2Calculator\", _version)\r\n\r\n        # call withdrawCollateral() on the Aave V2 Escrow to initiate the withdrawal of collateral\r\n        ESCROW(aaveV2Escrow).withdrawCollateral(_borrow_ticker, _collateral_ticker, _amount, aaveV2Calculator, _loan_key, store, _version)\r\n\r\n    # check if the loan was originated with Compound\r\n    elif keccak256(protocol) == keccak256(\"compound\"):\r\n\r\n        # get the addresses of the Greenwood Compound Escrow and Calculator for the specified version from the Registry\r\n        compoundEscrow: address = REGISTRY(cachedRegistry).getAddress(\"compoundEscrow\", _version)\r\n        compoundCalculator: address = REGISTRY(cachedRegistry).getAddress(\"compoundCalculator\", _version)\r\n\r\n        # call withdrawCollateral() on the Compound Escrow to initiate the withdrawal of collateral\r\n        ESCROW(compoundEscrow).withdrawCollateral(_borrow_ticker, _collateral_ticker, _amount, compoundCalculator, _loan_key, store, _version)\r\n    \r\n    # catch unsupported protocols\r\n    else:\r\n        raise \"Unhandled protocol for withdrawCollateral\"\r\n\r\n@external\r\n@payable\r\n@nonreentrant(\"controller_lock\")\r\ndef liquidate(_borrow_ticker: String[10], _collateral_ticker: String[10], _key_count: uint256, _loan_keys: bytes32[100], _version: String[11]):\r\n    \"\"\"\r\n    @notice Liquidate undercollateralized loans    \r\n    @param _borrow_ticker The ticker string of the asset that was borrowed\r\n    @param _collateral_ticker The ticker string of the asset that is being used as collateral\r\n    @param _key_count The number of uinque identifiers in the _loan_keys array\r\n    @param _loan_keys The uinque identifiers for the loans\r\n    @param _version The version of the Greenwood protocol to use\r\n    \"\"\"\r\n\r\n    # require that the key count is less than or equal to the max length of the loan keys array\r\n    assert _key_count <= 100 and _key_count > 0, \"Key count must be less than or equal to 100 and greater than 0\"\r\n\r\n    # cache the Registry address into memory\r\n    cachedRegistry: address = self.registry\r\n\r\n    # get the addresses of the Greenwood Store for the specified version from the Registry\r\n    store: address = REGISTRY(cachedRegistry).getAddress(\"store\", _version)\r\n\r\n    # get the addresses of the Greenwood Liquidator for the specified version from the Registry\r\n    liquidator: address = REGISTRY(cachedRegistry).getAddress(\"liquidator\", _version)\r\n\r\n    # get the address of the Greenwood Aave V2 Escrow from the Registry\r\n    aaveV2Escrow: address = REGISTRY(cachedRegistry).getAddress(\"aaveV2Escrow\", _version)\r\n\r\n    # get the addresso f the Greenwood Compound Escrow from the Registry\r\n    compoundEscrow: address = REGISTRY(cachedRegistry).getAddress(\"compoundEscrow\", _version)\r\n\r\n    # call liquidate() on the Liquidator\r\n    LIQUIDATOR(liquidator).liquidate(_borrow_ticker, _collateral_ticker, aaveV2Escrow, compoundEscrow, _key_count, msg.sender, _loan_keys, empty(bytes32[100]), empty(bytes32[100]), store, _version)\r\n\r\n@external\r\n@nonreentrant(\"controller_lock\")\r\ndef togglePauseBorrow():\r\n    \"\"\"\r\n    @notice Pause and unpause the borrow method\r\n    @dev Only the Controller governance can call this method\r\n    \"\"\"\r\n\r\n    # assert that the method caller is the Governance\r\n    assert self.isGovernance(msg.sender, \"governance\") == True, \"Only Governance can call this method\"\r\n\r\n    # get the previous isBorrowPaused\r\n    previousIsBorrowPaused: bool = self.isBorrowPaused\r\n\r\n    # set the isBorrowPaused bool to be the negation of the current value\r\n    self.isBorrowPaused = not self.isBorrowPaused\r\n\r\n    # emit a TogglePauseBorrow event\r\n    log TogglePauseBorrow(previousIsBorrowPaused, not previousIsBorrowPaused, msg.sender, block.number)\r\n\r\n@external\r\n@nonreentrant(\"controller_lock\")\r\ndef setRegistry(_new_registry: address):\r\n    \"\"\"\r\n    @notice Updates the address of the Registry\r\n    @param _new_registry The address of the new Greenwood Registry\r\n    @dev Only the Governance can call this method\r\n    @dev Only call this method with a valid Greenwood Registry or subsequent calls will fail!\r\n    \"\"\"\r\n\r\n    # require that the method caller is the Governance\r\n    assert self.isGovernance(msg.sender, \"governance\") == True, \"Only Governance can call this method\"\r\n\r\n    # get the previous Registry\r\n    previousRegistry: address = self.registry\r\n\r\n    # update the address of the Registry\r\n    self.registry = _new_registry\r\n\r\n    # emit a SetRegistry event\r\n    log SetRegistry(previousRegistry, _new_registry, msg.sender, block.number)","ABI":"[{\"name\":\"SetRegistry\",\"inputs\":[{\"type\":\"address\",\"name\":\"previousRegistry\",\"indexed\":false},{\"type\":\"address\",\"name\":\"newRegistry\",\"indexed\":false},{\"type\":\"address\",\"name\":\"governance\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"blockNumber\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"TogglePauseBorrow\",\"inputs\":[{\"type\":\"bool\",\"name\":\"previousIsBorrowPaused\",\"indexed\":false},{\"type\":\"bool\",\"name\":\"newIsBorrowPaused\",\"indexed\":false},{\"type\":\"address\",\"name\":\"governance\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"blockNumber\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_registry\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"name\":\"borrow\",\"outputs\":[],\"inputs\":[{\"type\":\"string\",\"name\":\"_borrow_ticker\"},{\"type\":\"string\",\"name\":\"_collateral_ticker\"},{\"type\":\"uint256\",\"name\":\"_amount\"},{\"type\":\"uint256\",\"name\":\"_collateralization_ratio\"},{\"type\":\"string\",\"name\":\"_protocol\"},{\"type\":\"string\",\"name\":\"_version\"}],\"stateMutability\":\"payable\",\"type\":\"function\",\"gas\":116286},{\"name\":\"repay\",\"outputs\":[],\"inputs\":[{\"type\":\"string\",\"name\":\"_borrow_ticker\"},{\"type\":\"string\",\"name\":\"_collateral_ticker\"},{\"type\":\"uint256\",\"name\":\"_amount\"},{\"type\":\"bytes32\",\"name\":\"_loan_key\"},{\"type\":\"string\",\"name\":\"_version\"}],\"stateMutability\":\"payable\",\"type\":\"function\",\"gas\":107244},{\"name\":\"addCollateral\",\"outputs\":[],\"inputs\":[{\"type\":\"string\",\"name\":\"_collateral_ticker\"},{\"type\":\"uint256\",\"name\":\"_amount\"},{\"type\":\"bytes32\",\"name\":\"_loan_key\"},{\"type\":\"string\",\"name\":\"_version\"}],\"stateMutability\":\"payable\",\"type\":\"function\",\"gas\":103006},{\"name\":\"withdrawCollateral\",\"outputs\":[],\"inputs\":[{\"type\":\"string\",\"name\":\"_borrow_ticker\"},{\"type\":\"string\",\"name\":\"_collateral_ticker\"},{\"type\":\"uint256\",\"name\":\"_amount\"},{\"type\":\"bytes32\",\"name\":\"_loan_key\"},{\"type\":\"string\",\"name\":\"_version\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":73399},{\"name\":\"liquidate\",\"outputs\":[],\"inputs\":[{\"type\":\"string\",\"name\":\"_borrow_ticker\"},{\"type\":\"string\",\"name\":\"_collateral_ticker\"},{\"type\":\"uint256\",\"name\":\"_key_count\"},{\"type\":\"bytes32[100]\",\"name\":\"_loan_keys\"},{\"type\":\"string\",\"name\":\"_version\"}],\"stateMutability\":\"payable\",\"type\":\"function\",\"gas\":78944},{\"name\":\"togglePauseBorrow\",\"outputs\":[],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":100258},{\"name\":\"setRegistry\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_new_registry\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":99524},{\"name\":\"isBorrowPaused\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1391},{\"name\":\"registry\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1421}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.3","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"0000000000000000000000001ddbb7a21905c6a8dbd76b20b7c6b3a55d1af24f","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":""}]}