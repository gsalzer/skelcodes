{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.26;\r\n\r\nlibrary ERC20AsmFn {\r\n\r\n    function isContract(address addr) internal view {\r\n        assembly {\r\n            if iszero(extcodesize(addr)) { revert(0, 0) }\r\n        }\r\n    }\r\n\r\n    function handleReturnData() internal pure returns (bool result) {\r\n        assembly {\r\n            switch returndatasize()\r\n            case 0 { // not a std erc20\r\n                result := 1\r\n            }\r\n            case 32 { // std erc20\r\n                returndatacopy(0, 0, 32)\r\n                result := mload(0)\r\n            }\r\n            default { // anything else, should revert for safety\r\n                revert(0, 0)\r\n            }\r\n        }\r\n    }\r\n\r\n    function asmTransfer(address _erc20Addr, address _to, uint256 _value) internal returns (bool result) {\r\n\r\n        // Must be a contract addr first!\r\n        isContract(_erc20Addr);\r\n\r\n        // call return false when something wrong\r\n        require(_erc20Addr.call(bytes4(keccak256(\"transfer(address,uint256)\")), _to, _value));\r\n\r\n        // handle returndata\r\n        return handleReturnData();\r\n    }\r\n\r\n    function asmTransferFrom(address _erc20Addr, address _from, address _to, uint256 _value) internal returns (bool result) {\r\n\r\n        // Must be a contract addr first!\r\n        isContract(_erc20Addr);\r\n\r\n        // call return false when something wrong\r\n        require(_erc20Addr.call(bytes4(keccak256(\"transferFrom(address,address,uint256)\")), _from, _to, _value));\r\n\r\n        // handle returndata\r\n        return handleReturnData();\r\n    }\r\n\r\n    function asmApprove(address _erc20Addr, address _spender, uint256 _value) internal returns (bool result) {\r\n\r\n        // Must be a contract addr first!\r\n        isContract(_erc20Addr);\r\n\r\n        // call return false when something wrong\r\n        require(_erc20Addr.call(bytes4(keccak256(\"approve(address,uint256)\")), _spender, _value));\r\n\r\n        // handle returndata\r\n        return handleReturnData();\r\n    }\r\n}\r\n\r\n\r\ninterface ERC20 {\r\n     function balanceOf(address who) external view returns (uint256);\r\n     function transfer(address _to, uint256 _value) external returns (bool success);\r\n     function transferFrom(address _from, address _to, uint256 _value) external  returns (bool success);\r\n     function approve(address _spender, uint256 _value) external returns (bool success);\r\n}\r\n\r\n\r\n// File: contracts/EternalStorage.sol\r\n\r\n// Roman Storm Multi Sender\r\n// To Use this Dapp: https://rstormsf.github.io/multisender\r\npragma solidity 0.4.26;\r\n\r\n\r\n/**\r\n * @title EternalStorage\r\n * @dev This contract holds all the necessary state variables to carry out the storage of any contract.\r\n */\r\ncontract EternalStorage {\r\n\r\n    mapping(bytes32 => uint256) internal uintStorage;\r\n    mapping(bytes32 => string) internal stringStorage;\r\n    mapping(bytes32 => address) internal addressStorage;\r\n    mapping(bytes32 => bytes) internal bytesStorage;\r\n    mapping(bytes32 => bool) internal boolStorage;\r\n    mapping(bytes32 => int256) internal intStorage;\r\n\r\n}\r\n\r\n// File: contracts/UpgradeabilityOwnerStorage.sol\r\n\r\n// Roman Storm Multi Sender\r\n// To Use this Dapp: https://rstormsf.github.io/multisender\r\npragma solidity 0.4.26;\r\n\r\n\r\n/**\r\n * @title UpgradeabilityOwnerStorage\r\n * @dev This contract keeps track of the upgradeability owner\r\n */\r\ncontract UpgradeabilityOwnerStorage {\r\n    // Owner of the contract\r\n    address private _upgradeabilityOwner;\r\n\r\n    /**\r\n    * @dev Tells the address of the owner\r\n    * @return the address of the owner\r\n    */\r\n    function upgradeabilityOwner() public view returns (address) {\r\n        return _upgradeabilityOwner;\r\n    }\r\n\r\n    /**\r\n    * @dev Sets the address of the owner\r\n    */\r\n    function setUpgradeabilityOwner(address newUpgradeabilityOwner) internal {\r\n        _upgradeabilityOwner = newUpgradeabilityOwner;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/UpgradeabilityStorage.sol\r\n\r\n// Roman Storm Multi Sender\r\n// To Use this Dapp: https://rstormsf.github.io/multisender\r\npragma solidity 0.4.26;\r\n\r\n\r\n/**\r\n * @title UpgradeabilityStorage\r\n * @dev This contract holds all the necessary state variables to support the upgrade functionality\r\n */\r\ncontract UpgradeabilityStorage {\r\n    // Version name of the current implementation\r\n    string internal _version;\r\n\r\n    // Address of the current implementation\r\n    address internal _implementation;\r\n\r\n    /**\r\n    * @dev Tells the version name of the current implementation\r\n    * @return string representing the name of the current version\r\n    */\r\n    function version() public view returns (string) {\r\n        return _version;\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the address of the current implementation\r\n    * @return address of the current implementation\r\n    */\r\n    function implementation() public view returns (address) {\r\n        return _implementation;\r\n    }\r\n}\r\n\r\n// File: contracts/OwnedUpgradeabilityStorage.sol\r\n\r\n// Roman Storm Multi Sender\r\n// To Use this Dapp: https://rstormsf.github.io/multisender\r\npragma solidity >=0.4.26;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title OwnedUpgradeabilityStorage\r\n * @dev This is the storage necessary to perform upgradeable contracts.\r\n * This means, required state variables for upgradeability purpose and eternal storage per se.\r\n */\r\ncontract OwnedUpgradeabilityStorage is UpgradeabilityOwnerStorage, UpgradeabilityStorage, EternalStorage {}\r\n\r\n// File: contracts/SafeMath.sol\r\n\r\n// Roman Storm Multi Sender\r\n// To Use this Dapp: https://rstormsf.github.io/multisender\r\npragma solidity 0.4.26;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n// File: contracts/multisender/Ownable.sol\r\n\r\n// Roman Storm Multi Sender\r\n// To Use this Dapp: https://rstormsf.github.io/multisender\r\npragma solidity  0.4.26;\r\n\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev This contract has an owner address providing basic authorization control\r\n */\r\ncontract Ownable is EternalStorage {\r\n    /**\r\n    * @dev Event to show ownership has been transferred\r\n    * @param previousOwner representing the address of the previous owner\r\n    * @param newOwner representing the address of the new owner\r\n    */\r\n    event OwnershipTransferred(address previousOwner, address newOwner);\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the address of the owner\r\n    * @return the address of the owner\r\n    */\r\n    function owner() public view returns (address) {\r\n        return addressStorage[keccak256(\"owner\")];\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param newOwner the address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        setOwner(newOwner);\r\n    }\r\n\r\n    /**\r\n    * @dev Sets a new owner address\r\n    */\r\n    function setOwner(address newOwner) internal {\r\n        emit OwnershipTransferred(owner(), newOwner);\r\n        addressStorage[keccak256(\"owner\")] = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/multisender/Claimable.sol\r\n\r\n// Roman Storm Multi Sender\r\n// To Use this Dapp: https://rstormsf.github.io/multisender\r\npragma solidity  0.4.26;\r\n\r\n\r\n/**\r\n * @title Claimable\r\n * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\r\n * This allows the new owner to accept the transfer.\r\n */\r\ncontract Claimable is EternalStorage, Ownable {\r\n    function pendingOwner() public view returns (address) {\r\n        return addressStorage[keccak256(\"pendingOwner\")];\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier throws if called by any account other than the pendingOwner.\r\n    */\r\n    modifier onlyPendingOwner() {\r\n        require(msg.sender == pendingOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to set the pendingOwner address.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        addressStorage[keccak256(\"pendingOwner\")] = newOwner;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the pendingOwner address to finalize the transfer.\r\n    */\r\n    function claimOwnership() public onlyPendingOwner {\r\n        emit OwnershipTransferred(owner(), pendingOwner());\r\n        addressStorage[keccak256(\"owner\")] = addressStorage[keccak256(\"pendingOwner\")];\r\n        addressStorage[keccak256(\"pendingOwner\")] = address(0);\r\n    }\r\n}\r\n\r\n// File: contracts/multisender/UpgradebleStormSender.sol\r\n\r\n// Roman Storm Multi Sender\r\n// To Use this Dapp: https://rstormsf.github.io/multisender\r\npragma solidity  0.4.26;\r\n\r\ncontract UpgradebleStormSender is OwnedUpgradeabilityStorage, Claimable {\r\n    using SafeMath for uint256;\r\n    using ERC20AsmFn for ERC20;\r\n\r\n    event Multisended(uint256 total, address tokenAddress);\r\n\r\n    function() public payable {}\r\n\r\n    function initialize(address _owner) public {\r\n        require(!initialized());\r\n        setOwner(_owner);\r\n        setArrayLimit(200);\r\n        boolStorage[keccak256(\"rs_multisender_initialized\")] = true;\r\n    }\r\n\r\n    function initialized() public view returns (bool) {\r\n        return boolStorage[keccak256(\"rs_multisender_initialized\")];\r\n    }\r\n\r\n    function arrayLimit() public view returns(uint256) {\r\n        return uintStorage[keccak256(\"arrayLimit\")];\r\n    }\r\n\r\n    function setArrayLimit(uint256 _newLimit) public onlyOwner {\r\n        require(_newLimit != 0);\r\n        uintStorage[keccak256(\"arrayLimit\")] = _newLimit;\r\n    }\r\n\r\n    function multisendToken(address token, address[] fromArray, address[] toArray, uint256[] amountArray) public onlyOwner payable {\r\n        require(fromArray.length <= arrayLimit());\r\n        require(fromArray.length == toArray.length);\r\n        require(fromArray.length == amountArray.length);\r\n\r\n        uint256 total = 0;\r\n        ERC20 erc20token = ERC20(token);\r\n        uint8 i = 0;\r\n        for (i; i < fromArray.length; i++) {\r\n            require(erc20token.asmTransferFrom(fromArray[i],toArray[i],amountArray[i]));\r\n            total += amountArray[i];\r\n        }\r\n        emit Multisended(total, token);\r\n    }\r\n\r\n    function multisendEther(address[] toArray, uint256[] amountArray) public onlyOwner payable {\r\n        require(toArray.length <= arrayLimit());\r\n\r\n        uint256 total = 0;\r\n        uint8 i = 0;\r\n        for (i; i < toArray.length; i++) {\r\n            toArray[i].transfer(amountArray[i]);\r\n            total += amountArray[i];\r\n        }\r\n        emit Multisended(total, 0x000000000000000000000000000000000000bEEF);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgradeabilityOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"toArray\",\"type\":\"address[]\"},{\"name\":\"amountArray\",\"type\":\"uint256[]\"}],\"name\":\"multisendEther\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"arrayLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setArrayLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"fromArray\",\"type\":\"address[]\"},{\"name\":\"toArray\",\"type\":\"address[]\"},{\"name\":\"amountArray\",\"type\":\"uint256[]\"}],\"name\":\"multisendToken\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"total\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"Multisended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"UpgradebleStormSender","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://5452b3081fb8de06855b655e03285744b4bf4d732208d14326c928381fc15dfc"}]}