{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/igor/job/dev/defi-sdk/contracts/adapters/ERC20ProtocolAdapter.sol\": {\r\n      \"content\": \"// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\\n//\\n// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport { ERC20 } from \\\"../interfaces/ERC20.sol\\\";\\nimport { ProtocolAdapter } from \\\"./ProtocolAdapter.sol\\\";\\n\\n/**\\n * @title Adapter for any protocol with ERC20 interface.\\n * @dev Implementation of ProtocolAdapter abstract contract.\\n * @author Igor Sobolev <sobolev@zerion.io>\\n */\\ncontract ERC20ProtocolAdapter is ProtocolAdapter {\\n    /**\\n     * @return Amount of tokens held by the given account.\\n     * @dev Implementation of ProtocolAdapter abstract contract function.\\n     */\\n    function getBalance(address token, address account) public view override returns (int256) {\\n        return int256(ERC20(token).balanceOf(account));\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/igor/job/dev/defi-sdk/contracts/adapters/ProtocolAdapter.sol\": {\r\n      \"content\": \"// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\\n//\\n// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @title Protocol adapter abstract contract.\\n * @dev adapterType(), tokenType(), and getBalance() functions MUST be implemented.\\n * @author Igor Sobolev <sobolev@zerion.io>\\n */\\nabstract contract ProtocolAdapter {\\n    /**\\n     * @dev MUST return amount and type of the given token\\n     * locked on the protocol by the given account.\\n     */\\n    function getBalance(address token, address account) public virtual returns (int256);\\n}\\n\"\r\n    },\r\n    \"/Users/igor/job/dev/defi-sdk/contracts/interactiveAdapters/InteractiveAdapter.sol\": {\r\n      \"content\": \"// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\\n//\\n// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport { ProtocolAdapter } from \\\"../adapters/ProtocolAdapter.sol\\\";\\nimport { TokenAmount, AmountType } from \\\"../shared/Structs.sol\\\";\\nimport { ERC20 } from \\\"../interfaces/ERC20.sol\\\";\\n\\n/**\\n * @title Base contract for interactive protocol adapters.\\n * @dev deposit() and withdraw() functions MUST be implemented\\n * as well as all the functions from ProtocolAdapter abstract contract.\\n * @author Igor Sobolev <sobolev@zerion.io>\\n */\\nabstract contract InteractiveAdapter is ProtocolAdapter {\\n    uint256 internal constant DELIMITER = 1e18;\\n    address internal constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    /**\\n     * @dev The function must deposit assets to the protocol.\\n     * @return MUST return assets to be sent back to the `msg.sender`.\\n     */\\n    function deposit(TokenAmount[] calldata tokenAmounts, bytes calldata data)\\n        external\\n        payable\\n        virtual\\n        returns (address[] memory);\\n\\n    /**\\n     * @dev The function must withdraw assets from the protocol.\\n     * @return MUST return assets to be sent back to the `msg.sender`.\\n     */\\n    function withdraw(TokenAmount[] calldata tokenAmounts, bytes calldata data)\\n        external\\n        payable\\n        virtual\\n        returns (address[] memory);\\n\\n    function getAbsoluteAmountDeposit(TokenAmount calldata tokenAmount)\\n        internal\\n        view\\n        virtual\\n        returns (uint256)\\n    {\\n        address token = tokenAmount.token;\\n        uint256 amount = tokenAmount.amount;\\n        AmountType amountType = tokenAmount.amountType;\\n\\n        require(\\n            amountType == AmountType.Relative || amountType == AmountType.Absolute,\\n            \\\"IA: bad amount type\\\"\\n        );\\n        if (amountType == AmountType.Relative) {\\n            require(amount <= DELIMITER, \\\"IA: bad amount\\\");\\n\\n            uint256 balance;\\n            if (token == ETH) {\\n                balance = address(this).balance;\\n            } else {\\n                balance = ERC20(token).balanceOf(address(this));\\n            }\\n\\n            if (amount == DELIMITER) {\\n                return balance;\\n            } else {\\n                return mul_(balance, amount) / DELIMITER;\\n            }\\n        } else {\\n            return amount;\\n        }\\n    }\\n\\n    function getAbsoluteAmountWithdraw(TokenAmount calldata tokenAmount)\\n        internal\\n        virtual\\n        returns (uint256)\\n    {\\n        address token = tokenAmount.token;\\n        uint256 amount = tokenAmount.amount;\\n        AmountType amountType = tokenAmount.amountType;\\n\\n        require(\\n            amountType == AmountType.Relative || amountType == AmountType.Absolute,\\n            \\\"IA: bad amount type\\\"\\n        );\\n        if (amountType == AmountType.Relative) {\\n            require(amount <= DELIMITER, \\\"IA: bad amount\\\");\\n\\n            int256 balanceSigned = getBalance(token, address(this));\\n            uint256 balance = balanceSigned > 0 ? uint256(balanceSigned) : uint256(-balanceSigned);\\n            if (amount == DELIMITER) {\\n                return balance;\\n            } else {\\n                return mul_(balance, amount) / DELIMITER;\\n            }\\n        } else {\\n            return amount;\\n        }\\n    }\\n\\n    function mul_(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"IA: mul overflow\\\");\\n\\n        return c;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/igor/job/dev/defi-sdk/contracts/interactiveAdapters/alphaHomora/AlphaHomoraV2AssetInteractiveAdapter.sol\": {\r\n      \"content\": \"// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\\n//\\n// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport { InteractiveAdapter } from \\\"../InteractiveAdapter.sol\\\";\\nimport { ERC20ProtocolAdapter } from \\\"../../adapters/ERC20ProtocolAdapter.sol\\\";\\nimport { SafeERC20 } from \\\"../../shared/SafeERC20.sol\\\";\\nimport { TokenAmount } from \\\"../../shared/Structs.sol\\\";\\nimport { ERC20 } from \\\"../../interfaces/ERC20.sol\\\";\\nimport { SafeBox } from \\\"../../interfaces/SafeBox.sol\\\";\\n\\n/**\\n * @title Interactive adapter for SafeBox contracts.\\n * @dev Implementation of InteractiveAdapter abstract contract.\\n */\\ncontract AlphaHomoraV2AssetInteractiveAdapter is InteractiveAdapter, ERC20ProtocolAdapter {\\n    using SafeERC20 for ERC20;\\n\\n    address internal constant IBETH = 0xeEa3311250FE4c3268F8E684f7C87A82fF183Ec1;\\n\\n    /**\\n     * @notice Deposits tokens to the SafeBox contract.\\n     * @param tokenAmounts Array with one element - TokenAmount struct with\\n     *     underlying token address, underlying token amount to be deposited, and amount type.\\n     * @param data ABI-encoded additional parameters:\\n     *     - box - SafeBox contract address.\\n     * @return tokensToBeWithdrawn Array with ane element - SafeBox contract address.\\n     * @dev Implementation of InteractiveAdapter function.\\n     */\\n    function deposit(TokenAmount[] calldata tokenAmounts, bytes calldata data)\\n        external\\n        payable\\n        override\\n        returns (address[] memory tokensToBeWithdrawn)\\n    {\\n        require(tokenAmounts.length == 1, \\\"AHV2AIA: should be 1 tokenAmount[1]\\\");\\n\\n        address box = abi.decode(data, (address));\\n\\n        address token = tokenAmounts[0].token;\\n        uint256 amount = getAbsoluteAmountDeposit(tokenAmounts[0]);\\n\\n        tokensToBeWithdrawn = new address[](1);\\n        tokensToBeWithdrawn[0] = box;\\n\\n        if (token == ETH) {\\n            // solhint-disable-next-line no-empty-blocks\\n            try SafeBox(box).deposit{ value: amount }() {} catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"AHV2AIA: ETH deposit fail\\\");\\n            }\\n        } else {\\n            ERC20(token).safeApproveMax(box, amount, \\\"AHV2AIA\\\");\\n            // solhint-disable-next-line no-empty-blocks\\n            try SafeBox(box).deposit(amount) {} catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"AHV2AIA: deposit fail\\\");\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Withdraws tokens from the SafeBox contract.\\n     * @param tokenAmounts Array with one element - TokenAmount struct with\\n     *     SafeBox address, amount to be redeemed, and amount type.\\n     * @return tokensToBeWithdrawn Array with one element - underlying token.\\n     * @dev Implementation of InteractiveAdapter function.\\n     */\\n    function withdraw(TokenAmount[] calldata tokenAmounts, bytes calldata)\\n        external\\n        payable\\n        override\\n        returns (address[] memory tokensToBeWithdrawn)\\n    {\\n        require(tokenAmounts.length == 1, \\\"AHV2AIA: should be 1 tokenAmount[2]\\\");\\n\\n        address token = tokenAmounts[0].token;\\n        uint256 amount = getAbsoluteAmountWithdraw(tokenAmounts[0]);\\n\\n        tokensToBeWithdrawn = new address[](1);\\n        tokensToBeWithdrawn[0] = token == IBETH ? ETH : SafeBox(token).uToken();\\n\\n        // solhint-disable-next-line no-empty-blocks\\n        try SafeBox(token).withdraw(amount) {} catch Error(string memory reason) {\\n            revert(reason);\\n        } catch {\\n            revert(\\\"AHV2AIA: withdraw fail\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/igor/job/dev/defi-sdk/contracts/interfaces/ERC20.sol\": {\r\n      \"content\": \"// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\\n//\\n// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\ninterface ERC20 {\\n    function approve(address, uint256) external returns (bool);\\n\\n    function transfer(address, uint256) external returns (bool);\\n\\n    function transferFrom(\\n        address,\\n        address,\\n        uint256\\n    ) external returns (bool);\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address) external view returns (uint256);\\n\\n    function allowance(address, address) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"/Users/igor/job/dev/defi-sdk/contracts/interfaces/SafeBox.sol\": {\r\n      \"content\": \"// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\\n//\\n// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.7.6;\\n\\n/**\\n * @dev SafeBOX contract interface.\\n * The SafeBOX contract is available here\\n * github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/SafeBox.sol.\\n * The SafeBoxETH contract interface is combined into this interface.\\n * The SafeBoxETH contract is available here\\n * github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/SafeBoxETH.sol.\\n */\\ninterface SafeBox {\\n    function deposit(uint256) external;\\n\\n    function deposit() external payable;\\n\\n    function withdraw(uint256) external;\\n\\n    function uToken() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"/Users/igor/job/dev/defi-sdk/contracts/shared/SafeERC20.sol\": {\r\n      \"content\": \"// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\\n//\\n// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"../interfaces/ERC20.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token contract\\n * returns false). Tokens that return no value (and instead revert or throw on failure)\\n * are also supported, non-reverting calls are assumed to be successful.\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 value,\\n        string memory location\\n    ) internal {\\n        callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transfer.selector, to, value),\\n            \\\"transfer\\\",\\n            location\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 value,\\n        string memory location\\n    ) internal {\\n        callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value),\\n            \\\"transferFrom\\\",\\n            location\\n        );\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address spender,\\n        uint256 value,\\n        string memory location\\n    ) internal {\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            string(abi.encodePacked(\\\"SafeERC20: bad approve call from \\\", location))\\n        );\\n        callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.approve.selector, spender, value),\\n            \\\"approve\\\",\\n            location\\n        );\\n    }\\n\\n    function safeApproveMax(\\n        ERC20 token,\\n        address spender,\\n        uint256 value,\\n        string memory location\\n    ) internal {\\n        uint256 allowance = ERC20(token).allowance(address(this), spender);\\n        if (allowance < value) {\\n            if (allowance > 0) {\\n                safeApprove(token, spender, 0, location);\\n            }\\n            safeApprove(token, spender, type(uint256).max, location);\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract),\\n     * relaxing the requirement on the return value: the return value is optional\\n     * (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     * @param location Location of the call (for debug).\\n     */\\n    function callOptionalReturn(\\n        ERC20 token,\\n        bytes memory data,\\n        string memory functionName,\\n        string memory location\\n    ) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking\\n        // mechanism, since we're implementing it ourselves.\\n\\n        // We implement two-steps call as callee is a contract is a responsibility of a caller.\\n        //  1. The call itself is made, and success asserted\\n        //  2. The return value is decoded, which in turn checks the size of the returned data.\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(\\n            success,\\n            string(abi.encodePacked(\\\"SafeERC20: \\\", functionName, \\\" failed in \\\", location))\\n        );\\n\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(\\n                abi.decode(returndata, (bool)),\\n                string(\\n                    abi.encodePacked(\\\"SafeERC20: \\\", functionName, \\\" returned false in \\\", location)\\n                )\\n            );\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/igor/job/dev/defi-sdk/contracts/shared/Structs.sol\": {\r\n      \"content\": \"// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\\n//\\n// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\n// The struct consists of TokenBalanceMeta structs for\\n// (base) token and its underlying tokens (if any).\\nstruct FullTokenBalance {\\n    TokenBalanceMeta base;\\n    TokenBalanceMeta[] underlying;\\n}\\n\\n// The struct consists of TokenBalance struct\\n// with token address and absolute amount\\n// and ERC20Metadata struct with ERC20-style metadata.\\n// NOTE: 0xEeee...EEeE address is used for ETH.\\nstruct TokenBalanceMeta {\\n    TokenBalance tokenBalance;\\n    ERC20Metadata erc20metadata;\\n}\\n\\n// The struct consists of ERC20-style token metadata.\\nstruct ERC20Metadata {\\n    string name;\\n    string symbol;\\n    uint8 decimals;\\n}\\n\\n// The struct consists of protocol adapter's name\\n// and array of TokenBalance structs\\n// with token addresses and absolute amounts.\\nstruct AdapterBalance {\\n    bytes32 protocolAdapterName;\\n    TokenBalance[] tokenBalances;\\n}\\n\\n// The struct consists of token address\\n// and its absolute amount (may be negative).\\n// 0xEeee...EEeE is used for Ether\\nstruct TokenBalance {\\n    address token;\\n    int256 amount;\\n}\\n\\n// The struct consists of token address,\\n// and price per full share (1e18).\\n// 0xEeee...EEeE is used for Ether\\nstruct Component {\\n    address token;\\n    int256 rate;\\n}\\n\\n//=============================== Interactive Adapters Structs ====================================\\n\\n// The struct consists of name of the protocol adapter,\\n// action type, array of token amounts,\\n// and some additional data (depends on the protocol).\\nstruct Action {\\n    bytes32 protocolAdapterName;\\n    ActionType actionType;\\n    TokenAmount[] tokenAmounts;\\n    bytes data;\\n}\\n\\n// The struct consists of token address,\\n// its amount, and amount type, as well as\\n// permit type and calldata.\\nstruct Input {\\n    TokenAmount tokenAmount;\\n    Permit permit;\\n}\\n\\n// The struct consists of\\n// permit type and calldata.\\nstruct Permit {\\n    PermitType permitType;\\n    bytes permitCallData;\\n}\\n\\n// The struct consists of token address,\\n// its amount, and amount type.\\n// 0xEeee...EEeE is used for Ether\\nstruct TokenAmount {\\n    address token;\\n    uint256 amount;\\n    AmountType amountType;\\n}\\n\\n// The struct consists of fee share\\n// and beneficiary address.\\nstruct Fee {\\n    uint256 share;\\n    address beneficiary;\\n}\\n\\n// The struct consists of token address\\n// and its absolute amount.\\n// 0xEeee...EEeE is used for Ether\\nstruct AbsoluteTokenAmount {\\n    address token;\\n    uint256 absoluteAmount;\\n}\\n\\nenum ActionType { None, Deposit, Withdraw }\\n\\nenum AmountType { None, Relative, Absolute }\\n\\nenum PermitType { None, EIP2612, DAI, Yearn }\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"enum AmountType\",\"name\":\"amountType\",\"type\":\"uint8\"}],\"internalType\":\"struct TokenAmount[]\",\"name\":\"tokenAmounts\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokensToBeWithdrawn\",\"type\":\"address[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"enum AmountType\",\"name\":\"amountType\",\"type\":\"uint8\"}],\"internalType\":\"struct TokenAmount[]\",\"name\":\"tokenAmounts\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokensToBeWithdrawn\",\"type\":\"address[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"AlphaHomoraV2AssetInteractiveAdapter","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}