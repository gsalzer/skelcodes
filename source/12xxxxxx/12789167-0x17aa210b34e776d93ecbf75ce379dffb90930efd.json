{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.7.6;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface ITroveManager {\r\n    function redeemCollateral(\r\n        uint _LUSDAmount,\r\n        address _firstRedemptionHint,\r\n        address _upperPartialRedemptionHint,\r\n        address _lowerPartialRedemptionHint,\r\n        uint _partialRedemptionHintNICR,\r\n        uint _maxIterations,\r\n        uint _maxFee\r\n    ) external; \r\n}\r\n\r\ninterface Curve {\r\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy, address _receiver) external returns (uint256);\r\n    function get_dy_underlying(int128 i, int128 j, uint256 dx) view external returns (uint256);\r\n}\r\n\r\ninterface IStabilityPool {\r\n\r\n    // --- Events ---\r\n    \r\n    event StabilityPoolETHBalanceUpdated(uint _newBalance);\r\n    event StabilityPoolLUSDBalanceUpdated(uint _newBalance);\r\n\r\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\r\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\r\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\r\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\r\n    event LUSDTokenAddressChanged(address _newLUSDTokenAddress);\r\n    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);\r\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\r\n    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);\r\n\r\n    event P_Updated(uint _P);\r\n    event S_Updated(uint _S, uint128 _epoch, uint128 _scale);\r\n    event G_Updated(uint _G, uint128 _epoch, uint128 _scale);\r\n    event EpochUpdated(uint128 _currentEpoch);\r\n    event ScaleUpdated(uint128 _currentScale);\r\n\r\n    event FrontEndRegistered(address indexed _frontEnd, uint _kickbackRate);\r\n    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);\r\n\r\n    event DepositSnapshotUpdated(address indexed _depositor, uint _P, uint _S, uint _G);\r\n    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint _P, uint _G);\r\n    event UserDepositChanged(address indexed _depositor, uint _newDeposit);\r\n    event FrontEndStakeChanged(address indexed _frontEnd, uint _newFrontEndStake, address _depositor);\r\n\r\n    event ETHGainWithdrawn(address indexed _depositor, uint _ETH, uint _LUSDLoss);\r\n    event LQTYPaidToDepositor(address indexed _depositor, uint _LQTY);\r\n    event LQTYPaidToFrontEnd(address indexed _frontEnd, uint _LQTY);\r\n    event EtherSent(address _to, uint _amount);\r\n\r\n    // --- Functions ---\r\n\r\n    /*\r\n     * Called only once on init, to set addresses of other Liquity contracts\r\n     * Callable only by owner, renounces ownership at the end\r\n     */\r\n    function setAddresses(\r\n        address _borrowerOperationsAddress,\r\n        address _troveManagerAddress,\r\n        address _activePoolAddress,\r\n        address _lusdTokenAddress,\r\n        address _sortedTrovesAddress,\r\n        address _priceFeedAddress,\r\n        address _communityIssuanceAddress\r\n    ) external;\r\n\r\n    /*\r\n     * Initial checks:\r\n     * - Frontend is registered or zero address\r\n     * - Sender is not a registered frontend\r\n     * - _amount is not zero\r\n     * ---\r\n     * - Triggers a LQTY issuance, based on time passed since the last issuance. The LQTY issuance is shared between *all* depositors and front ends\r\n     * - Tags the deposit with the provided front end tag param, if it's a new deposit\r\n     * - Sends depositor's accumulated gains (LQTY, ETH) to depositor\r\n     * - Sends the tagged front end's accumulated LQTY gains to the tagged front end\r\n     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.\r\n     */\r\n    function provideToSP(uint _amount, address _frontEndTag) external;\r\n\r\n    /*\r\n     * Initial checks:\r\n     * - _amount is zero or there are no under collateralized troves left in the system\r\n     * - User has a non zero deposit\r\n     * ---\r\n     * - Triggers a LQTY issuance, based on time passed since the last issuance. The LQTY issuance is shared between *all* depositors and front ends\r\n     * - Removes the deposit's front end tag if it is a full withdrawal\r\n     * - Sends all depositor's accumulated gains (LQTY, ETH) to depositor\r\n     * - Sends the tagged front end's accumulated LQTY gains to the tagged front end\r\n     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.\r\n     *\r\n     * If _amount > userDeposit, the user withdraws all of their compounded deposit.\r\n     */\r\n    function withdrawFromSP(uint _amount) external;\r\n\r\n    /*\r\n     * Initial checks:\r\n     * - User has a non zero deposit\r\n     * - User has an open trove\r\n     * - User has some ETH gain\r\n     * ---\r\n     * - Triggers a LQTY issuance, based on time passed since the last issuance. The LQTY issuance is shared between *all* depositors and front ends\r\n     * - Sends all depositor's LQTY gain to  depositor\r\n     * - Sends all tagged front end's LQTY gain to the tagged front end\r\n     * - Transfers the depositor's entire ETH gain from the Stability Pool to the caller's trove\r\n     * - Leaves their compounded deposit in the Stability Pool\r\n     * - Updates snapshots for deposit and tagged front end stake\r\n     */\r\n    function withdrawETHGainToTrove(address _upperHint, address _lowerHint) external;\r\n\r\n    /*\r\n     * Initial checks:\r\n     * - Frontend (sender) not already registered\r\n     * - User (sender) has no deposit\r\n     * - _kickbackRate is in the range [0, 100%]\r\n     * ---\r\n     * Front end makes a one-time selection of kickback rate upon registering\r\n     */\r\n    function registerFrontEnd(uint _kickbackRate) external;\r\n\r\n    /*\r\n     * Initial checks:\r\n     * - Caller is TroveManager\r\n     * ---\r\n     * Cancels out the specified debt against the LUSD contained in the Stability Pool (as far as possible)\r\n     * and transfers the Trove's ETH collateral from ActivePool to StabilityPool.\r\n     * Only called by liquidation functions in the TroveManager.\r\n     */\r\n    function offset(uint _debt, uint _coll) external;\r\n\r\n    /*\r\n     * Returns the total amount of ETH held by the pool, accounted in an internal variable instead of `balance`,\r\n     * to exclude edge cases like ETH received from a self-destruct.\r\n     */\r\n    function getETH() external view returns (uint);\r\n\r\n    /*\r\n     * Returns LUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\r\n     */\r\n    function getTotalLUSDDeposits() external view returns (uint);\r\n\r\n    /*\r\n     * Calculates the ETH gain earned by the deposit since its last snapshots were taken.\r\n     */\r\n    function getDepositorETHGain(address _depositor) external view returns (uint);\r\n\r\n    /*\r\n     * Calculate the LQTY gain earned by a deposit since its last snapshots were taken.\r\n     * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.\r\n     * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through\r\n     * which they made their deposit.\r\n     */\r\n    function getDepositorLQTYGain(address _depositor) external view returns (uint);\r\n\r\n    /*\r\n     * Return the LQTY gain earned by the front end.\r\n     */\r\n    function getFrontEndLQTYGain(address _frontEnd) external view returns (uint);\r\n\r\n    /*\r\n     * Return the user's compounded deposit.\r\n     */\r\n    function getCompoundedLUSDDeposit(address _depositor) external view returns (uint);\r\n\r\n    /*\r\n     * Return the front end's compounded stake.\r\n     *\r\n     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.\r\n     */\r\n    function getCompoundedFrontEndStake(address _frontEnd) external view returns (uint);\r\n\r\n    /*\r\n     * Fallback function\r\n     * Only callable by Active Pool, it just accounts for ETH received\r\n     * receive() external payable;\r\n     */\r\n}\r\n\r\ncontract Redeem {\r\n    address public lusd_trove_mgr = address(0xA39739EF8b0231DbFA0DcdA07d7e29faAbCf4bb2);\r\n    address public lusd_curve_pool = address(0xEd279fDD11cA84bEef15AF5D39BB4d4bEE23F0cA);\r\n    address public lusd_token = address(0x5f98805A4E8be255a32880FDeC7F6728C6568bA0);\r\n    address public usdc_token = address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\r\n    address public stability_pool = address(0x66017D22b0f8556afDd19FC67041899Eb65a21bb);\r\n\r\n    function fund() public payable returns(bool success) {\r\n        return true;\r\n    }\r\n\r\n    function _exchange_underlying(uint256 dx, uint256 dy) internal {\r\n        IERC20(usdc_token).transferFrom(msg.sender, address(this), dx);\r\n        require(IERC20(usdc_token).balanceOf(address(this)) == dx);\r\n        Curve(lusd_curve_pool).exchange_underlying(2, 0 , dx,  dy, msg.sender);\r\n    }\r\n\r\n\r\n    function redeem_all_lusd(\r\n        uint256 dx, uint256 dy,\r\n        address _firstRedemptionHint,\r\n        address _upperPartialRedemptionHint,\r\n        address _lowerPartialRedemptionHint,\r\n        uint _partialRedemptionHintNICR,\r\n        uint _maxIterations,\r\n        uint _maxFee\r\n        ) external payable {\r\n        _exchange_underlying(dx, dy);\r\n        uint lusd_balance = IERC20(lusd_token).balanceOf(msg.sender);\r\n        IERC20(lusd_token).transferFrom(msg.sender, address(this), lusd_balance);\r\n        ITroveManager(lusd_trove_mgr).redeemCollateral(\r\n            lusd_balance,\r\n            _firstRedemptionHint,\r\n            _upperPartialRedemptionHint,\r\n            _lowerPartialRedemptionHint,\r\n            _partialRedemptionHintNICR,\r\n            _maxFee,\r\n            _maxFee\r\n        );\r\n\r\n        msg.sender.transfer(address(this).balance);\r\n\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"name\":\"fund\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lusd_curve_pool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lusd_token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lusd_trove_mgr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dy\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_firstRedemptionHint\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_upperPartialRedemptionHint\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_lowerPartialRedemptionHint\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_partialRedemptionHintNICR\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxIterations\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxFee\",\"type\":\"uint256\"}],\"name\":\"redeem_all_lusd\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stability_pool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdc_token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Redeem","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://ebb087203f757d03c707a0d36ac14970cac6c4e68f0d73fe55bb988eb184861c"}]}