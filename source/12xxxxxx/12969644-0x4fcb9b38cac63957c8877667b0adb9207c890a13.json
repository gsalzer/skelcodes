{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ECRegistryV2.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\npragma abicoder v2;\\n\\n/***\\n *                                                                                                           \\n *            ███████ ████████ ██   ██ ███████ ██████      ██████  █████  ██████  ██████  ███████            \\n *            ██         ██    ██   ██ ██      ██   ██    ██      ██   ██ ██   ██ ██   ██ ██                 \\n *            █████      ██    ███████ █████   ██████     ██      ███████ ██████  ██   ██ ███████            \\n *            ██         ██    ██   ██ ██      ██   ██    ██      ██   ██ ██   ██ ██   ██      ██            \\n *            ███████    ██    ██   ██ ███████ ██   ██ ██  ██████ ██   ██ ██   ██ ██████  ███████            \\n *                                                                                                           \\n *                                                                                                           \\n *    ████████ ██████   █████  ██ ████████     ██████  ███████  ██████  ██ ███████ ████████ ██████  ██    ██ \\n *       ██    ██   ██ ██   ██ ██    ██        ██   ██ ██      ██       ██ ██         ██    ██   ██  ██  ██  \\n *       ██    ██████  ███████ ██    ██        ██████  █████   ██   ███ ██ ███████    ██    ██████    ████   \\n *       ██    ██   ██ ██   ██ ██    ██        ██   ██ ██      ██    ██ ██      ██    ██    ██   ██    ██    \\n *       ██    ██   ██ ██   ██ ██    ██        ██   ██ ███████  ██████  ██ ███████    ██    ██   ██    ██    \\n *                                                                                                           \\n *                                                                                                           \\n *                      ██   ██  ██████  ████████     ██████  ██ ███    ██ ██   ██                           \\n *                      ██   ██ ██    ██    ██        ██   ██ ██ ████   ██ ██  ██                            \\n *                █████ ███████ ██    ██    ██        ██████  ██ ██ ██  ██ █████   █████                     \\n *                      ██   ██ ██    ██    ██        ██      ██ ██  ██ ██ ██  ██                            \\n *                      ██   ██  ██████     ██        ██      ██ ██   ████ ██   ██                           \\n *                                                                                                           \\n *                                                                                                           \\n *                        ███████ ██████  ██ ████████ ██  ██████  ███    ██                                  \\n *                        ██      ██   ██ ██    ██    ██ ██    ██ ████   ██                                  \\n *                        █████   ██   ██ ██    ██    ██ ██    ██ ██ ██  ██                                  \\n *                        ██      ██   ██ ██    ██    ██ ██    ██ ██  ██ ██                                  \\n *                        ███████ ██████  ██    ██    ██  ██████  ██   ████                                  \\n *                                                                                                           \\n *                                                                                                           \\n *    ETHER.CARDS - Trait Registry - Hot Pink - Edition                                                      \\n *                                                                                                           \\n */\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/EnumerableSet.sol\\\";\\n\\ncontract ECRegistryV2 is Ownable {\\n\\n    struct traitStruct {\\n        string  name;\\n        address implementer;     // address of the smart contract that will implement extra functionality\\n        uint8   traitType;       // 0 for normal, 1 for inverted, 2 for inverted range\\n        uint16  start;\\n        uint16  end;\\n    }\\n\\n    uint16 public traitCount;\\n    mapping(uint16 => traitStruct) public traits;\\n\\n    // token data\\n    mapping(uint16 => mapping(uint16 => uint8) ) public tokenData;\\n\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    // onlyOwner can change contractControllers and transfer it's ownership\\n    // any contractController can setData\\n    EnumerableSet.AddressSet contractController;\\n\\n    // trait controller access designates sub contracts that can affect 1 or more traits\\n    mapping(uint16 => address ) public traitControllerById;\\n    mapping(address => uint16 ) public traitControllerByAddress;\\n    uint16 public traitControllerCount = 0;\\n\\n    mapping(address => mapping(uint8 => uint8) ) public traitControllerAccess;\\n\\n\\n    /*\\n    *   Events\\n    */\\n    event contractControllerEvent(address _address, bool mode);\\n    event traitControllerEvent(address _address);\\n    \\n    // traits\\n    event newTraitEvent(string _name, address _address, uint8 _traitType, uint16 _start, uint16 _end );\\n    event updateTraitEvent(uint16 indexed _id, string _name, address _address, uint8 _traitType, uint16 _start, uint16 _end);\\n    event updateTraitDataEvent(uint16 indexed _id);\\n    // tokens\\n    event tokenTraitChangeEvent(uint16 indexed _traitId, uint16 indexed _tokenId, bool mode);\\n\\n    function addTrait(\\n        string[]    calldata _name,\\n        address[]   calldata _implementer,\\n        uint8[]     calldata _traitType,\\n        uint16[]    calldata _start,\\n        uint16[]    calldata _end\\n    ) public onlyAllowed {\\n\\n        for (uint8 i = 0; i < _name.length; i++) {\\n            uint16 newTraitId = traitCount++;\\n            traitStruct storage newT = traits[newTraitId];\\n            newT.name = _name[i];\\n            newT.implementer = _implementer[i];\\n            newT.traitType = _traitType[i];\\n            newT.start = _start[i];\\n            newT.end = _end[i];\\n\\n            emit newTraitEvent(_name[i], _implementer[i], _traitType[i], _start[i], _end[i] );\\n            if(_implementer[i] != address(0)) {\\n                setTraitControllerAccess(_implementer[i], newTraitId, true);\\n            }\\n            setTraitControllerAccess(owner(), newTraitId, true);\\n        }\\n    }\\n\\n    function updateTrait(\\n        uint16 _traitId,\\n        string memory _name,\\n        address _implementer,\\n        uint8   _traitType,\\n        uint16  _start,\\n        uint16  _end\\n    ) public onlyAllowed {\\n        // set old to false\\n        setTraitControllerAccess(traits[_traitId].implementer, _traitId, false);\\n\\n        traits[_traitId].name = _name;\\n        traits[_traitId].implementer = _implementer;\\n        traits[_traitId].traitType = _traitType;\\n        traits[_traitId].start = _start;\\n        traits[_traitId].end = _end;\\n\\n        // set new to true\\n        setTraitControllerAccess(_implementer, _traitId, true);\\n\\n        emit updateTraitEvent(_traitId, _name, _implementer, _traitType, _start, _end);\\n    }\\n\\n    function setTrait(uint16 traitID, uint16 tokenId, bool _value) external onlyTraitController(traitID) {\\n        _setTrait(traitID, tokenId, _value);\\n    }\\n\\n    function setTraitOnMultiple(uint16 traitID, uint16[] memory tokenIds, bool[] memory _value) public onlyTraitController(traitID) {\\n        for (uint16 i = 0; i < tokenIds.length; i++) {\\n            _setTrait(traitID, tokenIds[i], _value[i]);\\n        }\\n    }\\n\\n    function _setTrait(uint16 traitID, uint16 tokenId, bool _value) internal {\\n        bool emitvalue = _value;\\n        (uint16 byteNum, uint8 bitPos) = getByteAndBit(tokenId);\\n        if(traits[traitID].traitType == 1 || traits[traitID].traitType == 2) {\\n            _value = !_value; \\n        }\\n        if(_value) {\\n            tokenData[traitID][byteNum] = uint8(tokenData[traitID][byteNum] | 2**bitPos);\\n        } else {\\n            tokenData[traitID][byteNum] = uint8(tokenData[traitID][byteNum] & ~(2**bitPos));\\n        }\\n        emit tokenTraitChangeEvent(traitID, tokenId, emitvalue);\\n    }\\n\\n    // set trait data\\n    function setData(uint16 traitId, uint16[] calldata _ids, uint8[] calldata _data) public onlyAllowed {\\n        for (uint16 i = 0; i < _data.length; i++) {\\n            tokenData[traitId][_ids[i]] = _data[i];\\n        }\\n        updateTraitDataEvent(traitId);\\n    }\\n\\n    /*\\n    *   View Methods\\n    */\\n\\n    /*\\n    * _perPage = 1250 in order to load 10000 tokens ( 10000 / 8; starting from 0 )\\n    */\\n    function getData(uint16 traitId, uint8 _page, uint16 _perPage) public view returns (uint8[] memory) {\\n        uint16 i = _perPage * _page;\\n        uint16 max = i + (_perPage);\\n        uint16 j = 0;\\n        uint8[] memory retValues;\\n        assembly {\\n            mstore(retValues, _perPage)\\n        }\\n        while(i < max) {\\n            retValues[j] = tokenData[traitId][i];\\n            j++;\\n            i++;\\n        }\\n        \\n        assembly {\\n            // move pointer to freespace otherwise return calldata gets messed up\\n            mstore(0x40, msize()) \\n        }\\n        return retValues;\\n    }\\n\\n    function getTokenData(uint16 tokenId) public view returns (uint8[] memory) {\\n        uint16 _traitCount = traitCount;\\n        uint16 _returnCount = traitCount/8;\\n        if(_returnCount * 8 < _traitCount) {\\n            _returnCount++;\\n        }\\n\\n        uint16 i = 0;\\n        uint8[] memory retValues;\\n        assembly {\\n            // set dynamic memory array length\\n            mstore(retValues, _returnCount)\\n        }\\n        while(i < _returnCount) {\\n            retValues[i] = 0;\\n            i++;\\n        }\\n        assembly {\\n            // move pointer to freespace otherwise return calldata gets messed up\\n            mstore(0x40, msize()) \\n        }\\n\\n        i = 0;\\n        \\n        // calculate positions for our token\\n        while(i < traitCount) {\\n            if(hasTrait(i, tokenId)) {\\n                uint8 byteNum = uint8(i / 8);\\n                uint8 bitPos = uint8(i - byteNum * 8);\\n                retValues[byteNum] = uint8(retValues[byteNum] | 2**bitPos);\\n            }\\n            i++;\\n        }\\n        return retValues;\\n    }\\n\\n\\n    function getTraitControllerAccessData(address _addr) public view returns (uint8[] memory) {\\n        uint16 _traitCount = traitCount;\\n        uint16 _returnCount = traitCount/8;\\n        if(_returnCount * 8 < _traitCount) {\\n            _returnCount++;\\n        }\\n        uint8 i = 0;\\n        uint8[] memory retValues;\\n        assembly {\\n            // set dynamic memory array length\\n            mstore(retValues, _returnCount)\\n        }\\n\\n        while(i < _returnCount) {\\n            retValues[i] = traitControllerAccess[_addr][i];\\n            i++;\\n        }\\n        \\n        assembly {\\n            // move pointer to freespace otherwise return calldata gets messed up\\n            mstore(0x40, msize()) \\n        }\\n        return retValues;\\n    }\\n\\n    function getByteAndBit(uint16 _offset) public pure returns (uint16 _byte, uint8 _bit)\\n    {\\n        // find byte storig our bit\\n        _byte = uint16(_offset / 8);\\n        _bit = uint8(_offset - _byte * 8);\\n    }\\n\\n    function getImplementer(uint16 traitID) public view returns (address implementer)\\n    {\\n        return traits[traitID].implementer;\\n    }\\n\\n    function hasTrait(uint16 traitID, uint16 tokenId) public view returns (bool result)\\n    {\\n        (uint16 byteNum, uint8 bitPos) = getByteAndBit(tokenId);\\n        bool _result = tokenData[traitID][byteNum] & (0x01 * 2**bitPos) != 0;\\n        bool _returnVal = (traits[traitID].traitType == 1) ? !_result: _result;\\n        if(traits[traitID].traitType == 2) {\\n            // range trait\\n            if(traits[traitID].start <= tokenId && tokenId <= traits[traitID].end) {\\n                _returnVal = !_result;\\n            }\\n        }\\n        return _returnVal;\\n    }\\n\\n    /*\\n    *   Admin Stuff\\n    */\\n\\n    function setContractController(address _controller, bool _mode) public onlyOwner {\\n        if(_mode) {\\n            contractController.add(_controller);\\n        } else {\\n            contractController.remove(_controller);\\n        }\\n        emit contractControllerEvent(_controller, _mode);\\n    }\\n\\n    function getContractControllerLength() public view returns (uint256) {\\n        return contractController.length();\\n    }\\n\\n    function getContractControllerAt(uint256 _index) public view returns (address) {\\n        return contractController.at(_index);\\n    }\\n\\n    function getContractControllerContains(address _addr) public view returns (bool) {\\n        return contractController.contains(_addr);\\n    }\\n\\n    /*\\n    *   Trait Controllers\\n    */\\n\\n    function indexTraitController(address _addr) internal {\\n        if(traitControllerByAddress[_addr] == 0) {\\n            uint16 controllerId = ++traitControllerCount;\\n            traitControllerByAddress[_addr] = controllerId;\\n            traitControllerById[controllerId] = _addr;\\n        }\\n    }\\n\\n    function setTraitControllerAccessData(address _addr, uint8[] calldata _data) public onlyAllowed {\\n        indexTraitController(_addr);\\n        for (uint8 i = 0; i < _data.length; i++) {\\n            traitControllerAccess[_addr][i] = _data[i];\\n        }\\n        traitControllerEvent(_addr);\\n    }\\n\\n    function setTraitControllerAccess(address _addr, uint16 traitID, bool _value) public onlyAllowed {\\n        indexTraitController(_addr);\\n        if(_addr != address(0)) {\\n            (uint16 byteNum, uint8 bitPos) = getByteAndBit(traitID);\\n            if(_value) {\\n                traitControllerAccess[_addr][uint8(byteNum)] = uint8(traitControllerAccess[_addr][uint8(byteNum)] | 2**bitPos);\\n            } else {\\n                traitControllerAccess[_addr][uint8(byteNum)] = uint8(traitControllerAccess[_addr][uint8(byteNum)] & ~(2**bitPos));\\n            }\\n        }\\n        traitControllerEvent(_addr);\\n    }\\n \\n    function addressCanModifyTrait(address _addr, uint16 traitID) public view returns (bool result) {\\n        (uint16 byteNum, uint8 bitPos) = getByteAndBit(traitID);\\n        return traitControllerAccess[_addr][uint8(byteNum)] & (0x01 * 2**bitPos) != 0;\\n    }\\n\\n    function addressCanModifyTraits(address _addr, uint16[] memory traitIDs) public view returns (bool result) {\\n        for(uint16 i = 0; i < traitIDs.length; i++) {\\n            if(!addressCanModifyTrait(_addr, traitIDs[i])) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    modifier onlyAllowed() {\\n        require(\\n            msg.sender == owner() || contractController.contains(msg.sender),\\n            \\\"Not Authorised\\\"\\n        );\\n        _;\\n    }\\n    \\n    modifier onlyTraitController(uint16 traitID) {\\n        require(\\n            addressCanModifyTrait(msg.sender, traitID),\\n            \\\"Not Authorised\\\"\\n        );\\n        _;\\n    }\\n}\\n\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"mode\",\"type\":\"bool\"}],\"name\":\"contractControllerEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_traitType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"_start\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"_end\",\"type\":\"uint16\"}],\"name\":\"newTraitEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"_traitId\",\"type\":\"uint16\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"_tokenId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"mode\",\"type\":\"bool\"}],\"name\":\"tokenTraitChangeEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"traitControllerEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"_id\",\"type\":\"uint16\"}],\"name\":\"updateTraitDataEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"_id\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_traitType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"_start\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"_end\",\"type\":\"uint16\"}],\"name\":\"updateTraitEvent\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"_name\",\"type\":\"string[]\"},{\"internalType\":\"address[]\",\"name\":\"_implementer\",\"type\":\"address[]\"},{\"internalType\":\"uint8[]\",\"name\":\"_traitType\",\"type\":\"uint8[]\"},{\"internalType\":\"uint16[]\",\"name\":\"_start\",\"type\":\"uint16[]\"},{\"internalType\":\"uint16[]\",\"name\":\"_end\",\"type\":\"uint16[]\"}],\"name\":\"addTrait\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"traitID\",\"type\":\"uint16\"}],\"name\":\"addressCanModifyTrait\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint16[]\",\"name\":\"traitIDs\",\"type\":\"uint16[]\"}],\"name\":\"addressCanModifyTraits\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_offset\",\"type\":\"uint16\"}],\"name\":\"getByteAndBit\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"_byte\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"_bit\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getContractControllerAt\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getContractControllerContains\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractControllerLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"traitId\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"_page\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"_perPage\",\"type\":\"uint16\"}],\"name\":\"getData\",\"outputs\":[{\"internalType\":\"uint8[]\",\"name\":\"\",\"type\":\"uint8[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"traitID\",\"type\":\"uint16\"}],\"name\":\"getImplementer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"implementer\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"}],\"name\":\"getTokenData\",\"outputs\":[{\"internalType\":\"uint8[]\",\"name\":\"\",\"type\":\"uint8[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getTraitControllerAccessData\",\"outputs\":[{\"internalType\":\"uint8[]\",\"name\":\"\",\"type\":\"uint8[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"traitID\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"}],\"name\":\"hasTrait\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_controller\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_mode\",\"type\":\"bool\"}],\"name\":\"setContractController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"traitId\",\"type\":\"uint16\"},{\"internalType\":\"uint16[]\",\"name\":\"_ids\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[]\",\"name\":\"_data\",\"type\":\"uint8[]\"}],\"name\":\"setData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"traitID\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"setTrait\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"traitID\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"setTraitControllerAccess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint8[]\",\"name\":\"_data\",\"type\":\"uint8[]\"}],\"name\":\"setTraitControllerAccessData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"traitID\",\"type\":\"uint16\"},{\"internalType\":\"uint16[]\",\"name\":\"tokenIds\",\"type\":\"uint16[]\"},{\"internalType\":\"bool[]\",\"name\":\"_value\",\"type\":\"bool[]\"}],\"name\":\"setTraitOnMultiple\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"tokenData\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"traitControllerAccess\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"traitControllerByAddress\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"traitControllerById\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"traitControllerCount\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"traitCount\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"traits\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"implementer\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"traitType\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"start\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"end\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_traitId\",\"type\":\"uint16\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_implementer\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_traitType\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"_start\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_end\",\"type\":\"uint16\"}],\"name\":\"updateTrait\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ECRegistryV2","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}