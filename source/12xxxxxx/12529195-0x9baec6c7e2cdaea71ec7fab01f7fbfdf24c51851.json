{"status":"1","message":"OK","result":[{"SourceCode":"{\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/*\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint value);\\r\\n}\"},\"IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../IERC20.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\r\\n *\\r\\n * _Available since v4.1._\\r\\n */\\r\\ninterface IERC20Metadata is IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the symbol of the token.\\r\\n     */\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the decimals places of the token.\\r\\n     */\\r\\n    function decimals() external view returns (uint);\\r\\n}\"},\"IERC20Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface for the ownable functions from the ERC20 standard.\\r\\n */\\r\\ncontract IERC20Ownable {\\r\\n    address public owner;\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\t/**\\r\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender account.\\r\\n     **/\\r\\n   constructor() {\\r\\n      owner = msg.sender;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     **/\\r\\n    modifier onlyOwner() {\\r\\n      require(msg.sender == owner);\\r\\n      _;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\r\\n     * @param newOwner The address to transfer ownership to.\\r\\n     **/\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n      require(newOwner != address(0));\\r\\n      emit OwnershipTransferred(owner, newOwner);\\r\\n      owner = newOwner;\\r\\n    }\\r\\n}\"},\"lorcoin.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\n// ----------------------------------------------------------------------------\\r\\n// LorCoin smart contract\\r\\n//\\r\\n// Symbol        \\t: LORY\\r\\n// Name          \\t: LorCoin\\r\\n// Total supply  \\t: 500 millions\\r\\n// Mineable Suply\\t: 200 millions\\r\\n// Reward Stages\\t: 40\\r\\n// Decimals      \\t: 18\\r\\n//\\r\\n// Created: 2021\\r\\n// ----------------------------------------------------------------------------\\r\\n\\r\\n//Compiler Version\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n//Dependencies\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./IERC20Metadata.sol\\\";\\r\\nimport \\\"./IERC20Ownable.sol\\\";\\r\\nimport \\\"./Context.sol\\\";\\r\\n\\r\\n//----------------------------------------------------------------------------\\r\\n// Safe Math Library\\r\\n//----------------------------------------------------------------------------\\r\\nlibrary SafeMath {\\r\\n\\r\\n    function add(uint a, uint b) internal pure returns (uint c) {\\r\\n        c = a + b;\\r\\n        require(c \\u003e= a);\\r\\n    }\\r\\n\\r\\n    function sub(uint a, uint b) internal pure returns (uint c) {\\r\\n        require(b \\u003c= a);\\r\\n        c = a - b;\\r\\n    }\\r\\n\\r\\n    function mul(uint a, uint b) internal pure returns (uint c) {\\r\\n        c = a * b;\\r\\n        require(a == 0 || c / a == b);\\r\\n    }\\r\\n\\r\\n    function div(uint a, uint b) internal pure returns (uint c) {\\r\\n        require(b \\u003e 0);\\r\\n        c = a / b;\\r\\n    }\\r\\n    \\r\\n    function ceil(uint a, uint m) internal pure returns (uint) {\\r\\n        uint c = add(a,m);\\r\\n        uint d = sub(c,1);\\r\\n        return mul(div(d, m),m);\\r\\n    }\\r\\n}\\r\\n\\r\\n//----------------------------------------------------------------------------\\r\\n// Extended Math Library\\r\\n//----------------------------------------------------------------------------\\r\\nlibrary ExtendedMath {\\r\\n\\tusing SafeMath for uint;\\r\\n\\t\\r\\n    function limitLessThan(uint a, uint b) internal pure returns (uint c) {\\r\\n        if(a \\u003e b) return b;\\r\\n        return a;\\r\\n    }\\r\\n\\t\\r\\n\\tfunction findOnePercent(uint _tokenAmount) internal pure returns (uint){\\r\\n    \\tuint roundValue = _tokenAmount.ceil(100);\\r\\n    \\tuint onePercent = roundValue.mul(100).div(10000);\\r\\n    \\treturn onePercent;\\r\\n    }\\r\\n}\\r\\n\\r\\n//----------------------------------------------------------------------------\\r\\n// @title Standard contract for a token, that implements all neccessary\\r\\n// definitions and variables.\\r\\n//----------------------------------------------------------------------------\\r\\nabstract contract StandardToken is Context, IERC20, IERC20Metadata {\\r\\n    \\r\\n    using SafeMath for uint;\\r\\n    using ExtendedMath for uint;\\r\\n\\t\\r\\n    uint _totalSupply;\\r\\n    \\r\\n\\tmapping(address =\\u003e uint) balances;\\r\\n\\tmapping (address =\\u003e mapping (address =\\u003e uint)) internal allowed;\\r\\n    \\r\\n    /**\\r\\n     * Total amount of supply in circulation.\\r\\n\\t * @return uint\\r\\n\\t * Returns the amount.\\r\\n     **/\\r\\n    function  totalSupply() override public view returns (uint) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * Transfers a specified token amount to an address.\\r\\n\\t *\\r\\n     * @param _to is Address\\r\\n\\t * The address to transfer to.\\r\\n     * @param _value is uint\\r\\n\\t * The amount to be transferred from.\\r\\n\\t * @return bool\\r\\n\\t * Returns true for success and false if it failed.\\r\\n     **/\\r\\n    function transfer(address _to, uint _value) override public returns (bool) {\\r\\n        require(_to != address(0));\\r\\n        require(_value \\u003c= balances[msg.sender]);\\r\\n        \\r\\n        balances[_to] = balances[_to].add(_value);\\r\\n        balances[msg.sender] = balances[msg.sender].sub(_value);\\r\\n        emit Transfer(msg.sender, _to, _value);\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * Returns the balance of a specified address.\\r\\n\\t *\\r\\n     * @param _owner is Address\\r\\n\\t * The address to query the the balance from.\\r\\n     * @return uint\\r\\n\\t * A uint representing the amount owned by the specified address.\\r\\n     **/\\r\\n    function balanceOf(address _owner) override public view returns (uint) {\\r\\n        return balances[_owner];\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * Transfers a desired amount from one address to another.\\r\\n\\t * \\r\\n     * @param _from is Address\\r\\n\\t * Address the amount is being sent from.\\r\\n     * @param _to is Address\\r\\n\\t * Address the amount is being transfered to.\\r\\n     * @param _value is uint\\r\\n\\t * The amount that shall be transfered.\\r\\n     **/\\r\\n    function transferFrom(address _from, address _to, uint _value) override public returns (bool) {\\r\\n        require(_to != address(0));\\r\\n        require(_value \\u003c= balances[_from]);\\r\\n        require(_value \\u003c= allowed[_from][msg.sender]);\\r\\n    \\r\\n        balances[_from] = balances[_from].sub(_value);\\r\\n        balances[_to] = balances[_to].add(_value);\\r\\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\\r\\n        \\r\\n        emit Transfer(_from, _to, _value);\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * Approves the passed address to spend the specified amount of tokens on behalf of msg.sender.\\r\\n     *\\r\\n     * @param _spender is Address\\r\\n\\t * The address which will spend the funds.\\r\\n     * @param _value is uint\\r\\n\\t * The amount of tokens to be spent.\\r\\n     **/\\r\\n    function approve(address _spender, uint _value) override public returns (bool) {\\r\\n        allowed[msg.sender][_spender] = _value;\\r\\n        emit Approval(msg.sender, _spender, _value);\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * Function to check the amount of tokens that an owner allowed to a spender.\\r\\n     * @param _owner is Address\\r\\n\\t * The address which owns the funds.\\r\\n     * @param _spender is Address\\r\\n\\t * The address which will spend the funds.\\r\\n     * @return is uint\\r\\n\\t * A uint specifying the amount of tokens still available for the spender.\\r\\n     **/\\r\\n    function allowance(address _owner, address _spender) override public view returns (uint) {\\r\\n        return allowed[_owner][_spender];\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * Increases the amount of tokens that an owner allowed to a spender.\\r\\n     *\\r\\n     * The function \\u0027approve\\u0027 should be called when allowed[_spender] == 0. To increment\\r\\n     * the allowed value it\\u0027s better to use this function to avoid 2 calls (and wait until\\r\\n     * the first transaction is mined).\\r\\n\\t * - From MonolithDAO Token.sol\\r\\n\\t * \\r\\n     * @param _spender is Address\\r\\n\\t * The address which will spend the funds.\\r\\n     * @param _addedValue is Address\\r\\n\\t * The amount of tokens to increase the allowance by.\\r\\n     **/\\r\\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\\r\\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\\r\\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * Decreases the amount of tokens that an owner allowed to a spender.\\r\\n     *\\r\\n     * The function \\u0027approve\\u0027 should be called when allowed[_spender] == 0. To decrement\\r\\n     * the allowed value it\\u0027s better to use this function to avoid 2 calls (and wait until\\r\\n     * the first transaction is mined).\\r\\n\\t * - From MonolithDAO Token.sol\\r\\n\\t * \\r\\n     * @param _spender is Address\\r\\n\\t * The address which will spend the funds.\\r\\n     * @param _subtractedValue is Address\\r\\n\\t * The amount of tokens to decrease the allowance by.\\r\\n     **/\\r\\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\\r\\n        uint oldValue = allowed[msg.sender][_spender];\\r\\n        if (_subtractedValue \\u003e oldValue) {\\r\\n            allowed[msg.sender][_spender] = 0;\\r\\n        } else {\\r\\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\\r\\n        }\\r\\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\r\\n        return true;\\r\\n    }\\r\\n\\t\\r\\n}\\r\\n\\r\\n//----------------------------------------------------------------------------\\r\\n// @title Sets the configurable variables for the contract.\\r\\n//----------------------------------------------------------------------------\\r\\ncontract Configurable {\\r\\n    using SafeMath for uint;\\r\\n\\t\\r\\n    uint public constant cap = 100000000*10**18; \\r\\n    uint public constant basePrice = 10000000*10**18; \\r\\n\\t\\r\\n    uint public constant minableTokenSupply = 200000000*10**18;\\r\\n    uint public tokenReserve = 200000000*10**18;\\r\\n\\t\\r\\n    uint public tokensSold = 0;\\r\\n    uint public remainingSellTokens = 0;\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * Minting Variables\\r\\n\\t **/\\r\\n    uint public tokensMinted;\\r\\n\\tuint public latestDifficultyPeriodStarted;\\r\\n\\t\\r\\n\\tuint public  _MINIMUM_TARGET = 2**16;\\r\\n    uint public  _MAXIMUM_TARGET = 2**234;\\r\\n\\t\\r\\n    uint public _BLOCKS_BEFORE_READJUSTMENT = 1024;\\r\\n\\t\\r\\n    uint public miningTarget = _MAXIMUM_TARGET;\\r\\n    bytes32 public challengeNumber;\\r\\n\\t\\r\\n    uint public epochCount;\\r\\n\\t\\r\\n    uint public rewardEra;\\r\\n    uint public maxSupplyForEra;\\r\\n\\r\\n    address public lastRewardTo;\\r\\n    uint public lastRewardAmount;\\r\\n    uint public lastRewardEthBlockNumber;\\r\\n\\r\\n    mapping(bytes32 =\\u003e bytes32) solutionForChallenge;\\r\\n    event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber);\\r\\n}\\r\\n\\r\\n//----------------------------------------------------------------------------\\r\\n// @title Contract for a smart contract that implements a crowdsale \\r\\n// functionality.\\r\\n// Thanks to Stephen Hall!\\r\\n//----------------------------------------------------------------------------\\r\\nabstract contract CrowdsaleToken is StandardToken, Configurable, IERC20Ownable {\\r\\n    using SafeMath for uint;\\r\\n    using ExtendedMath for uint;\\r\\n    \\r\\n    enum Stages {\\r\\n        none,\\r\\n        icoStart, \\r\\n        icoEnd\\r\\n    }\\r\\n    Stages currentStage;\\r\\n  \\r\\n    //constructor\\r\\n    constructor() {\\r\\n        currentStage = Stages.none;\\r\\n        _totalSupply = _totalSupply.add(tokenReserve);\\r\\n        remainingSellTokens = cap;\\r\\n\\t\\t\\r\\n\\t\\trewardEra = 0;\\r\\n\\t\\ttokensMinted = 0;\\r\\n\\t\\tmaxSupplyForEra = minableTokenSupply.div(2);\\r\\n\\t\\tlatestDifficultyPeriodStarted = block.number;\\r\\n\\t\\t\\r\\n\\t\\t_startNewMiningEpoch();\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * Receive function to send Ether to during crowd sale.\\r\\n     **/\\r\\n    receive () external payable {\\r\\n        require(currentStage == Stages.icoStart);\\r\\n        require(msg.value \\u003e 0);\\r\\n        require(remainingSellTokens \\u003e 0);\\r\\n        \\r\\n        \\r\\n        uint weiAmount = msg.value;\\r\\n        uint tokens = weiAmount.mul(basePrice).div(1 ether);\\r\\n        uint returnWei = 0;\\r\\n        \\r\\n        if(tokensSold.add(tokens) \\u003e cap){\\r\\n            uint newTokens = cap.sub(tokensSold);\\r\\n            uint newWei = newTokens.div(basePrice).mul(1 ether);\\r\\n            returnWei = weiAmount.sub(newWei);\\r\\n            weiAmount = newWei;\\r\\n            tokens = newTokens;\\r\\n        }\\r\\n        \\r\\n        tokensSold = tokensSold.add(tokens);\\r\\n        remainingSellTokens = cap.sub(tokensSold);\\r\\n        if(returnWei \\u003e 0){\\r\\n            payable(msg.sender).transfer(returnWei);\\r\\n            emit Transfer(address(this), msg.sender, returnWei);\\r\\n        }\\r\\n        \\r\\n\\t\\tuint tokensToAdd = tokens.findOnePercent();\\r\\n\\t\\ttokenReserve = tokenReserve.sub(tokensToAdd);\\r\\n        uint tokensToTransfer = tokens.add(tokensToAdd);\\r\\n        balances[msg.sender] = balances[msg.sender].add(tokensToTransfer);\\r\\n        emit Transfer(address(this), msg.sender, tokensToTransfer);\\r\\n\\t\\t\\r\\n        _totalSupply = _totalSupply.add(tokens);\\r\\n        \\r\\n\\t\\tpayable(owner).transfer(weiAmount);\\r\\n    }\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * Fallback method\\r\\n\\t **/\\r\\n\\tfallback () external payable {\\r\\n\\t\\trevert();\\r\\n\\t}\\r\\n\\t\\r\\n\\t/**\\r\\n     * Starts the crowdsale.\\r\\n     **/\\r\\n    function startIco() public onlyOwner {\\r\\n        require(currentStage != Stages.icoEnd);\\r\\n        currentStage = Stages.icoStart;\\r\\n    }\\r\\n\\t\\r\\n\\t/**\\r\\n     * Ends the crowdsale.\\r\\n     **/\\r\\n    function endIco() internal {\\r\\n        currentStage = Stages.icoEnd;\\r\\n        \\r\\n        if(remainingSellTokens \\u003e 0)\\r\\n            balances[owner] = balances[owner].add(remainingSellTokens);\\r\\n\\t\\t_totalSupply = _totalSupply.add(remainingSellTokens);\\r\\n        \\r\\n        payable(owner).transfer(address(this).balance); \\r\\n\\t\\t\\r\\n        balances[owner] = balances[owner].add(tokenReserve);\\r\\n        emit Transfer(address(this), owner, tokenReserve);\\r\\n    }\\r\\n\\t\\r\\n\\t/**\\r\\n     * Finalizes the crowdsale and ends it.\\r\\n     **/\\r\\n    function finalizeIco() public onlyOwner {\\r\\n        require(currentStage != Stages.icoEnd);\\r\\n        endIco();\\r\\n    }\\r\\n    \\r\\n    /*\\r\\n\\t * Minting function that can be called to gain a reward\\r\\n\\t * if Proof-of-Work was successfully provided.\\r\\n\\t * \\r\\n\\t * @param _nonce is uint265\\r\\n\\t * The number that has been found by the sender.\\r\\n\\t * @param _challenge_digest is bytes32\\r\\n\\t * The challenge the nonce is for.\\r\\n\\t *\\r\\n\\t * Thanks to 0xBitcoin!\\r\\n\\t */\\r\\n\\t function mint(uint256 _nonce, bytes32 _challenge_digest) public returns (bool success) {\\r\\n\\r\\n\\t\\tbytes32 digest =  keccak256(abi.encodePacked(challengeNumber, msg.sender, _nonce ));\\r\\n\\r\\n\\t\\tif (digest != _challenge_digest) revert();\\r\\n\\t\\tif(uint256(digest) \\u003e miningTarget) revert();\\r\\n\\r\\n\\t\\tbytes32 solution = solutionForChallenge[challengeNumber];\\r\\n\\t\\tsolutionForChallenge[challengeNumber] = digest;\\r\\n\\t\\tif(solution != 0x0) revert();\\r\\n\\r\\n\\t\\tuint reward_amount = getMiningReward();\\r\\n\\t\\tbalances[msg.sender] = balances[msg.sender].add(reward_amount);\\r\\n\\t\\ttokensMinted = tokensMinted.add(reward_amount);\\r\\n\\t\\t_totalSupply = _totalSupply.add(reward_amount);\\r\\n\\r\\n\\t\\tassert(tokensMinted \\u003c= maxSupplyForEra);\\r\\n\\r\\n\\t\\tlastRewardTo = msg.sender;\\r\\n\\t\\tlastRewardAmount = reward_amount;\\r\\n\\t\\tlastRewardEthBlockNumber = block.number;\\r\\n\\r\\n\\t\\t_startNewMiningEpoch();\\r\\n\\t\\tMint(msg.sender, reward_amount, epochCount, challengeNumber );\\r\\n\\r\\n\\t\\treturn true;\\r\\n\\t}\\r\\n\\r\\n\\r\\n\\t/*\\r\\n\\t * Starts the next minting proccess, Checks if a new reward era has been \\r\\n\\t * reached, the difficuly of the minting has to be adjusted and sets \\r\\n\\t * the next challenge.\\r\\n\\t */\\r\\n\\tfunction _startNewMiningEpoch() internal {\\r\\n\\r\\n\\t  if( tokensMinted.add(getMiningReward()) \\u003e maxSupplyForEra \\u0026\\u0026 rewardEra \\u003c 39)\\r\\n\\t  {\\r\\n\\t\\trewardEra = rewardEra + 1;\\r\\n\\t  }\\r\\n\\r\\n\\t  maxSupplyForEra = minableTokenSupply - minableTokenSupply.div( 2**(rewardEra + 1));\\r\\n\\r\\n\\t  epochCount = epochCount.add(1);\\r\\n\\r\\n\\t  if(epochCount % _BLOCKS_BEFORE_READJUSTMENT == 0)\\r\\n\\t  {\\r\\n\\t\\t_reAdjustDifficulty();\\r\\n\\t  }\\r\\n\\r\\n\\t  challengeNumber = blockhash(block.number - 1);\\r\\n\\t}\\r\\n\\r\\n\\r\\n\\t//https://en.bitcoin.it/wiki/Difficulty#What_is_the_formula_for_difficulty.3F\\r\\n\\t/**\\r\\n\\t * Function that adjust the difficulty of the minting process when called.\\r\\n\\t **/\\r\\n\\tfunction _reAdjustDifficulty() internal {\\r\\n\\r\\n\\t\\tuint ethBlocksSinceLastDifficultyPeriod = block.number - latestDifficultyPeriodStarted;\\r\\n\\t\\tuint epochsMined = _BLOCKS_BEFORE_READJUSTMENT;\\r\\n\\t\\tuint targetEthBlocksPerDiffPeriod = epochsMined * 45;\\r\\n\\r\\n\\t\\tif( ethBlocksSinceLastDifficultyPeriod \\u003c targetEthBlocksPerDiffPeriod )\\r\\n\\t\\t{\\r\\n\\t\\t  uint excess_block_pct = (targetEthBlocksPerDiffPeriod.mul(100)).div( ethBlocksSinceLastDifficultyPeriod );\\r\\n\\t\\t  uint excess_block_pct_extra = excess_block_pct.sub(100).limitLessThan(1000);\\r\\n\\t\\t  miningTarget = miningTarget.sub(miningTarget.div(2000).mul(excess_block_pct_extra));\\r\\n\\t\\t}\\r\\n\\t\\telse\\r\\n\\t\\t{\\r\\n\\t\\t  uint shortage_block_pct = (ethBlocksSinceLastDifficultyPeriod.mul(100)).div( targetEthBlocksPerDiffPeriod );\\r\\n\\t\\t  uint shortage_block_pct_extra = shortage_block_pct.sub(100).limitLessThan(1000);\\r\\n\\t\\t  miningTarget = miningTarget.add(miningTarget.div(2000).mul(shortage_block_pct_extra));\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tlatestDifficultyPeriodStarted = block.number;\\r\\n\\r\\n\\t\\tif(miningTarget \\u003c _MINIMUM_TARGET)\\r\\n\\t\\t{\\r\\n\\t\\t  miningTarget = _MINIMUM_TARGET;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif(miningTarget \\u003e _MAXIMUM_TARGET)\\r\\n\\t\\t{\\r\\n\\t\\t  miningTarget = _MAXIMUM_TARGET;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * Get the current challenge for minting tokens.\\r\\n\\t * \\r\\n\\t * @return byte32\\r\\n\\t * A \\u0027byte32\\u0027 variable that represents the current challenge.\\r\\n\\t **/\\r\\n\\tfunction getChallengeNumber() public view returns (bytes32) {\\r\\n\\t\\treturn challengeNumber;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * The numbers of zeroes the submitted digest to the minting function\\r\\n\\t * must to contain.\\r\\n\\t * \\r\\n\\t * @return uint\\r\\n\\t * A \\u0027uint\\u0027 variable that represents the amount of zeroes.\\r\\n\\t **/\\r\\n\\tfunction getMiningDifficulty() public view returns (uint) {\\r\\n\\t\\treturn _MAXIMUM_TARGET.div(miningTarget);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * Get the current minting target that is also used to calculate\\r\\n\\t * the difficulty of the minting process.\\r\\n\\t *\\r\\n\\t * @return uint\\r\\n\\t * A \\u0027uint\\u0027 variable that represents the minting target.\\r\\n\\t **/\\r\\n\\tfunction getMiningTarget() public view returns (uint) {\\r\\n\\t   return miningTarget;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * Gets the current token reward for successfully calling the \\u0027mint\\u0027 function.\\r\\n\\t * The reward starts at 100 and is halved after every reward era.\\r\\n\\t *\\r\\n\\t * @return uint\\r\\n\\t * A \\u0027uint\\u0027 variable that represents the minting reward.\\r\\n\\t **/\\r\\n\\tfunction getMiningReward() public view returns (uint) {\\r\\n\\t\\t return (100 * 10**uint(18) ).div( 2**rewardEra ) ;\\r\\n\\t}\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * Gets the amount of all tokens that have been minted so far.\\r\\n\\t *\\r\\n\\t * @return uint\\r\\n\\t * A \\u0027uint\\u0027 variable that represents the amount of minted tokens.\\r\\n\\t **/\\r\\n\\tfunction getMintedTokenAmount() public view returns (uint) {\\r\\n\\t\\treturn tokensMinted;\\r\\n\\t}\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * Gets the amount of all tokens that can still be minted.\\r\\n\\t *\\r\\n\\t * @return uint\\r\\n\\t * A \\u0027uint\\u0027 variable that represents the amount of mintable tokens.\\r\\n\\t **/\\r\\n\\tfunction getMintableTokenAmount() public view returns (uint) {\\r\\n\\t\\treturn minableTokenSupply.sub(tokensMinted);\\r\\n\\t}\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * Gets the amount of all the tokens that can ever exist.\\r\\n\\t *\\r\\n\\t * @return uint\\r\\n\\t * A \\u0027uint\\u0027 variable that represents the maximal amount of tokens.\\r\\n\\t **/\\r\\n\\tfunction getMaxSupply() public view returns (uint) {\\r\\n\\t\\treturn tokenReserve.add(minableTokenSupply).add(cap);\\r\\n\\t}\\r\\n}\\r\\n\\r\\n//----------------------------------------------------------------------------\\r\\n// @title The actual contract for LorCoin.\\r\\n//----------------------------------------------------------------------------\\r\\ncontract LorCoin is CrowdsaleToken {\\r\\n    string override public constant name = \\\"LorCoin\\\";\\r\\n    string override public constant symbol = \\\"LORY\\\";\\r\\n    uint override public constant decimals = 18;\\r\\n}\\r\\n\\r\\n\"}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epochCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"newChallengeNumber\",\"type\":\"bytes32\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"_BLOCKS_BEFORE_READJUSTMENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_MAXIMUM_TARGET\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_MINIMUM_TARGET\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"basePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"challengeNumber\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epochCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalizeIco\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChallengeNumber\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMiningDifficulty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMiningReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMiningTarget\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMintableTokenAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMintedTokenAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRewardAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRewardEthBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRewardTo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestDifficultyPeriodStarted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSupplyForEra\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minableTokenSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"miningTarget\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_challenge_digest\",\"type\":\"bytes32\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"remainingSellTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardEra\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startIco\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenReserve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensMinted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"LorCoin","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://c5769baae8a266a6337ee71e18f29590f2cd6ba2364d9fb13b99dad1758342f7"}]}