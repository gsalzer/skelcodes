{"status":"1","message":"OK","result":[{"SourceCode":"// Sources flattened with hardhat v2.4.0 https://hardhat.org\r\n\r\n// File contracts/auxiliary/interfaces/v0.8.4/IERC20Aux.sol\r\n\r\n\r\npragma solidity 0.8.4;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20Aux {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n// File contracts/auxiliary/interfaces/v0.8.4/IApi3Token.sol\r\n\r\npragma solidity 0.8.4;\r\n\r\ninterface IApi3Token is IERC20Aux {\r\n    event MinterStatusUpdated(\r\n        address indexed minterAddress,\r\n        bool minterStatus\r\n        );\r\n\r\n    event BurnerStatusUpdated(\r\n        address indexed burnerAddress,\r\n        bool burnerStatus\r\n        );\r\n\r\n    function updateMinterStatus(\r\n        address minterAddress,\r\n        bool minterStatus\r\n        )\r\n        external;\r\n\r\n    function updateBurnerStatus(bool burnerStatus)\r\n        external;\r\n\r\n    function mint(\r\n        address account,\r\n        uint256 amount\r\n        )\r\n        external;\r\n\r\n    function burn(uint256 amount)\r\n        external;\r\n\r\n    function getMinterStatus(address minterAddress)\r\n        external\r\n        view\r\n        returns (bool minterStatus);\r\n\r\n    function getBurnerStatus(address burnerAddress)\r\n        external\r\n        view\r\n        returns (bool burnerStatus);\r\n}\r\n\r\n\r\n// File contracts/interfaces/IStateUtils.sol\r\n\r\npragma solidity 0.8.4;\r\n\r\ninterface IStateUtils {\r\n    event SetDaoApps(\r\n        address agentAppPrimary,\r\n        address agentAppSecondary,\r\n        address votingAppPrimary,\r\n        address votingAppSecondary\r\n        );\r\n\r\n    event SetClaimsManagerStatus(\r\n        address indexed claimsManager,\r\n        bool indexed status\r\n        );\r\n\r\n    event SetStakeTarget(uint256 stakeTarget);\r\n\r\n    event SetMaxApr(uint256 maxApr);\r\n\r\n    event SetMinApr(uint256 minApr);\r\n\r\n    event SetUnstakeWaitPeriod(uint256 unstakeWaitPeriod);\r\n\r\n    event SetAprUpdateStep(uint256 aprUpdateStep);\r\n\r\n    event SetProposalVotingPowerThreshold(uint256 proposalVotingPowerThreshold);\r\n\r\n    event UpdatedLastProposalTimestamp(\r\n        address indexed user,\r\n        uint256 lastProposalTimestamp,\r\n        address votingApp\r\n        );\r\n\r\n    function setDaoApps(\r\n        address _agentAppPrimary,\r\n        address _agentAppSecondary,\r\n        address _votingAppPrimary,\r\n        address _votingAppSecondary\r\n        )\r\n        external;\r\n\r\n    function setClaimsManagerStatus(\r\n        address claimsManager,\r\n        bool status\r\n        )\r\n        external;\r\n\r\n    function setStakeTarget(uint256 _stakeTarget)\r\n        external;\r\n\r\n    function setMaxApr(uint256 _maxApr)\r\n        external;\r\n\r\n    function setMinApr(uint256 _minApr)\r\n        external;\r\n\r\n    function setUnstakeWaitPeriod(uint256 _unstakeWaitPeriod)\r\n        external;\r\n\r\n    function setAprUpdateStep(uint256 _aprUpdateStep)\r\n        external;\r\n\r\n    function setProposalVotingPowerThreshold(uint256 _proposalVotingPowerThreshold)\r\n        external;\r\n\r\n    function updateLastProposalTimestamp(address userAddress)\r\n        external;\r\n\r\n    function isGenesisEpoch()\r\n        external\r\n        view\r\n        returns (bool);\r\n}\r\n\r\n\r\n// File contracts/StateUtils.sol\r\n\r\npragma solidity 0.8.4;\r\n\r\n\r\n/// @title Contract that keeps state variables\r\ncontract StateUtils is IStateUtils {\r\n    struct Checkpoint {\r\n        uint32 fromBlock;\r\n        uint224 value;\r\n    }\r\n\r\n    struct AddressCheckpoint {\r\n        uint32 fromBlock;\r\n        address _address;\r\n    }\r\n\r\n    struct Reward {\r\n        uint32 atBlock;\r\n        uint224 amount;\r\n        uint256 totalSharesThen;\r\n        uint256 totalStakeThen;\r\n    }\r\n\r\n    struct User {\r\n        Checkpoint[] shares;\r\n        Checkpoint[] delegatedTo;\r\n        AddressCheckpoint[] delegates;\r\n        uint256 unstaked;\r\n        uint256 vesting;\r\n        uint256 unstakeAmount;\r\n        uint256 unstakeShares;\r\n        uint256 unstakeScheduledFor;\r\n        uint256 lastDelegationUpdateTimestamp;\r\n        uint256 lastProposalTimestamp;\r\n    }\r\n\r\n    struct LockedCalculation {\r\n        uint256 initialIndEpoch;\r\n        uint256 nextIndEpoch;\r\n        uint256 locked;\r\n    }\r\n\r\n    /// @notice Length of the epoch in which the staking reward is paid out\r\n    /// once. It is hardcoded as 7 days.\r\n    /// @dev In addition to regulating reward payments, this variable is used\r\n    /// for two additional things:\r\n    /// (1) After a user makes a proposal, they cannot make a second one\r\n    /// before `EPOCH_LENGTH` has passed\r\n    /// (2) After a user updates their delegation status, they have to wait\r\n    /// `EPOCH_LENGTH` before updating it again\r\n    uint256 public constant EPOCH_LENGTH = 1 weeks;\r\n\r\n    /// @notice Number of epochs before the staking rewards get unlocked.\r\n    /// Hardcoded as 52 epochs, which approximately corresponds to a year with\r\n    /// an `EPOCH_LENGTH` of 1 week.\r\n    uint256 public constant REWARD_VESTING_PERIOD = 52;\r\n\r\n    // All percentage values are represented as 1e18 = 100%\r\n    uint256 internal constant ONE_PERCENT = 1e18 / 100;\r\n    uint256 internal constant HUNDRED_PERCENT = 1e18;\r\n\r\n    // To assert that typecasts do not overflow\r\n    uint256 internal constant MAX_UINT32 = 2**32 - 1;\r\n    uint256 internal constant MAX_UINT224 = 2**224 - 1;\r\n\r\n    /// @notice Epochs are indexed as `block.timestamp / EPOCH_LENGTH`.\r\n    /// `genesisEpoch` is the index of the epoch in which the pool is deployed.\r\n    /// @dev No reward gets paid and proposals are not allowed in the genesis\r\n    /// epoch\r\n    uint256 public immutable genesisEpoch;\r\n\r\n    /// @notice API3 token contract\r\n    IApi3Token public immutable api3Token;\r\n\r\n    /// @notice TimelockManager contract\r\n    address public immutable timelockManager;\r\n\r\n    /// @notice Address of the primary Agent app of the API3 DAO\r\n    /// @dev Primary Agent can be operated through the primary Api3Voting app.\r\n    /// The primary Api3Voting app requires a higher quorum by default, and the\r\n    /// primary Agent is more privileged.\r\n    address public agentAppPrimary;\r\n\r\n    /// @notice Address of the secondary Agent app of the API3 DAO\r\n    /// @dev Secondary Agent can be operated through the secondary Api3Voting\r\n    /// app. The secondary Api3Voting app requires a lower quorum by default,\r\n    /// and the primary Agent is less privileged.\r\n    address public agentAppSecondary;\r\n\r\n    /// @notice Address of the primary Api3Voting app of the API3 DAO\r\n    /// @dev Used to operate the primary Agent\r\n    address public votingAppPrimary;\r\n\r\n    /// @notice Address of the secondary Api3Voting app of the API3 DAO\r\n    /// @dev Used to operate the secondary Agent\r\n    address public votingAppSecondary;\r\n\r\n    /// @notice Mapping that keeps the claims manager statuses of addresses\r\n    /// @dev A claims manager is a contract that is authorized to pay out\r\n    /// claims from the staking pool, effectively slashing the stakers. The\r\n    /// statuses are kept as a mapping to support multiple claims managers.\r\n    mapping(address => bool) public claimsManagerStatus;\r\n\r\n    /// @notice Records of rewards paid in each epoch\r\n    /// @dev `.atBlock` of a past epoch's reward record being `0` means no\r\n    /// reward was paid for that epoch\r\n    mapping(uint256 => Reward) public epochIndexToReward;\r\n\r\n    /// @notice Epoch index of the most recent reward\r\n    uint256 public epochIndexOfLastReward;\r\n\r\n    /// @notice Total number of tokens staked at the pool\r\n    uint256 public totalStake;\r\n\r\n    /// @notice Stake target the pool will aim to meet in percentages of the\r\n    /// total token supply. The staking rewards increase if the total staked\r\n    /// amount is below this, and vice versa.\r\n    /// @dev Default value is 50% of the total API3 token supply. This\r\n    /// parameter is governable by the DAO.\r\n    uint256 public stakeTarget = ONE_PERCENT * 50;\r\n\r\n    /// @notice Minimum APR (annual percentage rate) the pool will pay as\r\n    /// staking rewards in percentages\r\n    /// @dev Default value is 2.5%. This parameter is governable by the DAO.\r\n    uint256 public minApr = ONE_PERCENT * 25 / 10;\r\n\r\n    /// @notice Maximum APR (annual percentage rate) the pool will pay as\r\n    /// staking rewards in percentages\r\n    /// @dev Default value is 75%. This parameter is governable by the DAO.\r\n    uint256 public maxApr = ONE_PERCENT * 75;\r\n\r\n    /// @notice Steps in which APR will be updated in percentages\r\n    /// @dev Default value is 1%. This parameter is governable by the DAO.\r\n    uint256 public aprUpdateStep = ONE_PERCENT;\r\n\r\n    /// @notice Users need to schedule an unstake and wait for\r\n    /// `unstakeWaitPeriod` before being able to unstake. This is to prevent\r\n    /// the stakers from frontrunning insurance claims by unstaking to evade\r\n    /// them, or repeatedly unstake/stake to work around the proposal spam\r\n    /// protection. The tokens awaiting to be unstaked during this period do\r\n    /// not grant voting power or rewards.\r\n    /// @dev This parameter is governable by the DAO, and the DAO is expected\r\n    /// to set this to a value that is large enough to allow insurance claims\r\n    /// to be resolved.\r\n    uint256 public unstakeWaitPeriod = EPOCH_LENGTH;\r\n\r\n    /// @notice Minimum voting power the users must have to be able to make\r\n    /// proposals (in percentages)\r\n    /// @dev Delegations count towards voting power.\r\n    /// Default value is 0.1%. This parameter is governable by the DAO.\r\n    uint256 public proposalVotingPowerThreshold = ONE_PERCENT / 10;\r\n\r\n    /// @notice APR that will be paid next epoch\r\n    /// @dev This value will reach an equilibrium based on the stake target.\r\n    /// Every epoch (week), APR/52 of the total staked tokens will be added to\r\n    /// the pool, effectively distributing them to the stakers.\r\n    uint256 public apr = (maxApr + minApr) / 2;\r\n\r\n    /// @notice User records\r\n    mapping(address => User) public users;\r\n\r\n    // Keeps the total number of shares of the pool\r\n    Checkpoint[] public poolShares;\r\n\r\n    // Keeps user states used in `withdrawPrecalculated()` calls\r\n    mapping(address => LockedCalculation) public userToLockedCalculation;\r\n\r\n    // Kept to prevent third parties from frontrunning the initialization\r\n    // `setDaoApps()` call and grief the deployment\r\n    address private deployer;\r\n\r\n    /// @dev Reverts if the caller is not an API3 DAO Agent\r\n    modifier onlyAgentApp() {\r\n        require(\r\n            msg.sender == agentAppPrimary || msg.sender == agentAppSecondary,\r\n            \"Pool: Caller not agent\"\r\n            );\r\n        _;\r\n    }\r\n\r\n    /// @dev Reverts if the caller is not the primary API3 DAO Agent\r\n    modifier onlyAgentAppPrimary() {\r\n        require(\r\n            msg.sender == agentAppPrimary,\r\n            \"Pool: Caller not primary agent\"\r\n            );\r\n        _;\r\n    }\r\n\r\n    /// @dev Reverts if the caller is not an API3 DAO Api3Voting app\r\n    modifier onlyVotingApp() {\r\n        require(\r\n            msg.sender == votingAppPrimary || msg.sender == votingAppSecondary,\r\n            \"Pool: Caller not voting app\"\r\n            );\r\n        _;\r\n    }\r\n\r\n    /// @param api3TokenAddress API3 token contract address\r\n    /// @param timelockManagerAddress Timelock manager contract address\r\n    constructor(\r\n        address api3TokenAddress,\r\n        address timelockManagerAddress\r\n        )\r\n    {\r\n        require(\r\n            api3TokenAddress != address(0),\r\n            \"Pool: Invalid Api3Token\"\r\n            );\r\n        require(\r\n            timelockManagerAddress != address(0),\r\n            \"Pool: Invalid TimelockManager\"\r\n            );\r\n        deployer = msg.sender;\r\n        api3Token = IApi3Token(api3TokenAddress);\r\n        timelockManager = timelockManagerAddress;\r\n        // Initialize the share price at 1\r\n        updateCheckpointArray(poolShares, 1);\r\n        totalStake = 1;\r\n        // Set the current epoch as the genesis epoch and skip its reward\r\n        // payment\r\n        uint256 currentEpoch = block.timestamp / EPOCH_LENGTH;\r\n        genesisEpoch = currentEpoch;\r\n        epochIndexOfLastReward = currentEpoch;\r\n    }\r\n\r\n    /// @notice Called after deployment to set the addresses of the DAO apps\r\n    /// @dev This can also be called later on by the primary Agent to update\r\n    /// all app addresses as a means of an upgrade\r\n    /// @param _agentAppPrimary Address of the primary Agent\r\n    /// @param _agentAppSecondary Address of the secondary Agent\r\n    /// @param _votingAppPrimary Address of the primary Api3Voting app\r\n    /// @param _votingAppSecondary Address of the secondary Api3Voting app\r\n    function setDaoApps(\r\n        address _agentAppPrimary,\r\n        address _agentAppSecondary,\r\n        address _votingAppPrimary,\r\n        address _votingAppSecondary\r\n        )\r\n        external\r\n        override\r\n    {\r\n        // solhint-disable-next-line reason-string\r\n        require(\r\n            msg.sender == agentAppPrimary\r\n                || (agentAppPrimary == address(0) && msg.sender == deployer),\r\n            \"Pool: Caller not primary agent or deployer initializing values\"\r\n            );\r\n        require(\r\n            _agentAppPrimary != address(0)\r\n                && _agentAppSecondary != address(0)\r\n                && _votingAppPrimary != address(0)\r\n                && _votingAppSecondary != address(0),\r\n            \"Pool: Invalid DAO apps\"\r\n            );\r\n        agentAppPrimary = _agentAppPrimary;\r\n        agentAppSecondary = _agentAppSecondary;\r\n        votingAppPrimary = _votingAppPrimary;\r\n        votingAppSecondary = _votingAppSecondary;\r\n        emit SetDaoApps(\r\n            agentAppPrimary,\r\n            agentAppSecondary,\r\n            votingAppPrimary,\r\n            votingAppSecondary\r\n            );\r\n    }\r\n\r\n    /// @notice Called by the primary DAO Agent to set the authorization status\r\n    /// of a claims manager contract\r\n    /// @dev The claims manager is a trusted contract that is allowed to\r\n    /// withdraw as many tokens as it wants from the pool to pay out insurance\r\n    /// claims.\r\n    /// Only the primary Agent can do this because it is a critical operation.\r\n    /// WARNING: A compromised contract being given claims manager status may\r\n    /// result in loss of staked funds. If a proposal has been made to call\r\n    /// this method to set a contract as a claims manager, you are recommended\r\n    /// to review the contract yourself and/or refer to the audit reports to\r\n    /// understand the implications.\r\n    /// @param claimsManager Claims manager contract address\r\n    /// @param status Authorization status\r\n    function setClaimsManagerStatus(\r\n        address claimsManager,\r\n        bool status\r\n        )\r\n        external\r\n        override\r\n        onlyAgentAppPrimary()\r\n    {\r\n        claimsManagerStatus[claimsManager] = status;\r\n        emit SetClaimsManagerStatus(\r\n            claimsManager,\r\n            status\r\n            );\r\n    }\r\n\r\n    /// @notice Called by the DAO Agent to set the stake target\r\n    /// @param _stakeTarget Stake target\r\n    function setStakeTarget(uint256 _stakeTarget)\r\n        external\r\n        override\r\n        onlyAgentApp()\r\n    {\r\n        require(\r\n            _stakeTarget <= HUNDRED_PERCENT,\r\n            \"Pool: Invalid percentage value\"\r\n            );\r\n        stakeTarget = _stakeTarget;\r\n        emit SetStakeTarget(_stakeTarget);\r\n    }\r\n\r\n    /// @notice Called by the DAO Agent to set the maximum APR\r\n    /// @param _maxApr Maximum APR\r\n    function setMaxApr(uint256 _maxApr)\r\n        external\r\n        override\r\n        onlyAgentApp()\r\n    {\r\n        require(\r\n            _maxApr >= minApr,\r\n            \"Pool: Max APR smaller than min\"\r\n            );\r\n        maxApr = _maxApr;\r\n        emit SetMaxApr(_maxApr);\r\n    }\r\n\r\n    /// @notice Called by the DAO Agent to set the minimum APR\r\n    /// @param _minApr Minimum APR\r\n    function setMinApr(uint256 _minApr)\r\n        external\r\n        override\r\n        onlyAgentApp()\r\n    {\r\n        require(\r\n            _minApr <= maxApr,\r\n            \"Pool: Min APR larger than max\"\r\n            );\r\n        minApr = _minApr;\r\n        emit SetMinApr(_minApr);\r\n    }\r\n\r\n    /// @notice Called by the primary DAO Agent to set the unstake waiting\r\n    /// period\r\n    /// @dev This may want to be increased to provide more time for insurance\r\n    /// claims to be resolved.\r\n    /// Even when the insurance functionality is not implemented, the minimum\r\n    /// valid value is `EPOCH_LENGTH` to prevent users from unstaking,\r\n    /// withdrawing and staking with another address to work around the\r\n    /// proposal spam protection.\r\n    /// Only the primary Agent can do this because it is a critical operation.\r\n    /// @param _unstakeWaitPeriod Unstake waiting period\r\n    function setUnstakeWaitPeriod(uint256 _unstakeWaitPeriod)\r\n        external\r\n        override\r\n        onlyAgentAppPrimary()\r\n    {\r\n        require(\r\n            _unstakeWaitPeriod >= EPOCH_LENGTH,\r\n            \"Pool: Period shorter than epoch\"\r\n            );\r\n        unstakeWaitPeriod = _unstakeWaitPeriod;\r\n        emit SetUnstakeWaitPeriod(_unstakeWaitPeriod);\r\n    }\r\n\r\n    /// @notice Called by the primary DAO Agent to set the APR update steps\r\n    /// @dev aprUpdateStep can be 0% or 100%+.\r\n    /// Only the primary Agent can do this because it is a critical operation.\r\n    /// @param _aprUpdateStep APR update steps\r\n    function setAprUpdateStep(uint256 _aprUpdateStep)\r\n        external\r\n        override\r\n        onlyAgentAppPrimary()\r\n    {\r\n        aprUpdateStep = _aprUpdateStep;\r\n        emit SetAprUpdateStep(_aprUpdateStep);\r\n    }\r\n\r\n    /// @notice Called by the primary DAO Agent to set the voting power\r\n    /// threshold for proposals\r\n    /// @dev Only the primary Agent can do this because it is a critical\r\n    /// operation.\r\n    /// @param _proposalVotingPowerThreshold Voting power threshold for\r\n    /// proposals\r\n    function setProposalVotingPowerThreshold(uint256 _proposalVotingPowerThreshold)\r\n        external\r\n        override\r\n        onlyAgentAppPrimary()\r\n    {\r\n        require(\r\n            _proposalVotingPowerThreshold >= ONE_PERCENT / 10\r\n                && _proposalVotingPowerThreshold <= ONE_PERCENT * 10,\r\n            \"Pool: Threshold outside limits\");\r\n        proposalVotingPowerThreshold = _proposalVotingPowerThreshold;\r\n        emit SetProposalVotingPowerThreshold(_proposalVotingPowerThreshold);\r\n    }\r\n\r\n    /// @notice Called by a DAO Api3Voting app at proposal creation-time to\r\n    /// update the timestamp of the user's last proposal\r\n    /// @param userAddress User address\r\n    function updateLastProposalTimestamp(address userAddress)\r\n        external\r\n        override\r\n        onlyVotingApp()\r\n    {\r\n        users[userAddress].lastProposalTimestamp = block.timestamp;\r\n        emit UpdatedLastProposalTimestamp(\r\n            userAddress,\r\n            block.timestamp,\r\n            msg.sender\r\n            );\r\n    }\r\n\r\n    /// @notice Called to check if we are in the genesis epoch\r\n    /// @dev Voting apps use this to prevent proposals from being made in the\r\n    /// genesis epoch\r\n    /// @return If the current epoch is the genesis epoch\r\n    function isGenesisEpoch()\r\n        external\r\n        view\r\n        override\r\n        returns (bool)\r\n    {\r\n        return block.timestamp / EPOCH_LENGTH == genesisEpoch;\r\n    }\r\n\r\n    /// @notice Called internally to update a checkpoint array by pushing a new\r\n    /// checkpoint\r\n    /// @dev We assume `block.number` will always fit in a uint32 and `value`\r\n    /// will always fit in a uint224. `value` will either be a raw token amount\r\n    /// or a raw pool share amount so this assumption will be correct in\r\n    /// practice with a token with 18 decimals, 1e8 initial total supply and no\r\n    /// hyperinflation.\r\n    /// @param checkpointArray Checkpoint array\r\n    /// @param value Value to be used to create the new checkpoint\r\n    function updateCheckpointArray(\r\n        Checkpoint[] storage checkpointArray,\r\n        uint256 value\r\n        )\r\n        internal\r\n    {\r\n        assert(block.number <= MAX_UINT32);\r\n        assert(value <= MAX_UINT224);\r\n        checkpointArray.push(Checkpoint({\r\n            fromBlock: uint32(block.number),\r\n            value: uint224(value)\r\n            }));\r\n    }\r\n\r\n    /// @notice Called internally to update an address-checkpoint array by\r\n    /// pushing a new checkpoint\r\n    /// @dev We assume `block.number` will always fit in a uint32\r\n    /// @param addressCheckpointArray Address-checkpoint array\r\n    /// @param _address Address to be used to create the new checkpoint\r\n    function updateAddressCheckpointArray(\r\n        AddressCheckpoint[] storage addressCheckpointArray,\r\n        address _address\r\n        )\r\n        internal\r\n    {\r\n        assert(block.number <= MAX_UINT32);\r\n        addressCheckpointArray.push(AddressCheckpoint({\r\n            fromBlock: uint32(block.number),\r\n            _address: _address\r\n            }));\r\n    }\r\n}\r\n\r\n\r\n// File contracts/interfaces/IGetterUtils.sol\r\n\r\npragma solidity 0.8.4;\r\n\r\ninterface IGetterUtils is IStateUtils {\r\n    function userVotingPowerAt(\r\n        address userAddress,\r\n        uint256 _block\r\n        )\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function userVotingPower(address userAddress)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function totalSharesAt(uint256 _block)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function totalShares()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function userSharesAt(\r\n        address userAddress,\r\n        uint256 _block\r\n        )\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function userShares(address userAddress)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function userStake(address userAddress)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function delegatedToUserAt(\r\n        address userAddress,\r\n        uint256 _block\r\n        )\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function delegatedToUser(address userAddress)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function userDelegateAt(\r\n        address userAddress,\r\n        uint256 _block\r\n        )\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    function userDelegate(address userAddress)\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    function userLocked(address userAddress)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getUser(address userAddress)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 unstaked,\r\n            uint256 vesting,\r\n            uint256 unstakeShares,\r\n            uint256 unstakeAmount,\r\n            uint256 unstakeScheduledFor,\r\n            uint256 lastDelegationUpdateTimestamp,\r\n            uint256 lastProposalTimestamp\r\n            );\r\n}\r\n\r\n\r\n// File contracts/GetterUtils.sol\r\n\r\npragma solidity 0.8.4;\r\n\r\n\r\n/// @title Contract that implements getters\r\nabstract contract GetterUtils is StateUtils, IGetterUtils {\r\n    /// @notice Called to get the voting power of a user at a specific block\r\n    /// @param userAddress User address\r\n    /// @param _block Block number for which the query is being made for\r\n    /// @return Voting power of the user at the block\r\n    function userVotingPowerAt(\r\n        address userAddress,\r\n        uint256 _block\r\n        )\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        // Users that have a delegate have no voting power\r\n        if (userDelegateAt(userAddress, _block) != address(0))\r\n        {\r\n            return 0;\r\n        }\r\n        return userSharesAt(userAddress, _block)\r\n            + delegatedToUserAt(userAddress, _block);\r\n    }\r\n\r\n    /// @notice Called to get the current voting power of a user\r\n    /// @param userAddress User address\r\n    /// @return Current voting power of the user\r\n    function userVotingPower(address userAddress)\r\n        external\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return userVotingPowerAt(userAddress, block.number);\r\n    }\r\n\r\n    /// @notice Called to get the total pool shares at a specific block\r\n    /// @dev Total pool shares also corresponds to total voting power\r\n    /// @param _block Block number for which the query is being made for\r\n    /// @return Total pool shares at the block\r\n    function totalSharesAt(uint256 _block)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return getValueAt(poolShares, _block);\r\n    }\r\n\r\n    /// @notice Called to get the current total pool shares\r\n    /// @dev Total pool shares also corresponds to total voting power\r\n    /// @return Current total pool shares\r\n    function totalShares()\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return totalSharesAt(block.number);\r\n    }\r\n\r\n    /// @notice Called to get the pool shares of a user at a specific block\r\n    /// @param userAddress User address\r\n    /// @param _block Block number for which the query is being made for\r\n    /// @return Pool shares of the user at the block\r\n    function userSharesAt(\r\n        address userAddress,\r\n        uint256 _block\r\n        )\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return getValueAt(users[userAddress].shares, _block);\r\n    }\r\n\r\n    /// @notice Called to get the current pool shares of a user\r\n    /// @param userAddress User address\r\n    /// @return Current pool shares of the user\r\n    function userShares(address userAddress)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return userSharesAt(userAddress, block.number);\r\n    }\r\n\r\n    /// @notice Called to get the current staked tokens of the user\r\n    /// @param userAddress User address\r\n    /// @return Current staked tokens of the user\r\n    function userStake(address userAddress)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return userShares(userAddress) * totalStake / totalShares();\r\n    }\r\n\r\n    /// @notice Called to get the voting power delegated to a user at a\r\n    /// specific block\r\n    /// @param userAddress User address\r\n    /// @param _block Block number for which the query is being made for\r\n    /// @return Voting power delegated to the user at the block\r\n    function delegatedToUserAt(\r\n        address userAddress,\r\n        uint256 _block\r\n        )\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return getValueAt(users[userAddress].delegatedTo, _block);\r\n    }\r\n\r\n    /// @notice Called to get the current voting power delegated to a user\r\n    /// @param userAddress User address\r\n    /// @return Current voting power delegated to the user\r\n    function delegatedToUser(address userAddress)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return delegatedToUserAt(userAddress, block.number);\r\n    }\r\n\r\n    /// @notice Called to get the delegate of the user at a specific block\r\n    /// @param userAddress User address\r\n    /// @param _block Block number\r\n    /// @return Delegate of the user at the specific block\r\n    function userDelegateAt(\r\n        address userAddress,\r\n        uint256 _block\r\n        )\r\n        public\r\n        view\r\n        override\r\n        returns (address)\r\n    {\r\n        return getAddressAt(users[userAddress].delegates, _block);\r\n    }\r\n\r\n    /// @notice Called to get the current delegate of the user\r\n    /// @param userAddress User address\r\n    /// @return Current delegate of the user\r\n    function userDelegate(address userAddress)\r\n        public\r\n        view\r\n        override\r\n        returns (address)\r\n    {\r\n        return userDelegateAt(userAddress, block.number);\r\n    }\r\n\r\n    /// @notice Called to get the current locked tokens of the user\r\n    /// @param userAddress User address\r\n    /// @return locked Current locked tokens of the user\r\n    function userLocked(address userAddress)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256 locked)\r\n    {\r\n        Checkpoint[] storage _userShares = users[userAddress].shares;\r\n        uint256 currentEpoch = block.timestamp / EPOCH_LENGTH;\r\n        uint256 oldestLockedEpoch = getOldestLockedEpoch();\r\n        uint256 indUserShares = _userShares.length;\r\n        for (\r\n                uint256 indEpoch = currentEpoch;\r\n                indEpoch >= oldestLockedEpoch;\r\n                indEpoch--\r\n            )\r\n        {\r\n            // The user has never staked at this point, we can exit early\r\n            if (indUserShares == 0)\r\n            {\r\n                break;\r\n            }\r\n            Reward storage lockedReward = epochIndexToReward[indEpoch];\r\n            if (lockedReward.atBlock != 0)\r\n            {\r\n                for (; indUserShares > 0; indUserShares--)\r\n                {\r\n                    Checkpoint storage userShare = _userShares[indUserShares - 1];\r\n                    if (userShare.fromBlock <= lockedReward.atBlock)\r\n                    {\r\n                        locked += lockedReward.amount * userShare.value / lockedReward.totalSharesThen;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Called to get the details of a user\r\n    /// @param userAddress User address\r\n    /// @return unstaked Amount of unstaked API3 tokens\r\n    /// @return vesting Amount of API3 tokens locked by vesting\r\n    /// @return unstakeAmount Amount scheduled to unstake\r\n    /// @return unstakeShares Shares revoked to unstake\r\n    /// @return unstakeScheduledFor Time unstaking is scheduled for\r\n    /// @return lastDelegationUpdateTimestamp Time of last delegation update\r\n    /// @return lastProposalTimestamp Time when the user made their most\r\n    /// recent proposal\r\n    function getUser(address userAddress)\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            uint256 unstaked,\r\n            uint256 vesting,\r\n            uint256 unstakeAmount,\r\n            uint256 unstakeShares,\r\n            uint256 unstakeScheduledFor,\r\n            uint256 lastDelegationUpdateTimestamp,\r\n            uint256 lastProposalTimestamp\r\n            )\r\n    {\r\n        User storage user = users[userAddress];\r\n        unstaked = user.unstaked;\r\n        vesting = user.vesting;\r\n        unstakeAmount = user.unstakeAmount;\r\n        unstakeShares = user.unstakeShares;\r\n        unstakeScheduledFor = user.unstakeScheduledFor;\r\n        lastDelegationUpdateTimestamp = user.lastDelegationUpdateTimestamp;\r\n        lastProposalTimestamp = user.lastProposalTimestamp;\r\n    }\r\n\r\n    /// @notice Called to get the value of a checkpoint array at a specific\r\n    /// block using binary search\r\n    /// @dev Adapted from\r\n    /// https://github.com/aragon/minime/blob/1d5251fc88eee5024ff318d95bc9f4c5de130430/contracts/MiniMeToken.sol#L431\r\n    /// @param checkpoints Checkpoints array\r\n    /// @param _block Block number for which the query is being made\r\n    /// @return Value of the checkpoint array at the block\r\n    function getValueAt(\r\n        Checkpoint[] storage checkpoints,\r\n        uint256 _block\r\n        )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (checkpoints.length == 0)\r\n            return 0;\r\n\r\n        // Shortcut for the actual value\r\n        if (_block >= checkpoints[checkpoints.length -1].fromBlock)\r\n            return checkpoints[checkpoints.length - 1].value;\r\n        if (_block < checkpoints[0].fromBlock)\r\n            return 0;\r\n\r\n        // Limit the search to the last 1024 elements if the value being\r\n        // searched falls within that window\r\n        uint min = 0;\r\n        if (\r\n            checkpoints.length > 1024\r\n                && checkpoints[checkpoints.length - 1024].fromBlock < _block\r\n            )\r\n        {\r\n            min = checkpoints.length - 1024;\r\n        }\r\n\r\n        // Binary search of the value in the array\r\n        uint max = checkpoints.length - 1;\r\n        while (max > min) {\r\n            uint mid = (max + min + 1) / 2;\r\n            if (checkpoints[mid].fromBlock <= _block) {\r\n                min = mid;\r\n            } else {\r\n                max = mid - 1;\r\n            }\r\n        }\r\n        return checkpoints[min].value;\r\n    }\r\n\r\n    /// @notice Called to get the value of an address-checkpoint array at a\r\n    /// specific block using binary search\r\n    /// @dev Adapted from\r\n    /// https://github.com/aragon/minime/blob/1d5251fc88eee5024ff318d95bc9f4c5de130430/contracts/MiniMeToken.sol#L431\r\n    /// @param checkpoints Address-checkpoint array\r\n    /// @param _block Block number for which the query is being made\r\n    /// @return Value of the address-checkpoint array at the block\r\n    function getAddressAt(\r\n        AddressCheckpoint[] storage checkpoints,\r\n        uint256 _block\r\n        )\r\n        private\r\n        view\r\n        returns (address)\r\n    {\r\n        if (checkpoints.length == 0)\r\n            return address(0);\r\n\r\n        // Shortcut for the actual value\r\n        if (_block >= checkpoints[checkpoints.length -1].fromBlock)\r\n            return checkpoints[checkpoints.length - 1]._address;\r\n        if (_block < checkpoints[0].fromBlock)\r\n            return address(0);\r\n\r\n        // Limit the search to the last 1024 elements if the value being\r\n        // searched falls within that window\r\n        uint min = 0;\r\n        if (\r\n            checkpoints.length > 1024\r\n                && checkpoints[checkpoints.length - 1024].fromBlock < _block\r\n            )\r\n        {\r\n            min = checkpoints.length - 1024;\r\n        }\r\n\r\n        // Binary search of the value in the array\r\n        uint max = checkpoints.length - 1;\r\n        while (max > min) {\r\n            uint mid = (max + min + 1) / 2;\r\n            if (checkpoints[mid].fromBlock <= _block) {\r\n                min = mid;\r\n            } else {\r\n                max = mid - 1;\r\n            }\r\n        }\r\n        return checkpoints[min]._address;\r\n    }\r\n\r\n    /// @notice Called internally to get the index of the oldest epoch whose\r\n    /// reward should be locked in the current epoch\r\n    /// @return oldestLockedEpoch Index of the oldest epoch with locked rewards\r\n    function getOldestLockedEpoch()\r\n        internal\r\n        view\r\n        returns (uint256 oldestLockedEpoch)\r\n    {\r\n        uint256 currentEpoch = block.timestamp / EPOCH_LENGTH;\r\n        oldestLockedEpoch = currentEpoch - REWARD_VESTING_PERIOD + 1;\r\n        if (oldestLockedEpoch < genesisEpoch + 1)\r\n        {\r\n            oldestLockedEpoch = genesisEpoch + 1;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/interfaces/IRewardUtils.sol\r\n\r\npragma solidity 0.8.4;\r\n\r\ninterface IRewardUtils is IGetterUtils {\r\n    event MintedReward(\r\n        uint256 indexed epochIndex,\r\n        uint256 amount,\r\n        uint256 newApr,\r\n        uint256 totalStake\r\n        );\r\n\r\n    function mintReward()\r\n        external;\r\n}\r\n\r\n\r\n// File contracts/RewardUtils.sol\r\n\r\npragma solidity 0.8.4;\r\n\r\n\r\n/// @title Contract that implements reward payments\r\nabstract contract RewardUtils is GetterUtils, IRewardUtils {\r\n    /// @notice Called to mint the staking reward\r\n    /// @dev Skips past epochs for which rewards have not been paid for.\r\n    /// Skips the reward payment if the pool is not authorized to mint tokens.\r\n    /// Neither of these conditions will occur in practice.\r\n    function mintReward()\r\n        public\r\n        override\r\n    {\r\n        uint256 currentEpoch = block.timestamp / EPOCH_LENGTH;\r\n        // This will be skipped in most cases because someone else will have\r\n        // triggered the payment for this epoch\r\n        if (epochIndexOfLastReward < currentEpoch)\r\n        {\r\n            if (api3Token.getMinterStatus(address(this)))\r\n            {\r\n                uint256 rewardAmount = totalStake * apr * EPOCH_LENGTH / 365 days / HUNDRED_PERCENT;\r\n                assert(block.number <= MAX_UINT32);\r\n                assert(rewardAmount <= MAX_UINT224);\r\n                epochIndexToReward[currentEpoch] = Reward({\r\n                    atBlock: uint32(block.number),\r\n                    amount: uint224(rewardAmount),\r\n                    totalSharesThen: totalShares(),\r\n                    totalStakeThen: totalStake\r\n                    });\r\n                api3Token.mint(address(this), rewardAmount);\r\n                totalStake += rewardAmount;\r\n                updateCurrentApr();\r\n                emit MintedReward(\r\n                    currentEpoch,\r\n                    rewardAmount,\r\n                    apr,\r\n                    totalStake\r\n                    );\r\n            }\r\n            epochIndexOfLastReward = currentEpoch;\r\n        }\r\n    }\r\n\r\n    /// @notice Updates the current APR\r\n    /// @dev Called internally after paying out the reward\r\n    function updateCurrentApr()\r\n        internal\r\n    {\r\n        uint256 totalStakePercentage = totalStake\r\n            * HUNDRED_PERCENT\r\n            / api3Token.totalSupply();\r\n        if (totalStakePercentage > stakeTarget)\r\n        {\r\n            apr = apr > aprUpdateStep ? apr - aprUpdateStep : 0;\r\n        }\r\n        else\r\n        {\r\n            apr += aprUpdateStep;\r\n        }\r\n        if (apr > maxApr) {\r\n            apr = maxApr;\r\n        }\r\n        else if (apr < minApr) {\r\n            apr = minApr;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/interfaces/IDelegationUtils.sol\r\n\r\npragma solidity 0.8.4;\r\n\r\ninterface IDelegationUtils is IRewardUtils {\r\n    event Delegated(\r\n        address indexed user,\r\n        address indexed delegate,\r\n        uint256 shares,\r\n        uint256 totalDelegatedTo\r\n        );\r\n\r\n    event Undelegated(\r\n        address indexed user,\r\n        address indexed delegate,\r\n        uint256 shares,\r\n        uint256 totalDelegatedTo\r\n        );\r\n\r\n    event UpdatedDelegation(\r\n        address indexed user,\r\n        address indexed delegate,\r\n        bool delta,\r\n        uint256 shares,\r\n        uint256 totalDelegatedTo\r\n        );\r\n\r\n    function delegateVotingPower(address delegate) \r\n        external;\r\n\r\n    function undelegateVotingPower()\r\n        external;\r\n\r\n    \r\n}\r\n\r\n\r\n// File contracts/DelegationUtils.sol\r\n\r\npragma solidity 0.8.4;\r\n\r\n\r\n/// @title Contract that implements voting power delegation\r\nabstract contract DelegationUtils is RewardUtils, IDelegationUtils {\r\n    /// @notice Called by the user to delegate voting power\r\n    /// @param delegate User address the voting power will be delegated to\r\n    function delegateVotingPower(address delegate) \r\n        external\r\n        override\r\n    {\r\n        mintReward();\r\n        require(\r\n            delegate != address(0) && delegate != msg.sender,\r\n            \"Pool: Invalid delegate\"\r\n            );\r\n        // Delegating users cannot use their voting power, so we are\r\n        // verifying that the delegate is not currently delegating. However,\r\n        // the delegate may delegate after they have been delegated to.\r\n        require(\r\n            userDelegate(delegate) == address(0),\r\n            \"Pool: Delegate is delegating\"\r\n            );\r\n        User storage user = users[msg.sender];\r\n        // Do not allow frequent delegation updates as that can be used to spam\r\n        // proposals\r\n        require(\r\n            user.lastDelegationUpdateTimestamp + EPOCH_LENGTH < block.timestamp,\r\n            \"Pool: Updated delegate recently\"\r\n            );\r\n        user.lastDelegationUpdateTimestamp = block.timestamp;\r\n\r\n        uint256 userShares = userShares(msg.sender);\r\n        require(\r\n            userShares != 0,\r\n            \"Pool: Have no shares to delegate\"\r\n            );\r\n\r\n        address previousDelegate = userDelegate(msg.sender);\r\n        require(\r\n            previousDelegate != delegate,\r\n            \"Pool: Already delegated\"\r\n            );\r\n        if (previousDelegate != address(0)) {\r\n            // Need to revoke previous delegation\r\n            updateCheckpointArray(\r\n                users[previousDelegate].delegatedTo,\r\n                delegatedToUser(previousDelegate) - userShares\r\n                );\r\n        }\r\n\r\n        // Assign the new delegation\r\n        uint256 delegatedToUpdate = delegatedToUser(delegate) + userShares;\r\n        updateCheckpointArray(\r\n            users[delegate].delegatedTo,\r\n            delegatedToUpdate\r\n            );\r\n\r\n        // Record the new delegate for the user\r\n        updateAddressCheckpointArray(\r\n            user.delegates,\r\n            delegate\r\n            );\r\n        emit Delegated(\r\n            msg.sender,\r\n            delegate,\r\n            userShares,\r\n            delegatedToUpdate\r\n            );\r\n    }\r\n\r\n    /// @notice Called by the user to undelegate voting power\r\n    function undelegateVotingPower()\r\n        external\r\n        override\r\n    {\r\n        mintReward();\r\n        User storage user = users[msg.sender];\r\n        address previousDelegate = userDelegate(msg.sender);\r\n        require(\r\n            previousDelegate != address(0),\r\n            \"Pool: Not delegated\"\r\n            );\r\n        require(\r\n            user.lastDelegationUpdateTimestamp + EPOCH_LENGTH < block.timestamp,\r\n            \"Pool: Updated delegate recently\"\r\n            );\r\n        user.lastDelegationUpdateTimestamp = block.timestamp;\r\n\r\n        uint256 userShares = userShares(msg.sender);\r\n        uint256 delegatedToUpdate = delegatedToUser(previousDelegate) - userShares;\r\n        updateCheckpointArray(\r\n            users[previousDelegate].delegatedTo,\r\n            delegatedToUpdate\r\n            );\r\n        updateAddressCheckpointArray(\r\n            user.delegates,\r\n            address(0)\r\n            );\r\n        emit Undelegated(\r\n            msg.sender,\r\n            previousDelegate,\r\n            userShares,\r\n            delegatedToUpdate\r\n            );\r\n    }\r\n\r\n    /// @notice Called internally when the user shares are updated to update\r\n    /// the delegated voting power\r\n    /// @dev User shares only get updated while staking or scheduling unstaking\r\n    /// @param shares Amount of shares that will be added/removed\r\n    /// @param delta Whether the shares will be added/removed (add for `true`,\r\n    /// and vice versa)\r\n    function updateDelegatedVotingPower(\r\n        uint256 shares,\r\n        bool delta\r\n        )\r\n        internal\r\n    {\r\n        address delegate = userDelegate(msg.sender);\r\n        if (delegate == address(0))\r\n        {\r\n            return;\r\n        }\r\n        uint256 currentDelegatedTo = delegatedToUser(delegate);\r\n        uint256 delegatedToUpdate = delta\r\n            ? currentDelegatedTo + shares\r\n            : currentDelegatedTo - shares;\r\n        updateCheckpointArray(\r\n            users[delegate].delegatedTo,\r\n            delegatedToUpdate\r\n            );\r\n        emit UpdatedDelegation(\r\n            msg.sender,\r\n            delegate,\r\n            delta,\r\n            shares,\r\n            delegatedToUpdate\r\n            );\r\n    }\r\n}\r\n\r\n\r\n// File contracts/interfaces/ITransferUtils.sol\r\n\r\npragma solidity 0.8.4;\r\n\r\ninterface ITransferUtils is IDelegationUtils{\r\n    event Deposited(\r\n        address indexed user,\r\n        uint256 amount,\r\n        uint256 userUnstaked\r\n        );\r\n\r\n    event Withdrawn(\r\n        address indexed user,\r\n        uint256 amount,\r\n        uint256 userUnstaked\r\n        );\r\n\r\n    event CalculatingUserLocked(\r\n        address indexed user,\r\n        uint256 nextIndEpoch,\r\n        uint256 oldestLockedEpoch\r\n        );\r\n\r\n    event CalculatedUserLocked(\r\n        address indexed user,\r\n        uint256 amount\r\n        );\r\n\r\n    function depositRegular(uint256 amount)\r\n        external;\r\n\r\n    function withdrawRegular(uint256 amount)\r\n        external;\r\n\r\n    function precalculateUserLocked(\r\n        address userAddress,\r\n        uint256 noEpochsPerIteration\r\n        )\r\n        external\r\n        returns (bool finished);\r\n\r\n    function withdrawPrecalculated(uint256 amount)\r\n        external;\r\n}\r\n\r\n\r\n// File contracts/TransferUtils.sol\r\n\r\npragma solidity 0.8.4;\r\n\r\n\r\n/// @title Contract that implements token transfer functionality\r\nabstract contract TransferUtils is DelegationUtils, ITransferUtils {\r\n    /// @notice Called by the user to deposit tokens\r\n    /// @dev The user should approve the pool to spend at least `amount` tokens\r\n    /// before calling this.\r\n    /// The method is named `depositRegular()` to prevent potential confusion.\r\n    /// See `deposit()` for more context.\r\n    /// @param amount Amount to be deposited\r\n    function depositRegular(uint256 amount)\r\n        public\r\n        override\r\n    {\r\n        mintReward();\r\n        uint256 unstakedUpdate = users[msg.sender].unstaked + amount;\r\n        users[msg.sender].unstaked = unstakedUpdate;\r\n        // Should never return false because the API3 token uses the\r\n        // OpenZeppelin implementation\r\n        assert(api3Token.transferFrom(msg.sender, address(this), amount));\r\n        emit Deposited(\r\n            msg.sender,\r\n            amount,\r\n            unstakedUpdate\r\n            );\r\n    }\r\n\r\n    /// @notice Called by the user to withdraw tokens to their wallet\r\n    /// @dev The user should call `userLocked()` beforehand to ensure that\r\n    /// they have at least `amount` unlocked tokens to withdraw.\r\n    /// The method is named `withdrawRegular()` to be consistent with the name\r\n    /// `depositRegular()`. See `depositRegular()` for more context.\r\n    /// @param amount Amount to be withdrawn\r\n    function withdrawRegular(uint256 amount)\r\n        public\r\n        override\r\n    {\r\n        mintReward();\r\n        withdraw(amount, userLocked(msg.sender));\r\n    }\r\n\r\n    /// @notice Called to calculate the locked tokens of a user by making\r\n    /// multiple transactions\r\n    /// @dev If the user updates their `user.shares` by staking/unstaking too\r\n    /// frequently (50+/week) in the last `REWARD_VESTING_PERIOD`, the\r\n    /// `userLocked()` call gas cost may exceed the block gas limit. In that\r\n    /// case, the user may call this method multiple times to have their locked\r\n    /// tokens calculated and use `withdrawPrecalculated()` to withdraw.\r\n    /// @param userAddress User address\r\n    /// @param noEpochsPerIteration Number of epochs per iteration\r\n    /// @return finished Calculation has finished in this call\r\n    function precalculateUserLocked(\r\n        address userAddress,\r\n        uint256 noEpochsPerIteration\r\n        )\r\n        external\r\n        override\r\n        returns (bool finished)\r\n    {\r\n        mintReward();\r\n        require(\r\n            noEpochsPerIteration > 0,\r\n            \"Pool: Zero iteration window\"\r\n            );\r\n        uint256 currentEpoch = block.timestamp / EPOCH_LENGTH;\r\n        LockedCalculation storage lockedCalculation = userToLockedCalculation[userAddress];\r\n        // Reset the state if there was no calculation made in this epoch\r\n        if (lockedCalculation.initialIndEpoch != currentEpoch)\r\n        {\r\n            lockedCalculation.initialIndEpoch = currentEpoch;\r\n            lockedCalculation.nextIndEpoch = currentEpoch;\r\n            lockedCalculation.locked = 0;\r\n        }\r\n        uint256 indEpoch = lockedCalculation.nextIndEpoch;\r\n        uint256 locked = lockedCalculation.locked;\r\n        uint256 oldestLockedEpoch = getOldestLockedEpoch();\r\n        for (; indEpoch >= oldestLockedEpoch; indEpoch--)\r\n        {\r\n            if (lockedCalculation.nextIndEpoch >= indEpoch + noEpochsPerIteration)\r\n            {\r\n                lockedCalculation.nextIndEpoch = indEpoch;\r\n                lockedCalculation.locked = locked;\r\n                emit CalculatingUserLocked(\r\n                    userAddress,\r\n                    indEpoch,\r\n                    oldestLockedEpoch\r\n                    );\r\n                return false;\r\n            }\r\n            Reward storage lockedReward = epochIndexToReward[indEpoch];\r\n            if (lockedReward.atBlock != 0)\r\n            {\r\n                uint256 userSharesThen = userSharesAt(userAddress, lockedReward.atBlock);\r\n                locked += lockedReward.amount * userSharesThen / lockedReward.totalSharesThen;\r\n            }\r\n        }\r\n        lockedCalculation.nextIndEpoch = indEpoch;\r\n        lockedCalculation.locked = locked;\r\n        emit CalculatedUserLocked(userAddress, locked);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Called by the user to withdraw after their locked token amount\r\n    /// is calculated with repeated calls to `precalculateUserLocked()`\r\n    /// @dev Only use `precalculateUserLocked()` and this method if\r\n    /// `withdrawRegular()` hits the block gas limit\r\n    /// @param amount Amount to be withdrawn\r\n    function withdrawPrecalculated(uint256 amount)\r\n        external\r\n        override\r\n    {\r\n        mintReward();\r\n        uint256 currentEpoch = block.timestamp / EPOCH_LENGTH;\r\n        LockedCalculation storage lockedCalculation = userToLockedCalculation[msg.sender];\r\n        require(\r\n            lockedCalculation.initialIndEpoch == currentEpoch,\r\n            \"Pool: Calculation not up to date\"\r\n            );\r\n        require(\r\n            lockedCalculation.nextIndEpoch < getOldestLockedEpoch(),\r\n            \"Pool: Calculation not complete\"\r\n            );\r\n        withdraw(amount, lockedCalculation.locked);\r\n    }\r\n\r\n    /// @notice Called internally after the amount of locked tokens of the user\r\n    /// is determined\r\n    /// @param amount Amount to be withdrawn\r\n    /// @param userLocked Amount of locked tokens of the user\r\n    function withdraw(\r\n        uint256 amount,\r\n        uint256 userLocked\r\n        )\r\n        private\r\n    {\r\n        User storage user = users[msg.sender];\r\n        // Check if the user has `amount` unlocked tokens to withdraw\r\n        uint256 lockedAndVesting = userLocked + user.vesting;\r\n        uint256 userTotalFunds = user.unstaked + userStake(msg.sender);\r\n        require(\r\n            userTotalFunds >= lockedAndVesting + amount,\r\n            \"Pool: Not enough unlocked funds\"\r\n            );\r\n        require(\r\n            user.unstaked >= amount,\r\n            \"Pool: Not enough unstaked funds\"\r\n            );\r\n        // Carry on with the withdrawal\r\n        uint256 unstakedUpdate = user.unstaked - amount;\r\n        user.unstaked = unstakedUpdate;\r\n        // Should never return false because the API3 token uses the\r\n        // OpenZeppelin implementation\r\n        assert(api3Token.transfer(msg.sender, amount));\r\n        emit Withdrawn(\r\n            msg.sender,\r\n            amount,\r\n            unstakedUpdate\r\n            );\r\n    }\r\n}\r\n\r\n\r\n// File contracts/interfaces/IStakeUtils.sol\r\n\r\npragma solidity 0.8.4;\r\n\r\ninterface IStakeUtils is ITransferUtils{\r\n    event Staked(\r\n        address indexed user,\r\n        uint256 amount,\r\n        uint256 mintedShares,\r\n        uint256 userUnstaked,\r\n        uint256 userShares,\r\n        uint256 totalShares,\r\n        uint256 totalStake\r\n        );\r\n\r\n    event ScheduledUnstake(\r\n        address indexed user,\r\n        uint256 amount,\r\n        uint256 shares,\r\n        uint256 scheduledFor,\r\n        uint256 userShares\r\n        );\r\n\r\n    event Unstaked(\r\n        address indexed user,\r\n        uint256 amount,\r\n        uint256 userUnstaked,\r\n        uint256 totalShares,\r\n        uint256 totalStake\r\n        );\r\n\r\n    function stake(uint256 amount)\r\n        external;\r\n\r\n    function depositAndStake(uint256 amount)\r\n        external;\r\n\r\n    function scheduleUnstake(uint256 amount)\r\n        external;\r\n\r\n    function unstake(address userAddress)\r\n        external\r\n        returns (uint256);\r\n\r\n    function unstakeAndWithdraw()\r\n        external;\r\n}\r\n\r\n\r\n// File contracts/StakeUtils.sol\r\n\r\npragma solidity 0.8.4;\r\n\r\n\r\n/// @title Contract that implements staking functionality\r\nabstract contract StakeUtils is TransferUtils, IStakeUtils {\r\n    /// @notice Called to stake tokens to receive pools in the share\r\n    /// @param amount Amount of tokens to stake\r\n    function stake(uint256 amount)\r\n        public\r\n        override\r\n    {\r\n        mintReward();\r\n        User storage user = users[msg.sender];\r\n        require(\r\n            user.unstaked >= amount,\r\n            \"Pool: Amount exceeds unstaked\"\r\n            );\r\n        uint256 userUnstakedUpdate = user.unstaked - amount;\r\n        user.unstaked = userUnstakedUpdate;\r\n        uint256 totalSharesNow = totalShares();\r\n        uint256 sharesToMint = amount * totalSharesNow / totalStake;\r\n        uint256 userSharesUpdate = userShares(msg.sender) + sharesToMint;\r\n        updateCheckpointArray(\r\n            user.shares,\r\n            userSharesUpdate\r\n            );\r\n        uint256 totalSharesUpdate = totalSharesNow + sharesToMint;\r\n        updateCheckpointArray(\r\n            poolShares,\r\n            totalSharesUpdate\r\n            );\r\n        totalStake += amount;\r\n        updateDelegatedVotingPower(sharesToMint, true);\r\n        emit Staked(\r\n            msg.sender,\r\n            amount,\r\n            sharesToMint,\r\n            userUnstakedUpdate,\r\n            userSharesUpdate,\r\n            totalSharesUpdate,\r\n            totalStake\r\n            );\r\n    }\r\n\r\n    /// @notice Convenience method to deposit and stake in a single transaction\r\n    /// @param amount Amount to be deposited and staked\r\n    function depositAndStake(uint256 amount)\r\n        external\r\n        override\r\n    {\r\n        depositRegular(amount);\r\n        stake(amount);\r\n    }\r\n\r\n    /// @notice Called by the user to schedule unstaking of their tokens\r\n    /// @dev While scheduling an unstake, `shares` get deducted from the user,\r\n    /// meaning that they will not receive rewards or voting power for them any\r\n    /// longer.\r\n    /// At unstaking-time, the user unstakes either the amount of tokens\r\n    /// scheduled to unstake, or the amount of tokens `shares` corresponds to\r\n    /// at unstaking-time, whichever is smaller. This corresponds to tokens\r\n    /// being scheduled to be unstaked not receiving any rewards, but being\r\n    /// subject to claim payouts.\r\n    /// In the instance that a claim has been paid out before an unstaking is\r\n    /// executed, the user may potentially receive rewards during\r\n    /// `unstakeWaitPeriod` (but not if there has not been a claim payout) but\r\n    /// the amount of tokens that they can unstake will not be able to exceed\r\n    /// the amount they scheduled the unstaking for.\r\n    /// @param amount Amount of tokens scheduled to unstake\r\n    function scheduleUnstake(uint256 amount)\r\n        external\r\n        override\r\n    {\r\n        mintReward();\r\n        uint256 userSharesNow = userShares(msg.sender);\r\n        uint256 totalSharesNow = totalShares();\r\n        uint256 userStaked = userSharesNow * totalStake / totalSharesNow;\r\n        require(\r\n            userStaked >= amount,\r\n            \"Pool: Amount exceeds staked\"\r\n            );\r\n\r\n        User storage user = users[msg.sender];\r\n        require(\r\n            user.unstakeScheduledFor == 0,\r\n            \"Pool: Unexecuted unstake exists\"\r\n            );\r\n\r\n        uint256 sharesToUnstake = amount * totalSharesNow / totalStake;\r\n        // This will only happen if the user wants to schedule an unstake for a\r\n        // few Wei\r\n        require(sharesToUnstake > 0, \"Pool: Unstake amount too small\");\r\n        uint256 unstakeScheduledFor = block.timestamp + unstakeWaitPeriod;\r\n        user.unstakeScheduledFor = unstakeScheduledFor;\r\n        user.unstakeAmount = amount;\r\n        user.unstakeShares = sharesToUnstake;\r\n        uint256 userSharesUpdate = userSharesNow - sharesToUnstake;\r\n        updateCheckpointArray(\r\n            user.shares,\r\n            userSharesUpdate\r\n            );\r\n        updateDelegatedVotingPower(sharesToUnstake, false);\r\n        emit ScheduledUnstake(\r\n            msg.sender,\r\n            amount,\r\n            sharesToUnstake,\r\n            unstakeScheduledFor,\r\n            userSharesUpdate\r\n            );\r\n    }\r\n\r\n    /// @notice Called to execute a pre-scheduled unstake\r\n    /// @dev Anyone can execute a matured unstake. This is to allow the user to\r\n    /// use bots, etc. to execute their unstaking as soon as possible.\r\n    /// @param userAddress User address\r\n    /// @return Amount of tokens that are unstaked\r\n    function unstake(address userAddress)\r\n        public\r\n        override\r\n        returns (uint256)\r\n    {\r\n        mintReward();\r\n        User storage user = users[userAddress];\r\n        require(\r\n            user.unstakeScheduledFor != 0,\r\n            \"Pool: No unstake scheduled\"\r\n            );\r\n        require(\r\n            user.unstakeScheduledFor < block.timestamp,\r\n            \"Pool: Unstake not mature yet\"\r\n            );\r\n        uint256 totalShares = totalShares();\r\n        uint256 unstakeAmount = user.unstakeAmount;\r\n        uint256 unstakeAmountByShares = user.unstakeShares * totalStake / totalShares;\r\n        // If there was a claim payout in between the scheduling and the actual\r\n        // unstake then the amount might be lower than expected at scheduling\r\n        // time\r\n        if (unstakeAmount > unstakeAmountByShares)\r\n        {\r\n            unstakeAmount = unstakeAmountByShares;\r\n        }\r\n        uint256 userUnstakedUpdate = user.unstaked + unstakeAmount;\r\n        user.unstaked = userUnstakedUpdate;\r\n\r\n        uint256 totalSharesUpdate = totalShares - user.unstakeShares;\r\n        updateCheckpointArray(\r\n            poolShares,\r\n            totalSharesUpdate\r\n            );\r\n        totalStake -= unstakeAmount;\r\n\r\n        user.unstakeAmount = 0;\r\n        user.unstakeShares = 0;\r\n        user.unstakeScheduledFor = 0;\r\n        emit Unstaked(\r\n            userAddress,\r\n            unstakeAmount,\r\n            userUnstakedUpdate,\r\n            totalSharesUpdate,\r\n            totalStake\r\n            );\r\n        return unstakeAmount;\r\n    }\r\n\r\n    /// @notice Convenience method to execute an unstake and withdraw to the\r\n    /// user's wallet in a single transaction\r\n    /// @dev The withdrawal will revert if the user has less than\r\n    /// `unstakeAmount` tokens that are withdrawable\r\n    function unstakeAndWithdraw()\r\n        external\r\n        override\r\n    {\r\n        withdrawRegular(unstake(msg.sender));\r\n    }\r\n}\r\n\r\n\r\n// File contracts/interfaces/IClaimUtils.sol\r\n\r\npragma solidity 0.8.4;\r\n\r\ninterface IClaimUtils is IStakeUtils {\r\n    event PaidOutClaim(\r\n        address indexed recipient,\r\n        uint256 amount,\r\n        uint256 totalStake\r\n        );\r\n\r\n    function payOutClaim(\r\n        address recipient,\r\n        uint256 amount\r\n        )\r\n        external;\r\n}\r\n\r\n\r\n// File contracts/ClaimUtils.sol\r\n\r\npragma solidity 0.8.4;\r\n\r\n\r\n/// @title Contract that implements the insurance claim payout functionality\r\nabstract contract ClaimUtils is StakeUtils, IClaimUtils {\r\n    /// @dev Reverts if the caller is not a claims manager\r\n    modifier onlyClaimsManager() {\r\n        require(\r\n            claimsManagerStatus[msg.sender],\r\n            \"Pool: Caller not claims manager\"\r\n            );\r\n        _;\r\n    }\r\n\r\n    /// @notice Called by a claims manager to pay out an insurance claim\r\n    /// @dev The claims manager is a trusted contract that is allowed to\r\n    /// withdraw as many tokens as it wants from the pool to pay out insurance\r\n    /// claims. Any kind of limiting logic (e.g., maximum amount of tokens that\r\n    /// can be withdrawn) is implemented at its end and is out of the scope of\r\n    /// this contract.\r\n    /// This will revert if the pool does not have enough staked funds.\r\n    /// @param recipient Recipient of the claim\r\n    /// @param amount Amount of tokens that will be paid out\r\n    function payOutClaim(\r\n        address recipient,\r\n        uint256 amount\r\n        )\r\n        external\r\n        override\r\n        onlyClaimsManager()\r\n    {\r\n        mintReward();\r\n        // totalStake should not go lower than 1\r\n        require(\r\n            totalStake > amount,\r\n            \"Pool: Amount exceeds total stake\"\r\n            );\r\n        totalStake -= amount;\r\n        // Should never return false because the API3 token uses the\r\n        // OpenZeppelin implementation\r\n        assert(api3Token.transfer(recipient, amount));\r\n        emit PaidOutClaim(\r\n            recipient,\r\n            amount,\r\n            totalStake\r\n            );\r\n    }\r\n}\r\n\r\n\r\n// File contracts/interfaces/ITimelockUtils.sol\r\n\r\npragma solidity 0.8.4;\r\n\r\ninterface ITimelockUtils is IClaimUtils {\r\n    event DepositedByTimelockManager(\r\n        address indexed user,\r\n        uint256 amount,\r\n        uint256 userUnstaked\r\n        );\r\n\r\n    event DepositedVesting(\r\n        address indexed user,\r\n        uint256 amount,\r\n        uint256 start,\r\n        uint256 end,\r\n        uint256 userUnstaked,\r\n        uint256 userVesting\r\n        );\r\n\r\n    event VestedTimelock(\r\n        address indexed user,\r\n        uint256 amount,\r\n        uint256 userVesting\r\n        );\r\n\r\n    function deposit(\r\n        address source,\r\n        uint256 amount,\r\n        address userAddress\r\n        )\r\n        external;\r\n\r\n    function depositWithVesting(\r\n        address source,\r\n        uint256 amount,\r\n        address userAddress,\r\n        uint256 releaseStart,\r\n        uint256 releaseEnd\r\n        )\r\n        external;\r\n\r\n    function updateTimelockStatus(address userAddress)\r\n        external;\r\n}\r\n\r\n\r\n// File contracts/TimelockUtils.sol\r\n\r\npragma solidity 0.8.4;\r\n\r\n\r\n/// @title Contract that implements vesting functionality\r\n/// @dev The TimelockManager contract interfaces with this contract to transfer\r\n/// API3 tokens that are locked under a vesting schedule.\r\n/// This contract keeps its own type definitions, event declarations and state\r\n/// variables for them to be easier to remove for a subDAO where they will\r\n/// likely not be used.\r\nabstract contract TimelockUtils is ClaimUtils, ITimelockUtils {\r\n    struct Timelock {\r\n        uint256 totalAmount;\r\n        uint256 remainingAmount;\r\n        uint256 releaseStart;\r\n        uint256 releaseEnd;\r\n    }\r\n\r\n    /// @notice Maps user addresses to timelocks\r\n    /// @dev This implies that a user cannot have multiple timelocks\r\n    /// transferred from the TimelockManager contract. This is acceptable\r\n    /// because TimelockManager is implemented in a way to not allow multiple\r\n    /// timelocks per user.\r\n    mapping(address => Timelock) public userToTimelock;\r\n\r\n    /// @notice Called by the TimelockManager contract to deposit tokens on\r\n    /// behalf of a user\r\n    /// @dev This method is only usable by `TimelockManager.sol`.\r\n    /// It is named as `deposit()` and not `depositAsTimelockManager()` for\r\n    /// example, because the TimelockManager is already deployed and expects\r\n    /// the `deposit(address,uint256,address)` interface.\r\n    /// @param source Token transfer source\r\n    /// @param amount Amount to be deposited\r\n    /// @param userAddress User that the tokens will be deposited for\r\n    function deposit(\r\n        address source,\r\n        uint256 amount,\r\n        address userAddress\r\n        )\r\n        external\r\n        override\r\n    {\r\n        require(\r\n            msg.sender == timelockManager,\r\n            \"Pool: Caller not TimelockManager\"\r\n            );\r\n        uint256 unstakedUpdate = users[userAddress].unstaked + amount;\r\n        users[userAddress].unstaked = unstakedUpdate;\r\n        // Should never return false because the API3 token uses the\r\n        // OpenZeppelin implementation\r\n        assert(api3Token.transferFrom(source, address(this), amount));\r\n        emit DepositedByTimelockManager(\r\n            userAddress,\r\n            amount,\r\n            unstakedUpdate\r\n            );\r\n    }\r\n\r\n    /// @notice Called by the TimelockManager contract to deposit tokens on\r\n    /// behalf of a user on a linear vesting schedule\r\n    /// @dev Refer to `TimelockManager.sol` to see how this is used\r\n    /// @param source Token source\r\n    /// @param amount Token amount\r\n    /// @param userAddress Address of the user who will receive the tokens\r\n    /// @param releaseStart Vesting schedule starting time\r\n    /// @param releaseEnd Vesting schedule ending time\r\n    function depositWithVesting(\r\n        address source,\r\n        uint256 amount,\r\n        address userAddress,\r\n        uint256 releaseStart,\r\n        uint256 releaseEnd\r\n        )\r\n        external\r\n        override\r\n    {\r\n        require(\r\n            msg.sender == timelockManager,\r\n            \"Pool: Caller not TimelockManager\"\r\n            );\r\n        require(\r\n            userToTimelock[userAddress].remainingAmount == 0,\r\n            \"Pool: User has active timelock\"\r\n            );\r\n        require(\r\n            releaseEnd > releaseStart,\r\n            \"Pool: Timelock start after end\"\r\n            );\r\n        require(\r\n            amount != 0,\r\n            \"Pool: Timelock amount zero\"\r\n            );\r\n        uint256 unstakedUpdate = users[userAddress].unstaked + amount;\r\n        users[userAddress].unstaked = unstakedUpdate;\r\n        uint256 vestingUpdate = users[userAddress].vesting + amount;\r\n        users[userAddress].vesting = vestingUpdate;\r\n        userToTimelock[userAddress] = Timelock({\r\n            totalAmount: amount,\r\n            remainingAmount: amount,\r\n            releaseStart: releaseStart,\r\n            releaseEnd: releaseEnd\r\n            });\r\n        // Should never return false because the API3 token uses the\r\n        // OpenZeppelin implementation\r\n        assert(api3Token.transferFrom(source, address(this), amount));\r\n        emit DepositedVesting(\r\n            userAddress,\r\n            amount,\r\n            releaseStart,\r\n            releaseEnd,\r\n            unstakedUpdate,\r\n            vestingUpdate\r\n            );\r\n    }\r\n\r\n    /// @notice Called to release tokens vested by the timelock\r\n    /// @param userAddress Address of the user whose timelock status will be\r\n    /// updated\r\n    function updateTimelockStatus(address userAddress)\r\n        external\r\n        override\r\n    {\r\n        Timelock storage timelock = userToTimelock[userAddress];\r\n        require(\r\n            block.timestamp > timelock.releaseStart,\r\n            \"Pool: Release not started yet\"\r\n            );\r\n        require(\r\n            timelock.remainingAmount > 0,\r\n            \"Pool: Timelock already released\"\r\n            );\r\n        uint256 totalUnlocked;\r\n        if (block.timestamp >= timelock.releaseEnd)\r\n        {\r\n            totalUnlocked = timelock.totalAmount;\r\n        }\r\n        else\r\n        {\r\n            uint256 passedTime = block.timestamp - timelock.releaseStart;\r\n            uint256 totalTime = timelock.releaseEnd - timelock.releaseStart;\r\n            totalUnlocked = timelock.totalAmount * passedTime / totalTime;\r\n        }\r\n        uint256 previouslyUnlocked = timelock.totalAmount - timelock.remainingAmount;\r\n        uint256 newlyUnlocked = totalUnlocked - previouslyUnlocked;\r\n        User storage user = users[userAddress];\r\n        uint256 vestingUpdate = user.vesting - newlyUnlocked;\r\n        user.vesting = vestingUpdate;\r\n        timelock.remainingAmount -= newlyUnlocked;\r\n        emit VestedTimelock(\r\n            userAddress,\r\n            newlyUnlocked,\r\n            vestingUpdate\r\n            );\r\n    }\r\n}\r\n\r\n\r\n// File contracts/interfaces/IApi3Pool.sol\r\n\r\npragma solidity 0.8.4;\r\n\r\ninterface IApi3Pool is ITimelockUtils {\r\n}\r\n\r\n\r\n// File contracts/Api3Pool.sol\r\n\r\npragma solidity 0.8.4;\r\n\r\n\r\n/// @title API3 pool contract\r\n/// @notice Users can stake API3 tokens at the pool contract to be granted\r\n/// shares. These shares are exposed to the Aragon-based DAO, giving the user\r\n/// voting power at the DAO. Staking pays out weekly rewards that get unlocked\r\n/// after a year, and staked funds are used to collateralize an insurance\r\n/// product that is outside the scope of this contract.\r\n/// @dev Functionalities of the contract are distributed to files that form a\r\n/// chain of inheritance:\r\n/// (1) Api3Pool.sol\r\n/// (2) TimelockUtils.sol\r\n/// (3) ClaimUtils.sol\r\n/// (4) StakeUtils.sol\r\n/// (5) TransferUtils.sol\r\n/// (6) DelegationUtils.sol\r\n/// (7) RewardUtils.sol\r\n/// (8) GetterUtils.sol\r\n/// (9) StateUtils.sol\r\ncontract Api3Pool is TimelockUtils, IApi3Pool {\r\n    /// @param api3TokenAddress API3 token contract address\r\n    /// @param timelockManagerAddress Timelock manager contract address\r\n    constructor(\r\n        address api3TokenAddress,\r\n        address timelockManagerAddress\r\n        )\r\n        StateUtils(\r\n            api3TokenAddress,\r\n            timelockManagerAddress\r\n            )\r\n    {}\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"api3TokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"timelockManagerAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CalculatedUserLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nextIndEpoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldestLockedEpoch\",\"type\":\"uint256\"}],\"name\":\"CalculatingUserLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalDelegatedTo\",\"type\":\"uint256\"}],\"name\":\"Delegated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userUnstaked\",\"type\":\"uint256\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userUnstaked\",\"type\":\"uint256\"}],\"name\":\"DepositedByTimelockManager\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userUnstaked\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userVesting\",\"type\":\"uint256\"}],\"name\":\"DepositedVesting\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epochIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newApr\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalStake\",\"type\":\"uint256\"}],\"name\":\"MintedReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalStake\",\"type\":\"uint256\"}],\"name\":\"PaidOutClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"scheduledFor\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userShares\",\"type\":\"uint256\"}],\"name\":\"ScheduledUnstake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"aprUpdateStep\",\"type\":\"uint256\"}],\"name\":\"SetAprUpdateStep\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimsManager\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"SetClaimsManagerStatus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"agentAppPrimary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"agentAppSecondary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"votingAppPrimary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"votingAppSecondary\",\"type\":\"address\"}],\"name\":\"SetDaoApps\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxApr\",\"type\":\"uint256\"}],\"name\":\"SetMaxApr\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minApr\",\"type\":\"uint256\"}],\"name\":\"SetMinApr\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalVotingPowerThreshold\",\"type\":\"uint256\"}],\"name\":\"SetProposalVotingPowerThreshold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeTarget\",\"type\":\"uint256\"}],\"name\":\"SetStakeTarget\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unstakeWaitPeriod\",\"type\":\"uint256\"}],\"name\":\"SetUnstakeWaitPeriod\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintedShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userUnstaked\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalStake\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalDelegatedTo\",\"type\":\"uint256\"}],\"name\":\"Undelegated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userUnstaked\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalStake\",\"type\":\"uint256\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"delta\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalDelegatedTo\",\"type\":\"uint256\"}],\"name\":\"UpdatedDelegation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lastProposalTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"votingApp\",\"type\":\"address\"}],\"name\":\"UpdatedLastProposalTimestamp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userVesting\",\"type\":\"uint256\"}],\"name\":\"VestedTimelock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userUnstaked\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"EPOCH_LENGTH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REWARD_VESTING_PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"agentAppPrimary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"agentAppSecondary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"api3Token\",\"outputs\":[{\"internalType\":\"contract IApi3Token\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"apr\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"aprUpdateStep\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimsManagerStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"delegateVotingPower\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"delegatedToUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"delegatedToUserAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositAndStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositRegular\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"releaseStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"releaseEnd\",\"type\":\"uint256\"}],\"name\":\"depositWithVesting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epochIndexOfLastReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"epochIndexToReward\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"atBlock\",\"type\":\"uint32\"},{\"internalType\":\"uint224\",\"name\":\"amount\",\"type\":\"uint224\"},{\"internalType\":\"uint256\",\"name\":\"totalSharesThen\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStakeThen\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"genesisEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"unstaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vesting\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstakeShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstakeScheduledFor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastDelegationUpdateTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastProposalTimestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isGenesisEpoch\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxApr\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minApr\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"payOutClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolShares\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"fromBlock\",\"type\":\"uint32\"},{\"internalType\":\"uint224\",\"name\":\"value\",\"type\":\"uint224\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"noEpochsPerIteration\",\"type\":\"uint256\"}],\"name\":\"precalculateUserLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"finished\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposalVotingPowerThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"scheduleUnstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_aprUpdateStep\",\"type\":\"uint256\"}],\"name\":\"setAprUpdateStep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"claimsManager\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setClaimsManagerStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_agentAppPrimary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_agentAppSecondary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_votingAppPrimary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_votingAppSecondary\",\"type\":\"address\"}],\"name\":\"setDaoApps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxApr\",\"type\":\"uint256\"}],\"name\":\"setMaxApr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minApr\",\"type\":\"uint256\"}],\"name\":\"setMinApr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_proposalVotingPowerThreshold\",\"type\":\"uint256\"}],\"name\":\"setProposalVotingPowerThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakeTarget\",\"type\":\"uint256\"}],\"name\":\"setStakeTarget\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_unstakeWaitPeriod\",\"type\":\"uint256\"}],\"name\":\"setUnstakeWaitPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeTarget\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timelockManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"totalSharesAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"undelegateVotingPower\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"unstake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstakeAndWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstakeWaitPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"updateLastProposalTimestamp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"updateTimelockStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"userDelegate\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"userDelegateAt\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"userLocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"locked\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"userShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"userSharesAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"userStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userToLockedCalculation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"initialIndEpoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextIndEpoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"locked\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userToTimelock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"releaseStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"releaseEnd\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"userVotingPower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"userVotingPowerAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"unstaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vesting\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstakeShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstakeScheduledFor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastDelegationUpdateTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastProposalTimestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votingAppPrimary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votingAppSecondary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawPrecalculated\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawRegular\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Api3Pool","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000b38210ea11411557c13457d4da7dc6ea731b88a000000000000000000000000faef86994a37f1c8b2a5c73648f07dd4eff02baa","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://dab22d0b89f8e4222d6d396b8e9eff20e527eeba97d049ec9d7bf982050a7ce5"}]}