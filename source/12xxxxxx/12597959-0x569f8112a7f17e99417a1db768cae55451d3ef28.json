{"status":"1","message":"OK","result":[{"SourceCode":"// Sources flattened with hardhat v2.0.11 https://hardhat.org\r\n\r\n// File contracts/interfaces/IController.sol\r\n\r\n/*\r\n    Copyright 2021 Cook Finance.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n\r\n    SPDX-License-Identifier: Apache License, Version 2.0\r\n*/\r\npragma solidity 0.6.10;\r\n\r\ninterface IController {\r\n    function addCK(address _ckToken) external;\r\n    function feeRecipient() external view returns(address);\r\n    function getModuleFee(address _module, uint256 _feeType) external view returns(uint256);\r\n    function isModule(address _module) external view returns(bool);\r\n    function isCK(address _ckToken) external view returns(bool);\r\n    function isSystemContract(address _contractAddress) external view returns (bool);\r\n    function resourceId(uint256 _id) external view returns(address);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Context.sol@v3.4.0\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/access/Ownable.sol@v3.4.0\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/protocol/IntegrationRegistry.sol\r\n\r\n/*\r\n    Copyright 2021 Cook Finance.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n\r\n*/\r\n\r\npragma solidity 0.6.10;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n/**\r\n * @title IntegrationRegistry\r\n * @author Cook Finance\r\n *\r\n * The IntegrationRegistry holds state relating to the Modules and the integrations they are connected with.\r\n * The state is combined into a single Registry to allow governance updates to be aggregated to one contract.\r\n */\r\ncontract IntegrationRegistry is Ownable {\r\n\r\n    /* ============ Events ============ */\r\n\r\n    event IntegrationAdded(address indexed _module, address indexed _adapter, string _integrationName);\r\n    event IntegrationRemoved(address indexed _module, address indexed _adapter, string _integrationName);\r\n    event IntegrationEdited(\r\n        address indexed _module,\r\n        address _newAdapter,\r\n        string _integrationName\r\n    );\r\n\r\n    /* ============ State Variables ============ */\r\n\r\n    // Address of the Controller contract\r\n    IController public controller;\r\n\r\n    // Mapping of module => integration identifier => adapter address\r\n    mapping(address => mapping(bytes32 => address)) private integrations;\r\n\r\n    /* ============ Constructor ============ */\r\n\r\n    /**\r\n     * Initializes the controller\r\n     *\r\n     * @param _controller          Instance of the controller\r\n     */\r\n    constructor(IController _controller) public {\r\n        controller = _controller;\r\n    }\r\n\r\n    /* ============ External Functions ============ */\r\n\r\n    /**\r\n     * GOVERNANCE FUNCTION: Add a new integration to the registry\r\n     *\r\n     * @param  _module       The address of the module associated with the integration\r\n     * @param  _name         Human readable string identifying the integration\r\n     * @param  _adapter      Address of the adapter contract to add\r\n     */\r\n    function addIntegration(\r\n        address _module,\r\n        string memory _name,\r\n        address _adapter\r\n    )\r\n        public\r\n        onlyOwner\r\n    {\r\n        bytes32 hashedName = _nameHash(_name);\r\n        require(controller.isModule(_module), \"Must be valid module.\");\r\n        require(integrations[_module][hashedName] == address(0), \"Integration exists already.\");\r\n        require(_adapter != address(0), \"Adapter address must exist.\");\r\n\r\n        integrations[_module][hashedName] = _adapter;\r\n\r\n        emit IntegrationAdded(_module, _adapter, _name);\r\n    }\r\n\r\n    /**\r\n     * GOVERNANCE FUNCTION: Batch add new adapters. Reverts if exists on any module and name\r\n     *\r\n     * @param  _modules      Array of addresses of the modules associated with integration\r\n     * @param  _names        Array of human readable strings identifying the integration\r\n     * @param  _adapters     Array of addresses of the adapter contracts to add\r\n     */\r\n    function batchAddIntegration(\r\n        address[] memory _modules,\r\n        string[] memory _names,\r\n        address[] memory _adapters\r\n    )\r\n        external\r\n        onlyOwner\r\n    {\r\n        // Storing modules count to local variable to save on invocation\r\n        uint256 modulesCount = _modules.length;\r\n\r\n        require(modulesCount > 0, \"Modules must not be empty\");\r\n        require(modulesCount == _names.length, \"Module and name lengths mismatch\");\r\n        require(modulesCount == _adapters.length, \"Module and adapter lengths mismatch\");\r\n\r\n        for (uint256 i = 0; i < modulesCount; i++) {\r\n            // Add integrations to the specified module. Will revert if module and name combination exists\r\n            addIntegration(\r\n                _modules[i],\r\n                _names[i],\r\n                _adapters[i]\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * GOVERNANCE FUNCTION: Edit an existing integration on the registry\r\n     *\r\n     * @param  _module       The address of the module associated with the integration\r\n     * @param  _name         Human readable string identifying the integration\r\n     * @param  _adapter      Address of the adapter contract to edit\r\n     */\r\n    function editIntegration(\r\n        address _module,\r\n        string memory _name,\r\n        address _adapter\r\n    )\r\n        public\r\n        onlyOwner\r\n    {\r\n        bytes32 hashedName = _nameHash(_name);\r\n\r\n        require(controller.isModule(_module), \"Must be valid module.\");\r\n        require(integrations[_module][hashedName] != address(0), \"Integration does not exist.\");\r\n        require(_adapter != address(0), \"Adapter address must exist.\");\r\n\r\n        integrations[_module][hashedName] = _adapter;\r\n\r\n        emit IntegrationEdited(_module, _adapter, _name);\r\n    }\r\n\r\n    /**\r\n     * GOVERNANCE FUNCTION: Batch edit adapters for modules. Reverts if module and\r\n     * adapter name don't map to an adapter address\r\n     *\r\n     * @param  _modules      Array of addresses of the modules associated with integration\r\n     * @param  _names        Array of human readable strings identifying the integration\r\n     * @param  _adapters     Array of addresses of the adapter contracts to add\r\n     */\r\n    function batchEditIntegration(\r\n        address[] memory _modules,\r\n        string[] memory _names,\r\n        address[] memory _adapters\r\n    )\r\n        external\r\n        onlyOwner\r\n    {\r\n        // Storing name count to local variable to save on invocation\r\n        uint256 modulesCount = _modules.length;\r\n\r\n        require(modulesCount > 0, \"Modules must not be empty\");\r\n        require(modulesCount == _names.length, \"Module and name lengths mismatch\");\r\n        require(modulesCount == _adapters.length, \"Module and adapter lengths mismatch\");\r\n\r\n        for (uint256 i = 0; i < modulesCount; i++) {\r\n            // Edits integrations to the specified module. Will revert if module and name combination does not exist\r\n            editIntegration(\r\n                _modules[i],\r\n                _names[i],\r\n                _adapters[i]\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * GOVERNANCE FUNCTION: Remove an existing integration on the registry\r\n     *\r\n     * @param  _module       The address of the module associated with the integration\r\n     * @param  _name         Human readable string identifying the integration\r\n     */\r\n    function removeIntegration(address _module, string memory _name) external onlyOwner {\r\n        bytes32 hashedName = _nameHash(_name);\r\n        require(integrations[_module][hashedName] != address(0), \"Integration does not exist.\");\r\n\r\n        address oldAdapter = integrations[_module][hashedName];\r\n        delete integrations[_module][hashedName];\r\n\r\n        emit IntegrationRemoved(_module, oldAdapter, _name);\r\n    }\r\n\r\n    /* ============ External Getter Functions ============ */\r\n\r\n    /**\r\n     * Get integration adapter address associated with passed human readable name\r\n     *\r\n     * @param  _module       The address of the module associated with the integration\r\n     * @param  _name         Human readable adapter name\r\n     *\r\n     * @return               Address of adapter\r\n     */\r\n    function getIntegrationAdapter(address _module, string memory _name) external view returns (address) {\r\n        return integrations[_module][_nameHash(_name)];\r\n    }\r\n\r\n    /**\r\n     * Get integration adapter address associated with passed hashed name\r\n     *\r\n     * @param  _module       The address of the module associated with the integration\r\n     * @param  _nameHash     Hash of human readable adapter name\r\n     *\r\n     * @return               Address of adapter\r\n     */\r\n    function getIntegrationAdapterWithHash(address _module, bytes32 _nameHash) external view returns (address) {\r\n        return integrations[_module][_nameHash];\r\n    }\r\n\r\n    /**\r\n     * Check if adapter name is valid\r\n     *\r\n     * @param  _module       The address of the module associated with the integration\r\n     * @param  _name         Human readable string identifying the integration\r\n     *\r\n     * @return               Boolean indicating if valid\r\n     */\r\n    function isValidIntegration(address _module, string memory _name) external view returns (bool) {\r\n        return integrations[_module][_nameHash(_name)] != address(0);\r\n    }\r\n\r\n    /* ============ Internal Functions ============ */\r\n\r\n    /**\r\n     * Hashes the string and returns a bytes32 value\r\n     */\r\n    function _nameHash(string memory _name) internal pure returns(bytes32) {\r\n        return keccak256(bytes(_name));\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IController\",\"name\":\"_controller\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_module\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_adapter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_integrationName\",\"type\":\"string\"}],\"name\":\"IntegrationAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_module\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newAdapter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_integrationName\",\"type\":\"string\"}],\"name\":\"IntegrationEdited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_module\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_adapter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_integrationName\",\"type\":\"string\"}],\"name\":\"IntegrationRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_module\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_adapter\",\"type\":\"address\"}],\"name\":\"addIntegration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_modules\",\"type\":\"address[]\"},{\"internalType\":\"string[]\",\"name\":\"_names\",\"type\":\"string[]\"},{\"internalType\":\"address[]\",\"name\":\"_adapters\",\"type\":\"address[]\"}],\"name\":\"batchAddIntegration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_modules\",\"type\":\"address[]\"},{\"internalType\":\"string[]\",\"name\":\"_names\",\"type\":\"string[]\"},{\"internalType\":\"address[]\",\"name\":\"_adapters\",\"type\":\"address[]\"}],\"name\":\"batchEditIntegration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"contract IController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_module\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_adapter\",\"type\":\"address\"}],\"name\":\"editIntegration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_module\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"getIntegrationAdapter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_module\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_nameHash\",\"type\":\"bytes32\"}],\"name\":\"getIntegrationAdapterWithHash\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_module\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"isValidIntegration\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_module\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"removeIntegration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"IntegrationRegistry","CompilerVersion":"v0.6.10+commit.00c0fcaf","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000e565711e7a59800e110c959e156121988e6f4704","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":"ipfs://a2b017d08b6b353e471b1f16dce5dc9626e3ce47e0a528afc3dc20b123697597"}]}