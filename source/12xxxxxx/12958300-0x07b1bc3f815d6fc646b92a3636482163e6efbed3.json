{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/seed/Seed.sol\": {\r\n      \"content\": \"/*\\r\\n\\r\\n██████╗░██████╗░██╗███╗░░░███╗███████╗██████╗░░█████╗░░█████╗░\\r\\n██╔══██╗██╔══██╗██║████╗░████║██╔════╝██╔══██╗██╔══██╗██╔══██╗\\r\\n██████╔╝██████╔╝██║██╔████╔██║█████╗░░██║░░██║███████║██║░░██║\\r\\n██╔═══╝░██╔══██╗██║██║╚██╔╝██║██╔══╝░░██║░░██║██╔══██║██║░░██║\\r\\n██║░░░░░██║░░██║██║██║░╚═╝░██║███████╗██████╔╝██║░░██║╚█████╔╝\\r\\n╚═╝░░░░░╚═╝░░╚═╝╚═╝╚═╝░░░░░╚═╝╚══════╝╚═════╝░╚═╝░░╚═╝░╚════╝░\\r\\n\\r\\n*/\\r\\n\\r\\n// SPDX-License-Identifier: GPL-3.0-or-later\\r\\n// solium-disable operator-whitespace\\r\\n/* solhint-disable space-after-comma */\\r\\n/* solhint-disable max-states-count */\\r\\n// solium-disable linebreak-style\\r\\npragma solidity 0.8.6;\\r\\n\\r\\nimport \\\"openzeppelin-contracts-sol8/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\n\\r\\n/**\\r\\n * @title PrimeDAO Seed contract\\r\\n * @dev   Smart contract for seed phases of liquid launch.\\r\\n */\\r\\ncontract Seed {\\r\\n    // Locked parameters\\r\\n    address public beneficiary;\\r\\n    address public admin;\\r\\n    uint256 public softCap;\\r\\n    uint256 public hardCap;\\r\\n    uint256 public seedAmountRequired; // Amount of seed required for distribution\\r\\n    uint256 public feeAmountRequired;  // Amount of seed required for fee\\r\\n    uint256 public price;              // price of a SeedToken, expressed in fundingTokens, with precision of 10**18\\r\\n    uint256 public startTime;\\r\\n    uint256 public endTime;            // set by project admin, this is the last resort endTime to be applied when\\r\\n                                       //     maximumReached has not been reached by then\\r\\n    bool    public permissionedSeed;\\r\\n    uint32  public vestingDuration;\\r\\n    uint32  public vestingCliff;\\r\\n    IERC20  public seedToken;\\r\\n    IERC20  public fundingToken;\\r\\n    uint256 public fee;                // Success fee expressed as a % (e.g. 10**18 = 100% fee, 10**16 = 1%)\\r\\n\\r\\n    bytes   public metadata;           // IPFS Hash\\r\\n\\r\\n    uint256 constant internal PRECISION = 10 ** 18; // used for precision e.g. 1 ETH = 10**18 wei; toWei(\\\"1\\\") = 10**18\\r\\n\\r\\n    // Contract logic\\r\\n    bool    public closed;                 // is the distribution closed\\r\\n    bool    public paused;                 // is the distribution paused\\r\\n    bool    public isFunded;               // distribution can only start when required seed tokens have been funded\\r\\n    bool    public initialized;            // is this contract initialized [not necessary that it is funded]\\r\\n    bool    public minimumReached;         // if the softCap[minimum limit of funding token] is reached\\r\\n    bool    public maximumReached;         // if the hardCap[maximum limit of funding token] is reached\\r\\n    uint256 public vestingStartTime;       // timestamp for when vesting starts, by default == endTime,\\r\\n                                           //     otherwise when maximumReached is reached\\r\\n    uint256 public totalFunderCount;       // Total funders that have contributed.\\r\\n    uint256 public seedRemainder;          // Amount of seed tokens remaining to be distributed\\r\\n    uint256 public seedClaimed;            // Amount of seed token claimed by the user.\\r\\n    uint256 public feeRemainder;           // Amount of seed tokens remaining for the fee\\r\\n    uint256 public fundingCollected;       // Amount of funding tokens collected by the seed contract.\\r\\n    uint256 public fundingWithdrawn;       // Amount of funding token withdrawn from the seed contract.\\r\\n\\r\\n    mapping (address => bool) public whitelisted;        // funders that are whitelisted and allowed to contribute\\r\\n    mapping (address => FunderPortfolio) public funders; // funder address to funder portfolio\\r\\n\\r\\n    event SeedsPurchased(address indexed recipient, uint256 amountPurchased);\\r\\n    event TokensClaimed(address indexed recipient,uint256 amount,address indexed beneficiary,uint256 feeAmount);\\r\\n    event FundingReclaimed(address indexed recipient, uint256 amountReclaimed);\\r\\n    event MetadataUpdated(bytes indexed metadata);\\r\\n\\r\\n    struct FunderPortfolio {\\r\\n        uint256 totalClaimed;               // Total amount of seed tokens claimed\\r\\n        uint256 fundingAmount;              // Total amount of funding tokens contributed\\r\\n    }\\r\\n\\r\\n    modifier onlyAdmin() {\\r\\n        require(msg.sender == admin, \\\"Seed: caller should be admin\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier isActive() {\\r\\n        require(!closed, \\\"Seed: should not be closed\\\");\\r\\n        require(!paused, \\\"Seed: should not be paused\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @dev                          Initialize Seed.\\r\\n      * @param _beneficiary           The address that recieves fees.\\r\\n      * @param _admin                 The address of the admin of this contract. Funds contract\\r\\n                                      and has permissions to whitelist users, pause and close contract.\\r\\n      * @param _tokens                Array containing two params:\\r\\n                                        - The address of the seed token being distributed.\\r\\n      *                                 - The address of the funding token being exchanged for seed token.\\r\\n      * @param _softHardThresholds    Array containing two params:\\r\\n                                        - the minimum funding token collection threshold in wei denomination.\\r\\n                                        - the highest possible funding token amount to be raised in wei denomination.\\r\\n      * @param _price                 price of a SeedToken, expressed in fundingTokens, with precision of 10**18\\r\\n      * @param _startTime             Distribution start time in unix timecode.\\r\\n      * @param _endTime               Distribution end time in unix timecode.\\r\\n      * @param _vestingDuration       Vesting period duration in seconds.\\r\\n      * @param _vestingCliff          Cliff duration in seconds.\\r\\n      * @param _permissionedSeed      Set to true if only whitelisted adresses are allowed to participate.\\r\\n      * @param _fee                   Success fee expressed as a % (e.g. 10**18 = 100% fee, toWei('1') = 100%)\\r\\n    */\\r\\n    function initialize(\\r\\n        address _beneficiary,\\r\\n        address _admin,\\r\\n        address[] memory _tokens,\\r\\n        uint256[] memory _softHardThresholds,\\r\\n        uint256 _price,\\r\\n        uint256 _startTime,\\r\\n        uint256 _endTime,\\r\\n        uint32  _vestingDuration,\\r\\n        uint32  _vestingCliff,\\r\\n        bool    _permissionedSeed,\\r\\n        uint256   _fee\\r\\n    ) external\\r\\n    {\\r\\n        require(!initialized, \\\"Seed: contract already initialized\\\");\\r\\n        initialized = true;\\r\\n\\r\\n        // parameter check\\r\\n        require(_tokens[0] != _tokens[1], \\\"SeedFactory: seedToken cannot be fundingToken\\\");\\r\\n        require(_softHardThresholds[1] >= _softHardThresholds[0],\\\"SeedFactory: hardCap cannot be less than softCap\\\");\\r\\n        require(_vestingDuration >= _vestingCliff, \\\"SeedFactory: vestingDuration cannot be less than vestingCliff\\\");\\r\\n        require(_endTime > _startTime, \\\"SeedFactory: endTime cannot be less than equal to startTime\\\");\\r\\n\\r\\n        beneficiary       = _beneficiary;\\r\\n        admin             = _admin;\\r\\n        softCap           = _softHardThresholds[0];\\r\\n        hardCap           = _softHardThresholds[1];\\r\\n        price             = _price;\\r\\n        startTime         = _startTime;\\r\\n        endTime           = _endTime;\\r\\n        vestingStartTime  = endTime;\\r\\n        vestingDuration   = _vestingDuration;\\r\\n        vestingCliff      = _vestingCliff;\\r\\n        permissionedSeed  = _permissionedSeed;\\r\\n        seedToken         = IERC20(_tokens[0]);\\r\\n        fundingToken      = IERC20(_tokens[1]);\\r\\n        fee               = _fee;\\r\\n\\r\\n        seedAmountRequired = (hardCap*PRECISION) / _price;\\r\\n        // (seedAmountRequired*fee) / (100*FEE_PRECISION) = (seedAmountRequired*fee) / PRECISION\\r\\n        //  where FEE_PRECISION = 10**16\\r\\n        feeAmountRequired  = (seedAmountRequired*fee) / PRECISION;\\r\\n        seedRemainder      = seedAmountRequired;\\r\\n        feeRemainder       = feeAmountRequired;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @dev                     Buy seed tokens.\\r\\n      * @param _fundingAmount    The amount of funding tokens to contribute.\\r\\n    */\\r\\n    function buy(uint256 _fundingAmount) external isActive returns(uint256, uint256) {\\r\\n        require(!maximumReached, \\\"Seed: maximum funding reached\\\");\\r\\n        require(!permissionedSeed || whitelisted[msg.sender], \\\"Seed: sender has no rights\\\");\\r\\n        require(endTime >= block.timestamp && startTime <= block.timestamp,\\r\\n            \\\"Seed: only allowed during distribution period\\\");\\r\\n        if (!isFunded) {\\r\\n            require(seedToken.balanceOf(address(this)) >= seedAmountRequired + feeAmountRequired,\\r\\n                \\\"Seed: sufficient seeds not provided\\\");\\r\\n            isFunded = true;\\r\\n        }\\r\\n        // fundingAmount is an amount of fundingTokens required to buy _seedAmount of SeedTokens\\r\\n        uint256 seedAmount = (_fundingAmount*PRECISION)/price;\\r\\n\\r\\n        // feeAmount is an amount of fee we are going to get in seedTokens\\r\\n        uint256 feeAmount = (seedAmount*fee) / PRECISION;\\r\\n\\r\\n        // seed amount vested per second > zero, i.e. amountVestedPerSecond = seedAmount/vestingDuration\\r\\n        require(\\r\\n            seedAmount >= vestingDuration,\\r\\n            \\\"Seed: amountVestedPerSecond > 0\\\");\\r\\n\\r\\n        // total fundingAmount should not be greater than the hardCap\\r\\n        require( fundingCollected + _fundingAmount <= hardCap,\\r\\n            \\\"Seed: amount exceeds contract sale hardCap\\\");\\r\\n\\r\\n        fundingCollected += _fundingAmount;\\r\\n\\r\\n        // the amount of seed tokens still to be distributed\\r\\n        seedRemainder -= seedAmount;\\r\\n        feeRemainder  -= feeAmount;\\r\\n\\r\\n        if (fundingCollected >= softCap) {\\r\\n            minimumReached = true;\\r\\n        }\\r\\n        if (fundingCollected >= hardCap) {\\r\\n            maximumReached = true;\\r\\n            vestingStartTime = block.timestamp;\\r\\n        }\\r\\n\\r\\n        //functionality of addFunder\\r\\n        if (funders[msg.sender].fundingAmount==0) {\\r\\n            totalFunderCount++;\\r\\n        }\\r\\n        funders[msg.sender].fundingAmount += _fundingAmount;\\r\\n\\r\\n        // Here we are sending amount of tokens to pay for seed tokens to purchase\\r\\n        require(\\r\\n            fundingToken.transferFrom(msg.sender, address(this), _fundingAmount),\\r\\n            \\\"Seed: funding token transferFrom failed\\\"\\r\\n        );\\r\\n\\r\\n        emit SeedsPurchased(msg.sender, seedAmount);\\r\\n\\r\\n        return (seedAmount, feeAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @dev                     Claim vested seed tokens.\\r\\n      * @param _funder           Address of funder to calculate seconds and amount claimable\\r\\n      * @param _claimAmount      The amount of seed token a users wants to claim.\\r\\n    */\\r\\n    function claim(address _funder, uint256 _claimAmount) external returns(uint256) {\\r\\n        require(minimumReached, \\\"Seed: minimum funding amount not met\\\");\\r\\n        require(endTime < block.timestamp || maximumReached,\\\"Seed: the distribution has not yet finished\\\");\\r\\n        uint256 amountClaimable;\\r\\n\\r\\n        amountClaimable = calculateClaim(_funder);\\r\\n        require(amountClaimable > 0, \\\"Seed: amount claimable is 0\\\");\\r\\n        require(amountClaimable >= _claimAmount, \\\"Seed: request is greater than claimable amount\\\");\\r\\n        uint256 feeAmountOnClaim = (_claimAmount * fee) / PRECISION;\\r\\n\\r\\n        funders[_funder].totalClaimed    += _claimAmount;\\r\\n\\r\\n        seedClaimed += _claimAmount;\\r\\n        require(\\r\\n            seedToken.transfer(beneficiary, feeAmountOnClaim) && seedToken.transfer(_funder, _claimAmount),\\r\\n            \\\"Seed: seed token transfer failed\\\");\\r\\n\\r\\n        emit TokensClaimed(_funder, _claimAmount, beneficiary, feeAmountOnClaim);\\r\\n\\r\\n        return feeAmountOnClaim;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @dev         Returns funding tokens to user.\\r\\n    */\\r\\n    function retrieveFundingTokens() external returns(uint256) {\\r\\n        require(startTime <= block.timestamp, \\\"Seed: distribution haven't started\\\");\\r\\n        require(!minimumReached, \\\"Seed: minimum funding amount met\\\");\\r\\n        FunderPortfolio storage tokenFunder = funders[msg.sender];\\r\\n        uint256 fundingAmount = tokenFunder.fundingAmount;\\r\\n        require(fundingAmount > 0, \\\"Seed: zero funding amount\\\");\\r\\n        seedRemainder += seedAmountForFunder(msg.sender);\\r\\n        feeRemainder += feeForFunder(msg.sender);\\r\\n        totalFunderCount--;\\r\\n        tokenFunder.fundingAmount = 0;\\r\\n        fundingCollected -= fundingAmount;\\r\\n        require(\\r\\n            fundingToken.transfer(msg.sender, fundingAmount),\\r\\n            \\\"Seed: cannot return funding tokens to msg.sender\\\"\\r\\n        );\\r\\n        emit FundingReclaimed(msg.sender, fundingAmount);\\r\\n\\r\\n        return fundingAmount;\\r\\n    }\\r\\n\\r\\n    // ADMIN ACTIONS\\r\\n\\r\\n    /**\\r\\n      * @dev                     Pause distribution.\\r\\n    */\\r\\n    function pause() external onlyAdmin isActive {\\r\\n        paused = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @dev                     Unpause distribution.\\r\\n    */\\r\\n    function unpause() external onlyAdmin {\\r\\n        require(closed != true, \\\"Seed: should not be closed\\\");\\r\\n        require(paused == true, \\\"Seed: should be paused\\\");\\r\\n\\r\\n        paused = false;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @dev                Shut down contributions (buying).\\r\\n                            Supersedes the normal logic that eventually shuts down buying anyway.\\r\\n                            Also shuts down the admin's ability to alter the whitelist.\\r\\n    */\\r\\n    function close() external onlyAdmin {\\r\\n        // close seed token distribution\\r\\n        require(!closed, \\\"Seed: should not be closed\\\");\\r\\n        closed = true;\\r\\n        paused = false;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @dev                     retrieve remaining seed tokens back to project.\\r\\n      * @param _refundReceiver   refund receiver address\\r\\n    */\\r\\n    function retrieveSeedTokens(address _refundReceiver) external onlyAdmin {\\r\\n        // transfer seed tokens back to admin\\r\\n        /*\\r\\n            Can't withdraw seed tokens until buying has ended and\\r\\n            therefore the number of distributable seed tokens can no longer change.\\r\\n        */\\r\\n        require(\\r\\n            closed ||\\r\\n            maximumReached ||\\r\\n            block.timestamp >= endTime,\\r\\n            \\\"Seed: The ability to buy seed tokens must have ended before remaining seed tokens can be withdrawn\\\"\\r\\n        );\\r\\n        if (!minimumReached) {\\r\\n            require(\\r\\n                seedToken.transfer(_refundReceiver, seedToken.balanceOf(address(this))),\\r\\n                \\\"Seed: should transfer seed tokens to refund receiver\\\"\\r\\n            );\\r\\n        } else {\\r\\n            // seed tokens to transfer = balance of seed tokens - totalSeedDistributed\\r\\n            uint256 totalSeedDistributed = (seedAmountRequired+feeAmountRequired)-(seedRemainder+feeRemainder);\\r\\n            uint256 amountToTransfer = seedToken.balanceOf(address(this))-totalSeedDistributed;\\r\\n            require(\\r\\n                seedToken.transfer(_refundReceiver, amountToTransfer),\\r\\n                \\\"Seed: should transfer seed tokens to refund receiver\\\"\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @dev                     Add address to whitelist.\\r\\n      * @param _buyer            Address which needs to be whitelisted\\r\\n    */\\r\\n    function whitelist(address _buyer) external onlyAdmin {\\r\\n        require(!closed, \\\"Seed: should not be closed\\\");\\r\\n        require(permissionedSeed == true, \\\"Seed: seed is not whitelisted\\\");\\r\\n\\r\\n        whitelisted[_buyer] = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @dev                     Add multiple addresses to whitelist.\\r\\n      * @param _buyers           Array of addresses to whitelist addresses in batch\\r\\n    */\\r\\n    function whitelistBatch(address[] memory _buyers) external onlyAdmin {\\r\\n        require(!closed, \\\"Seed: should not be closed\\\");\\r\\n        require(permissionedSeed == true, \\\"Seed: seed is not whitelisted\\\");\\r\\n        for (uint256 i = 0; i < _buyers.length; i++) {\\r\\n            whitelisted[_buyers[i]] = true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @dev                     Remove address from whitelist.\\r\\n      * @param buyer             Address which needs to be unwhitelisted\\r\\n    */\\r\\n    function unwhitelist(address buyer) external onlyAdmin {\\r\\n        require(!closed, \\\"Seed: should not be closed\\\");\\r\\n        require(permissionedSeed == true, \\\"Seed: seed is not whitelisted\\\");\\r\\n\\r\\n        whitelisted[buyer] = false;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @dev                     Withdraw funds from the contract\\r\\n    */\\r\\n    function withdraw() external onlyAdmin {\\r\\n        /*\\r\\n            Admin can't withdraw funding tokens until buying has ended and\\r\\n            therefore contributors can no longer withdraw their funding tokens.\\r\\n        */\\r\\n        require(\\r\\n            maximumReached ||\\r\\n            (minimumReached && block.timestamp >= endTime),\\r\\n            \\\"Seed: cannot withdraw while funding tokens can still be withdrawn by contributors\\\"\\r\\n        );\\r\\n        uint pendingFundingBalance = fundingCollected - fundingWithdrawn;\\r\\n        fundingWithdrawn = fundingCollected;\\r\\n        fundingToken.transfer(msg.sender, pendingFundingBalance);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @dev                     Updates metadata.\\r\\n      * @param _metadata         Seed contract metadata, that is IPFS Hash\\r\\n    */\\r\\n    function updateMetadata(bytes memory _metadata) external {\\r\\n        require(\\r\\n            initialized != true || msg.sender == admin,\\r\\n            \\\"Seed: contract should not be initialized or caller should be admin\\\"\\r\\n        );\\r\\n        metadata = _metadata;\\r\\n        emit MetadataUpdated(_metadata);\\r\\n    }\\r\\n\\r\\n    // GETTER FUNCTIONS\\r\\n    /**\\r\\n      * @dev                     Calculates the maximum claim\\r\\n      * @param _funder           Address of funder to find the maximum claim\\r\\n    */\\r\\n    function calculateClaim(address _funder) public view returns(uint256) {\\r\\n        FunderPortfolio storage tokenFunder = funders[_funder];\\r\\n\\r\\n        if (block.timestamp < vestingStartTime) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        // Check cliff was reached\\r\\n        uint256 elapsedSeconds = block.timestamp - vestingStartTime;\\r\\n\\r\\n        if (elapsedSeconds < vestingCliff) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        // If over vesting duration, all tokens vested\\r\\n        if (elapsedSeconds >= vestingDuration) {\\r\\n            return seedAmountForFunder(_funder) - tokenFunder.totalClaimed;\\r\\n        } else {\\r\\n            uint256 amountVested = (elapsedSeconds*seedAmountForFunder(_funder)) / vestingDuration;\\r\\n            return amountVested - tokenFunder.totalClaimed;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @dev                     Amount of seed tokens claimed as fee\\r\\n    */\\r\\n    function feeClaimed() public view returns(uint256) {\\r\\n        return (seedClaimed*fee)/PRECISION;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @dev                     get fee claimed for funder\\r\\n      * @param _funder           address of funder to check fee claimed\\r\\n    */\\r\\n    function feeClaimedForFunder(address _funder) public view returns(uint256) {\\r\\n        return (funders[_funder].totalClaimed*fee)/PRECISION;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @dev                     get fee for funder\\r\\n      * @param _funder           address of funder to check fee\\r\\n    */\\r\\n    function feeForFunder(address _funder) public view returns(uint256) {\\r\\n        return (seedAmountForFunder(_funder)*fee)/PRECISION;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @dev                     get seed amount for funder\\r\\n      * @param _funder           address of funder to seed amount\\r\\n    */\\r\\n    function seedAmountForFunder(address _funder) public view returns(uint256) {\\r\\n        return (funders[_funder].fundingAmount*PRECISION)/price;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"openzeppelin-contracts-sol8/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountReclaimed\",\"type\":\"uint256\"}],\"name\":\"FundingReclaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"name\":\"MetadataUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountPurchased\",\"type\":\"uint256\"}],\"name\":\"SeedsPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"name\":\"TokensClaimed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fundingAmount\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_funder\",\"type\":\"address\"}],\"name\":\"calculateClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_funder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_claimAmount\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"close\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"closed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeAmountRequired\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_funder\",\"type\":\"address\"}],\"name\":\"feeClaimedForFunder\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_funder\",\"type\":\"address\"}],\"name\":\"feeForFunder\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeRemainder\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"funders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalClaimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fundingAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundingCollected\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundingToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundingWithdrawn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hardCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_softHardThresholds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_vestingDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_vestingCliff\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"_permissionedSeed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isFunded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maximumReached\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"metadata\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumReached\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"permissionedSeed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"retrieveFundingTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_refundReceiver\",\"type\":\"address\"}],\"name\":\"retrieveSeedTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_funder\",\"type\":\"address\"}],\"name\":\"seedAmountForFunder\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"seedAmountRequired\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"seedClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"seedRemainder\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"seedToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"softCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFunderCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"}],\"name\":\"unwhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_metadata\",\"type\":\"bytes\"}],\"name\":\"updateMetadata\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vestingCliff\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vestingDuration\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vestingStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_buyer\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_buyers\",\"type\":\"address[]\"}],\"name\":\"whitelistBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Seed","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}