{"status":"1","message":"OK","result":[{"SourceCode":"{\"AccessControl.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\ncontract AccessControl {\\n    // This facet controls access control for Cavalox. There are four roles managed here:\\n    //\\n    //     - The CEO: The CEO can reassign other roles and change the addresses of our dependent smart\\n    //         contracts. It is also the only role that can unpause the smart contract. It is initially\\n    //         set to the address that created the smart contract in the KittyCore constructor.\\n    //\\n    //     - The CFO: The CFO can withdraw funds from CVXBX.\\n    //\\n    //     - The COO: The COO can release gen0 kitties to auction, and mint promo cats.\\n    //\\n    // It should be noted that these roles are distinct without overlap in their access abilities, the\\n    // abilities listed for each role above are exhaustive. In particular, while the CEO can assign any\\n    // address to any role, the CEO address itself doesn\\u0027t have the ability to act in those roles. This\\n    // restriction is intentional so that we aren\\u0027t tempted to use the CEO address frequently out of\\n    // convenience. The less we use an address, the less likely it is that we somehow compromise the\\n    // account.\\n\\n    // The addresses of the accounts (or contracts) that can execute actions within each roles.\\n    address public ceoAddress;\\n    address payable public cfoAddress;\\n    address public cooAddress;\\n    \\n    constructor () public {\\n       ceoAddress = msg.sender;\\n       cfoAddress = msg.sender;\\n       cooAddress = msg.sender;\\n    }\\n    \\n    \\n    /// @dev Access modifier for CEO-only functionality\\n    modifier onlyCEO() {\\n        require(msg.sender == ceoAddress);\\n        _;\\n    }\\n\\n    /// @dev Access modifier for CFO-only functionality\\n    modifier onlyCFO() {\\n        require(msg.sender == cfoAddress);\\n        _;\\n    }\\n\\n    /// @dev Access modifier for COO-only functionality\\n    modifier onlyCOO() {\\n        require(msg.sender == cooAddress);\\n        _;\\n    }\\n\\n    modifier onlyCLevel() {\\n        require(\\n            msg.sender == cooAddress ||\\n            msg.sender == ceoAddress ||\\n            msg.sender == cfoAddress\\n        );\\n        _;\\n    }\\n    \\n     /// @dev Assigns a new address to act as the CEO. Only available to the current CEO.\\n    /// @param _newCEO The address of the new CEO\\n    function setCEO(address _newCEO) external onlyCEO {\\n        require(_newCEO != address(0));\\n\\n        ceoAddress = _newCEO;\\n    }\\n\\n    /// @dev Assigns a new address to act as the CFO. Only available to the current CEO.\\n    /// @param _newCFO The address of the new CFO\\n    function setCFO(address payable _newCFO) external onlyCEO {\\n        require(_newCFO != address(0));\\n\\n        cfoAddress = _newCFO;\\n    }\\n\\n    /// @dev Assigns a new address to act as the COO. Only available to the current CEO.\\n    /// @param _newCOO The address of the new COO\\n    function setCOO(address _newCOO) external onlyCEO {\\n        require(_newCOO != address(0));\\n\\n        cooAddress = _newCOO;\\n    }\\n}\\n\"},\"BidCVXBX.sol\":{\"content\":\"pragma solidity ^0.5.0;\\nimport \\\"./ERC721Full.sol\\\";\\nimport \\\"./AccessControl.sol\\\";\\n\\ncontract BidCVXBX is Ownable, AccessControl, ERC721Full {\\n\\n    //Bidding Active Status\\n    bool public bidding = false;\\n\\n    address constant nullAddress = address(0);\\n\\n    //Bidding\\n    struct Offer {\\n        bool isForSale;\\n        uint tokenId;\\n        address seller;\\n        uint minValue;          // in ether\\n        address onlySellTo;     // specify to sell only to a specific person\\n    }\\n\\n    struct Bid {\\n        bool hasBid;\\n        uint tokenId;\\n        address bidder;\\n        uint value;\\n    }\\n\\n\\n    // A record of horses that are offered for sale at a specific minimum value, and perhaps to a specific person\\n    mapping (uint =\\u003e Offer) public horsesOfferedForSale;\\n\\n    // A record of the highest horse bid\\n    mapping (uint =\\u003e Bid) public horseBids;\\n\\n    mapping (address =\\u003e uint) public pendingWithdrawals;\\n\\n    uint public bidSuccessFees = 0; //Fees\\n\\n    //Bid specific events\\n    event BiddingPaused( uint64 date );\\n    event BiddingUnPaused( uint64 date );\\n\\n    event HorseOffered(uint indexed tokenId, uint minValue, address toAddress, uint64 time );\\n    event HorseBidEntered(uint indexed tokenId, uint value, address indexed fromAddress, uint64 time);\\n    event HorseBidWithdrawn(uint indexed tokenId, uint value, address indexed fromAddress, uint64 time);\\n    event HorseBoughtWithBid(uint indexed tokenId, uint value, address indexed fromAddress, address indexed toAddress, uint64 time);\\n    event HorseBoughtWithOffer(uint indexed tokenId, uint value, address indexed fromAddress, address indexed toAddress, uint64 time);\\n    event HorseNoLongerForSale(uint indexed tokenId, uint64 time);\\n\\n    modifier whenBiddingActive() {\\n        require(bidding, \\u0027Bidding is currently not active!\\u0027);\\n        _;\\n    }\\n\\n    modifier whenBiddingNotActive() {\\n        require(!bidding, \\u0027Bidding is currently active!\\u0027);\\n        _;\\n    }\\n\\n    modifier onlyTokenOwner( uint tokenId ) {\\n        require( ownerOf(tokenId) == msg.sender, \\u0027Only owners of horse can call this!\\u0027 );\\n        _;\\n    }\\n\\n    modifier onlyNonTokenOwner( uint tokenId ) {\\n        require( ownerOf(tokenId) != msg.sender \\u0026\\u0026 ownerOf(tokenId) != nullAddress, \\u0027Non owners of this horse can call this!\\u0027 );\\n        _;\\n    }\\n\\n    constructor () public { }\\n\\n    //Bidding Utilities\\n    /**\\n    * @dev called by the owner to pause, triggers stopped state of bidding\\n    */\\n   function pauseBidding() public onlyCOO whenBiddingActive returns (bool) {\\n      bidding = false;\\n      emit BiddingPaused( uint64(now) );\\n      return true;\\n   }\\n\\n   /**\\n   * @dev called by the owner to unpause, returns to normal state of bidding\\n   */\\n    function unpauseBidding() public onlyCOO whenBiddingNotActive returns (bool) {\\n      bidding = true;\\n      emit BiddingUnPaused( uint64(now) );\\n      return true;\\n    }\\n\\n    function horseNoLongerForSale(uint tokenId) public whenNotPaused whenBiddingActive onlyTokenOwner(tokenId) {\\n        horsesOfferedForSale[tokenId] = Offer(false, tokenId, msg.sender, 0, nullAddress);\\n        emit HorseNoLongerForSale(tokenId, uint64(now));\\n    }\\n\\n    function offerHorseForSale(uint tokenId, uint minSalePriceInWei) public whenNotPaused whenBiddingActive onlyTokenOwner(tokenId) {\\n        horsesOfferedForSale[tokenId] = Offer(true, tokenId, msg.sender, minSalePriceInWei, nullAddress);\\n        emit HorseOffered(tokenId, minSalePriceInWei, nullAddress, uint64(now) );\\n    }\\n\\n    function offerHorseForSaleToAddress(uint tokenId, uint minSalePriceInWei, address toAddress) public whenNotPaused whenBiddingActive onlyTokenOwner(tokenId) {\\n        horsesOfferedForSale[tokenId] = Offer(true, tokenId, msg.sender, minSalePriceInWei, toAddress);\\n        emit HorseOffered(tokenId, minSalePriceInWei, toAddress, uint64(now));\\n    }\\n\\n    function buyHorseFromOffer(uint tokenId) public whenNotPaused whenBiddingActive payable {\\n        Offer memory offer = horsesOfferedForSale[tokenId];\\n        require( offer.isForSale, \\u0027This horse if not for sale!\\u0027 );\\n        require( offer.onlySellTo == nullAddress || offer.onlySellTo == msg.sender, \\\"Horse not supposed to be sold to this user!\\\" );\\n        require( msg.value \\u003e= offer.minValue, \\\"Didn\\u0027t send enough ETH to buy Horse\\\" );\\n        require( offer.seller == ownerOf(tokenId), \\\"Seller no longer owner of horse\\\" );\\n\\n        address seller = offer.seller;\\n\\n        //Transfer horse to new owner\\n        transferFromOffer( seller, msg.sender, tokenId );\\n\\n        horseNoLongerForSale( tokenId );\\n        pendingWithdrawals[seller] += msg.value;\\n\\n        emit HorseBoughtWithOffer(tokenId, msg.value, seller, msg.sender, uint64(now));\\n\\n        // Check for the case where there is a bid from the new owner and refund it.\\n        // Any other bid can stay in place.\\n        Bid memory bid = horseBids[tokenId];\\n        if (bid.bidder == msg.sender) {\\n            // Kill bid and refund value\\n            pendingWithdrawals[msg.sender] += bid.value;\\n            horseBids[tokenId] = Bid(false, tokenId, nullAddress, 0);\\n        }\\n\\n       deductFees( seller, msg.value ); //Transfer funds\\n    }\\n\\n    function enterBidForHorse(uint tokenId) public whenNotPaused whenBiddingActive onlyNonTokenOwner(tokenId) payable {\\n        Bid memory existing = horseBids[tokenId];\\n        require (msg.value \\u003e existing.value, \\\"Bid value cannot be less than or equal to existing value!\\\");\\n\\n        if (existing.value \\u003e 0) {\\n            // Refund the failing bid\\n            pendingWithdrawals[existing.bidder] += existing.value;\\n        }\\n        horseBids[tokenId] = Bid(true, tokenId, msg.sender, msg.value);\\n        emit HorseBidEntered(tokenId, msg.value, msg.sender, uint64(now));\\n    }\\n\\n    function acceptBidForHorse(uint tokenId, uint minPrice) public whenNotPaused whenBiddingActive onlyTokenOwner( tokenId ) {\\n        address seller = msg.sender;\\n        Bid memory bid = horseBids[tokenId];\\n        require( bid.value \\u003e 0 \\u0026\\u0026 bid.value \\u003e= minPrice, \\\"Bid value should be greater than or equal to minPrice!\\\" );\\n\\n        //Transfer horse to new owner\\n        transferFromOffer( seller, bid.bidder, tokenId );\\n\\n        horsesOfferedForSale[tokenId] = Offer(false, tokenId, bid.bidder, 0, nullAddress);\\n        uint amount = bid.value;\\n        horseBids[tokenId] = Bid(false, tokenId, nullAddress, 0);\\n        pendingWithdrawals[seller] += amount;\\n\\n        emit HorseBoughtWithBid(tokenId, bid.value, seller, bid.bidder, uint64(now));\\n\\n        deductFees(seller, amount); //Transfer funds\\n    }\\n\\n    function withdrawBidForHorse(uint tokenId) public whenNotPaused whenBiddingActive onlyNonTokenOwner(tokenId) {\\n        Bid memory bid = horseBids[tokenId];\\n        require( bid.bidder == msg.sender, \\u0027Only Bidders can withdraw their bids!\\u0027 );\\n        emit HorseBidWithdrawn(tokenId, bid.value, msg.sender, uint64(now));\\n        uint amount = bid.value;\\n        horseBids[tokenId] = Bid(false, tokenId, nullAddress, 0);\\n\\n        // Refund the bid money\\n        msg.sender.transfer(amount);\\n    }\\n\\n\\n    function setSuccessFees( uint256 fees ) public onlyCFO {\\n      bidSuccessFees = fees;\\n    }\\n\\n    function calcFees( uint _amount ) internal view returns(uint) {\\n        uint fees = (_amount * bidSuccessFees)/100;\\n        return fees;\\n    }\\n    \\n    function deductFees( address seller, uint amount ) private {\\n        uint fees = calcFees( amount );\\n        if( fees \\u003e 0 ) {\\n            cfoAddress.transfer(fees);\\n            pendingWithdrawals[ seller ] = pendingWithdrawals[ seller ] - fees;\\n        }\\n    }\\n\\n    function withdrawFundsFromBid() public {\\n        uint amount = pendingWithdrawals[msg.sender];\\n        // Remember to zero the pending refund before\\n        // sending to prevent re-entrancy attacks\\n        pendingWithdrawals[msg.sender] = 0;\\n        msg.sender.transfer(amount);\\n    }\\n\\n}\\n\"},\"Context.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\ncontract Context {\\n   constructor () internal { }\\n\\n    function _msgSender() internal view returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view returns (bytes memory) {\\n        this;\\n        return msg.data;\\n    }\\n}\\n\\ninterface IERC165 {\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\\ncontract IERC721 is IERC165 {\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n    function balanceOf(address owner) public view returns (uint256 balance);\\n    function ownerOf(uint256 tokenId) public view returns (address owner);\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\\n    function transferFrom(address from, address to, uint256 tokenId) public;\\n    function approve(address to, uint256 tokenId) public;\\n    function getApproved(uint256 tokenId) public view returns (address operator);\\n    function setApprovalForAll(address operator, bool _approved) public;\\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\\n}\\n\\ncontract IERC721Receiver {\\n\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\\n    public returns (bytes4);\\n}\\n\\nlibrary SafeMath {\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        return c;\\n    }\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\\nlibrary Counters {\\n    using SafeMath for uint256;\\n\\n    struct Counter {\\n        uint256 _value;\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        counter._value += 1;\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        counter._value = counter._value.sub(1);\\n    }\\n}\\n\\ncontract ERC165 is IERC165 {\\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\\n    mapping(bytes4 =\\u003e bool) private _supportedInterfaces;\\n\\n    constructor () internal {\\n    }\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\\n        return _supportedInterfaces[interfaceId];\\n    }\\n    function _registerInterface(bytes4 interfaceId) internal {\\n        require(interfaceId != 0xffffffff, \\\"ERC165: invalid interface id\\\");\\n        _supportedInterfaces[interfaceId] = true;\\n    }\\n}\"},\"CVXBX.sol\":{\"content\":\"pragma solidity ^0.5.0;\\nimport \\\"./BidCVXBX.sol\\\";\\n\\ncontract CVXBX is BidCVXBX {\\n    string public cavaloxCdn = \\\"https://www.cavalox.eu/erc721/\\\";\\n\\n    uint[] public r_stallions;\\n    uint[] public m_stallions;\\n    uint[] public l_stallions;\\n    uint[] public mares;\\n\\n    //Only 39,000 stallions\\n    \\n    //3,000 rarest stallions\\n    uint constant r_TotalStallions = 3000;\\n    uint constant r_StallionPrice = 2000000000000000000; //Representing 2 eth as a starting price\\n    uint constant r_incRarestStallionPerFifty = 11; //Representing = 1.1% increase in price per 50 stallions\\n    \\n    //9,000 mid-rare stallions\\n    uint constant m_TotalStallions = 9000;\\n    uint constant m_StallionPrice = 1250000000000000000; //Representing 1.25 eth as a starting price\\n    uint constant m_incStallionPerFifty = 9; //Representing = 0.9% increase in price per 50 stallions\\n    \\n    //27,000 low-rare\\n    uint constant l_TotalStallions = 27000;\\n    uint constant l_stallionPrice = 500000000000000000; //Representing 0.5 eth as a starting price\\n    uint constant l_incStallionPerFifty = 7; //Representing = 0.7% increase in price per 50 stallions\\n\\n    //Only 9,000 mares\\n    uint constant totalMares = 9000;\\n    uint constant marePrice = 1000000000000000000; //Representing 1eth eth as a starting price\\n    uint constant incMarePerFifty = 10; //Representing = 1% increase in price per 50 mares\\n    \\n    /// @dev The main Horse struct. Every horse in Cavalox is represented by a copy\\n    ///  of this structure, so great care was taken to ensure that it fits neatly into\\n    ///  exactly two 256-bit words. Note that the order of the members in this structure\\n    ///  is important because of the byte-packing rules used by Ethereum.\\n    ///  Ref: http://solidity.readthedocs.io/en/develop/miscellaneous.html\\n    struct Horse {\\n        //TokenUri of the Horse\\n        string tokenUri;\\n\\n        // The timestamp from the block when this horse came into existence.\\n        uint64 birthTime;\\n\\n        // Type of horse, stallion or mare\\n        string typeOfHorse;\\n        \\n        // SubType of horse, stallion or mare\\n        uint64 subType;\\n        \\n        // Gene of horse\\n        uint gene;\\n    }\\n    \\n    Horse[] public horses;\\n    \\n    constructor() ERC721Full(\\\"CVXBX\\\", \\\"ℂℽ\\\") public {}\\n    \\n    modifier validRareIndex( uint64 rarityIndex ) {\\n        require( rarityIndex == 1 || rarityIndex == 2 || rarityIndex == 3 );\\n        _;\\n    } \\n    \\n    modifier checkMareCount() {\\n        uint256 nextMare = getMintedMares().add(1);\\n        require( nextMare \\u003c= totalMares, \\\"Cannot mint more than 9000 mares!\\\");\\n        _;\\n    }\\n    \\n    modifier checkStallionCount( uint64 rarityIndex ) {\\n        uint256 nextStallion = getMintedStallions( rarityIndex ).add(1);\\n        uint256 totalStallions = getTotalStallions( rarityIndex );\\n        \\n        require( nextStallion \\u003c= totalStallions, \\\"Cannot mint more than available stallions!\\\");\\n        _;\\n    }\\n\\n    /// @notice No tipping!\\n    /// @dev Reject all Ether from being sent here\\n    function() external payable {\\n    }\\n    \\n    function geneSequencer() private view returns(uint) {\\n        uint time = uint(now);\\n        uint sequence1 = block.difficulty.add(block.number);\\n        uint sequence2 = time;\\n        uint sequence = sequence1.add(sequence2);\\n        \\n        return sequence;\\n    }\\n\\n    function mintHorse( string memory typeOfHorse, address owner, uint64 rarityIndex ) internal returns(uint256) {\\n        string memory tokenUri = \\u0027\\u0027;\\n        \\n        if( keccak256(bytes( typeOfHorse )) == keccak256(bytes(\\u0027stallion\\u0027)) ) {\\n            if( rarityIndex == 1 ) {\\n                tokenUri =  strConcat( cavaloxCdn, \\u0027horse/r_stallion.png\\u0027 );\\n            } else if( rarityIndex == 2 ) {\\n                tokenUri =  strConcat( cavaloxCdn, \\u0027horse/m_stallion.png\\u0027 );\\n            } else if( rarityIndex == 3 ) {\\n                tokenUri =  strConcat( cavaloxCdn, \\u0027horse/l_stallion.png\\u0027 );\\n            }\\n        } else {\\n            tokenUri = tokenUri =  strConcat( cavaloxCdn, \\u0027horse/mare.png\\u0027 );\\n        }\\n        \\n        uint gene = geneSequencer();\\n\\n        Horse memory _horse = Horse({\\n            tokenUri: tokenUri,\\n            birthTime: uint64(now),\\n            typeOfHorse: typeOfHorse,\\n            subType: rarityIndex,\\n            gene: gene\\n        });\\n\\n        uint256 _id = horses.push(_horse);\\n\\n       horseTypes[_id] = typeOfHorse;\\n       horseSubTypes[_id] = rarityIndex;\\n       tokenUriMapping[_id] = tokenUri;\\n        _mint(owner, _id);\\n        return _id;\\n    }\\n    \\n    function strConcat(string memory _a, string memory _b) internal pure returns (string memory){\\n        bytes memory _ba = bytes(_a);\\n        bytes memory _bb = bytes(_b);\\n        \\n        string memory abcde = new string(_ba.length + _bb.length);\\n        bytes memory babcde = bytes(abcde);\\n        uint k = 0;\\n        uint i = 0;\\n        for ( i = 0; i \\u003c _ba.length; i++) babcde[k++] = _ba[i];\\n        for (i = 0; i \\u003c _bb.length; i++) babcde[k++] = _bb[i];\\n        return string(babcde);\\n    }\\n    \\n    function mintStallionInternally( address owner, uint64 rarityIndex ) internal {\\n        uint256 _id = mintHorse( \\u0027stallion\\u0027, owner, rarityIndex );\\n        if( rarityIndex == 1 ) {\\n            r_stallions.push(_id);\\n        } else if( rarityIndex == 2 ) {\\n            m_stallions.push(_id);\\n        } else if( rarityIndex == 3 ) {\\n            l_stallions.push(_id);\\n        }\\n    }\\n\\n    function mintStallion( uint64 rarityIndex ) public whenNotPaused validRareIndex( rarityIndex ) checkStallionCount( rarityIndex ) payable {\\n        uint256 currentStallionPrice = getStallionPrice( rarityIndex );\\n        require(msg.value == currentStallionPrice, \\\"Price of stallion not correct!\\\");\\n\\n        mintStallionInternally( msg.sender, rarityIndex );\\n        uint256 balance = address(this).balance;\\n        cfoAddress.transfer(balance);\\n    }\\n    \\n    function getTotalStallions( uint64 rarityIndex ) public pure returns(uint256) {\\n        uint256 totalStallions = 0;\\n        \\n        if( rarityIndex == 1 ) {\\n            totalStallions = r_TotalStallions;\\n        } else if( rarityIndex == 2 ) {\\n            totalStallions = m_TotalStallions;\\n        } else if( rarityIndex == 3 ) {\\n            totalStallions = l_TotalStallions;\\n        }\\n        \\n        return totalStallions;\\n    }\\n    \\n    function mintMareInternally( address owner ) internal {\\n        uint256 _id = mintHorse(\\u0027mare\\u0027, owner, 0 );\\n        mares.push(_id);\\n    }\\n\\n    function mintMare() public checkMareCount whenNotPaused payable {\\n        uint256 currentMarePrice = getMarePrice();\\n        require(msg.value == currentMarePrice, \\\"Price of mare not correct!\\\");\\n\\n        mintMareInternally( msg.sender );\\n        uint256 balance = address(this).balance;\\n        cfoAddress.transfer(balance);\\n    }\\n    \\n    function getGene(uint n) public view returns ( uint ) {\\n        return ( horses[n].gene );\\n    }\\n\\n    function getMintedStallions( uint64 rarityIndex ) public view validRareIndex( rarityIndex ) returns (uint256) {\\n        uint256 stallionsLength = 0;\\n        if( rarityIndex == 1 ) {\\n            stallionsLength = r_stallions.length;\\n        } else if( rarityIndex == 2 ) {\\n            stallionsLength = m_stallions.length;\\n        } else if( rarityIndex == 3 ) {\\n            stallionsLength = l_stallions.length;\\n        }\\n        return stallionsLength;\\n    }\\n\\n    function getMintedMares() public view returns (uint256) {\\n        return mares.length;\\n    }\\n    \\n    function getIndividualStallionPrice( uint64 rarityIndex ) public pure returns(uint256) {\\n        uint256 priceStallions = 0;\\n        \\n        if( rarityIndex == 1 ) {\\n            priceStallions = r_StallionPrice;\\n        } else if( rarityIndex == 2 ) {\\n            priceStallions = m_StallionPrice;\\n        } else if( rarityIndex == 3 ) {\\n            priceStallions = l_stallionPrice;\\n        }\\n        \\n        require( priceStallions \\u003e 0, \\u0027Invalid rarityIndex\\u0027 );\\n        return priceStallions;\\n    }\\n    \\n    function getIncStallionPerFifty( uint64 rarityIndex ) public pure returns(uint256) {\\n        uint256 incStallionPerFifty = 0;\\n        \\n        if( rarityIndex == 1 ) {\\n            incStallionPerFifty = r_incRarestStallionPerFifty;\\n        } else if( rarityIndex == 2 ) {\\n            incStallionPerFifty = m_incStallionPerFifty;\\n        } else if( rarityIndex == 3 ) {\\n            incStallionPerFifty = l_incStallionPerFifty;\\n        }\\n        \\n        require( incStallionPerFifty \\u003e 0, \\u0027Invalid rarityIndex\\u0027 );\\n        return incStallionPerFifty;\\n    }\\n\\n    function getStallionPrice( uint64 rarityIndex ) public view returns (uint256) {\\n        uint256 mintedStallions = getMintedStallions( rarityIndex ).add(1);\\n        uint256 stallionPrice = getIndividualStallionPrice( rarityIndex );\\n        uint256 incStallionPerFifty = getIncStallionPerFifty( rarityIndex );\\n        \\n        uint256 price = stallionPrice + ((stallionPrice * incStallionPerFifty)/1000) * (mintedStallions/50);\\n        return ( price );\\n    }\\n\\n    function getMarePrice() public view returns (uint256) {\\n        uint256 mintedMares = getMintedMares().add(1);\\n        uint256 price = marePrice + ((marePrice * incMarePerFifty)/1000) * (mintedMares/50);\\n        return ( price );\\n    }\\n\\n    function mFreeStallion(address owner, uint64 rarityIndex) public whenNotPaused onlyCLevel validRareIndex( rarityIndex ) checkStallionCount( rarityIndex ) {\\n        mintStallionInternally( owner, rarityIndex );\\n    }\\n    \\n    function mFreeMare(address owner) public onlyCLevel checkMareCount {\\n        mintMareInternally( owner );\\n    }\\n\\n    function setCavaloxCdn(string memory cdn) public onlyCEO {\\n        cavaloxCdn = cdn;\\n    }\\n}\\n\"},\"ERC721Full.sol\":{\"content\":\"pragma solidity ^0.5.0;\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./Context.sol\\\";\\nimport \\\"./Pausable.sol\\\";\\n\\ncontract ERC721 is Context, ERC165, IERC721, Pausable {\\n    using SafeMath for uint256;\\n    using Counters for Counters.Counter;\\n    \\n    event HorseBought(address indexed owner, uint256 indexed tokenId, string horseType, uint64 horseSubType, uint64 birthTime, string tokenUri );\\n    event HorseTransferred(address indexed from, address indexed to, uint256 indexed tokenId, string horseType, uint64 horseSubType, uint64 birthTime, string tokenUri );\\n    \\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\\n    mapping (uint256 =\\u003e address) private _tokenOwner;\\n    mapping (uint256 =\\u003e address) private _tokenApprovals;\\n    mapping (address =\\u003e Counters.Counter) private _ownedTokensCount;\\n    mapping (address =\\u003e mapping (address =\\u003e bool)) private _operatorApprovals;\\n\\n    mapping(address =\\u003e Counters.Counter) public r_stallionsCount;\\n    mapping(address =\\u003e Counters.Counter) public m_stallionsCount;\\n    mapping(address =\\u003e Counters.Counter) public l_stallionsCount;\\n    mapping(address =\\u003e Counters.Counter) public maresCount;\\n    mapping(uint256 =\\u003e string) public tokenUriMapping;\\n   \\n    mapping(uint256 =\\u003e string) public horseTypes;\\n    mapping(uint256 =\\u003e uint64) public horseSubTypes;\\n    \\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\\n\\n    constructor () public {\\n        _registerInterface(_INTERFACE_ID_ERC721);\\n    }\\n    function balanceOf(address owner) public view returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n\\n        return _ownedTokensCount[owner].current();\\n    }\\n    function ownerOf(uint256 tokenId) public view returns (address) {\\n        address owner = _tokenOwner[tokenId];\\n        require(owner != address(0), \\\"ERC721: owner query for nonexistent token\\\");\\n\\n        return owner;\\n    }\\n    function approve(address to, uint256 tokenId) public whenNotPaused {\\n        address owner = ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n        );\\n\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(owner, to, tokenId);\\n    }\\n    function getApproved(uint256 tokenId) public view returns (address) {\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n    function setApprovalForAll(address to, bool approved) public whenNotPaused {\\n        require(to != _msgSender(), \\\"ERC721: approve to caller\\\");\\n\\n        _operatorApprovals[_msgSender()][to] = approved;\\n        emit ApprovalForAll(_msgSender(), to, approved);\\n    }\\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n    function transferFrom(address from, address to, uint256 tokenId) public whenNotPaused {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\n        _transferFrom(from, to, tokenId);\\n    }\\n    \\n    function transferFromOffer(address from, address to, uint256 tokenId) internal whenNotPaused {\\n        _transferFrom(from, to, tokenId);\\n    }\\n    \\n    function safeTransferFrom(address from, address to, uint256 tokenId) public whenNotPaused {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public whenNotPaused {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        _safeTransferFrom(from, to, tokenId, _data);\\n    }\\n    function _safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) internal {\\n        _transferFrom(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n    function _exists(uint256 tokenId) internal view returns (bool) {\\n        address owner = _tokenOwner[tokenId];\\n        return owner != address(0);\\n    }\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\n        address owner = ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\n    }\\n    function _safeMint(address to, uint256 tokenId) internal {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal {\\n        _mint(to, tokenId);\\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n    function _mint(address to, uint256 tokenId) internal {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _tokenOwner[tokenId] = to;\\n        _ownedTokensCount[to].increment();\\n\\n        if( keccak256(bytes(horseTypes[tokenId])) == keccak256(bytes(\\u0027stallion\\u0027)) ) {\\n            if( horseSubTypes[tokenId] == 1 ) {\\n                r_stallionsCount[to].increment();\\n            } else if( horseSubTypes[tokenId] == 2 ) {\\n                m_stallionsCount[to].increment();\\n            } else if( horseSubTypes[tokenId] == 3 ) {\\n                l_stallionsCount[to].increment();\\n            }\\n          emit HorseBought( to, tokenId, \\u0027stallion\\u0027, horseSubTypes[tokenId], uint64(now), tokenUriMapping[tokenId] );\\n        } else {\\n          maresCount[to].increment();\\n          emit HorseBought( to, tokenId, \\u0027mare\\u0027, 0, uint64(now), tokenUriMapping[tokenId] );\\n        }\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\\n        require(ownerOf(tokenId) == from, \\\"ERC721: transfer of token that is not own\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _clearApproval(tokenId);\\n\\n        _ownedTokensCount[from].decrement();\\n        _ownedTokensCount[to].increment();\\n\\n        _tokenOwner[tokenId] = to;\\n\\n        if( keccak256(bytes(horseTypes[tokenId])) == keccak256(bytes(\\u0027stallion\\u0027)) ) {\\n          if( horseSubTypes[tokenId] == 1 ) {\\n              r_stallionsCount[from].decrement();\\n              r_stallionsCount[to].increment();\\n           } else if( horseSubTypes[tokenId] == 2 ) {\\n              m_stallionsCount[from].decrement();\\n              m_stallionsCount[to].increment();\\n           } else if( horseSubTypes[tokenId] == 3 ) {\\n              l_stallionsCount[from].decrement();\\n              l_stallionsCount[to].increment();\\n           }\\n          \\n          emit HorseTransferred( from, to, tokenId, \\u0027stallion\\u0027, horseSubTypes[tokenId], uint64(now), tokenUriMapping[tokenId] );\\n          \\n        } else {\\n          maresCount[from].decrement();\\n          maresCount[to].increment();\\n          \\n          emit HorseTransferred( from, to, tokenId, \\u0027mare\\u0027, 0, uint64(now), tokenUriMapping[tokenId] );\\n        }\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    function isContract(address account) internal view returns (bool) {\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != accountHash \\u0026\\u0026 codehash != 0x0);\\n    }\\n\\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\\n        internal returns (bool) {\\n        if ( isContract(to) ) {\\n            return true;\\n        }\\n        (bool success, bytes memory returndata) = to.call(abi.encodeWithSelector(\\n            IERC721Receiver(to).onERC721Received.selector,\\n            _msgSender(),\\n            from,\\n            tokenId,\\n            _data\\n        ));\\n        if (!success) {\\n            if (returndata.length \\u003e 0) {\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n            }\\n        } else {\\n            bytes4 retval = abi.decode(returndata, (bytes4));\\n            return (retval == _ERC721_RECEIVED);\\n        }\\n    }\\n    function _clearApproval(uint256 tokenId) private {\\n        if (_tokenApprovals[tokenId] != address(0)) {\\n            _tokenApprovals[tokenId] = address(0);\\n        }\\n    }\\n}\\ncontract IERC721Enumerable is IERC721 {\\n    function totalSupply() public view returns (uint256);\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256 tokenId);\\n\\n    function tokenByIndex(uint256 index) public view returns (uint256);\\n}\\ncontract ERC721Enumerable is Context, ERC165, ERC721, IERC721Enumerable {\\n    mapping(address =\\u003e uint256[]) private _ownedTokens;\\n    mapping(uint256 =\\u003e uint256) private _ownedTokensIndex;\\n    uint256[] private _allTokens;\\n    mapping(uint256 =\\u003e uint256) private _allTokensIndex;\\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\\n    constructor () public {\\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\\n    }\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\\n        require(index \\u003c balanceOf(owner), \\\"ERC721Enumerable: owner index out of bounds\\\");\\n        return _ownedTokens[owner][index];\\n    }\\n    function totalSupply() public view returns (uint256) {\\n        return _allTokens.length;\\n    }\\n    function tokenByIndex(uint256 index) public view returns (uint256) {\\n        require(index \\u003c totalSupply(), \\\"ERC721Enumerable: global index out of bounds\\\");\\n        return _allTokens[index];\\n    }\\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\\n        super._transferFrom(from, to, tokenId);\\n\\n        _removeTokenFromOwnerEnumeration(from, tokenId);\\n\\n        _addTokenToOwnerEnumeration(to, tokenId);\\n    }\\n    function _mint(address to, uint256 tokenId) internal {\\n        super._mint(to, tokenId);\\n\\n        _addTokenToOwnerEnumeration(to, tokenId);\\n\\n        _addTokenToAllTokensEnumeration(tokenId);\\n    }\\n\\n    function _tokensOfOwner(address owner) internal view returns (uint256[] storage) {\\n        return _ownedTokens[owner];\\n    }\\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\\n        _ownedTokensIndex[tokenId] = _ownedTokens[to].length;\\n        _ownedTokens[to].push(tokenId);\\n    }\\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\\n        _allTokensIndex[tokenId] = _allTokens.length;\\n        _allTokens.push(tokenId);\\n    }\\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\\n        uint256 lastTokenIndex = _ownedTokens[from].length.sub(1);\\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\\n        if (tokenIndex != lastTokenIndex) {\\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\\n\\n            _ownedTokens[from][tokenIndex] = lastTokenId;\\n            _ownedTokensIndex[lastTokenId] = tokenIndex;\\n        }\\n        _ownedTokens[from].length--;\\n    }\\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\\n        uint256 lastTokenIndex = _allTokens.length.sub(1);\\n        uint256 tokenIndex = _allTokensIndex[tokenId];\\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\\n\\n        _allTokens[tokenIndex] = lastTokenId;\\n        _allTokensIndex[lastTokenId] = tokenIndex;\\n        _allTokens.length--;\\n        _allTokensIndex[tokenId] = 0;\\n    }\\n}\\n\\n\\ncontract IERC721Metadata is IERC721 {\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\\ncontract ERC721Metadata is Context, ERC165, ERC721, IERC721Metadata {\\n    string private _name;\\n    string private _symbol;\\n    string private _baseURI;\\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\\n    \\n    constructor (string memory name, string memory symbol) public {\\n        _name = name;\\n        _symbol = symbol;\\n\\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\\n    }\\n\\n    function name() external view returns (string memory) {\\n        return _name;\\n    }\\n    function symbol() external view returns (string memory) {\\n        return _symbol;\\n    }\\n    function tokenURI(uint256 tokenId) external view returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\n        string memory _tokenURI = tokenUriMapping[tokenId];\\n        if (bytes(_tokenURI).length == 0) {\\n            return \\\"\\\";\\n        } else {\\n            return string(abi.encodePacked(_baseURI, _tokenURI));\\n        }\\n    }\\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI set of nonexistent token\\\");\\n        tokenUriMapping[tokenId] = _tokenURI;\\n    }\\n    function _setBaseURI(string memory baseURI) internal {\\n        _baseURI = baseURI;\\n    }\\n    function baseURI() external view returns (string memory) {\\n        return _baseURI;\\n    }\\n}\\ncontract ERC721Full is ERC721, ERC721Enumerable, ERC721Metadata {\\n    constructor (string memory name, string memory symbol) public ERC721Metadata(name, symbol) {\\n        // solhint-disable-previous-line no-empty-blocks\\n    }\\n}\\n\"},\"Migrations.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.4.22 \\u003c0.9.0;\\n\\ncontract Migrations {\\n  address public owner = msg.sender;\\n  uint public last_completed_migration;\\n\\n  modifier restricted() {\\n    require(\\n      msg.sender == owner,\\n      \\\"This function is restricted to the contract\\u0027s owner\\\"\\n    );\\n    _;\\n  }\\n\\n  function setCompleted(uint completed) public restricted {\\n    last_completed_migration = completed;\\n  }\\n}\\n\"},\"Ownable.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Ownable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () public {\\n        address msgSender = msg.sender;\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _owner, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n}\\n\"},\"Pausable.sol\":{\"content\":\"import \\\"./Ownable.sol\\\";\\n\\npragma solidity ^0.5.0;\\n\\n/**\\n * @title Pausable\\n * @dev Base contract which allows children to implement an emergency stop mechanism.\\n */\\ncontract Pausable is Ownable {\\n  event Pause( uint64 timestamp );\\n  event Unpause( uint64 timestamp );\\n\\n  bool public paused = false;\\n\\n\\n  /**\\n   * @dev modifier to allow actions only when the contract IS paused\\n   */\\n  modifier whenNotPaused() {\\n    require(!paused, \\u0027CVXBX is currently paused!\\u0027);\\n    _;\\n  }\\n\\n  /**\\n   * @dev modifier to allow actions only when the contract IS NOT paused\\n   */\\n  modifier whenPaused {\\n    require(paused, \\u0027CVXBX is not paused!\\u0027);\\n    _;\\n  }\\n\\n  /**\\n   * @dev called by the owner to pause, triggers stopped state\\n   */\\n  function pause() public onlyOwner whenNotPaused returns (bool) {\\n    paused = true;\\n    emit Pause( uint64(now) );\\n    return true;\\n  }\\n\\n  /**\\n   * @dev called by the owner to unpause, returns to normal state\\n   */\\n  function unpause() public onlyOwner whenPaused returns (bool) {\\n    paused = false;\\n    emit Unpause( uint64(now) );\\n    return true;\\n  }\\n}\\n\"}}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"date\",\"type\":\"uint64\"}],\"name\":\"BiddingPaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"date\",\"type\":\"uint64\"}],\"name\":\"BiddingUnPaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fromAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"time\",\"type\":\"uint64\"}],\"name\":\"HorseBidEntered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fromAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"time\",\"type\":\"uint64\"}],\"name\":\"HorseBidWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"horseType\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"horseSubType\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"birthTime\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"tokenUri\",\"type\":\"string\"}],\"name\":\"HorseBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fromAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"time\",\"type\":\"uint64\"}],\"name\":\"HorseBoughtWithBid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fromAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"time\",\"type\":\"uint64\"}],\"name\":\"HorseBoughtWithOffer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"time\",\"type\":\"uint64\"}],\"name\":\"HorseNoLongerForSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"time\",\"type\":\"uint64\"}],\"name\":\"HorseOffered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"horseType\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"horseSubType\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"birthTime\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"tokenUri\",\"type\":\"string\"}],\"name\":\"HorseTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"}],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"}],\"name\":\"Unpause\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minPrice\",\"type\":\"uint256\"}],\"name\":\"acceptBidForHorse\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bidSuccessFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bidding\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"buyHorseFromOffer\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cavaloxCdn\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ceoAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cfoAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cooAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"enterBidForHorse\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"getGene\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"rarityIndex\",\"type\":\"uint64\"}],\"name\":\"getIncStallionPerFifty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"rarityIndex\",\"type\":\"uint64\"}],\"name\":\"getIndividualStallionPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMarePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMintedMares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"rarityIndex\",\"type\":\"uint64\"}],\"name\":\"getMintedStallions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"rarityIndex\",\"type\":\"uint64\"}],\"name\":\"getStallionPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"rarityIndex\",\"type\":\"uint64\"}],\"name\":\"getTotalStallions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"horseBids\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"hasBid\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"horseNoLongerForSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"horseSubTypes\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"horseTypes\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"horses\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"tokenUri\",\"type\":\"string\"},{\"internalType\":\"uint64\",\"name\":\"birthTime\",\"type\":\"uint64\"},{\"internalType\":\"string\",\"name\":\"typeOfHorse\",\"type\":\"string\"},{\"internalType\":\"uint64\",\"name\":\"subType\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"gene\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"horsesOfferedForSale\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isForSale\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minValue\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"onlySellTo\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"l_stallions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"l_stallionsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"mFreeMare\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"rarityIndex\",\"type\":\"uint64\"}],\"name\":\"mFreeStallion\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"m_stallions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"m_stallionsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"maresCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"mintMare\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"rarityIndex\",\"type\":\"uint64\"}],\"name\":\"mintStallion\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minSalePriceInWei\",\"type\":\"uint256\"}],\"name\":\"offerHorseForSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minSalePriceInWei\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"}],\"name\":\"offerHorseForSaleToAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pauseBidding\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pendingWithdrawals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"r_stallions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"r_stallionsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newCEO\",\"type\":\"address\"}],\"name\":\"setCEO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newCFO\",\"type\":\"address\"}],\"name\":\"setCFO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newCOO\",\"type\":\"address\"}],\"name\":\"setCOO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"cdn\",\"type\":\"string\"}],\"name\":\"setCavaloxCdn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fees\",\"type\":\"uint256\"}],\"name\":\"setSuccessFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenUriMapping\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpauseBidding\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"withdrawBidForHorse\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawFundsFromBid\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CVXBX","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://0ece1919882bd46a8d1d1e1dc65222cb23a3d11cca480490dac7a3cae5a2aa29"}]}