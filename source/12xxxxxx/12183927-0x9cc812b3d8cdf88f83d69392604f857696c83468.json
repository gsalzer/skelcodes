{"status":"1","message":"OK","result":[{"SourceCode":"// File: node_modules\\@openzeppelin\\contracts\\introspection\\IERC165.sol\r\n\r\n    // SPDX-License-Identifier: MIT\r\n\r\n    pragma solidity >=0.6.0 <0.8.0;\r\n\r\n    /**\r\n    * @dev Interface of the ERC165 standard, as defined in the\r\n    * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n    *\r\n    * Implementers can declare support of contract interfaces, which can then be\r\n    * queried by others ({ERC165Checker}).\r\n    *\r\n    * For an implementation, see {ERC165}.\r\n    */\r\n    interface IERC165 {\r\n        /**\r\n        * @dev Returns true if this contract implements the interface defined by\r\n        * `interfaceId`. See the corresponding\r\n        * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n        * to learn more about how these ids are created.\r\n        *\r\n        * This function call must use less than 30 000 gas.\r\n        */\r\n        function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n    }\r\n\r\n    // File: node_modules\\@openzeppelin\\contracts\\token\\ERC1155\\IERC1155.sol\r\n\r\n\r\n    pragma solidity >=0.6.2 <0.8.0;\r\n\r\n\r\n    /**\r\n    * @dev Required interface of an ERC1155 compliant contract, as defined in the\r\n    * https://eips.ethereum.org/EIPS/eip-1155[EIP].\r\n    *\r\n    * _Available since v3.1._\r\n    */\r\n    interface IERC1155 is IERC165 {\r\n        /**\r\n        * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\r\n        */\r\n        event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n\r\n        /**\r\n        * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\r\n        * transfers.\r\n        */\r\n        event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\r\n\r\n        /**\r\n        * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\r\n        * `approved`.\r\n        */\r\n        event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n\r\n        /**\r\n        * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\r\n        *\r\n        * If an {URI} event was emitted for `id`, the standard\r\n        * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\r\n        * returned by {IERC1155MetadataURI-uri}.\r\n        */\r\n        event URI(string value, uint256 indexed id);\r\n\r\n        /**\r\n        * @dev Returns the amount of tokens of token type `id` owned by `account`.\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - `account` cannot be the zero address.\r\n        */\r\n        function balanceOf(address account, uint256 id) external view returns (uint256);\r\n\r\n        /**\r\n        * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - `accounts` and `ids` must have the same length.\r\n        */\r\n        function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\r\n\r\n        /**\r\n        * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\r\n        *\r\n        * Emits an {ApprovalForAll} event.\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - `operator` cannot be the caller.\r\n        */\r\n        function setApprovalForAll(address operator, bool approved) external;\r\n\r\n        /**\r\n        * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\r\n        *\r\n        * See {setApprovalForAll}.\r\n        */\r\n        function isApprovedForAll(address account, address operator) external view returns (bool);\r\n\r\n        /**\r\n        * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\r\n        *\r\n        * Emits a {TransferSingle} event.\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - `to` cannot be the zero address.\r\n        * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\r\n        * - `from` must have a balance of tokens of type `id` of at least `amount`.\r\n        * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n        * acceptance magic value.\r\n        */\r\n        function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\r\n\r\n        /**\r\n        * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\r\n        *\r\n        * Emits a {TransferBatch} event.\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - `ids` and `amounts` must have the same length.\r\n        * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n        * acceptance magic value.\r\n        */\r\n        function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\r\n    }\r\n\r\n    // File: node_modules\\@openzeppelin\\contracts\\token\\ERC1155\\IERC1155MetadataURI.sol\r\n\r\n\r\n    pragma solidity >=0.6.2 <0.8.0;\r\n\r\n\r\n    /**\r\n    * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\r\n    * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\r\n    *\r\n    * _Available since v3.1._\r\n    */\r\n    interface IERC1155MetadataURI is IERC1155 {\r\n        /**\r\n        * @dev Returns the URI for token type `id`.\r\n        *\r\n        * If the `\\{id\\}` substring is present in the URI, it must be replaced by\r\n        * clients with the actual token type ID.\r\n        */\r\n        function uri(uint256 id) external view returns (string memory);\r\n    }\r\n\r\n    // File: node_modules\\@openzeppelin\\contracts\\token\\ERC1155\\IERC1155Receiver.sol\r\n\r\n\r\n    pragma solidity >=0.6.0 <0.8.0;\r\n\r\n\r\n    /**\r\n    * _Available since v3.1._\r\n    */\r\n    interface IERC1155Receiver is IERC165 {\r\n\r\n        /**\r\n            @dev Handles the receipt of a single ERC1155 token type. This function is\r\n            called at the end of a `safeTransferFrom` after the balance has been updated.\r\n            To accept the transfer, this must return\r\n            `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n            (i.e. 0xf23a6e61, or its own function selector).\r\n            @param operator The address which initiated the transfer (i.e. msg.sender)\r\n            @param from The address which previously owned the token\r\n            @param id The ID of the token being transferred\r\n            @param value The amount of tokens being transferred\r\n            @param data Additional data with no specified format\r\n            @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\r\n        */\r\n        function onERC1155Received(\r\n            address operator,\r\n            address from,\r\n            uint256 id,\r\n            uint256 value,\r\n            bytes calldata data\r\n        )\r\n            external\r\n            returns(bytes4);\r\n\r\n        /**\r\n            @dev Handles the receipt of a multiple ERC1155 token types. This function\r\n            is called at the end of a `safeBatchTransferFrom` after the balances have\r\n            been updated. To accept the transfer(s), this must return\r\n            `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n            (i.e. 0xbc197c81, or its own function selector).\r\n            @param operator The address which initiated the batch transfer (i.e. msg.sender)\r\n            @param from The address which previously owned the token\r\n            @param ids An array containing ids of each token being transferred (order and length must match values array)\r\n            @param values An array containing amounts of each token being transferred (order and length must match ids array)\r\n            @param data Additional data with no specified format\r\n            @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\r\n        */\r\n        function onERC1155BatchReceived(\r\n            address operator,\r\n            address from,\r\n            uint256[] calldata ids,\r\n            uint256[] calldata values,\r\n            bytes calldata data\r\n        )\r\n            external\r\n            returns(bytes4);\r\n    }\r\n\r\n    // File: node_modules\\@openzeppelin\\contracts\\utils\\Context.sol\r\n\r\n\r\n    pragma solidity >=0.6.0 <0.8.0;\r\n\r\n    /*\r\n    * @dev Provides information about the current execution context, including the\r\n    * sender of the transaction and its data. While these are generally available\r\n    * via msg.sender and msg.data, they should not be accessed in such a direct\r\n    * manner, since when dealing with GSN meta-transactions the account sending and\r\n    * paying for execution may not be the actual sender (as far as an application\r\n    * is concerned).\r\n    *\r\n    * This contract is only required for intermediate, library-like contracts.\r\n    */\r\n    abstract contract Context {\r\n        function _msgSender() internal view virtual returns (address payable) {\r\n            return msg.sender;\r\n        }\r\n\r\n        function _msgData() internal view virtual returns (bytes memory) {\r\n            this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n            return msg.data;\r\n        }\r\n    }\r\n\r\n    // File: node_modules\\@openzeppelin\\contracts\\introspection\\ERC165.sol\r\n\r\n\r\n    pragma solidity >=0.6.0 <0.8.0;\r\n\r\n\r\n    /**\r\n    * @dev Implementation of the {IERC165} interface.\r\n    *\r\n    * Contracts may inherit from this and call {_registerInterface} to declare\r\n    * their support of an interface.\r\n    */\r\n    abstract contract ERC165 is IERC165 {\r\n        /*\r\n        * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\r\n        */\r\n        bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n\r\n        /**\r\n        * @dev Mapping of interface ids to whether or not it's supported.\r\n        */\r\n        mapping(bytes4 => bool) private _supportedInterfaces;\r\n\r\n        constructor () internal {\r\n            // Derived contracts need only register support for their own interfaces,\r\n            // we register support for ERC165 itself here\r\n            _registerInterface(_INTERFACE_ID_ERC165);\r\n        }\r\n\r\n        /**\r\n        * @dev See {IERC165-supportsInterface}.\r\n        *\r\n        * Time complexity O(1), guaranteed to always use less than 30 000 gas.\r\n        */\r\n        function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n            return _supportedInterfaces[interfaceId];\r\n        }\r\n\r\n        /**\r\n        * @dev Registers the contract as an implementer of the interface defined by\r\n        * `interfaceId`. Support of the actual ERC165 interface is automatic and\r\n        * registering its interface id is not required.\r\n        *\r\n        * See {IERC165-supportsInterface}.\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\r\n        */\r\n        function _registerInterface(bytes4 interfaceId) internal virtual {\r\n            require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\r\n            _supportedInterfaces[interfaceId] = true;\r\n        }\r\n    }\r\n\r\n    // File: node_modules\\@openzeppelin\\contracts\\math\\SafeMath.sol\r\n\r\n\r\n    pragma solidity >=0.6.0 <0.8.0;\r\n\r\n    /**\r\n    * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n    * checks.\r\n    *\r\n    * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n    * in bugs, because programmers usually assume that an overflow raises an\r\n    * error, which is the standard behavior in high level programming languages.\r\n    * `SafeMath` restores this intuition by reverting the transaction when an\r\n    * operation overflows.\r\n    *\r\n    * Using this library instead of the unchecked operations eliminates an entire\r\n    * class of bugs, so it's recommended to use it always.\r\n    */\r\n    library SafeMath {\r\n        /**\r\n        * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n        *\r\n        * _Available since v3.4._\r\n        */\r\n        function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n\r\n        /**\r\n        * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n        *\r\n        * _Available since v3.4._\r\n        */\r\n        function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n\r\n        /**\r\n        * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n        *\r\n        * _Available since v3.4._\r\n        */\r\n        function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n\r\n        /**\r\n        * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n        *\r\n        * _Available since v3.4._\r\n        */\r\n        function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n\r\n        /**\r\n        * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n        *\r\n        * _Available since v3.4._\r\n        */\r\n        function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n\r\n        /**\r\n        * @dev Returns the addition of two unsigned integers, reverting on\r\n        * overflow.\r\n        *\r\n        * Counterpart to Solidity's `+` operator.\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - Addition cannot overflow.\r\n        */\r\n        function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n            uint256 c = a + b;\r\n            require(c >= a, \"SafeMath: addition overflow\");\r\n            return c;\r\n        }\r\n\r\n        /**\r\n        * @dev Returns the subtraction of two unsigned integers, reverting on\r\n        * overflow (when the result is negative).\r\n        *\r\n        * Counterpart to Solidity's `-` operator.\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - Subtraction cannot overflow.\r\n        */\r\n        function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n            require(b <= a, \"SafeMath: subtraction overflow\");\r\n            return a - b;\r\n        }\r\n\r\n        /**\r\n        * @dev Returns the multiplication of two unsigned integers, reverting on\r\n        * overflow.\r\n        *\r\n        * Counterpart to Solidity's `*` operator.\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - Multiplication cannot overflow.\r\n        */\r\n        function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n            if (a == 0) return 0;\r\n            uint256 c = a * b;\r\n            require(c / a == b, \"SafeMath: multiplication overflow\");\r\n            return c;\r\n        }\r\n\r\n        /**\r\n        * @dev Returns the integer division of two unsigned integers, reverting on\r\n        * division by zero. The result is rounded towards zero.\r\n        *\r\n        * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n        * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n        * uses an invalid opcode to revert (consuming all remaining gas).\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - The divisor cannot be zero.\r\n        */\r\n        function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n            require(b > 0, \"SafeMath: division by zero\");\r\n            return a / b;\r\n        }\r\n\r\n        /**\r\n        * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n        * reverting when dividing by zero.\r\n        *\r\n        * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n        * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n        * invalid opcode to revert (consuming all remaining gas).\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - The divisor cannot be zero.\r\n        */\r\n        function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n            require(b > 0, \"SafeMath: modulo by zero\");\r\n            return a % b;\r\n        }\r\n\r\n        /**\r\n        * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n        * overflow (when the result is negative).\r\n        *\r\n        * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n        * message unnecessarily. For custom revert reasons use {trySub}.\r\n        *\r\n        * Counterpart to Solidity's `-` operator.\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - Subtraction cannot overflow.\r\n        */\r\n        function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n\r\n        /**\r\n        * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n        * division by zero. The result is rounded towards zero.\r\n        *\r\n        * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n        * message unnecessarily. For custom revert reasons use {tryDiv}.\r\n        *\r\n        * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n        * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n        * uses an invalid opcode to revert (consuming all remaining gas).\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - The divisor cannot be zero.\r\n        */\r\n        function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n\r\n        /**\r\n        * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n        * reverting with custom message when dividing by zero.\r\n        *\r\n        * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n        * message unnecessarily. For custom revert reasons use {tryMod}.\r\n        *\r\n        * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n        * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n        * invalid opcode to revert (consuming all remaining gas).\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - The divisor cannot be zero.\r\n        */\r\n        function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n\r\n    // File: node_modules\\@openzeppelin\\contracts\\utils\\Address.sol\r\n\r\n\r\n    pragma solidity >=0.6.2 <0.8.0;\r\n\r\n    /**\r\n    * @dev Collection of functions related to the address type\r\n    */\r\n    library Address {\r\n        /**\r\n        * @dev Returns true if `account` is a contract.\r\n        *\r\n        * [IMPORTANT]\r\n        * ====\r\n        * It is unsafe to assume that an address for which this function returns\r\n        * false is an externally-owned account (EOA) and not a contract.\r\n        *\r\n        * Among others, `isContract` will return false for the following\r\n        * types of addresses:\r\n        *\r\n        *  - an externally-owned account\r\n        *  - a contract in construction\r\n        *  - an address where a contract will be created\r\n        *  - an address where a contract lived, but was destroyed\r\n        * ====\r\n        */\r\n        function isContract(address account) internal view returns (bool) {\r\n            // This method relies on extcodesize, which returns 0 for contracts in\r\n            // construction, since the code is only stored at the end of the\r\n            // constructor execution.\r\n\r\n            uint256 size;\r\n            // solhint-disable-next-line no-inline-assembly\r\n            assembly { size := extcodesize(account) }\r\n            return size > 0;\r\n        }\r\n\r\n        /**\r\n        * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n        * `recipient`, forwarding all available gas and reverting on errors.\r\n        *\r\n        * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n        * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n        * imposed by `transfer`, making them unable to receive funds via\r\n        * `transfer`. {sendValue} removes this limitation.\r\n        *\r\n        * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n        *\r\n        * IMPORTANT: because control is transferred to `recipient`, care must be\r\n        * taken to not create reentrancy vulnerabilities. Consider using\r\n        * {ReentrancyGuard} or the\r\n        * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n        */\r\n        function sendValue(address payable recipient, uint256 amount) internal {\r\n            require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n            // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n            (bool success, ) = recipient.call{ value: amount }(\"\");\r\n            require(success, \"Address: unable to send value, recipient may have reverted\");\r\n        }\r\n\r\n        /**\r\n        * @dev Performs a Solidity function call using a low level `call`. A\r\n        * plain`call` is an unsafe replacement for a function call: use this\r\n        * function instead.\r\n        *\r\n        * If `target` reverts with a revert reason, it is bubbled up by this\r\n        * function (like regular Solidity function calls).\r\n        *\r\n        * Returns the raw returned data. To convert to the expected return value,\r\n        * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - `target` must be a contract.\r\n        * - calling `target` with `data` must not revert.\r\n        *\r\n        * _Available since v3.1._\r\n        */\r\n        function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n        }\r\n\r\n        /**\r\n        * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n        * `errorMessage` as a fallback revert reason when `target` reverts.\r\n        *\r\n        * _Available since v3.1._\r\n        */\r\n        function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n            return functionCallWithValue(target, data, 0, errorMessage);\r\n        }\r\n\r\n        /**\r\n        * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n        * but also transferring `value` wei to `target`.\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - the calling contract must have an ETH balance of at least `value`.\r\n        * - the called Solidity function must be `payable`.\r\n        *\r\n        * _Available since v3.1._\r\n        */\r\n        function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n            return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n        }\r\n\r\n        /**\r\n        * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n        * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n        *\r\n        * _Available since v3.1._\r\n        */\r\n        function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n            require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n            require(isContract(target), \"Address: call to non-contract\");\r\n\r\n            // solhint-disable-next-line avoid-low-level-calls\r\n            (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n            return _verifyCallResult(success, returndata, errorMessage);\r\n        }\r\n\r\n        /**\r\n        * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n        * but performing a static call.\r\n        *\r\n        * _Available since v3.3._\r\n        */\r\n        function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n            return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n        }\r\n\r\n        /**\r\n        * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n        * but performing a static call.\r\n        *\r\n        * _Available since v3.3._\r\n        */\r\n        function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n            require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n            // solhint-disable-next-line avoid-low-level-calls\r\n            (bool success, bytes memory returndata) = target.staticcall(data);\r\n            return _verifyCallResult(success, returndata, errorMessage);\r\n        }\r\n\r\n        /**\r\n        * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n        * but performing a delegate call.\r\n        *\r\n        * _Available since v3.4._\r\n        */\r\n        function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n            return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n        }\r\n\r\n        /**\r\n        * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n        * but performing a delegate call.\r\n        *\r\n        * _Available since v3.4._\r\n        */\r\n        function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n            require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n            // solhint-disable-next-line avoid-low-level-calls\r\n            (bool success, bytes memory returndata) = target.delegatecall(data);\r\n            return _verifyCallResult(success, returndata, errorMessage);\r\n        }\r\n\r\n        function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n            if (success) {\r\n                return returndata;\r\n            } else {\r\n                // Look for revert reason and bubble it up if present\r\n                if (returndata.length > 0) {\r\n                    // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                    // solhint-disable-next-line no-inline-assembly\r\n                    assembly {\r\n                        let returndata_size := mload(returndata)\r\n                        revert(add(32, returndata), returndata_size)\r\n                    }\r\n                } else {\r\n                    revert(errorMessage);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // File: @openzeppelin\\contracts\\token\\ERC1155\\ERC1155.sol\r\n\r\n\r\n    pragma solidity >=0.6.0 <0.8.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /**\r\n    *\r\n    * @dev Implementation of the basic standard multi-token.\r\n    * See https://eips.ethereum.org/EIPS/eip-1155\r\n    * Originally based on code by Enjin: https://github.com/enjin/erc-1155\r\n    *\r\n    * _Available since v3.1._\r\n    */\r\n    contract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\r\n        using SafeMath for uint256;\r\n        using Address for address;\r\n\r\n        // Mapping from token ID to account balances\r\n        mapping (uint256 => mapping(address => uint256)) private _balances;\r\n\r\n        // Mapping from account to operator approvals\r\n        mapping (address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n        // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\r\n        string private _uri;\r\n\r\n        /*\r\n        *     bytes4(keccak256('balanceOf(address,uint256)')) == 0x00fdd58e\r\n        *     bytes4(keccak256('balanceOfBatch(address[],uint256[])')) == 0x4e1273f4\r\n        *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\r\n        *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\r\n        *     bytes4(keccak256('safeTransferFrom(address,address,uint256,uint256,bytes)')) == 0xf242432a\r\n        *     bytes4(keccak256('safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)')) == 0x2eb2c2d6\r\n        *\r\n        *     => 0x00fdd58e ^ 0x4e1273f4 ^ 0xa22cb465 ^\r\n        *        0xe985e9c5 ^ 0xf242432a ^ 0x2eb2c2d6 == 0xd9b67a26\r\n        */\r\n        bytes4 private constant _INTERFACE_ID_ERC1155 = 0xd9b67a26;\r\n\r\n        /*\r\n        *     bytes4(keccak256('uri(uint256)')) == 0x0e89341c\r\n        */\r\n        bytes4 private constant _INTERFACE_ID_ERC1155_METADATA_URI = 0x0e89341c;\r\n\r\n        /**\r\n        * @dev See {_setURI}.\r\n        */\r\n        constructor (string memory uri_) public {\r\n            _setURI(uri_);\r\n\r\n            // register the supported interfaces to conform to ERC1155 via ERC165\r\n            _registerInterface(_INTERFACE_ID_ERC1155);\r\n\r\n            // register the supported interfaces to conform to ERC1155MetadataURI via ERC165\r\n            _registerInterface(_INTERFACE_ID_ERC1155_METADATA_URI);\r\n        }\r\n\r\n        /**\r\n        * @dev See {IERC1155MetadataURI-uri}.\r\n        *\r\n        * This implementation returns the same URI for *all* token types. It relies\r\n        * on the token type ID substitution mechanism\r\n        * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\r\n        *\r\n        * Clients calling this function must replace the `\\{id\\}` substring with the\r\n        * actual token type ID.\r\n        */\r\n        function uri(uint256) external view virtual override returns (string memory) {\r\n            return _uri;\r\n        }\r\n\r\n        /**\r\n        * @dev See {IERC1155-balanceOf}.\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - `account` cannot be the zero address.\r\n        */\r\n        function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\r\n            require(account != address(0), \"ERC1155: balance query for the zero address\");\r\n            return _balances[id][account];\r\n        }\r\n\r\n        /**\r\n        * @dev See {IERC1155-balanceOfBatch}.\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - `accounts` and `ids` must have the same length.\r\n        */\r\n        function balanceOfBatch(\r\n            address[] memory accounts,\r\n            uint256[] memory ids\r\n        )\r\n            public\r\n            view\r\n            virtual\r\n            override\r\n            returns (uint256[] memory)\r\n        {\r\n            require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\r\n\r\n            uint256[] memory batchBalances = new uint256[](accounts.length);\r\n\r\n            for (uint256 i = 0; i < accounts.length; ++i) {\r\n                batchBalances[i] = balanceOf(accounts[i], ids[i]);\r\n            }\r\n\r\n            return batchBalances;\r\n        }\r\n\r\n        /**\r\n        * @dev See {IERC1155-setApprovalForAll}.\r\n        */\r\n        function setApprovalForAll(address operator, bool approved) public virtual override {\r\n            require(_msgSender() != operator, \"ERC1155: setting approval status for self\");\r\n\r\n            _operatorApprovals[_msgSender()][operator] = approved;\r\n            emit ApprovalForAll(_msgSender(), operator, approved);\r\n        }\r\n\r\n        /**\r\n        * @dev See {IERC1155-isApprovedForAll}.\r\n        */\r\n        function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\r\n            return _operatorApprovals[account][operator];\r\n        }\r\n\r\n        /**\r\n        * @dev See {IERC1155-safeTransferFrom}.\r\n        */\r\n        function safeTransferFrom(\r\n            address from,\r\n            address to,\r\n            uint256 id,\r\n            uint256 amount,\r\n            bytes memory data\r\n        )\r\n            public\r\n            virtual\r\n            override\r\n        {\r\n            require(to != address(0), \"ERC1155: transfer to the zero address\");\r\n            require(\r\n                from == _msgSender() || isApprovedForAll(from, _msgSender()),\r\n                \"ERC1155: caller is not owner nor approved\"\r\n            );\r\n\r\n            address operator = _msgSender();\r\n\r\n            _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\r\n\r\n            _balances[id][from] = _balances[id][from].sub(amount, \"ERC1155: insufficient balance for transfer\");\r\n            _balances[id][to] = _balances[id][to].add(amount);\r\n\r\n            emit TransferSingle(operator, from, to, id, amount);\r\n\r\n            _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\r\n        }\r\n\r\n        /**\r\n        * @dev See {IERC1155-safeBatchTransferFrom}.\r\n        */\r\n        function safeBatchTransferFrom(\r\n            address from,\r\n            address to,\r\n            uint256[] memory ids,\r\n            uint256[] memory amounts,\r\n            bytes memory data\r\n        )\r\n            public\r\n            virtual\r\n            override\r\n        {\r\n            require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\r\n            require(to != address(0), \"ERC1155: transfer to the zero address\");\r\n            require(\r\n                from == _msgSender() || isApprovedForAll(from, _msgSender()),\r\n                \"ERC1155: transfer caller is not owner nor approved\"\r\n            );\r\n\r\n            address operator = _msgSender();\r\n\r\n            _beforeTokenTransfer(operator, from, to, ids, amounts, data);\r\n\r\n            for (uint256 i = 0; i < ids.length; ++i) {\r\n                uint256 id = ids[i];\r\n                uint256 amount = amounts[i];\r\n\r\n                _balances[id][from] = _balances[id][from].sub(\r\n                    amount,\r\n                    \"ERC1155: insufficient balance for transfer\"\r\n                );\r\n                _balances[id][to] = _balances[id][to].add(amount);\r\n            }\r\n\r\n            emit TransferBatch(operator, from, to, ids, amounts);\r\n\r\n            _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\r\n        }\r\n\r\n        /**\r\n        * @dev Sets a new URI for all token types, by relying on the token type ID\r\n        * substitution mechanism\r\n        * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\r\n        *\r\n        * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\r\n        * URI or any of the amounts in the JSON file at said URI will be replaced by\r\n        * clients with the token type ID.\r\n        *\r\n        * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\r\n        * interpreted by clients as\r\n        * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\r\n        * for token type ID 0x4cce0.\r\n        *\r\n        * See {uri}.\r\n        *\r\n        * Because these URIs cannot be meaningfully represented by the {URI} event,\r\n        * this function emits no events.\r\n        */\r\n        function _setURI(string memory newuri) internal virtual {\r\n            _uri = newuri;\r\n        }\r\n\r\n        /**\r\n        * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\r\n        *\r\n        * Emits a {TransferSingle} event.\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - `account` cannot be the zero address.\r\n        * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n        * acceptance magic value.\r\n        */\r\n        function _mint(address account, uint256 id, uint256 amount, bytes memory data) internal virtual {\r\n            require(account != address(0), \"ERC1155: mint to the zero address\");\r\n\r\n            address operator = _msgSender();\r\n\r\n            _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\r\n\r\n            _balances[id][account] = _balances[id][account].add(amount);\r\n            emit TransferSingle(operator, address(0), account, id, amount);\r\n\r\n            _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\r\n        }\r\n\r\n        /**\r\n        * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - `ids` and `amounts` must have the same length.\r\n        * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n        * acceptance magic value.\r\n        */\r\n        function _mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal virtual {\r\n            require(to != address(0), \"ERC1155: mint to the zero address\");\r\n            require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\r\n\r\n            address operator = _msgSender();\r\n\r\n            _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\r\n\r\n            for (uint i = 0; i < ids.length; i++) {\r\n                _balances[ids[i]][to] = amounts[i].add(_balances[ids[i]][to]);\r\n            }\r\n\r\n            emit TransferBatch(operator, address(0), to, ids, amounts);\r\n\r\n            _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\r\n        }\r\n\r\n        /**\r\n        * @dev Destroys `amount` tokens of token type `id` from `account`\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - `account` cannot be the zero address.\r\n        * - `account` must have at least `amount` tokens of token type `id`.\r\n        */\r\n        function _burn(address account, uint256 id, uint256 amount) internal virtual {\r\n            require(account != address(0), \"ERC1155: burn from the zero address\");\r\n\r\n            address operator = _msgSender();\r\n\r\n            _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), \"\");\r\n\r\n            _balances[id][account] = _balances[id][account].sub(\r\n                amount,\r\n                \"ERC1155: burn amount exceeds balance\"\r\n            );\r\n\r\n            emit TransferSingle(operator, account, address(0), id, amount);\r\n        }\r\n\r\n        /**\r\n        * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - `ids` and `amounts` must have the same length.\r\n        */\r\n        function _burnBatch(address account, uint256[] memory ids, uint256[] memory amounts) internal virtual {\r\n            require(account != address(0), \"ERC1155: burn from the zero address\");\r\n            require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\r\n\r\n            address operator = _msgSender();\r\n\r\n            _beforeTokenTransfer(operator, account, address(0), ids, amounts, \"\");\r\n\r\n            for (uint i = 0; i < ids.length; i++) {\r\n                _balances[ids[i]][account] = _balances[ids[i]][account].sub(\r\n                    amounts[i],\r\n                    \"ERC1155: burn amount exceeds balance\"\r\n                );\r\n            }\r\n\r\n            emit TransferBatch(operator, account, address(0), ids, amounts);\r\n        }\r\n\r\n        /**\r\n        * @dev Hook that is called before any token transfer. This includes minting\r\n        * and burning, as well as batched variants.\r\n        *\r\n        * The same hook is called on both single and batched variants. For single\r\n        * transfers, the length of the `id` and `amount` arrays will be 1.\r\n        *\r\n        * Calling conditions (for each `id` and `amount` pair):\r\n        *\r\n        * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n        * of token type `id` will be  transferred to `to`.\r\n        * - When `from` is zero, `amount` tokens of token type `id` will be minted\r\n        * for `to`.\r\n        * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\r\n        * will be burned.\r\n        * - `from` and `to` are never both zero.\r\n        * - `ids` and `amounts` have the same, non-zero length.\r\n        *\r\n        * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n        */\r\n        function _beforeTokenTransfer(\r\n            address operator,\r\n            address from,\r\n            address to,\r\n            uint256[] memory ids,\r\n            uint256[] memory amounts,\r\n            bytes memory data\r\n        )\r\n            internal\r\n            virtual\r\n        { }\r\n\r\n        function _doSafeTransferAcceptanceCheck(\r\n            address operator,\r\n            address from,\r\n            address to,\r\n            uint256 id,\r\n            uint256 amount,\r\n            bytes memory data\r\n        )\r\n            private\r\n        {\r\n            if (to.isContract()) {\r\n                try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\r\n                    if (response != IERC1155Receiver(to).onERC1155Received.selector) {\r\n                        revert(\"ERC1155: ERC1155Receiver rejected tokens\");\r\n                    }\r\n                } catch Error(string memory reason) {\r\n                    revert(reason);\r\n                } catch {\r\n                    revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\r\n                }\r\n            }\r\n        }\r\n\r\n        function _doSafeBatchTransferAcceptanceCheck(\r\n            address operator,\r\n            address from,\r\n            address to,\r\n            uint256[] memory ids,\r\n            uint256[] memory amounts,\r\n            bytes memory data\r\n        )\r\n            private\r\n        {\r\n            if (to.isContract()) {\r\n                try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (bytes4 response) {\r\n                    if (response != IERC1155Receiver(to).onERC1155BatchReceived.selector) {\r\n                        revert(\"ERC1155: ERC1155Receiver rejected tokens\");\r\n                    }\r\n                } catch Error(string memory reason) {\r\n                    revert(reason);\r\n                } catch {\r\n                    revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\r\n                }\r\n            }\r\n        }\r\n\r\n        function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\r\n            uint256[] memory array = new uint256[](1);\r\n            array[0] = element;\r\n\r\n            return array;\r\n        }\r\n    }\r\n\r\n    // File: @openzeppelin\\contracts\\token\\ERC721\\IERC721.sol\r\n\r\n\r\n    pragma solidity >=0.6.2 <0.8.0;\r\n\r\n\r\n    /**\r\n    * @dev Required interface of an ERC721 compliant contract.\r\n    */\r\n    interface IERC721 is IERC165 {\r\n        /**\r\n        * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n        */\r\n        event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n        /**\r\n        * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n        */\r\n        event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n        /**\r\n        * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n        */\r\n        event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n        /**\r\n        * @dev Returns the number of tokens in ``owner``'s account.\r\n        */\r\n        function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n        /**\r\n        * @dev Returns the owner of the `tokenId` token.\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - `tokenId` must exist.\r\n        */\r\n        function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n        /**\r\n        * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n        * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - `from` cannot be the zero address.\r\n        * - `to` cannot be the zero address.\r\n        * - `tokenId` token must exist and be owned by `from`.\r\n        * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n        * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n        *\r\n        * Emits a {Transfer} event.\r\n        */\r\n        function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n        /**\r\n        * @dev Transfers `tokenId` token from `from` to `to`.\r\n        *\r\n        * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - `from` cannot be the zero address.\r\n        * - `to` cannot be the zero address.\r\n        * - `tokenId` token must be owned by `from`.\r\n        * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n        *\r\n        * Emits a {Transfer} event.\r\n        */\r\n        function transferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n        /**\r\n        * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n        * The approval is cleared when the token is transferred.\r\n        *\r\n        * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - The caller must own the token or be an approved operator.\r\n        * - `tokenId` must exist.\r\n        *\r\n        * Emits an {Approval} event.\r\n        */\r\n        function approve(address to, uint256 tokenId) external;\r\n\r\n        /**\r\n        * @dev Returns the account approved for `tokenId` token.\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - `tokenId` must exist.\r\n        */\r\n        function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n        /**\r\n        * @dev Approve or remove `operator` as an operator for the caller.\r\n        * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - The `operator` cannot be the caller.\r\n        *\r\n        * Emits an {ApprovalForAll} event.\r\n        */\r\n        function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n        /**\r\n        * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n        *\r\n        * See {setApprovalForAll}\r\n        */\r\n        function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n        /**\r\n        * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - `from` cannot be the zero address.\r\n        * - `to` cannot be the zero address.\r\n        * - `tokenId` token must exist and be owned by `from`.\r\n        * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n        * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n        *\r\n        * Emits a {Transfer} event.\r\n        */\r\n        function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n    }\r\n\r\n    // File: @openzeppelin\\contracts\\utils\\EnumerableSet.sol\r\n\r\n\r\n    pragma solidity >=0.6.0 <0.8.0;\r\n\r\n    /**\r\n    * @dev Library for managing\r\n    * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\r\n    * types.\r\n    *\r\n    * Sets have the following properties:\r\n    *\r\n    * - Elements are added, removed, and checked for existence in constant time\r\n    * (O(1)).\r\n    * - Elements are enumerated in O(n). No guarantees are made on the ordering.\r\n    *\r\n    * ```\r\n    * contract Example {\r\n    *     // Add the library methods\r\n    *     using EnumerableSet for EnumerableSet.AddressSet;\r\n    *\r\n    *     // Declare a set state variable\r\n    *     EnumerableSet.AddressSet private mySet;\r\n    * }\r\n    * ```\r\n    *\r\n    * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\r\n    * and `uint256` (`UintSet`) are supported.\r\n    */\r\n    library EnumerableSet {\r\n        // To implement this library for multiple types with as little code\r\n        // repetition as possible, we write it in terms of a generic Set type with\r\n        // bytes32 values.\r\n        // The Set implementation uses private functions, and user-facing\r\n        // implementations (such as AddressSet) are just wrappers around the\r\n        // underlying Set.\r\n        // This means that we can only create new EnumerableSets for types that fit\r\n        // in bytes32.\r\n\r\n        struct Set {\r\n            // Storage of set values\r\n            bytes32[] _values;\r\n\r\n            // Position of the value in the `values` array, plus 1 because index 0\r\n            // means a value is not in the set.\r\n            mapping (bytes32 => uint256) _indexes;\r\n        }\r\n\r\n        /**\r\n        * @dev Add a value to a set. O(1).\r\n        *\r\n        * Returns true if the value was added to the set, that is if it was not\r\n        * already present.\r\n        */\r\n        function _add(Set storage set, bytes32 value) private returns (bool) {\r\n            if (!_contains(set, value)) {\r\n                set._values.push(value);\r\n                // The value is stored at length-1, but we add 1 to all indexes\r\n                // and use 0 as a sentinel value\r\n                set._indexes[value] = set._values.length;\r\n                return true;\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        /**\r\n        * @dev Removes a value from a set. O(1).\r\n        *\r\n        * Returns true if the value was removed from the set, that is if it was\r\n        * present.\r\n        */\r\n        function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n            // We read and store the value's index to prevent multiple reads from the same storage slot\r\n            uint256 valueIndex = set._indexes[value];\r\n\r\n            if (valueIndex != 0) { // Equivalent to contains(set, value)\r\n                // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n                // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n                // This modifies the order of the array, as noted in {at}.\r\n\r\n                uint256 toDeleteIndex = valueIndex - 1;\r\n                uint256 lastIndex = set._values.length - 1;\r\n\r\n                // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\r\n                // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\r\n\r\n                bytes32 lastvalue = set._values[lastIndex];\r\n\r\n                // Move the last value to the index where the value to delete is\r\n                set._values[toDeleteIndex] = lastvalue;\r\n                // Update the index for the moved value\r\n                set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\r\n\r\n                // Delete the slot where the moved value was stored\r\n                set._values.pop();\r\n\r\n                // Delete the index for the deleted slot\r\n                delete set._indexes[value];\r\n\r\n                return true;\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        /**\r\n        * @dev Returns true if the value is in the set. O(1).\r\n        */\r\n        function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n            return set._indexes[value] != 0;\r\n        }\r\n\r\n        /**\r\n        * @dev Returns the number of values on the set. O(1).\r\n        */\r\n        function _length(Set storage set) private view returns (uint256) {\r\n            return set._values.length;\r\n        }\r\n\r\n    /**\r\n        * @dev Returns the value stored at position `index` in the set. O(1).\r\n        *\r\n        * Note that there are no guarantees on the ordering of values inside the\r\n        * array, and it may change when more values are added or removed.\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - `index` must be strictly less than {length}.\r\n        */\r\n        function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n            require(set._values.length > index, \"EnumerableSet: index out of bounds\");\r\n            return set._values[index];\r\n        }\r\n\r\n        // Bytes32Set\r\n\r\n        struct Bytes32Set {\r\n            Set _inner;\r\n        }\r\n\r\n        /**\r\n        * @dev Add a value to a set. O(1).\r\n        *\r\n        * Returns true if the value was added to the set, that is if it was not\r\n        * already present.\r\n        */\r\n        function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n            return _add(set._inner, value);\r\n        }\r\n\r\n        /**\r\n        * @dev Removes a value from a set. O(1).\r\n        *\r\n        * Returns true if the value was removed from the set, that is if it was\r\n        * present.\r\n        */\r\n        function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n            return _remove(set._inner, value);\r\n        }\r\n\r\n        /**\r\n        * @dev Returns true if the value is in the set. O(1).\r\n        */\r\n        function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\r\n            return _contains(set._inner, value);\r\n        }\r\n\r\n        /**\r\n        * @dev Returns the number of values in the set. O(1).\r\n        */\r\n        function length(Bytes32Set storage set) internal view returns (uint256) {\r\n            return _length(set._inner);\r\n        }\r\n\r\n    /**\r\n        * @dev Returns the value stored at position `index` in the set. O(1).\r\n        *\r\n        * Note that there are no guarantees on the ordering of values inside the\r\n        * array, and it may change when more values are added or removed.\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - `index` must be strictly less than {length}.\r\n        */\r\n        function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\r\n            return _at(set._inner, index);\r\n        }\r\n\r\n        // AddressSet\r\n\r\n        struct AddressSet {\r\n            Set _inner;\r\n        }\r\n\r\n        /**\r\n        * @dev Add a value to a set. O(1).\r\n        *\r\n        * Returns true if the value was added to the set, that is if it was not\r\n        * already present.\r\n        */\r\n        function add(AddressSet storage set, address value) internal returns (bool) {\r\n            return _add(set._inner, bytes32(uint256(uint160(value))));\r\n        }\r\n\r\n        /**\r\n        * @dev Removes a value from a set. O(1).\r\n        *\r\n        * Returns true if the value was removed from the set, that is if it was\r\n        * present.\r\n        */\r\n        function remove(AddressSet storage set, address value) internal returns (bool) {\r\n            return _remove(set._inner, bytes32(uint256(uint160(value))));\r\n        }\r\n\r\n        /**\r\n        * @dev Returns true if the value is in the set. O(1).\r\n        */\r\n        function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n            return _contains(set._inner, bytes32(uint256(uint160(value))));\r\n        }\r\n\r\n        /**\r\n        * @dev Returns the number of values in the set. O(1).\r\n        */\r\n        function length(AddressSet storage set) internal view returns (uint256) {\r\n            return _length(set._inner);\r\n        }\r\n\r\n    /**\r\n        * @dev Returns the value stored at position `index` in the set. O(1).\r\n        *\r\n        * Note that there are no guarantees on the ordering of values inside the\r\n        * array, and it may change when more values are added or removed.\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - `index` must be strictly less than {length}.\r\n        */\r\n        function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n            return address(uint160(uint256(_at(set._inner, index))));\r\n        }\r\n\r\n\r\n        // UintSet\r\n\r\n        struct UintSet {\r\n            Set _inner;\r\n        }\r\n\r\n        /**\r\n        * @dev Add a value to a set. O(1).\r\n        *\r\n        * Returns true if the value was added to the set, that is if it was not\r\n        * already present.\r\n        */\r\n        function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n            return _add(set._inner, bytes32(value));\r\n        }\r\n\r\n        /**\r\n        * @dev Removes a value from a set. O(1).\r\n        *\r\n        * Returns true if the value was removed from the set, that is if it was\r\n        * present.\r\n        */\r\n        function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n            return _remove(set._inner, bytes32(value));\r\n        }\r\n\r\n        /**\r\n        * @dev Returns true if the value is in the set. O(1).\r\n        */\r\n        function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n            return _contains(set._inner, bytes32(value));\r\n        }\r\n\r\n        /**\r\n        * @dev Returns the number of values on the set. O(1).\r\n        */\r\n        function length(UintSet storage set) internal view returns (uint256) {\r\n            return _length(set._inner);\r\n        }\r\n\r\n    /**\r\n        * @dev Returns the value stored at position `index` in the set. O(1).\r\n        *\r\n        * Note that there are no guarantees on the ordering of values inside the\r\n        * array, and it may change when more values are added or removed.\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - `index` must be strictly less than {length}.\r\n        */\r\n        function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n            return uint256(_at(set._inner, index));\r\n        }\r\n    }\r\n\r\n    // File: contracts\\TokenSign.sol\r\n\r\n\r\n    pragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n    /**\r\n    *\r\n    * @dev Implementation of the one and only TokenSign Signature Token.\r\n    * Written by Ryley Ohlsen & Cody Ohlsen, 03.09.2021.\r\n    *\r\n    * See https://eips.ethereum.org/EIPS/eip-1155\r\n    * Extends openzeppelin ERC1155.sol; see: https://docs.openzeppelin.com/contracts/3.x/erc1155\r\n    */\r\n    contract TokenSign is ERC1155 {\r\n        /**\r\n        * @dev Emitted when 'owner' signs NFT 'nftAddr', 'nftTokenId' with Signature Token 'sigTokenId'.\r\n        */\r\n        event Sign(address owner, uint256 indexed sigTokenId, address indexed nftAddr, uint256 indexed nftTokenId);\r\n        /**\r\n        * @dev Emitted when minter mints Signature Tokens as minter index 'minterId' with name 'name'.\r\n        */\r\n        event Mint(address indexed minter, uint256 indexed minterId, string name, bool isFounder);\r\n\r\n        // Add the openzeppelin library methods\r\n        using EnumerableSet for EnumerableSet.UintSet;\r\n\r\n        /**\r\n        * Token types:\r\n        * uint | description\r\n        *   0  = PLATINUM\r\n        *   1  = GOLD\r\n        *   2  = SILVER\r\n        *   3  = INK\r\n        *   4  = DEV\r\n        *   5  = FOUNDER\r\n        */\r\n\r\n        /*\r\n        * number of each signature token type to mint, per address, only once\r\n        */\r\n        uint256 public constant N_PLATINUM = 3;\r\n        uint256 public constant N_GOLD = 9;\r\n        uint256 public constant N_SILVER = 200;\r\n        // effectively unlimited ink tokens, minter can do whatever they please\r\n        uint256 public constant N_INK = 1000;\r\n        // devs receive a dev signature token to commemorate every minting, run the front end\r\n        uint256 public constant N_DEV = 1;\r\n        // special first year - minter receives single founder signature token\r\n        uint256 public constant N_FOUNDER = 1;\r\n\r\n        // token ids per set\r\n        uint256 private constant TOKEN_IDS_PER_SET = 6;\r\n        bool public foundingEventActive = true;\r\n        uint256 public birthTime;\r\n        uint256 private constant SECONDS_IN_YEAR = 31556952;\r\n\r\n        // error messages\r\n        string private constant DUPLICATE_MINT_ERROR = \"DUPLICATE MINT ERROR: Minting only allowed once per address\";\r\n        string private constant END_FOUNDERS_ERROR = \"END FOUNDERS ERROR: The founder's event lasts 1 year\";\r\n        string private constant FOUNDERS_ALREADY_OVER = \"FOUNDERS OVER: The founder's event is already over\";\r\n        string private constant OWNERSHIP_ERROR = \"OWNERSHIP ERROR: Only the owner of an ERC-721 may sign it\";\r\n        string private constant ALREADY_SIGNED_ERROR = \"ALREADY SIGNED ERROR: An ERC-721 may only be signed once by each Signature Token ID\";\r\n\r\n        // util constants\r\n        uint256 private constant N_BURN = 1;\r\n\r\n        // next token id to mint\r\n        uint256 public nextTokenId = 0;\r\n\r\n        // map of ERC-721 addresses to ERC-721 tokenId to EnumerableSet of signatureTokenIds that have signed the ERC-721\r\n        mapping(address => mapping(uint256 => EnumerableSet.UintSet)) private signatures;\r\n\r\n        // map of minter address to bool representing if an address has minted\r\n        mapping(address => bool) public hasMinted;\r\n\r\n        // dev address\r\n        address public devs;\r\n\r\n        constructor() public ERC1155(\"https://api.tokensign.app/item/{id}.json\") {\r\n            birthTime = block.timestamp;\r\n            // record who the devs are\r\n            devs = msg.sender;\r\n            // mint first signatures ever to the devs\r\n            mint(\"TokenSign Creators\");\r\n        }\r\n\r\n        /**\r\n        * Mint your signature tokens!\r\n        * @param name: Minter's name. Whatever the minter wants it to be. Can never be changed.\r\n        */\r\n        function mint(string memory name) public {\r\n            // check that have not already minted, then register as minted\r\n            require(!hasMinted[msg.sender], DUPLICATE_MINT_ERROR);\r\n            hasMinted[msg.sender] = true;\r\n\r\n            uint256 tmpId = nextTokenId;\r\n\r\n            // build up for batch mint\r\n            if (foundingEventActive) {\r\n                uint256[] memory ids = new uint256[](TOKEN_IDS_PER_SET-1);\r\n                uint256[] memory amounts = new uint256[](TOKEN_IDS_PER_SET-1);\r\n                ids[0] = tmpId;\r\n                amounts[0] = N_PLATINUM;\r\n                ids[1] = tmpId+1;\r\n                amounts[1] = N_GOLD;\r\n                ids[2] = tmpId+2;\r\n                amounts[2] = N_SILVER;\r\n                ids[3] = tmpId+3;\r\n                amounts[3] = N_INK;\r\n                ids[4] = tmpId+5; // intentional!\r\n                amounts[4] = N_FOUNDER;\r\n                _mintBatch(msg.sender, ids, amounts, \"\");\r\n            } else {\r\n                uint256[] memory ids = new uint256[](TOKEN_IDS_PER_SET-2);\r\n                uint256[] memory amounts = new uint256[](TOKEN_IDS_PER_SET-2);\r\n                ids[0] = tmpId;\r\n                amounts[0] = N_PLATINUM;\r\n                ids[1] = tmpId+1;\r\n                amounts[1] = N_GOLD;\r\n                ids[2] = tmpId+2;\r\n                amounts[2] = N_SILVER;\r\n                ids[3] = tmpId+3;\r\n                amounts[3] = N_INK;\r\n                _mintBatch(msg.sender, ids, amounts, \"\");\r\n            }\r\n            _mint(devs, tmpId+4, N_DEV, \"\");\r\n\r\n            // emit Mint event\r\n            emit Mint(msg.sender, nextTokenId.div(TOKEN_IDS_PER_SET), name, foundingEventActive);\r\n            nextTokenId += TOKEN_IDS_PER_SET;\r\n        }\r\n\r\n        /**\r\n        * Anyone can call to end the founder event after the first year has passed\r\n        */\r\n        function endFounderEvent() external {\r\n            require(birthTime + SECONDS_IN_YEAR < block.timestamp, END_FOUNDERS_ERROR);\r\n            require(foundingEventActive, FOUNDERS_ALREADY_OVER);\r\n            foundingEventActive = false;\r\n        }\r\n\r\n        /**\r\n        * Call sign to sign any ERC-721 owned by msg.sender with a signature token,\r\n        * while also burning your signature token.\r\n        *\r\n        * @param nftAddr: address of NFT to be signed\r\n        * @param nftTokenId: tokenId of NFT to be signed, at nftAddr\r\n        * @param sigTokenId: signature tokenId to sign with (in this contract)\r\n        */\r\n        function sign(address nftAddr, uint256 nftTokenId, uint256 sigTokenId) external {\r\n            // sender must own the NFT to be signed\r\n            IERC721 ERC721 = IERC721(nftAddr);\r\n            require(ERC721.ownerOf(nftTokenId) == msg.sender, OWNERSHIP_ERROR);\r\n            // burn the signature token\r\n            _burn(msg.sender, sigTokenId, N_BURN);\r\n            // require NFT to not already signed by the exact same signature token + type\r\n            require(!signatures[nftAddr][nftTokenId].contains(sigTokenId), ALREADY_SIGNED_ERROR);\r\n            // sign the token\r\n            signatures[nftAddr][nftTokenId].add(sigTokenId);\r\n            // emit Sign event\r\n            emit Sign(msg.sender, sigTokenId, nftAddr, nftTokenId);\r\n        }\r\n\r\n        // ALL FUNCTIONS AFTER THIS POINT ARE READ-ONLY\r\n\r\n        /**\r\n        * Returns number of signatures currently on a given ERC-721 NFT\r\n        *\r\n        * @param nftAddr: address of ERC-721 NFT to be queried\r\n        * @param nftTokenId: tokenId of ERC-721 NFT to be queried, at nftAddr\r\n        * @return uint256 quantity of signatures on the queried ERC-721 NFT\r\n        */\r\n        function nftSignatureQuantity(address nftAddr, uint256 nftTokenId) external view returns (uint256) {\r\n            return signatures[nftAddr][nftTokenId].length();\r\n        }\r\n\r\n        /**\r\n        * Returns the signature token ID that signed at a specific index for a given ERC-721 NFT\r\n        *\r\n        * @param nftAddr: address of ERC-721 NFT to be queried\r\n        * @param nftTokenId: tokenId of ERC-721 NFT to be queried, at nftAddr\r\n        * @param index: index of signature token ID to return\r\n        * @return uint256 signature token id at queried index\r\n        */\r\n        function nftSignatureIdAtIndex(address nftAddr, uint256 nftTokenId, uint256 index) external view returns (uint256) {\r\n            return signatures[nftAddr][nftTokenId].at(index);\r\n        }\r\n    }","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"minterId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isFounder\",\"type\":\"bool\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"sigTokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftAddr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftTokenId\",\"type\":\"uint256\"}],\"name\":\"Sign\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"N_DEV\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"N_FOUNDER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"N_GOLD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"N_INK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"N_PLATINUM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"N_SILVER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"birthTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endFounderEvent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"foundingEventActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasMinted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextTokenId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"nftSignatureIdAtIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftTokenId\",\"type\":\"uint256\"}],\"name\":\"nftSignatureQuantity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sigTokenId\",\"type\":\"uint256\"}],\"name\":\"sign\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"TokenSign","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://61c74af31ff61384038ff808e5ce66e13f7353addad24bf919cb7ca11d1cfcc1"}]}