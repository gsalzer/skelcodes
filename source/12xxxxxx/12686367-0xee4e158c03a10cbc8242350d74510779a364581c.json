{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/UserProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/IERC20Permit.sol\\\";\\nimport \\\"./interfaces/ITranche.sol\\\";\\nimport \\\"./interfaces/IWETH.sol\\\";\\nimport \\\"./interfaces/IWrappedPosition.sol\\\";\\nimport \\\"./libraries/Authorizable.sol\\\";\\n\\n/// @author Element Finance\\n/// @title User Proxy\\ncontract UserProxy is Authorizable {\\n    // This contract is a convenience library to consolidate\\n    // the actions needed to create interest or principal tokens to one call.\\n    // It will hold user allowances, and can be disabled by authorized addresses\\n    // for security.\\n    // If frozen users still control their own tokens so can manually redeem them.\\n\\n    // Store the accessibility state of the contract\\n    bool public isFrozen = false;\\n    // Constant wrapped ether address\\n    IWETH public immutable weth;\\n    // Tranche factory address for Tranche contract address derivation\\n    address internal immutable _trancheFactory;\\n    // Tranche bytecode hash for Tranche contract address derivation.\\n    // This is constant as long as Tranche does not implement non-constant constructor arguments.\\n    bytes32 internal immutable _trancheBytecodeHash;\\n    // A constant which represents ether\\n    address internal constant _ETH_CONSTANT = address(\\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\\n    );\\n\\n    /// @dev Marks the msg.sender as authorized and sets them\\n    ///      as the owner in authorization library\\n    /// @param _weth The constant weth contract address\\n    /// @param __trancheFactory Address of the TrancheFactory contract\\n    /// @param __trancheBytecodeHash Hash of the Tranche bytecode.\\n    constructor(\\n        IWETH _weth,\\n        address __trancheFactory,\\n        bytes32 __trancheBytecodeHash\\n    ) Authorizable() {\\n        _authorize(msg.sender);\\n        weth = _weth;\\n        _trancheFactory = __trancheFactory;\\n        _trancheBytecodeHash = __trancheBytecodeHash;\\n    }\\n\\n    /// @dev Requires that the contract is not frozen\\n    modifier notFrozen() {\\n        require(!isFrozen, \\\"Contract frozen\\\");\\n        _;\\n    }\\n\\n    /// @dev Allows an authorized address to freeze or unfreeze this contract\\n    /// @param _newState True for frozen and false for unfrozen\\n    function setIsFrozen(bool _newState) external onlyAuthorized() {\\n        isFrozen = _newState;\\n    }\\n\\n    // Memory encoding of the permit data\\n    struct PermitData {\\n        IERC20Permit tokenContract;\\n        address who;\\n        uint256 amount;\\n        uint256 expiration;\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n    }\\n\\n    /// @dev Takes the input permit calls and executes them\\n    /// @param data The array which encodes the set of permit calls to make\\n    modifier preApproval(PermitData[] memory data) {\\n        // If permit calls are provided we make try to make them\\n        if (data.length != 0) {\\n            // We make permit calls for each indicated call\\n            for (uint256 i = 0; i < data.length; i++) {\\n                _permitCall(data[i]);\\n            }\\n        }\\n        _;\\n    }\\n\\n    /// @dev Makes permit calls indicated by a struct\\n    /// @param data the struct which has the permit calldata\\n    function _permitCall(PermitData memory data) internal {\\n        // Make the permit call to the token in the data field using\\n        // the fields provided.\\n        // Security note - This fairly open call is safe because it cannot\\n        // call 'transferFrom' or other sensitive methods despite the open\\n        // scope. Do not make more general without security review.\\n        data.tokenContract.permit(\\n            msg.sender,\\n            data.who,\\n            data.amount,\\n            data.expiration,\\n            data.v,\\n            data.r,\\n            data.s\\n        );\\n    }\\n\\n    /// @notice Mints a Principal/Interest token pair from either underlying token or Eth\\n    ///      then returns the tokens to the caller.\\n    /// @dev This function assumes that it already has an allowance for the token in question.\\n    /// @param _amount The amount of underlying to turn into tokens\\n    /// @param _underlying Either (1) The underlying ERC20 token contract\\n    ///                   or (2) the _ETH_CONSTANT to indicate the user has sent eth.\\n    ///                   This token should revert in the event of a transfer failure.\\n    /// @param _expiration The expiration time of the Tranche contract\\n    /// @param _position The contract which manages pooled deposits\\n    /// @param _permitCallData Encoded array of permit calls to make prior to minting\\n    ///                        the data should be encoded with abi.encode(data, \\\"PermitData[]\\\")\\n    ///                        each PermitData struct provided will be executed as a call.\\n    ///                        An example use of this is if using a token with permit like USDC\\n    ///                        to encode a permit which gives this contract allowance before minting.\\n    /// @return returns the minted amounts of PT and YT\\n    // NOTE - It is critical that the notFrozen modifier is listed first so it gets called first.\\n    function mint(\\n        uint256 _amount,\\n        IERC20 _underlying,\\n        uint256 _expiration,\\n        address _position,\\n        PermitData[] calldata _permitCallData\\n    )\\n        external\\n        payable\\n        notFrozen()\\n        preApproval(_permitCallData)\\n        returns (uint256, uint256)\\n    {\\n        // If the underlying token matches this predefined 'ETH token'\\n        // then we create weth for the user and go from there\\n        if (address(_underlying) == _ETH_CONSTANT) {\\n            // Check that the amount matches the amount provided\\n            require(msg.value == _amount, \\\"Incorrect amount provided\\\");\\n            // Create weth from the provided eth\\n            weth.deposit{ value: msg.value }();\\n            weth.transfer(address(_position), _amount);\\n        } else {\\n            // Check for the fact that this branch should not be payable\\n            require(msg.value == 0, \\\"Non payable\\\");\\n            // Move the user's funds to the wrapped position contract\\n            _underlying.transferFrom(msg.sender, address(_position), _amount);\\n        }\\n\\n        // Proceed to internal minting steps\\n        (uint256 ptMinted, uint256 ytMinted) = _mint(_expiration, _position);\\n        // This sanity check ensure that at least as much was minted as was transferred\\n        require(ytMinted >= _amount, \\\"Not enough minted\\\");\\n        return (ptMinted, ytMinted);\\n    }\\n\\n    /// @dev Allows a user to withdraw and unwrap weth in the same transaction\\n    ///      likely quite a bit more expensive than direct unwrapping but useful\\n    ///      for those who want to do one tx instead of two\\n    /// @param _expiration The tranche expiration time\\n    /// @param _position The contract which interacts with the yield bearing strategy\\n    /// @param _amountPT The amount of principal token to withdraw\\n    /// @param _amountYT The amount of yield token to withdraw.\\n    /// @param _permitCallData Encoded array of permit calls to make prior to withdrawing,\\n    ///                        should be used to get allowances for PT and YT\\n    // NOTE - It is critical that the notFrozen modifier is listed first so it gets called first.\\n    function withdrawWeth(\\n        uint256 _expiration,\\n        address _position,\\n        uint256 _amountPT,\\n        uint256 _amountYT,\\n        PermitData[] calldata _permitCallData\\n    ) external notFrozen() preApproval(_permitCallData) {\\n        // Post the Berlin hardfork this call warms the address so only cost ~100 gas overall\\n        require(IWrappedPosition(_position).token() == weth, \\\"Non weth token\\\");\\n        // Only allow access if the user is actually attempting to withdraw\\n        require(((_amountPT != 0) || (_amountYT != 0)), \\\"Invalid withdraw\\\");\\n        // Because of create2 we know this code is exactly what is expected.\\n        ITranche derivedTranche = _deriveTranche(_position, _expiration);\\n\\n        uint256 wethReceivedPt = 0;\\n        uint256 wethReceivedYt = 0;\\n        // Check if we need to withdraw principal token\\n        if (_amountPT != 0) {\\n            // If we have to withdraw PT first transfer it to this contract\\n            derivedTranche.transferFrom(msg.sender, address(this), _amountPT);\\n            // Then we withdraw that PT with the resulting weth going to this address\\n            wethReceivedPt = derivedTranche.withdrawPrincipal(\\n                _amountPT,\\n                address(this)\\n            );\\n        }\\n        // Check if we need to withdraw yield token\\n        if (_amountYT != 0) {\\n            // Post Berlin this lookup only costs 100 gas overall as well\\n            IERC20Permit yieldToken = derivedTranche.interestToken();\\n            // Transfer the YT to this contract\\n            yieldToken.transferFrom(msg.sender, address(this), _amountYT);\\n            // Withdraw that YT\\n            wethReceivedYt = derivedTranche.withdrawInterest(\\n                _amountYT,\\n                address(this)\\n            );\\n        }\\n\\n        // A sanity check that some value was withdrawn\\n        if (_amountPT != 0) {\\n            require((wethReceivedPt != 0), \\\"Rugged\\\");\\n        }\\n        if (_amountYT != 0) {\\n            require((wethReceivedYt != 0), \\\"No yield accrued\\\");\\n        }\\n        // Withdraw the ether from weth\\n        weth.withdraw(wethReceivedPt + wethReceivedYt);\\n        // Send the withdrawn eth to the caller\\n        payable(msg.sender).transfer(wethReceivedPt + wethReceivedYt);\\n    }\\n\\n    /// @dev The receive function allows WETH and only WETH to send\\n    ///      eth directly to this contract. Note - It Cannot be assumed\\n    ///      that this will prevent this contract from having an ETH balance\\n    receive() external payable {\\n        require(msg.sender == address(weth));\\n    }\\n\\n    /// @dev This internal mint function performs the core minting logic after\\n    ///      the contract has already transferred to WrappedPosition contract\\n    /// @param _expiration The tranche expiration time\\n    /// @param _position The contract which interacts with the yield bearing strategy\\n    /// @return the principal token yield token returned\\n    function _mint(uint256 _expiration, address _position)\\n        internal\\n        returns (uint256, uint256)\\n    {\\n        // Use create2 to derive the tranche contract\\n        ITranche tranche = _deriveTranche(address(_position), _expiration);\\n        // Move funds into the Tranche contract\\n        // it will credit the msg.sender with the new tokens\\n        return tranche.prefundedDeposit(msg.sender);\\n    }\\n\\n    /// @dev This internal function produces the deterministic create2\\n    ///      address of the Tranche contract from a wrapped position contract and expiration\\n    /// @param _position The wrapped position contract address\\n    /// @param _expiration The expiration time of the tranche\\n    /// @return The derived Tranche contract\\n    function _deriveTranche(address _position, uint256 _expiration)\\n        internal\\n        virtual\\n        view\\n        returns (ITranche)\\n    {\\n        bytes32 salt = keccak256(abi.encodePacked(_position, _expiration));\\n        bytes32 addressBytes = keccak256(\\n            abi.encodePacked(\\n                bytes1(0xff),\\n                _trancheFactory,\\n                salt,\\n                _trancheBytecodeHash\\n            )\\n        );\\n        return ITranche(address(uint160(uint256(addressBytes))));\\n    }\\n\\n    /// @dev This contract holds a number of allowances for addresses so if it is deprecated\\n    ///      it should be removed so that users do not have to remove allowances.\\n    ///      Note - onlyOwner is a stronger check than onlyAuthorized, many addresses can be\\n    ///      authorized to freeze or unfreeze the contract but only the owner address can kill\\n    function deprecate() external onlyOwner() {\\n        selfdestruct(payable(msg.sender));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\ninterface IERC20 {\\n    function symbol() external view returns (string memory);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    // Note this is non standard but nearly all ERC20 have exposed decimal functions\\n    function decimals() external view returns (uint8);\\n\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20Permit.sol\": {\r\n      \"content\": \"// Forked from openzepplin\\n// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit is IERC20 {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over `owner`'s tokens,\\n     * given `owner`'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for `permit`, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITranche.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20Permit.sol\\\";\\nimport \\\"./IInterestToken.sol\\\";\\n\\ninterface ITranche is IERC20Permit {\\n    function deposit(uint256 _shares, address destination)\\n        external\\n        returns (uint256, uint256);\\n\\n    function prefundedDeposit(address _destination)\\n        external\\n        returns (uint256, uint256);\\n\\n    function withdrawPrincipal(uint256 _amount, address _destination)\\n        external\\n        returns (uint256);\\n\\n    function withdrawInterest(uint256 _amount, address _destination)\\n        external\\n        returns (uint256);\\n\\n    function interestToken() external view returns (IInterestToken);\\n\\n    function interestSupply() external view returns (uint128);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IWETH is IERC20 {\\n    function deposit() external payable;\\n\\n    function withdraw(uint256 wad) external;\\n\\n    event Deposit(address indexed dst, uint256 wad);\\n    event Withdrawal(address indexed src, uint256 wad);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWrappedPosition.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20Permit.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IWrappedPosition is IERC20Permit {\\n    function token() external view returns (IERC20);\\n\\n    function balanceOfUnderlying(address who) external view returns (uint256);\\n\\n    function getSharesToUnderlying(uint256 shares)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function deposit(address sender, uint256 amount) external returns (uint256);\\n\\n    function withdraw(\\n        address sender,\\n        uint256 _shares,\\n        uint256 _minUnderlying\\n    ) external returns (uint256);\\n\\n    function withdrawUnderlying(\\n        address _destination,\\n        uint256 _amount,\\n        uint256 _minUnderlying\\n    ) external returns (uint256, uint256);\\n\\n    function prefundedDeposit(address _destination)\\n        external\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Authorizable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity >=0.7.0;\\n\\ncontract Authorizable {\\n    // This contract allows a flexible authorization scheme\\n\\n    // The owner who can change authorization status\\n    address public owner;\\n    // A mapping from an address to its authorization status\\n    mapping(address => bool) public authorized;\\n\\n    /// @dev We set the deployer to the owner\\n    constructor() {\\n        owner = msg.sender;\\n    }\\n\\n    /// @dev This modifier checks if the msg.sender is the owner\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"Sender not owner\\\");\\n        _;\\n    }\\n\\n    /// @dev This modifier checks if an address is authorized\\n    modifier onlyAuthorized() {\\n        require(isAuthorized(msg.sender), \\\"Sender not Authorized\\\");\\n        _;\\n    }\\n\\n    /// @dev Returns true if an address is authorized\\n    /// @param who the address to check\\n    /// @return true if authorized false if not\\n    function isAuthorized(address who) public view returns (bool) {\\n        return authorized[who];\\n    }\\n\\n    /// @dev Privileged function authorize an address\\n    /// @param who the address to authorize\\n    function authorize(address who) external onlyOwner() {\\n        _authorize(who);\\n    }\\n\\n    /// @dev Privileged function to de authorize an address\\n    /// @param who The address to remove authorization from\\n    function deauthorize(address who) external onlyOwner() {\\n        authorized[who] = false;\\n    }\\n\\n    /// @dev Function to change owner\\n    /// @param who The new owner address\\n    function setOwner(address who) public onlyOwner() {\\n        owner = who;\\n    }\\n\\n    /// @dev Inheritable function which authorizes someone\\n    /// @param who the address to authorize\\n    function _authorize(address who) internal {\\n        authorized[who] = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IInterestToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20Permit.sol\\\";\\n\\ninterface IInterestToken is IERC20Permit {\\n    function mint(address _account, uint256 _amount) external;\\n\\n    function burn(address _account, uint256 _amount) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 7500\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IWETH\",\"name\":\"_weth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"__trancheFactory\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"__trancheBytecodeHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"authorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"deauthorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deprecate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isFrozen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC20\",\"name\":\"_underlying\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_expiration\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_position\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"contract IERC20Permit\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct UserProxy.PermitData[]\",\"name\":\"_permitCallData\",\"type\":\"tuple[]\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_newState\",\"type\":\"bool\"}],\"name\":\"setIsFrozen\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"contract IWETH\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_expiration\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_position\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountPT\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountYT\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"contract IERC20Permit\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct UserProxy.PermitData[]\",\"name\":\"_permitCallData\",\"type\":\"tuple[]\"}],\"name\":\"withdrawWeth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"UserProxy","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"7500","ConstructorArguments":"000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000062f161bf3692e4015befb05a03a94a40f520d1c0f481a073666136ab1f5e93b296e84df58092065256d0db23b2d22b62c68e978d","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}