{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"tornado-trees/contracts/TornadoTrees.sol\": {\r\n      \"content\": \"// https://tornado.cash\\n/*\\n* d888888P                                           dP              a88888b.                   dP\\n*    88                                              88             d8'   `88                   88\\n*    88    .d8888b. 88d888b. 88d888b. .d8888b. .d888b88 .d8888b.    88        .d8888b. .d8888b. 88d888b.\\n*    88    88'  `88 88'  `88 88'  `88 88'  `88 88'  `88 88'  `88    88        88'  `88 Y8ooooo. 88'  `88\\n*    88    88.  .88 88       88    88 88.  .88 88.  .88 88.  .88 dP Y8.   .88 88.  .88       88 88    88\\n*    dP    `88888P' dP       dP    dP `88888P8 `88888P8 `88888P' 88  Y88888P' `88888P8 `88888P' dP    dP\\n* ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\\n*/\\n\\n// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./interfaces/ITornadoTreesV1.sol\\\";\\nimport \\\"./interfaces/IBatchTreeUpdateVerifier.sol\\\";\\nimport \\\"@openzeppelin/upgrades-core/contracts/Initializable.sol\\\";\\n\\n/// @dev This contract holds a merkle tree of all tornado cash deposit and withdrawal events\\ncontract TornadoTrees is Initializable {\\n  address public immutable governance;\\n  bytes32 public depositRoot;\\n  bytes32 public previousDepositRoot;\\n  bytes32 public withdrawalRoot;\\n  bytes32 public previousWithdrawalRoot;\\n  address public tornadoProxy;\\n  IBatchTreeUpdateVerifier public treeUpdateVerifier;\\n  ITornadoTreesV1 public immutable tornadoTreesV1;\\n\\n  uint256 public constant CHUNK_TREE_HEIGHT = 8;\\n  uint256 public constant CHUNK_SIZE = 2**CHUNK_TREE_HEIGHT;\\n  uint256 public constant ITEM_SIZE = 32 + 20 + 4;\\n  uint256 public constant BYTES_SIZE = 32 + 32 + 4 + CHUNK_SIZE * ITEM_SIZE;\\n  uint256 public constant SNARK_FIELD = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\\n\\n  mapping(uint256 => bytes32) public deposits;\\n  uint256 public depositsLength;\\n  uint256 public lastProcessedDepositLeaf;\\n  uint256 public immutable depositsV1Length;\\n\\n  mapping(uint256 => bytes32) public withdrawals;\\n  uint256 public withdrawalsLength;\\n  uint256 public lastProcessedWithdrawalLeaf;\\n  uint256 public immutable withdrawalsV1Length;\\n\\n  event DepositData(address instance, bytes32 indexed hash, uint256 block, uint256 index);\\n  event WithdrawalData(address instance, bytes32 indexed hash, uint256 block, uint256 index);\\n  event VerifierUpdated(address newVerifier);\\n  event ProxyUpdated(address newProxy);\\n\\n  struct TreeLeaf {\\n    bytes32 hash;\\n    address instance;\\n    uint32 block;\\n  }\\n\\n  modifier onlyTornadoProxy {\\n    require(msg.sender == tornadoProxy, \\\"Not authorized\\\");\\n    _;\\n  }\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\\"Only governance can perform this action\\\");\\n    _;\\n  }\\n\\n  struct SearchParams {\\n    uint256 depositsFrom;\\n    uint256 depositsStep;\\n    uint256 withdrawalsFrom;\\n    uint256 withdrawalsStep;\\n  }\\n\\n  constructor(\\n    address _governance,\\n    ITornadoTreesV1 _tornadoTreesV1,\\n    SearchParams memory _searchParams\\n  ) public {\\n    governance = _governance;\\n    tornadoTreesV1 = _tornadoTreesV1;\\n\\n    depositsV1Length = findArrayLength(\\n      _tornadoTreesV1,\\n      \\\"deposits(uint256)\\\",\\n      _searchParams.depositsFrom,\\n      _searchParams.depositsStep\\n    );\\n\\n    withdrawalsV1Length = findArrayLength(\\n      _tornadoTreesV1,\\n      \\\"withdrawals(uint256)\\\",\\n      _searchParams.withdrawalsFrom,\\n      _searchParams.withdrawalsStep\\n    );\\n  }\\n\\n  function initialize(address _tornadoProxy, IBatchTreeUpdateVerifier _treeUpdateVerifier) public initializer onlyGovernance {\\n    tornadoProxy = _tornadoProxy;\\n    treeUpdateVerifier = _treeUpdateVerifier;\\n\\n    depositRoot = tornadoTreesV1.depositRoot();\\n    uint256 lastDepositLeaf = tornadoTreesV1.lastProcessedDepositLeaf();\\n    require(lastDepositLeaf % CHUNK_SIZE == 0, \\\"Incorrect TornadoTrees state\\\");\\n    lastProcessedDepositLeaf = lastDepositLeaf;\\n    depositsLength = depositsV1Length;\\n\\n    withdrawalRoot = tornadoTreesV1.withdrawalRoot();\\n    uint256 lastWithdrawalLeaf = tornadoTreesV1.lastProcessedWithdrawalLeaf();\\n    require(lastWithdrawalLeaf % CHUNK_SIZE == 0, \\\"Incorrect TornadoTrees state\\\");\\n    lastProcessedWithdrawalLeaf = lastWithdrawalLeaf;\\n    withdrawalsLength = withdrawalsV1Length;\\n  }\\n\\n  /// @dev Queue a new deposit data to be inserted into a merkle tree\\n  function registerDeposit(address _instance, bytes32 _commitment) public onlyTornadoProxy {\\n    uint256 _depositsLength = depositsLength;\\n    deposits[_depositsLength] = keccak256(abi.encode(_instance, _commitment, blockNumber()));\\n    emit DepositData(_instance, _commitment, blockNumber(), _depositsLength);\\n    depositsLength = _depositsLength + 1;\\n  }\\n\\n  /// @dev Queue a new withdrawal data to be inserted into a merkle tree\\n  function registerWithdrawal(address _instance, bytes32 _nullifierHash) public onlyTornadoProxy {\\n    uint256 _withdrawalsLength = withdrawalsLength;\\n    withdrawals[_withdrawalsLength] = keccak256(abi.encode(_instance, _nullifierHash, blockNumber()));\\n    emit WithdrawalData(_instance, _nullifierHash, blockNumber(), _withdrawalsLength);\\n    withdrawalsLength = _withdrawalsLength + 1;\\n  }\\n\\n  /// @dev Insert a full batch of queued deposits into a merkle tree\\n  /// @param _proof A snark proof that elements were inserted correctly\\n  /// @param _argsHash A hash of snark inputs\\n  /// @param _argsHash Current merkle tree root\\n  /// @param _newRoot Updated merkle tree root\\n  /// @param _pathIndices Merkle path to inserted batch\\n  /// @param _events A batch of inserted events (leaves)\\n  function updateDepositTree(\\n    bytes calldata _proof,\\n    bytes32 _argsHash,\\n    bytes32 _currentRoot,\\n    bytes32 _newRoot,\\n    uint32 _pathIndices,\\n    TreeLeaf[CHUNK_SIZE] calldata _events\\n  ) public {\\n    uint256 offset = lastProcessedDepositLeaf;\\n    require(_currentRoot == depositRoot, \\\"Proposed deposit root is invalid\\\");\\n    require(_pathIndices == offset >> CHUNK_TREE_HEIGHT, \\\"Incorrect deposit insert index\\\");\\n\\n    bytes memory data = new bytes(BYTES_SIZE);\\n    assembly {\\n      mstore(add(data, 0x44), _pathIndices)\\n      mstore(add(data, 0x40), _newRoot)\\n      mstore(add(data, 0x20), _currentRoot)\\n    }\\n    for (uint256 i = 0; i < CHUNK_SIZE; i++) {\\n      (bytes32 hash, address instance, uint32 blockNumber) = (_events[i].hash, _events[i].instance, _events[i].block);\\n      bytes32 leafHash = keccak256(abi.encode(instance, hash, blockNumber));\\n      bytes32 deposit = offset + i >= depositsV1Length ? deposits[offset + i] : tornadoTreesV1.deposits(offset + i);\\n      require(leafHash == deposit, \\\"Incorrect deposit\\\");\\n      assembly {\\n        let itemOffset := add(data, mul(ITEM_SIZE, i))\\n        mstore(add(itemOffset, 0x7c), blockNumber)\\n        mstore(add(itemOffset, 0x78), instance)\\n        mstore(add(itemOffset, 0x64), hash)\\n      }\\n      if (offset + i >= depositsV1Length) {\\n        delete deposits[offset + i];\\n      } else {\\n        emit DepositData(instance, hash, blockNumber, offset + i);\\n      }\\n    }\\n\\n    uint256 argsHash = uint256(sha256(data)) % SNARK_FIELD;\\n    require(argsHash == uint256(_argsHash), \\\"Invalid args hash\\\");\\n    require(treeUpdateVerifier.verifyProof(_proof, [argsHash]), \\\"Invalid deposit tree update proof\\\");\\n\\n    previousDepositRoot = _currentRoot;\\n    depositRoot = _newRoot;\\n    lastProcessedDepositLeaf = offset + CHUNK_SIZE;\\n  }\\n\\n  /// @dev Insert a full batch of queued withdrawals into a merkle tree\\n  /// @param _proof A snark proof that elements were inserted correctly\\n  /// @param _argsHash A hash of snark inputs\\n  /// @param _argsHash Current merkle tree root\\n  /// @param _newRoot Updated merkle tree root\\n  /// @param _pathIndices Merkle path to inserted batch\\n  /// @param _events A batch of inserted events (leaves)\\n  function updateWithdrawalTree(\\n    bytes calldata _proof,\\n    bytes32 _argsHash,\\n    bytes32 _currentRoot,\\n    bytes32 _newRoot,\\n    uint32 _pathIndices,\\n    TreeLeaf[CHUNK_SIZE] calldata _events\\n  ) public {\\n    uint256 offset = lastProcessedWithdrawalLeaf;\\n    require(_currentRoot == withdrawalRoot, \\\"Proposed withdrawal root is invalid\\\");\\n    require(_pathIndices == offset >> CHUNK_TREE_HEIGHT, \\\"Incorrect withdrawal insert index\\\");\\n\\n    bytes memory data = new bytes(BYTES_SIZE);\\n    assembly {\\n      mstore(add(data, 0x44), _pathIndices)\\n      mstore(add(data, 0x40), _newRoot)\\n      mstore(add(data, 0x20), _currentRoot)\\n    }\\n    for (uint256 i = 0; i < CHUNK_SIZE; i++) {\\n      (bytes32 hash, address instance, uint32 blockNumber) = (_events[i].hash, _events[i].instance, _events[i].block);\\n      bytes32 leafHash = keccak256(abi.encode(instance, hash, blockNumber));\\n      bytes32 withdrawal = offset + i >= withdrawalsV1Length ? withdrawals[offset + i] : tornadoTreesV1.withdrawals(offset + i);\\n      require(leafHash == withdrawal, \\\"Incorrect withdrawal\\\");\\n      assembly {\\n        let itemOffset := add(data, mul(ITEM_SIZE, i))\\n        mstore(add(itemOffset, 0x7c), blockNumber)\\n        mstore(add(itemOffset, 0x78), instance)\\n        mstore(add(itemOffset, 0x64), hash)\\n      }\\n      if (offset + i >= withdrawalsV1Length) {\\n        delete withdrawals[offset + i];\\n      } else {\\n        emit WithdrawalData(instance, hash, blockNumber, offset + i);\\n      }\\n    }\\n\\n    uint256 argsHash = uint256(sha256(data)) % SNARK_FIELD;\\n    require(argsHash == uint256(_argsHash), \\\"Invalid args hash\\\");\\n    require(treeUpdateVerifier.verifyProof(_proof, [argsHash]), \\\"Invalid withdrawal tree update proof\\\");\\n\\n    previousWithdrawalRoot = _currentRoot;\\n    withdrawalRoot = _newRoot;\\n    lastProcessedWithdrawalLeaf = offset + CHUNK_SIZE;\\n  }\\n\\n  function validateRoots(bytes32 _depositRoot, bytes32 _withdrawalRoot) public view {\\n    require(_depositRoot == depositRoot || _depositRoot == previousDepositRoot, \\\"Incorrect deposit tree root\\\");\\n    require(_withdrawalRoot == withdrawalRoot || _withdrawalRoot == previousWithdrawalRoot, \\\"Incorrect withdrawal tree root\\\");\\n  }\\n\\n  /// @dev There is no array length getter for deposit and withdrawal arrays\\n  /// in the previous contract, so we have to find them length manually.\\n  /// Used only during deployment\\n  function findArrayLength(\\n    ITornadoTreesV1 _tornadoTreesV1,\\n    string memory _type,\\n    uint256 _from, // most likely array length after the proposal has passed\\n    uint256 _step // optimal step size to find first match, approximately equals dispersion\\n  ) internal view virtual returns (uint256) {\\n    // Find the segment with correct array length\\n    bool direction = elementExists(_tornadoTreesV1, _type, _from);\\n    do {\\n      _from = direction ? _from + _step : _from - _step;\\n    } while (direction == elementExists(_tornadoTreesV1, _type, _from));\\n    uint256 high = direction ? _from : _from + _step;\\n    uint256 low = direction ? _from - _step : _from;\\n    uint256 mid = (high + low) / 2;\\n\\n    // Perform a binary search in this segment\\n    while (low < mid) {\\n      if (elementExists(_tornadoTreesV1, _type, mid)) {\\n        low = mid;\\n      } else {\\n        high = mid;\\n      }\\n      mid = (low + high) / 2;\\n    }\\n    return mid + 1;\\n  }\\n\\n  function elementExists(\\n    ITornadoTreesV1 _tornadoTreesV1,\\n    string memory _type,\\n    uint256 index\\n  ) public view returns (bool success) {\\n    // Try to get the element. If it succeeds the array length is higher, it it reverts the length is equal or lower\\n    (success, ) = address(_tornadoTreesV1).staticcall{ gas: 2500 }(abi.encodeWithSignature(_type, index));\\n  }\\n\\n  function setTornadoProxyContract(address _tornadoProxy) external onlyGovernance {\\n    tornadoProxy = _tornadoProxy;\\n    emit ProxyUpdated(_tornadoProxy);\\n  }\\n\\n  function setVerifierContract(IBatchTreeUpdateVerifier _treeUpdateVerifier) external onlyGovernance {\\n    treeUpdateVerifier = _treeUpdateVerifier;\\n    emit VerifierUpdated(address(_treeUpdateVerifier));\\n  }\\n\\n  function blockNumber() public view virtual returns (uint256) {\\n    return block.number;\\n  }\\n}\\n\"\r\n    },\r\n    \"tornado-trees/contracts/interfaces/ITornadoTreesV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\ninterface ITornadoTreesV1 {\\n  function lastProcessedDepositLeaf() external view returns (uint256);\\n\\n  function lastProcessedWithdrawalLeaf() external view returns (uint256);\\n\\n  function depositRoot() external view returns (bytes32);\\n\\n  function withdrawalRoot() external view returns (bytes32);\\n\\n  function deposits(uint256 i) external view returns (bytes32);\\n\\n  function withdrawals(uint256 i) external view returns (bytes32);\\n\\n  function registerDeposit(address instance, bytes32 commitment) external;\\n\\n  function registerWithdrawal(address instance, bytes32 nullifier) external;\\n}\\n\"\r\n    },\r\n    \"tornado-trees/contracts/interfaces/IBatchTreeUpdateVerifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\ninterface IBatchTreeUpdateVerifier {\\n  function verifyProof(bytes calldata proof, uint256[1] calldata input) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/upgrades-core/contracts/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.4.24 <0.7.0;\\n\\n\\n/**\\n * @title Initializable\\n *\\n * @dev Helper contract to support initializer functions. To use it, replace\\n * the constructor with a function that has the `initializer` modifier.\\n * WARNING: Unlike constructors, initializer functions must be manually\\n * invoked. This applies both to deploying an Initializable contract, as well\\n * as extending an Initializable contract via inheritance.\\n * WARNING: When used with inheritance, manual care must be taken to not invoke\\n * a parent initializer twice, or ensure that all initializers are idempotent,\\n * because this is not dealt with automatically as with constructors.\\n */\\ncontract Initializable {\\n\\n  /**\\n   * @dev Indicates that the contract has been initialized.\\n   */\\n  bool private initialized;\\n\\n  /**\\n   * @dev Indicates that the contract is in the process of being initialized.\\n   */\\n  bool private initializing;\\n\\n  /**\\n   * @dev Modifier to use in the initializer function of a contract.\\n   */\\n  modifier initializer() {\\n    require(initializing || isConstructor() || !initialized, \\\"Contract instance has already been initialized\\\");\\n\\n    bool isTopLevelCall = !initializing;\\n    if (isTopLevelCall) {\\n      initializing = true;\\n      initialized = true;\\n    }\\n\\n    _;\\n\\n    if (isTopLevelCall) {\\n      initializing = false;\\n    }\\n  }\\n\\n  /// @dev Returns true if and only if the function is running in the constructor\\n  function isConstructor() private view returns (bool) {\\n    // extcodesize checks the size of the code stored in an address, and\\n    // address returns the current address. Since the code is still not\\n    // deployed when running a constructor, any checks on its code size will\\n    // yield zero, making it an effective way to detect if a contract is\\n    // under construction or not.\\n    address self = address(this);\\n    uint256 cs;\\n    assembly { cs := extcodesize(self) }\\n    return cs == 0;\\n  }\\n\\n  // Reserved storage space to allow for layout changes in the future.\\n  uint256[50] private ______gap;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_governance\",\"type\":\"address\"},{\"internalType\":\"contract ITornadoTreesV1\",\"name\":\"_tornadoTreesV1\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"depositsFrom\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositsStep\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawalsFrom\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawalsStep\",\"type\":\"uint256\"}],\"internalType\":\"struct TornadoTrees.SearchParams\",\"name\":\"_searchParams\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"instance\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"block\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"DepositData\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newProxy\",\"type\":\"address\"}],\"name\":\"ProxyUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newVerifier\",\"type\":\"address\"}],\"name\":\"VerifierUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"instance\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"block\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"WithdrawalData\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BYTES_SIZE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CHUNK_SIZE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CHUNK_TREE_HEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ITEM_SIZE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SNARK_FIELD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"deposits\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositsV1Length\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ITornadoTreesV1\",\"name\":\"_tornadoTreesV1\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_type\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"elementExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tornadoProxy\",\"type\":\"address\"},{\"internalType\":\"contract IBatchTreeUpdateVerifier\",\"name\":\"_treeUpdateVerifier\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastProcessedDepositLeaf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastProcessedWithdrawalLeaf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"previousDepositRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"previousWithdrawalRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_instance\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_commitment\",\"type\":\"bytes32\"}],\"name\":\"registerDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_instance\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_nullifierHash\",\"type\":\"bytes32\"}],\"name\":\"registerWithdrawal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tornadoProxy\",\"type\":\"address\"}],\"name\":\"setTornadoProxyContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IBatchTreeUpdateVerifier\",\"name\":\"_treeUpdateVerifier\",\"type\":\"address\"}],\"name\":\"setVerifierContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tornadoProxy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tornadoTreesV1\",\"outputs\":[{\"internalType\":\"contract ITornadoTreesV1\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treeUpdateVerifier\",\"outputs\":[{\"internalType\":\"contract IBatchTreeUpdateVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_proof\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"_argsHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_currentRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_newRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"_pathIndices\",\"type\":\"uint32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"instance\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"block\",\"type\":\"uint32\"}],\"internalType\":\"struct TornadoTrees.TreeLeaf[256]\",\"name\":\"_events\",\"type\":\"tuple[256]\"}],\"name\":\"updateDepositTree\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_proof\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"_argsHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_currentRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_newRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"_pathIndices\",\"type\":\"uint32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"instance\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"block\",\"type\":\"uint32\"}],\"internalType\":\"struct TornadoTrees.TreeLeaf[256]\",\"name\":\"_events\",\"type\":\"tuple[256]\"}],\"name\":\"updateWithdrawalTree\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_depositRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_withdrawalRoot\",\"type\":\"bytes32\"}],\"name\":\"validateRoots\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawalRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"withdrawals\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawalsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawalsV1Length\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"TornadoTrees","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000005efda50f22d34f262c29268506c5fa42cb56a1ce00000000000000000000000043a3be4ae954d9869836702afd10393d3a7ea4170000000000000000000000000000000000000000000000000000000000005382000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000035770000000000000000000000000000000000000000000000000000000000000019","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}