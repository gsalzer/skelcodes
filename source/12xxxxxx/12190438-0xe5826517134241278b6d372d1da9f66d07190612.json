{"status":"1","message":"OK","result":[{"SourceCode":"# Copyright (C) 2021 VolumeFi Software, Inc.\r\n\r\n#  This program is free software: you can redistribute it and/or modify\r\n#  it under the terms of the Apache 2.0 License. \r\n#  This program is distributed WITHOUT ANY WARRANTY without even the implied warranty of\r\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\r\n#  @author VolumeFi, Software inc.\r\n#  @notice This Vyper contract adds liquidity to any Sushiswap pool using ETH or any ERC20 Token.\r\n#  SPDX-License-Identifier: Apache-2.0\r\n\r\n# @version ^0.2.0\r\n\r\ninterface ERC20:\r\n    def approve(spender: address, amount: uint256): nonpayable\r\n    def transfer(recipient: address, amount: uint256): nonpayable\r\n    def transferFrom(sender: address, recipient: address, amount: uint256): nonpayable\r\n\r\ninterface SushiswapFactory:\r\n    def getPair(tokenA: address, tokenB: address) -> address: view\r\n    def createPair(tokenA: address, tokenB: address) -> address: nonpayable\r\n\r\ninterface SushiswapPair:\r\n    def token0() -> address: view\r\n    def token1() -> address: view\r\n    def getReserves() -> (uint256, uint256, uint256): view\r\n    def mint(to: address) -> uint256: nonpayable\r\n\r\ninterface SushiswapRouter:\r\n    def addLiquidity(tokenA: address, tokenB: address, amountADesired: uint256, amountBDesired: uint256, amountAMin: uint256, amountBMin: uint256, to: address, deadline: uint256) -> (uint256, uint256, uint256): nonpayable\r\n\r\ninterface WrappedEth:\r\n    def deposit(): payable\r\n\r\nevent LPTokenMint:\r\n    minter: address\r\n    liquidity: uint256\r\n\r\nDEADLINE: constant(uint256) = MAX_UINT256\r\nSUSHISWAPROUTER: constant(address) = 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F\r\nSUSHISWAPFACTORY: constant(address) = 0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac\r\nVETH: constant(address) = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\r\nWETH: constant(address) = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\r\n\r\nadmin: public(address)\r\nfeeAmount: public(uint256)\r\nfeeAddress: public(address)\r\npaused: public(bool)\r\n\r\n@external\r\ndef __init__():\r\n    self.paused = False\r\n    self.admin = msg.sender\r\n    self.feeAddress = 0xf29399fB3311082d9F8e62b988cBA44a5a98ebeD\r\n    self.feeAmount = 5 * 10 ** 15\r\n\r\n@internal\r\n@pure\r\ndef uintSqrt(y: uint256) -> uint256:\r\n    z: uint256 = 0\r\n    x: uint256 = 0\r\n    if y > 3:\r\n        z = y\r\n        x = y / 2 + 1\r\n        for i in range(256):\r\n            if x >= z:\r\n                break\r\n            z = x\r\n            x = (y / x + x) / 2\r\n    elif y != 0:\r\n        z = 1\r\n    else:\r\n        z = 0\r\n    return z\r\n\r\n@internal\r\n@pure\r\ndef _getPairTokens(pair: address) -> (address, address):\r\n    token0: address = SushiswapPair(pair).token0()\r\n    token1: address = SushiswapPair(pair).token1()\r\n    return (token0, token1)\r\n\r\n@internal\r\n@view\r\ndef _calculateSwapInAmount(reserveIn: uint256, userIn: uint256) -> uint256:\r\n    return ((self.uintSqrt(reserveIn * (userIn * 3988000 + reserveIn * 3988009))) - reserveIn * 1997) / 1994\r\n\r\n@internal\r\n@view\r\ndef _getLiquidityInPool(token: address, pair: address) -> uint256:\r\n    res0: uint256 = 0\r\n    res1: uint256 = 0\r\n    token0: address = ZERO_ADDRESS\r\n    token1: address = ZERO_ADDRESS\r\n    blockTimestampLast: uint256 = 0\r\n    (res0, res1, blockTimestampLast) = SushiswapPair(pair).getReserves()\r\n    (token0, token1) = self._getPairTokens(pair)\r\n    assert token0 == token or token1 == token, \"Token ERROR!\"\r\n    if token0 == token:\r\n        return res0\r\n    else:\r\n        return res1\r\n\r\n@internal\r\n@view\r\ndef _getMidToken(midToken: address, token0: address, token1: address) -> address:\r\n    pair0: address = SushiswapFactory(SUSHISWAPFACTORY).getPair(midToken, token0)\r\n    pair1: address = SushiswapFactory(SUSHISWAPFACTORY).getPair(midToken, token1)\r\n    midAmount0: uint256 = self._getLiquidityInPool(midToken, pair0)\r\n    midAmount1: uint256 = self._getLiquidityInPool(midToken, pair1)\r\n    if midAmount0 > midAmount1:\r\n        return token0\r\n    else:\r\n        return token1\r\n\r\n@internal\r\ndef _token2Token(fromToken: address, toToken: address, tokens2Trade: uint256, deadline: uint256) -> uint256:\r\n    if fromToken == toToken:\r\n        return tokens2Trade\r\n    ERC20(fromToken).approve(SUSHISWAPROUTER, 0)\r\n    ERC20(fromToken).approve(SUSHISWAPROUTER, tokens2Trade)\r\n    \r\n    addrBytes: Bytes[288] = concat(convert(tokens2Trade, bytes32), convert(0, bytes32), convert(160, bytes32), convert(self, bytes32), convert(deadline, bytes32), convert(2, bytes32), convert(fromToken, bytes32), convert(toToken, bytes32))\r\n    funcsig: Bytes[4] = method_id(\"swapExactTokensForTokens(uint256,uint256,address[],address,uint256)\")\r\n    full_data: Bytes[292] = concat(funcsig, addrBytes)\r\n    \r\n    _response: Bytes[128] = raw_call(\r\n        SUSHISWAPROUTER,\r\n        full_data,\r\n        max_outsize=128\r\n    )\r\n    tokenBought: uint256 = convert(slice(_response, 96, 32), uint256)\r\n    assert tokenBought > 0, \"Error Swapping Token 2\"\r\n    return tokenBought\r\n\r\n@internal\r\ndef _swap(fromToken: address, pair: address, toSushipoolToken0: address, toSushipoolToken1: address, amount: uint256, deadline: uint256) -> (uint256, uint256):\r\n    res0: uint256 = 0\r\n    res1: uint256 = 0\r\n    blockTimestampLast: uint256 = 0\r\n    (res0, res1, blockTimestampLast) = SushiswapPair(pair).getReserves()\r\n    token1Bought: uint256 = 0\r\n    token0Bought: uint256 = 0\r\n    if (fromToken == toSushipoolToken0):\r\n        amountToSwap: uint256 = self._calculateSwapInAmount(res0, amount)\r\n        if amountToSwap == 0:\r\n            amountToSwap = amount / 2\r\n        token1Bought = self._token2Token(fromToken, toSushipoolToken1, amountToSwap, deadline)\r\n        token0Bought = amount - amountToSwap\r\n    else:\r\n        amountToSwap: uint256 = self._calculateSwapInAmount(res1, amount)\r\n        if amountToSwap == 0:\r\n            amountToSwap = amount / 2\r\n        token0Bought = self._token2Token(fromToken, toSushipoolToken0, amountToSwap, deadline)\r\n        token1Bought = amount - amountToSwap\r\n    return (token0Bought, token1Bought)\r\n\r\n@internal\r\ndef _sushiDeposit(token0: address, token1: address, amount0: uint256, amount1: uint256, sender: address, deadline: uint256) -> uint256:\r\n    ERC20(token0).approve(SUSHISWAPROUTER, 0)\r\n    ERC20(token1).approve(SUSHISWAPROUTER, 0)\r\n    ERC20(token0).approve(SUSHISWAPROUTER, amount0)\r\n    ERC20(token1).approve(SUSHISWAPROUTER, amount1)\r\n    amountA: uint256 = 0\r\n    amountB: uint256 = 0\r\n    LP: uint256 = 0\r\n    (amountA, amountB, LP) = SushiswapRouter(SUSHISWAPROUTER).addLiquidity(token0, token1, amount0, amount1, 1, 1, sender, deadline)\r\n    if amount0 - amountA > 0:\r\n        ERC20(token0).transfer(sender, amount0 - amountA)\r\n    if amount1 - amountB > 0:\r\n        ERC20(token1).transfer(sender, amount1 - amountB)\r\n    return LP\r\n\r\n@internal\r\ndef _performInvest(fromToken:address, pair:address, amount:uint256, sender: address, deadline: uint256) -> uint256:\r\n    toSushiswapToken0: address = ZERO_ADDRESS\r\n    toSushiswapToken1: address = ZERO_ADDRESS\r\n    (toSushiswapToken0, toSushiswapToken1) = self._getPairTokens(pair)\r\n    if fromToken != toSushiswapToken0 and fromToken != toSushiswapToken1:\r\n        raise \"Token Error\"\r\n    token0Bought: uint256 = 0\r\n    token1Bought: uint256 = 0\r\n    (token0Bought, token1Bought) = self._swap(fromToken, pair, toSushiswapToken0, toSushiswapToken1, amount, deadline)\r\n    return self._sushiDeposit(toSushiswapToken0, toSushiswapToken1, token0Bought, token1Bought, sender, deadline)\r\n\r\n@internal\r\ndef _add_liquidity(tokenA: address, tokenB: address, amountADesired: uint256, amountBDesired: uint256, amountAMin: uint256, amountBMin: uint256) -> (uint256, uint256, address):\r\n    pair: address = SushiswapFactory(SUSHISWAPFACTORY).getPair(tokenA, tokenB)\r\n    if pair == ZERO_ADDRESS:\r\n        pair = SushiswapFactory(SUSHISWAPFACTORY).createPair(tokenA, tokenB)\r\n    token0: address = ZERO_ADDRESS\r\n    token1: address = ZERO_ADDRESS\r\n    amount0Min: uint256 = 0\r\n    amount1Min: uint256 = 0\r\n    amount0Desired: uint256 = 0\r\n    amount1Desired: uint256 = 0\r\n    amount0: uint256 = 0\r\n    amount1: uint256 = 0\r\n    ab_swapped: bool = False\r\n    if convert(tokenA, uint256) < convert(tokenB, uint256):\r\n        amount0Min = amountAMin\r\n        amount1Min = amountBMin\r\n        amount0Desired = amountADesired\r\n        amount1Desired = amountBDesired\r\n    else:\r\n        amount0Min = amountBMin\r\n        amount1Min = amountAMin\r\n        amount0Desired = amountBDesired\r\n        amount1Desired = amountADesired\r\n        ab_swapped = True\r\n    reserve0: uint256 = 0\r\n    reserve1: uint256 = 0\r\n    blockTimestampLast: uint256 = 0\r\n    (reserve0, reserve1, blockTimestampLast) = SushiswapPair(pair).getReserves()\r\n    if reserve0 == 0 and reserve1 == 0:\r\n        return (amountADesired, amountBDesired, pair)\r\n    amount1Optimal: uint256 = amount0Desired * reserve1 / reserve0\r\n    if amount1Optimal <= amount1Desired:\r\n        if ab_swapped:\r\n            assert amount1Optimal >= amount1Min, \"INSUFFICIENT_A_AMOUNT\"\r\n            return (amount1Optimal, amount0Desired, pair)\r\n        else:\r\n            assert amount1Optimal >= amount1Min, \"INSUFFICIENT_B_AMOUNT\"\r\n            return (amount0Desired, amount1Optimal, pair)\r\n        \r\n    else:\r\n        amount0Optimal: uint256 = amount1Desired * reserve0 / reserve1\r\n        assert amount0Optimal <= amount0Desired, \"DESIRED AMOUNT ERROR\"\r\n        if ab_swapped:\r\n            assert amount0Optimal >= amount0Min, \"INSUFFICIENT_B_AMOUNT\"\r\n            return (amount1Desired, amount0Optimal, pair)\r\n        else:\r\n            assert amount0Optimal >= amount0Min, \"INSUFFICIENT_A_AMOUNT\"\r\n            return (amount0Optimal, amount1Desired, pair)\r\n\r\n@external\r\n@payable\r\n@nonreentrant('lock')\r\ndef investTokenForSushiPair(token: address, pair: address, amount: uint256, minPoolTokens: uint256, deadline: uint256=DEADLINE) -> uint256:\r\n    assert not self.paused, \"Paused\"\r\n    fee: uint256 = self.feeAmount\r\n    msg_value: uint256 = msg.value\r\n    assert msg.value >= fee, \"Insufficient fee\"\r\n    send(self.feeAddress, fee)\r\n    msg_value -= fee\r\n    assert amount > 0, \"Invalid input amount\"\r\n    token0: address = ZERO_ADDRESS\r\n    token1: address = ZERO_ADDRESS\r\n    (token0, token1) = self._getPairTokens(pair)\r\n    LPBought: uint256 = 0\r\n    midToken: address = WETH\r\n    toInvest: uint256 = 0\r\n    # invest ETH\r\n    if token == VETH or token == ZERO_ADDRESS:\r\n        assert msg_value >= amount, \"ETH not enough\"\r\n        # return remaining ETH\r\n        if msg_value > amount:\r\n            send(msg.sender, msg_value - amount)\r\n        toInvest = amount\r\n        WrappedEth(WETH).deposit(value=toInvest)\r\n    # invest Token\r\n    else:\r\n        ERC20(token).transferFrom(msg.sender, self, amount)\r\n        if msg_value > 0:\r\n            send(msg.sender, msg_value)\r\n        if token == WETH:\r\n            toInvest = amount\r\n        elif token != token0 and token != token1:\r\n            toInvest = self._token2Token(token, WETH, amount, deadline)\r\n        else:\r\n            midToken = token\r\n            toInvest = amount\r\n    if token0 == WETH or token1 == WETH or token == token0 or token == token1:\r\n        LPBought = self._performInvest(midToken, pair, toInvest, msg.sender, deadline)\r\n    else:\r\n        midToken = self._getMidToken(WETH, token0, token1)\r\n        toInvest = self._token2Token(WETH, midToken, toInvest, deadline)\r\n        LPBought = self._performInvest(midToken, pair, toInvest, msg.sender, deadline)\r\n    assert LPBought >= minPoolTokens, \"High Slippage\"\r\n    return LPBought\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef addLiquidity(tokenA: address, tokenB: address, amountADesired: uint256, amountBDesired: uint256, amountAMin: uint256, amountBMin: uint256, to: address, deadline: uint256=DEADLINE) -> (uint256, uint256, uint256):\r\n    assert deadline >= block.timestamp, \"EXPIRED\"\r\n    amountA: uint256 = 0\r\n    amountB: uint256 = 0\r\n    liquidity: uint256 = 0\r\n    pair: address = ZERO_ADDRESS\r\n    (amountA, amountB, pair) = self._add_liquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin)\r\n    ERC20(tokenA).transferFrom(msg.sender, pair, amountA)\r\n    ERC20(tokenB).transferFrom(msg.sender, pair, amountB)\r\n    liquidity = SushiswapPair(pair).mint(to)\r\n    log LPTokenMint(msg.sender, liquidity)\r\n    return (amountA, amountB, liquidity)\r\n\r\n@external\r\n@payable\r\n@nonreentrant('lock')\r\ndef addLiquidityETH(token: address, amountTokenDesired: uint256, amountTokenMin: uint256, amountETHMin: uint256, to: address, deadline: uint256=DEADLINE) -> (uint256, uint256, uint256):\r\n    assert deadline >= block.timestamp, \"EXPIRED\"\r\n    amountToken: uint256 = 0\r\n    amountETH: uint256 = 0\r\n    liquidity: uint256 = 0\r\n    pair: address = ZERO_ADDRESS\r\n    (amountToken, amountETH, pair) = self._add_liquidity(token, WETH, amountTokenDesired, msg.value, amountTokenMin, amountETHMin)\r\n    ERC20(token).transferFrom(msg.sender, pair, amountToken)\r\n    WrappedEth(WETH).deposit(value=amountETH)\r\n    if msg.value > amountETH:\r\n        send(msg.sender, msg.value - amountETH)\r\n    ERC20(WETH).transfer(pair, amountETH)\r\n    liquidity = SushiswapPair(pair).mint(to)\r\n    log LPTokenMint(msg.sender, liquidity)\r\n    return (amountToken, amountETH, liquidity)\r\n\r\n# Admin functions\r\n@external\r\ndef pause(_paused: bool):\r\n    assert msg.sender == self.admin, \"Not admin\"\r\n    self.paused = _paused\r\n\r\n@external\r\ndef newAdmin(_admin: address):\r\n    assert msg.sender == self.admin, \"Not admin\"\r\n    self.admin = _admin\r\n\r\n@external\r\ndef newFeeAmount(_feeAmount: uint256):\r\n    assert msg.sender == self.admin, \"Not admin\"\r\n    self.feeAmount = _feeAmount\r\n\r\n@external\r\ndef newFeeAddress(_feeAddress: address):\r\n    assert msg.sender == self.admin, \"Not admin\"\r\n    self.feeAddress = _feeAddress\r\n\r\n@external\r\n@payable\r\ndef __default__(): pass","ABI":"[{\"name\":\"LPTokenMint\",\"inputs\":[{\"type\":\"address\",\"name\":\"minter\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"liquidity\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"outputs\":[],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"name\":\"investTokenForSushiPair\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"token\"},{\"type\":\"address\",\"name\":\"pair\"},{\"type\":\"uint256\",\"name\":\"amount\"},{\"type\":\"uint256\",\"name\":\"minPoolTokens\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"name\":\"investTokenForSushiPair\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"token\"},{\"type\":\"address\",\"name\":\"pair\"},{\"type\":\"uint256\",\"name\":\"amount\"},{\"type\":\"uint256\",\"name\":\"minPoolTokens\"},{\"type\":\"uint256\",\"name\":\"deadline\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"name\":\"addLiquidity\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"},{\"type\":\"uint256\",\"name\":\"\"},{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"tokenA\"},{\"type\":\"address\",\"name\":\"tokenB\"},{\"type\":\"uint256\",\"name\":\"amountADesired\"},{\"type\":\"uint256\",\"name\":\"amountBDesired\"},{\"type\":\"uint256\",\"name\":\"amountAMin\"},{\"type\":\"uint256\",\"name\":\"amountBMin\"},{\"type\":\"address\",\"name\":\"to\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"name\":\"addLiquidity\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"},{\"type\":\"uint256\",\"name\":\"\"},{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"tokenA\"},{\"type\":\"address\",\"name\":\"tokenB\"},{\"type\":\"uint256\",\"name\":\"amountADesired\"},{\"type\":\"uint256\",\"name\":\"amountBDesired\"},{\"type\":\"uint256\",\"name\":\"amountAMin\"},{\"type\":\"uint256\",\"name\":\"amountBMin\"},{\"type\":\"address\",\"name\":\"to\"},{\"type\":\"uint256\",\"name\":\"deadline\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"name\":\"addLiquidityETH\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"},{\"type\":\"uint256\",\"name\":\"\"},{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"token\"},{\"type\":\"uint256\",\"name\":\"amountTokenDesired\"},{\"type\":\"uint256\",\"name\":\"amountTokenMin\"},{\"type\":\"uint256\",\"name\":\"amountETHMin\"},{\"type\":\"address\",\"name\":\"to\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"name\":\"addLiquidityETH\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"},{\"type\":\"uint256\",\"name\":\"\"},{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"token\"},{\"type\":\"uint256\",\"name\":\"amountTokenDesired\"},{\"type\":\"uint256\",\"name\":\"amountTokenMin\"},{\"type\":\"uint256\",\"name\":\"amountETHMin\"},{\"type\":\"address\",\"name\":\"to\"},{\"type\":\"uint256\",\"name\":\"deadline\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"name\":\"pause\",\"outputs\":[],\"inputs\":[{\"type\":\"bool\",\"name\":\"_paused\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":36727},{\"name\":\"newAdmin\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_admin\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":36757},{\"name\":\"newFeeAmount\",\"outputs\":[],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_feeAmount\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":36687},{\"name\":\"newFeeAddress\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_feeAddress\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":36817},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"name\":\"admin\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1661},{\"name\":\"feeAmount\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1691},{\"name\":\"feeAddress\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1721},{\"name\":\"paused\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1751}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.8","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":""}]}