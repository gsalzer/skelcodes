{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.6.12;\r\n\r\n\r\n// \r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// \r\n/**\r\n * @dev Library for managing\r\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\r\n * types.\r\n *\r\n * Sets have the following properties:\r\n *\r\n * - Elements are added, removed, and checked for existence in constant time\r\n * (O(1)).\r\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\r\n *\r\n * ```\r\n * contract Example {\r\n *     // Add the library methods\r\n *     using EnumerableSet for EnumerableSet.AddressSet;\r\n *\r\n *     // Declare a set state variable\r\n *     EnumerableSet.AddressSet private mySet;\r\n * }\r\n * ```\r\n *\r\n * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\r\n * (`UintSet`) are supported.\r\n */\r\nlibrary EnumerableSet {\r\n    // To implement this library for multiple types with as little code\r\n    // repetition as possible, we write it in terms of a generic Set type with\r\n    // bytes32 values.\r\n    // The Set implementation uses private functions, and user-facing\r\n    // implementations (such as AddressSet) are just wrappers around the\r\n    // underlying Set.\r\n    // This means that we can only create new EnumerableSets for types that fit\r\n    // in bytes32.\r\n\r\n    struct Set {\r\n        // Storage of set values\r\n        bytes32[] _values;\r\n\r\n        // Position of the value in the `values` array, plus 1 because index 0\r\n        // means a value is not in the set.\r\n        mapping (bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        // We read and store the value's index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\r\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\r\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\r\n\r\n            bytes32 lastvalue = set._values[lastIndex];\r\n\r\n            // Move the last value to the index where the value to delete is\r\n            set._values[toDeleteIndex] = lastvalue;\r\n            // Update the index for the moved value\r\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set._values.pop();\r\n\r\n            // Delete the index for the deleted slot\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\r\n        return set._values[index];\r\n    }\r\n\r\n    // AddressSet\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        return address(uint256(_at(set._inner, index)));\r\n    }\r\n\r\n\r\n    // UintSet\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n}\r\n\r\n// \r\ninterface IMMStrategyHarvestKp3r {\r\n    event Keep3rSet(address keep3r);\r\n    event Keep3rHelperSet(address keep3rHelper);\r\n    event SlidingOracleSet(address slidingOracle);\r\n\r\n    // Actions by Keeper\r\n    event HarvestedByKeeper(address _strategy);\r\n\t\r\n    // Harvestable check\r\n    event HarvestableCheck(address _strategy, uint256 profitTokenAmount, uint256 profitFactor, uint256 profitInEther, uint256 ethCallCost);\r\n\r\n    // Setters\r\n    function setKeep3r(address _keep3r) external;\r\n\r\n    function setKeep3rHelper(address _keep3rHelper) external;\r\n\r\n    function setSlidingOracle(address _slidingOracle) external;\r\n\r\n    function setSushiSlidingOracle(address _sushiSlidingOracle) external;\r\n\t\r\n    function setMinHarvestInterval(uint256 _interval) external;\r\n\t\r\n    function setProfitFactor(uint256 _profitFactor) external;\r\n\r\n    // Getters\r\n    function getStrategies() external view returns (address[] memory);\r\n    function getCollateralizedStrategies() external view returns (address[] memory);\r\n    function getVaults() external view returns (address[] memory);\r\n\r\n    // psuedo view method, please use something similar to below tool to query\r\n    // https://docs.ethers.io/v5/api/contract/contract/#contract-callStatic \r\n    function harvestable(address _strategy) external returns (bool);\r\n\r\n    // harvest actions for Keep3r\r\n    function harvest(address _strategy) external;\r\n    \r\n    // earn() actions for Keep3r\r\n    function earnable(address _strategy) external view returns (bool);\r\n    function earn(address _strategy) external;\r\n    \r\n    // keepMinRatio() actions for Keep3r\r\n    function keepMinRatioMayday(address _strategy) external view returns (bool);\r\n    function keepMinRatio(address _strategy) external;\r\n\r\n    // Name of the Keep3r\r\n    function name() external pure returns (string memory);\r\n\r\n    event HarvestStrategyAdded(address _vault, address _strategy, uint256 _requiredHarvest, bool _requiredKeepMinRatio, bool _requiredLeverageToMax, address yieldToken, uint256 yieldTokenOracle);\r\n\r\n    event EarnVaultAdded(address _vault, uint256 _requiredEarnBalance);\r\n\r\n    event HarvestStrategyModified(address _strategy, uint256 _requiredHarvest);\r\n\r\n    event EarnVaultModified(address _vault, uint256 _requiredEarnBalance);\r\n\r\n    event HarvestStrategyRemoved(address _strategy);\r\n\r\n    event EarnVaultRemoved(address _vault);\r\n\r\n    // Modifiers\r\n    function addStrategy(address _vault, address _strategy, uint256 _requiredHarvest, bool _requiredKeepMinRatio, bool _requiredLeverageToMax, address yieldToken, uint256 yieldTokenOracle) external;\r\n    \r\n    function addVault(address _vault, uint256 _requiredEarnBalance) external;\r\n\r\n    function updateRequiredHarvestAmount(address _strategy, uint256 _requiredHarvest) external;\r\n    \r\n    function updateYieldTokenOracle(address _strategy, uint256 _yieldTokenOracle) external;\r\n    \r\n    function updateRequiredEarn(address _vault, uint256 _requiredEarnBalance) external;\r\n\r\n    function removeHarvestStrategy(address _strategy) external;\r\n\r\n    function removeEarnVault(address _vault) external;\r\n\r\n}\r\n\r\n// \r\ninterface IKeep3rV1 {\r\n    function KPRH() external returns (address);\r\n\r\n    function name() external returns (string memory);\r\n\r\n    function isKeeper(address) external returns (bool);\r\n\r\n    function worked(address keeper) external;\r\n\r\n    function addKPRCredit(address job, uint256 amount) external;\r\n\r\n    function addJob(address job) external;\r\n}\r\n\r\n// \r\nabstract contract Keep3r {\r\n    IKeep3rV1 public keep3r;\r\n\r\n    constructor(address _keep3r) public {\r\n        _setKeep3r(_keep3r);\r\n    }\r\n\r\n    function _setKeep3r(address _keep3r) internal {\r\n        keep3r = IKeep3rV1(_keep3r);\r\n    }\r\n\r\n    function _isKeeper() internal {\r\n        require(tx.origin == msg.sender, \"keep3r::isKeeper:keeper-is-a-smart-contract\");\r\n        require(keep3r.isKeeper(msg.sender), \"keep3r::isKeeper:keeper-is-not-registered\");\r\n    }\r\n\r\n    // Only checks if caller is a valid keeper, payment should be handled manually\r\n    modifier onlyKeeper() {\r\n        _isKeeper();\r\n        _;\r\n    }\r\n\r\n    // Checks if caller is a valid keeper, handles default payment after execution\r\n    modifier paysKeeper() {\r\n        _isKeeper();\r\n        _;\r\n        keep3r.worked(msg.sender);\r\n    }\r\n}\r\n\r\n// \r\ninterface IKeep3rV1Helper {\r\n    function getQuoteLimit(uint256 gasUsed) external view returns (uint256);\r\n}\r\n\r\n// \r\ninterface IUniswapV2SlidingOracle {\r\n    function current(\r\n        address tokenIn,\r\n        uint256 amountIn,\r\n        address tokenOut\r\n    ) external view returns (uint256);\r\n    function work() external;\r\n    function updatePair(address pair) external;\r\n    function observationLength(address pair) external view returns (uint);\r\n    function lastObservation(address pair) external view returns (uint timestamp, uint price0Cumulative, uint price1Cumulative);\r\n    function observations(address pair, uint256 idx) external view returns (uint timestamp, uint price0Cumulative, uint price1Cumulative);\r\n}\r\n\r\n// \r\ninterface IStrategy {\r\n    function rewards() external view returns (address);\r\n\r\n    function gauge() external view returns (address);\r\n\r\n    function want() external view returns (address);\r\n\r\n    function timelock() external view returns (address);\r\n\r\n    function deposit() external;\r\n\r\n    function withdraw(address) external;\r\n\r\n    function withdraw(uint256, address) external;\r\n\r\n    function skim() external;\r\n\r\n    function withdrawAll() external returns (uint256);\r\n\r\n    function balanceOf() external view returns (uint256);\r\n\r\n    function harvest() external;\r\n\r\n    function setTimelock(address) external;\r\n\r\n    function setController(address _controller) external;\r\n\r\n    function execute(address _target, bytes calldata _data)\r\n        external\r\n        payable\r\n        returns (bytes memory response);\r\n\r\n    function execute(bytes calldata _data)\r\n        external\r\n        payable\r\n        returns (bytes memory response);\r\n}\r\n\r\n// \r\ninterface ICrvStrategy is IStrategy {\r\n    function getHarvestable() external returns (uint256);\r\n}\r\n\r\n// \r\ninterface ICompStrategy is IStrategy {\r\n    function getCompAccrued() external returns (uint256);\r\n}\r\n\r\n// \r\ninterface ILeveragedStrategy is IStrategy {\r\n    function leverageToMax() external;\r\n}\r\n\r\n// \r\ninterface ICollateralizedStrategy is IStrategy {\r\n    function keepMinRatio() external;\r\n    function currentRatio() external view returns (uint256);\r\n    function minRatio() external view returns (uint256);\r\n    function setMinRatio(uint256 _minRatio) external;\r\n}\r\n\r\n// \r\ninterface IVault {\r\n    function earn() external;\r\n    function token() external view returns (address);\r\n}\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\ninterface MMController {\r\n    function vaults(address _wantToken) external view returns (address);\r\n    function strategies(address _wantToken) external view returns (address);\r\n}\r\n\r\ninterface KeeperCompatibleInterface {\r\n    function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\r\n    function performUpkeep(bytes calldata performData) external;\r\n}\r\n\r\n//\r\n// inspired by & thanks to https://macarse.medium.com/the-keep3r-network-experiment-bb1c5182bda3\r\n//\r\ncontract GenericKeep3rV2 is Keep3r, IMMStrategyHarvestKp3r, KeeperCompatibleInterface {\r\n    using SafeMath for uint256;\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n\r\n    EnumerableSet.AddressSet internal availableStrategies;\r\n    EnumerableSet.AddressSet internal leveragedStrategies;\r\n    EnumerableSet.AddressSet internal collateralizedStrategies;\r\n    EnumerableSet.AddressSet internal availableVaults;\r\n    \r\n    // one-to-one mapping from vault to strategy\r\n    mapping(address => address) public vaultStrategies;\r\n    // required gas cost on strategy harvest()\r\n    mapping(address => uint256) public requiredHarvest;\r\n    // last harvest timestamp for strategy\r\n    mapping(address => uint256) public strategyLastHarvest;\r\n    // profit token yield by strategy harvest()\r\n    mapping(address => address) public stratagyYieldTokens;\r\n    // oracles used in harvest() for strategy: \r\n    //    0 : slidingOracle \r\n    //    1 : sushiSlidingOracle \r\n    //    anything > 1 : simply use token number instead price oracle\r\n    mapping(address => uint256) public stratagyYieldTokenOracles;\r\n    // required minimum token available for vault earn(), may subject to change to make this job reasonable\r\n    mapping(address => uint256) public requiredEarnBalance;\r\n    \r\n    address public keep3rHelper;\r\n    address public slidingOracle;\r\n    address public sushiSlidingOracle;\r\n    address public mmController;\r\n\r\n    address public constant KP3R = address(0x1cEB5cB57C4D4E2b2433641b95Dd330A33185A44);\r\n    address public constant WETH = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\r\n    address public constant CRV = address(0xD533a949740bb3306d119CC777fa900bA034cd52);\r\n    address public constant COMP = address(0xc00e94Cb662C3520282E6f5717214004A7f26888);\r\n    address public constant MIR = address(0x09a3EcAFa817268f77BE1283176B946C4ff2E608);\r\n    address public constant PICKLE = address(0x429881672B9AE42b8EbA0E26cD9C73711b891Ca5);\r\n    address public constant TRU = address(0x4C19596f5aAfF459fA38B0f7eD92F11AE6543784);\r\n    address public constant CVXCRV = address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);\r\n    address public constant THREECRV = address(0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490);\r\n    address public constant CRVRENWBTC = address(0x49849C98ae39Fff122806C06791Fa73784FB3675);\r\n    address public constant DAI = address(0x6B175474E89094C44Da98b954EedeAC495271d0F );\r\n    address public constant USDC = address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48 );\r\n    address public constant MIRUSTLP = address(0x87dA823B6fC8EB8575a235A824690fda94674c88 );\r\n    address public constant WBTC = address(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599);\r\n    address public constant LINK = address(0x514910771AF9Ca656af840dff83E8264EcF986CA);\r\n    address public constant ZRX = address(0xE41d2489571d322189246DaFA5ebDe1F4699F498);\r\n    address public constant ALCX = address(0xdBdb4d16EdA451D0503b854CF79D55697F90c8DF);\r\n    address public constant ALUSD = address(0xBC6DA0FE9aD5f3b0d58160288917AA56653660E9);\r\n    address public constant USDP3CRV = address(0x7Eb40E450b9655f4B3cC4259BCC731c63ff55ae6);\r\n    address public constant RENBTC = address(0xEB4C2781e4ebA804CE9a9803C67d0893436bB27D);\r\n    address public constant YVECRV = address(0xc5bDdf9843308380375a611c18B50Fb9341f502A);\r\n    address public constant TUSD = address(0x0000000000085d4780B73119b644AE5ecd22b376);\r\n    address public constant CVX = address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);\r\n    uint256 public constant UNISWAP_ORACLE = 0;\r\n    uint256 public constant SUSHISWAP_ORACLE = 1;\r\n\r\n    bytes4 public constant earnForChainlinkMethodId = bytes4(keccak256(\"earnForChainlink(address)\"));\r\n    bytes4 public constant harvestForChainlinkMethodId = bytes4(keccak256(\"harvestForChainlink(address)\"));\r\n    bytes4 public constant keepMinRatioForChainlinkMethodId = bytes4(keccak256(\"keepMinRatioForChainlink(address)\"));\r\n    bytes4 public constant earnableMethodId = bytes4(keccak256(\"earnable(address)\"));\r\n    bytes4 public constant harvestableMethodId = bytes4(keccak256(\"harvestable(address)\"));\r\n    bytes4 public constant keepMinRatioableMethodId = bytes4(keccak256(\"keepMinRatioMayday(address)\"));\r\n\r\n    // The minimum number of seconds between harvest calls, once half a day\r\n    uint256 public minHarvestInterval = 43200;\r\n\r\n    // The minimum multiple that `callCost` must be above the profit to be \"justifiable\"\r\n    uint256 public profitFactor = 1;\r\n\r\n    // The minimum bps setting for keepMinRatio\r\n    uint256 public keepMinRatioMaydayTrigger = 9000;\r\n\r\n    address public governor;\r\n\r\n    constructor(\r\n        address _keep3r,\r\n        address _keep3rHelper,\r\n        address _slidingOracle,\r\n        address _sushiSlidingOracle,\r\n        address _mmController\r\n    ) public Keep3r(_keep3r) {\r\n        \r\n        keep3rHelper = _keep3rHelper;\r\n        slidingOracle = _slidingOracle;\r\n        sushiSlidingOracle = _sushiSlidingOracle;\r\n        governor = msg.sender;\r\n        mmController = _mmController;\r\n    \r\n        // add exisitng vaults         \r\n        addVault(MMController(_mmController).vaults(THREECRV), 5000 * 1e18);     // Matsutake Field   3CRV\r\n        addVault(MMController(_mmController).vaults(CRVRENWBTC), 1 * 1e18);      // Boletus Field     crvRENWBTC\r\n        addVault(MMController(_mmController).vaults(DAI), 5000 * 1e18);          // Kikurage Field    DAI\r\n        addVault(MMController(_mmController).vaults(USDC), 5000 * 1e6);          // Lentinula Field   USDC\r\n        addVault(MMController(_mmController).vaults(MIRUSTLP), 1000 * 1e18);     // Agaricus Field    MIR-UST LP\r\n        addVault(MMController(_mmController).vaults(WETH), 5 * 1e18);            // Russula Field     WETH\r\n        addVault(MMController(_mmController).vaults(WBTC), 1 * 1e8);             // Pleurotus Field   WBTC\r\n        addVault(MMController(_mmController).vaults(LINK), 500 * 1e18);          // Calvatia Field    LINK\r\n        addVault(MMController(_mmController).vaults(ZRX), 5000 * 1e18);          // Helvella Field    ZRX\r\n        addVault(MMController(_mmController).vaults(ALCX), 20 * 1e18);           // Geastrum Field    ALCX\r\n        addVault(MMController(_mmController).vaults(ALUSD), 5000 * 1e18);        // Aleuria Field     ALUSD\r\n        addVault(MMController(_mmController).vaults(USDP3CRV), 5000 * 1e18);     // Lycoperdon Field  USDP3CRV\r\n        addVault(MMController(_mmController).vaults(RENBTC), 1 * 1e8);           // Rhizopogon Field  RENBTC\r\n        addVault(MMController(_mmController).vaults(YVECRV), 5000 * 1e18);       // Chaga Field       YVECRV\r\n        addVault(MMController(_mmController).vaults(TUSD), 5000 * 1e18);         // Lepista Field     TUSD\r\n        addVault(MMController(_mmController).vaults(CVX), 2000 * 1e18);          // Tremella Field    CVX\r\n        \r\n        // add exisitng strategies\r\n        addStrategy(MMController(_mmController).vaults(THREECRV), MMController(_mmController).strategies(THREECRV), 1000000, false, false, CRV, 300 * 1e18);            // 3CRV              Yield $CRV\r\n        addStrategy(MMController(_mmController).vaults(CRVRENWBTC), MMController(_mmController).strategies(CRVRENWBTC), 1000000, false, false, CRV, 300 * 1e18);        // crvRENWBTC        Yield $CRV\r\n        addStrategy(MMController(_mmController).vaults(DAI), MMController(_mmController).strategies(DAI), 700000, false, true, COMP, 3 * 1e18);                         // DAI               Leveraged Yield $COMP\r\n        addStrategy(MMController(_mmController).vaults(USDC), MMController(_mmController).strategies(USDC), 700000, false, true, COMP, 3 * 1e18);                       // USDC              Leveraged Yield $COMP\r\n        addStrategy(MMController(_mmController).vaults(MIRUSTLP), MMController(_mmController).strategies(MIRUSTLP), 850000, false, false, MIR, 1000 * 1e18);            // MIR-UST LP        Yield $MIR\r\n        addStrategy(MMController(_mmController).vaults(WETH), MMController(_mmController).strategies(WETH), 1100000, true, false, CRV, 300 * 1e18);                     // WETH              Collateralized LP Yield $CRV\r\n        addStrategy(MMController(_mmController).vaults(WBTC), MMController(_mmController).strategies(WBTC), 700000, false, true, COMP, 10 * 1e18);                      // WBTC              Leveraged Yield $COMP\r\n        addStrategy(MMController(_mmController).vaults(LINK), MMController(_mmController).strategies(LINK), 1100000, false, false, CRV, 300 * 1e18);                    // LINK              LP Yield $CRV\r\n        addStrategy(MMController(_mmController).vaults(ZRX), MMController(_mmController).strategies(ZRX), 1100000, false, false, COMP, 3 * 1e18);                       // ZRX               Leveraged Yield $COMP\r\n        addStrategy(MMController(_mmController).vaults(ALCX), MMController(_mmController).strategies(ALCX), 400000, false, false, ALCX, 3 * 1e18);                      // ALCX              Yield $ALCX\r\n        //addStrategy(MMController(_mmController).vaults(ALUSD), MMController(_mmController).strategies(ALUSD), 500000, false, false, CRV, 200 * 1e18);                 // ALUSD             LP Yield $CRV\r\n        addStrategy(MMController(_mmController).vaults(USDP3CRV), MMController(_mmController).strategies(USDP3CRV), 1200000, false, false, CRV, 300 * 1e18);            // USDP3CRV          Yield $CRV\r\n        addStrategy(MMController(_mmController).vaults(RENBTC), MMController(_mmController).strategies(RENBTC), 1200000, false, false, CRV, 300 * 1e18);                // RENBTC            LP Yield $CRV\r\n        addStrategy(MMController(_mmController).vaults(YVECRV), MMController(_mmController).strategies(YVECRV), 900000, false, false, PICKLE, 100 * 1e18);              // YVECRV            LP Yield $PICKLE\r\n        addStrategy(MMController(_mmController).vaults(TUSD), MMController(_mmController).strategies(TUSD), 1400000, false, false, TRU, 300 * 1e18);                    // TUSD              Yield $TRU\r\n        addStrategy(MMController(_mmController).vaults(CVX), MMController(_mmController).strategies(CVX), 600000, false, false, CVXCRV, 300 * 1e18);                    // CVX               Yield $CVXCRV\r\n    }\r\n\r\n    modifier onlyGovernor {\r\n        require(msg.sender == governor, \"governable::only-governor\");\r\n        _;\r\n    }\r\n\r\n    function _setGovernor(address _governor) external onlyGovernor {\r\n        require(_governor != address(0), \"governable::governor-should-not-be-zero-addres\");\r\n        governor = _governor;\r\n    }\r\n\r\n    // Unique method to add a strategy with specified parameters to the system\r\n    function addStrategy(address _vault, address _strategy, uint256 _requiredHarvest, bool _requiredKeepMinRatio, bool _requiredLeverageToMax, address yieldToken, uint256 yieldTokenOracle) public override onlyGovernor {\r\n        _addHarvestStrategy(_vault, _strategy, _requiredHarvest);\r\n        availableStrategies.add(_strategy);\r\n        stratagyYieldTokens[_strategy] = yieldToken;\r\n        stratagyYieldTokenOracles[_strategy] = yieldTokenOracle;\r\n        if (_requiredKeepMinRatio){\r\n            collateralizedStrategies.add(_strategy);\r\n        }\r\n        if (_requiredLeverageToMax){\r\n            leveragedStrategies.add(_strategy);\r\n        }\r\n        emit HarvestStrategyAdded(_vault, _strategy, _requiredHarvest, _requiredKeepMinRatio, _requiredLeverageToMax, yieldToken, yieldTokenOracle);\r\n    }\r\n\r\n    function _addHarvestStrategy(address _vault, address _strategy, uint256 _requiredHarvest) internal {\r\n        require(availableVaults.contains(_vault), \"generic-keep3r-v2:!availableVaults\");\r\n        require(requiredHarvest[_strategy] == 0 && !availableStrategies.contains(_strategy), \"generic-keep3r-v2:!requiredHarvest:strategy-already-added\");\r\n        _setRequiredHarvest(_strategy, _requiredHarvest);\r\n        vaultStrategies[_vault] = _strategy;\r\n    }\r\n    \r\n    // Unique method to add a vault with specified parameters to the system\r\n    function addVault(address _vault, uint256 _requiredEarnBalance) public override onlyGovernor {\r\n        require(!availableVaults.contains(_vault), \"generic-keep3r-v2:!requiredEarn:vault-already-added\");\r\n        availableVaults.add(_vault);\r\n        _setRequiredEarn(_vault, _requiredEarnBalance);\r\n        emit EarnVaultAdded(_vault, _requiredEarnBalance);\r\n    }\r\n\r\n    // Unique method to update a strategy with specified gas cost\r\n    function updateRequiredHarvestAmount(address _strategy, uint256 _requiredHarvest) external override onlyGovernor {\r\n        require(requiredHarvest[_strategy] > 0 && availableStrategies.contains(_strategy), \"generic-keep3r-v2::update-required-harvest:strategy-not-added\");\r\n        _setRequiredHarvest(_strategy, _requiredHarvest);\r\n        emit HarvestStrategyModified(_strategy, _requiredHarvest);\r\n    }\r\n\r\n    // Unique method to update a strategy with specified yield token oracle type\r\n    function updateYieldTokenOracle(address _strategy, uint256 _yieldTokenOracle) external override onlyGovernor {\r\n        require(requiredHarvest[_strategy] > 0 && availableStrategies.contains(_strategy), \"generic-keep3r-v2::update-yield-token-oracle:strategy-not-added\");\r\n        stratagyYieldTokenOracles[_strategy] = _yieldTokenOracle;\r\n    }\r\n\r\n    // Unique method to update a vault with specified required want token number for earn()\r\n    function updateRequiredEarn(address _vault, uint256 _requiredEarnBalance) external override onlyGovernor {\r\n        require(availableVaults.contains(_vault), \"generic-keep3r-v2::update-required-earn:vault-not-added\");\r\n        _setRequiredEarn(_vault, _requiredEarnBalance);\r\n        emit EarnVaultModified(_vault, _requiredEarnBalance);\r\n    }\r\n\r\n    function removeHarvestStrategy(address _strategy) public override onlyGovernor {\r\n        require(requiredHarvest[_strategy] > 0 && availableStrategies.contains(_strategy), \"generic-keep3r-v2::remove-harvest-strategy:strategy-not-added\");\r\n        \r\n        delete requiredHarvest[_strategy];\r\n        availableStrategies.remove(_strategy);\r\n        \r\n        if (collateralizedStrategies.contains(_strategy)){\r\n            collateralizedStrategies.remove(_strategy);\r\n        }\r\n        \r\n        if (leveragedStrategies.contains(_strategy)){\r\n            leveragedStrategies.remove(_strategy);\r\n        }\r\n        \r\n        emit HarvestStrategyRemoved(_strategy);\r\n    }\r\n\r\n    function removeEarnVault(address _vault) external override onlyGovernor {\r\n        require(availableVaults.contains(_vault), \"generic-keep3r-v2::remove-earn-vault:vault-not-added\");\r\n        \r\n        address _strategy = vaultStrategies[_vault];\r\n        if (_strategy != address(0) && requiredHarvest[_strategy] > 0 && availableStrategies.contains(_strategy)){\r\n            removeHarvestStrategy(_strategy);\r\n            delete vaultStrategies[_vault];\r\n        }\r\n        \r\n        delete requiredEarnBalance[_vault];\r\n        availableVaults.remove(_vault);\r\n        \r\n        emit EarnVaultRemoved(_vault);\r\n    }\r\n\r\n    function setMinHarvestInterval(uint256 _interval) external override onlyGovernor {\r\n        require(_interval > 0, \"!_interval\");\r\n        minHarvestInterval = _interval;\r\n    }\r\n\r\n    function setProfitFactor(uint256 _profitFactor) external override onlyGovernor {\r\n        require(_profitFactor > 0, \"!_profitFactor\");\r\n        profitFactor = _profitFactor;\r\n    }\r\n\r\n    function setKeepMinRatioMaydayTrigger(uint256 _keepMinRatioTrigger) external onlyGovernor {\r\n        require(_keepMinRatioTrigger > 100 && _keepMinRatioTrigger < 10000, \"!_keepMinRatioTrigger\");\r\n        keepMinRatioMaydayTrigger = _keepMinRatioTrigger;\r\n    }\r\n\r\n    function setKeep3r(address _keep3r) external override onlyGovernor {\r\n        _setKeep3r(_keep3r);\r\n        emit Keep3rSet(_keep3r);\r\n    }\r\n\r\n    function setKeep3rHelper(address _keep3rHelper) external override onlyGovernor {\r\n        keep3rHelper = _keep3rHelper;\r\n        emit Keep3rHelperSet(_keep3rHelper);\r\n    }\r\n\r\n    function setSlidingOracle(address _slidingOracle) external override onlyGovernor {\r\n        slidingOracle = _slidingOracle;\r\n        emit SlidingOracleSet(_slidingOracle);\r\n    }\r\n\r\n    function setSushiSlidingOracle(address _sushiSlidingOracle) external override onlyGovernor {\r\n        sushiSlidingOracle = _sushiSlidingOracle;\r\n    }\r\n\r\n    function _setRequiredEarn(address _vault, uint256 _requiredEarnBalance) internal {\r\n        if (_requiredEarnBalance > 0){\r\n            requiredEarnBalance[_vault] = _requiredEarnBalance;\r\n        }\r\n    }\r\n\r\n    function _setRequiredHarvest(address _strategy, uint256 _requiredHarvest) internal {\r\n        if (_requiredHarvest > 0){\r\n            requiredHarvest[_strategy] = _requiredHarvest;\r\n        }\r\n    }\r\n\r\n    // Getters\r\n    function name() external pure override returns (string memory) {\r\n        return \"Generic Keep3r for Mushrooms Finance\";\r\n    }\r\n\r\n    function getStrategies() public view override returns (address[] memory _strategies) {\r\n        _strategies = new address[](availableStrategies.length());\r\n        for (uint256 i; i < availableStrategies.length(); i++) {\r\n            _strategies[i] = availableStrategies.at(i);\r\n        }\r\n    }\r\n\r\n    function getCollateralizedStrategies() public view override returns (address[] memory _strategies) {\r\n        _strategies = new address[](collateralizedStrategies.length());\r\n        for (uint256 i; i < collateralizedStrategies.length(); i++) {\r\n            _strategies[i] = collateralizedStrategies.at(i);\r\n        }\r\n    }\r\n\r\n    function getVaults() public view override returns (address[] memory _vaults) {\r\n        _vaults = new address[](availableVaults.length());\r\n        for (uint256 i; i < availableVaults.length(); i++) {\r\n            _vaults[i] = availableVaults.at(i);\r\n        }\r\n    }\r\n\r\n    // this method is not specified as view since some strategy maybe not able to return accurate underlying profit in snapshot,\r\n\t// please use something similar to below tool to query\r\n\t// https://docs.ethers.io/v5/api/contract/contract/#contract-callStatic\r\n    function harvestable(address _strategy) public override returns (bool) {\r\n        require(requiredHarvest[_strategy] > 0, \"generic-keep3r-v2::harvestable:strategy-not-added\");\r\n\r\n        // Should not trigger if had been called recently\r\n        if (strategyLastHarvest[_strategy] > 0 && block.timestamp.sub(strategyLastHarvest[_strategy]) <= minHarvestInterval){\r\n            return false;\r\n        }\r\n\r\n        uint256 ethCallCost = 0;\r\n        \r\n        // estimate yield profit to harvest\r\n        uint256 profitTokenAmount = 0;\r\n        address yieldToken = stratagyYieldTokens[_strategy];\r\n        uint256 yieldTokenOracle = stratagyYieldTokenOracles[_strategy];\r\n        if (yieldToken == COMP){\r\n            profitTokenAmount = ICompStrategy(_strategy).getCompAccrued();\r\n        } else{\r\n            profitTokenAmount = ICrvStrategy(_strategy).getHarvestable();\r\n        }\r\n            \r\n        if (yieldTokenOracle > SUSHISWAP_ORACLE){ // no oracle to use, just use token number\r\n            emit HarvestableCheck(_strategy, profitTokenAmount, profitFactor, 0, ethCallCost);\r\n            return (profitTokenAmount >= yieldTokenOracle);\r\n        } else{\r\n            // quote from keep3r network for specified workload\r\n            uint256 kp3rCallCost = IKeep3rV1Helper(keep3rHelper).getQuoteLimit(requiredHarvest[_strategy]);\r\n            // get ETH gas cost by querying uniswap sliding oracle\r\n            ethCallCost = IUniswapV2SlidingOracle(sushiSlidingOracle).current(KP3R, kp3rCallCost, WETH);\r\n\r\n            address oracle = yieldTokenOracle == UNISWAP_ORACLE? slidingOracle : sushiSlidingOracle;\r\n            uint256 profitInEther = IUniswapV2SlidingOracle(oracle).current(yieldToken, profitTokenAmount, WETH);\r\n            emit HarvestableCheck(_strategy, profitTokenAmount, profitFactor, profitInEther, ethCallCost);\r\n            return (profitInEther >= profitFactor.mul(ethCallCost));\r\n        }\r\n    }\r\n    \r\n    function earnable(address _vault) public view override returns (bool) {\r\n        require(availableVaults.contains(_vault), \"generic-keep3r-v2::earnable:vault-not-added\");\r\n        return (IERC20(IVault(_vault).token()).balanceOf(_vault) >= requiredEarnBalance[_vault]);\r\n    }\r\n    \r\n    function keepMinRatioMayday(address _strategy) public view override returns (bool) {\r\n        require(collateralizedStrategies.contains(_strategy), \"generic-keep3r-v2::keepMinRatioMayday:strategy-not-added\");\r\n        return ICollateralizedStrategy(_strategy).currentRatio() <= (ICollateralizedStrategy(_strategy).minRatio() * keepMinRatioMaydayTrigger / 10000);\r\n    }\r\n\r\n    // harvest() actions for Keep3r\r\n    function harvest(address _strategy) external override paysKeeper {\r\n        require(harvestable(_strategy), \"generic-keep3r-v2::harvest:not-workable\");\r\n        IStrategy(_strategy).harvest();\r\n        strategyLastHarvest[_strategy] = block.timestamp;\r\n        emit HarvestedByKeeper(_strategy);\r\n    }\r\n\r\n    // earn() actions for Keep3r\r\n    function earn(address _vault) external override paysKeeper {\r\n        require(earnable(_vault), \"generic-keep3r-v2::earn:not-workable\");\r\n        IVault(_vault).earn();\r\n        address _strategy = vaultStrategies[_vault];\r\n        if (_strategy != address(0) && requiredHarvest[_strategy] > 0 && leveragedStrategies.contains(_strategy)){\r\n            ILeveragedStrategy(_strategy).leverageToMax();\r\n        }\r\n    }\r\n\r\n    // keepMinRatio() actions for Keep3r\r\n    function keepMinRatio(address _strategy) external override paysKeeper {\r\n        require(keepMinRatioMayday(_strategy), \"generic-keep3r-v2::keepMinRatio:not-workable\");\r\n        ICollateralizedStrategy(_strategy).keepMinRatio();\r\n    }\r\n\r\n    //chainlink keep job start--------\r\n    // harvest() actions for chainlink keeper\r\n    function harvestForChainlink(address _strategy) public {\r\n        require(msg.sender == address(this), \"!this\");\r\n        require(harvestable(_strategy), \"generic-chainlink-keeper-v2::harvest:not-workable\");\r\n        IStrategy(_strategy).harvest();\r\n        strategyLastHarvest[_strategy] = block.timestamp;\r\n        emit HarvestedByKeeper(_strategy);\r\n    }\r\n\r\n    // earn() actions for chainlink keeper\r\n    function earnForChainlink(address _vault) public {\r\n        require(msg.sender == address(this), \"!this\");\r\n        require(earnable(_vault), \"generic-chainlink-keeper-v2::earn:not-workable\");\r\n        IVault(_vault).earn();\r\n        address _strategy = vaultStrategies[_vault];\r\n        if (_strategy != address(0) && requiredHarvest[_strategy] > 0 && leveragedStrategies.contains(_strategy)){\r\n            ILeveragedStrategy(_strategy).leverageToMax();\r\n        }\r\n    }\r\n\r\n    // keepMinRatio() actions for chainlink keeper\r\n    function keepMinRatioForChainlink(address _strategy) public {\r\n        require(msg.sender == address(this), \"!this\");\r\n        require(keepMinRatioMayday(_strategy), \"generic-chainlink-keeper-v2::keepMinRatio:not-workable\");\r\n        ICollateralizedStrategy(_strategy).keepMinRatio();\r\n    }\r\n\r\n    function checkUpkeep(bytes calldata checkData) external override returns (bool upkeepNeeded, bytes memory performData) {\r\n        require(checkCallData(checkData), \"bad checkData\");\r\n\r\n        (bool success,bytes memory returnData) = address(this).delegatecall(checkData);\r\n        require(success, \" delegatecall failed\");\r\n\r\n        bytes memory trueBytes = hex\"0000000000000000000000000000000000000000000000000000000000000001\";\r\n        upkeepNeeded = keccak256(returnData) == keccak256(trueBytes);\r\n        performData = \"\";\r\n        if(upkeepNeeded){\r\n            bytes4 sig = getSig(checkData);\r\n            address targetAddr = abi.decode(checkData[4:], (address));\r\n            if(sig == earnableMethodId){\r\n                performData = abi.encodeWithSelector(earnForChainlinkMethodId, targetAddr);\r\n            }else if(sig == harvestableMethodId){\r\n                performData = abi.encodeWithSelector(harvestForChainlinkMethodId, targetAddr);\r\n            }else if(sig == keepMinRatioableMethodId){\r\n                performData = abi.encodeWithSelector(keepMinRatioForChainlinkMethodId, targetAddr);\r\n            }\r\n        }\r\n    }\r\n\r\n    function performUpkeep(bytes calldata performData) external override {\r\n        require(checkPerformData(performData), \"bad performData\");\r\n\r\n        (bool success,) = address(this).call(performData);\r\n        require(success, \"call failed\");\r\n    }\r\n\r\n    function checkCallData(bytes calldata checkData) public pure returns (bool){\r\n        require(checkData.length > 10, \"checkData not good\");\r\n        bytes4 sig = getSig(checkData);\r\n        return (sig == earnableMethodId || sig == harvestableMethodId || sig == keepMinRatioableMethodId);\r\n    }\r\n\r\n    function checkPerformData(bytes calldata performData) public pure returns (bool){\r\n        require(performData.length > 10, \"performData not good\");\r\n        bytes4 sig = getSig(performData);\r\n        return (sig == earnForChainlinkMethodId || sig == harvestForChainlinkMethodId || sig == keepMinRatioForChainlinkMethodId);\r\n    }\r\n\r\n    function getSig(bytes calldata data) internal pure returns (bytes4){\r\n        bytes4 sig = data[0] |\r\n        (bytes4(data[1]) >> 8) |\r\n        (bytes4(data[2]) >> 16) |\r\n        (bytes4(data[3]) >> 24);\r\n\r\n        return sig;\r\n    }\r\n    //chainlink keep job end--------\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_keep3r\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_keep3rHelper\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_slidingOracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sushiSlidingOracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_mmController\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_requiredEarnBalance\",\"type\":\"uint256\"}],\"name\":\"EarnVaultAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_requiredEarnBalance\",\"type\":\"uint256\"}],\"name\":\"EarnVaultModified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"EarnVaultRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_strategy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_requiredHarvest\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_requiredKeepMinRatio\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_requiredLeverageToMax\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"yieldToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"yieldTokenOracle\",\"type\":\"uint256\"}],\"name\":\"HarvestStrategyAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_strategy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_requiredHarvest\",\"type\":\"uint256\"}],\"name\":\"HarvestStrategyModified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_strategy\",\"type\":\"address\"}],\"name\":\"HarvestStrategyRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_strategy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"profitTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"profitFactor\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"profitInEther\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethCallCost\",\"type\":\"uint256\"}],\"name\":\"HarvestableCheck\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_strategy\",\"type\":\"address\"}],\"name\":\"HarvestedByKeeper\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"keep3rHelper\",\"type\":\"address\"}],\"name\":\"Keep3rHelperSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"keep3r\",\"type\":\"address\"}],\"name\":\"Keep3rSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"slidingOracle\",\"type\":\"address\"}],\"name\":\"SlidingOracleSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ALCX\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ALUSD\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"COMP\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CRV\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CRVRENWBTC\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CVX\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CVXCRV\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DAI\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"KP3R\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LINK\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIR\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIRUSTLP\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PICKLE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RENBTC\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SUSHISWAP_ORACLE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"THREECRV\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TRU\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TUSD\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNISWAP_ORACLE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDC\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDP3CRV\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WBTC\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"YVECRV\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ZRX\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_governor\",\"type\":\"address\"}],\"name\":\"_setGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_strategy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_requiredHarvest\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_requiredKeepMinRatio\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_requiredLeverageToMax\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"yieldToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"yieldTokenOracle\",\"type\":\"uint256\"}],\"name\":\"addStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_requiredEarnBalance\",\"type\":\"uint256\"}],\"name\":\"addVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"checkData\",\"type\":\"bytes\"}],\"name\":\"checkCallData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"performData\",\"type\":\"bytes\"}],\"name\":\"checkPerformData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"checkData\",\"type\":\"bytes\"}],\"name\":\"checkUpkeep\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"upkeepNeeded\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"performData\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"earn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"earnForChainlink\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"earnForChainlinkMethodId\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"earnable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"earnableMethodId\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCollateralizedStrategies\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"_strategies\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStrategies\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"_strategies\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVaults\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"_vaults\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategy\",\"type\":\"address\"}],\"name\":\"harvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategy\",\"type\":\"address\"}],\"name\":\"harvestForChainlink\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"harvestForChainlinkMethodId\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategy\",\"type\":\"address\"}],\"name\":\"harvestable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"harvestableMethodId\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"keep3r\",\"outputs\":[{\"internalType\":\"contract IKeep3rV1\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"keep3rHelper\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategy\",\"type\":\"address\"}],\"name\":\"keepMinRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategy\",\"type\":\"address\"}],\"name\":\"keepMinRatioForChainlink\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"keepMinRatioForChainlinkMethodId\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategy\",\"type\":\"address\"}],\"name\":\"keepMinRatioMayday\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"keepMinRatioMaydayTrigger\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"keepMinRatioableMethodId\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minHarvestInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mmController\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"performData\",\"type\":\"bytes\"}],\"name\":\"performUpkeep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"profitFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"removeEarnVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategy\",\"type\":\"address\"}],\"name\":\"removeHarvestStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"requiredEarnBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"requiredHarvest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_keep3r\",\"type\":\"address\"}],\"name\":\"setKeep3r\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_keep3rHelper\",\"type\":\"address\"}],\"name\":\"setKeep3rHelper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_keepMinRatioTrigger\",\"type\":\"uint256\"}],\"name\":\"setKeepMinRatioMaydayTrigger\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_interval\",\"type\":\"uint256\"}],\"name\":\"setMinHarvestInterval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_profitFactor\",\"type\":\"uint256\"}],\"name\":\"setProfitFactor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_slidingOracle\",\"type\":\"address\"}],\"name\":\"setSlidingOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sushiSlidingOracle\",\"type\":\"address\"}],\"name\":\"setSushiSlidingOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"slidingOracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stratagyYieldTokenOracles\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stratagyYieldTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"strategyLastHarvest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sushiSlidingOracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_requiredEarnBalance\",\"type\":\"uint256\"}],\"name\":\"updateRequiredEarn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_requiredHarvest\",\"type\":\"uint256\"}],\"name\":\"updateRequiredHarvestAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_yieldTokenOracle\",\"type\":\"uint256\"}],\"name\":\"updateYieldTokenOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"vaultStrategies\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"GenericKeep3rV2","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000001ceb5cb57c4d4e2b2433641b95dd330a33185a4400000000000000000000000024e1565ed1d6530cd977a6a8b3e327b9f53a9fd200000000000000000000000073353801921417f465377c8d898c6f4c0270282c000000000000000000000000e20b3f175f9f4e1eddf333f96b72bba138c9e83a0000000000000000000000004bf5059065541a2b176500928e91fbfd0b121d07","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://e8d94e4e00e913cf585f421612a0280e70c28ba51eea1b43a334fdac5196ccf1"}]}