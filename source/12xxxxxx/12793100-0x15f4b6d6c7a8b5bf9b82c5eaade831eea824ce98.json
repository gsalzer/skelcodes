{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.8.4;\r\n\r\ninterface Uniswap {\r\n    function swapExactETHForTokens(\r\n        uint256 amountOutMin,\r\n        address[] memory path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory);\r\n\r\n    function swapExactTokensForTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] memory path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory);\r\n\r\n    function getAmountsOut(uint256 amountIn, address[] memory path)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    function getAmountsIn(uint256 amountOut, address[] memory path)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n}\r\n\r\n\r\nlibrary ExchangeHelper {\r\n    function amountOutFor(\r\n        Uniswap exchange,\r\n        address[] memory path,\r\n        uint256 amountIn\r\n    ) internal returns (uint256) {\r\n        uint256[] memory amountsOut = exchange.getAmountsOut(amountIn, path);\r\n        return amountsOut[amountsOut.length - 1];\r\n    }\r\n}\r\n\r\n\r\n/// @title Enum - Collection of enums\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract Enum {\r\n    enum Operation {Call, DelegateCall}\r\n}\r\n\r\n\r\n/// @title SelfAuthorized - authorizes current contract to perform actions\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract SelfAuthorized {\r\n    function requireSelfCall() private view {\r\n        require(msg.sender == address(this), \"GS031\");\r\n    }\r\n\r\n    modifier authorized() {\r\n        // This is a function call as it minimized the bytecode size\r\n        requireSelfCall();\r\n        _;\r\n    }\r\n}\r\n\r\n/// @title Executor - A contract that can execute transactions\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract Executor {\r\n    function execute(\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data,\r\n        Enum.Operation operation,\r\n        uint256 txGas\r\n    ) internal returns (bool success) {\r\n        if (operation == Enum.Operation.DelegateCall) {\r\n            // solhint-disable-next-line no-inline-assembly\r\n            assembly {\r\n                success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)\r\n            }\r\n        } else {\r\n            // solhint-disable-next-line no-inline-assembly\r\n            assembly {\r\n                success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/// @title Module Manager - A contract that manages modules that can execute transactions via this contract\r\n/// @author Stefan George - <stefan@gnosis.pm>\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract ModuleManager is SelfAuthorized, Executor {\r\n    event EnabledModule(address module);\r\n    event DisabledModule(address module);\r\n    event ExecutionFromModuleSuccess(address indexed module);\r\n    event ExecutionFromModuleFailure(address indexed module);\r\n\r\n    address internal constant SENTINEL_MODULES = address(0x1);\r\n\r\n    mapping(address => address) internal modules;\r\n\r\n    function setupModules(address to, bytes memory data) internal {\r\n        require(modules[SENTINEL_MODULES] == address(0), \"GS100\");\r\n        modules[SENTINEL_MODULES] = SENTINEL_MODULES;\r\n        if (to != address(0))\r\n            // Setup has to complete successfully or transaction fails.\r\n            require(execute(to, 0, data, Enum.Operation.DelegateCall, gasleft()), \"GS000\");\r\n    }\r\n\r\n    /// @dev Allows to add a module to the whitelist.\r\n    ///      This can only be done via a Safe transaction.\r\n    /// @notice Enables the module `module` for the Safe.\r\n    /// @param module Module to be whitelisted.\r\n    function enableModule(address module) public authorized {\r\n        // Module address cannot be null or sentinel.\r\n        require(module != address(0) && module != SENTINEL_MODULES, \"GS101\");\r\n        // Module cannot be added twice.\r\n        require(modules[module] == address(0), \"GS102\");\r\n        modules[module] = modules[SENTINEL_MODULES];\r\n        modules[SENTINEL_MODULES] = module;\r\n        emit EnabledModule(module);\r\n    }\r\n\r\n    /// @dev Allows to remove a module from the whitelist.\r\n    ///      This can only be done via a Safe transaction.\r\n    /// @notice Disables the module `module` for the Safe.\r\n    /// @param prevModule Module that pointed to the module to be removed in the linked list\r\n    /// @param module Module to be removed.\r\n    function disableModule(address prevModule, address module) public authorized {\r\n        // Validate module address and check that it corresponds to module index.\r\n        require(module != address(0) && module != SENTINEL_MODULES, \"GS101\");\r\n        require(modules[prevModule] == module, \"GS103\");\r\n        modules[prevModule] = modules[module];\r\n        modules[module] = address(0);\r\n        emit DisabledModule(module);\r\n    }\r\n\r\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.\r\n    /// @param to Destination address of module transaction.\r\n    /// @param value Ether value of module transaction.\r\n    /// @param data Data payload of module transaction.\r\n    /// @param operation Operation type of module transaction.\r\n    function execTransactionFromModule(\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data,\r\n        Enum.Operation operation\r\n    ) public virtual returns (bool success) {\r\n        // Only whitelisted modules are allowed.\r\n        require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), \"GS104\");\r\n        // Execute transaction without further confirmations.\r\n        success = execute(to, value, data, operation, gasleft());\r\n        if (success) emit ExecutionFromModuleSuccess(msg.sender);\r\n        else emit ExecutionFromModuleFailure(msg.sender);\r\n    }\r\n\r\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations and return data\r\n    /// @param to Destination address of module transaction.\r\n    /// @param value Ether value of module transaction.\r\n    /// @param data Data payload of module transaction.\r\n    /// @param operation Operation type of module transaction.\r\n    function execTransactionFromModuleReturnData(\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data,\r\n        Enum.Operation operation\r\n    ) public returns (bool success, bytes memory returnData) {\r\n        success = execTransactionFromModule(to, value, data, operation);\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            // Load free memory location\r\n            let ptr := mload(0x40)\r\n            // We allocate memory for the return data by setting the free memory location to\r\n            // current free memory location + data size + 32 bytes for data size value\r\n            mstore(0x40, add(ptr, add(returndatasize(), 0x20)))\r\n            // Store the size\r\n            mstore(ptr, returndatasize())\r\n            // Store the data\r\n            returndatacopy(add(ptr, 0x20), 0, returndatasize())\r\n            // Point the return data to the correct memory location\r\n            returnData := ptr\r\n        }\r\n    }\r\n\r\n    /// @dev Returns if an module is enabled\r\n    /// @return True if the module is enabled\r\n    function isModuleEnabled(address module) public view returns (bool) {\r\n        return SENTINEL_MODULES != module && modules[module] != address(0);\r\n    }\r\n\r\n    /// @dev Returns array of modules.\r\n    /// @param start Start of the page.\r\n    /// @param pageSize Maximum number of modules that should be returned.\r\n    /// @return array Array of modules.\r\n    /// @return next Start of the next page.\r\n    function getModulesPaginated(address start, uint256 pageSize) external view returns (address[] memory array, address next) {\r\n        // Init array with max page size\r\n        array = new address[](pageSize);\r\n\r\n        // Populate return array\r\n        uint256 moduleCount = 0;\r\n        address currentModule = modules[start];\r\n        while (currentModule != address(0x0) && currentModule != SENTINEL_MODULES && moduleCount < pageSize) {\r\n            array[moduleCount] = currentModule;\r\n            currentModule = modules[currentModule];\r\n            moduleCount++;\r\n        }\r\n        next = currentModule;\r\n        // Set correct size of returned array\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            mstore(array, moduleCount)\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/// @title OwnerManager - Manages a set of owners and a threshold to perform actions.\r\n/// @author Stefan George - <stefan@gnosis.pm>\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract OwnerManager is SelfAuthorized {\r\n    event AddedOwner(address owner);\r\n    event RemovedOwner(address owner);\r\n    event ChangedThreshold(uint256 threshold);\r\n\r\n    address internal constant SENTINEL_OWNERS = address(0x1);\r\n\r\n    mapping(address => address) internal owners;\r\n    uint256 internal ownerCount;\r\n    uint256 internal threshold;\r\n\r\n    /// @dev Setup function sets initial storage of contract.\r\n    /// @param _owners List of Safe owners.\r\n    /// @param _threshold Number of required confirmations for a Safe transaction.\r\n    function setupOwners(address[] memory _owners, uint256 _threshold) internal {\r\n        // Threshold can only be 0 at initialization.\r\n        // Check ensures that setup function can only be called once.\r\n        require(threshold == 0, \"GS200\");\r\n        // Validate that threshold is smaller than number of added owners.\r\n        require(_threshold <= _owners.length, \"GS201\");\r\n        // There has to be at least one Safe owner.\r\n        require(_threshold >= 1, \"GS202\");\r\n        // Initializing Safe owners.\r\n        address currentOwner = SENTINEL_OWNERS;\r\n        for (uint256 i = 0; i < _owners.length; i++) {\r\n            // Owner address cannot be null.\r\n            address owner = _owners[i];\r\n            require(owner != address(0) && owner != SENTINEL_OWNERS && owner != address(this) && currentOwner != owner, \"GS203\");\r\n            // No duplicate owners allowed.\r\n            require(owners[owner] == address(0), \"GS204\");\r\n            owners[currentOwner] = owner;\r\n            currentOwner = owner;\r\n        }\r\n        owners[currentOwner] = SENTINEL_OWNERS;\r\n        ownerCount = _owners.length;\r\n        threshold = _threshold;\r\n    }\r\n\r\n    /// @dev Allows to add a new owner to the Safe and update the threshold at the same time.\r\n    ///      This can only be done via a Safe transaction.\r\n    /// @notice Adds the owner `owner` to the Safe and updates the threshold to `_threshold`.\r\n    /// @param owner New owner address.\r\n    /// @param _threshold New threshold.\r\n    function addOwnerWithThreshold(address owner, uint256 _threshold) public authorized {\r\n        // Owner address cannot be null, the sentinel or the Safe itself.\r\n        require(owner != address(0) && owner != SENTINEL_OWNERS && owner != address(this), \"GS203\");\r\n        // No duplicate owners allowed.\r\n        require(owners[owner] == address(0), \"GS204\");\r\n        owners[owner] = owners[SENTINEL_OWNERS];\r\n        owners[SENTINEL_OWNERS] = owner;\r\n        ownerCount++;\r\n        emit AddedOwner(owner);\r\n        // Change threshold if threshold was changed.\r\n        if (threshold != _threshold) changeThreshold(_threshold);\r\n    }\r\n\r\n    /// @dev Allows to remove an owner from the Safe and update the threshold at the same time.\r\n    ///      This can only be done via a Safe transaction.\r\n    /// @notice Removes the owner `owner` from the Safe and updates the threshold to `_threshold`.\r\n    /// @param prevOwner Owner that pointed to the owner to be removed in the linked list\r\n    /// @param owner Owner address to be removed.\r\n    /// @param _threshold New threshold.\r\n    function removeOwner(\r\n        address prevOwner,\r\n        address owner,\r\n        uint256 _threshold\r\n    ) public authorized {\r\n        // Only allow to remove an owner, if threshold can still be reached.\r\n        require(ownerCount - 1 >= _threshold, \"GS201\");\r\n        // Validate owner address and check that it corresponds to owner index.\r\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \"GS203\");\r\n        require(owners[prevOwner] == owner, \"GS205\");\r\n        owners[prevOwner] = owners[owner];\r\n        owners[owner] = address(0);\r\n        ownerCount--;\r\n        emit RemovedOwner(owner);\r\n        // Change threshold if threshold was changed.\r\n        if (threshold != _threshold) changeThreshold(_threshold);\r\n    }\r\n\r\n    /// @dev Allows to swap/replace an owner from the Safe with another address.\r\n    ///      This can only be done via a Safe transaction.\r\n    /// @notice Replaces the owner `oldOwner` in the Safe with `newOwner`.\r\n    /// @param prevOwner Owner that pointed to the owner to be replaced in the linked list\r\n    /// @param oldOwner Owner address to be replaced.\r\n    /// @param newOwner New owner address.\r\n    function swapOwner(\r\n        address prevOwner,\r\n        address oldOwner,\r\n        address newOwner\r\n    ) public authorized {\r\n        // Owner address cannot be null, the sentinel or the Safe itself.\r\n        require(newOwner != address(0) && newOwner != SENTINEL_OWNERS && newOwner != address(this), \"GS203\");\r\n        // No duplicate owners allowed.\r\n        require(owners[newOwner] == address(0), \"GS204\");\r\n        // Validate oldOwner address and check that it corresponds to owner index.\r\n        require(oldOwner != address(0) && oldOwner != SENTINEL_OWNERS, \"GS203\");\r\n        require(owners[prevOwner] == oldOwner, \"GS205\");\r\n        owners[newOwner] = owners[oldOwner];\r\n        owners[prevOwner] = newOwner;\r\n        owners[oldOwner] = address(0);\r\n        emit RemovedOwner(oldOwner);\r\n        emit AddedOwner(newOwner);\r\n    }\r\n\r\n    /// @dev Allows to update the number of required confirmations by Safe owners.\r\n    ///      This can only be done via a Safe transaction.\r\n    /// @notice Changes the threshold of the Safe to `_threshold`.\r\n    /// @param _threshold New threshold.\r\n    function changeThreshold(uint256 _threshold) public authorized {\r\n        // Validate that threshold is smaller than number of owners.\r\n        require(_threshold <= ownerCount, \"GS201\");\r\n        // There has to be at least one Safe owner.\r\n        require(_threshold >= 1, \"GS202\");\r\n        threshold = _threshold;\r\n        emit ChangedThreshold(threshold);\r\n    }\r\n\r\n    function getThreshold() public view returns (uint256) {\r\n        return threshold;\r\n    }\r\n\r\n    function isOwner(address owner) public view returns (bool) {\r\n        return owner != SENTINEL_OWNERS && owners[owner] != address(0);\r\n    }\r\n\r\n    /// @dev Returns array of owners.\r\n    /// @return Array of Safe owners.\r\n    function getOwners() public view returns (address[] memory) {\r\n        address[] memory array = new address[](ownerCount);\r\n\r\n        // populate return array\r\n        uint256 index = 0;\r\n        address currentOwner = owners[SENTINEL_OWNERS];\r\n        while (currentOwner != SENTINEL_OWNERS) {\r\n            array[index] = currentOwner;\r\n            currentOwner = owners[currentOwner];\r\n            index++;\r\n        }\r\n        return array;\r\n    }\r\n}\r\n\r\n\r\n/// @title Fallback Manager - A contract that manages fallback calls made to this contract\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract FallbackManager is SelfAuthorized {\r\n    event ChangedFallbackHandler(address handler);\r\n\r\n    // keccak256(\"fallback_manager.handler.address\")\r\n    bytes32 internal constant FALLBACK_HANDLER_STORAGE_SLOT = 0x6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d5;\r\n\r\n    function internalSetFallbackHandler(address handler) internal {\r\n        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            sstore(slot, handler)\r\n        }\r\n    }\r\n\r\n    /// @dev Allows to add a contract to handle fallback calls.\r\n    ///      Only fallback calls without value and with data will be forwarded.\r\n    ///      This can only be done via a Safe transaction.\r\n    /// @param handler contract to handle fallbacks calls.\r\n    function setFallbackHandler(address handler) public authorized {\r\n        internalSetFallbackHandler(handler);\r\n        emit ChangedFallbackHandler(handler);\r\n    }\r\n\r\n    // solhint-disable-next-line payable-fallback,no-complex-fallback\r\n    fallback() external {\r\n        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            let handler := sload(slot)\r\n            if iszero(handler) {\r\n                return(0, 0)\r\n            }\r\n            calldatacopy(0, 0, calldatasize())\r\n            // The msg.sender address is shifted to the left by 12 bytes to remove the padding\r\n            // Then the address without padding is stored right after the calldata\r\n            mstore(calldatasize(), shl(96, caller()))\r\n            // Add 20 bytes for the address appended add the end\r\n            let success := call(gas(), handler, 0, 0, add(calldatasize(), 20), 0, 0)\r\n            returndatacopy(0, 0, returndatasize())\r\n            if iszero(success) {\r\n                revert(0, returndatasize())\r\n            }\r\n            return(0, returndatasize())\r\n        }\r\n    }\r\n}\r\n\r\ninterface Guard {\r\n    function checkTransaction(\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data,\r\n        Enum.Operation operation,\r\n        uint256 safeTxGas,\r\n        uint256 baseGas,\r\n        uint256 gasPrice,\r\n        address gasToken,\r\n        address payable refundReceiver,\r\n        bytes memory signatures,\r\n        address msgSender\r\n    ) external;\r\n\r\n    function checkAfterExecution(bytes32 txHash, bool success) external;\r\n}\r\n\r\n/// @title Fallback Manager - A contract that manages fallback calls made to this contract\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract GuardManager is SelfAuthorized {\r\n    event ChangedGuard(address guard);\r\n    // keccak256(\"guard_manager.guard.address\")\r\n    bytes32 internal constant GUARD_STORAGE_SLOT = 0x4a204f620c8c5ccdca3fd54d003badd85ba500436a431f0cbda4f558c93c34c8;\r\n\r\n    /// @dev Set a guard that checks transactions before execution\r\n    /// @param guard The address of the guard to be used or the 0 address to disable the guard\r\n    function setGuard(address guard) external authorized {\r\n        bytes32 slot = GUARD_STORAGE_SLOT;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            sstore(slot, guard)\r\n        }\r\n        emit ChangedGuard(guard);\r\n    }\r\n\r\n    function getGuard() internal view returns (address guard) {\r\n        bytes32 slot = GUARD_STORAGE_SLOT;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            guard := sload(slot)\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/// @title EtherPaymentFallback - A contract that has a fallback to accept ether payments\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract EtherPaymentFallback {\r\n    event SafeReceived(address indexed sender, uint256 value);\r\n\r\n    /// @dev Fallback function accepts Ether transactions.\r\n    receive() external payable {\r\n        emit SafeReceived(msg.sender, msg.value);\r\n    }\r\n}\r\n\r\n\r\n/// @title Singleton - Base for singleton contracts (should always be first super contract)\r\n///         This contract is tightly coupled to our proxy contract (see `proxies/GnosisSafeProxy.sol`)\r\n/// @author Richard Meissner - <richard@gnosis.io>\r\ncontract Singleton {\r\n    // singleton always needs to be first declared variable, to ensure that it is at the same location as in the Proxy contract.\r\n    // It should also always be ensured that the address is stored alone (uses a full word)\r\n    address private singleton;\r\n}\r\n\r\n/// @title SignatureDecoder - Decodes signatures that a encoded as bytes\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract SignatureDecoder {\r\n    /// @dev divides bytes signature into `uint8 v, bytes32 r, bytes32 s`.\r\n    /// @notice Make sure to peform a bounds check for @param pos, to avoid out of bounds access on @param signatures\r\n    /// @param pos which signature to read. A prior bounds check of this parameter should be performed, to avoid out of bounds access\r\n    /// @param signatures concatenated rsv signatures\r\n    function signatureSplit(bytes memory signatures, uint256 pos)\r\n        internal\r\n        pure\r\n        returns (\r\n            uint8 v,\r\n            bytes32 r,\r\n            bytes32 s\r\n        )\r\n    {\r\n        // The signature format is a compact form of:\r\n        //   {bytes32 r}{bytes32 s}{uint8 v}\r\n        // Compact means, uint8 is not padded to 32 bytes.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            let signaturePos := mul(0x41, pos)\r\n            r := mload(add(signatures, add(signaturePos, 0x20)))\r\n            s := mload(add(signatures, add(signaturePos, 0x40)))\r\n            // Here we are loading the last 32 bytes, including 31 bytes\r\n            // of 's'. There is no 'mload8' to do this.\r\n            //\r\n            // 'byte' is not working due to the Solidity parser, so lets\r\n            // use the second best option, 'and'\r\n            v := and(mload(add(signatures, add(signaturePos, 0x41))), 0xff)\r\n        }\r\n    }\r\n}\r\n\r\n/// @title SecuredTokenTransfer - Secure token transfer\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract SecuredTokenTransfer {\r\n    /// @dev Transfers a token and returns if it was a success\r\n    /// @param token Token that should be transferred\r\n    /// @param receiver Receiver to whom the token should be transferred\r\n    /// @param amount The amount of tokens that should be transferred\r\n    function transferToken(\r\n        address token,\r\n        address receiver,\r\n        uint256 amount\r\n    ) internal returns (bool transferred) {\r\n        // 0xa9059cbb - keccack(\"transfer(address,uint256)\")\r\n        bytes memory data = abi.encodeWithSelector(0xa9059cbb, receiver, amount);\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            // We write the return value to scratch space.\r\n            // See https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html#layout-in-memory\r\n            let success := call(sub(gas(), 10000), token, 0, add(data, 0x20), mload(data), 0, 0x20)\r\n            switch returndatasize()\r\n                case 0 {\r\n                    transferred := success\r\n                }\r\n                case 0x20 {\r\n                    transferred := iszero(or(iszero(success), iszero(mload(0))))\r\n                }\r\n                default {\r\n                    transferred := 0\r\n                }\r\n        }\r\n    }\r\n}\r\n\r\n/// @title StorageAccessible - generic base contract that allows callers to access all internal storage.\r\n/// @notice See https://github.com/gnosis/util-contracts/blob/bb5fe5fb5df6d8400998094fb1b32a178a47c3a1/contracts/StorageAccessible.sol\r\ncontract StorageAccessible {\r\n    /**\r\n     * @dev Reads `length` bytes of storage in the currents contract\r\n     * @param offset - the offset in the current contract's storage in words to start reading from\r\n     * @param length - the number of words (32 bytes) of data to read\r\n     * @return the bytes that were read.\r\n     */\r\n    function getStorageAt(uint256 offset, uint256 length) public view returns (bytes memory) {\r\n        bytes memory result = new bytes(length * 32);\r\n        for (uint256 index = 0; index < length; index++) {\r\n            // solhint-disable-next-line no-inline-assembly\r\n            assembly {\r\n                let word := sload(add(offset, index))\r\n                mstore(add(add(result, 0x20), mul(index, 0x20)), word)\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a delegetecall on a targetContract in the context of self.\r\n     * Internally reverts execution to avoid side effects (making it static).\r\n     *\r\n     * This method reverts with data equal to `abi.encode(bool(success), bytes(response))`.\r\n     * Specifically, the `returndata` after a call to this method will be:\r\n     * `success:bool || response.length:uint256 || response:bytes`.\r\n     *\r\n     * @param targetContract Address of the contract containing the code to execute.\r\n     * @param calldataPayload Calldata that should be sent to the target contract (encoded method name and arguments).\r\n     */\r\n    function simulateAndRevert(address targetContract, bytes memory calldataPayload) external {\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            let success := delegatecall(gas(), targetContract, add(calldataPayload, 0x20), mload(calldataPayload), 0, 0)\r\n\r\n            mstore(0x00, success)\r\n            mstore(0x20, returndatasize())\r\n            returndatacopy(0x40, 0, returndatasize())\r\n            revert(0, add(returndatasize(), 0x40))\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract ISignatureValidatorConstants {\r\n    // bytes4(keccak256(\"isValidSignature(bytes,bytes)\")\r\n    bytes4 internal constant EIP1271_MAGIC_VALUE = 0x20c13b0b;\r\n}\r\n\r\nabstract contract ISignatureValidator is ISignatureValidatorConstants {\r\n    /**\r\n     * @dev Should return whether the signature provided is valid for the provided data\r\n     * @param _data Arbitrary length data signed on the behalf of address(this)\r\n     * @param _signature Signature byte array associated with _data\r\n     *\r\n     * MUST return the bytes4 magic value 0x20c13b0b when function passes.\r\n     * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\r\n     * MUST allow external calls\r\n     */\r\n    function isValidSignature(bytes memory _data, bytes memory _signature) public view virtual returns (bytes4);\r\n}\r\n\r\n\r\n/**\r\n * @title GnosisSafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n * Renamed from SafeMath to GnosisSafeMath to avoid conflicts\r\n * TODO: remove once open zeppelin update to solc 0.5.0\r\n */\r\nlibrary GnosisSafeMath {\r\n    /**\r\n     * @dev Multiplies two numbers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two numbers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title Gnosis Safe - A multisignature wallet with support for confirmations using signed messages based on ERC191.\r\n/// @author Stefan George - <stefan@gnosis.io>\r\n/// @author Richard Meissner - <richard@gnosis.io>\r\ncontract GnosisSafe is\r\n    EtherPaymentFallback,\r\n    Singleton,\r\n    ModuleManager,\r\n    OwnerManager,\r\n    SignatureDecoder,\r\n    SecuredTokenTransfer,\r\n    ISignatureValidatorConstants,\r\n    FallbackManager,\r\n    StorageAccessible,\r\n    GuardManager\r\n{\r\n    using GnosisSafeMath for uint256;\r\n\r\n    string public constant VERSION = \"1.3.0\";\r\n\r\n    // keccak256(\r\n    //     \"EIP712Domain(uint256 chainId,address verifyingContract)\"\r\n    // );\r\n    bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH = 0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\r\n\r\n    // keccak256(\r\n    //     \"SafeTx(address to,uint256 value,bytes data,uint8 operation,uint256 safeTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\"\r\n    // );\r\n    bytes32 private constant SAFE_TX_TYPEHASH = 0xbb8310d486368db6bd6f849402fdd73ad53d316b5a4b2644ad6efe0f941286d8;\r\n\r\n    event SafeSetup(address indexed initiator, address[] owners, uint256 threshold, address initializer, address fallbackHandler);\r\n    event ApproveHash(bytes32 indexed approvedHash, address indexed owner);\r\n    event SignMsg(bytes32 indexed msgHash);\r\n    event ExecutionFailure(bytes32 txHash, uint256 payment);\r\n    event ExecutionSuccess(bytes32 txHash, uint256 payment);\r\n\r\n    uint256 public nonce;\r\n    bytes32 private _deprecatedDomainSeparator;\r\n    // Mapping to keep track of all message hashes that have been approve by ALL REQUIRED owners\r\n    mapping(bytes32 => uint256) public signedMessages;\r\n    // Mapping to keep track of all hashes (message or transaction) that have been approve by ANY owners\r\n    mapping(address => mapping(bytes32 => uint256)) public approvedHashes;\r\n\r\n    // This constructor ensures that this contract can only be used as a master copy for Proxy contracts\r\n    constructor() {\r\n        // By setting the threshold it is not possible to call setup anymore,\r\n        // so we create a Safe with 0 owners and threshold 1.\r\n        // This is an unusable Safe, perfect for the singleton\r\n        threshold = 1;\r\n    }\r\n\r\n    /// @dev Setup function sets initial storage of contract.\r\n    /// @param _owners List of Safe owners.\r\n    /// @param _threshold Number of required confirmations for a Safe transaction.\r\n    /// @param to Contract address for optional delegate call.\r\n    /// @param data Data payload for optional delegate call.\r\n    /// @param fallbackHandler Handler for fallback calls to this contract\r\n    /// @param paymentToken Token that should be used for the payment (0 is ETH)\r\n    /// @param payment Value that should be paid\r\n    /// @param paymentReceiver Adddress that should receive the payment (or 0 if tx.origin)\r\n    function setup(\r\n        address[] calldata _owners,\r\n        uint256 _threshold,\r\n        address to,\r\n        bytes calldata data,\r\n        address fallbackHandler,\r\n        address paymentToken,\r\n        uint256 payment,\r\n        address payable paymentReceiver\r\n    ) external {\r\n        // setupOwners checks if the Threshold is already set, therefore preventing that this method is called twice\r\n        setupOwners(_owners, _threshold);\r\n        if (fallbackHandler != address(0)) internalSetFallbackHandler(fallbackHandler);\r\n        // As setupOwners can only be called if the contract has not been initialized we don't need a check for setupModules\r\n        setupModules(to, data);\r\n\r\n        if (payment > 0) {\r\n            // To avoid running into issues with EIP-170 we reuse the handlePayment function (to avoid adjusting code of that has been verified we do not adjust the method itself)\r\n            // baseGas = 0, gasPrice = 1 and gas = payment => amount = (payment + 0) * 1 = payment\r\n            handlePayment(payment, 0, 1, paymentToken, paymentReceiver);\r\n        }\r\n        emit SafeSetup(msg.sender, _owners, _threshold, to, fallbackHandler);\r\n    }\r\n\r\n    /// @dev Allows to execute a Safe transaction confirmed by required number of owners and then pays the account that submitted the transaction.\r\n    ///      Note: The fees are always transferred, even if the user transaction fails.\r\n    /// @param to Destination address of Safe transaction.\r\n    /// @param value Ether value of Safe transaction.\r\n    /// @param data Data payload of Safe transaction.\r\n    /// @param operation Operation type of Safe transaction.\r\n    /// @param safeTxGas Gas that should be used for the Safe transaction.\r\n    /// @param baseGas Gas costs that are independent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)\r\n    /// @param gasPrice Gas price that should be used for the payment calculation.\r\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\r\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\r\n    /// @param signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})\r\n    function execTransaction(\r\n        address to,\r\n        uint256 value,\r\n        bytes calldata data,\r\n        Enum.Operation operation,\r\n        uint256 safeTxGas,\r\n        uint256 baseGas,\r\n        uint256 gasPrice,\r\n        address gasToken,\r\n        address payable refundReceiver,\r\n        bytes memory signatures\r\n    ) public payable virtual returns (bool success) {\r\n        bytes32 txHash;\r\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\r\n        {\r\n            bytes memory txHashData =\r\n                encodeTransactionData(\r\n                    // Transaction info\r\n                    to,\r\n                    value,\r\n                    data,\r\n                    operation,\r\n                    safeTxGas,\r\n                    // Payment info\r\n                    baseGas,\r\n                    gasPrice,\r\n                    gasToken,\r\n                    refundReceiver,\r\n                    // Signature info\r\n                    nonce\r\n                );\r\n            // Increase nonce and execute transaction.\r\n            nonce++;\r\n            txHash = keccak256(txHashData);\r\n            checkSignatures(txHash, txHashData, signatures);\r\n        }\r\n        address guard = getGuard();\r\n        {\r\n            if (guard != address(0)) {\r\n                Guard(guard).checkTransaction(\r\n                    // Transaction info\r\n                    to,\r\n                    value,\r\n                    data,\r\n                    operation,\r\n                    safeTxGas,\r\n                    // Payment info\r\n                    baseGas,\r\n                    gasPrice,\r\n                    gasToken,\r\n                    refundReceiver,\r\n                    // Signature info\r\n                    signatures,\r\n                    msg.sender\r\n                );\r\n            }\r\n        }\r\n        // We require some gas to emit the events (at least 2500) after the execution and some to perform code until the execution (500)\r\n        // We also include the 1/64 in the check that is not send along with a call to counteract potential shortings because of EIP-150\r\n        require(gasleft() >= ((safeTxGas * 64) / 63).max(safeTxGas + 2500) + 500, \"GS010\");\r\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\r\n        {\r\n            uint256 gasUsed = gasleft();\r\n            // If the gasPrice is 0 we assume that nearly all available gas can be used (it is always more than safeTxGas)\r\n            // We only substract 2500 (compared to the 3000 before) to ensure that the amount passed is still higher than safeTxGas\r\n            success = execute(to, value, data, operation, gasPrice == 0 ? (gasleft() - 2500) : safeTxGas);\r\n            gasUsed = gasUsed.sub(gasleft());\r\n            // If no safeTxGas and no gasPrice was set (e.g. both are 0), then the internal tx is required to be successful\r\n            // This makes it possible to use `estimateGas` without issues, as it searches for the minimum gas where the tx doesn't revert\r\n            require(success || safeTxGas != 0 || gasPrice != 0, \"GS013\");\r\n            // We transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls\r\n            uint256 payment = 0;\r\n            if (gasPrice > 0) {\r\n                payment = handlePayment(gasUsed, baseGas, gasPrice, gasToken, refundReceiver);\r\n            }\r\n            if (success) emit ExecutionSuccess(txHash, payment);\r\n            else emit ExecutionFailure(txHash, payment);\r\n        }\r\n        {\r\n            if (guard != address(0)) {\r\n                Guard(guard).checkAfterExecution(txHash, success);\r\n            }\r\n        }\r\n    }\r\n\r\n    function handlePayment(\r\n        uint256 gasUsed,\r\n        uint256 baseGas,\r\n        uint256 gasPrice,\r\n        address gasToken,\r\n        address payable refundReceiver\r\n    ) private returns (uint256 payment) {\r\n        // solhint-disable-next-line avoid-tx-origin\r\n        address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\r\n        if (gasToken == address(0)) {\r\n            // For ETH we will only adjust the gas price to not be higher than the actual used gas price\r\n            payment = gasUsed.add(baseGas).mul(gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\r\n            require(receiver.send(payment), \"GS011\");\r\n        } else {\r\n            payment = gasUsed.add(baseGas).mul(gasPrice);\r\n            require(transferToken(gasToken, receiver, payment), \"GS012\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise.\r\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\r\n     * @param data That should be signed (this is passed to an external validator contract)\r\n     * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.\r\n     */\r\n    function checkSignatures(\r\n        bytes32 dataHash,\r\n        bytes memory data,\r\n        bytes memory signatures\r\n    ) public view {\r\n        // Load threshold to avoid multiple storage loads\r\n        uint256 _threshold = threshold;\r\n        // Check that a threshold is set\r\n        require(_threshold > 0, \"GS001\");\r\n        checkNSignatures(dataHash, data, signatures, _threshold);\r\n    }\r\n\r\n    /**\r\n     * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise.\r\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\r\n     * @param data That should be signed (this is passed to an external validator contract)\r\n     * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.\r\n     * @param requiredSignatures Amount of required valid signatures.\r\n     */\r\n    function checkNSignatures(\r\n        bytes32 dataHash,\r\n        bytes memory data,\r\n        bytes memory signatures,\r\n        uint256 requiredSignatures\r\n    ) public view {\r\n        // Check that the provided signature data is not too short\r\n        require(signatures.length >= requiredSignatures.mul(65), \"GS020\");\r\n        // There cannot be an owner with address 0.\r\n        address lastOwner = address(0);\r\n        address currentOwner;\r\n        uint8 v;\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint256 i;\r\n        for (i = 0; i < requiredSignatures; i++) {\r\n            (v, r, s) = signatureSplit(signatures, i);\r\n            if (v == 0) {\r\n                // If v is 0 then it is a contract signature\r\n                // When handling contract signatures the address of the contract is encoded into r\r\n                currentOwner = address(uint160(uint256(r)));\r\n\r\n                // Check that signature data pointer (s) is not pointing inside the static part of the signatures bytes\r\n                // This check is not completely accurate, since it is possible that more signatures than the threshold are send.\r\n                // Here we only check that the pointer is not pointing inside the part that is being processed\r\n                require(uint256(s) >= requiredSignatures.mul(65), \"GS021\");\r\n\r\n                // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)\r\n                require(uint256(s).add(32) <= signatures.length, \"GS022\");\r\n\r\n                // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length\r\n                uint256 contractSignatureLen;\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    contractSignatureLen := mload(add(add(signatures, s), 0x20))\r\n                }\r\n                require(uint256(s).add(32).add(contractSignatureLen) <= signatures.length, \"GS023\");\r\n\r\n                // Check signature\r\n                bytes memory contractSignature;\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    // The signature data for contract signatures is appended to the concatenated signatures and the offset is stored in s\r\n                    contractSignature := add(add(signatures, s), 0x20)\r\n                }\r\n                require(ISignatureValidator(currentOwner).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, \"GS024\");\r\n            } else if (v == 1) {\r\n                // If v is 1 then it is an approved hash\r\n                // When handling approved hashes the address of the approver is encoded into r\r\n                currentOwner = address(uint160(uint256(r)));\r\n                // Hashes are automatically approved by the sender of the message or when they have been pre-approved via a separate transaction\r\n                require(msg.sender == currentOwner || approvedHashes[currentOwner][dataHash] != 0, \"GS025\");\r\n            } else if (v > 30) {\r\n                // If v > 30 then default va (27,28) has been adjusted for eth_sign flow\r\n                // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover\r\n                currentOwner = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s);\r\n            } else {\r\n                // Default is the ecrecover flow with the provided data hash\r\n                // Use ecrecover with the messageHash for EOA signatures\r\n                currentOwner = ecrecover(dataHash, v, r, s);\r\n            }\r\n            require(currentOwner > lastOwner && owners[currentOwner] != address(0) && currentOwner != SENTINEL_OWNERS, \"GS026\");\r\n            lastOwner = currentOwner;\r\n        }\r\n    }\r\n\r\n    /// @dev Allows to estimate a Safe transaction.\r\n    ///      This method is only meant for estimation purpose, therefore the call will always revert and encode the result in the revert data.\r\n    ///      Since the `estimateGas` function includes refunds, call this method to get an estimated of the costs that are deducted from the safe with `execTransaction`\r\n    /// @param to Destination address of Safe transaction.\r\n    /// @param value Ether value of Safe transaction.\r\n    /// @param data Data payload of Safe transaction.\r\n    /// @param operation Operation type of Safe transaction.\r\n    /// @return Estimate without refunds and overhead fees (base transaction and payload data gas costs).\r\n    /// @notice Deprecated in favor of common/StorageAccessible.sol and will be removed in next version.\r\n    function requiredTxGas(\r\n        address to,\r\n        uint256 value,\r\n        bytes calldata data,\r\n        Enum.Operation operation\r\n    ) external returns (uint256) {\r\n        uint256 startGas = gasleft();\r\n        // We don't provide an error message here, as we use it to return the estimate\r\n        require(execute(to, value, data, operation, gasleft()));\r\n        uint256 requiredGas = startGas - gasleft();\r\n        // Convert response to string and return via error message\r\n        revert(string(abi.encodePacked(requiredGas)));\r\n    }\r\n\r\n    /**\r\n     * @dev Marks a hash as approved. This can be used to validate a hash that is used by a signature.\r\n     * @param hashToApprove The hash that should be marked as approved for signatures that are verified by this contract.\r\n     */\r\n    function approveHash(bytes32 hashToApprove) external {\r\n        require(owners[msg.sender] != address(0), \"GS030\");\r\n        approvedHashes[msg.sender][hashToApprove] = 1;\r\n        emit ApproveHash(hashToApprove, msg.sender);\r\n    }\r\n\r\n    /// @dev Returns the chain id used by this contract.\r\n    function getChainId() public view returns (uint256) {\r\n        uint256 id;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            id := chainid()\r\n        }\r\n        return id;\r\n    }\r\n\r\n    function domainSeparator() public view returns (bytes32) {\r\n        return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, getChainId(), this));\r\n    }\r\n\r\n    /// @dev Returns the bytes that are hashed to be signed by owners.\r\n    /// @param to Destination address.\r\n    /// @param value Ether value.\r\n    /// @param data Data payload.\r\n    /// @param operation Operation type.\r\n    /// @param safeTxGas Gas that should be used for the safe transaction.\r\n    /// @param baseGas Gas costs for that are independent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)\r\n    /// @param gasPrice Maximum gas price that should be used for this transaction.\r\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\r\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\r\n    /// @param _nonce Transaction nonce.\r\n    /// @return Transaction hash bytes.\r\n    function encodeTransactionData(\r\n        address to,\r\n        uint256 value,\r\n        bytes calldata data,\r\n        Enum.Operation operation,\r\n        uint256 safeTxGas,\r\n        uint256 baseGas,\r\n        uint256 gasPrice,\r\n        address gasToken,\r\n        address refundReceiver,\r\n        uint256 _nonce\r\n    ) public view returns (bytes memory) {\r\n        bytes32 safeTxHash =\r\n            keccak256(\r\n                abi.encode(\r\n                    SAFE_TX_TYPEHASH,\r\n                    to,\r\n                    value,\r\n                    keccak256(data),\r\n                    operation,\r\n                    safeTxGas,\r\n                    baseGas,\r\n                    gasPrice,\r\n                    gasToken,\r\n                    refundReceiver,\r\n                    _nonce\r\n                )\r\n            );\r\n        return abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), safeTxHash);\r\n    }\r\n\r\n    /// @dev Returns hash to be signed by owners.\r\n    /// @param to Destination address.\r\n    /// @param value Ether value.\r\n    /// @param data Data payload.\r\n    /// @param operation Operation type.\r\n    /// @param safeTxGas Fas that should be used for the safe transaction.\r\n    /// @param baseGas Gas costs for data used to trigger the safe transaction.\r\n    /// @param gasPrice Maximum gas price that should be used for this transaction.\r\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\r\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\r\n    /// @param _nonce Transaction nonce.\r\n    /// @return Transaction hash.\r\n    function getTransactionHash(\r\n        address to,\r\n        uint256 value,\r\n        bytes calldata data,\r\n        Enum.Operation operation,\r\n        uint256 safeTxGas,\r\n        uint256 baseGas,\r\n        uint256 gasPrice,\r\n        address gasToken,\r\n        address refundReceiver,\r\n        uint256 _nonce\r\n    ) public view returns (bytes32) {\r\n        return keccak256(encodeTransactionData(to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce));\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Modules/Module.sol\r\n\r\npragma solidity ^0.8.4;\r\n\r\ncontract Module {\r\n    /// The executors for the safe.\r\n    mapping(address => address) executors;\r\n\r\n    modifier onlyExecutor(GnosisSafe safe) {\r\n        require(\r\n            executors[address(safe)] == msg.sender || safe.isOwner(msg.sender),\r\n            \"Sender is not harvester\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function addExecutor(address executor) external {\r\n        require(executors[msg.sender] == address(0x0), \"harvester already set\");\r\n        executors[msg.sender] = executor;\r\n    }\r\n\r\n    function removeExecutor() external {\r\n        executors[msg.sender] = address(0x0);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Interfaces/Aave/StakedTokenIncentivesController.sol\r\n\r\npragma solidity ^0.8.4;\r\n\r\ninterface StakedTokenIncentivesController {\r\n    function claimRewards(\r\n        address[] calldata assets,\r\n        uint256 amount,\r\n        address to\r\n    ) external;\r\n\r\n    function getRewardsBalance(address[] calldata, address)\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\n\r\n// File contracts/Interfaces/Aave/StakedAave.sol\r\n\r\npragma solidity ^0.8.4;\r\n\r\ninterface StakedAave {\r\n    function stake(address, uint256) external;\r\n\r\n    function redeem(address, uint256) external;\r\n\r\n    function cooldown() external;\r\n\r\n    function claimRewards(address, uint256) external;\r\n\r\n    function balanceOf(address) external returns (uint256);\r\n}\r\n\r\n\r\n// File contracts/Interfaces/Aave/LendingPool.sol\r\n\r\npragma solidity ^0.8.4;\r\n\r\ninterface LendingPool {\r\n    function deposit(\r\n        address,\r\n        uint256,\r\n        address,\r\n        uint16\r\n    ) external;\r\n}\r\n\r\n\r\n// File contracts/Interfaces/ERC20.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface ERC20 {\r\n    function balanceOf(address) external view returns (uint256);\r\n\r\n    function transfer(address, uint256) external returns (bool);\r\n\r\n    function allowance(address, address) external view returns (uint256);\r\n\r\n    function approve(address, uint256) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address,\r\n        address,\r\n        uint256\r\n    ) external returns (bool);\r\n}\r\n\r\n\r\n// File contracts/Modules/AaveHarvester.sol\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract AaveHarvester is Module {\r\n    using ExchangeHelper for Uniswap;\r\n\r\n    string public constant NAME = \"Aave Harvester Module\";\r\n    string public constant VERSION = \"0.1.0\";\r\n\r\n    StakedAave public constant stakedAave = StakedAave(0x4da27a545c0c5B758a6BA100e3a049001de870f5);\r\n    StakedTokenIncentivesController public constant incentives = StakedTokenIncentivesController(0xd784927Ff2f95ba542BfC824c8a8a98F3495f6b5);\r\n    LendingPool public constant lendingPool = LendingPool(0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9);\r\n\r\n    ERC20 public constant usdc = ERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\r\n    ERC20 public constant aave = ERC20(0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9);\r\n    ERC20 public constant weth = ERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\r\n\r\n    Uniswap public uni = Uniswap(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n    Uniswap public sushi = Uniswap(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);\r\n\r\n    function activateCooldown(GnosisSafe safe, address[] calldata assets)\r\n        external\r\n        onlyExecutor(safe)\r\n    {\r\n        // Claim the rewards\r\n        execute(\r\n            safe,\r\n            address(incentives),\r\n            abi.encodeWithSelector(\r\n                incentives.claimRewards.selector,\r\n                assets,\r\n                incentives.getRewardsBalance(assets, address(safe)),\r\n                address(safe)\r\n            )\r\n        );\r\n\r\n        // Cooldown the rewards so we can harvest\r\n        execute(\r\n            safe,\r\n            address(stakedAave),\r\n            abi.encodeWithSelector(stakedAave.cooldown.selector)\r\n        );\r\n    }\r\n\r\n    function harvest(GnosisSafe safe) external onlyExecutor(safe) {\r\n        uint256 stakeBalance = stakedAave.balanceOf(address(safe));\r\n\r\n        // Redeem Aave Tokens\r\n        execute(\r\n            safe,\r\n            address(stakedAave),\r\n            abi.encodeWithSelector(\r\n                stakedAave.redeem.selector,\r\n                address(safe),\r\n                stakeBalance\r\n            )\r\n        );\r\n\r\n        address[] memory path = new address[](3);\r\n        path[0] = address(aave);\r\n        path[1] = address(weth);\r\n        path[2] = address(usdc);\r\n\r\n        uint256 balance = aave.balanceOf(address(safe));\r\n\r\n        // Check for best price\r\n        Uniswap exchange;\r\n        if (\r\n            sushi.amountOutFor(path, balance) > uni.amountOutFor(path, balance)\r\n        ) {\r\n            exchange = sushi;\r\n        } else {\r\n            exchange = uni;\r\n        }\r\n\r\n        // Approve Aave on best exchange\r\n        execute(\r\n            safe,\r\n            address(aave),\r\n            abi.encodeWithSelector(\r\n                aave.approve.selector,\r\n                address(exchange),\r\n                balance\r\n            )\r\n        );\r\n\r\n        // Trade\r\n        (bool success, bytes memory data) = safe\r\n        .execTransactionFromModuleReturnData(\r\n            address(exchange),\r\n            0,\r\n            abi.encodeWithSelector(\r\n                exchange.swapExactTokensForTokens.selector,\r\n                balance,\r\n                1,\r\n                path,\r\n                address(safe),\r\n                block.timestamp + 180\r\n            ),\r\n            Enum.Operation.Call\r\n        );\r\n        require(success);\r\n\r\n        uint256[] memory balances = abi.decode(data, (uint256[]));\r\n        uint256 usdcBalance = balances[3];\r\n\r\n        // Approve USDC for aave\r\n        execute(\r\n            safe,\r\n            address(usdc),\r\n            abi.encodeWithSelector(\r\n                usdc.approve.selector,\r\n                address(lendingPool),\r\n                usdcBalance\r\n            )\r\n        );\r\n\r\n        // Deposit\r\n        execute(\r\n            safe,\r\n            address(lendingPool),\r\n            abi.encodeWithSelector(\r\n                lendingPool.deposit.selector,\r\n                address(usdc),\r\n                usdcBalance,\r\n                address(safe)\r\n            )\r\n        );\r\n    }\r\n\r\n    function execute(\r\n        GnosisSafe safe,\r\n        address to,\r\n        bytes memory data\r\n    ) internal {\r\n        require(\r\n            safe.execTransactionFromModule(to, 0, data, Enum.Operation.Call),\r\n            \"could not execute\"\r\n        );\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"aave\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract GnosisSafe\",\"name\":\"safe\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"assets\",\"type\":\"address[]\"}],\"name\":\"activateCooldown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"}],\"name\":\"addExecutor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract GnosisSafe\",\"name\":\"safe\",\"type\":\"address\"}],\"name\":\"harvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"incentives\",\"outputs\":[{\"internalType\":\"contract StakedTokenIncentivesController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lendingPool\",\"outputs\":[{\"internalType\":\"contract LendingPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeExecutor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakedAave\",\"outputs\":[{\"internalType\":\"contract StakedAave\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sushi\",\"outputs\":[{\"internalType\":\"contract Uniswap\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uni\",\"outputs\":[{\"internalType\":\"contract Uniswap\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdc\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"AaveHarvester","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://c3af125d13fa9b80ab5944943f1e3269219eb3ca32c54f0929e8a6aa8abbb93d"}]}