{"status":"1","message":"OK","result":[{"SourceCode":"{\"ACOAssetHelper.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\nlibrary ACOAssetHelper {\\r\\n    uint256 internal constant MAX_UINT = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to get if the address is for Ethereum (0x0).\\r\\n     * @param _address Address to be checked.\\r\\n     * @return Whether the address is for Ethereum.\\r\\n     */ \\r\\n    function _isEther(address _address) internal pure returns(bool) {\\r\\n        return _address == address(0);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to approve ERC20 tokens.\\r\\n     * @param token Address of the token.\\r\\n     * @param spender Authorized address.\\r\\n     * @param amount Amount to authorize.\\r\\n     */\\r\\n    function _callApproveERC20(address token, address spender, uint256 amount) internal {\\r\\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(0x095ea7b3, spender, amount));\\r\\n        require(success \\u0026\\u0026 (returndata.length == 0 || abi.decode(returndata, (bool))), \\\"approve\\\");\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to transfer ERC20 tokens.\\r\\n     * @param token Address of the token.\\r\\n     * @param recipient Address of the transfer destination.\\r\\n     * @param amount Amount to transfer.\\r\\n     */\\r\\n    function _callTransferERC20(address token, address recipient, uint256 amount) internal {\\r\\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(0xa9059cbb, recipient, amount));\\r\\n        require(success \\u0026\\u0026 (returndata.length == 0 || abi.decode(returndata, (bool))), \\\"transfer\\\");\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to call transferFrom on ERC20 tokens.\\r\\n     * @param token Address of the token.\\r\\n     * @param sender Address of the sender.\\r\\n     * @param recipient Address of the transfer destination.\\r\\n     * @param amount Amount to transfer.\\r\\n     */\\r\\n     function _callTransferFromERC20(address token, address sender, address recipient, uint256 amount) internal {\\r\\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(0x23b872dd, sender, recipient, amount));\\r\\n        require(success \\u0026\\u0026 (returndata.length == 0 || abi.decode(returndata, (bool))), \\\"transferFrom\\\");\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to the asset symbol.\\r\\n     * @param asset Address of the asset.\\r\\n     * @return The asset symbol.\\r\\n     */\\r\\n    function _getAssetSymbol(address asset) internal view returns(string memory) {\\r\\n        if (_isEther(asset)) {\\r\\n            return \\\"ETH\\\";\\r\\n        } else {\\r\\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x95d89b41));\\r\\n            require(success, \\\"symbol\\\");\\r\\n            return abi.decode(returndata, (string));\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to the asset decimals.\\r\\n     * @param asset Address of the asset.\\r\\n     * @return The asset decimals.\\r\\n     */\\r\\n    function _getAssetDecimals(address asset) internal view returns(uint8) {\\r\\n        if (_isEther(asset)) {\\r\\n            return uint8(18);\\r\\n        } else {\\r\\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x313ce567));\\r\\n            require(success, \\\"decimals\\\");\\r\\n            return abi.decode(returndata, (uint8));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to the asset name.\\r\\n     * @param asset Address of the asset.\\r\\n     * @return The asset name.\\r\\n     */\\r\\n    function _getAssetName(address asset) internal view returns(string memory) {\\r\\n        if (_isEther(asset)) {\\r\\n            return \\\"Ethereum\\\";\\r\\n        } else {\\r\\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x06fdde03));\\r\\n            require(success, \\\"name\\\");\\r\\n            return abi.decode(returndata, (string));\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to the asset balance of an account.\\r\\n     * @param asset Address of the asset.\\r\\n     * @param account Address of the account.\\r\\n     * @return The account balance.\\r\\n     */\\r\\n    function _getAssetBalanceOf(address asset, address account) internal view returns(uint256) {\\r\\n        if (_isEther(asset)) {\\r\\n            return account.balance;\\r\\n        } else {\\r\\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x70a08231, account));\\r\\n            require(success, \\\"balanceOf\\\");\\r\\n            return abi.decode(returndata, (uint256));\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to the asset allowance between two addresses.\\r\\n     * @param asset Address of the asset.\\r\\n     * @param owner Address of the owner of the tokens.\\r\\n     * @param spender Address of the spender authorized.\\r\\n     * @return The owner allowance for the spender.\\r\\n     */\\r\\n    function _getAssetAllowance(address asset, address owner, address spender) internal view returns(uint256) {\\r\\n        if (_isEther(asset)) {\\r\\n            return 0;\\r\\n        } else {\\r\\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0xdd62ed3e, owner, spender));\\r\\n            require(success, \\\"allowance\\\");\\r\\n            return abi.decode(returndata, (uint256));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to transfer an asset. \\r\\n     * @param asset Address of the asset to be transferred.\\r\\n     * @param to Address of the destination.\\r\\n     * @param amount The amount to be transferred.\\r\\n     */\\r\\n    function _transferAsset(address asset, address to, uint256 amount) internal {\\r\\n        if (_isEther(asset)) {\\r\\n            (bool success,) = to.call{value:amount}(new bytes(0));\\r\\n            require(success, \\\"send\\\");\\r\\n        } else {\\r\\n            _callTransferERC20(asset, to, amount);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Internal function to receive an asset. \\r\\n     * @param asset Address of the asset to be received.\\r\\n     * @param amount The amount to be received.\\r\\n     */\\r\\n    function _receiveAsset(address asset, uint256 amount) internal {\\r\\n        if (_isEther(asset)) {\\r\\n            require(msg.value == amount, \\\"Invalid ETH amount\\\");\\r\\n        } else {\\r\\n            require(msg.value == 0, \\\"No payable\\\");\\r\\n            _callTransferFromERC20(asset, msg.sender, address(this), amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to check asset allowance and set to Infinity if necessary.\\r\\n     * @param asset Address of the asset.\\r\\n     * @param owner Address of the owner of the tokens.\\r\\n     * @param spender Address of the spender authorized.\\r\\n     * @param amount Amount to check allowance.\\r\\n     */\\r\\n    function _setAssetInfinityApprove(address asset, address owner, address spender, uint256 amount) internal {\\r\\n        if (_getAssetAllowance(asset, owner, spender) \\u003c amount) {\\r\\n            _callApproveERC20(asset, spender, MAX_UINT);\\r\\n        }\\r\\n    }\\r\\n}\"},\"ACOWriterV2.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\\"./IACOToken.sol\\\";\\r\\nimport \\\"./IWETH.sol\\\";\\r\\nimport \\\"./ACOAssetHelper.sol\\\";\\r\\n\\r\\ncontract ACOWriterV2 {\\r\\n    \\r\\n    address immutable public weth;\\r\\n    address immutable public zrxExchange;\\r\\n    \\r\\n    bool internal _notEntered;\\r\\n\\r\\n    modifier nonReentrant() {\\r\\n        require(_notEntered, \\\"ACOWriter::Reentry\\\");\\r\\n        _notEntered = false;\\r\\n        _;\\r\\n        _notEntered = true;\\r\\n    }\\r\\n    \\r\\n    constructor(address _weth, address _zrxExchange) public {\\r\\n        weth = _weth;\\r\\n        zrxExchange = _zrxExchange;\\r\\n        _notEntered = true;\\r\\n    }\\r\\n    \\r\\n    receive() external payable {\\r\\n        require(tx.origin != msg.sender, \\\"ACOWriter:: Not allowed\\\");\\r\\n    }\\r\\n    \\r\\n    function write(\\r\\n        address acoToken, \\r\\n        uint256 collateralAmount, \\r\\n        bytes memory zrxExchangeData\\r\\n    ) \\r\\n        nonReentrant \\r\\n        public \\r\\n        payable \\r\\n    {\\r\\n        require(msg.value \\u003e 0,  \\\"ACOWriter::write: Invalid msg value\\\");\\r\\n        require(collateralAmount \\u003e 0,  \\\"ACOWriter::write: Invalid collateral amount\\\");\\r\\n        \\r\\n        address _collateral = IACOToken(acoToken).collateral();\\r\\n        if (ACOAssetHelper._isEther(_collateral)) {\\r\\n            IACOToken(acoToken).mintToPayable{value: collateralAmount}(msg.sender);\\r\\n        } else {\\r\\n            ACOAssetHelper._callTransferFromERC20(_collateral, msg.sender, address(this), collateralAmount);\\r\\n            ACOAssetHelper._setAssetInfinityApprove(_collateral, address(this), acoToken, collateralAmount);\\r\\n            IACOToken(acoToken).mintTo(msg.sender, collateralAmount);\\r\\n        }\\r\\n        \\r\\n        _sellACOTokens(acoToken, zrxExchangeData);\\r\\n    }\\r\\n    \\r\\n    function _sellACOTokens(address acoToken, bytes memory exchangeData) internal {\\r\\n        uint256 acoBalance = ACOAssetHelper._getAssetBalanceOf(acoToken, address(this));\\r\\n        ACOAssetHelper._setAssetInfinityApprove(acoToken, address(this), zrxExchange, acoBalance);\\r\\n        (bool success,) = zrxExchange.call{value: address(this).balance}(exchangeData);\\r\\n        require(success, \\\"ACOWriter::_sellACOTokens: Error on call the exchange\\\");\\r\\n        \\r\\n        address token = IACOToken(acoToken).strikeAsset();\\r\\n        if(ACOAssetHelper._isEther(token)) {\\r\\n            uint256 wethBalance = ACOAssetHelper._getAssetBalanceOf(weth, address(this));\\r\\n            if (wethBalance \\u003e 0) {\\r\\n                IWETH(weth).withdraw(wethBalance);\\r\\n            }\\r\\n        } else {\\r\\n            uint256 remaining = ACOAssetHelper._getAssetBalanceOf(token, address(this));\\r\\n            if (remaining \\u003e 0) {\\r\\n                ACOAssetHelper._callTransferERC20(token, msg.sender, remaining);\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        if (address(this).balance \\u003e 0) {\\r\\n            msg.sender.transfer(address(this).balance);\\r\\n        }\\r\\n    }\\r\\n}\"},\"IACOToken.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\ninterface IACOToken is IERC20 {\\r\\n\\tfunction init(address _underlying, address _strikeAsset, bool _isCall, uint256 _strikePrice, uint256 _expiryTime, uint256 _acoFee, address payable _feeDestination, uint256 _maxExercisedAccounts) external;\\r\\n    function name() external view returns(string memory);\\r\\n    function symbol() external view returns(string memory);\\r\\n    function decimals() external view returns(uint8);\\r\\n    function underlying() external view returns (address);\\r\\n    function strikeAsset() external view returns (address);\\r\\n    function feeDestination() external view returns (address);\\r\\n    function isCall() external view returns (bool);\\r\\n    function strikePrice() external view returns (uint256);\\r\\n    function expiryTime() external view returns (uint256);\\r\\n    function totalCollateral() external view returns (uint256);\\r\\n    function acoFee() external view returns (uint256);\\r\\n\\tfunction maxExercisedAccounts() external view returns (uint256);\\r\\n    function underlyingSymbol() external view returns (string memory);\\r\\n    function strikeAssetSymbol() external view returns (string memory);\\r\\n    function underlyingDecimals() external view returns (uint8);\\r\\n    function strikeAssetDecimals() external view returns (uint8);\\r\\n    function currentCollateral(address account) external view returns(uint256);\\r\\n    function unassignableCollateral(address account) external view returns(uint256);\\r\\n    function assignableCollateral(address account) external view returns(uint256);\\r\\n    function currentCollateralizedTokens(address account) external view returns(uint256);\\r\\n    function unassignableTokens(address account) external view returns(uint256);\\r\\n    function assignableTokens(address account) external view returns(uint256);\\r\\n    function getCollateralAmount(uint256 tokenAmount) external view returns(uint256);\\r\\n    function getTokenAmount(uint256 collateralAmount) external view returns(uint256);\\r\\n    function getBaseExerciseData(uint256 tokenAmount) external view returns(address, uint256);\\r\\n    function numberOfAccountsWithCollateral() external view returns(uint256);\\r\\n    function getCollateralOnExercise(uint256 tokenAmount) external view returns(uint256, uint256);\\r\\n    function collateral() external view returns(address);\\r\\n    function mintPayable() external payable returns(uint256);\\r\\n    function mintToPayable(address account) external payable returns(uint256);\\r\\n    function mint(uint256 collateralAmount) external returns(uint256);\\r\\n    function mintTo(address account, uint256 collateralAmount) external returns(uint256);\\r\\n    function burn(uint256 tokenAmount) external returns(uint256);\\r\\n    function burnFrom(address account, uint256 tokenAmount) external returns(uint256);\\r\\n    function redeem() external returns(uint256);\\r\\n    function redeemFrom(address account) external returns(uint256);\\r\\n    function exercise(uint256 tokenAmount, uint256 salt) external payable returns(uint256);\\r\\n    function exerciseFrom(address account, uint256 tokenAmount, uint256 salt) external payable returns(uint256);\\r\\n    function exerciseAccounts(uint256 tokenAmount, address[] calldata accounts) external payable returns(uint256);\\r\\n    function exerciseAccountsFrom(address account, uint256 tokenAmount, address[] calldata accounts) external payable returns(uint256);\\r\\n    function transferCollateralOwnership(address recipient, uint256 tokenCollateralizedAmount) external;\\r\\n}\"},\"IERC20.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\"},\"IWETH.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\ninterface IWETH {\\r\\n    function deposit() external payable;\\r\\n    function transfer(address to, uint value) external returns (bool);\\r\\n    function withdraw(uint) external;\\r\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_zrxExchange\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"acoToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"zrxExchangeData\",\"type\":\"bytes\"}],\"name\":\"write\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zrxExchange\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"ACOWriterV2","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000def1c0ded9bec7f1a1670819833240f027b25eff","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://f8f2dbbdfecd954c6c2640b2c0879f6c49fc3a832322ac3ef3aa831845fc69ea"}]}