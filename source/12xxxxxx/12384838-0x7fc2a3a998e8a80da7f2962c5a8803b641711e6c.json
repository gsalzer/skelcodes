{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Paralism.com EPARA Token V1 on Ethereum\r\n*/\r\npragma solidity >=0.6.4 <0.8.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n/// @title Math library with safety checks\r\n/// @author Paralism.com\r\nlibrary SafeMath {\r\n    function safeAdd(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x + y) >= x, \"add() overflow!\");\r\n    }\r\n\r\n    function safeSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x - y) <= x, \"sub() underflow!\");\r\n    }\r\n    \r\n    function toUint64(uint256 _value) internal pure returns (uint64 z){\r\n        require(_value < 2**64, \"toUint64() overflow!\");\r\n        return uint64(_value);\r\n    }\r\n}\r\n\r\n/// @title Contract of EPARA\r\n/// @author Paralism.com\r\n/// @notice EPARA ERC20 contract with lock functionality extension \r\n/// @dev EPARA V1 March 2021 \r\ncontract EPARA {\r\n    using SafeMath for uint;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    \r\n    uint256 internal _supplyCap;\r\n    uint256 public totalLocked;\r\n\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n    mapping (address => uint256) public freezeOf;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner,address indexed spender,uint256 value);\r\n    \r\n    event Freeze(address indexed from, uint256 value);\r\n    event Unfreeze(address indexed from, uint256 value);\r\n    event Burn(address indexed from, uint256 value);\r\n\r\n    struct TokensWithLock {\r\n        address sender;\r\n        uint256 lockValue;\r\n        uint64 lockTime;\r\n        bool allowLockTimeUpdate;      \r\n        uint64 initAskTime;\r\n        uint256 askToLock;\r\n    }\r\n\r\n    mapping (address => TokensWithLock) public lock;\r\n    \r\n    event TransferWithLock(address indexed sender, address indexed owner, uint256 value, uint256 lockTime ,uint256 initLockDays);\r\n    event ReturnLockedTokens(address indexed owner, address indexed sender, uint256 value);\r\n    event UpdateLockTime(address indexed sender, address indexed owner, uint256 lockDays);\r\n    event AllowUpdateLock(address indexed owner, bool allow);\r\n    event RequestToLock(address indexed sender, address indexed owner, uint256 value, uint256 intLockDays);\r\n    event AcceptLock(address indexed owner,address indexed sender, uint256 value, uint256 lockTime);\r\n    event ReduceLockValue(address indexed sender, address indexed owner, uint256 value);\r\n \r\n    /*MultiSign*/\r\n    struct Approver {address addr; uint64 score; bool activated; }\r\n    struct ApproveTrans {address to; uint256 value; }\r\n    struct MultiSign {\r\n        uint256 multiSignBalance;\r\n        Approver[] approvers;\r\n        uint64 passScore;                // score of multi party signed to effective\r\n        uint64 expiration;               // MultiSign account expiration time in UNIX seconds\r\n        bool holdFlag;                // hold balance flag, for transfer check gas saving\r\n        address backAccount;             // all tokens controled by MultiSign will return to backAccount when expired\r\n    }\r\n    mapping (address => MultiSign) public multiSign;\r\n    struct Vote {\r\n        ApproveTrans approveTrans;       // transfer request\r\n        uint256 recall;                  // the requestion of recall from keeper's balance to multisign balance\r\n        address backAccount;             // the account where the expired token return to\r\n        bool holdBalance;                // true: freeze account keeper's balance\r\n        uint64 expireDays;               // update expiration days \r\n    }\r\n    mapping (address => mapping(address => Vote)) public vote;\r\n    \r\n    event MultiSignApprover(address indexed keeper, address indexed approver, uint individualScore);\r\n    event CreateMultiSign(address indexed keeper, uint passScore, address backAccount, uint expiration);\r\n    event FreezeKeeper(address indexed approver, address indexed keeper, bool freeze);\r\n    event HoldBalance(address indexed keeper, bool _freeze);\r\n    event ApproveTransferTo(address indexed approver,address indexed keeper, address indexed to, uint value);\r\n    event MultiSignTransfer(address indexed keeper, address indexed to, uint value);\r\n    event RecallToMultiSign(address indexed approver, address indexed keeper, uint value);\r\n    event MultiSignRecall(address indexed keeper, uint value);\r\n    event UpdateExpiration(address indexed approver, address indexed keeper,uint expireDays);\r\n    event MultiSignExpirationUpdated(address indexed keeper,uint expireDays);\r\n    event UpdateBackAccount(address indexed approver, address indexed keeper, address newBackAccount);\r\n    event MultiSignBackAccountUpdated(address indexed keeper, address newBackAccount);\r\n    event CancelVote(address indexed approver, address indexed keeper);\r\n    event TransferToMultiSign(address indexed approver,address indexed keeper, uint valu);\r\n    event ClearMutiSign(address indexed sender,address indexed keeper, address indexed backAccount,uint value);\r\n\r\n    constructor() {\r\n        decimals = 9;\r\n        name = \"Paralism-EPARA\";  \r\n        symbol = \"EPARA\";\r\n        _supplyCap = 21000*10000*(10**9);\r\n        totalLocked = 0;\r\n\r\n        balanceOf[msg.sender] = _supplyCap;         //210M\r\n    }\r\n\r\n    /// @notice Return total available liquidity of token\r\n    /// @return total available liquidity of token\r\n    function totalSupply() public view returns (uint256){\r\n        return _supplyCap - totalLocked;\r\n    }\r\n    \r\n    /// @notice transfer tokens with a timer lock to an address, the timer lock would lock up the transfered funds from being spend for given days\r\n    /// @dev this increase totalLocked and reduce the totalSupply\r\n    /// @param _to the receiver address of token\r\n    /// @param _value the amount of token\r\n    /// @param _initLockdays the how long time in days the funds would be locked up, only can be set at when timer lock initializes\r\n    /// @return success true if transaction accomplished\r\n    function transferWithLockInit(address _to, uint256 _value, uint256 _initLockdays) public returns (bool success) {\r\n        require (address(0) != _to,\"transfer to address 0\");\r\n        require (false == isMutltiSignHoldBalance(msg.sender), \"multisign balance hold\");\r\n        require (balanceOf[msg.sender] >= theLockValue(msg.sender).safeAdd(_value),\"insufficient balance or locked\");\r\n\r\n        if (0 < theLockValue(_to)) {\r\n            require (msg.sender == lock[_to].sender,\"others lock detected\") ;\r\n            require (_initLockdays == 0,\"Lock detected, init fail\") ;\r\n        }\r\n\r\n        if (0 == theLockValue(_to)) {\r\n            lock[_to].lockTime = (block.timestamp.safeAdd(_initLockdays * 1 days)).toUint64();           //init expriation day.\r\n            lock[_to].sender= msg.sender;                                                   //init sender\r\n        }\r\n\r\n        lock[_to].lockValue = lock[_to].lockValue.safeAdd(_value);                          //add lock value\r\n        balanceOf[msg.sender] = balanceOf[msg.sender].safeSub(_value);                      //subtract from the sender\r\n        balanceOf[_to] = balanceOf[_to].safeAdd(_value);                                    //add to the recipient\r\n        \r\n        if (true == lock[_to].allowLockTimeUpdate) \r\n            lock[_to].allowLockTimeUpdate = false;                                         //disable sender change lock time until owner allowed again\r\n        \r\n        emit TransferWithLock(msg.sender, _to, _value, lock[_to].lockTime , _initLockdays);\r\n\r\n        totalLocked = totalLocked.safeAdd(_value);    //increase totalLocked\r\n        return true;\r\n    }\r\n    \r\n    /// @notice transfer more tokens to an existed lock\r\n    /// @dev this increase totalLocked and reduce the totalSupply\r\n    /// @param _to the receiver address of token\r\n    /// @param _value the amount of token\r\n    /// @return success true if transaction accomplished\r\n    function transferMoreToLock(address _to, uint256 _value) public returns (bool success) {\r\n        if(0 == theLockValue(_to)) revert(\"NO lock detected\");\r\n        return transferWithLockInit(_to,_value,0);\r\n    }\r\n\r\n    /// @notice get timer locked value in effective on owner address.\r\n    /// @dev contract inernal only,once timer expired, the value will update to 0.\r\n    /// @param _addr the address of lock funds owner\r\n    /// @return amount the effective value of timer lock \r\n    function theLockValue(address _addr) internal returns (uint256 amount){\r\n        if (lock[_addr].lockTime <= block.timestamp) {\r\n            totalLocked = totalLocked.safeSub(lock[_addr].lockValue);           //reduce totalLocked\r\n            lock[_addr].lockValue = 0;                      //reset expired value\r\n        }\r\n        return lock[_addr].lockValue;\r\n    }\r\n\r\n    /// @notice Query timer locked balance of funds on owner address\r\n    /// @param _addr the address of lock funds owner\r\n    /// @return amount the effective value of timer lock \r\n    function getLockValue(address _addr) public view returns (uint256 amount){\r\n        lock[_addr].lockTime > block.timestamp ? amount = lock[_addr].lockValue : amount = 0;\r\n    }\r\n\r\n    /// @notice get lock remaining time in seconds of funds on owner address\r\n    /// @param _addr the address of lock funds owner\r\n    /// @return sec the time in seconds of timer\r\n    function getLockRemainSeconds(address _addr) public view returns (uint256 sec){\r\n        lock[_addr].lockTime > block.timestamp ? sec = lock[_addr].lockTime - block.timestamp : sec = 0;\r\n    }\r\n\r\n    /// @notice the lock expiration could be modify by lock sender\r\n    /// @dev none.\r\n    /// @param _addr the address of lock funds owner\r\n    /// @param _days the how long time in days the funds would be locked up\r\n    /// @return success true if transaction accomplished\r\n    function updateLockTime(address _addr, uint256 _days)public returns (bool success) {\r\n        require(theLockValue(_addr) > 0,\"NO lock detected\");\r\n        require(msg.sender == lock[_addr].sender, \"others lock detected\");\r\n        require(true == lock[_addr].allowLockTimeUpdate,\"allowUpdateLockTime is false\");\r\n\r\n        lock[_addr].lockTime = (block.timestamp.safeAdd(_days * 1 days)).toUint64();\r\n        lock[_addr].allowLockTimeUpdate = false;\r\n        emit UpdateLockTime(msg.sender, _addr, _days);\r\n        return true;\r\n    }\r\n\r\n    /// @notice address Owner switch on to permit lock sender updating the lock expiration or switch off to prohibit the modification\r\n    /// @param _allow the permssion flag\r\n    /// @return success true if transaction accomplished\r\n    function allowUpdateLockTime(bool _allow) public returns (bool success){\r\n        lock[msg.sender].allowLockTimeUpdate = _allow;\r\n        emit AllowUpdateLock(msg.sender, _allow);\r\n        return true;\r\n    }\r\n\r\n    /// @notice address owner return given amount of locked tokens to the lock sender when the lock in effective\r\n    /// @dev this would reduce totalLocked and increase totalSupply.\r\n    /// @param _value the amount return to the lock funds sender\r\n    /// @return success true if transaction accomplished\r\n    function returnLockedTokens(uint256 _value) public returns (bool success){\r\n        address _returnTo = lock[msg.sender].sender;\r\n        address _returnFrom = msg.sender;\r\n\r\n        uint256 lockValue = theLockValue(_returnFrom);\r\n        require(0 < lockValue, \"NO lock detected\");\r\n        require(_value <= lockValue,\"insufficient lock value\");\r\n        require(balanceOf[_returnFrom] >= _value,\"insufficient balance\");\r\n\r\n        balanceOf[_returnFrom] = balanceOf[_returnFrom].safeSub(_value);\r\n        balanceOf[_returnTo] = balanceOf[_returnTo].safeAdd(_value);\r\n\r\n        lock[_returnFrom].lockValue = lock[_returnFrom].lockValue.safeSub(_value);   //reduce locked amount\r\n\r\n        emit ReturnLockedTokens(_returnFrom, _returnTo, _value);\r\n\r\n        totalLocked = totalLocked.safeSub(_value);  //reduce totalLocked\r\n        return true;\r\n    }\r\n\r\n    /// @notice send lock request to an address, the lock would take effective once the adderss owner accept the request\r\n    /// @dev this would have not impact to totalLocked and totalSupply.\r\n    /// @param _to the address of funds owner\r\n    /// @param _value the amount of token requet to locked\r\n    /// @param _initLockdays the how long time in days the funds would be locked up\r\n    /// @return success true if transaction accomplished\r\n    function askToLock(address _to, uint256 _value, uint256 _initLockdays) public returns(bool success) {\r\n        require(balanceOf[_to] >= theLockValue(_to).safeAdd(_value), \"insufficient balance to lock\");\r\n        if (0 < theLockValue(_to)) {\r\n            require (msg.sender == lock[_to].sender,\"others lock detected\") ;\r\n            require (_initLockdays == 0,\"lock time exist\") ;\r\n        }\r\n        lock[_to].askToLock = _value;\r\n        lock[_to].initAskTime = (block.timestamp + _initLockdays * 1 days).toUint64();\r\n        lock[_to].sender = msg.sender;\r\n        \r\n        emit RequestToLock(msg.sender, _to, _value, _initLockdays);\r\n        return true;\r\n    }\r\n\r\n    /// @notice accept a lock request by address owner, the lock take effective\r\n    /// @dev this would increase totalLocked and decrease totalSupply.\r\n    /// @param _sender the address of timer lock request sender\r\n    /// @param _value the amount return to the lock funds sender\r\n    /// @return success true if transaction accomplished\r\n    function acceptLockReq(address _sender, uint256 _value) public returns(bool success) {\r\n        require(lock[msg.sender].askToLock == _value,\"value incorrect\");\r\n        require(balanceOf[msg.sender] >= theLockValue(msg.sender).safeAdd(_value), \"insufficient balance or locked\");//\r\n        require(_sender == lock[msg.sender].sender,\"sender incorrect\");\r\n\r\n        if(0 == theLockValue(msg.sender)) {\r\n            lock[msg.sender].lockTime = lock[msg.sender].initAskTime;\r\n        }\r\n        lock[msg.sender].lockValue = theLockValue(msg.sender).safeAdd(_value);\r\n        totalLocked = totalLocked.safeAdd(_value);    //increase totalLocked\r\n        \r\n        if (true ==lock[msg.sender].allowLockTimeUpdate) \r\n            lock[msg.sender].allowLockTimeUpdate = false;           //disable sender change lock timer until owner permits\r\n            \r\n        emit AcceptLock(msg.sender, _sender, _value, lock[msg.sender].lockTime);\r\n        resetLockReq();\r\n        return true;\r\n    }\r\n\r\n    /// @notice reset a lock request received\r\n    /// @dev this would have not impact to totalLocked and totalSupply.\r\n    /// @return success true if transaction accomplished\r\n    function resetLockReq() public returns(bool success) {\r\n        lock[msg.sender].askToLock = 0;\r\n        lock[msg.sender].initAskTime = 0;\r\n        return true;\r\n    }\r\n\r\n    /// @notice lock sender reduce given amount of locked funds\r\n    /// @dev this would reduce totalLocked and increase totalSupply.\r\n    /// @param _to the address of funds owner\r\n    /// @param _value the amount of locked token to be reudced\r\n    /// @return success true if transaction accomplished\r\n    function reduceLockValue(address _to, uint256 _value) public returns(bool success) {\r\n        require(_value <= theLockValue(_to), \"insufficient lock balance\");\r\n        require (msg.sender == lock[_to].sender,\"others lock detected\") ;\r\n\r\n        lock[_to].lockValue = lock[_to].lockValue.safeSub(_value);\r\n        totalLocked = totalLocked.safeSub(_value);  //reduce totalLocked\r\n        emit ReduceLockValue(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n    \r\n    /// @notice create MultiSign Account on own address \r\n    /// @dev this function will clean previous MultiSign account if it is expired or not activated\r\n    /// @param _approvers the approver address list\r\n    /// @param _individualScores the array of vote weight of each approver\r\n    /// @param _initPassScore passing score of approver's vote\r\n    /// @param _backAccount the account to which MultiSignBalance will transfer when Multisign are cleared   \r\n    /// @param _initExpireDays the days from now on MultiSign account will expire \r\n    /// @return success true if transaction accomplished\r\n    function createMultiSign(address[] memory _approvers, \r\n                             uint[] memory _individualScores, \r\n                             uint _initPassScore, \r\n                             address _backAccount, \r\n                             uint _initExpireDays) \r\n                             public returns(bool) \r\n    {\r\n        require(_initPassScore > 0,\"invalid pass score\");\r\n        require(false == isMultiSignActivated(msg.sender), \"multiSign existed\");\r\n        require(_individualScores.length == _approvers.length,\"arrays length mismatch\");\r\n\r\n        if (0 < multiSign[address(this)].approvers.length) clearMultiSign(address(this));  //have multiSign not activated and not expired, clean\r\n        \r\n        for (uint i = 0; i < _approvers.length; i++) {\r\n            Approver memory a = Approver(_approvers[i],_individualScores[i].toUint64(),false);\r\n            multiSign[msg.sender].approvers.push(a);\r\n            emit MultiSignApprover(msg.sender, _approvers[i], _individualScores[i]);\r\n        }\r\n        multiSign[msg.sender].passScore = _initPassScore.toUint64();\r\n        multiSign[msg.sender].expiration = (block.timestamp+_initExpireDays*1 days).toUint64();\r\n        \r\n        if (address(0) != _backAccount){\r\n            multiSign[msg.sender].backAccount = _backAccount;\r\n        } else {\r\n            multiSign[msg.sender].backAccount = msg.sender;\r\n        }\r\n        \r\n        emit CreateMultiSign(msg.sender,_initPassScore,_backAccount, _initExpireDays);\r\n        return true;\r\n    }\r\n    \r\n    /// @notice check if MultiSign Account activated or not \r\n    /// @dev this function will clean previous MultiSign account if it is expired\r\n    /// @param _multisign the keeper address of MultiSign Account\r\n    /// @return activated true if activated\r\n    function isMultiSignActivated(address _multisign) public returns (bool activated){\r\n        uint score;\r\n        uint length = multiSign[_multisign].approvers.length;\r\n        if (multiSign[_multisign].expiration < block.timestamp && multiSign[_multisign].expiration != 0) { // if expired clean \r\n            clearMultiSign(_multisign); \r\n        }\r\n        else{       //check if actived \r\n            for (uint i = 0; i < length; i++) {\r\n                if(true == multiSign[_multisign].approvers[i].activated){\r\n                    score += multiSign[_multisign].approvers[i].score;\r\n                    if (score >= multiSign[_multisign].passScore) return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    /// @notice check if msg.sender is an approver of MultiSign account \r\n    /// @param _multisign the keeper address of MultiSign Account\r\n    /// @return presence true if msg.sender is approver\r\n    function isApprover(address _multisign) public view returns (bool presence) {\r\n        uint length = multiSign[_multisign].approvers.length;\r\n        require(length > 0, \"multiSign not found\");\r\n        for (uint i = 0; i < length; i++) {\r\n            if (msg.sender == multiSign[_multisign].approvers[i].addr){\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    /// @notice activate an approver of MultiSign Account \r\n    /// @param _multisign the keeper address of MultiSign Account\r\n    /// @return activated true if approver activated\r\n    function activateApprover(address _multisign) public returns(bool activated) \r\n    {\r\n        require(isApprover(_multisign),\"approver only\");\r\n        uint length = multiSign[_multisign].approvers.length;\r\n        for (uint i = 0; i < length; i++) {\r\n            if (msg.sender == multiSign[_multisign].approvers[i].addr){\r\n                if(false == multiSign[_multisign].approvers[i].activated){\r\n                    multiSign[_multisign].approvers[i].activated = true;\r\n                }\r\n                activated = true;\r\n            }\r\n        }\r\n        return activated;\r\n    }\r\n    \r\n    /// @notice vote to agree on freeze or unfreeze keeper address balance   \r\n    /// @dev the vote history of the option to which have just been voted and take effective will be cleaned after execution\r\n    /// @param _multisign the keeper address of MultiSign Account\r\n    /// @param _freeze true for freeze, false for unfreeze\r\n    /// @return success true if transaction accomplished\r\n    function freezeKeeper(address _multisign, bool _freeze) public returns(bool success) \r\n    {\r\n        require(activateApprover(_multisign));\r\n        vote[_multisign][msg.sender].holdBalance = _freeze;\r\n        emit FreezeKeeper(msg.sender, _multisign, _freeze);\r\n\r\n        uint length = multiSign[_multisign].approvers.length;\r\n        uint score = 0;\r\n        for (uint i = 0; i < length; i++) {                     //count score\r\n            if (_freeze == vote[_multisign][multiSign[_multisign].approvers[i].addr].holdBalance) \r\n                score += multiSign[_multisign].approvers[i].score;            //count score by individual score weight\r\n        }\r\n        \r\n        if (true == isMultiSignActivated(_multisign)\r\n            && score >= multiSign[_multisign].passScore \r\n            && multiSign[_multisign].holdFlag != _freeze){           //check if reach passScore,and is necessary to update\r\n            multiSign[_multisign].holdFlag = _freeze;                //update holdFlag\r\n            emit HoldBalance(_multisign, _freeze);\r\n        }\r\n        \r\n        return true;\r\n    }\r\n    \r\n    /// @notice check if MultiSign account set to freeze keeper address balance or not  \r\n    /// @param _multisign the keeper address of MultiSign Account\r\n    /// @return flag the multiSign account holdFlag bool value\r\n    function isMutltiSignHoldBalance(address _multisign) public view returns(bool flag){\r\n        return multiSign[_multisign].holdFlag;\r\n    }\r\n    \r\n    /// @notice vote to agree on tranfer from MultiSignBalance to an receiver address   \r\n    /// @dev the vote history of the option to which have just been voted and take effective will be cleaned after execution\r\n    /// @param _multisign the keeper address of MultiSign Account\r\n    /// @param _to receiver address\r\n    /// @param _value value to transfer\r\n    /// @return success true if transaction accomplished\r\n    function approveTransferTo(address _multisign, address _to, uint _value) public returns(bool success) \r\n    {\r\n        require(address(0) != _to,\"transfer to address 0\");\r\n        require(activateApprover(_multisign));\r\n\r\n        vote[_multisign][msg.sender].approveTrans.to = _to;\r\n        vote[_multisign][msg.sender].approveTrans.value = _value;\r\n        emit ApproveTransferTo(msg.sender,_multisign, _to, _value);\r\n        \r\n        uint length = multiSign[_multisign].approvers.length;\r\n        uint score = 0;\r\n        for (uint i = 0; i < length; i++) {                                    //count score\r\n            if (_to == vote[_multisign][multiSign[_multisign].approvers[i].addr].approveTrans.to\r\n                && _value == vote[_multisign][multiSign[_multisign].approvers[i].addr].approveTrans.value) \r\n                score += multiSign[_multisign].approvers[i].score;             //count score by individual score weight\r\n        }\r\n        \r\n        if (true == isMultiSignActivated(_multisign)\r\n            && score >= multiSign[_multisign].passScore){//check if reach passScore, execute recall\r\n            require(_value <= multiSign[_multisign].multiSignBalance,\"insufficent MultiSign balance\");\r\n            //reset to prevent errorly repeat transfer trigger by more vote \r\n            for (uint i = 0; i < length; i++) {                                                                \r\n                if (_to == vote[_multisign][multiSign[_multisign].approvers[i].addr].approveTrans.to\r\n                    && _value == vote[_multisign][multiSign[_multisign].approvers[i].addr].approveTrans.value) \r\n                {   \r\n                    vote[_multisign][multiSign[_multisign].approvers[i].addr].approveTrans.to = address(0);        //reset\r\n                    vote[_multisign][multiSign[_multisign].approvers[i].addr].approveTrans.value = 0;              //reset\r\n                }\r\n            }\r\n            \r\n            multiSign[_multisign].multiSignBalance = multiSign[_multisign].multiSignBalance.safeSub(_value);     //reduce multiSignBalance\r\n            balanceOf[_to] = balanceOf[_to].safeAdd(_value);                   //increase receiver balance\r\n            emit MultiSignTransfer(_multisign, _to, _value);\r\n            totalLocked = totalLocked.safeSub(_value);  //reduce totalLocked\r\n            }\r\n        \r\n        return true;\r\n    }\r\n    \r\n    /// @notice vote to agree on tranfer from keeper address balance to MultiSignBalances   \r\n    /// @dev the vote history of the option to which have just been voted and take effective will be cleaned after execution\r\n    /// @param _multisign the keeper address of MultiSign Account\r\n    /// @param _value value to transfer\r\n    /// @return success true if transaction accomplished\r\n    function recallToMultiSign(address _multisign, uint _value) public returns(bool success) \r\n    {\r\n        require(activateApprover(_multisign));\r\n        require(0 <_value);\r\n        \r\n        vote[_multisign][msg.sender].recall = _value;         //vote recall\r\n        emit RecallToMultiSign(msg.sender, _multisign, _value);\r\n        \r\n        uint length = multiSign[_multisign].approvers.length;\r\n        uint score = 0;\r\n        for (uint i = 0; i < length; i++) {                     //count score\r\n            if (_value == vote[_multisign][multiSign[_multisign].approvers[i].addr].recall) \r\n                score += multiSign[_multisign].approvers[i].score;             //count score by individual score weight\r\n        }\r\n\r\n        if (true == isMultiSignActivated(_multisign)\r\n            && score >= multiSign[_multisign].passScore\r\n            && balanceOf[_multisign] >= theLockValue(_multisign).safeAdd(_value)){//check if reach passScore and have enough balance, execute recall\r\n            //reset to prevent errorly repeat transfer trigger by more vote\r\n            for (uint i = 0; i < length; i++) {                     \r\n                if (_value == vote[_multisign][multiSign[_multisign].approvers[i].addr].recall) \r\n                    vote[_multisign][multiSign[_multisign].approvers[i].addr].recall = 0;             //reset\r\n            }\r\n            balanceOf[_multisign] = balanceOf[_multisign].safeSub(_value);                                   //reduce keeper's balance\r\n            multiSign[_multisign].multiSignBalance = multiSign[_multisign].multiSignBalance.safeAdd(_value); //increase multiSignBalance\r\n            emit MultiSignRecall(_multisign, _value);\r\n            totalLocked = totalLocked.safeAdd(_value);                                                     //increase totalLocked\r\n        }\r\n        \r\n        return true;\r\n    }\r\n    \r\n    /// @notice vote to agree on update expiration time of MultiSign Account\r\n    /// @dev the vote history of the option to which have just been voted and take effective will be cleaned after execution\r\n    /// @param _multisign the keeper address of MultiSign Account\r\n    /// @param _expireDays new expiration dayss\r\n    /// @return success true if transaction accomplished\r\n    function updateExpiration(address _multisign, uint _expireDays) public returns(bool success) \r\n    {\r\n        require (activateApprover(_multisign));\r\n\r\n        _expireDays = _expireDays.safeAdd(1);     //add vote guard\r\n        \r\n        vote[_multisign][msg.sender].expireDays = _expireDays.toUint64();     //vote expireDays\r\n        emit UpdateExpiration(msg.sender, _multisign, _expireDays);\r\n        \r\n        uint length = multiSign[_multisign].approvers.length;\r\n        uint score = 0;\r\n        for (uint i = 0; i < length; i++) {                     //count score\r\n            if (_expireDays == vote[_multisign][multiSign[_multisign].approvers[i].addr].expireDays) \r\n                score += multiSign[_multisign].approvers[i].score;            //count score by individual score weight\r\n        }\r\n        \r\n        if (true == isMultiSignActivated(_multisign)\r\n            && score >= multiSign[_multisign].passScore){                         //check if reach passScore,\r\n            for (uint i = 0; i < length; i++) {\r\n                vote[_multisign][multiSign[_multisign].approvers[i].addr].expireDays = 0;   //clear voted data\r\n            }  \r\n            _expireDays -= 1;   //clear vote guard\r\n            multiSign[_multisign].expiration = (block.timestamp + (_expireDays) * 1 days).toUint64();             //update multisign expire\r\n            emit MultiSignExpirationUpdated(_multisign, _expireDays);\r\n        }\r\n        \r\n        return true;\r\n    }\r\n    \r\n    /// @notice vote to agree on update back account of MultiSign Account\r\n    /// @dev the vote history of the option to which have just been voted and take effective will be cleaned after execution\r\n    /// @param _multisign the keeper address of MultiSign Account\r\n    /// @param _newBackAccount new back account\r\n    /// @return success true if transaction accomplished\r\n    function updateBackAccount(address _multisign, address _newBackAccount) public returns(bool success)\r\n    {\r\n        require (address(0) != _newBackAccount,\"invalid address\");\r\n        require (activateApprover(_multisign));\r\n        vote[_multisign][msg.sender].backAccount = _newBackAccount;     //vote backAccount\r\n        emit UpdateBackAccount(msg.sender, _multisign, _newBackAccount);\r\n        \r\n        uint length = multiSign[_multisign].approvers.length;\r\n        uint score = 0;\r\n        for (uint i = 0; i < length; i++) {                     //count score\r\n            if (_newBackAccount == vote[_multisign][multiSign[_multisign].approvers[i].addr].backAccount) \r\n                score += multiSign[_multisign].approvers[i].score;            //count score by individual score weight\r\n        }\r\n        \r\n        if (true == isMultiSignActivated(_multisign)\r\n            && score >= multiSign[_multisign].passScore\r\n            && multiSign[_multisign].backAccount != _newBackAccount){     //check if reach passScore,\r\n            multiSign[_multisign].backAccount = _newBackAccount;             //update multisign backAccount\r\n            emit MultiSignBackAccountUpdated(_multisign, _newBackAccount);\r\n        }\r\n        \r\n        return true;\r\n    }\r\n    \r\n    /// @notice clean all vote by msg.sender who is an approver of MultiSign Account\r\n    /// @param _multisign the keeper address of MultiSign Account\r\n    /// @return success true if transaction accomplished\r\n    function cancelVote(address _multisign) public returns(bool success) \r\n    {\r\n        require (activateApprover(_multisign));\r\n        delete vote[_multisign][msg.sender];\r\n        emit CancelVote(msg.sender,_multisign);\r\n        return true;\r\n    }\r\n    \r\n    /// @notice transfer tokens to MultiSign Account Balance if it is activated\r\n    /// @param _multisign the keeper address of MultiSign Account\r\n    /// @param _value token value to transfer\r\n    /// @return success true if transaction accomplished\r\n    function transferToMultiSign(address _multisign, uint _value) public returns(bool success) \r\n    {\r\n        require (address(0) != _multisign,\"transfer to address 0\");\r\n        require (balanceOf[msg.sender] >= theLockValue(msg.sender).safeAdd(_value),\"insufficient balance or locked\");\r\n        require (isMultiSignActivated(_multisign),\"multisign not activated\");\r\n        require (false == isMutltiSignHoldBalance(msg.sender), \"multisign balance hold\");\r\n\r\n        balanceOf[msg.sender] = balanceOf[msg.sender].safeSub(_value);                                    //subtract from the sender\r\n        multiSign[_multisign].multiSignBalance = multiSign[_multisign].multiSignBalance.safeAdd(_value);    //add to the multisignbalance\r\n        emit TransferToMultiSign(msg.sender, _multisign, _value);\r\n        totalLocked = totalLocked.safeAdd(_value);                                                     //increase totalLocked\r\n        return true;\r\n    }\r\n    \r\n    /// @notice get MultiSign account balance\r\n    /// @param _multisign the keeper address of MultiSign Account\r\n    /// @return balanceOfMultiSign value of balance\r\n    function getBalanceOfMultiSign(address _multisign) public view returns(uint balanceOfMultiSign) \r\n    {\r\n        return multiSign[_multisign].multiSignBalance;\r\n    }\r\n    \r\n    /// @notice get MultiSign account approvers\r\n    /// @param _multisign the keeper address of MultiSign Account\r\n    /// @return approvers list\r\n    function getApproversOfMultiSign(address _multisign) public view returns(Approver[] memory approvers) \r\n    {\r\n        return multiSign[_multisign].approvers;\r\n    }\r\n    \r\n    /// @notice clear MultiSign Account if it is not activated or expired\r\n    /// @param _multisign the keeper address of MultiSign Account\r\n    /// @return success true if transaction accomplished\r\n    function clearMultiSign(address _multisign) public returns (bool success) {\r\n        require(isApprover(_multisign) || msg.sender == _multisign);\r\n        \r\n        uint score;\r\n        uint length = multiSign[_multisign].approvers.length;\r\n        for (uint i = 0; i < length; i++) {\r\n            if(true == multiSign[_multisign].approvers[i].activated){\r\n                score += multiSign[_multisign].approvers[i].score;\r\n            }\r\n        }\r\n        \r\n        require(score < multiSign[_multisign].passScore || multiSign[_multisign].expiration < block.timestamp);\r\n            \r\n        for (uint i = 0; i < length; i++) {\r\n            delete vote[_multisign][multiSign[_multisign].approvers[i].addr];   //clear votes\r\n        }\r\n           \r\n        address bAccount = multiSign[_multisign].backAccount;\r\n        uint value = multiSign[_multisign].multiSignBalance;\r\n        if (address(0) != bAccount && 0 < value){                                 //transfer balance to backAccount\r\n            balanceOf[bAccount] = balanceOf[bAccount].safeAdd(value); \r\n            totalLocked = totalLocked.safeSub(value);   //reduce totalLocked\r\n        }\r\n\r\n        delete multiSign[_multisign];                                           //remove multiSign\r\n        emit ClearMutiSign(msg.sender,_multisign,bAccount,value);\r\n        return true;\r\n    }\r\n    \r\n    /// @notice Transfer tokens to multiple addresses\r\n    /// @param _addresses the address list of token receivers\r\n    /// @param _amounts the amount list one to one correspondence to the address list\r\n    /// @return success true if transaction accomplished\r\n    function transferForMultiAddresses(address[] memory _addresses, uint256[] memory _amounts) public returns (bool) {\r\n        require(_addresses.length == _amounts.length,\"arrays length mismatch\");\r\n        require (false == isMutltiSignHoldBalance(msg.sender), \"multisign balance hold\");\r\n\r\n        for (uint i = 0; i < _addresses.length; i++) {\r\n            require(_addresses[i] != address(0),\"transfer to address 0\");\r\n            if (balanceOf[msg.sender] < theLockValue(msg.sender).safeAdd(_amounts[i])) revert(\"insufficient balance or locked\");\r\n\r\n            balanceOf[msg.sender] = balanceOf[msg.sender].safeSub(_amounts[i]);\r\n            balanceOf[_addresses[i]] = balanceOf[_addresses[i]].safeAdd(_amounts[i]);\r\n            emit Transfer(msg.sender, _addresses[i], _amounts[i]);\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    /// @notice token plain transfer to given address\r\n    /// @param _to the receiver address of token\r\n    /// @param _value the amount of token\r\n    /// @return success true if transaction accomplished\r\n    function transfer(address _to, uint256 _value) public returns (bool success){\r\n        if (_to == address(0)) revert(\"transfert to address 0\");\r\n        require (false == isMutltiSignHoldBalance(msg.sender), \"multisign balance hold\");\r\n        require (balanceOf[msg.sender] >= theLockValue(msg.sender).safeAdd(_value),\"insufficient balance or locked\");\r\n\r\n        balanceOf[msg.sender] = balanceOf[msg.sender].safeSub(_value);\r\n        balanceOf[_to] = balanceOf[_to].safeAdd(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n    \r\n    /// @notice approve another address to spend giben tokens on your behalf\r\n    /// @param _spender the address would be given permission\r\n    /// @param _value the amount of token\r\n    /// @return success true if transaction accomplished\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n    \r\n    /// @notice the permitted address spend the approved amount of tokens\r\n    /// @param _from the address approved the spend\r\n    /// @param _to the receiver address of token \r\n    /// @param _value the amount of token\r\n    /// @return success true if transaction accomplished\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        require (_to != address(0), \"transfert to address 0\");\r\n        require (_value <= allowance[_from][msg.sender],\"transfer more than allowance\");\r\n        require (false == isMutltiSignHoldBalance(_from), \"multisign balance hold\");\r\n        require (balanceOf[_from] >= theLockValue(_from).safeAdd(_value),\"insufficient balance or locked\");\r\n\r\n        allowance[_from][msg.sender] = allowance[_from][msg.sender].safeSub(_value);\r\n        balanceOf[_from] = balanceOf[_from].safeSub(_value);\r\n        balanceOf[_to] = balanceOf[_to].safeAdd(_value);\r\n\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n    \r\n    /// @notice burn a given amount of token, unrecoverable\r\n    /// @dev this would reduce _supplyCap\r\n    /// @param _value the amount of token\r\n    /// @return success true if transaction accomplished\r\n    function burn(uint256 _value) public returns (bool success) {\r\n        require (balanceOf[msg.sender] >= theLockValue(msg.sender).safeAdd(_value), \"insufficient balance or locked\");\r\n        require (false == isMutltiSignHoldBalance(msg.sender), \"multisign balance hold\");\r\n\r\n        balanceOf[msg.sender] = balanceOf[msg.sender].safeSub(_value);\r\n        _supplyCap = _supplyCap.safeSub(_value);\r\n        emit Burn(msg.sender, _value);\r\n        return true;\r\n    }\r\n    \r\n    /// @notice move given amount of token from balanceOf into freezeOf \r\n    /// @dev no size impact to _supplyCap\r\n    /// @param _value the amount of token\r\n    /// @return success true if transaction accomplished\r\n    function freeze(uint256 _value) public returns (bool success) {\r\n        if (balanceOf[msg.sender] < _value) revert(\"insufficient balance\");\r\n\r\n        balanceOf[msg.sender] = balanceOf[msg.sender].safeSub(_value);\r\n        freezeOf[msg.sender] = freezeOf[msg.sender].safeAdd(_value);\r\n        emit Freeze(msg.sender, _value);\r\n        return true;\r\n    }\r\n\r\n    /// @notice move given amount of token from freezeOf into balanceOf\r\n    /// @dev no size impact to _supplyCap\r\n    /// @param _value the amount of token\r\n    /// @return success true if transaction accomplished\r\n    function unfreeze(uint256 _value) public returns (bool success) {\r\n        if (freezeOf[msg.sender] < _value) revert(\"insufficient balance.\");\r\n\r\n        freezeOf[msg.sender] = freezeOf[msg.sender].safeSub(_value);\r\n        balanceOf[msg.sender] = balanceOf[msg.sender].safeAdd(_value);\r\n        emit Unfreeze(msg.sender, _value);\r\n        return true;\r\n    }\r\n\r\n }","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockTime\",\"type\":\"uint256\"}],\"name\":\"AcceptLock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"allow\",\"type\":\"bool\"}],\"name\":\"AllowUpdateLock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ApproveTransferTo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"}],\"name\":\"CancelVote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"backAccount\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ClearMutiSign\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"passScore\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"backAccount\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"}],\"name\":\"CreateMultiSign\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Freeze\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"freeze\",\"type\":\"bool\"}],\"name\":\"FreezeKeeper\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_freeze\",\"type\":\"bool\"}],\"name\":\"HoldBalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"individualScore\",\"type\":\"uint256\"}],\"name\":\"MultiSignApprover\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newBackAccount\",\"type\":\"address\"}],\"name\":\"MultiSignBackAccountUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expireDays\",\"type\":\"uint256\"}],\"name\":\"MultiSignExpirationUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"MultiSignRecall\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"MultiSignTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"RecallToMultiSign\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ReduceLockValue\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"intLockDays\",\"type\":\"uint256\"}],\"name\":\"RequestToLock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ReturnLockedTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"valu\",\"type\":\"uint256\"}],\"name\":\"TransferToMultiSign\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"initLockDays\",\"type\":\"uint256\"}],\"name\":\"TransferWithLock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Unfreeze\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newBackAccount\",\"type\":\"address\"}],\"name\":\"UpdateBackAccount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expireDays\",\"type\":\"uint256\"}],\"name\":\"UpdateExpiration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockDays\",\"type\":\"uint256\"}],\"name\":\"UpdateLockTime\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"acceptLockReq\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_multisign\",\"type\":\"address\"}],\"name\":\"activateApprover\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"activated\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_allow\",\"type\":\"bool\"}],\"name\":\"allowUpdateLockTime\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_multisign\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approveTransferTo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_initLockdays\",\"type\":\"uint256\"}],\"name\":\"askToLock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_multisign\",\"type\":\"address\"}],\"name\":\"cancelVote\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_multisign\",\"type\":\"address\"}],\"name\":\"clearMultiSign\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_approvers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_individualScores\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_initPassScore\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_backAccount\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_initExpireDays\",\"type\":\"uint256\"}],\"name\":\"createMultiSign\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"freeze\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_multisign\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_freeze\",\"type\":\"bool\"}],\"name\":\"freezeKeeper\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"freezeOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_multisign\",\"type\":\"address\"}],\"name\":\"getApproversOfMultiSign\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"score\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"activated\",\"type\":\"bool\"}],\"internalType\":\"struct EPARA.Approver[]\",\"name\":\"approvers\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_multisign\",\"type\":\"address\"}],\"name\":\"getBalanceOfMultiSign\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balanceOfMultiSign\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getLockRemainSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"sec\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getLockValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_multisign\",\"type\":\"address\"}],\"name\":\"isApprover\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"presence\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_multisign\",\"type\":\"address\"}],\"name\":\"isMultiSignActivated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"activated\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_multisign\",\"type\":\"address\"}],\"name\":\"isMutltiSignHoldBalance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"flag\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lock\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lockValue\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"lockTime\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"allowLockTimeUpdate\",\"type\":\"bool\"},{\"internalType\":\"uint64\",\"name\":\"initAskTime\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"askToLock\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"multiSign\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"multiSignBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"passScore\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"expiration\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"holdFlag\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"backAccount\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_multisign\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"recallToMultiSign\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"reduceLockValue\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resetLockReq\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"returnLockedTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"transferForMultiAddresses\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferMoreToLock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_multisign\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferToMultiSign\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_initLockdays\",\"type\":\"uint256\"}],\"name\":\"transferWithLockInit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"unfreeze\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_multisign\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_newBackAccount\",\"type\":\"address\"}],\"name\":\"updateBackAccount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_multisign\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_expireDays\",\"type\":\"uint256\"}],\"name\":\"updateExpiration\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_days\",\"type\":\"uint256\"}],\"name\":\"updateLockTime\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"vote\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct EPARA.ApproveTrans\",\"name\":\"approveTrans\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"recall\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"backAccount\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"holdBalance\",\"type\":\"bool\"},{\"internalType\":\"uint64\",\"name\":\"expireDays\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"EPARA","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://b39c1d04092983b0274608ccd34ccb526629a9f80edbaaf51f84089b300a436c"}]}