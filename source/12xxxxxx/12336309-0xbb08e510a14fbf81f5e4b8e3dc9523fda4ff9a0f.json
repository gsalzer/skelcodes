{"status":"1","message":"OK","result":[{"SourceCode":"{\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENCED\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\ncontract Ownable {\\n\\n    address public owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n     * account.\\n     */\\n    constructor(){\\n        owner = msg.sender;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        require(newOwner != address(0));\\n        emit OwnershipTransferred(owner, newOwner);\\n        owner = newOwner;\\n    }\\n}\\n\\n\\n\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\\n\"},\"XIVDatabaseLib.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENCED\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\npragma abicoder v2;\\n\\nlibrary XIVDatabaseLib{\\n    // deficoin struct for deficoinmappings..\\n    struct DefiCoin{\\n        uint16 oracleType;\\n        string currencySymbol;\\n        bool status;\\n    }\\n    struct TimePeriod{\\n        uint256 _days;\\n        bool status;\\n    }\\n     struct FlexibleInfo{\\n        uint256 id;\\n        uint16 upDownPercentage; //10**2\\n        uint16 riskFactor;       //10**2\\n        uint16 rewardFactor;     //10**2\\n        bool status;\\n    }\\n    struct FixedInfo{\\n        uint256 id;\\n        uint256 daysCount;// integer value\\n        uint16 upDownPercentage; //10**2\\n        uint16 riskFactor;       //10**2\\n        uint16 rewardFactor;     //10**2\\n        bool status;\\n    }\\n    struct IndexCoin{\\n        uint16 oracleType;\\n        string currencySymbol;\\n        address contractAddress;\\n        bool status;\\n        uint256 contributionPercentage; //10**2\\n    }\\n    struct BetPriceHistory{\\n        uint256 baseIndexValue;\\n        uint256 actualIndexValue;\\n    }\\n    struct LPLockedInfo{\\n        uint256 lockedTimeStamp;\\n        uint256 amountLocked;\\n    }\\n    struct StakingInfo{\\n        uint256 investmentId;\\n        uint256 stakeAmount;\\n    }\\n    struct IncentiveInfo{\\n        uint256 tillInvestmentId;\\n        uint256 incentiveAmount;\\n        uint256 totalAmountStakedAtIncentiveTime;\\n    }\\n    struct BetInfo{\\n        uint256 id;\\n        uint256 principalAmount;\\n        uint256 amount;\\n        address userAddress;\\n        address contractAddress;\\n        uint256 betType; //\\n        uint256 currentPrice;\\n        uint256 timestamp;\\n        uint256 betTimePeriod;\\n        uint16 checkpointPercent;\\n        uint16 rewardFactor;\\n        uint16 riskFactor;\\n        uint256 adminCommissionFee;\\n        uint16 status; // 0-\\u003ebet active, 1-\\u003ebet won, 2-\\u003ebet lost, 3-\\u003e withdraw before result\\n    }\\n}\\n\"},\"XIVInterface.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENCED\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\npragma abicoder v2;\\n\\nimport \\\"./XIVDatabaseLib.sol\\\";\\n\\ninterface Token{\\n    function decimals() external view returns(uint256);\\n    function symbol() external view returns(string memory);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address who) external view returns (uint256);\\n    function transfer(address to, uint256 value) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n    function approve(address spender, uint256 value) external returns (bool);\\n}\\n\\n\\ninterface OracleWrapper{\\n    function getPrice(string calldata currencySymbol,uint256 oracleType) external view returns (uint256);\\n}\\ninterface DatabaseContract{\\n    function transferTokens(address contractAddress,address userAddress,uint256 amount) external;\\n    function transferFromTokens(address contractAddress,address fromAddress, address toAddress,uint256 amount) external;\\n    function getTokensStaked(address userAddress) external view returns(uint256);\\n    function updateTokensStaked(address userAddress, uint256 amount) external;\\n    function getTokenStakedAmount() external view returns(uint256);\\n    function updateTokenStakedAmount(uint256 _tokenStakedAmount) external;\\n    function getBetId() external view returns(uint256);\\n    function updateBetId(uint256 _userBetId) external;\\n    function updateBetArray(XIVDatabaseLib.BetInfo memory bObject) external;\\n    function getBetArray() external view returns(XIVDatabaseLib.BetInfo[] memory);\\n    function getFindBetInArrayUsingBetIdMapping(uint256 _betid) external view returns(uint256);\\n    function updateFindBetInArrayUsingBetIdMapping(uint256 _betid, uint256 value) external;\\n    function updateUserStakedAddress(address _address) external;\\n    function updateUserStakedAddress(address[] memory _userStakedAddress) external;\\n    function getUserStakedAddress() external view returns(address[] memory);\\n    function getDefiCoinsFixedMapping(address _betContractAddress,bool isFlashVault) external view returns(XIVDatabaseLib.DefiCoin memory);\\n    function getDefiCoinsFlexibleMapping(address _betContractAddress) external view returns(XIVDatabaseLib.DefiCoin memory);\\n    function getFlexibleDefiCoinArray() external view returns(XIVDatabaseLib.FlexibleInfo[] memory);\\n    function getFlexibleIndexArray() external view returns(XIVDatabaseLib.FlexibleInfo[] memory);\\n    function updateBetArrayIndex(XIVDatabaseLib.BetInfo memory bObject, uint256 index) external;\\n    function updateBetIndexForFixedArray(uint256 _betId, XIVDatabaseLib.IndexCoin memory iCArray) external;\\n    function updateBetBaseIndexValue(uint256 _betBaseIndexValueFixed) external;\\n    function getBetBaseIndexValue() external view returns(uint256);\\n    function updateBetPriceHistoryFixedMapping(uint256 _betId, XIVDatabaseLib.BetPriceHistory memory bPHObj) external;\\n    function updateBetActualIndexValue(uint256 _betActualIndexValueFixed) external;\\n    function getBetActualIndexValue() external view returns(uint256);\\n    function getBetIndexForFixedArray(uint256 _betId) external view returns(XIVDatabaseLib.IndexCoin[] memory);\\n    function getBetPriceHistoryFixedMapping(uint256 _betId) external view returns(XIVDatabaseLib.BetPriceHistory memory);\\n    function getXIVTokenContractAddress() external view returns(address);\\n    function getAllIndexContractAddressArray() external view returns(address[] memory);\\n    function getDefiCoinIndexMapping(address _ContractAddress) external view returns(XIVDatabaseLib.IndexCoin memory);\\n    \\n    function updateBetIndexForFlexibleArray(uint256 _betId, XIVDatabaseLib.IndexCoin memory iCArray) external;\\n    function getBetIndexForFlexibleArray(uint256 _betId) external view returns(XIVDatabaseLib.IndexCoin[] memory);\\n    function updateBetPriceHistoryFlexibleMapping(uint256 _betId, XIVDatabaseLib.BetPriceHistory memory bPHObj) external;\\n    function getBetPriceHistoryFlexibleMapping(uint256 _betId) external view returns(XIVDatabaseLib.BetPriceHistory memory);\\n    \\n    function getOracleWrapperContractAddress() external view returns(address);\\n    function getPlentyOneDayPercentage() external view returns(uint256);\\n    function getPlentyThreeDayPercentage(uint256 _days) external view returns(uint256);\\n    function getPlentySevenDayPercentage(uint256 _days) external view returns(uint256);\\n    function getBetsAccordingToUserAddress(address userAddress) external view returns(uint256[] memory);\\n    function updateBetAddressesArray(address userAddress, uint256 _betId) external;\\n    function getRewardGeneratedAmount() external view returns(uint256);\\n    function updateRewardGeneratedAmount(uint256 _rewardGeneratedAmount) external;\\n    function addUserAddressUsedForBetting(address userAddress) external;\\n    function getUserAddressUsedForBetting() external view returns(address[] memory);\\n    function getFixedDefiCoinArray() external view returns(XIVDatabaseLib.FixedInfo[] memory);\\n    function getFixedDefiIndexArray() external view returns(XIVDatabaseLib.FixedInfo[] memory);\\n    function getMaxStakeXIVAmount() external view returns(uint256);\\n    function getMinStakeXIVAmount() external view returns(uint256);\\n    function getBetFactorLP() external view returns(uint256);\\n    function updateActualAmountStakedByUser(address userAddress, uint256 amount) external;\\n    function getActualAmountStakedByUser(address userAddress) external view returns(uint256);\\n    function isDaysAvailable(uint256 _days) external view returns(bool);\\n    function updateExistingBetCheckMapping(address _userAddress,uint256 _betType, address _BetContractAddress,bool status) external;\\n    function getExistingBetCheckMapping(address _userAddress,uint256 _betType, address _BetContractAddress) external view returns(bool);\\n    function updateTotalTransactions(uint256 _totalTransactions) external;\\n    function getTotalTransactions() external view returns(uint256);\\n    function getFlexibleDefiCoinTimePeriodArray() external view returns(XIVDatabaseLib.TimePeriod[] memory);\\n    function getFlexibleIndexTimePeriodArray() external view returns(XIVDatabaseLib.TimePeriod[] memory);\\n    function getMinLPvalue() external view returns(uint256);\\n    function getLockingPeriodForLPMapping(address userAddress) external view returns(XIVDatabaseLib.LPLockedInfo memory);\\n    function updateLockingPeriodForLPMapping(address userAddress, uint256 _amountLocked, uint256 _lockedTimeStamp) external;\\n    function getStakingInfoMapping(address userAddress) external view returns(XIVDatabaseLib.StakingInfo[] memory);\\n    function updateStakingInfoMapping(address userAddress, XIVDatabaseLib.StakingInfo memory sInfo) external;\\n    function getInvestmentId() external view returns(uint256);\\n    function updateInvestmentId(uint256 _investmentId) external;\\n    function getSlotExecutionId() external view returns(uint256);\\n    function updateSlotExecutionId(uint256 _slotExecutionId) external;\\n    function getSlotId() external view returns(uint256);\\n    function updateSlotId(uint256 _slotId) external;\\n    function updateIncentiveMapping(uint256 _slotId, XIVDatabaseLib.IncentiveInfo memory iInfo) external;\\n    function getIncentiveMapping(uint256 _slotId) external view returns(XIVDatabaseLib.IncentiveInfo[] memory);\\n    function emitBetDetails(uint256  betId, uint256  status, uint256  betEndTime) external;\\n    function emitLPEvent(uint256 typeOfLP, address userAddress, uint256 amount, uint256 timestamp) external ;\\n    function updateIsStakeMapping(address userAddress,bool isStake) external;\\n    function getIsStakeMapping(address userAddress) external view returns(bool);\\n    \\n}\\n\"},\"XIVMain.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENCED\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\npragma abicoder v2;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./XIVInterface.sol\\\";\\n\\n\\ncontract XIVMain is Ownable{\\n    \\n    using SafeMath for uint256;\\n    address[] tempArray;\\n    \\n    address public databaseContractAddress=0x18464e4584759A50CE9FC58eA5997F8B0D1EA1d8;\\n    \\n    XIVDatabaseLib.IndexCoin[] tempObjectArray;\\n    \\n    function stakeTokens(uint256 amount) external{\\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\\n        Token tokenObj = Token(dContract.getXIVTokenContractAddress());\\n        require(amount\\u003e=dContract.getMinLPvalue(),\\\"Please enter more amount.\\\");\\n        //check if user has balance\\n        require(tokenObj.balanceOf(msg.sender) \\u003e= amount, \\\"You don\\u0027t have enough XIV balance\\\");\\n        //check if user has provided allowance\\n        require(tokenObj.allowance(msg.sender,databaseContractAddress) \\u003e= amount, \\n        \\\"Please allow smart contract to spend on your behalf\\\");\\n        dContract.transferFromTokens(dContract.getXIVTokenContractAddress(),msg.sender,databaseContractAddress,amount);\\n        \\n        uint256 currentTimeStamp=block.timestamp;\\n        XIVDatabaseLib.StakingInfo memory sInfo= XIVDatabaseLib.StakingInfo({\\n            investmentId:dContract.getInvestmentId(),\\n            stakeAmount:amount\\n        });\\n        dContract.updateStakingInfoMapping(msg.sender,sInfo);\\n        dContract.updateInvestmentId(dContract.getInvestmentId().add(1));\\n        if(!dContract.getIsStakeMapping(msg.sender)){\\n            dContract.updateUserStakedAddress(msg.sender);\\n            dContract.updateIsStakeMapping(msg.sender,true);\\n        }\\n        dContract.updateTokensStaked(msg.sender,dContract.getTokensStaked(msg.sender).add(amount));\\n        dContract.updateActualAmountStakedByUser(msg.sender,dContract.getActualAmountStakedByUser(msg.sender).add(amount));\\n        dContract.updateTokenStakedAmount(dContract.getTokenStakedAmount().add(amount));\\n        dContract.updateTotalTransactions(dContract.getTotalTransactions().add(amount));\\n        if(dContract.getLockingPeriodForLPMapping(msg.sender).lockedTimeStamp\\u003ecurrentTimeStamp){\\n            dContract.updateLockingPeriodForLPMapping(msg.sender,(dContract.getLockingPeriodForLPMapping(msg.sender).amountLocked).add(amount),\\n                                                        dContract.getLockingPeriodForLPMapping(msg.sender).lockedTimeStamp);\\n        }else{\\n            dContract.updateLockingPeriodForLPMapping(msg.sender,amount,currentTimeStamp.add(30 days));\\n        }\\n        dContract.emitLPEvent(0,msg.sender,amount,currentTimeStamp);\\n    }\\n     function unStakeTokens(uint256 amount) external{\\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\\n        uint256 currentTimeStamp=block.timestamp;\\n        if(dContract.getLockingPeriodForLPMapping(msg.sender).lockedTimeStamp\\u003ecurrentTimeStamp){\\n            require(dContract.getTokensStaked(msg.sender).sub(dContract.getLockingPeriodForLPMapping(msg.sender).amountLocked) \\u003e= amount, \\\"You can not retrive LP token with this amount\\\");\\n        }else{\\n            require(dContract.getTokensStaked(msg.sender)\\u003e=amount, \\\"You can not retrive LP token with this amount\\\");\\n        }\\n        dContract.transferTokens(dContract.getXIVTokenContractAddress(),msg.sender,amount);\\n        dContract.updateTokensStaked(msg.sender,dContract.getTokensStaked(msg.sender).sub(amount));\\n        if(amount\\u003edContract.getActualAmountStakedByUser(msg.sender)){\\n            dContract.updateActualAmountStakedByUser(msg.sender,0);\\n        }else{\\n            dContract.updateActualAmountStakedByUser(msg.sender,dContract.getActualAmountStakedByUser(msg.sender).sub(amount));\\n        }\\n        dContract.updateTokenStakedAmount(dContract.getTokenStakedAmount().sub(amount));\\n        dContract.emitLPEvent(1,msg.sender,amount,currentTimeStamp);\\n    }\\n    \\n    function updateDatabaseAddress(address _databaseContractAddress) external onlyOwner{\\n        databaseContractAddress=_databaseContractAddress;\\n    }\\n    \\n}\\n\"}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"databaseContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stakeTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unStakeTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_databaseContractAddress\",\"type\":\"address\"}],\"name\":\"updateDatabaseAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"XIVMain","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"1","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://55378dd91541cd0faf55229956410467340b0b69f5d7babf91216671957bcbd8"}]}