{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIXED\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\n// solhint-disable not-rely-on-time\r\n\r\n// File contracts/interfaces/IOracle.sol\r\n// License-Identifier: MIT\r\n\r\ninterface IOracle {\r\n    /// @notice Get the latest exchange rate.\r\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\r\n    /// For example:\r\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\r\n    /// @return success if no valid (recent) rate is available, return false else true.\r\n    /// @return rate The rate of the requested asset / pair / pool.\r\n    function get(bytes calldata data) external returns (bool success, uint256 rate);\r\n\r\n    /// @notice Check the last exchange rate without any state changes.\r\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\r\n    /// For example:\r\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\r\n    /// @return success if no valid (recent) rate is available, return false else true.\r\n    /// @return rate The rate of the requested asset / pair / pool.\r\n    function peek(bytes calldata data) external view returns (bool success, uint256 rate);\r\n\r\n    /// @notice Check the current spot exchange rate without any state changes. For oracles like TWAP this will be different from peek().\r\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\r\n    /// For example:\r\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\r\n    /// @return rate The rate of the requested asset / pair / pool.\r\n    function peekSpot(bytes calldata data) external view returns (uint256 rate);\r\n\r\n    /// @notice Returns a human readable (short) name about this oracle.\r\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\r\n    /// For example:\r\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\r\n    /// @return (string) A human readable symbol name about this oracle.\r\n    function symbol(bytes calldata data) external view returns (string memory);\r\n\r\n    /// @notice Returns a human readable name about this oracle.\r\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\r\n    /// For example:\r\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\r\n    /// @return (string) A human readable name about this oracle.\r\n    function name(bytes calldata data) external view returns (string memory);\r\n}\r\n\r\n// File @boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol@v1.2.1\r\n// License-Identifier: MIT\r\n\r\n/// @notice A library for performing overflow-/underflow-safe math,\r\n/// updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math).\r\nlibrary BoringMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require(b == 0 || (c = a * b) / b == a, \"BoringMath: Mul Overflow\");\r\n    }\r\n\r\n    function to128(uint256 a) internal pure returns (uint128 c) {\r\n        require(a <= uint128(-1), \"BoringMath: uint128 Overflow\");\r\n        c = uint128(a);\r\n    }\r\n\r\n    function to64(uint256 a) internal pure returns (uint64 c) {\r\n        require(a <= uint64(-1), \"BoringMath: uint64 Overflow\");\r\n        c = uint64(a);\r\n    }\r\n\r\n    function to32(uint256 a) internal pure returns (uint32 c) {\r\n        require(a <= uint32(-1), \"BoringMath: uint32 Overflow\");\r\n        c = uint32(a);\r\n    }\r\n}\r\n\r\n/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint128.\r\nlibrary BoringMath128 {\r\n    function add(uint128 a, uint128 b) internal pure returns (uint128 c) {\r\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\r\n    }\r\n\r\n    function sub(uint128 a, uint128 b) internal pure returns (uint128 c) {\r\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\r\n    }\r\n}\r\n\r\n/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint64.\r\nlibrary BoringMath64 {\r\n    function add(uint64 a, uint64 b) internal pure returns (uint64 c) {\r\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\r\n    }\r\n\r\n    function sub(uint64 a, uint64 b) internal pure returns (uint64 c) {\r\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\r\n    }\r\n}\r\n\r\n/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint32.\r\nlibrary BoringMath32 {\r\n    function add(uint32 a, uint32 b) internal pure returns (uint32 c) {\r\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\r\n    }\r\n\r\n    function sub(uint32 a, uint32 b) internal pure returns (uint32 c) {\r\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\r\n    }\r\n}\r\n\r\n// File @sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol@v1.4.2\r\n// License-Identifier: GPL-3.0\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\r\n\r\n    function feeTo() external view returns (address);\r\n\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function migrator() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n\r\n    function allPairs(uint256) external view returns (address pair);\r\n\r\n    function allPairsLength() external view returns (uint256);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n\r\n    function setFeeToSetter(address) external;\r\n\r\n    function setMigrator(address) external;\r\n}\r\n\r\n// File @sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol@v1.4.2\r\n// License-Identifier: GPL-3.0\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    function name() external pure returns (string memory);\r\n\r\n    function symbol() external pure returns (string memory);\r\n\r\n    function decimals() external pure returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\r\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\r\n    event Swap(address indexed sender, uint256 amount0In, uint256 amount1In, uint256 amount0Out, uint256 amount1Out, address indexed to);\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\r\n\r\n    function factory() external view returns (address);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (\r\n            uint112 reserve0,\r\n            uint112 reserve1,\r\n            uint32 blockTimestampLast\r\n        );\r\n\r\n    function price0CumulativeLast() external view returns (uint256);\r\n\r\n    function price1CumulativeLast() external view returns (uint256);\r\n\r\n    function kLast() external view returns (uint256);\r\n\r\n    function mint(address to) external returns (uint256 liquidity);\r\n\r\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\r\n\r\n    function swap(\r\n        uint256 amount0Out,\r\n        uint256 amount1Out,\r\n        address to,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function skim(address to) external;\r\n\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\n// File contracts/libraries/FullMath.sol\r\n// License-Identifier: CC-BY-4.0\r\n\r\n// taken from https://medium.com/coinmonks/math-in-solidity-part-3-percents-and-proportions-4db014e080b1\r\n// license is CC-BY-4.0\r\nlibrary FullMath {\r\n    function fullMul(uint256 x, uint256 y) private pure returns (uint256 l, uint256 h) {\r\n        uint256 mm = mulmod(x, y, uint256(-1));\r\n        l = x * y;\r\n        h = mm - l;\r\n        if (mm < l) h -= 1;\r\n    }\r\n\r\n    function fullDiv(\r\n        uint256 l,\r\n        uint256 h,\r\n        uint256 d\r\n    ) private pure returns (uint256) {\r\n        uint256 pow2 = d & -d;\r\n        d /= pow2;\r\n        l /= pow2;\r\n        l += h * ((-pow2) / pow2 + 1);\r\n        uint256 r = 1;\r\n        r *= 2 - d * r;\r\n        r *= 2 - d * r;\r\n        r *= 2 - d * r;\r\n        r *= 2 - d * r;\r\n        r *= 2 - d * r;\r\n        r *= 2 - d * r;\r\n        r *= 2 - d * r;\r\n        r *= 2 - d * r;\r\n        return l * r;\r\n    }\r\n\r\n    function mulDiv(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 d\r\n    ) internal pure returns (uint256) {\r\n        (uint256 l, uint256 h) = fullMul(x, y);\r\n        uint256 mm = mulmod(x, y, d);\r\n        if (mm > l) h -= 1;\r\n        l -= mm;\r\n        require(h < d, \"FullMath::mulDiv: overflow\");\r\n        return fullDiv(l, h, d);\r\n    }\r\n}\r\n\r\n// File contracts/libraries/FixedPoint.sol\r\n// License-Identifier: GPL-3.0-or-later\r\n\r\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\r\nlibrary FixedPoint {\r\n    // range: [0, 2**112 - 1]\r\n    // resolution: 1 / 2**112\r\n    struct uq112x112 {\r\n        uint224 _x;\r\n    }\r\n\r\n    // range: [0, 2**144 - 1]\r\n    // resolution: 1 / 2**112\r\n    struct uq144x112 {\r\n        uint256 _x;\r\n    }\r\n\r\n    uint8 private constant RESOLUTION = 112;\r\n    uint256 private constant Q112 = 0x10000000000000000000000000000;\r\n    uint256 private constant Q224 = 0x100000000000000000000000000000000000000000000000000000000;\r\n    uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\r\n\r\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\r\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\r\n        return uint144(self._x >> RESOLUTION);\r\n    }\r\n\r\n    // multiply a UQ112x112 by a uint256, returning a UQ144x112\r\n    // reverts on overflow\r\n    function mul(uq112x112 memory self, uint256 y) internal pure returns (uq144x112 memory) {\r\n        uint256 z = 0;\r\n        require(y == 0 || (z = self._x * y) / y == self._x, \"FixedPoint::mul: overflow\");\r\n        return uq144x112(z);\r\n    }\r\n\r\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\r\n    // lossy if either numerator or denominator is greater than 112 bits\r\n    function fraction(uint256 numerator, uint256 denominator) internal pure returns (uq112x112 memory) {\r\n        require(denominator > 0, \"FixedPoint::fraction: div by 0\");\r\n        if (numerator == 0) return FixedPoint.uq112x112(0);\r\n\r\n        if (numerator <= uint144(-1)) {\r\n            uint256 result = (numerator << RESOLUTION) / denominator;\r\n            require(result <= uint224(-1), \"FixedPoint::fraction: overflow\");\r\n            return uq112x112(uint224(result));\r\n        } else {\r\n            uint256 result = FullMath.mulDiv(numerator, Q112, denominator);\r\n            require(result <= uint224(-1), \"FixedPoint::fraction: overflow\");\r\n            return uq112x112(uint224(result));\r\n        }\r\n    }\r\n}\r\n\r\n// File contracts/oracles/SimpleSLPTWAP0Oracle.sol\r\n// License-Identifier: AGPL-3.0-only\r\n// Using the same Copyleft License as in the original Repository\r\n\r\n// adapted from https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/examples/ExampleSlidingWindowOracle.sol\r\n\r\ncontract SimpleSLPTWAP0OracleV1 is IOracle {\r\n    using FixedPoint for *;\r\n    using BoringMath for uint256;\r\n    uint256 public constant PERIOD = 5 minutes;\r\n\r\n    struct PairInfo {\r\n        uint256 priceCumulativeLast;\r\n        uint32 blockTimestampLast;\r\n        uint144 priceAverage;\r\n    }\r\n\r\n    mapping(IUniswapV2Pair => PairInfo) public pairs; // Map of pairs and their info\r\n    mapping(address => IUniswapV2Pair) public callerInfo; // Map of callers to pairs\r\n\r\n    function _get(IUniswapV2Pair pair, uint32 blockTimestamp) public view returns (uint256) {\r\n        uint256 priceCumulative = pair.price0CumulativeLast();\r\n\r\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\r\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\r\n        priceCumulative += uint256(FixedPoint.fraction(reserve1, reserve0)._x) * (blockTimestamp - blockTimestampLast); // overflows ok\r\n\r\n        // overflow is desired, casting never truncates\r\n        // cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\r\n        return priceCumulative;\r\n    }\r\n\r\n    function getDataParameter(IUniswapV2Pair pair) public pure returns (bytes memory) {\r\n        return abi.encode(pair);\r\n    }\r\n\r\n    // Get the latest exchange rate, if no valid (recent) rate is available, return false\r\n    /// @inheritdoc IOracle\r\n    function get(bytes calldata data) external override returns (bool, uint256) {\r\n        IUniswapV2Pair pair = abi.decode(data, (IUniswapV2Pair));\r\n        uint32 blockTimestamp = uint32(block.timestamp);\r\n        if (pairs[pair].blockTimestampLast == 0) {\r\n            pairs[pair].blockTimestampLast = blockTimestamp;\r\n            pairs[pair].priceCumulativeLast = _get(pair, blockTimestamp);\r\n            return (false, 0);\r\n        }\r\n        uint32 timeElapsed = blockTimestamp - pairs[pair].blockTimestampLast; // overflow is desired\r\n        if (timeElapsed < PERIOD) {\r\n            return (true, pairs[pair].priceAverage);\r\n        }\r\n\r\n        uint256 priceCumulative = _get(pair, blockTimestamp);\r\n        pairs[pair].priceAverage = FixedPoint\r\n            .uq112x112(uint224((priceCumulative - pairs[pair].priceCumulativeLast) / timeElapsed))\r\n            .mul(1e18)\r\n            .decode144();\r\n        pairs[pair].blockTimestampLast = blockTimestamp;\r\n        pairs[pair].priceCumulativeLast = priceCumulative;\r\n\r\n        return (true, pairs[pair].priceAverage);\r\n    }\r\n\r\n    // Check the last exchange rate without any state changes\r\n    /// @inheritdoc IOracle\r\n    function peek(bytes calldata data) public view override returns (bool, uint256) {\r\n        IUniswapV2Pair pair = abi.decode(data, (IUniswapV2Pair));\r\n        uint32 blockTimestamp = uint32(block.timestamp);\r\n        if (pairs[pair].blockTimestampLast == 0) {\r\n            return (false, 0);\r\n        }\r\n        uint32 timeElapsed = blockTimestamp - pairs[pair].blockTimestampLast; // overflow is desired\r\n        if (timeElapsed < PERIOD) {\r\n            return (true, pairs[pair].priceAverage);\r\n        }\r\n\r\n        uint256 priceCumulative = _get(pair, blockTimestamp);\r\n        uint144 priceAverage =\r\n            FixedPoint.uq112x112(uint224((priceCumulative - pairs[pair].priceCumulativeLast) / timeElapsed)).mul(1e18).decode144();\r\n\r\n        return (true, priceAverage);\r\n    }\r\n\r\n    // Check the current spot exchange rate without any state changes\r\n    /// @inheritdoc IOracle\r\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\r\n        IUniswapV2Pair pair = abi.decode(data, (IUniswapV2Pair));\r\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\r\n        rate = reserve1.mul(1e18) / reserve0;\r\n    }\r\n\r\n    /// @inheritdoc IOracle\r\n    function name(bytes calldata) public view override returns (string memory) {\r\n        return \"SushiSwap TWAP\";\r\n    }\r\n\r\n    /// @inheritdoc IOracle\r\n    function symbol(bytes calldata) public view override returns (string memory) {\r\n        return \"TWAP\";\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"name\":\"PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"blockTimestamp\",\"type\":\"uint32\"}],\"name\":\"_get\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"callerInfo\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"get\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"getDataParameter\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pairs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"priceCumulativeLast\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"blockTimestampLast\",\"type\":\"uint32\"},{\"internalType\":\"uint144\",\"name\":\"priceAverage\",\"type\":\"uint144\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"peek\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"peekSpot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"SimpleSLPTWAP0OracleV1","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://5a146b99fde6f39ccdb3bdba7646b69613c4392057d16ba418826217c7ce9bcb"}]}