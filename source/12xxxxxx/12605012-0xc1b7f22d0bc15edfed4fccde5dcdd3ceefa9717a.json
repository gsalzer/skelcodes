{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.16;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract StringUtil {\r\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\r\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\r\n    }\r\n\r\n    function append(string memory a, string memory b) internal pure returns (string memory) {\r\n        return string(abi.encodePacked(a, b));\r\n    }\r\n\r\n    function append2(string memory a, string memory b, string memory c) internal pure returns (string memory) {\r\n        return string(abi.encodePacked(a, b, c));\r\n    }\r\n\r\n    function append3(string memory a, string memory b, string memory c, string memory d) internal pure returns (string memory) {\r\n        return string(abi.encodePacked(a, b, c, d));\r\n    }\r\n\r\n    function bool2str(bool b) internal pure returns(string memory){\r\n        if(b) return \"true\";\r\n\r\n        return \"false\";\r\n    }\r\n\r\n    function address2str(address x) internal pure returns (string memory) {\r\n        bytes memory s = new bytes(40);\r\n        for (uint i = 0; i < 20; i++) {\r\n            bytes1 b = bytes1(uint8(uint(uint160(x)) / (2**(8*(19 - i)))));\r\n            bytes1 hi = bytes1(uint8(b) / 16);\r\n            bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\r\n            s[2*i] = char(hi);\r\n            s[2*i+1] = char(lo);\r\n        }\r\n        return string(s);\r\n    }\r\n\r\n    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\r\n        if (_i == 0) {\r\n            return \"0\";\r\n        }\r\n        uint j = _i;\r\n        uint len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (_i != 0) {\r\n            bstr[k--] = byte(uint8(48 + _i % 10));\r\n            _i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n    function char(bytes1 b) internal pure returns (bytes1 c) {\r\n        if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);\r\n        else return bytes1(uint8(b) + 0x57);\r\n    }\r\n}\r\n\r\ncontract Constants {\r\n    uint internal constant oneMantissa = 10**18;\r\n\r\n    enum LoopControl {\r\n        NONE,\r\n        CONTINUE,\r\n        BREAK\r\n    }\r\n}\r\n\r\ncontract CompoundAddresses {\r\n      address internal constant cDAIAddr = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643;\r\n      address internal constant cETHAddr = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\r\n      address internal constant cUSDCAddr = 0x39AA39c021dfbaE8faC545936693aC917d5E7563;\r\n      address internal constant cUSDTAddr = 0xf650C3d88D12dB855b8bf7D11Be6C55A4e07dCC9;\r\n      address internal constant cWBTCAddr = 0xC11b1268C1A384e55C48c2391d8d480264A3A7F4;\r\n      address internal constant cWBTC2Addr = 0xccF4429DB6322D5C611ee964527D42E5d685DD6a; //migrated at block number 12069867\r\n      address internal constant cCOMPAddr = 0x70e36f6BF80a52b3B46b3aF8e106CC0ed743E8e4;\r\n      address internal constant cSAIAddr = 0xF5DCe57282A584D2746FaF1593d3121Fcac444dC;\r\n      address internal constant compAddr = 0xc00e94Cb662C3520282E6f5717214004A7f26888;\r\n\r\n      address internal constant compoundLensAddr = 0xd513d22422a3062Bd342Ae374b4b9c20E0a9a074;\r\n      address internal constant comptrollerAddr = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\r\n      address internal constant uniswapAnchoredViewAddr = 0x922018674c12a7F0D394ebEEf9B58F186CdE13c1;\r\n\r\n      function getCWBTCAddr(uint blockNumber) public pure returns(address){\r\n          if(blockNumber >= 12069867){\r\n              return cWBTC2Addr;\r\n          }\r\n\r\n          return cWBTCAddr;\r\n      }\r\n}\r\n\r\ncontract ERC20Addresses {\r\n      address internal constant usdtAddr = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\r\n}\r\n\r\ncontract UniswapV2Addresses {\r\n      address internal constant uniswapV2Router02Address = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n      address internal constant wETHAddr = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n}\r\n\r\ncontract ERC20 {\r\n\r\n    uint8 public decimals;\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function transfer(address dst, uint amount) external returns (bool);\r\n    function symbol() external view returns (string memory);\r\n\r\n}\r\n\r\ncontract USDT_ERC20 {\r\n    function approve(address spender, uint value) external;\r\n}\r\n\r\ncontract Comptroller {\r\n    struct Market {\r\n           bool isListed;\r\n           uint collateralFactorMantissa;\r\n           bool isComped;\r\n    }\r\n\r\n    mapping(address => Market) public markets;\r\n    mapping(address => uint) public compAccrued;\r\n\r\n\r\n    uint public closeFactorMantissa;\r\n    uint public liquidationIncentiveMantissa;\r\n    address public oracle;\r\n    function getAccountLiquidity(address account) public view returns (uint, uint, uint);\r\n    function getAssetsIn(address account) external view returns (address[] memory);\r\n    function compSpeeds(address cTokenAddress) external view returns(uint);\r\n    function getAllMarkets() public view returns (CToken[] memory);\r\n\r\n\r\n}\r\n\r\ncontract CToken is ERC20{\r\n    address public underlying;\r\n    uint public totalBorrows;\r\n    uint public totalReserves;\r\n    \r\n    function mint(uint mintAmount) external returns (uint);\r\n    function redeem(uint redeemTokens) external returns (uint);\r\n    function exchangeRateStored() public view returns (uint);\r\n    function balanceOfUnderlying(address owner) external returns (uint);\r\n    function borrowBalanceStored(address account) public view returns (uint);\r\n    function getCash() external view returns (uint);\r\n    function totalBorrowsCurrent() external view returns (uint);\r\n    function borrowRatePerBlock() external view returns (uint);\r\n    function supplyRatePerBlock() external view returns (uint);\r\n    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\r\n}\r\n\r\ncontract PriceOracle {\r\n    function getUnderlyingPrice(CToken cToken) public view returns (uint);\r\n}\r\n\r\ncontract UniswapAnchoredView {\r\n    function price(string memory symbol) public view returns (uint);\r\n}\r\n\r\ncontract CErc20 is CToken {\r\n    address public underlying;\r\n    function liquidateBorrow(address borrower, uint repayAmount, CToken cTokenCollateral) external returns (uint);\r\n}\r\n\r\ncontract CompoundLens {\r\n\r\n    struct CompBalanceMetadataExt{\r\n            uint balance;\r\n            uint votes;\r\n            address delegate;\r\n            uint allocated;\r\n    }\r\n\r\n    function getCompBalanceMetadataExt(Comp comp, ComptrollerLensInterface comptroller, address account) external returns (CompBalanceMetadataExt memory);\r\n\r\n}\r\n\r\ncontract Comp {\r\n\r\n}\r\n\r\ninterface ComptrollerLensInterface {\r\n\r\n}\r\n\r\ncontract ERC20ErrorReporter {\r\n    enum ERC20Error {\r\n        NO_ERROR,\r\n        TRANSFER_FROM_FAILED,\r\n        APPROVE_FAILED,\r\n        TRANSFER_FAILED\r\n    }\r\n\r\n    event fail(uint err);\r\n}\r\n\r\ncontract ERC20Methods is ERC20ErrorReporter, ERC20Addresses{\r\n\r\n    function getDecimals(address token) internal view returns(uint decimals){\r\n        if(token == address(0)){\r\n            return 18;\r\n        }\r\n\r\n        return ERC20(token).decimals();\r\n    }\r\n\r\n    function transferIn(address token, address from, address to, uint amount) internal returns(ERC20Error){\r\n\r\n        if(!ERC20(token).transferFrom(from, to, amount)){\r\n             emit fail(uint(ERC20Error.TRANSFER_FROM_FAILED));\r\n             return ERC20Error.TRANSFER_FROM_FAILED;\r\n        }\r\n\r\n        return ERC20Error.NO_ERROR;\r\n    }\r\n\r\n    function transferOut(address token, address to, uint amount) internal returns(ERC20Error){\r\n        ERC20 erc20 = ERC20(token);\r\n\r\n        if(!erc20.approve(to, amount)){\r\n             emit fail(uint(ERC20Error.APPROVE_FAILED));\r\n             return ERC20Error.APPROVE_FAILED;\r\n        }\r\n\r\n        if(!erc20.transfer(to, amount)){\r\n             emit fail(uint(ERC20Error.TRANSFER_FAILED));\r\n             return ERC20Error.TRANSFER_FAILED;\r\n        }\r\n\r\n        return ERC20Error.NO_ERROR;\r\n    }\r\n\r\n    //works with ETH and ERC20\r\n    function balanceOf(address tokenAddr, address accAddr) internal view returns(uint){\r\n        //for ETH\r\n        if(tokenAddr == address(0)){\r\n            return accAddr.balance;\r\n        }\r\n\r\n        return ERC20(tokenAddr).balanceOf(accAddr);\r\n    }\r\n\r\n    //works with standard and non-standard ERC20\r\n    function approve(address tokenAddr, address spender, uint256 amount) internal returns(bool){\r\n        if(tokenAddr == usdtAddr){\r\n             USDT_ERC20(usdtAddr).approve(spender, 0);\r\n             USDT_ERC20(usdtAddr).approve(spender, amount);\r\n             return true;\r\n        }\r\n\r\n        return ERC20(tokenAddr).approve(spender, amount);\r\n    }\r\n}\r\n\r\ncontract CompoundMethodsErrorReporter {\r\n    enum CompoundMethodsError {\r\n        NO_ERROR,\r\n        Liquidation_Failed,\r\n        APPROVE_FAILED,\r\n        Redeem_Failed\r\n    }\r\n\r\n    event fail(uint err);\r\n    event fail(uint err, uint detail);\r\n}\r\n\r\ncontract CompoundMethods is CompoundMethodsErrorReporter, ERC20Methods, CompoundAddresses, UniswapV2Addresses, Constants, StringUtil{\r\n      using SafeMath for uint;\r\n\r\n      function cmp_redeemUnderlying(address cToken, uint amount) internal returns(CompoundMethodsError err){\r\n          uint error_redeem = CToken(cToken).redeem(amount);\r\n          if(error_redeem != 0){\r\n              emit fail(uint(CompoundMethodsError.Redeem_Failed), error_redeem);\r\n              return CompoundMethodsError.Redeem_Failed;\r\n          }\r\n\r\n          return CompoundMethodsError.NO_ERROR;\r\n      }\r\n\r\n      function cmp_liquidateBorrow(address cTokenBorrowed, address underlyingBorrowed, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns(CompoundMethodsError err){\r\n          //approve USDT won't work\r\n          if(!approve(underlyingBorrowed, cTokenBorrowed, repayAmount)){\r\n              emit fail(uint(CompoundMethodsError.APPROVE_FAILED));\r\n              return CompoundMethodsError.APPROVE_FAILED;\r\n          }\r\n\r\n          //liquidate\r\n          uint err_liquidateBorrow = CErc20(cTokenBorrowed).liquidateBorrow(borrower, repayAmount, cTokenCollateral);\r\n          if(err_liquidateBorrow != 0){\r\n              emit fail(uint(CompoundMethodsError.APPROVE_FAILED), err_liquidateBorrow);\r\n              return CompoundMethodsError.APPROVE_FAILED;\r\n          }\r\n\r\n          return CompoundMethodsError.NO_ERROR;\r\n      }\r\n\r\n      function cmp_getUnderlyingAddr(address cTokenAddr) internal view returns(address underlyingAddr) {\r\n          if(cTokenAddr == cETHAddr){\r\n              return address(0);\r\n          }\r\n\r\n          underlyingAddr = CToken(cTokenAddr).underlying();\r\n\r\n          return underlyingAddr;\r\n      }\r\n\r\n\r\n      function cmp_underlyingValueInUSD(uint underlyingBalance, address cTokenAddr) internal view returns(uint valueInUSD){\r\n\r\n          uint underlyingDecimals = cmp_getUnderlyingDecimals(cTokenAddr);\r\n          valueInUSD = cmp_getUnderlyingPriceInUSD(cTokenAddr).mul(underlyingBalance).div(10**underlyingDecimals);\r\n\r\n          return valueInUSD;\r\n      }\r\n\r\n      function cmp_getUnderlyingPriceInUSD(address cTokenAddr) internal view returns (uint priceInUSD){\r\n\r\n            address oracleAddr = Comptroller(comptrollerAddr).oracle();\r\n\r\n            if(cTokenAddr == cUSDCAddr || cTokenAddr == cUSDTAddr){\r\n                priceInUSD = oneMantissa;\r\n                return priceInUSD;\r\n            }\r\n\r\n            if(cTokenAddr == cWBTC2Addr || cTokenAddr == cWBTCAddr){\r\n                priceInUSD = PriceOracle(oracleAddr).getUnderlyingPrice(CToken(cTokenAddr)).div(10**10);\r\n                return priceInUSD;\r\n            }\r\n\r\n            priceInUSD = PriceOracle(oracleAddr).getUnderlyingPrice(CToken(cTokenAddr));\r\n            return priceInUSD;\r\n      }\r\n\r\n      function cmp_getPriceInUSDByUnderlyingAddr(address underlyingAddr) internal view returns(uint underlyingPriceInUSD){\r\n          string memory symbol = ERC20(underlyingAddr).symbol();\r\n          if(compareStrings(symbol, \"wBTC\")){\r\n              symbol = \"BTC\";\r\n          }\r\n\r\n          return cmp_getPriceBySymbol(symbol).mul(10**12);\r\n      }\r\n\r\n      function cmp_getPriceBySymbol(string memory symbol) internal view returns(uint priceInUSDMantissa6){\r\n          return UniswapAnchoredView(uniswapAnchoredViewAddr).price(symbol);\r\n      }\r\n\r\n      function cmp_getUnderlyingSymbol(address cTokenAddr) internal view returns(string memory getUnderlyingSymbol){\r\n          if(cTokenAddr == cETHAddr) return \"ETH\";\r\n\r\n          if(cTokenAddr == cSAIAddr) return \"SAI\";\r\n\r\n          return ERC20(CToken(cTokenAddr).underlying()).symbol();\r\n      }\r\n\r\n      function cmp_getUnderlyingDecimals(address cTokenAddr) internal view returns(uint decimals){\r\n          if(cTokenAddr == cETHAddr){\r\n               decimals = 18;\r\n               return decimals;\r\n          }\r\n\r\n          address underlyingAddr = cmp_getUnderlyingAddr(cTokenAddr);\r\n          decimals = ERC20(underlyingAddr).decimals();\r\n          return decimals;\r\n      }\r\n\r\n      //not tested\r\n      function cmp_getTotalSupplyInUSD(address cTokenAddr) internal view returns(uint totalSupplyInUSD){\r\n          return cmp_underlyingValueInUSD(cmp_getTotalSupply(cTokenAddr), cTokenAddr);\r\n      }\r\n\r\n      function cmp_getTotalSupply(address cTokenAddr) internal view returns(uint totalSupply){\r\n          CToken cToken = CToken(cTokenAddr);\r\n          uint cash = cToken.getCash();\r\n          uint totalBorrow = cToken.totalBorrows();\r\n          uint totalReserves = cToken.totalReserves();\r\n\r\n          return cash.add(totalBorrow).sub(totalReserves);\r\n      }\r\n\r\n      function cmp_getCompDistSpeedPerBlock(address cTokenAddr) internal view returns(uint compDistSpeedPerBlock){\r\n          Comptroller comptroller = Comptroller(comptrollerAddr);\r\n          return comptroller.compSpeeds(cTokenAddr);\r\n      }\r\n\r\n\r\n      function cmp_getCompDistAmount(address cTokenAddr, uint numberOfBlocks) internal view returns(uint compDistAmount){\r\n          return cmp_getCompDistSpeedPerBlock(cTokenAddr).mul(numberOfBlocks);\r\n      }\r\n\r\n      function cmp_getCurrentCTokenAddrList() internal view returns(address[] memory cTokenAddrList){\r\n            Comptroller comptroller = Comptroller(comptrollerAddr);\r\n            CToken[] memory allMarkets = comptroller.getAllMarkets();\r\n\r\n            cTokenAddrList = new address[](cmp_getNumberOfCurrentCTokens(allMarkets));\r\n\r\n            CToken eachCToken;\r\n            uint index;\r\n            for(uint i = 0; i < allMarkets.length; i++){\r\n                eachCToken = allMarkets[i];\r\n\r\n                if(!cmp_isCurrentCToken(address(eachCToken))) continue;\r\n\r\n                cTokenAddrList[index] = address(eachCToken);\r\n                index++;\r\n            }\r\n\r\n            return cTokenAddrList;\r\n      }\r\n\r\n      function cmp_getCurrentCTokenSymbolList() internal view returns(string[] memory cTokenSymbolList){\r\n            Comptroller comptroller = Comptroller(comptrollerAddr);\r\n            CToken[] memory allMarkets = comptroller.getAllMarkets();\r\n\r\n            cTokenSymbolList = new string[](cmp_getNumberOfCurrentCTokens(allMarkets));\r\n\r\n            CToken eachCToken;\r\n            uint index;\r\n            for(uint i = 0; i < allMarkets.length; i++){\r\n                eachCToken = allMarkets[i];\r\n\r\n                if(!cmp_isCurrentCToken(address(eachCToken))) continue;\r\n\r\n                cTokenSymbolList[index] = eachCToken.symbol();\r\n                index++;\r\n            }\r\n\r\n            return cTokenSymbolList;\r\n      }\r\n\r\n\r\n\r\n      function cmp_isCurrentCToken(address cTokenAddr) internal view returns(bool){\r\n          bool isListed;\r\n          bool isComped;\r\n\r\n          Comptroller comptroller = Comptroller(comptrollerAddr);\r\n          (isListed, , isComped) = comptroller.markets(cTokenAddr);\r\n\r\n          if(isListed && isComped) return true;\r\n\r\n          return false;\r\n      }\r\n\r\n      function cmp_getNumberOfCurrentCTokens(CToken[] memory allMarkets) internal view returns(uint numberOfCurrentCTokens){\r\n\r\n          for(uint i = 0; i < allMarkets.length; i++){\r\n              if(cmp_isCurrentCToken(address(allMarkets[i]))) numberOfCurrentCTokens++;\r\n          }\r\n\r\n          return numberOfCurrentCTokens;\r\n      }\r\n\r\n      function cmp_getPercentageOfStakeOnSupplyMantissa(address acc, address cTokenAddr) internal view returns(uint percentageOfStakeOnSupplyMantissa){\r\n\r\n          uint supplyByTheAcc = cmp_getUnderlyingBalanceOfAnAcc(acc, cTokenAddr);\r\n\r\n          return cmp_calPercentageOfStakeOnSupplyMantissa(cTokenAddr, supplyByTheAcc);\r\n      }\r\n\r\n      function cmp_calPercentageOfStakeOnSupplyMantissa(address cTokenAddr, uint supplyByTheAcc) internal view returns(uint percentageOfStakeOnSupplyMantissa){\r\n          uint totalSupply = cmp_getTotalSupply(cTokenAddr);\r\n\r\n          return supplyByTheAcc.mul(oneMantissa).div(totalSupply);\r\n      }\r\n\r\n      function cmp_getPercentageOfStakeOnBorrowMantissa(address acc, address cTokenAddr) internal view returns(uint percentageOfStakeOnBorrowMantissa){\r\n\r\n          uint err;\r\n          uint borrowByTheAcc;\r\n\r\n          (err, ,borrowByTheAcc, ) = CToken(cTokenAddr).getAccountSnapshot(acc);\r\n\r\n          if(err != 0){\r\n              return 0;\r\n          }\r\n\r\n          return cmp_calPercentageOfStakeOnBorrowMantissa(cTokenAddr, borrowByTheAcc);\r\n      }\r\n\r\n      function cmp_calPercentageOfStakeOnBorrowMantissa(address cTokenAddr, uint borrowByTheAcc) internal view returns(uint percentageOfStakeOnBorrowMantissa){\r\n\r\n          uint totalBorrow = CToken(cTokenAddr).totalBorrows();\r\n\r\n          return borrowByTheAcc.mul(oneMantissa).div(totalBorrow);\r\n      }\r\n\r\n      function cmp_getUnderlyingBalanceOfAnAcc(address acc, address cTokenAddr) internal view returns(uint underlyingBalanceOfAnAcc){\r\n          CToken cToken = CToken(cTokenAddr);\r\n          return cToken.balanceOf(acc).mul(cToken.exchangeRateStored()).div(oneMantissa);\r\n      }\r\n\r\n      function cmp_getBorrowedTokenList(address acc) internal view returns(address[] memory borrowedCTokenList){\r\n          CToken[] memory allMarkets = Comptroller(comptrollerAddr).getAllMarkets();\r\n\r\n          uint length;\r\n          for(uint i = 0; i < allMarkets.length; i++){\r\n//require(false, uint2str(CToken(cDAIAddr).borrowBalanceStored(acc)));\r\n              if(allMarkets[i].borrowBalanceStored(acc) == 0) continue;\r\n\r\n              length++;\r\n          }\r\n\r\n          borrowedCTokenList = new address[](length);\r\n\r\n          uint index;\r\n          for(uint i = 0; i < allMarkets.length; i++){\r\n              if(allMarkets[i].borrowBalanceStored(acc) == 0) continue;\r\n\r\n              borrowedCTokenList[index] = address(allMarkets[i]);\r\n              index++;\r\n          }\r\n\r\n          return borrowedCTokenList;\r\n      }\r\n\r\n      function cmp_getCollateralFactorMantissa(address cTokenAddr) internal view returns(uint collateralFactorMantissa){\r\n          bool isListed;\r\n\r\n          (isListed, collateralFactorMantissa, ) = Comptroller(comptrollerAddr).markets(cTokenAddr);\r\n\r\n          if(!isListed) return 0;\r\n\r\n          return collateralFactorMantissa;\r\n      }\r\n\r\n\r\n\r\n}\r\n\r\ncontract ArrayUtil {\r\n      \r\n      function quickSortDESC(string[] memory keys, uint[] memory values) internal pure returns (string[] memory, uint[] memory){\r\n\r\n            string[] memory keysPlus = new string[](keys.length + 1);\r\n            uint[] memory valuesPlus = new uint[](values.length + 1);\r\n\r\n            for(uint i = 0; i < keys.length; i++){\r\n                keysPlus[i] = keys[i];\r\n                valuesPlus[i] = values[i];\r\n            }\r\n\r\n            (keysPlus, valuesPlus) = quickSort(keysPlus, valuesPlus, 0, keysPlus.length - 1);\r\n\r\n            string[] memory keys_desc = new string[](keys.length);\r\n            uint[] memory values_desc = new uint[](values.length);\r\n            for(uint i = 0; i < keys.length; i++){\r\n                keys_desc[keys.length - 1 - i] = keysPlus[i + 1];\r\n                values_desc[keys.length - 1 - i] = valuesPlus[i + 1];\r\n            }\r\n\r\n            return (keys_desc, values_desc);\r\n      }\r\n\r\n      function quickSort(string[] memory keys, uint[] memory values, uint left, uint right) internal pure returns (string[] memory, uint[] memory){\r\n            uint i = left;\r\n            uint j = right;\r\n            uint pivot = values[left + (right - left) / 2];\r\n            while (i <= j) {\r\n                while (values[i] < pivot) i++;\r\n                while (pivot < values[j]) j--;\r\n                if (i <= j) {\r\n                    (keys[i], keys[j]) = (keys[j], keys[i]);\r\n                    (values[i], values[j]) = (values[j], values[i]);\r\n                    i++;\r\n                    j--;\r\n                }\r\n            }\r\n            if (left < j)\r\n                quickSort(keys, values, left, j);\r\n\r\n            if (i < right)\r\n                quickSort(keys, values, i, right);\r\n\r\n                return (keys, values);\r\n      }\r\n}\r\n\r\ncontract Logging is StringUtil{\r\n\r\n    function debug(string memory name, string[] memory values) internal pure{\r\n        string memory log_name = append(name, \": \");\r\n        string memory valueStr;\r\n\r\n        for(uint i = 0; i < values.length; i++){\r\n            valueStr = append(valueStr, values[i]);\r\n            valueStr = append(valueStr, \", \");\r\n        }\r\n\r\n        require(false, append(log_name, valueStr));\r\n    }\r\n\r\n    function debug(string memory name, address[] memory values) internal pure{\r\n        string memory log_name = append(name, \": \");\r\n        string memory valueStr;\r\n\r\n        for(uint i = 0; i < values.length; i++){\r\n            valueStr = append(valueStr, address2str(values[i]));\r\n            valueStr = append(valueStr, \", \");\r\n        }\r\n\r\n        require(false, append(log_name, valueStr));\r\n    }\r\n\r\n    function debug(string memory name, uint[] memory values) internal pure{\r\n        string memory log_name = append(name, \": \");\r\n        string memory valueStr;\r\n\r\n        for(uint i = 0; i < values.length; i++){\r\n            valueStr = append(valueStr, uint2str(values[i]));\r\n            valueStr = append(valueStr, \", \");\r\n        }\r\n\r\n        require(false, append(log_name, valueStr));\r\n    }\r\n\r\n    function debug(string memory name, string memory value) internal pure{\r\n        string memory log_name = append(name, \": \");\r\n        string memory valueStr = value;\r\n\r\n        require(false, append(log_name, valueStr));\r\n    }\r\n\r\n    function debug(string memory name, address value) internal pure{\r\n        string memory log_name = append(name, \": \");\r\n        string memory valueStr = address2str(value);\r\n\r\n        require(false, append(log_name, valueStr));\r\n    }\r\n\r\n    function debug(string memory name, uint value) internal pure{\r\n        string memory log_name = append(name, \": \");\r\n        string memory valueStr = uint2str(value);\r\n\r\n        require(false, append(log_name, valueStr));\r\n    }\r\n\r\n    function debug(string memory name, bool value) internal pure{\r\n        string memory log_name = append(name, \": \");\r\n        string memory valueStr = bool2str(value);\r\n\r\n        require(false, append(log_name, valueStr));\r\n    }\r\n\r\n\r\n\r\n    event log(string name, address value);\r\n    event log(string name, uint value);\r\n    event log(string name, string value);\r\n    event log(string name, bool value);\r\n    event log(string name, uint[] value);\r\n    event log(string name, address[] value);\r\n\r\n}\r\n\r\ncontract CompFarmingSummaryV3Model is CompoundMethods, ArrayUtil{\r\n    uint256 constant public MAX_INT_NUMBER = 115792089237316195423570985008687907853269984665640564039457584007913129639935;\r\n\r\n    enum LiquidationRiskRanking{\r\n        ZERO_RISK,\r\n        INTEREST_RISK_ONLY,\r\n        PRICE_MOVEMENT_RISK\r\n    }\r\n\r\n    struct CompProfile{\r\n         uint balance;\r\n         uint yetToClaimed;\r\n    }\r\n\r\n    struct AccountInterestProfile{\r\n        CTokenInterest[] supplyInterests;\r\n        CTokenInterest[] borrowInterests;\r\n\r\n        uint totalInterestInUSD_;\r\n        bool isPositiveInterest_;\r\n    }\r\n\r\n    struct CTokenInterest{\r\n        address cTokenAddr;\r\n        uint interestRateMantissa;\r\n        uint balance;\r\n        uint numberOfBlocks;\r\n\r\n        string underlyingSymbol_;\r\n        uint interestInUSD_;\r\n    }\r\n\r\n    struct AccountProfile{\r\n        SupplyAsset[] suppliedAssets;\r\n        BorrowAsset[] borrowedAssets;\r\n\r\n        uint totalSuppliedInUSD_;\r\n        uint totalBorrowedInUSD_;\r\n        uint totalSuppliedInUsdAsCollateral_;\r\n        uint borrowLimitPCTMantissa_;\r\n        uint accountCapital_;\r\n\r\n        uint[] borrowLimitPCTLineItemMantissaList;\r\n    }\r\n\r\n    struct SupplyAsset{\r\n        Asset asset;\r\n\r\n        uint collateralFactorMantissa_;\r\n        uint suppliedInUsdAsCollateral_;\r\n    }\r\n\r\n    struct BorrowAsset{\r\n        Asset asset;\r\n    }\r\n\r\n    struct Asset{\r\n        address cTokenAddr;\r\n        uint amount;\r\n\r\n        string underlyingSymbol_;\r\n        uint underlyingDecimals_;\r\n        uint valueInUSD_;\r\n        uint compSpeed_;\r\n    }\r\n\r\n    function createCTokenInterest(address cTokenAddr, uint interestRateMantissa, uint balance, uint numberOfBlocks) internal view returns(CTokenInterest memory cTokenInterest){\r\n        cTokenInterest.cTokenAddr = cTokenAddr;\r\n        cTokenInterest.interestRateMantissa = interestRateMantissa;\r\n        cTokenInterest.balance = balance;\r\n        cTokenInterest.numberOfBlocks = numberOfBlocks;\r\n\r\n        refreshCTokenInterest(cTokenInterest);\r\n\r\n        return cTokenInterest;\r\n    }\r\n\r\n    function refreshCTokenInterest(CTokenInterest memory cTokenInterest) internal view{\r\n        cTokenInterest.underlyingSymbol_ = cmp_getUnderlyingSymbol(cTokenInterest.cTokenAddr);\r\n        cTokenInterest.interestInUSD_ = cmp_underlyingValueInUSD(cTokenInterest.balance.mul(cTokenInterest.interestRateMantissa), cTokenInterest.cTokenAddr).mul(cTokenInterest.numberOfBlocks).div(oneMantissa);\r\n    }\r\n\r\n    function createAccountInterestProfile(CTokenInterest[] memory supplyInterests, CTokenInterest[] memory borrowInterests) internal pure returns(AccountInterestProfile memory accountInterestProfile){\r\n        accountInterestProfile.supplyInterests = supplyInterests;\r\n        accountInterestProfile.borrowInterests = borrowInterests;\r\n\r\n        refreshAccountInterestProfile(accountInterestProfile);\r\n\r\n        return accountInterestProfile;\r\n    }\r\n\r\n    function refreshAccountInterestProfile(AccountInterestProfile memory accountInterestProfile) internal pure {\r\n        uint totalSupplyInterestInUSD;\r\n        uint totalBorrowInterestInUSD;\r\n\r\n        for(uint i = 0; i < accountInterestProfile.supplyInterests.length; i++){\r\n            totalSupplyInterestInUSD += accountInterestProfile.supplyInterests[i].interestInUSD_;\r\n        }\r\n\r\n        for(uint i = 0; i < accountInterestProfile.borrowInterests.length; i++){\r\n            totalBorrowInterestInUSD += accountInterestProfile.borrowInterests[i].interestInUSD_;\r\n        }\r\n\r\n        if(totalSupplyInterestInUSD > totalBorrowInterestInUSD){\r\n            accountInterestProfile.totalInterestInUSD_ = totalSupplyInterestInUSD.sub(totalBorrowInterestInUSD);\r\n            accountInterestProfile.isPositiveInterest_ = true;\r\n        }\r\n\r\n        if(totalSupplyInterestInUSD <= totalBorrowInterestInUSD){\r\n            accountInterestProfile.totalInterestInUSD_ = totalBorrowInterestInUSD.sub(totalSupplyInterestInUSD);\r\n            accountInterestProfile.isPositiveInterest_ = false;\r\n        }\r\n    }\r\n\r\n    function createSupplyAsset(address cTokenAddr, uint amount) internal view returns(SupplyAsset memory supplyAsset){\r\n        Asset memory asset = createAsset(cTokenAddr, amount);\r\n        supplyAsset.asset = asset;\r\n\r\n        refreshSupplyAsset(supplyAsset);\r\n\r\n        return supplyAsset;\r\n    }\r\n\r\n    function createBorrowAsset(address cTokenAddr, uint amount) internal view returns(BorrowAsset memory borrowAsset){\r\n        Asset memory asset = createAsset(cTokenAddr, amount);\r\n        borrowAsset.asset = asset;\r\n\r\n        return borrowAsset;\r\n    }\r\n\r\n    function updateSupplyAssetAmount(SupplyAsset memory supplyAsset, uint newAmount) internal view{\r\n        supplyAsset.asset.amount = newAmount;\r\n\r\n        refreshAsset(supplyAsset.asset);\r\n        refreshSupplyAsset(supplyAsset);\r\n    }\r\n\r\n    function updateBorrowAssetAmount(BorrowAsset memory borrowAsset, uint newAmount) internal view{\r\n        borrowAsset.asset.amount = newAmount;\r\n\r\n        refreshAsset(borrowAsset.asset);\r\n    }\r\n\r\n    function refreshSupplyAsset(SupplyAsset memory supplyAsset) internal view{\r\n        supplyAsset.collateralFactorMantissa_ = cmp_getCollateralFactorMantissa(supplyAsset.asset.cTokenAddr);\r\n        supplyAsset.suppliedInUsdAsCollateral_ = supplyAsset.asset.valueInUSD_.mul(supplyAsset.collateralFactorMantissa_).div(oneMantissa);\r\n    }\r\n\r\n    function createAsset(address cTokenAddr, uint amount) internal view returns(Asset memory asset){\r\n        updateAsset(asset, cTokenAddr, amount);\r\n\r\n        return asset;\r\n    }\r\n\r\n    function updateAsset(Asset memory asset, address cTokenAddr, uint amount) internal view{\r\n        asset.cTokenAddr = cTokenAddr;\r\n        asset.amount = amount;\r\n\r\n        refreshAsset(asset);\r\n    }\r\n\r\n    function refreshAsset(Asset memory asset) internal view{\r\n        asset.underlyingSymbol_ = cmp_getUnderlyingSymbol(asset.cTokenAddr);\r\n        asset.underlyingDecimals_ = cmp_getUnderlyingDecimals(asset.cTokenAddr);\r\n        asset.valueInUSD_ = cmp_underlyingValueInUSD(asset.amount, asset.cTokenAddr);\r\n        asset.compSpeed_ = cmp_getCompDistSpeedPerBlock(asset.cTokenAddr);\r\n    }\r\n\r\n    function createAccountProfile(SupplyAsset[] memory suppliedAssets, BorrowAsset[] memory borrowedAssets) internal pure returns(AccountProfile memory accountProfile){\r\n        accountProfile.suppliedAssets = suppliedAssets;\r\n        accountProfile.borrowedAssets = borrowedAssets;\r\n\r\n        refreshAccountProfile(accountProfile);\r\n    }\r\n\r\n    function refreshAccountProfile(AccountProfile memory accountProfile) internal pure{\r\n        accountProfile.totalSuppliedInUSD_ = calTotalSuppliedInUSD(accountProfile.suppliedAssets);\r\n        accountProfile.totalBorrowedInUSD_ = calTotalBorrowedInUSD(accountProfile.borrowedAssets);\r\n        accountProfile.totalSuppliedInUsdAsCollateral_ = calTotalSuppliedInUsdAsCollateral(accountProfile.suppliedAssets);\r\n        accountProfile.accountCapital_ = calAccountCapital(accountProfile.totalSuppliedInUSD_, accountProfile.totalBorrowedInUSD_);\r\n        accountProfile.borrowLimitPCTMantissa_ = calBorrowLimitPCTMantissa(accountProfile.totalSuppliedInUsdAsCollateral_, accountProfile.totalBorrowedInUSD_);\r\n        accountProfile.borrowLimitPCTLineItemMantissaList = calBorrowLimitPCTLineItemMantissaList(accountProfile.suppliedAssets, accountProfile.borrowedAssets);\r\n    }\r\n\r\n    function calTotalSuppliedInUSD(SupplyAsset[] memory suppliedAssets) internal pure returns(uint totalSuppliedInUSD){\r\n        for(uint i = 0; i < suppliedAssets.length; i++){\r\n            totalSuppliedInUSD += suppliedAssets[i].asset.valueInUSD_;\r\n        }\r\n\r\n        return totalSuppliedInUSD;\r\n    }\r\n\r\n    function calTotalBorrowedInUSD(BorrowAsset[] memory borrowedAssets) internal pure returns(uint totalBorrowedInUSD){\r\n        for(uint i = 0; i < borrowedAssets.length; i++){\r\n            totalBorrowedInUSD += borrowedAssets[i].asset.valueInUSD_;\r\n        }\r\n\r\n        return totalBorrowedInUSD;\r\n    }\r\n\r\n    function calTotalSuppliedInUsdAsCollateral(SupplyAsset[] memory suppliedAssets) internal pure returns(uint totalSuppliedInUsdAsCollateral){\r\n        for(uint i = 0; i < suppliedAssets.length; i++){\r\n            totalSuppliedInUsdAsCollateral += suppliedAssets[i].suppliedInUsdAsCollateral_;\r\n        }\r\n\r\n        return totalSuppliedInUsdAsCollateral;\r\n    }\r\n\r\n    function calBorrowLimitPCTMantissa(uint totalSuppliedInUsdAsCollateral, uint totalBorrowedInUSD) internal pure returns(uint borrowLimitPCTMantissa){\r\n        if(totalSuppliedInUsdAsCollateral == 0) return oneMantissa;\r\n\r\n        return totalBorrowedInUSD.mul(oneMantissa).div(totalSuppliedInUsdAsCollateral);\r\n    }\r\n\r\n    function calBorrowLimitPCTLineItemMantissaList(SupplyAsset[] memory suppliedAssets, BorrowAsset[] memory borrowedAssets) internal pure returns(uint[] memory borrowLimitPCTLineItemMantissaList){\r\n\r\n        borrowLimitPCTLineItemMantissaList = new uint[](suppliedAssets.length);\r\n\r\n        bool _hasFound;\r\n        BorrowAsset memory _borrowedAsset;\r\n\r\n        for(uint i = 0; i < suppliedAssets.length; i++){\r\n            (_hasFound, _borrowedAsset) = findBorrowedAssetBycTokenAddr(suppliedAssets[i].asset.cTokenAddr, borrowedAssets);\r\n\r\n            if(suppliedAssets[i].suppliedInUsdAsCollateral_ == 0){\r\n                borrowLimitPCTLineItemMantissaList[i] = MAX_INT_NUMBER;\r\n            }\r\n\r\n            if(!_hasFound){\r\n                borrowLimitPCTLineItemMantissaList[i] = 0;\r\n                continue;\r\n            }\r\n\r\n            if(suppliedAssets[i].suppliedInUsdAsCollateral_ != 0){\r\n                borrowLimitPCTLineItemMantissaList[i] = _borrowedAsset.asset.valueInUSD_.mul(oneMantissa).div(suppliedAssets[i].suppliedInUsdAsCollateral_);\r\n            }\r\n\r\n        }\r\n\r\n        return borrowLimitPCTLineItemMantissaList;\r\n    }\r\n\r\n    function calAccountCapital(uint totalSuppliedInUSD, uint totalBorrowedInUSD) internal pure returns(uint accountCapital){\r\n        if(totalSuppliedInUSD > totalBorrowedInUSD){\r\n            return totalSuppliedInUSD.sub(totalBorrowedInUSD);\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    function findBorrowedAssetBycTokenAddr(address cTokenAddr, BorrowAsset[] memory borrowedAssets) internal pure returns(bool hasFound, BorrowAsset memory borrowAsset){\r\n        for(uint i = 0; i < borrowedAssets.length; i++){\r\n            if(borrowedAssets[i].asset.cTokenAddr == cTokenAddr) return (true, borrowedAssets[i]);\r\n        }\r\n\r\n        return (false, borrowAsset);\r\n    }\r\n\r\n    function addSuppliedAsset(AccountProfile memory accountProfile, SupplyAsset memory supplyAsset) internal view{\r\n\r\n        for(uint i = 0; i < accountProfile.suppliedAssets.length; i++){\r\n            if(accountProfile.suppliedAssets[i].asset.cTokenAddr != supplyAsset.asset.cTokenAddr) continue;\r\n\r\n            updateSupplyAssetAmount(accountProfile.suppliedAssets[i], accountProfile.suppliedAssets[i].asset.amount.add(supplyAsset.asset.amount));\r\n            refreshAccountProfile(accountProfile);\r\n\r\n            return;\r\n        }\r\n\r\n        //if not matching existing supplyAsset found\r\n        uint length = accountProfile.suppliedAssets.length.add(1);\r\n        SupplyAsset[] memory newSupplyAsset = new SupplyAsset[](length);\r\n\r\n        for(uint i = 0; i < accountProfile.suppliedAssets.length; i++){\r\n            newSupplyAsset[i] = accountProfile.suppliedAssets[i];\r\n        }\r\n\r\n        newSupplyAsset[length-1] = supplyAsset;\r\n        accountProfile.suppliedAssets = newSupplyAsset;\r\n\r\n        refreshAccountProfile(accountProfile);\r\n    }\r\n\r\n    function addBorrowAsset(AccountProfile memory accountProfile, BorrowAsset memory borrowAsset) internal view{\r\n        for(uint i = 0; i < accountProfile.borrowedAssets.length; i++){\r\n            if(accountProfile.borrowedAssets[i].asset.cTokenAddr != borrowAsset.asset.cTokenAddr) continue;\r\n\r\n            updateBorrowAssetAmount(accountProfile.borrowedAssets[i], accountProfile.borrowedAssets[i].asset.amount.add(borrowAsset.asset.amount));\r\n            refreshAccountProfile(accountProfile);\r\n\r\n            return;\r\n        }\r\n\r\n        uint length = accountProfile.borrowedAssets.length.add(1);\r\n        BorrowAsset[] memory newBorrowAssets = new BorrowAsset[](length);\r\n\r\n        for(uint i = 0; i < accountProfile.borrowedAssets.length; i++){\r\n            newBorrowAssets[i] = accountProfile.borrowedAssets[i];\r\n        }\r\n\r\n        newBorrowAssets[length-1] = borrowAsset;\r\n\r\n        accountProfile.borrowedAssets = newBorrowAssets;\r\n        refreshAccountProfile(accountProfile);\r\n\r\n    }\r\n\r\n    function findSuppliedAsset(address cTokenAddr, SupplyAsset[] memory supplyAssets) internal pure returns(bool hasFound, SupplyAsset memory supplyAsset){\r\n        for(uint i = 0; i < supplyAssets.length; i++){\r\n            if(cTokenAddr == supplyAssets[i].asset.cTokenAddr){\r\n                return (true, supplyAssets[i]);\r\n            }\r\n        }\r\n\r\n        return (false, supplyAsset);\r\n    }\r\n\r\n    function findBorrowAsset(address cTokenAddr, BorrowAsset[] memory borrowAssets) internal pure returns(bool hasFound, BorrowAsset memory borrowAsset){\r\n        for(uint i = 0; i < borrowAssets.length; i++){\r\n            if(cTokenAddr == borrowAssets[i].asset.cTokenAddr){\r\n                return (true, borrowAssets[i]);\r\n            }\r\n        }\r\n\r\n        return (false, borrowAsset);\r\n    }\r\n\r\n    function removeEmptySupplyAsset(SupplyAsset[] memory supplyAssets) internal pure returns(SupplyAsset[] memory newSupplyAssets){\r\n        uint length;\r\n\r\n        for(uint i = 0; i < supplyAssets.length; i++){\r\n            if(supplyAssets[i].asset.valueInUSD_ == 0) continue;\r\n\r\n            length++;\r\n        }\r\n\r\n        newSupplyAssets = new SupplyAsset[](length);\r\n        uint index;\r\n\r\n        for(uint i = 0; i < supplyAssets.length; i++){\r\n            if(supplyAssets[i].asset.valueInUSD_ == 0) continue;\r\n\r\n            newSupplyAssets[index] = supplyAssets[i];\r\n            index++;\r\n        }\r\n\r\n        return newSupplyAssets;\r\n    }\r\n\r\n    function removeEmptyBorrowAsset(BorrowAsset[] memory borrowAssets) internal pure returns(BorrowAsset[] memory newBorrowAssets){\r\n        uint length;\r\n\r\n        for(uint i = 0; i < borrowAssets.length; i++){\r\n            if(borrowAssets[i].asset.valueInUSD_ == 0) continue;\r\n\r\n            length++;\r\n        }\r\n\r\n        newBorrowAssets = new BorrowAsset[](length);\r\n        uint index;\r\n\r\n        for(uint i = 0; i < borrowAssets.length; i++){\r\n            if(borrowAssets[i].asset.valueInUSD_ == 0) continue;\r\n\r\n            newBorrowAssets[index] = borrowAssets[i];\r\n            index++;\r\n        }\r\n\r\n        return newBorrowAssets;\r\n    }\r\n\r\n\r\n}\r\n\r\ncontract CompFarmingSummaryV3 is CompFarmingSummaryV3Model{\r\n\r\n    string constant public version = \"v3\";\r\n    uint constant internal n80PCTMantissa = 800000000000000000;\r\n    uint constant internal n1PCTMantissa = 10000000000000000;\r\n\r\n    uint constant internal borrowLimitPCTDelta = 50000000000000000;\r\n\r\n    function getCompProfile(address acc) external returns(CompProfile memory compProfile){\r\n        return getCompProfileInternal(acc);\r\n    }\r\n\r\n    function getCOMPPriceInUSD() public view returns(uint compPriceInUSD){\r\n        return cmp_getUnderlyingPriceInUSD(cCOMPAddr);\r\n    }\r\n    //bulk testing required\r\n    function getTotalCompReceivable(address acc, uint numberOfBlocks) public view returns(uint totalCompReceivable){\r\n        return getTotalCompReceivableInternal(acc, numberOfBlocks);\r\n    }\r\n\r\n    function getTotalCompReceivablByAP(AccountProfile memory accountProfile, uint numberOfBlocks) public view returns(uint compReceivable){\r\n        return getTotalCompReceivableInternal(accountProfile, numberOfBlocks);\r\n    }\r\n    //bulk testing done\r\n    function getAccountProfile(address acc) external view returns(AccountProfile memory accountProfile){\r\n        return getAccountProfileInternal(acc);\r\n    }\r\n\r\n    function getAccountInterestProfile(address acc, uint numberOfBlocks) external view returns(AccountInterestProfile memory accountInterestProfile){\r\n        return getAccountInterestProfileInternal(acc, numberOfBlocks);\r\n    }\r\n\r\n    function getFarmingAccountProfileByAP(AccountProfile memory accountProfile, uint targetedBorrowLimitPCTMantissa) public view returns(bool isValidated, AccountProfile memory farmingAccountProfile){\r\n        return getFarmingAccountProfileInternal(accountProfile, targetedBorrowLimitPCTMantissa);\r\n    }\r\n\r\n    function getAccountInterestProfileByAP(AccountProfile memory accountProfile, uint numberOfBlocks) public view returns(AccountInterestProfile memory accountInterestProfile){\r\n        return getAccountInterestProfileInternal(accountProfile, numberOfBlocks);\r\n    }\r\n    //bulk testing done\r\n    function getLiquidationRiskRanking(address acc) external view returns(LiquidationRiskRanking liquidationRiskRanking){\r\n        return getLiquidationRiskRankingInternal(acc);\r\n    }\r\n\r\n    function getLiquidationRiskRankingByAP(AccountProfile memory accountProfile) public view returns(LiquidationRiskRanking liquidationRiskRanking){\r\n        return getLiquidationRiskRankingInternal(accountProfile);\r\n    }\r\n\r\n    function getMaxInterestAccountProfileByAP(AccountProfile memory accountProfile) public view returns(bool isValidated, AccountProfile memory maxInterestAccountProfile){\r\n        return getMaxInterestAccountProfileInternal(accountProfile);\r\n    }\r\n\r\n    //internal functions below\r\n    function getTotalCompReceivableInternal(address acc, uint numberOfBlocks) internal view returns(uint compReceivable){\r\n        return getTotalCompReceivableInternal(getAccountProfileInternal(acc), numberOfBlocks);\r\n    }\r\n\r\n    function getCompReceivableOfCToken(uint supplyByTheAcc, uint borrowByTheAcc, address cTokenAddr, uint numberOfBlocks) internal view returns(uint compReceivableByCToken){\r\n\r\n        uint compDistAmount = cmp_getCompDistAmount(cTokenAddr, numberOfBlocks);\r\n        uint percentageOfStakeOnSupplyMantissa = cmp_calPercentageOfStakeOnSupplyMantissa(cTokenAddr, supplyByTheAcc);\r\n        uint percentageOfStakeOnBorrowMantissa = cmp_calPercentageOfStakeOnBorrowMantissa(cTokenAddr, borrowByTheAcc);\r\n        uint decimals = cmp_getUnderlyingDecimals(cCOMPAddr);\r\n\r\n        //formula: compDistAmount * (stakeSupplied + stakeBorrowed)\r\n        compReceivableByCToken = compDistAmount.mul(percentageOfStakeOnSupplyMantissa.add(percentageOfStakeOnBorrowMantissa)).div(10**decimals);\r\n\r\n        return compReceivableByCToken;\r\n    }\r\n\r\n\r\n    function getTotalCompReceivableInternal(AccountProfile memory accountProfile, uint numberOfBlocks) internal view returns(uint compReceivable){\r\n        SupplyAsset[] memory suppliedAssets = accountProfile.suppliedAssets;\r\n        BorrowAsset[] memory borrowedAssets = accountProfile.borrowedAssets;\r\n\r\n        for(uint i = 0; i < suppliedAssets.length; i++){\r\n            compReceivable += getCompReceivableOfCToken(suppliedAssets[i].asset.amount, 0, suppliedAssets[i].asset.cTokenAddr, numberOfBlocks);\r\n        }\r\n\r\n        for(uint i = 0; i < borrowedAssets.length; i++){\r\n            compReceivable += getCompReceivableOfCToken(0, borrowedAssets[i].asset.amount, borrowedAssets[i].asset.cTokenAddr, numberOfBlocks);\r\n        }\r\n\r\n        return compReceivable;\r\n    }\r\n\r\n    function getCompProfileInternal(address acc) internal returns(CompProfile memory compProfile){\r\n\r\n        compProfile.balance = ERC20(compAddr).balanceOf(acc);\r\n\r\n        CompoundLens compoundLens = CompoundLens(compoundLensAddr);\r\n        compProfile.yetToClaimed = compoundLens.getCompBalanceMetadataExt(Comp(compAddr), ComptrollerLensInterface(comptrollerAddr), acc).allocated;\r\n\r\n    }\r\n\r\n    function getAccountProfileInternal(address acc) internal view returns(AccountProfile memory accountProfile){\r\n\r\n        SupplyAsset[] memory suppliedAssets = getSuppliedAssets(acc);\r\n        BorrowAsset[] memory borrowedAssets = getBorrowedAssets(acc);\r\n\r\n        return createAccountProfile(suppliedAssets, borrowedAssets);\r\n    }\r\n\r\n    function getSuppliedAssets(address acc) internal view returns(SupplyAsset[] memory suppliedAssets){\r\n        address[] memory suppliedCTokenAddrList = Comptroller(comptrollerAddr).getAssetsIn(acc);\r\n        suppliedAssets = new SupplyAsset[](suppliedCTokenAddrList.length);\r\n\r\n        for(uint i = 0; i < suppliedCTokenAddrList.length; i++){\r\n            //filter out cSAI\r\n            //if(suppliedCTokenAddrList[i] == 0xF5DCe57282A584D2746FaF1593d3121Fcac444dC) continue;\r\n            suppliedAssets[i] = createSupplyAsset(suppliedCTokenAddrList[i], cmp_getUnderlyingBalanceOfAnAcc(acc, suppliedCTokenAddrList[i]));\r\n        }\r\n\r\n        suppliedAssets = removeEmptySupplyAsset(suppliedAssets);\r\n\r\n        return suppliedAssets;\r\n    }\r\n\r\n    function getBorrowedAssets(address acc) internal view returns(BorrowAsset[] memory borrowedAssets){\r\n        address[] memory borrowedCTokenList = cmp_getBorrowedTokenList(acc);\r\n\r\n        borrowedAssets = new BorrowAsset[](borrowedCTokenList.length);\r\n\r\n        for(uint i = 0; i < borrowedCTokenList.length; i++){\r\n            borrowedAssets[i] = createBorrowAsset(borrowedCTokenList[i], CToken(borrowedCTokenList[i]).borrowBalanceStored(acc));\r\n        }\r\n\r\n        borrowedAssets = removeEmptyBorrowAsset(borrowedAssets);\r\n\r\n        return borrowedAssets;\r\n    }\r\n\r\n\r\n    function getFarmingAccountProfileInternal(AccountProfile memory accountProfile, uint targetedBorrowLimitPCTMantissa) internal view returns(bool isValidated, AccountProfile memory farmingAccountProfile){\r\n        //liquidation risk ranking needs to be lower or equials to 2\r\n        if(uint(getLiquidationRiskRankingInternal(accountProfile)) > 1) return (false, farmingAccountProfile);\r\n\r\n        //each supplied asset, run borrowANDsupplym check util borrowLimitsPCTPerAsset hits 80%withDelta\r\n        SupplyAsset[] memory suppliedAssets = accountProfile.suppliedAssets;\r\n\r\n        for(uint i = 0; i < suppliedAssets.length; i++){\r\n\r\n              if(suppliedAssets[i].collateralFactorMantissa_ == 0) continue;\r\n\r\n              uint maxBorrowAmount;\r\n              BorrowAsset memory moreBorrowAsset;\r\n              SupplyAsset memory moreSupplyAsset;\r\n\r\n              while(accountProfile.borrowLimitPCTLineItemMantissaList[i] <= targetedBorrowLimitPCTMantissa.sub(n1PCTMantissa)){\r\n                  maxBorrowAmount = suppliedAssets[i].asset.amount.mul(suppliedAssets[i].collateralFactorMantissa_).mul(targetedBorrowLimitPCTMantissa.sub(accountProfile.borrowLimitPCTLineItemMantissaList[i])).div(oneMantissa).div(oneMantissa);\r\n                  moreBorrowAsset = createBorrowAsset(suppliedAssets[i].asset.cTokenAddr, maxBorrowAmount);\r\n                  moreSupplyAsset = createSupplyAsset(suppliedAssets[i].asset.cTokenAddr, maxBorrowAmount);\r\n\r\n                  addBorrowAsset(accountProfile, moreBorrowAsset);\r\n                  addSuppliedAsset(accountProfile, moreSupplyAsset);\r\n\r\n              }\r\n        }\r\n\r\n        return (true, accountProfile);\r\n    }\r\n\r\n    function getAccountInterestProfileInternal(address acc, uint numberOfBlocks) internal view returns(AccountInterestProfile memory accountInterestProfile){\r\n        return getAccountInterestProfileInternal(getAccountProfileInternal(acc), numberOfBlocks);\r\n    }\r\n\r\n    function getAccountInterestProfileInternal(AccountProfile memory accountProfile, uint numberOfBlocks) internal view returns(AccountInterestProfile memory accountInterestProfile){\r\n        return createAccountInterestProfile(getSupplyInterests(accountProfile.suppliedAssets, numberOfBlocks), getBorrowInterests(accountProfile.borrowedAssets, numberOfBlocks));\r\n    }\r\n\r\n    function getSupplyInterests(SupplyAsset[] memory supplyAssets, uint numberOfBlocks) internal view returns(CTokenInterest[] memory supplyInterests){\r\n        supplyInterests = new CTokenInterest[](supplyAssets.length);\r\n\r\n        address cTokenAddr;\r\n        uint interestRateMantissa;\r\n        uint balance;\r\n        for(uint i = 0; i < supplyAssets.length; i++){\r\n            cTokenAddr = supplyAssets[i].asset.cTokenAddr;\r\n            interestRateMantissa = CToken(cTokenAddr).supplyRatePerBlock();\r\n            balance = supplyAssets[i].asset.amount;\r\n\r\n            supplyInterests[i] = createCTokenInterest(cTokenAddr, interestRateMantissa, balance, numberOfBlocks);\r\n        }\r\n\r\n        return supplyInterests;\r\n    }\r\n\r\n    function getBorrowInterests(BorrowAsset[] memory borrowedAssets, uint numberOfBlocks) internal view returns(CTokenInterest[] memory borrowInterests){\r\n        borrowInterests = new CTokenInterest[](borrowedAssets.length);\r\n\r\n        address cTokenAddr;\r\n        uint interestRateMantissa;\r\n        uint balance;\r\n        for(uint i = 0; i < borrowedAssets.length; i++){\r\n            cTokenAddr = borrowedAssets[i].asset.cTokenAddr;\r\n            interestRateMantissa = CToken(cTokenAddr).borrowRatePerBlock();\r\n            balance = borrowedAssets[i].asset.amount;\r\n\r\n            borrowInterests[i] = createCTokenInterest(cTokenAddr, interestRateMantissa, balance, numberOfBlocks);\r\n        }\r\n\r\n        return borrowInterests;\r\n    }\r\n\r\n    function getLiquidationRiskRankingInternal(AccountProfile memory accountProfile) internal view returns(LiquidationRiskRanking liquidationRiskRanking){\r\n        //find all the supplied asset\r\n        //find all the matching asset\r\n        //find calBorrowLimitPCTLineItemMantissaList\r\n        //check to see if any borrowed asset outside from supplied asset, acceptable asset require valueInUSD over 1\r\n        //check to see if any borrowed asset with underlying supplied of 0 collateral factor\r\n\r\n        //get account interest profile\r\n\r\n\r\n        liquidationRiskRanking = LiquidationRiskRanking.ZERO_RISK;\r\n///\r\n        if(!getAccountInterestProfileInternal(accountProfile, 1).isPositiveInterest_){\r\n            liquidationRiskRanking = LiquidationRiskRanking.INTEREST_RISK_ONLY;\r\n        }\r\n\r\n        for(uint i = 0; i < accountProfile.borrowLimitPCTLineItemMantissaList.length; i++){\r\n            if(accountProfile.borrowLimitPCTLineItemMantissaList[i] == MAX_INT_NUMBER) continue;\r\n\r\n            if(accountProfile.borrowLimitPCTLineItemMantissaList[i] > oneMantissa) {\r\n                liquidationRiskRanking = LiquidationRiskRanking.PRICE_MOVEMENT_RISK;\r\n                break;\r\n            }\r\n\r\n        }\r\n\r\n        bool hasFound;\r\n        SupplyAsset memory suppliedAsset;\r\n        for(uint i = 0; i < accountProfile.borrowedAssets.length; i++){\r\n            if(accountProfile.borrowedAssets[i].asset.valueInUSD_ < oneMantissa) continue;  //filter small value asset(asset USD value less than 1 USD)\r\n\r\n            (hasFound, suppliedAsset) = findSuppliedAsset(accountProfile.borrowedAssets[i].asset.cTokenAddr, accountProfile.suppliedAssets);\r\n\r\n            if(!hasFound){\r\n                liquidationRiskRanking = LiquidationRiskRanking.PRICE_MOVEMENT_RISK;\r\n                break;\r\n            }\r\n\r\n            if(suppliedAsset.collateralFactorMantissa_ == 0){\r\n                liquidationRiskRanking = LiquidationRiskRanking.PRICE_MOVEMENT_RISK;\r\n                break;\r\n            }\r\n        }\r\n\r\n        return liquidationRiskRanking;\r\n    }\r\n\r\n    function getLiquidationRiskRankingInternal(address acc) internal view returns(LiquidationRiskRanking liquidationRiskRanking){\r\n        return getLiquidationRiskRankingInternal(getAccountProfileInternal(acc));\r\n    }\r\n\r\n    function getMaxInterestAccountProfileInternal(AccountProfile memory accountProfile) internal view returns(bool isValidated, AccountProfile memory maxInterestAccountProfile){\r\n        if(uint(getLiquidationRiskRankingInternal(accountProfile)) > 1) return (false, maxInterestAccountProfile);\r\n\r\n        SupplyAsset[] memory newSupplyAssets = new SupplyAsset[](accountProfile.suppliedAssets.length);\r\n\r\n        address cTokenAddr;\r\n        uint amount;\r\n        bool hasFound;\r\n        BorrowAsset memory borrowedAsset;\r\n        for(uint i = 0; i < accountProfile.suppliedAssets.length; i++){\r\n            cTokenAddr = accountProfile.suppliedAssets[i].asset.cTokenAddr;\r\n\r\n            (hasFound, borrowedAsset) = findBorrowAsset(cTokenAddr, accountProfile.borrowedAssets);\r\n            if(!hasFound){\r\n                amount = accountProfile.suppliedAssets[i].asset.amount;\r\n            }\r\n\r\n            amount = accountProfile.suppliedAssets[i].asset.amount.sub(borrowedAsset.asset.amount);\r\n\r\n            newSupplyAssets[i] = createSupplyAsset(cTokenAddr, amount);\r\n        }\r\n\r\n        BorrowAsset[] memory borrowedAssets;\r\n\r\n        return (true, createAccountProfile(newSupplyAssets, borrowedAssets));\r\n    }\r\n\r\n\r\n\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"err\",\"type\":\"uint256\"}],\"name\":\"fail\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"err\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"detail\",\"type\":\"uint256\"}],\"name\":\"fail\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_INT_NUMBER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"acc\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"numberOfBlocks\",\"type\":\"uint256\"}],\"name\":\"getAccountInterestProfile\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"cTokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"interestRateMantissa\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numberOfBlocks\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"underlyingSymbol_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"interestInUSD_\",\"type\":\"uint256\"}],\"internalType\":\"struct CompFarmingSummaryV3Model.CTokenInterest[]\",\"name\":\"supplyInterests\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"cTokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"interestRateMantissa\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numberOfBlocks\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"underlyingSymbol_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"interestInUSD_\",\"type\":\"uint256\"}],\"internalType\":\"struct CompFarmingSummaryV3Model.CTokenInterest[]\",\"name\":\"borrowInterests\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"totalInterestInUSD_\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isPositiveInterest_\",\"type\":\"bool\"}],\"internalType\":\"struct CompFarmingSummaryV3Model.AccountInterestProfile\",\"name\":\"accountInterestProfile\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"cTokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"underlyingSymbol_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"underlyingDecimals_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"valueInUSD_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"compSpeed_\",\"type\":\"uint256\"}],\"internalType\":\"struct CompFarmingSummaryV3Model.Asset\",\"name\":\"asset\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"collateralFactorMantissa_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"suppliedInUsdAsCollateral_\",\"type\":\"uint256\"}],\"internalType\":\"struct CompFarmingSummaryV3Model.SupplyAsset[]\",\"name\":\"suppliedAssets\",\"type\":\"tuple[]\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"cTokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"underlyingSymbol_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"underlyingDecimals_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"valueInUSD_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"compSpeed_\",\"type\":\"uint256\"}],\"internalType\":\"struct CompFarmingSummaryV3Model.Asset\",\"name\":\"asset\",\"type\":\"tuple\"}],\"internalType\":\"struct CompFarmingSummaryV3Model.BorrowAsset[]\",\"name\":\"borrowedAssets\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"totalSuppliedInUSD_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrowedInUSD_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSuppliedInUsdAsCollateral_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowLimitPCTMantissa_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accountCapital_\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"borrowLimitPCTLineItemMantissaList\",\"type\":\"uint256[]\"}],\"internalType\":\"struct CompFarmingSummaryV3Model.AccountProfile\",\"name\":\"accountProfile\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"numberOfBlocks\",\"type\":\"uint256\"}],\"name\":\"getAccountInterestProfileByAP\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"cTokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"interestRateMantissa\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numberOfBlocks\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"underlyingSymbol_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"interestInUSD_\",\"type\":\"uint256\"}],\"internalType\":\"struct CompFarmingSummaryV3Model.CTokenInterest[]\",\"name\":\"supplyInterests\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"cTokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"interestRateMantissa\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numberOfBlocks\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"underlyingSymbol_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"interestInUSD_\",\"type\":\"uint256\"}],\"internalType\":\"struct CompFarmingSummaryV3Model.CTokenInterest[]\",\"name\":\"borrowInterests\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"totalInterestInUSD_\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isPositiveInterest_\",\"type\":\"bool\"}],\"internalType\":\"struct CompFarmingSummaryV3Model.AccountInterestProfile\",\"name\":\"accountInterestProfile\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"acc\",\"type\":\"address\"}],\"name\":\"getAccountProfile\",\"outputs\":[{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"cTokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"underlyingSymbol_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"underlyingDecimals_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"valueInUSD_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"compSpeed_\",\"type\":\"uint256\"}],\"internalType\":\"struct CompFarmingSummaryV3Model.Asset\",\"name\":\"asset\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"collateralFactorMantissa_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"suppliedInUsdAsCollateral_\",\"type\":\"uint256\"}],\"internalType\":\"struct CompFarmingSummaryV3Model.SupplyAsset[]\",\"name\":\"suppliedAssets\",\"type\":\"tuple[]\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"cTokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"underlyingSymbol_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"underlyingDecimals_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"valueInUSD_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"compSpeed_\",\"type\":\"uint256\"}],\"internalType\":\"struct CompFarmingSummaryV3Model.Asset\",\"name\":\"asset\",\"type\":\"tuple\"}],\"internalType\":\"struct CompFarmingSummaryV3Model.BorrowAsset[]\",\"name\":\"borrowedAssets\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"totalSuppliedInUSD_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrowedInUSD_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSuppliedInUsdAsCollateral_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowLimitPCTMantissa_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accountCapital_\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"borrowLimitPCTLineItemMantissaList\",\"type\":\"uint256[]\"}],\"internalType\":\"struct CompFarmingSummaryV3Model.AccountProfile\",\"name\":\"accountProfile\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCOMPPriceInUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"compPriceInUSD\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"getCWBTCAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"acc\",\"type\":\"address\"}],\"name\":\"getCompProfile\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"yetToClaimed\",\"type\":\"uint256\"}],\"internalType\":\"struct CompFarmingSummaryV3Model.CompProfile\",\"name\":\"compProfile\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"cTokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"underlyingSymbol_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"underlyingDecimals_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"valueInUSD_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"compSpeed_\",\"type\":\"uint256\"}],\"internalType\":\"struct CompFarmingSummaryV3Model.Asset\",\"name\":\"asset\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"collateralFactorMantissa_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"suppliedInUsdAsCollateral_\",\"type\":\"uint256\"}],\"internalType\":\"struct CompFarmingSummaryV3Model.SupplyAsset[]\",\"name\":\"suppliedAssets\",\"type\":\"tuple[]\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"cTokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"underlyingSymbol_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"underlyingDecimals_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"valueInUSD_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"compSpeed_\",\"type\":\"uint256\"}],\"internalType\":\"struct CompFarmingSummaryV3Model.Asset\",\"name\":\"asset\",\"type\":\"tuple\"}],\"internalType\":\"struct CompFarmingSummaryV3Model.BorrowAsset[]\",\"name\":\"borrowedAssets\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"totalSuppliedInUSD_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrowedInUSD_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSuppliedInUsdAsCollateral_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowLimitPCTMantissa_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accountCapital_\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"borrowLimitPCTLineItemMantissaList\",\"type\":\"uint256[]\"}],\"internalType\":\"struct CompFarmingSummaryV3Model.AccountProfile\",\"name\":\"accountProfile\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"targetedBorrowLimitPCTMantissa\",\"type\":\"uint256\"}],\"name\":\"getFarmingAccountProfileByAP\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isValidated\",\"type\":\"bool\"},{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"cTokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"underlyingSymbol_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"underlyingDecimals_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"valueInUSD_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"compSpeed_\",\"type\":\"uint256\"}],\"internalType\":\"struct CompFarmingSummaryV3Model.Asset\",\"name\":\"asset\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"collateralFactorMantissa_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"suppliedInUsdAsCollateral_\",\"type\":\"uint256\"}],\"internalType\":\"struct CompFarmingSummaryV3Model.SupplyAsset[]\",\"name\":\"suppliedAssets\",\"type\":\"tuple[]\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"cTokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"underlyingSymbol_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"underlyingDecimals_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"valueInUSD_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"compSpeed_\",\"type\":\"uint256\"}],\"internalType\":\"struct CompFarmingSummaryV3Model.Asset\",\"name\":\"asset\",\"type\":\"tuple\"}],\"internalType\":\"struct CompFarmingSummaryV3Model.BorrowAsset[]\",\"name\":\"borrowedAssets\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"totalSuppliedInUSD_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrowedInUSD_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSuppliedInUsdAsCollateral_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowLimitPCTMantissa_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accountCapital_\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"borrowLimitPCTLineItemMantissaList\",\"type\":\"uint256[]\"}],\"internalType\":\"struct CompFarmingSummaryV3Model.AccountProfile\",\"name\":\"farmingAccountProfile\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"acc\",\"type\":\"address\"}],\"name\":\"getLiquidationRiskRanking\",\"outputs\":[{\"internalType\":\"enum CompFarmingSummaryV3Model.LiquidationRiskRanking\",\"name\":\"liquidationRiskRanking\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"cTokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"underlyingSymbol_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"underlyingDecimals_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"valueInUSD_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"compSpeed_\",\"type\":\"uint256\"}],\"internalType\":\"struct CompFarmingSummaryV3Model.Asset\",\"name\":\"asset\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"collateralFactorMantissa_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"suppliedInUsdAsCollateral_\",\"type\":\"uint256\"}],\"internalType\":\"struct CompFarmingSummaryV3Model.SupplyAsset[]\",\"name\":\"suppliedAssets\",\"type\":\"tuple[]\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"cTokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"underlyingSymbol_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"underlyingDecimals_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"valueInUSD_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"compSpeed_\",\"type\":\"uint256\"}],\"internalType\":\"struct CompFarmingSummaryV3Model.Asset\",\"name\":\"asset\",\"type\":\"tuple\"}],\"internalType\":\"struct CompFarmingSummaryV3Model.BorrowAsset[]\",\"name\":\"borrowedAssets\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"totalSuppliedInUSD_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrowedInUSD_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSuppliedInUsdAsCollateral_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowLimitPCTMantissa_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accountCapital_\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"borrowLimitPCTLineItemMantissaList\",\"type\":\"uint256[]\"}],\"internalType\":\"struct CompFarmingSummaryV3Model.AccountProfile\",\"name\":\"accountProfile\",\"type\":\"tuple\"}],\"name\":\"getLiquidationRiskRankingByAP\",\"outputs\":[{\"internalType\":\"enum CompFarmingSummaryV3Model.LiquidationRiskRanking\",\"name\":\"liquidationRiskRanking\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"cTokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"underlyingSymbol_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"underlyingDecimals_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"valueInUSD_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"compSpeed_\",\"type\":\"uint256\"}],\"internalType\":\"struct CompFarmingSummaryV3Model.Asset\",\"name\":\"asset\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"collateralFactorMantissa_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"suppliedInUsdAsCollateral_\",\"type\":\"uint256\"}],\"internalType\":\"struct CompFarmingSummaryV3Model.SupplyAsset[]\",\"name\":\"suppliedAssets\",\"type\":\"tuple[]\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"cTokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"underlyingSymbol_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"underlyingDecimals_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"valueInUSD_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"compSpeed_\",\"type\":\"uint256\"}],\"internalType\":\"struct CompFarmingSummaryV3Model.Asset\",\"name\":\"asset\",\"type\":\"tuple\"}],\"internalType\":\"struct CompFarmingSummaryV3Model.BorrowAsset[]\",\"name\":\"borrowedAssets\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"totalSuppliedInUSD_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrowedInUSD_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSuppliedInUsdAsCollateral_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowLimitPCTMantissa_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accountCapital_\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"borrowLimitPCTLineItemMantissaList\",\"type\":\"uint256[]\"}],\"internalType\":\"struct CompFarmingSummaryV3Model.AccountProfile\",\"name\":\"accountProfile\",\"type\":\"tuple\"}],\"name\":\"getMaxInterestAccountProfileByAP\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isValidated\",\"type\":\"bool\"},{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"cTokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"underlyingSymbol_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"underlyingDecimals_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"valueInUSD_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"compSpeed_\",\"type\":\"uint256\"}],\"internalType\":\"struct CompFarmingSummaryV3Model.Asset\",\"name\":\"asset\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"collateralFactorMantissa_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"suppliedInUsdAsCollateral_\",\"type\":\"uint256\"}],\"internalType\":\"struct CompFarmingSummaryV3Model.SupplyAsset[]\",\"name\":\"suppliedAssets\",\"type\":\"tuple[]\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"cTokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"underlyingSymbol_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"underlyingDecimals_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"valueInUSD_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"compSpeed_\",\"type\":\"uint256\"}],\"internalType\":\"struct CompFarmingSummaryV3Model.Asset\",\"name\":\"asset\",\"type\":\"tuple\"}],\"internalType\":\"struct CompFarmingSummaryV3Model.BorrowAsset[]\",\"name\":\"borrowedAssets\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"totalSuppliedInUSD_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrowedInUSD_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSuppliedInUsdAsCollateral_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowLimitPCTMantissa_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accountCapital_\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"borrowLimitPCTLineItemMantissaList\",\"type\":\"uint256[]\"}],\"internalType\":\"struct CompFarmingSummaryV3Model.AccountProfile\",\"name\":\"maxInterestAccountProfile\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"cTokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"underlyingSymbol_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"underlyingDecimals_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"valueInUSD_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"compSpeed_\",\"type\":\"uint256\"}],\"internalType\":\"struct CompFarmingSummaryV3Model.Asset\",\"name\":\"asset\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"collateralFactorMantissa_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"suppliedInUsdAsCollateral_\",\"type\":\"uint256\"}],\"internalType\":\"struct CompFarmingSummaryV3Model.SupplyAsset[]\",\"name\":\"suppliedAssets\",\"type\":\"tuple[]\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"cTokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"underlyingSymbol_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"underlyingDecimals_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"valueInUSD_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"compSpeed_\",\"type\":\"uint256\"}],\"internalType\":\"struct CompFarmingSummaryV3Model.Asset\",\"name\":\"asset\",\"type\":\"tuple\"}],\"internalType\":\"struct CompFarmingSummaryV3Model.BorrowAsset[]\",\"name\":\"borrowedAssets\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"totalSuppliedInUSD_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrowedInUSD_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSuppliedInUsdAsCollateral_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowLimitPCTMantissa_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accountCapital_\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"borrowLimitPCTLineItemMantissaList\",\"type\":\"uint256[]\"}],\"internalType\":\"struct CompFarmingSummaryV3Model.AccountProfile\",\"name\":\"accountProfile\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"numberOfBlocks\",\"type\":\"uint256\"}],\"name\":\"getTotalCompReceivablByAP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"compReceivable\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"acc\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"numberOfBlocks\",\"type\":\"uint256\"}],\"name\":\"getTotalCompReceivable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalCompReceivable\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"CompFarmingSummaryV3","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://059da9e8fb338326f069bdf45a4bfcc034c0672b81114baa65039095278e3f4b"}]}