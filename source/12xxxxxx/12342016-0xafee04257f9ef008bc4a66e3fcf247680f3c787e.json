{"status":"1","message":"OK","result":[{"SourceCode":"{\"BlockchainCutiesToken.sol\":{\"content\":\"pragma solidity ^0.4.23;\\n\\nimport \\\"./CutieERC721Metadata.sol\\\";\\nimport \\\"./ERC721TokenReceiver.sol\\\";\\nimport \\\"./TokenRecipientInterface.sol\\\";\\n\\ncontract BlockchainCutiesToken is CutieERC721Metadata {\\n\\n    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\\n    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\\n\\n    // @dev This struct represents a blockchain Cutie. It was ensured that struct fits well into\\n    // exactly two 256-bit words. The order of the members in this structure\\n    // matters because of the Ethereum byte-packing rules.CutieERC721Metadata\\n    // Reference: http://solidity.readthedocs.io/en/develop/miscellaneous.html\\n    struct Cutie {\\n        // The Cutie\\u0027s genetic code is in these 256-bits. Cutie\\u0027s genes never change.\\n        uint256 genes;\\n\\n        // The timestamp from the block when this cutie was created.\\n        uint40 birthTime;\\n\\n        // The minimum timestamp after which the cutie can start breeding\\n        // again.\\n        uint40 cooldownEndTime;\\n\\n        // The cutie\\u0027s parents ID is set to 0 for gen0 cuties.\\n        uint40 momId;\\n        uint40 dadId;\\n\\n        // Set the index in the cooldown array (see below) that means\\n        // the current cooldown duration for this Cutie. Starts at 0\\n        // for gen0 cats, and is initialized to floor(generation/2) for others.\\n        // Incremented by one for each successful breeding, regardless\\n        // of being cutie mom or cutie dad.\\n        uint16 cooldownIndex;\\n\\n        // The \\\"generation number\\\" of the cutie. Cuties minted by the contract\\n        // for sale are called \\\"gen0\\\" with generation number of 0. All other cuties\\u0027\\n        // generation number is the larger of their parents\\u0027 two generation\\n        // numbers, plus one (i.e. max(mom.generation, dad.generation) + 1)\\n        uint16 generation;\\n\\n        // Some optional data used by external contracts\\n        // Cutie struct is 2x256 bits long.\\n        uint64 optional;\\n    }\\n\\n    bytes4 internal constant INTERFACE_SIGNATURE_ERC721Metadata =\\n        bytes4(keccak256(\\u0027name()\\u0027)) ^\\n        bytes4(keccak256(\\u0027symbol()\\u0027)) ^\\n        bytes4(keccak256(\\u0027tokenURI(uint256)\\u0027));\\n\\n    bytes4 internal constant INTERFACE_SIGNATURE_ERC721Enumerable =\\n        bytes4(keccak256(\\u0027totalSupply()\\u0027)) ^\\n        bytes4(keccak256(\\u0027tokenByIndex(uint256)\\u0027)) ^\\n        bytes4(keccak256(\\u0027tokenOfOwnerByIndex(address, uint256)\\u0027));\\n\\n    // @dev An mapping containing the Cutie struct for all Cuties in existence.\\n    // The ID of each cutie is actually an index into this mapping.\\n    //  ID 0 is the parent of all generation 0 cats, and both parents to itself. It is an invalid genetic code.\\n    mapping (uint40 =\\u003e Cutie) public cuties;\\n\\n    // @dev Total cuties count\\n    uint256 total;\\n\\n    // @dev Core game contract address\\n    address public gameAddress;\\n\\n    // @dev A mapping from cutie IDs to the address that owns them. All cuties have\\n    // some valid owner address, even gen0 cuties are created with a non-zero owner.\\n    mapping (uint40 =\\u003e address) public cutieIndexToOwner;\\n\\n    // @dev A mapping from owner address to count of tokens that address owns.\\n    // Used internally inside balanceOf() to resolve ownership count.\\n    mapping (address =\\u003e uint256) ownershipTokenCount;\\n\\n    // @dev A mapping from CutieIDs to an address that has been approved to call\\n    // transferFrom(). A Cutie can have one approved address for transfer\\n    // at any time. A zero value means that there is no outstanding approval.\\n    mapping (uint40 =\\u003e address) public cutieIndexToApproved;\\n\\n    // @dev A mapping from Cuties owner (account) to an address that has been approved to call\\n    // transferFrom() for all cuties, owned by owner.\\n    // Only one approved address is permitted for each account for transfer\\n    // at any time. A zero value means there is no outstanding approval.\\n    mapping (address =\\u003e mapping (address =\\u003e bool)) public addressToApprovedAll;\\n\\n    // Modifiers to check that inputs can be safely stored with a certain number of bits\\n    modifier canBeStoredIn40Bits(uint256 _value) {\\n        require(_value \\u003c= 0xFFFFFFFFFF, \\\"Value can\\u0027t be stored in 40 bits\\\");\\n        _;\\n    }\\n\\n    modifier onlyGame {\\n        require(msg.sender == gameAddress || msg.sender == ownerAddress, \\\"Access denied\\\");\\n        _;\\n    }\\n\\n    constructor() public {\\n        // Starts paused.\\n        paused = true;\\n    }\\n\\n    // @dev Accept all Ether\\n    function() external payable {}\\n\\n    function setup(uint256 _total) external onlyGame whenPaused {\\n        require(total == 0, \\\"Contract already initialized\\\");\\n        total = _total;\\n        paused = false;\\n    }\\n\\n    function setGame(address _gameAddress) external onlyOwner {\\n        gameAddress = _gameAddress;\\n    }\\n\\n    // @notice Query if a contract implements an interface\\n    // @param interfaceID The interface identifier, as specified in ERC-165\\n    // @dev Interface identification is specified in ERC-165. This function\\n    //  uses less than 30,000 gas.\\n    // @return `true` if the contract implements `interfaceID` and\\n    //  `interfaceID` is not 0xffffffff, `false` otherwise\\n    function supportsInterface(bytes4 interfaceID) external pure returns (bool) {\\n        return\\n        interfaceID == 0x6466353c ||\\n        interfaceID == 0x80ac58cd || // ERC721\\n        interfaceID == INTERFACE_SIGNATURE_ERC721Metadata ||\\n        interfaceID == INTERFACE_SIGNATURE_ERC721Enumerable ||\\n        interfaceID == bytes4(keccak256(\\u0027supportsInterface(bytes4)\\u0027));\\n    }\\n\\n    // @notice Returns the total number of Cuties in existence.\\n    // @dev Required for ERC-721 compliance.\\n    function totalSupply() public view returns (uint256) {\\n        return total;\\n    }\\n\\n    // @notice Returns the number of Cuties owned by a specific address.\\n    // @param _owner The owner address to check.\\n    // @dev Required for ERC-721 compliance\\n    function balanceOf(address _owner) external view returns (uint256) {\\n        require(_owner != 0x0, \\\"Owner can\\u0027t be zero address\\\");\\n        return ownershipTokenCount[_owner];\\n    }\\n\\n    // @notice Returns the address currently assigned ownership of a given Cutie.\\n    // @dev Required for ERC-721 compliance.\\n    function ownerOf(uint256 _cutieId) external view canBeStoredIn40Bits(_cutieId) returns (address owner) {\\n        owner = cutieIndexToOwner[uint40(_cutieId)];\\n        require(owner != address(0), \\\"Owner query for nonexistent token\\\");\\n    }\\n\\n    // @notice Returns the address currently assigned ownership of a given Cutie.\\n    // @dev do not revert when cutie has no owner\\n    function ownerOfCutie(uint256 _cutieId) external view canBeStoredIn40Bits(_cutieId) returns (address) {\\n        return cutieIndexToOwner[uint40(_cutieId)];\\n    }\\n\\n    // @notice Enumerate valid NFTs\\n    // @dev Throws if `_index` \\u003e= `totalSupply()`.\\n    // @param _index A counter less than `totalSupply()`\\n    // @return The token identifier for the `_index`th NFT,\\n    //  (sort order not specified)\\n    function tokenByIndex(uint256 _index) external view returns (uint256) {\\n        require(_index \\u003c total);\\n        return _index - 1;\\n    }\\n\\n    // @notice Returns the nth Cutie assigned to an address, with n specified by the\\n    //  _index argument.\\n    // @param _owner The owner of the Cuties we are interested in.\\n    // @param _index The zero-based index of the cutie within the owner\\u0027s list of cuties.\\n    //  Must be less than balanceOf(_owner).\\n    // @dev This method must not be called by smart contract code. It will almost\\n    //  certainly blow past the block gas limit once there are a large number of\\n    //  Cuties in existence. Exists only to allow off-chain queries of ownership.\\n    //  Optional method for ERC-721.\\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 cutieId) {\\n        require(_owner != 0x0, \\\"Owner can\\u0027t be 0x0\\\");\\n        uint40 count = 0;\\n        for (uint40 i = 1; i \\u003c= totalSupply(); ++i) {\\n            if (_isOwner(_owner, i)) {\\n                if (count == _index) {\\n                    return i;\\n                } else {\\n                    count++;\\n                }\\n            }\\n        }\\n        revert();\\n    }\\n\\n    // @notice Transfers the ownership of an NFT from one address to another address.\\n    // @dev Throws unless `msg.sender` is the current owner, an authorized\\n    //  operator, or the approved address for this NFT. Throws if `_from` is\\n    //  not the current owner. Throws if `_to` is the zero address. Throws if\\n    //  `_tokenId` is not a valid NFT. When transfer is complete, this function\\n    //  checks if `_to` is a smart contract (code size \\u003e 0). If so, it calls\\n    //  `onERC721Received` on `_to` and throws if the return value is not\\n    //  `bytes4(keccak256(\\\"onERC721Received(address,uint256,bytes)\\\"))`.\\n    // @param _from The current owner of the NFT\\n    // @param _to The new owner\\n    // @param _tokenId The NFT to transfer\\n    // @param data Additional data with no specified format, sent in call to `_to`\\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory data) public whenNotPaused canBeStoredIn40Bits(_tokenId) {\\n        transferFrom(_from, _to, uint40(_tokenId));\\n\\n        if (_isContract(_to)) {\\n            ERC721TokenReceiver(_to).onERC721Received(_from, _tokenId, data);\\n        }\\n    }\\n\\n    // @notice Transfers the ownership of an NFT from one address to another address\\n    // @dev This works identically to the other function with an extra data parameter,\\n    // except this function just sets data to \\\"\\\"\\n    // @param _from The current owner of the NFT\\n    // @param _to The new owner\\n    // @param _tokenId The NFT to transfer\\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external whenNotPaused {\\n        safeTransferFrom(_from, _to, _tokenId, \\\"\\\");\\n    }\\n\\n    // @notice Transfer a Cutie owned by another address, for which the calling address\\n    //  has been granted transfer approval by the owner.\\n    // @param _from The address that owns the Cutie to be transferred.\\n    // @param _to Any address, including the caller address, can take ownership of the Cutie.\\n    // @param _tokenId The ID of the Cutie to be transferred.\\n    // @dev Required for ERC-721 compliance.\\n    function transferFrom(address _from, address _to, uint256 _tokenId) public whenNotPaused canBeStoredIn40Bits(_tokenId) {\\n        require(_to != address(0), \\\"Wrong cutie destination\\\");\\n        require(_to != address(this), \\\"Wrong cutie destination\\\");\\n\\n        // Check for approval and valid ownership\\n        require(_isApprovedOrOwner(msg.sender, uint40(_tokenId)), \\\"Caller is not owner nor approved\\\");\\n        require(_isOwner(_from, uint40(_tokenId)), \\\"Wrong cutie owner\\\");\\n\\n        // Reassign ownership, clearing pending approvals and emitting Transfer event.\\n        _transfer(_from, _to, uint40(_tokenId));\\n    }\\n\\n    // @notice Transfers a Cutie to another address. When transferring to a smart\\n    // contract, ensure that it is aware of ERC-721 (or BlockchainCuties specifically),\\n    // otherwise the Cutie may be lost forever.\\n    // @param _to The address of the recipient, can be a user or contract.\\n    // @param _cutieId The ID of the Cutie to transfer.\\n    // @dev Required for ERC-721 compliance.\\n    function transfer(address _to, uint256 _cutieId) public whenNotPaused canBeStoredIn40Bits(_cutieId) {\\n        require(_to != address(0), \\\"Wrong cutie destination\\\");\\n\\n        // You can only send your own cutie.\\n        require(_isOwner(msg.sender, uint40(_cutieId)), \\\"Caller is not a cutie owner\\\");\\n\\n        // Reassign ownership, clear pending approvals, emit Transfer event.\\n        _transfer(msg.sender, _to, uint40(_cutieId));\\n    }\\n\\n    function transferBulk(address[] to, uint[] tokens) public whenNotPaused {\\n        require(to.length == tokens.length);\\n        for (uint i = 0; i \\u003c to.length; i++) {\\n            transfer(to[i], tokens[i]);\\n        }\\n    }\\n\\n    function transferMany(address to, uint[] tokens) public whenNotPaused {\\n        for (uint i = 0; i \\u003c tokens.length; i++) {\\n            transfer(to, tokens[i]);\\n        }\\n    }\\n\\n    // @notice Grant another address the right to transfer a particular Cutie via transferFrom().\\n    // This flow is preferred for transferring NFTs to contracts.\\n    // @param _to The address to be granted transfer approval. Pass address(0) to clear all approvals.\\n    // @param _cutieId The ID of the Cutie that can be transferred if this call succeeds.\\n    // @dev Required for ERC-721 compliance.\\n    function approve(address _to, uint256 _cutieId) public whenNotPaused canBeStoredIn40Bits(_cutieId) {\\n        // Only cutie\\u0027s owner can grant transfer approval.\\n        require(_isOwner(msg.sender, uint40(_cutieId)), \\\"Caller is not a cutie owner\\\");\\n        require(msg.sender != _to, \\\"Approval to current owner\\\");\\n\\n        // Registering approval replaces any previous approval.\\n        _approve(uint40(_cutieId), _to);\\n\\n        // Emit approval event.\\n        emit Approval(msg.sender, _to, _cutieId);\\n    }\\n\\n    function delegatedApprove(address _from, address _to, uint40 _cutieId) external whenNotPaused onlyGame {\\n        require(_isOwner(_from, _cutieId), \\\"Wrong cutie owner\\\");\\n        _approve(_cutieId, _to);\\n    }\\n\\n    function approveAndCall(address _spender, uint _tokenId, bytes data) external whenNotPaused returns (bool) {\\n        approve(_spender, _tokenId);\\n        TokenRecipientInterface(_spender).receiveApproval(msg.sender, _tokenId, this, data);\\n        return true;\\n    }\\n\\n    // @notice Enable or disable approval for a third party (\\\"operator\\\") to manage\\n    //  all your asset.\\n    // @dev Emits the ApprovalForAll event\\n    // @param _operator Address to add to the set of authorized operators.\\n    // @param _approved True if the operators is approved, false to revoke approval\\n    function setApprovalForAll(address _operator, bool _approved) external {\\n        require(_operator != msg.sender, \\\"Approve to caller\\\");\\n\\n        if (_approved) {\\n            addressToApprovedAll[msg.sender][_operator] = true;\\n        } else {\\n            delete addressToApprovedAll[msg.sender][_operator];\\n        }\\n        emit ApprovalForAll(msg.sender, _operator, _approved);\\n    }\\n\\n    // @notice Get the approved address for a single NFT\\n    // @dev Throws if `_tokenId` is not a valid NFT\\n    // @param _tokenId The NFT to find the approved address for\\n    // @return The approved address for this NFT, or the zero address if there is none\\n    function getApproved(uint256 _tokenId) external view canBeStoredIn40Bits(_tokenId) returns (address) {\\n        require(_tokenId \\u003c= total, \\\"Cutie not exists\\\");\\n        return cutieIndexToApproved[uint40(_tokenId)];\\n    }\\n\\n    // @notice Query if an address is an authorized operator for another address\\n    // @param _owner The address that owns the NFTs\\n    // @param _operator The address that acts on behalf of the owner\\n    // @return True if `_operator` is an approved operator for `_owner`, false otherwise\\n    function isApprovedForAll(address _owner, address _operator) public view returns (bool) {\\n        return addressToApprovedAll[_owner][_operator];\\n    }\\n\\n    // @dev Returns whether `spender` is allowed to manage `cutieId`.\\n    function _isApprovedOrOwner(address spender, uint40 cutieId) internal view returns (bool) {\\n        require(_exists(cutieId), \\\"Cutie not exists\\\");\\n        address owner = cutieIndexToOwner[cutieId];\\n        return (spender == owner || _approvedFor(spender, cutieId) || isApprovedForAll(owner, spender));\\n    }\\n\\n    // @dev Checks if a given address is the current owner of a certain Cutie.\\n    // @param _claimant the address we are validating against.\\n    // @param _cutieId cutie id, only valid when \\u003e 0\\n    function _isOwner(address _claimant, uint40 _cutieId) internal view returns (bool) {\\n        return cutieIndexToOwner[_cutieId] == _claimant;\\n    }\\n\\n    function _exists(uint40 _cutieId) internal view returns (bool) {\\n        return cutieIndexToOwner[_cutieId] != address(0);\\n    }\\n\\n    // @dev Marks an address as being approved for transferFrom(), overwriting any previous\\n    //  approval. Setting _approved to address(0) clears all transfer approval.\\n    //  NOTE: _approve() does NOT send the Approval event. This is done on purpose:\\n    //  _approve() and transferFrom() are used together for putting Cuties on auction.\\n    //  There is no value in spamming the log with Approval events in that case.\\n    function _approve(uint40 _cutieId, address _approved) internal {\\n        cutieIndexToApproved[_cutieId] = _approved;\\n    }\\n\\n    // @dev Checks if a given address currently has transferApproval for a certain Cutie.\\n    // @param _claimant the address we are confirming the cutie is approved for.\\n    // @param _cutieId cutie id, only valid when \\u003e 0\\n    function _approvedFor(address _claimant, uint40 _cutieId) internal view returns (bool) {\\n        return cutieIndexToApproved[_cutieId] == _claimant;\\n    }\\n\\n    // @dev Assigns ownership of a particular Cutie to an address.\\n    function _transfer(address _from, address _to, uint40 _cutieId) internal {\\n\\n        // since the number of cuties is capped to 2^40\\n        // there is no way to overflow this\\n        ownershipTokenCount[_to]++;\\n        // transfer ownership\\n        cutieIndexToOwner[_cutieId] = _to;\\n        // When creating new cuties _from is 0x0, but we cannot account that address.\\n        if (_from != address(0)) {\\n            ownershipTokenCount[_from]--;\\n            // clear any previously approved ownership exchange\\n            delete cutieIndexToApproved[_cutieId];\\n        }\\n        // Emit the transfer event.\\n        emit Transfer(_from, _to, _cutieId);\\n    }\\n\\n    // This method relies on extcodesize, which returns 0 for contracts in\\n    // construction, since the code is only stored at the end of the\\n    // constructor execution.\\n    function _isContract(address _account) internal view returns (bool) {\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(_account) }\\n        return size \\u003e 0;\\n    }\\n\\n    // @dev For transferring a cutie owned by this contract to the specified address.\\n    //  Used to rescue lost cuties. (There is no \\\"proper\\\" flow where this contract\\n    //  should be the owner of any Cutie. This function exists for us to reassign\\n    //  the ownership of Cuties that users may have accidentally sent to our address.)\\n    // @param _cutieId - ID of cutie\\n    // @param _recipient - Address to send the cutie to\\n    function restoreCutieToAddress(uint40 _cutieId, address _recipient) external whenNotPaused onlyOperator {\\n        require(_isOwner(this, _cutieId));\\n        _transfer(this, _recipient, _cutieId);\\n    }\\n\\n    // @dev An method that creates a new cutie and stores it. This\\n    //  method does not check anything and should only be called when the\\n    //  input data is valid for sure. Will generate both a Birth event\\n    //  and a Transfer event.\\n    // @param _momId The cutie ID of the mom of this cutie (zero for gen0)\\n    // @param _dadId The cutie ID of the dad of this cutie (zero for gen0)\\n    // @param _generation The generation number of this cutie, must be computed by caller.\\n    // @param _genes The cutie\\u0027s genetic code.\\n    // @param _owner The initial owner of this cutie, must be non-zero (except for the unCutie, ID 0)\\n    function createCutie(\\n        address _owner,\\n        uint40 _momId,\\n        uint40 _dadId,\\n        uint16 _generation,\\n        uint16 _cooldownIndex,\\n        uint256 _genes,\\n        uint40 _birthTime\\n    ) external whenNotPaused onlyGame returns (uint40) {\\n        Cutie memory _cutie = Cutie({\\n            genes : _genes,\\n            birthTime : _birthTime,\\n            cooldownEndTime : 0,\\n            momId : _momId,\\n            dadId : _dadId,\\n            cooldownIndex : _cooldownIndex,\\n            generation : _generation,\\n            optional : 0\\n        });\\n\\n        total++;\\n        uint256 newCutieId256 = total;\\n\\n        // Check if id can fit into 40 bits\\n        require(newCutieId256 \\u003c= 0xFFFFFFFFFF);\\n\\n        uint40 newCutieId = uint40(newCutieId256);\\n        cuties[newCutieId] = _cutie;\\n\\n        // This will assign ownership, as well as emit the Transfer event as per ERC721 draft\\n        _transfer(0, _owner, newCutieId);\\n\\n        return newCutieId;\\n    }\\n\\n    // @dev Recreate the cutie if it stuck on old contracts and cannot be migrated smoothly\\n    function restoreCutie(\\n        address owner,\\n        uint40 id,\\n        uint256 _genes,\\n        uint40 _momId,\\n        uint40 _dadId,\\n        uint16 _generation,\\n        uint40 _cooldownEndTime,\\n        uint16 _cooldownIndex,\\n        uint40 _birthTime\\n    ) external whenNotPaused onlyGame {\\n        require(owner != address(0), \\\"Restore to zero address\\\");\\n        require(total \\u003e= id, \\\"Cutie restore is not allowed\\\");\\n        require(cuties[id].birthTime == 0, \\\"Cutie overwrite is forbidden\\\");\\n\\n        Cutie memory cutie = Cutie({\\n            genes: _genes,\\n            momId: _momId,\\n            dadId: _dadId,\\n            generation: _generation,\\n            cooldownEndTime: _cooldownEndTime,\\n            cooldownIndex: _cooldownIndex,\\n            birthTime: _birthTime,\\n            optional: 0\\n        });\\n\\n        cuties[id] = cutie;\\n        cutieIndexToOwner[id] = owner;\\n        ownershipTokenCount[owner]++;\\n    }\\n\\n    // @notice Returns all the relevant information about a certain cutie.\\n    // @param _id The ID of the cutie of interest.\\n    function getCutie(uint40 _id) external view returns (\\n        uint256 genes,\\n        uint40 birthTime,\\n        uint40 cooldownEndTime,\\n        uint40 momId,\\n        uint40 dadId,\\n        uint16 cooldownIndex,\\n        uint16 generation\\n    ) {\\n        require(_exists(_id), \\\"Cutie not exists\\\");\\n\\n        Cutie storage cutie = cuties[_id];\\n\\n        genes = cutie.genes;\\n        birthTime = cutie.birthTime;\\n        cooldownEndTime = cutie.cooldownEndTime;\\n        momId = cutie.momId;\\n        dadId = cutie.dadId;\\n        cooldownIndex = cutie.cooldownIndex;\\n        generation = cutie.generation;\\n    }\\n\\n    function getGenes(uint40 _id) external view returns (uint256) {\\n        return cuties[_id].genes;\\n    }\\n\\n    function setGenes(uint40 _id, uint256 _genes) external whenNotPaused onlyGame {\\n        cuties[_id].genes = _genes;\\n    }\\n\\n    function getCooldownEndTime(uint40 _id) external view returns (uint40) {\\n        return cuties[_id].cooldownEndTime;\\n    }\\n\\n    function setCooldownEndTime(uint40 _id, uint40 _cooldownEndTime) external whenNotPaused onlyGame {\\n        cuties[_id].cooldownEndTime = _cooldownEndTime;\\n    }\\n\\n    function getCooldownIndex(uint40 _id) external view returns (uint16) {\\n        return cuties[_id].cooldownIndex;\\n    }\\n\\n    function setCooldownIndex(uint40 _id, uint16 _cooldownIndex) external whenNotPaused onlyGame {\\n        cuties[_id].cooldownIndex = _cooldownIndex;\\n    }\\n\\n    function getGeneration(uint40 _id) external view returns (uint16) {\\n        return cuties[_id].generation;\\n    }\\n\\n    function setGeneration(uint40 _id, uint16 _generation) external whenNotPaused onlyGame {\\n        cuties[_id].generation = _generation;\\n    }\\n\\n    function getOptional(uint40 _id) external view returns (uint64) {\\n        return cuties[_id].optional;\\n    }\\n\\n    function setOptional(uint40 _id, uint64 _optional) external whenNotPaused onlyGame {\\n        cuties[_id].optional = _optional;\\n    }\\n}\\n\"},\"CutieAccessControl.sol\":{\"content\":\"pragma solidity ^0.4.23;\\n\\nimport \\\"./IERC20Withdraw.sol\\\";\\nimport \\\"./IERC721Withdraw.sol\\\";\\n\\ncontract CutieAccessControl {\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    // @dev Address with full contract privileges\\n    address ownerAddress;\\n\\n    // @dev Next owner address\\n    address pendingOwnerAddress;\\n\\n    // @dev Addresses with configuration privileges\\n    mapping (address =\\u003e bool) operatorAddress;\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == ownerAddress, \\\"Access denied\\\");\\n        _;\\n    }\\n\\n    modifier onlyPendingOwner() {\\n        require(msg.sender == pendingOwnerAddress, \\\"Access denied\\\");\\n        _;\\n    }\\n\\n    modifier onlyOperator() {\\n        require(operatorAddress[msg.sender] || msg.sender == ownerAddress, \\\"Access denied\\\");\\n        _;\\n    }\\n\\n    constructor () internal {\\n        ownerAddress = msg.sender;\\n    }\\n\\n    function getOwner() external view returns (address) {\\n        return ownerAddress;\\n    }\\n\\n    function setOwner(address _newOwner) external onlyOwner {\\n        require(_newOwner != address(0));\\n        pendingOwnerAddress = _newOwner;\\n    }\\n\\n    function getPendingOwner() external view returns (address) {\\n        return pendingOwnerAddress;\\n    }\\n\\n    function claimOwnership() external onlyPendingOwner {\\n        emit OwnershipTransferred(ownerAddress, pendingOwnerAddress);\\n        ownerAddress = pendingOwnerAddress;\\n        pendingOwnerAddress = address(0);\\n    }\\n\\n    function isOperator(address _addr) public view returns (bool) {\\n        return operatorAddress[_addr];\\n    }\\n\\n    function setOperator(address _newOperator) public onlyOwner {\\n        require(_newOperator != address(0));\\n        operatorAddress[_newOperator] = true;\\n    }\\n\\n    function removeOperator(address _operator) public onlyOwner {\\n        delete(operatorAddress[_operator]);\\n    }\\n\\n    // @dev The balance transfer from CutieCore contract to project owners\\n    function withdraw(address _receiver) external onlyOwner {\\n        if (address(this).balance \\u003e 0) {\\n            _receiver.transfer(address(this).balance);\\n        }\\n    }\\n\\n    // @dev Allow to withdraw ERC20 tokens from contract itself\\n    function withdrawERC20(IERC20Withdraw _tokenContract) external onlyOwner {\\n        uint256 balance = _tokenContract.balanceOf(address(this));\\n        if (balance \\u003e 0) {\\n            _tokenContract.transfer(msg.sender, balance);\\n        }\\n    }\\n\\n    // @dev Allow to withdraw ERC721 tokens from contract itself\\n    function approveERC721(IERC721Withdraw _tokenContract) external onlyOwner {\\n        _tokenContract.setApprovalForAll(msg.sender, true);\\n    }\\n\\n}\\n\"},\"CutieERC721Metadata.sol\":{\"content\":\"pragma solidity ^0.4.23;\\n\\nimport \\\"./CutiePausable.sol\\\";\\n\\ncontract CutieERC721Metadata is CutiePausable /* is IERC721Metadata */ {\\n    string public metadataUrlPrefix = \\\"https://blockchaincuties.com/cutie/\\\";\\n    string public metadataUrlSuffix = \\\".svg\\\";\\n\\n    /// @notice A descriptive name for a collection of NFTs in this contract\\n    function name() external pure returns (string) {\\n        return \\\"BlockchainCuties\\\";\\n    }\\n\\n    /// @notice An abbreviated name for NFTs in this contract\\n    function symbol() external pure returns (string) {\\n        return \\\"CUTIE\\\";\\n    }\\n\\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\\n    ///  3986. The URI may point to a JSON file that conforms to the \\\"ERC721\\n    ///  Metadata JSON Schema\\\".\\n    function tokenURI(uint256 _tokenId) external view returns (string infoUrl) {\\n        return\\n        concat(toSlice(metadataUrlPrefix),\\n            toSlice(concat(toSlice(uintToString(_tokenId)), toSlice(metadataUrlSuffix))));\\n    }\\n\\n    function setMetadataUrl(string _metadataUrlPrefix, string _metadataUrlSuffix) public onlyOwner {\\n        metadataUrlPrefix = _metadataUrlPrefix;\\n        metadataUrlSuffix = _metadataUrlSuffix;\\n    }\\n\\n    /*\\n     * @title String \\u0026 slice utility library for Solidity contracts.\\n     * @author Nick Johnson \\u003carachnid@notdot.net\\u003e\\n     *\\n     * @dev Functionality in this library is largely implemented using an\\n     *      abstraction called a \\u0027slice\\u0027. A slice represents a part of a string -\\n     *      anything from the entire string to a single character, or even no\\n     *      characters at all (a 0-length slice). Since a slice only has to specify\\n     *      an offset and a length, copying and manipulating slices is a lot less\\n     *      expensive than copying and manipulating the strings they reference.\\n     *\\n     *      To further reduce gas costs, most functions on slice that need to return\\n     *      a slice modify the original one instead of allocating a new one; for\\n     *      instance, `s.split(\\\".\\\")` will return the text up to the first \\u0027.\\u0027,\\n     *      modifying s to only contain the remainder of the string after the \\u0027.\\u0027.\\n     *      In situations where you do not want to modify the original slice, you\\n     *      can make a copy first with `.copy()`, for example:\\n     *      `s.copy().split(\\\".\\\")`. Try and avoid using this idiom in loops; since\\n     *      Solidity has no memory management, it will result in allocating many\\n     *      short-lived slices that are later discarded.\\n     *\\n     *      Functions that return two slices come in two versions: a non-allocating\\n     *      version that takes the second slice as an argument, modifying it in\\n     *      place, and an allocating version that allocates and returns the second\\n     *      slice; see `nextRune` for example.\\n     *\\n     *      Functions that have to copy string data will return strings rather than\\n     *      slices; these can be cast back to slices for further processing if\\n     *      required.\\n     *\\n     *      For convenience, some functions are provided with non-modifying\\n     *      variants that create a new slice and return both; for instance,\\n     *      `s.splitNew(\\u0027.\\u0027)` leaves s unmodified, and returns two values\\n     *      corresponding to the left and right parts of the string.\\n     */\\n\\n    struct slice {\\n        uint _len;\\n        uint _ptr;\\n    }\\n\\n    /*\\n     * @dev Returns a slice containing the entire string.\\n     * @param self The string to make a slice from.\\n     * @return A newly allocated slice containing the entire string.\\n     */\\n    function toSlice(string self) internal pure returns (slice) {\\n        uint ptr;\\n        assembly {\\n            ptr := add(self, 0x20)\\n        }\\n        return slice(bytes(self).length, ptr);\\n    }\\n\\n    function memcpy(uint dest, uint src, uint len) private pure {\\n        // Copy word-length chunks while possible\\n        for(; len \\u003e= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        // Copy remaining bytes\\n        uint mask = 256 ** (32 - len) - 1;\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n\\n    /*\\n     * @dev Returns a newly allocated string containing the concatenation of\\n     *      `self` and `other`.\\n     * @param self The first slice to concatenate.\\n     * @param other The second slice to concatenate.\\n     * @return The concatenation of the two strings.\\n     */\\n    function concat(slice self, slice other) internal pure returns (string) {\\n        string memory ret = new string(self._len + other._len);\\n        uint retptr;\\n        assembly { retptr := add(ret, 32) }\\n        memcpy(retptr, self._ptr, self._len);\\n        memcpy(retptr + self._len, other._ptr, other._len);\\n        return ret;\\n    }\\n\\n\\n    function uintToString(uint256 a) internal pure returns (string result) {\\n        string memory r = \\\"\\\";\\n        do {\\n            uint b = a % 10;\\n            a /= 10;\\n\\n            string memory c = \\\"\\\";\\n\\n            if (b == 0) c = \\\"0\\\";\\n            else if (b == 1) c = \\\"1\\\";\\n            else if (b == 2) c = \\\"2\\\";\\n            else if (b == 3) c = \\\"3\\\";\\n            else if (b == 4) c = \\\"4\\\";\\n            else if (b == 5) c = \\\"5\\\";\\n            else if (b == 6) c = \\\"6\\\";\\n            else if (b == 7) c = \\\"7\\\";\\n            else if (b == 8) c = \\\"8\\\";\\n            else if (b == 9) c = \\\"9\\\";\\n\\n            r = concat(toSlice(c), toSlice(r));\\n        } while (a \\u003e 0);\\n        result = r;\\n    }\\n}\\n\"},\"CutiePausable.sol\":{\"content\":\"pragma solidity ^0.4.23;\\n\\nimport \\\"./CutieAccessControl.sol\\\";\\n\\n/**\\n * @title Pausable\\n * @dev Base contract which allows children to implement an emergency stop mechanism.\\n */\\ncontract CutiePausable is CutieAccessControl {\\n  event Pause();\\n  event Unpause();\\n\\n  bool public paused = false;\\n\\n\\n  /**\\n   * @dev Modifier to make a function callable only when the contract is not paused.\\n   */\\n  modifier whenNotPaused() {\\n    require(!paused);\\n    _;\\n  }\\n\\n  /**\\n   * @dev Modifier to make a function callable only when the contract is paused.\\n   */\\n  modifier whenPaused() {\\n    require(paused);\\n    _;\\n  }\\n\\n  /**\\n   * @dev called by the owner to pause, triggers stopped state\\n   */\\n  function pause() onlyOwner whenNotPaused public {\\n    paused = true;\\n    emit Pause();\\n  }\\n\\n  /**\\n   * @dev called by the owner to unpause, returns to normal state\\n   */\\n  function unpause() onlyOwner whenPaused public {\\n    paused = false;\\n    emit Unpause();\\n  }\\n}\\n\"},\"ERC721TokenReceiver.sol\":{\"content\":\"pragma solidity ^0.4.23;\\n\\n/// @dev Note: the ERC-165 identifier for this interface is 0xf0b9e5ba\\ninterface ERC721TokenReceiver {\\n    /// @notice Handle the receipt of an NFT\\n    /// @dev The ERC721 smart contract calls this function on the recipient\\n    ///  after a `transfer`. This function MAY throw to revert and reject the\\n    ///  transfer. This function MUST use 50,000 gas or less. Return of other\\n    ///  than the magic value MUST result in the transaction being reverted.\\n    ///  Note: the contract address is always the message sender.\\n    /// @param _from The sending address \\n    /// @param _tokenId The NFT identifier which is being transfered\\n    /// @param data Additional data with no specified format\\n    /// @return `bytes4(keccak256(\\\"onERC721Received(address,uint256,bytes)\\\"))`\\n    ///  unless throwing\\n    function onERC721Received(address _from, uint256 _tokenId, bytes data) external returns(bytes4);\\n}\\n\"},\"IERC20Withdraw.sol\":{\"content\":\"pragma solidity ^0.4.23;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Withdraw {\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n}\\n\"},\"IERC721Withdraw.sol\":{\"content\":\"pragma solidity ^0.4.23;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC721Withdraw {\\n    /**\\n    * @dev Approve or remove `operator` as an operator for the caller.\\n    * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n    *\\n    * Requirements:\\n    *\\n    * - The `operator` cannot be the caller.\\n    *\\n    * Emits an {ApprovalForAll} event.\\n    */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n}\\n\"},\"TokenRecipientInterface.sol\":{\"content\":\"pragma solidity ^0.4.23;\\n\\n// ----------------------------------------------------------------------------\\n// Contract function to receive approval and execute function in one call\\n//\\n// Borrowed from MiniMeToken\\n\\ninterface TokenRecipientInterface {\\n    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external;\\n}\\n\"}}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint40\"}],\"name\":\"cuties\",\"outputs\":[{\"name\":\"genes\",\"type\":\"uint256\"},{\"name\":\"birthTime\",\"type\":\"uint40\"},{\"name\":\"cooldownEndTime\",\"type\":\"uint40\"},{\"name\":\"momId\",\"type\":\"uint40\"},{\"name\":\"dadId\",\"type\":\"uint40\"},{\"name\":\"cooldownIndex\",\"type\":\"uint16\"},{\"name\":\"generation\",\"type\":\"uint16\"},{\"name\":\"optional\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_cutieId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint40\"}],\"name\":\"cutieIndexToApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint40\"}],\"name\":\"getCooldownIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"cutieId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint40\"}],\"name\":\"getOptional\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_total\",\"type\":\"uint256\"}],\"name\":\"setup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"}],\"name\":\"approveERC721\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_momId\",\"type\":\"uint40\"},{\"name\":\"_dadId\",\"type\":\"uint40\"},{\"name\":\"_generation\",\"type\":\"uint16\"},{\"name\":\"_cooldownIndex\",\"type\":\"uint16\"},{\"name\":\"_genes\",\"type\":\"uint256\"},{\"name\":\"_birthTime\",\"type\":\"uint40\"}],\"name\":\"createCutie\",\"outputs\":[{\"name\":\"\",\"type\":\"uint40\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint40\"},{\"name\":\"_cooldownIndex\",\"type\":\"uint16\"}],\"name\":\"setCooldownIndex\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_cutieId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOperator\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_metadataUrlPrefix\",\"type\":\"string\"},{\"name\":\"_metadataUrlSuffix\",\"type\":\"string\"}],\"name\":\"setMetadataUrl\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameAddress\",\"type\":\"address\"}],\"name\":\"setGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint40\"},{\"name\":\"_generation\",\"type\":\"uint16\"}],\"name\":\"setGeneration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address[]\"},{\"name\":\"tokens\",\"type\":\"uint256[]\"}],\"name\":\"transferBulk\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPendingOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint40\"}],\"name\":\"getGenes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint40\"}],\"name\":\"getGeneration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gameAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cutieId\",\"type\":\"uint40\"},{\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"restoreCutieToAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_cutieId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_cutieId\",\"type\":\"uint256\"}],\"name\":\"ownerOfCutie\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint40\"},{\"name\":\"_cooldownEndTime\",\"type\":\"uint40\"}],\"name\":\"setCooldownEndTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToApprovedAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"removeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint40\"}],\"name\":\"cutieIndexToOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOperator\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"metadataUrlPrefix\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"infoUrl\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"metadataUrlSuffix\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256[]\"}],\"name\":\"transferMany\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint40\"}],\"name\":\"getCutie\",\"outputs\":[{\"name\":\"genes\",\"type\":\"uint256\"},{\"name\":\"birthTime\",\"type\":\"uint40\"},{\"name\":\"cooldownEndTime\",\"type\":\"uint40\"},{\"name\":\"momId\",\"type\":\"uint40\"},{\"name\":\"dadId\",\"type\":\"uint40\"},{\"name\":\"cooldownIndex\",\"type\":\"uint16\"},{\"name\":\"generation\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint40\"},{\"name\":\"_genes\",\"type\":\"uint256\"},{\"name\":\"_momId\",\"type\":\"uint40\"},{\"name\":\"_dadId\",\"type\":\"uint40\"},{\"name\":\"_generation\",\"type\":\"uint16\"},{\"name\":\"_cooldownEndTime\",\"type\":\"uint40\"},{\"name\":\"_cooldownIndex\",\"type\":\"uint16\"},{\"name\":\"_birthTime\",\"type\":\"uint40\"}],\"name\":\"restoreCutie\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint40\"},{\"name\":\"_genes\",\"type\":\"uint256\"}],\"name\":\"setGenes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"}],\"name\":\"withdrawERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint40\"}],\"name\":\"getCooldownEndTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint40\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_cutieId\",\"type\":\"uint40\"}],\"name\":\"delegatedApprove\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint40\"},{\"name\":\"_optional\",\"type\":\"uint64\"}],\"name\":\"setOptional\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"BlockchainCutiesToken","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://84118b5bded503eb6ffb61d5b8aa6a61a8c9800148523b317643b0478c7378f0"}]}