{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity ^0.8.5;\r\n\r\n// Ethereum Token callback\r\ninterface tokenRecipient {\r\n  function receiveApproval( address from, uint256 value, bytes calldata data )\r\n  external;\r\n}\r\n\r\n// ERC223 callback\r\ninterface ContractReceiver {\r\n  function tokenFallback( address from, uint value, bytes calldata data )\r\n  external;\r\n}\r\n\r\ncontract owned {\r\n  address public owner;\r\n\r\n  constructor() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  function changeOwner( address _miner ) public onlyOwner {\r\n    owner = _miner;\r\n  }\r\n\r\n  modifier onlyOwner {\r\n    require (msg.sender == owner);\r\n    _;\r\n  }\r\n}\r\n\r\n// ERC20 token with added ERC223 and Ethereum-Token support\r\n//\r\n// Blend of multiple interfaces:\r\n// - https://theethereum.wiki/w/index.php/ERC20_Token_Standard\r\n// - https://www.ethereum.org/token (uncontrolled, non-standard)\r\n// - https://github.com/Dexaran/ERC23-tokens/blob/Recommended/ERC223_Token.sol\r\n\r\ncontract MineableToken is owned {\r\n\r\n  string  public name;\r\n  string  public symbol;\r\n  uint8   public decimals;\r\n  uint256 public totalSupply;\r\n\r\n  mapping( address => uint256 ) balances_;\r\n  mapping( address => mapping(address => uint256) ) allowances_;\r\n\r\n  // ERC20\r\n  event Approval( address indexed owner,\r\n                  address indexed spender,\r\n                  uint value );\r\n\r\n  // ERC20-compatible version only, breaks ERC223 compliance but etherscan\r\n  // and most exchanges only support ERC20 version. Events can't be overloaded\r\n\r\n  event Transfer( address indexed from,\r\n                  address indexed to,\r\n                  uint256 value );\r\n                  //bytes    data );\r\n\r\n  // Ethereum Token\r\n  event Burn( address indexed from,\r\n              uint256 value );\r\n\r\n  constructor ( uint8 _decimals,\r\n                string memory _name,\r\n                string memory _symbol ) {\r\n\r\n    decimals = uint8(_decimals); // audit recommended 18 decimals\r\n    totalSupply = 0;\r\n\r\n    name = _name;\r\n    symbol = _symbol;\r\n  }\r\n\r\n  receive() external payable { revert(\"does not accept eth\"); }\r\n  fallback() external payable { revert(\"calldata does not match a function\"); }\r\n\r\n  function mine( uint256 qty, address receiver ) public onlyOwner {\r\n    require ( (totalSupply + qty) > totalSupply, \"mine: overrun error\" );\r\n\r\n    totalSupply += qty;\r\n    balances_[receiver] += qty;\r\n    emit Transfer( address(0), receiver, qty );\r\n  }\r\n\r\n  // ERC20\r\n  function balanceOf( address owner ) public view returns (uint) {\r\n    return balances_[owner];\r\n  }\r\n\r\n  // ERC20\r\n  function approve( address spender, uint256 value ) public\r\n  returns (bool success)\r\n  {\r\n    // WARNING! When changing the approval amount, first set it back to zero\r\n    // AND wait until the transaction is mined. Only afterwards set the new\r\n    // amount. Otherwise you may be prone to a race condition attack.\r\n    // See: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n\r\n    allowances_[msg.sender][spender] = value;\r\n    emit Approval( msg.sender, spender, value );\r\n    return true;\r\n  }\r\n \r\n  // recommended fix for known attack on any ERC20\r\n  function safeApprove( address _spender,\r\n                        uint256 _currentValue,\r\n                        uint256 _value ) public\r\n  returns (bool success)\r\n  {\r\n    // If current allowance for _spender is equal to _currentValue, then\r\n    // overwrite it with _value and return true, otherwise return false.\r\n\r\n    if (allowances_[msg.sender][_spender] == _currentValue)\r\n      return approve(_spender, _value);\r\n\r\n    return false;\r\n  }\r\n\r\n  // ERC20\r\n  function allowance( address owner, address spender ) public view\r\n  returns (uint256 remaining)\r\n  {\r\n    return allowances_[owner][spender];\r\n  }\r\n\r\n  // ERC20\r\n  function transfer(address to, uint256 value) public\r\n  returns (bool success)\r\n  {\r\n    bytes memory empty; // null\r\n    _transfer( msg.sender, to, value, empty );\r\n    return true;\r\n  }\r\n\r\n  // ERC20\r\n  function transferFrom( address from, address to, uint256 value ) public\r\n  returns (bool success)\r\n  {\r\n    require( value <= allowances_[from][msg.sender],\r\n             \"transferFrom: insufficient allowance\" );\r\n\r\n    allowances_[from][msg.sender] -= value;\r\n    bytes memory empty;\r\n    _transfer( from, to, value, empty );\r\n\r\n    return true;\r\n  }\r\n\r\n  // Ethereum Token\r\n  function approveAndCall( address spender,\r\n                           uint256 value,\r\n                           bytes calldata context ) public\r\n  returns (bool success)\r\n  {\r\n    if ( approve(spender, value) )\r\n    {\r\n      tokenRecipient recip = tokenRecipient( spender );\r\n      recip.receiveApproval( msg.sender, value, context );\r\n\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }        \r\n\r\n  // Ethereum Token\r\n  function burn( uint256 value ) public\r\n  returns (bool success)\r\n  {\r\n    require( balances_[msg.sender] >= value, \"burn: insufficient balance\" );\r\n\r\n    balances_[msg.sender] -= value;\r\n    totalSupply -= value;\r\n\r\n    emit Burn( msg.sender, value );\r\n    return true;\r\n  }\r\n\r\n  // Ethereum Token\r\n  function burnFrom( address from, uint256 value ) public\r\n  returns (bool success)\r\n  {\r\n    require( balances_[from] >= value, \"burnFrom: insufficient balance\" );\r\n\r\n    require( value <= allowances_[from][msg.sender],\r\n             \"burnFrom: insuff allowance\" );\r\n\r\n    balances_[from] -= value;\r\n    allowances_[from][msg.sender] -= value;\r\n    totalSupply -= value;\r\n\r\n    emit Burn( from, value );\r\n    return true;\r\n  }\r\n\r\n  // ERC223 Transfer and invoke specified callback\r\n  function transfer( address to,\r\n                     uint value,\r\n                     bytes calldata data,\r\n                     string calldata custom_fallback )\r\n  public returns (bool success)\r\n  {\r\n    _transfer( msg.sender, to, value, data );\r\n\r\n    ContractReceiver rx = ContractReceiver( to );\r\n    // https://docs.soliditylang.org/en/v0.5.1/050-breaking-changes.html#semantic-and-syntactic-changes\r\n    (bool resok, bytes memory resdata) =\r\n      address(rx).call( abi.encodeWithSignature(custom_fallback,\r\n                          msg.sender, value, data) );\r\n\r\n    if (resdata.length > 0) {} // suppress warning\r\n\r\n    return resok;\r\n  }\r\n\r\n  // ERC223 Transfer to a contract or externally-owned account\r\n  function transfer( address to, uint value, bytes calldata data )\r\n  public returns (bool success)\r\n  {\r\n    if (isContract(to)) {\r\n      return transferToContract( to, value, data );\r\n    }\r\n\r\n    _transfer( msg.sender, to, value, data );\r\n    return true;\r\n  }\r\n\r\n  // ERC223 Transfer to contract and invoke tokenFallback() method\r\n  function transferToContract( address to, uint value, bytes memory data )\r\n  private returns (bool success)\r\n  {\r\n    _transfer( msg.sender, to, value, data );\r\n\r\n    ContractReceiver rx = ContractReceiver(to);\r\n\r\n    if (isContract(to)) {\r\n      rx.tokenFallback( msg.sender, value, data );\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  // ERC223 fetch contract size (must be nonzero to be a contract)\r\n  function isContract( address _addr ) private view returns (bool)\r\n  {\r\n    uint length;\r\n    assembly { length := extcodesize(_addr) }\r\n    return (length > 0);\r\n  }\r\n\r\n  function _transfer( address from,\r\n                      address to,\r\n                      uint value,\r\n                      bytes memory data ) internal\r\n  {\r\n    require( to != address(0x0), \"_transfer: to cannot be null\" );\r\n    require( balances_[from] >= value, \"_transfer: insufficient balance\" );\r\n    require( balances_[to] + value > balances_[to], \"_transfer: overflow\" );\r\n\r\n    balances_[from] -= value;\r\n    balances_[to] += value;\r\n\r\n    bytes memory ignore;\r\n    ignore = data;                    // ignore compiler warning\r\n    emit Transfer( from, to, value ); // ignore data\r\n  }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_decimals\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"context\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_miner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"qty\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"mine\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_currentValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"safeApprove\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"string\",\"name\":\"custom_fallback\",\"type\":\"string\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"MineableToken","CompilerVersion":"v0.8.5+commit.a4f2e591","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000001347726561736520546f6b656e204552433232330000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044c55424500000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://e14ff236944ea2970641cf27960bf5d16c87ed8e3e84b372d0bccd1142349158"}]}