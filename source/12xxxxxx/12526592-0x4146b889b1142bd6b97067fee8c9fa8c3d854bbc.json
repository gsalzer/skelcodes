{"status":"1","message":"OK","result":[{"SourceCode":"{\"IComptroller.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface Comptroller {\\r\\n  function _addCompMarkets ( address[] memory cTokens ) external;\\r\\n  function _become ( address unitroller ) external;\\r\\n  function _borrowGuardianPaused (  ) external view returns ( bool );\\r\\n  function _dropCompMarket ( address cToken ) external;\\r\\n  function _mintGuardianPaused (  ) external view returns ( bool );\\r\\n  function _setBorrowCapGuardian ( address newBorrowCapGuardian ) external;\\r\\n  function _setBorrowPaused ( address cToken, bool state ) external returns ( bool );\\r\\n  function _setClose ( uint256 newCloseFactorMantissa ) external returns ( uint256 );\\r\\n  function _setCollateralFactor ( address cToken, uint256 newCollateralFactorMantissa ) external returns ( uint256 );\\r\\n  function _setCompRate ( uint256 compRate_ ) external;\\r\\n  function _setLiquidationIncentive ( uint256 newLiquidationIncentiveMantissa ) external returns ( uint256 );\\r\\n  function _setMarketBorrowCaps ( address[] memory cTokens, uint256[] memory newBorrowCaps ) external;\\r\\n  function _setMaxAssets ( uint256 newMaxAssets ) external returns ( uint256 );\\r\\n  function _setMintPaused ( address cToken, bool state ) external returns ( bool );\\r\\n  function _setPauseGuardian ( address newPauseGuardian ) external returns ( uint256 );\\r\\n  function _setPriceOracle ( address newOracle ) external returns ( uint256 );\\r\\n  function _setSeizePaused ( bool state ) external returns ( bool );\\r\\n  function _setTransferPaused ( bool state ) external returns ( bool );\\r\\n  function _supportMarket ( address cToken ) external returns ( uint256 );\\r\\n  function accountAssets ( address, uint256 ) external view returns ( address );\\r\\n  function admin (  ) external view returns ( address );\\r\\n  function allMarkets ( uint256 ) external view returns ( address );\\r\\n  function borrowAllowed ( address cToken, address borrower, uint256 borrowAmount ) external returns ( uint256 );\\r\\n  function borrowCapGuardian (  ) external view returns ( address );\\r\\n  function borrowCaps ( address ) external view returns ( uint256 );\\r\\n  function borrowGuardianPaused ( address ) external view returns ( bool );\\r\\n  function borrowVerify ( address cToken, address borrower, uint256 borrowAmount ) external;\\r\\n  function checkMembership ( address account, address cToken ) external view returns ( bool );\\r\\n  function claimComp ( address holder, address[] memory cTokens ) external;\\r\\n  function claimComp ( address[] memory holders, address[] memory cTokens, bool borrowers, bool suppliers ) external;\\r\\n  function claimComp ( address holder ) external;\\r\\n  function closeFactorMantissa (  ) external view returns ( uint256 );\\r\\n  function compAccrued ( address ) external view returns ( uint256 );\\r\\n  function compBorrowState ( address ) external view returns ( uint224, uint32 );\\r\\n  function compBorrowerIndex ( address, address ) external view returns ( uint256 );\\r\\n  function compClaimThreshold (  ) external view returns ( uint256 );\\r\\n  function compInitialIndex (  ) external view returns ( uint224 );\\r\\n  function compRate (  ) external view returns ( uint256 );\\r\\n  function compSpeeds ( address ) external view returns ( uint256 );\\r\\n  function compSupplierIndex ( address, address ) external view returns ( uint256 );\\r\\n  function compSupplyState ( address ) external view returns ( uint224, uint32 );\\r\\n  function comptrollerImplementation (  ) external view returns ( address );\\r\\n  function enterMarkets ( address[] memory cTokens ) external returns ( uint256[] memory );\\r\\n  function exitMarket ( address cTokenAddress ) external returns ( uint256 );\\r\\n  function getAccountLiquidity ( address account ) external view returns ( uint256, uint256, uint256 );\\r\\n  function getAllMarkets (  ) external view returns ( address[] memory );\\r\\n  function getAssetsIn ( address account ) external view returns ( address[] memory );\\r\\n  function getBlockNumber (  ) external view returns ( uint256 );\\r\\n  function getCompAddress (  ) external view returns ( address );\\r\\n  function getHypotheticalAccountLiquidity ( address account, address cTokenModify, uint256 redeemTokens, uint256 borrowAmount ) external view returns ( uint256, uint256, uint256 );\\r\\n  function isComptroller (  ) external view returns ( bool );\\r\\n  function liquidateBorrowAllowed ( address cTokenBorrowed, address cTokenCollateral, address liquidator, address borrower, uint256 repayAmount ) external returns ( uint256 );\\r\\n  function liquidateBorrowVerify ( address cTokenBorrowed, address cTokenCollateral, address liquidator, address borrower, uint256 actualRepayAmount, uint256 seizeTokens ) external;\\r\\n  function liquidateCalculateSeizeTokens ( address cTokenBorrowed, address cTokenCollateral, uint256 actualRepayAmount ) external view returns ( uint256, uint256 );\\r\\n  function liquidationIncentiveMantissa (  ) external view returns ( uint256 );\\r\\n  function markets ( address ) external view returns ( bool isListed, uint256 collateralFactorMantissa, bool isComped );\\r\\n  function maxAssets (  ) external view returns ( uint256 );\\r\\n  function mintAllowed ( address cToken, address minter, uint256 mintAmount ) external returns ( uint256 );\\r\\n  function mintGuardianPaused ( address ) external view returns ( bool );\\r\\n  function mintVerify ( address cToken, address minter, uint256 actualMintAmount, uint256 mintTokens ) external;\\r\\n  function oracle (  ) external view returns ( address );\\r\\n  function pauseGuardian (  ) external view returns ( address );\\r\\n  function pendingAdmin (  ) external view returns ( address );\\r\\n  function pendingComptrollerImplementation (  ) external view returns ( address );\\r\\n  function redeemAllowed ( address cToken, address redeemer, uint256 redeemTokens ) external returns ( uint256 );\\r\\n  function redeemVerify ( address cToken, address redeemer, uint256 redeemAmount, uint256 redeemTokens ) external;\\r\\n  function refreshCompSpeeds (  ) external;\\r\\n  function repayBorrowAllowed ( address cToken, address payer, address borrower, uint256 repayAmount ) external returns ( uint256 );\\r\\n  function repayBorrowVerify ( address cToken, address payer, address borrower, uint256 actualRepayAmount, uint256 borrowerIndex ) external;\\r\\n  function seizeAllowed ( address cTokenCollateral, address cTokenBorrowed, address liquidator, address borrower, uint256 seizeTokens ) external returns ( uint256 );\\r\\n  function seizeGuardianPaused (  ) external view returns ( bool );\\r\\n  function seizeVerify ( address cTokenCollateral, address cTokenBorrowed, address liquidator, address borrower, uint256 seizeTokens ) external;\\r\\n  function transferAllowed ( address cToken, address src, address dst, uint256 transferTokens ) external returns ( uint256 );\\r\\n  function transferGuardianPaused (  ) external view returns ( bool );\\r\\n  function transferVerify ( address cToken, address src, address dst, uint256 transferTokens ) external;\\r\\n}\\r\\n\"},\"Ic_or_w_ETH.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface c_or_w_ETH {\\r\\n  function liquidateBorrow ( address borrower, address cTokenCollateral ) external payable;\\r\\n  function approve ( address spender, uint256 amount ) external returns ( bool );\\r\\n  function balanceOf ( address owner ) external view returns ( uint256 );\\r\\n  function balanceOfUnderlying ( address owner ) external returns ( uint256 );\\r\\n  function decimals (  ) external view returns ( uint256 );\\r\\n  function symbol (  ) external view returns ( string memory );\\r\\n  function totalSupply( ) external view returns (uint256 supply);\\r\\n  function transfer ( address dst, uint256 amount ) external returns ( bool );\\r\\n  function transferFrom ( address src, address dst, uint256 amount ) external returns ( bool );\\r\\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\r\\n}\\r\\n\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface ERC20 {\\r\\n  function liquidateBorrow ( address borrower, uint256 repayAmount, address cTokenCollateral ) external returns ( uint256 );\\r\\n  function approve ( address spender, uint256 amount ) external returns ( bool );\\r\\n  function balanceOf ( address owner ) external view returns ( uint256 );\\r\\n  function balanceOfUnderlying ( address owner ) external returns ( uint256 );\\r\\n  function decimals (  ) external view returns ( uint256 );\\r\\n  function mint ( uint256 mintAmount ) external returns ( uint256 );\\r\\n  function symbol (  ) external view returns ( string memory );\\r\\n  function totalSupply( ) external view returns (uint256 supply);\\r\\n  function transfer ( address dst, uint256 amount ) external returns ( bool );\\r\\n  function transferFrom ( address src, address dst, uint256 amount ) external returns ( bool );\\r\\n  function underlying (  ) external view returns ( address );\\r\\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\r\\n}\\r\\n\"},\"IKyberNetworkProxy.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IKyberNetworkProxy {\\n\\n    event ExecuteTrade(\\n        address indexed trader,\\n        ERC20 src,\\n        ERC20 dest,\\n        address destAddress,\\n        uint256 actualSrcAmount,\\n        uint256 actualDestAmount,\\n        address platformWallet,\\n        uint256 platformFeeBps\\n    );\\n\\n    /// @notice backward compatible\\n    function tradeWithHint(\\n        ERC20 src,\\n        uint256 srcAmount,\\n        ERC20 dest,\\n        address payable destAddress,\\n        uint256 maxDestAmount,\\n        uint256 minConversionRate,\\n        address payable walletId,\\n        bytes calldata hint\\n    ) external payable returns (uint256);\\n\\n    function tradeWithHintAndFee(\\n        ERC20 src,\\n        uint256 srcAmount,\\n        ERC20 dest,\\n        address payable destAddress,\\n        uint256 maxDestAmount,\\n        uint256 minConversionRate,\\n        address payable platformWallet,\\n        uint256 platformFeeBps,\\n        bytes calldata hint\\n    ) external payable returns (uint256 destAmount);\\n\\n    function trade(\\n        ERC20 src,\\n        uint256 srcAmount,\\n        ERC20 dest,\\n        address payable destAddress,\\n        uint256 maxDestAmount,\\n        uint256 minConversionRate,\\n        address payable platformWallet\\n    ) external payable returns (uint256);\\n\\n    /// @notice backward compatible\\n    /// @notice Rate units (10 ** 18) =\\u003e destQty (twei) / srcQty (twei) * 10 ** 18\\n    function getExpectedRate(\\n        ERC20 src,\\n        ERC20 dest,\\n        uint256 srcQty\\n    ) external view returns (uint256 expectedRate, uint256 worstRate);\\n\\n    function getExpectedRateAfterFee(\\n        ERC20 src,\\n        ERC20 dest,\\n        uint256 srcQty,\\n        uint256 platformFeeBps,\\n        bytes calldata hint\\n    ) external view returns (uint256 expectedRate);\\n}\"},\"IStructs.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n\\r\\ninterface Structs {\\r\\n    struct Val {\\r\\n        uint256 value;\\r\\n    }\\r\\n\\r\\n    enum ActionType {\\r\\n      Deposit,   // supply tokens\\r\\n      Withdraw,  // borrow tokens\\r\\n      Transfer,  // transfer balance between accounts\\r\\n      Buy,       // buy an amount of some token (externally)\\r\\n      Sell,      // sell an amount of some token (externally)\\r\\n      Trade,     // trade tokens against another account\\r\\n      Liquidate, // liquidate an undercollateralized or expiring account\\r\\n      Vaporize,  // use excnt is denominated in wei\\r\\n      Call       // send arbitrary data to an address\\r\\n    }\\r\\n\\r\\n    enum AssetReference {\\r\\n        Delta // the amount is given as a delta from the current value\\r\\n    }\\r\\n\\r\\n    struct AssetAmount {\\r\\n        bool sign;\\r\\n        AssetDenomination denomination;\\r\\n        AssetReference ref;\\r\\n        uint256 value;\\r\\n    }\\r\\n\\r\\n    enum AssetDenomination { Wei, Par }\\r\\n\\r\\n    struct ActionArgs {\\r\\n        ActionType actionType;\\r\\n        uint256 accountId;\\r\\n        AssetAmount amount;\\r\\n        uint256 primaryMarketId;\\r\\n        uint256 secondaryMarketId;\\r\\n        address otherAddress;\\r\\n        uint256 otherAccountId;\\r\\n        bytes data;\\r\\n    }\\r\\n\\r\\n    struct Info {\\r\\n        address owner;  // The address that owns the account\\r\\n        uint256 number; // A nonce that allows a single address to control many accounts\\r\\n    }\\r\\n\\r\\n    struct Wei {\\r\\n        bool sign; // true if positive\\r\\n        uint256 value;\\r\\n    }\\r\\n}\\r\\n\"},\"PreachersCompFiLqdt.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IStructs.sol\\\";\\r\\n\\r\\n// for CompFi Interfaces\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./Ic_or_w_ETH.sol\\\";\\r\\nimport \\\"./IComptroller.sol\\\";\\r\\n\\r\\n// KyberSwap\\r\\nimport \\\"./IKyberNetworkProxy.sol\\\";\\r\\n\\r\\n\\r\\n// dYdX flash loan contract\\r\\ninterface ISoloMargin {\\r\\n    function operate(Account.Info[] memory accounts, Actions.ActionArgs[] memory actions) external;\\r\\n}\\r\\n\\r\\naddress constant kETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\r\\n// Compound.Finance Comptroller constants\\r\\n// Note:To call Comptroller functions, use the Comptroller ABI on the Unitroller address.\\r\\naddress constant kUnitroller = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\\r\\naddress constant kComptroller = 0xd513d22422a3062Bd342Ae374b4b9c20E0a9a074;\\r\\naddress constant kcUSDC = 0x39AA39c021dfbaE8faC545936693aC917d5E7563;\\r\\naddress constant kcETH = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\\r\\n\\r\\n// KyberSwap Proxy contract \\r\\naddress constant kKyberProxy = 0x9AAb3f75489902f3a48495025729a0AF77d4b11e;\\r\\n// KyberHintHandler (KyberMatchingEngine)\\r\\naddress constant kKybeHint = 0xa1C0Fa73c39CFBcC11ec9Eb1Afc665aba9996E2C;\\r\\n\\r\\n// dYdX loan currencies\\r\\naddress constant kWETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\r\\naddress constant kSAI = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;\\r\\naddress constant kUSDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\\r\\naddress constant kDAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\\r\\n\\r\\nabstract contract DyDxPool is Structs {\\r\\n    function getAccountWei(Info memory account, uint256 marketId) public virtual view returns (Wei memory);\\r\\n    function operate(Info[] memory, ActionArgs[] memory) public virtual;\\r\\n}\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ncontract DyDxFlashLoan is Structs {\\r\\n    DyDxPool kDyDxPool = DyDxPool(0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e);\\r\\n\\r\\n    // address public WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\r\\n    // address public SAI = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;\\r\\n    // address public USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\\r\\n    // address public DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\\r\\n    mapping(address =\\u003e uint256) public currencies;\\r\\n    \\r\\n    constructor() {\\r\\n        currencies[kWETH] = 1;\\r\\n        currencies[kSAI] = 2;\\r\\n        currencies[kUSDC] = 3;\\r\\n        currencies[kDAI] = 4;\\r\\n    }\\r\\n\\r\\n    modifier onlyPool() {\\r\\n        require(msg.sender == address(kDyDxPool), \\\"FlashLoan: could be called by DyDx pool only\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function tokenToMarketId(address token) public view returns (uint256 ) {\\r\\n        \\r\\n        require(currencies[token] != 0, \\\"FlashLoan: Unsupported token\\\");\\r\\n        \\r\\n        return currencies[token] - 1;\\r\\n    }\\r\\n    \\r\\n\\r\\n    /***************************************************************************\\r\\n     * the DyDx will call `callFunction(address sender, Info memory accountInfo,\\r\\n     * bytes memory data) public` after during `operate` call\\r\\n     ***************************************************************************/\\r\\n    function flashloan(address token, uint256 amount, bytes memory data)\\r\\n        internal\\r\\n    {\\r\\n        ERC20(token).approve(address(kDyDxPool), amount + 1);\\r\\n        Info[] memory infos = new Info[](1);\\r\\n        ActionArgs[] memory args = new ActionArgs[](3);\\r\\n\\r\\n        infos[0] = Info(address(this), 0);\\r\\n\\r\\n        AssetAmount memory wamt = AssetAmount(\\r\\n            false,\\r\\n            AssetDenomination.Wei,\\r\\n            AssetReference.Delta,\\r\\n            amount\\r\\n        );\\r\\n        \\r\\n        ActionArgs memory withdraw;\\r\\n        withdraw.actionType = ActionType.Withdraw;\\r\\n        withdraw.accountId = 0;\\r\\n        withdraw.amount = wamt;\\r\\n        withdraw.primaryMarketId = tokenToMarketId(token);\\r\\n        withdraw.otherAddress = address(this);\\r\\n\\r\\n        args[0] = withdraw;\\r\\n\\r\\n        ActionArgs memory call;\\r\\n        call.actionType = ActionType.Call;\\r\\n        call.accountId = 0;\\r\\n        call.otherAddress = address(this);\\r\\n        call.data = data;\\r\\n\\r\\n        args[1] = call;\\r\\n\\r\\n        ActionArgs memory deposit;\\r\\n        AssetAmount memory damt = AssetAmount(\\r\\n            true,\\r\\n            AssetDenomination.Wei,\\r\\n            AssetReference.Delta,\\r\\n            amount + 1\\r\\n        );\\r\\n        deposit.actionType = ActionType.Deposit;\\r\\n        deposit.accountId = 0;\\r\\n        deposit.amount = damt;\\r\\n        deposit.primaryMarketId = tokenToMarketId(token);\\r\\n        deposit.otherAddress = address(this);\\r\\n\\r\\n        args[2] = deposit;\\r\\n\\r\\n        kDyDxPool.operate(infos, args);\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n/**********************************************************\\r\\n * Main Contract: PreachersCompFiLqdt\\r\\n **********************************************************/\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ncontract PreachersCompFiLqdt is DyDxFlashLoan {\\r\\n    uint256 public loan;\\r\\n    IKyberNetworkProxy cKyberProxy = IKyberNetworkProxy(kKyberProxy);\\r\\n\\r\\n    // Contract owner\\r\\n    address payable owner;\\r\\n\\r\\n    // Modifiers\\r\\n    modifier onlyOwner() {\\r\\n        require(msg.sender == owner, \\\"caller is not the owner!\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor() payable {\\r\\n\\r\\n        // Track the contract owner\\r\\n        owner = payable(msg.sender);\\r\\n        \\r\\n    }\\r\\n\\r\\n    /*************************************************************************************************************\\r\\n     * Call this contract function from the external \\r\\n     * remote job to perform the liquidation.\\r\\n     * \\r\\n     ************************************************************************************************************/\\r\\n    function doCompFiLiquidate(\\r\\n        //loan information\\r\\n        address flashToken, \\r\\n        uint256 flashAmount,\\r\\n        // Borrow Account to be liquidated\\r\\n        address targetAccount, \\r\\n        address targetToken, \\r\\n        uint256 liquidateAmount,\\r\\n        // liquidation reimbursement and Reward Token\\r\\n        address collateralToken\\r\\n        ) external returns(bool) {\\r\\n        \\r\\n        // Get the amount of the token in this contracts balance.\\r\\n        // At least 2 wei is needed for the loan fee.\\r\\n        uint256 balanceBefore = ERC20(flashToken).balanceOf(address(this));\\r\\n        \\r\\n        // Populate the passthru data structure, which will be used\\r\\n        // by \\u0027callFunction\\u0027\\r\\n        bytes memory data = abi.encode(\\r\\n            flashToken, \\r\\n            flashAmount, \\r\\n            balanceBefore,\\r\\n            targetAccount, \\r\\n            targetToken, \\r\\n            liquidateAmount, \\r\\n            collateralToken);\\r\\n        \\r\\n        // execution goes to `callFunction`\\r\\n        // STEP 1\\r\\n        flashloan(flashToken, flashAmount, data);\\r\\n        emit Liquidated( targetAccount, targetToken, liquidateAmount );\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    /**************************************************************************************\\r\\n     * Preacher\\u0027s Method II\\r\\n     * \\r\\n     * 1. Obtain Flash Loan in USDC from dYdX in the amount of equal value in the \\r\\n     * liquidation amount.\\r\\n     * 2. If the liquidate token is cUSDC, skip to step (3). Otherwise, swap (Kyber) the \\r\\n     * USDC for an equal value of the liquidate tokens.\\r\\n     * 3. Pay down the liquidate amount, liquidateBorrow(). CompFi will award an equal \\r\\n     * value from the unsafe account\\u0027s collateral + incentive reward.\\r\\n     * 4. Swap the received collateral tokens for USDC.\\r\\n     * 5. Repay the flash loan with the USDC.\\r\\n     * 6. Transfer what is left of the USDC to the Msg.sender.\\r\\n     * \\r\\n     **************************************************************************************/\\r\\n    function callFunction(\\r\\n        address, /* sender */\\r\\n        Info calldata, /* accountInfo */\\r\\n        bytes calldata data\\r\\n    ) external onlyPool {\\r\\n\\t\\r\\n\\t    // Decode the parameters in \\\"calldata\\\" as passed by doCompFiLiquidate.\\r\\n        (address flashToken, \\r\\n        uint256 flashAmount, \\r\\n        uint256 balanceBefore,\\r\\n        address targetAccount, \\r\\n        address targetToken, \\r\\n        uint256 liquidateAmount,\\r\\n        address collateralToken) = \\r\\n\\t\\t\\tabi.decode(data, (address, uint256, uint256, address, address, \\r\\n\\t\\t\\tuint256, address));\\r\\n\\r\\n\\t\\tERC20 cFlashToken = ERC20(flashToken);\\r\\n\\r\\n\\t\\trequire(cFlashToken.balanceOf(address(this)) - balanceBefore \\u003e=\\r\\n\\t\\t    flashAmount ,\\\"contract did not get the loan\\\");\\r\\n\\t\\temit Borrowed(flashToken, cFlashToken.balanceOf(address(this)));\\r\\n\\t\\t\\r\\n        // function approve(address _spender, uint256 _value) public returns (bool success)\\r\\n\\t\\tERC20 underlying = ERC20(cFlashToken.underlying( )); // get a handle for the underlying asset contract\\r\\n\\t\\trequire(underlying.approve(address(cFlashToken), flashAmount) == true, \\r\\n\\t\\t    \\\"01 approval failed\\\"); // approve the transfer\\r\\n\\t\\trequire(cFlashToken.mint(flashAmount) \\u003e 0, \\\"01 Mint failed\\\");    // mint the cTokens and assert there is no error\\r\\n\\t\\t\\r\\n\\t\\tERC20 cTargetToken = ERC20(targetToken);\\r\\n        // Step 2. Swap USDC for targetToken\\r\\n        if (targetToken != kcUSDC) {\\r\\n    \\t   require( executeKyberSwap(cFlashToken, flashAmount,\\r\\n\\t            cTargetToken, payable(address(this)), \\r\\n\\t            liquidateAmount) \\u003e 0, \\\"02 First Token swap failed\\\");\\r\\n        }\\r\\n        \\r\\n        require(cTargetToken.approve(address(this), liquidateAmount) == true,\\r\\n            \\\"02 approval failed.\\\");\\r\\n        \\r\\n        // Step 3. Pay down the amount borrowed by the unsafe account\\r\\n\\t\\t// -- Enter the market for the token to be liquidated\\r\\n\\t\\tComptroller ctroll = Comptroller(kUnitroller);\\r\\n\\r\\n\\t\\taddress[] memory cTokens = new address[](1);\\r\\n\\t\\tcTokens[0] = targetToken;\\r\\n\\t\\tuint[] memory ERRORS = ctroll.enterMarkets(cTokens);\\r\\n\\t\\tif (ERRORS[0] != 0) {\\r\\n            revert(\\\"01 Comptroller enter Markets for target token failed. \\\");\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tif (targetToken == kcETH){\\r\\n\\t\\t    c_or_w_ETH ceTargetToken = c_or_w_ETH(targetToken);\\r\\n\\t\\t    ceTargetToken.liquidateBorrow{value: flashAmount}\\r\\n\\t\\t        (targetAccount, collateralToken);\\r\\n\\t\\t} else {\\r\\n\\t\\t    cTargetToken.liquidateBorrow(targetAccount, flashAmount, collateralToken);\\r\\n\\t\\t}\\r\\n\\t\\trequire(ctroll.exitMarket(targetToken) == 0, \\r\\n\\t\\t    \\\"Exit Market of target token failed. \\\");\\r\\n\\t\\t \\r\\n\\t\\t// 4. Swap the received collateral tokens back to USDC to repay the flash loan.\\r\\n\\t\\tcTokens[0] = collateralToken;\\r\\n\\t\\tERRORS = ctroll.enterMarkets(cTokens);\\r\\n\\t\\trequire(ERRORS[0] == 0, \\\"02 Comptroller.enter Markets for collateral Token failed.\\\");\\r\\n\\r\\n\\t\\tERC20 cCollateralToken = ERC20(collateralToken);\\r\\n\\t\\trequire(cCollateralToken.approve(address(this), cCollateralToken.balanceOf(address(this))) == true,\\r\\n\\t\\t    \\\"03 Collateral Token approval failed.\\\");\\r\\n\\t\\t    \\r\\n\\t\\tif (collateralToken != kcUSDC) {\\r\\n    \\t   require( executeKyberSwap(cCollateralToken, \\r\\n    \\t        cCollateralToken.balanceOf(address(this)),\\r\\n\\t            cTargetToken, payable(address(this)), \\r\\n\\t            899999999999999999) \\u003e 0, \\\"02 First Token swap failed\\\");\\r\\n        }\\r\\n        \\r\\n    \\t// -- Liquidation is completed in flashloan()\\r\\n    }\\r\\n    \\r\\n    function changeOwner(address payable newOwner) public onlyOwner {\\r\\n        owner = newOwner;\\r\\n        emit ChangedOwner(owner, newOwner);\\r\\n    }\\r\\n\\r\\n    function getTokenBalance(address tokenAddress) public view returns(uint256) {\\r\\n        ERC20 theToken = ERC20(tokenAddress);\\r\\n        return theToken.balanceOf(address(this));\\r\\n    }\\r\\n    \\r\\n    function withdraw(address token) public onlyOwner returns(bool) {\\r\\n        uint256 tokenBalance;\\r\\n        // withdrawing Ether\\r\\n        if (address(token) == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\\r\\n            if (address(this).balance \\u003e 0){\\r\\n                tokenBalance = address(this).balance;\\r\\n                payable(msg.sender).transfer(address(this).balance);\\r\\n            }\\r\\n\\r\\n        } else {\\r\\n            ERC20 withdrawToken = ERC20(token);\\r\\n            if (withdrawToken.balanceOf(address(this)) \\u003e 0){\\r\\n                tokenBalance = withdrawToken.balanceOf(address(this));\\r\\n                require(withdrawToken.transfer(msg.sender, \\r\\n                    (withdrawToken.balanceOf(address(this)))));\\r\\n            }\\r\\n        }\\r\\n        emit Withdrawn(token, tokenBalance);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    event Transfer(address from, address to, uint256 value);\\r\\n    event Borrowed(address tokenborrowed, uint256 amount);\\r\\n    event Swapped(address fromtoken, uint256 fromamount,\\r\\n        address totoken, uint256 toamount);\\r\\n    event Liquidated(address account, address token, uint256 amount );\\r\\n    event ChangedOwner(address payable owner, address payable newOwner);\\r\\n    event Withdrawn(address token, uint256 amount);\\r\\n\\r\\n    /***************************************************************************\\r\\n     * KyberSwap functions\\r\\n    ****************************************************************************/\\r\\n    /// Swap from srcToken to destToken (including ether)\\r\\n    function executeKyberSwap( ERC20 cSrcToken, uint256 srcQty, ERC20 cDestToken, \\r\\n        address payable destAddress, uint256 maxDestAmount\\r\\n    ) internal returns ( uint256 ) {\\r\\n        \\r\\n        // if not Ethereum\\r\\n        if (address(cSrcToken) != kETH) {\\r\\n\\r\\n            // mitigate ERC20 Approve front-running attack, by initially setting\\r\\n            // allowance to 0\\r\\n            require(cSrcToken.approve(address(cKyberProxy), 0), \\\"approval to 0 failed\\\");\\r\\n\\r\\n            // set the spender\\u0027s token allowance to tokenQty\\r\\n            require(cSrcToken.approve(address(cKyberProxy), srcQty), \\\"approval to srcQty failed\\\");\\r\\n        }\\r\\n\\r\\n        // Get the minimum conversion rate\\r\\n        uint256 platformFeeBps = 25;    // using the Kyber example https://developer.kyber.network/docs/Integrations-SmartContractGuide/#fetching-rates\\r\\n        \\r\\n        uint256 minConversionRate = cKyberProxy.getExpectedRateAfterFee(\\r\\n            cSrcToken,\\r\\n            cDestToken,\\r\\n            srcQty,\\r\\n            platformFeeBps,\\r\\n            \\u0027\\u0027 // empty hint\\r\\n        );\\r\\n        \\r\\n        \\r\\n        /*********************************************************************************\\r\\n         * function trade(ERC20 src, uint256 srcAmount,\\r\\n         *  ERC20 dest, address payable destAddress,\\r\\n         *  uint256 maxDestAmount,    // wei\\r\\n         * \\r\\n         *  uint256 minConversionRate,\\r\\n         *      Minimum conversion rate (in wei). Trade is canceled if actual rate is lower\\r\\n         *      Should match makerAssetAmount/takerAssetAmount\\r\\n         *      This rate means for every 1 srcAmount, a Minimum\\r\\n         *      of X target Tokens are expected. \\r\\n         *      (Source token value / Target Token value) * 10**18 \\r\\n         * \\r\\n         *  address payable platformWallet ) external payable returns (uint256);\\r\\n        **********************************************************************************/\\r\\n        // Execute the trade and send to this contract to use to pay down the unsafe account\\r\\n        uint256 destAmount = cKyberProxy.trade(cSrcToken, srcQty, \\r\\n            cDestToken, payable(address(this)), \\r\\n            maxDestAmount, \\r\\n            minConversionRate,\\r\\n            // this contract\\r\\n            destAddress);\\r\\n          \\r\\n        emit Swapped(address(cSrcToken), srcQty, address(cDestToken), destAmount);\\r\\n        return destAmount;\\r\\n    }\\r\\n}\\r\\n\\r\\n// These definitions are taken from across multiple dydx contracts, and are\\r\\n// limited to just the bare minimum necessary to make flash loans work.\\r\\nlibrary Types {\\r\\n    enum AssetDenomination { Wei, Par }\\r\\n    enum AssetReference { Delta, Target }\\r\\n    struct AssetAmount {\\r\\n        bool sign;\\r\\n        AssetDenomination denomination;\\r\\n        AssetReference ref;\\r\\n        uint256 value;\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary Account {\\r\\n    struct Info {\\r\\n        address owner;\\r\\n        uint256 number;\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary Actions {\\r\\n    enum ActionType {\\r\\n        Deposit, Withdraw, Transfer, Buy, Sell, Trade, Liquidate, Vaporize, Call\\r\\n    }\\r\\n    struct ActionArgs {\\r\\n        ActionType actionType;\\r\\n        uint256 accountId;\\r\\n        Types.AssetAmount amount;\\r\\n        uint256 primaryMarketId;\\r\\n        uint256 secondaryMarketId;\\r\\n        address otherAddress;\\r\\n        uint256 otherAccountId;\\r\\n        bytes data;\\r\\n    }\\r\\n}\\r\\n\"}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenborrowed\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Borrowed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address payable\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address payable\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"ChangedOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Liquidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fromtoken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromamount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"totoken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toamount\",\"type\":\"uint256\"}],\"name\":\"Swapped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.Info\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"callFunction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"currencies\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"flashToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"flashAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"targetAccount\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"targetToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidateAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"}],\"name\":\"doCompFiLiquidate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"getTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"loan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"tokenToMarketId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"PreachersCompFiLqdt","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://7a6dddf9ff2f3bcf20d0af88c14a8e21433b1ad181c57fb855ca417aabe05398"}]}