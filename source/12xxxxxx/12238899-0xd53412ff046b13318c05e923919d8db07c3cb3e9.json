{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Rivendell.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.0;\\r\\n\\r\\nimport \\\"./Fellowship.sol\\\";\\r\\n\\r\\n/** \\r\\n @author Tellor Inc.\\r\\n @title Rivendell\\r\\n @dev This contract holds the voting logic to be used in the Fellowship contract\\r\\n**/\\r\\ncontract Rivendell {\\r\\n    //Storage\\r\\n    struct Vote {\\r\\n        uint256 walkerCount; //Number of total votes by walkers\\r\\n        uint256 payeeCount; //Number of total votes by payees\\r\\n        uint256 TRBCount; //Number of total votes by TRB holders\\r\\n        uint256 walkerTally; //Number of yes votes by walkers\\r\\n        uint256 payeeTally; //token weighted tally of yes votes by payees\\r\\n        uint256 TRBTally; //token weighted tally of yes votes by TRB holders\\r\\n        uint256 tally; //total weighted tally (/1000) of the vote\\r\\n        uint256 startDate; //startDate of the vote\\r\\n        uint256 startBlock; //startingblock of the vote\\r\\n        bool executed; //bool whether the vote has been settled and action ran\\r\\n        bytes32 ActionHash; //hash of the action to run upon successful vote\\r\\n    }\\r\\n\\r\\n    /*\\r\\n        Initial Weighting\\r\\n        40% - Walker Vote\\r\\n        40% - Customers\\r\\n        20% - TRB Holders\\r\\n    */\\r\\n    struct Weightings {\\r\\n        uint256 trbWeight; //weight of TRB holders\\r\\n        uint256 walkerWeight; //weight of Walkers\\r\\n        uint256 userWeight; //weight of payees (users)\\r\\n    }\\r\\n\\r\\n    Weightings weights;\\r\\n    mapping(address => mapping(uint256 => bool)) public voted; //mapping of address to mapping of ID's and bool if voted on said ID\\r\\n    mapping(uint256 => Vote) public voteBreakdown; // mapping of ID to the details of the vote\\r\\n    uint256 public voteCount; //Total number of votes handled by Rivendell contract\\r\\n    address public fellowship; // address of the fellowship contract.\\r\\n\\r\\n    //Events\\r\\n    event NewVote(uint256 voteID, address destination, bytes data);\\r\\n    event Voted(uint256 tally, address user);\\r\\n    event VoteSettled(uint256 voteID, bool passed);\\r\\n\\r\\n    //Functions\\r\\n    /**\\r\\n     * @dev Constructor for setting initial variables\\r\\n     * @param _fellowship the address of the fellowshipContract\\r\\n     */\\r\\n    constructor(address _fellowship) {\\r\\n        fellowship = _fellowship;\\r\\n        _setWeights(200, 400, 400);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to open a vote\\r\\n     * @param _destination address to call if vote passes\\r\\n     * @param _function bytes of function to call if vote passes\\r\\n     */\\r\\n    function openVote(address _destination, bytes memory _function) external {\\r\\n        require(\\r\\n            ERC20Interface(Fellowship(fellowship).tellor()).transferFrom(\\r\\n                msg.sender,\\r\\n                fellowship,\\r\\n                1 ether\\r\\n            )\\r\\n        );\\r\\n        //increment vote count\\r\\n        voteCount += 1;\\r\\n        //set struct variables\\r\\n        voteBreakdown[voteCount].startBlock = block.number; //safe to index vote from voteBreakdown mapping with VoteCount?\\r\\n        voteBreakdown[voteCount].startDate = block.timestamp;\\r\\n        bytes32 actionHash =\\r\\n            keccak256(abi.encodePacked(_destination, _function));\\r\\n        voteBreakdown[voteCount].ActionHash = actionHash;\\r\\n        emit NewVote(voteCount, _destination, _function);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to settle a vote after a week has passed\\r\\n     * @param _id ID of vote settle\\r\\n     * @param _destination destination of function to call\\r\\n     * @param _data bytes of function / action to call if successful\\r\\n     */\\r\\n    function settleVote(\\r\\n        uint256 _id,\\r\\n        address _destination,\\r\\n        bytes calldata _data\\r\\n    ) external returns (bool _succ, bytes memory _res) {\\r\\n        require(\\r\\n            block.timestamp - voteBreakdown[_id].startDate > 7 days,\\r\\n            \\\"vote has not been open long enough\\\"\\r\\n        );\\r\\n        require(\\r\\n            block.timestamp - voteBreakdown[_id].startDate < 14 days,\\r\\n            \\\"vote has failed / been too long\\\"\\r\\n        );\\r\\n        require(\\r\\n            voteBreakdown[_id].ActionHash ==\\r\\n                keccak256(abi.encodePacked(_destination, _data)),\\r\\n            \\\"Wrong action provided\\\"\\r\\n        );\\r\\n        require(!voteBreakdown[_id].executed, \\\"vote has already been settled\\\");\\r\\n        uint256 denominator = 1000;\\r\\n        if (voteBreakdown[_id].TRBCount == 0) {\\r\\n            denominator -= weights.trbWeight;\\r\\n        }\\r\\n        if (voteBreakdown[_id].walkerCount == 0) {\\r\\n            denominator -= weights.walkerWeight;\\r\\n        }\\r\\n        if (voteBreakdown[_id].payeeCount == 0) {\\r\\n            denominator -= weights.userWeight;\\r\\n        }\\r\\n        voteBreakdown[_id].executed = true;\\r\\n        if (voteBreakdown[_id].tally > denominator / 2) {\\r\\n            (_succ, _res) = _destination.call(_data);\\r\\n        }\\r\\n        emit VoteSettled(_id, voteBreakdown[_id].tally > denominator / 2);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to vote\\r\\n     * @param _id uint256 id of the vote\\r\\n     * @param _supports bool if supports the action being run\\r\\n     */\\r\\n    function vote(uint256 _id, bool _supports) external {\\r\\n        require(!voted[msg.sender][_id], \\\"address has already voted\\\");\\r\\n        require(voteBreakdown[_id].startDate > 0, \\\"vote must be started\\\");\\r\\n        //Inherit Fellowship\\r\\n        Fellowship _fellowship = Fellowship(fellowship);\\r\\n        uint256[3] memory weightedVotes;\\r\\n        //If the sender is a supported Walker (voter)\\r\\n        if (_fellowship.isWalker(msg.sender)) {\\r\\n            //Increment this election's number of voters\\r\\n            voteBreakdown[_id].walkerCount++;\\r\\n            //If they vote yes, add to yes votes Tally\\r\\n            if (_supports) {\\r\\n                voteBreakdown[_id].walkerTally++;\\r\\n            }\\r\\n        }\\r\\n        if (voteBreakdown[_id].walkerCount > 0) {\\r\\n            weightedVotes[0] =\\r\\n                weights.walkerWeight *\\r\\n                (voteBreakdown[_id].walkerTally /\\r\\n                    voteBreakdown[_id].walkerCount);\\r\\n        }\\r\\n        //increment payee contribution total by voter's contribution\\r\\n        voteBreakdown[_id].payeeCount += _fellowship.payments(msg.sender);\\r\\n        //should we make this just \\\"balanceOf\\\" to make it ERC20 compliant\\r\\n        uint256 _bal =\\r\\n            ERC20Interface(_fellowship.tellor()).balanceOfAt(\\r\\n                msg.sender,\\r\\n                voteBreakdown[_id].startBlock\\r\\n            );\\r\\n        voteBreakdown[_id].TRBCount += _bal;\\r\\n        if (_supports) {\\r\\n            voteBreakdown[_id].payeeTally += _fellowship.payments(msg.sender);\\r\\n            voteBreakdown[_id].TRBTally += _bal;\\r\\n        }\\r\\n        if (voteBreakdown[_id].payeeCount > 0) {\\r\\n            weightedVotes[1] =\\r\\n                weights.userWeight *\\r\\n                (voteBreakdown[_id].payeeTally / voteBreakdown[_id].payeeCount);\\r\\n        }\\r\\n        if (voteBreakdown[_id].TRBCount > 0) {\\r\\n            weightedVotes[2] =\\r\\n                weights.trbWeight *\\r\\n                (voteBreakdown[_id].TRBTally / voteBreakdown[_id].TRBCount);\\r\\n        }\\r\\n        voteBreakdown[_id].tally =\\r\\n            weightedVotes[0] +\\r\\n            weightedVotes[1] +\\r\\n            weightedVotes[2];\\r\\n        voted[msg.sender][_id] = true;\\r\\n        emit Voted(voteBreakdown[_id].tally, msg.sender);\\r\\n    }\\r\\n\\r\\n    //View Functions\\r\\n    /**\\r\\n     * @dev function to get details of a given vote id\\r\\n     * @param _id uint256 id of vote\\r\\n     * @return all information in voteBreakdown mapping\\r\\n     */\\r\\n    function getVoteInfo(uint256 _id)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint256[9] memory,\\r\\n            bool,\\r\\n            bytes32\\r\\n        )\\r\\n    {\\r\\n        return (\\r\\n            [\\r\\n                voteBreakdown[_id].walkerCount,\\r\\n                voteBreakdown[_id].payeeCount,\\r\\n                voteBreakdown[_id].TRBCount,\\r\\n                voteBreakdown[_id].walkerTally,\\r\\n                voteBreakdown[_id].payeeTally,\\r\\n                voteBreakdown[_id].TRBTally,\\r\\n                voteBreakdown[_id].tally,\\r\\n                voteBreakdown[_id].startDate,\\r\\n                voteBreakdown[_id].startBlock\\r\\n            ],\\r\\n            voteBreakdown[_id].executed,\\r\\n            voteBreakdown[_id].ActionHash\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to check weights in system\\r\\n     * @return TRB weights\\r\\n     * @return weight set for users\\r\\n     * @return weight set for walkers\\r\\n     */\\r\\n    function getWeights()\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256\\r\\n        )\\r\\n    {\\r\\n        return (weights.trbWeight, weights.userWeight, weights.walkerWeight);\\r\\n    }\\r\\n\\r\\n    //Internal Functions\\r\\n    /**\\r\\n     * @dev Internal Function to set weights in the contract\\r\\n     * @param _trb weight of TRB holders\\r\\n     * @param _walker weight of walkers\\r\\n     * @param _user weight of users of the Fellowship\\r\\n     **/\\r\\n    function _setWeights(\\r\\n        uint256 _trb,\\r\\n        uint256 _walker,\\r\\n        uint256 _user\\r\\n    ) internal {\\r\\n        require(_trb + _user + _walker == 1000, \\\"weights must sum to 1000\\\");\\r\\n        weights.trbWeight = _trb;\\r\\n        weights.userWeight = _user;\\r\\n        weights.walkerWeight = _walker;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Fellowship.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.0;\\r\\n\\r\\nimport \\\"./interfaces/ERC20Interface.sol\\\";\\r\\n\\r\\n/****\\r\\n\\r\\n████████╗██╗░░██╗███████╗  ███████╗███████╗██╗░░░░░██╗░░░░░░█████╗░░██╗░░░░░░░██╗░██████╗██╗░░██╗██╗██████╗░\\r\\n╚══██╔══╝██║░░██║██╔════╝  ██╔════╝██╔════╝██║░░░░░██║░░░░░██╔══██╗░██║░░██╗░░██║██╔════╝██║░░██║██║██╔══██╗\\r\\n░░░██║░░░███████║█████╗░░  █████╗░░█████╗░░██║░░░░░██║░░░░░██║░░██║░╚██╗████╗██╔╝╚█████╗░███████║██║██████╔╝\\r\\n░░░██║░░░██╔══██║██╔══╝░░  ██╔══╝░░██╔══╝░░██║░░░░░██║░░░░░██║░░██║░░████╔═████║░░╚═══██╗██╔══██║██║██╔═══╝░\\r\\n░░░██║░░░██║░░██║███████╗  ██║░░░░░███████╗███████╗███████╗╚█████╔╝░░╚██╔╝░╚██╔╝░██████╔╝██║░░██║██║██║░░░░░\\r\\n░░░╚═╝░░░╚═╝░░╚═╝╚══════╝  ╚═╝░░░░░╚══════╝╚══════╝╚══════╝░╚════╝░░░░╚═╝░░░╚═╝░░╚═════╝░╚═╝░░╚═╝╚═╝╚═╝░░░░░\\r\\n\\r\\n*****/\\r\\n\\r\\n/** \\r\\n @author Tellor Inc.\\r\\n @title Fellowship\\r\\n @dev This contract holds the selected few chosen as part of the Fellowship\\r\\n**/\\r\\ncontract Fellowship {\\r\\n    //Storage\\r\\n    enum Status {INACTIVE, ACTIVE, PENDING_WITHDRAW, UNFUNDED}\\r\\n\\r\\n    struct Walker {\\r\\n        Status status; //status of walker\\r\\n        uint256 date; //date the walker initally was chosen\\r\\n        uint256 fellowshipIndex; //index of walker in the fellowship array\\r\\n        uint256 balance; //TRB balance of walker (must be > stakeAmount to be ACTIVE)\\r\\n        uint256 rewardBalance; //balance of rewards they own\\r\\n        string name; //name of walker\\r\\n    }\\r\\n\\r\\n    uint256 public lastPayDate; //most recent date walkers were paid\\r\\n    uint256 public rewardPool; //sum of all payments for services in contract\\r\\n    uint256 public stakeAmount; //minimum amount each walker needs to stake\\r\\n    address public rivendell; //the address of the voting contract\\r\\n    address public tellor; //address of tellor (the token for staking and payments)\\r\\n\\r\\n    mapping(address => mapping(bytes32 => bytes)) information; //allows parties to store arbitrary information\\r\\n    mapping(address => Walker) public walkers; //a mapping of an address to their information as a Walker\\r\\n    mapping(address => uint256) public payments; //a mapping of an address to the payment amount they've given\\r\\n    //The Fellowship:\\r\\n    address[] public fellowship; //The array of chosen individuals who are part of the fellowship\\r\\n\\r\\n    //Events\\r\\n    event NewWalker(address walker);\\r\\n    event NewWalkerInformation(address walker, bytes32 input, bytes output);\\r\\n    event WalkerBanished(address walker);\\r\\n    event StakeWithdrawalRequestStarted(address walker);\\r\\n    event StakeWithdrawn(address walker);\\r\\n    event PaymentDeposited(address payee, uint256 amount);\\r\\n    event RewardsPaid(uint256 rewardPerWalker);\\r\\n\\r\\n    //Modifiers\\r\\n    /**\\r\\n     * @dev This modifier restricts the function to only the Rivendell contract\\r\\n     */\\r\\n    modifier onlyRivendell {\\r\\n        require(\\r\\n            msg.sender == rivendell,\\r\\n            \\\"Only rivendell can call this function.\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    //Functions\\r\\n    /**\\r\\n     * @dev Constructor for setting initial variables\\r\\n     * @param _tellor the address of the tellor contract\\r\\n     * @param _initialWalkers an array of three addresses to serve as the initial walkers\\r\\n     */\\r\\n    constructor(address _tellor, address[3] memory _initialWalkers) {\\r\\n        tellor = _tellor;\\r\\n        _newWalker(_initialWalkers[0], \\\"Aragorn\\\");\\r\\n        _newWalker(_initialWalkers[1], \\\"Legolas\\\");\\r\\n        _newWalker(_initialWalkers[2], \\\"Gimli\\\");\\r\\n        stakeAmount = 10 ether;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to banish a walker\\r\\n     * @param _oldWalker address of walker to be banished (removed from Fellowship)\\r\\n     **/\\r\\n    function banishWalker(address _oldWalker) external onlyRivendell {\\r\\n        require(\\r\\n            walkers[_oldWalker].status != Status.INACTIVE,\\r\\n            \\\"walker is already banished\\\"\\r\\n        );\\r\\n        _banishWalker(_oldWalker);\\r\\n        emit WalkerBanished(_oldWalker);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to deposit payment to use Fellowship\\r\\n     * @param _amount amount of TRB to be used as payment\\r\\n     **/\\r\\n    function depositPayment(uint256 _amount) external {\\r\\n        if (rewardPool > 0) {\\r\\n            payReward();\\r\\n        } else {\\r\\n            lastPayDate = block.timestamp;\\r\\n        }\\r\\n        ERC20Interface(tellor).transferFrom(msg.sender, address(this), _amount);\\r\\n        payments[msg.sender] += _amount;\\r\\n        rewardPool += _amount;\\r\\n        emit PaymentDeposited(msg.sender, _amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to deposit a stake for walkers\\r\\n     * @param _amount amount of TRB to deposit to account\\r\\n     **/\\r\\n    function depositStake(uint256 _amount) external {\\r\\n        ERC20Interface(tellor).transferFrom(msg.sender, address(this), _amount);\\r\\n        walkers[msg.sender].balance += _amount;\\r\\n        require(\\r\\n            walkers[msg.sender].status != Status.INACTIVE,\\r\\n            \\\"Walker has wrong status\\\"\\r\\n        );\\r\\n        require(\\r\\n            walkers[msg.sender].status != Status.PENDING_WITHDRAW,\\r\\n            \\\"Walker has wrong status\\\"\\r\\n        );\\r\\n        if (walkers[msg.sender].balance >= stakeAmount) {\\r\\n            walkers[msg.sender].status = Status.ACTIVE;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Change the rivendell (governance) contract\\r\\n     * @param _newRivendell address to act as owner of the Fellowship\\r\\n     **/\\r\\n    function newRivendell(address _newRivendell) external {\\r\\n        require(\\r\\n            msg.sender == rivendell || rivendell == address(0),\\r\\n            \\\"Only rivendell can call this function.\\\"\\r\\n        );\\r\\n        rivendell = _newRivendell;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to add a new walker\\r\\n     * @param _walker address of walker to be banished (removed from Fellowship)\\r\\n     * @param _name name of walker\\r\\n     **/\\r\\n    function newWalker(address _walker, string memory _name)\\r\\n        external\\r\\n        onlyRivendell\\r\\n    {\\r\\n        _newWalker(_walker, _name);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev function to pay a reward to the walkers\\r\\n     **/\\r\\n    function payReward() public {\\r\\n        uint256 timeSinceLastPayment = block.timestamp - lastPayDate;\\r\\n        if (timeSinceLastPayment > 6 * 30 days) {\\r\\n            timeSinceLastPayment = 6 * 30 days;\\r\\n        }\\r\\n        uint256 reward =\\r\\n            (rewardPool * timeSinceLastPayment) /\\r\\n                6 /\\r\\n                30 days /\\r\\n                fellowship.length;\\r\\n        if (reward > 0) {\\r\\n            for (uint256 i = 0; i < fellowship.length; i++) {\\r\\n                if (walkers[fellowship[i]].status == Status.ACTIVE) {\\r\\n                    walkers[fellowship[i]].rewardBalance += reward;\\r\\n                    rewardPool -= reward;\\r\\n                }\\r\\n            }\\r\\n            lastPayDate = block.timestamp;\\r\\n            emit RewardsPaid(reward);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function lets walkers recieve their reward\\r\\n     **/\\r\\n    function recieveReward() external {\\r\\n        require(\\r\\n            walkers[msg.sender].status == Status.ACTIVE,\\r\\n            \\\"Walker has wrong status\\\"\\r\\n        );\\r\\n        ERC20Interface(tellor).transfer(\\r\\n            msg.sender,\\r\\n            walkers[msg.sender].rewardBalance\\r\\n        );\\r\\n        walkers[msg.sender].rewardBalance = 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function for walkers to request to withdraw their stake\\r\\n     **/\\r\\n    function requestStakingWithdraw() external {\\r\\n        require(\\r\\n            walkers[msg.sender].status != Status.INACTIVE,\\r\\n            \\\"Walker has wrong status\\\"\\r\\n        );\\r\\n        walkers[msg.sender].status = Status.PENDING_WITHDRAW;\\r\\n        walkers[msg.sender].date = block.timestamp;\\r\\n        emit StakeWithdrawalRequestStarted(msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function for rivendell to change the staking amount\\r\\n     * @param _amount the staking requirement in TRB\\r\\n     **/\\r\\n    function setStakeAmount(uint256 _amount) external onlyRivendell {\\r\\n        stakeAmount = _amount;\\r\\n        for (uint256 i = 0; i < fellowship.length; i++) {\\r\\n            if (walkers[fellowship[i]].status == Status.ACTIVE && walkers[fellowship[i]].balance < stakeAmount) {\\r\\n                walkers[fellowship[i]].status = Status.UNFUNDED;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function for walkers to store arbitrary information mapped to their account\\r\\n     * @param _input the key for the mapping\\r\\n     * @param _output the result for the mapping\\r\\n     **/\\r\\n    function setWalkerInformation(bytes32 _input, bytes memory _output) external {\\r\\n        require(\\r\\n            isWalker(msg.sender) || msg.sender == rivendell,\\r\\n            \\\"must be a valid walker to use this function\\\"\\r\\n        );\\r\\n        information[msg.sender][_input] = _output;\\r\\n        emit NewWalkerInformation(msg.sender, _input, _output);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function for rivendell to slash a walker\\r\\n     * @param _walker the address of the slashed walker\\r\\n     * @param _amount the amount to slash\\r\\n     * @param _banish a bool to say whether the walker is also banished\\r\\n     **/\\r\\n    function slashWalker(\\r\\n        address _walker,\\r\\n        uint256 _amount,\\r\\n        bool _banish\\r\\n    ) external onlyRivendell {\\r\\n        if (walkers[_walker].balance >= _amount) {\\r\\n            walkers[_walker].balance -= _amount;\\r\\n            rewardPool += _amount;\\r\\n        } else if (walkers[_walker].balance > 0) {\\r\\n            rewardPool += walkers[_walker].balance;\\r\\n            walkers[_walker].balance = 0;\\r\\n        }\\r\\n        if (_banish) {\\r\\n            if (walkers[_walker].status != Status.INACTIVE) {\\r\\n                _banishWalker(_walker);\\r\\n            }\\r\\n        } else if (walkers[_walker].balance < stakeAmount) {\\r\\n            walkers[_walker].status = Status.UNFUNDED;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function for walkers to withdraw stake two weeks after requesting a withdrawal\\r\\n     **/\\r\\n    function withdrawStake() external {\\r\\n        require(\\r\\n            walkers[msg.sender].status == Status.PENDING_WITHDRAW,\\r\\n            \\\"walker has wrong status\\\"\\r\\n        );\\r\\n        require(\\r\\n            block.timestamp - walkers[msg.sender].date > 14 days,\\r\\n            \\\"has not been long enough to withdraw\\\"\\r\\n        );\\r\\n        ERC20Interface(tellor).transfer(\\r\\n            msg.sender,\\r\\n            walkers[msg.sender].balance\\r\\n        );\\r\\n        walkers[msg.sender].balance = 0;\\r\\n        _banishWalker(msg.sender);\\r\\n        emit StakeWithdrawn(msg.sender);\\r\\n    }\\r\\n\\r\\n    //View Functions\\r\\n    /**\\r\\n     * @dev Function returns the current reward for each walker\\r\\n     * @return uint256 reward\\r\\n     **/\\r\\n    function checkReward() external view returns (uint256) {\\r\\n        uint256 timeSinceLastPayment = block.timestamp - lastPayDate;\\r\\n        if (timeSinceLastPayment > 6 * 30 days) {\\r\\n            timeSinceLastPayment = 6 * 30 days;\\r\\n        }\\r\\n        return ((rewardPool * timeSinceLastPayment) /\\r\\n            6 /\\r\\n            30 days /\\r\\n            fellowship.length);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to return the fellowship size\\r\\n     * @return uint256 size\\r\\n     **/\\r\\n    function getFellowshipSize() external view returns (uint256) {\\r\\n        return fellowship.length;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function for walkers to withdraw stake two weeks after requesting a withdrawal\\r\\n     * @param _walker address of the walker of interest\\r\\n     * @return uint256 epoch timestamp of date walker started\\r\\n     * @return uint256 index in the fellowship array\\r\\n     * @return Status of the walker\\r\\n     * @return uint256 balance of the walker staked\\r\\n     * @return uint256 balance for withrawal by the walker\\r\\n     * @return string name of the walker\\r\\n     **/\\r\\n    function getWalkerDetails(address _walker)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint256,\\r\\n            uint256,\\r\\n            Status,\\r\\n            uint256,\\r\\n            uint256,\\r\\n            string memory\\r\\n        )\\r\\n    {\\r\\n        return (\\r\\n            walkers[_walker].date,\\r\\n            walkers[_walker].fellowshipIndex,\\r\\n            walkers[_walker].status,\\r\\n            walkers[_walker].balance,\\r\\n            walkers[_walker].rewardBalance,\\r\\n            walkers[_walker].name\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to get arbitrary information set by the walker\\r\\n     * @param _walker address of walker\\r\\n     * @param _input mapping key for information mapping\\r\\n     * @return bytes output of mapping\\r\\n     **/\\r\\n    function getWalkerInformation(address _walker, bytes32 _input)\\r\\n        external\\r\\n        view\\r\\n        returns (bytes memory)\\r\\n    {\\r\\n        return information[_walker][_input];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to check if walker's status is active\\r\\n     * @param _party address of walker\\r\\n     * @return bool if walker has Status.ACTIVE\\r\\n     **/\\r\\n    function isWalker(address _party) public view returns (bool) {\\r\\n        if (walkers[_party].status == Status.ACTIVE) {\\r\\n            return true;\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    //Internal Functions\\r\\n    /**\\r\\n     * @dev Internal function to banish a given walker\\r\\n     * @param _oldWalker walker to banish\\r\\n     **/\\r\\n    function _banishWalker(address _oldWalker) internal {\\r\\n        fellowship[walkers[_oldWalker].fellowshipIndex] = fellowship[\\r\\n            fellowship.length - 1\\r\\n        ];\\r\\n        walkers[fellowship[fellowship.length - 1]].fellowshipIndex = walkers[\\r\\n            _oldWalker\\r\\n        ]\\r\\n            .fellowshipIndex;\\r\\n        fellowship.pop();\\r\\n        walkers[_oldWalker].fellowshipIndex = 0;\\r\\n        walkers[_oldWalker].status = Status.INACTIVE;\\r\\n        ERC20Interface(tellor).transfer(\\r\\n            _oldWalker,\\r\\n            walkers[_oldWalker].balance\\r\\n        );\\r\\n        walkers[_oldWalker].balance = 0;\\r\\n        rewardPool += walkers[_oldWalker].rewardBalance;\\r\\n        walkers[_oldWalker].rewardBalance = 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to add a new walker\\r\\n     * @param _walker address of new walker\\r\\n     * @param _name name of new walker\\r\\n     **/\\r\\n    function _newWalker(address _walker, string memory _name) internal {\\r\\n        require(walkers[_walker].date == 0, \\\"cannot already be a walker\\\");\\r\\n        fellowship.push(_walker);\\r\\n        walkers[_walker] = Walker({\\r\\n            date: block.timestamp,\\r\\n            name: _name,\\r\\n            status: Status.UNFUNDED,\\r\\n            fellowshipIndex: fellowship.length - 1,\\r\\n            balance: 0,\\r\\n            rewardBalance: 0\\r\\n        });\\r\\n        emit NewWalker(_walker);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ERC20Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface ERC20Interface {\\r\\n    function transfer(address _to, uint256 _amount) external returns (bool);\\r\\n\\r\\n    function transferFrom(\\r\\n        address _from,\\r\\n        address _to,\\r\\n        uint256 _amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    function balanceOf(address _addy) external returns (uint256);\\r\\n\\r\\n    function balanceOfAt(address _addy, uint256 _block)\\r\\n        external\\r\\n        returns (uint256);\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fellowship\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"voteID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"NewVote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"voteID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"passed\",\"type\":\"bool\"}],\"name\":\"VoteSettled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tally\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"Voted\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"fellowship\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getVoteInfo\",\"outputs\":[{\"internalType\":\"uint256[9]\",\"name\":\"\",\"type\":\"uint256[9]\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWeights\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_destination\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_function\",\"type\":\"bytes\"}],\"name\":\"openVote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_destination\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"settleVote\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_succ\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"_res\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_supports\",\"type\":\"bool\"}],\"name\":\"vote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"voteBreakdown\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"walkerCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payeeCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"TRBCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"walkerTally\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payeeTally\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"TRBTally\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tally\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"ActionHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"voteCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"voted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Rivendell","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"000000000000000000000000ca240cf523cd9163c2a8465b2642b04749704625","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}