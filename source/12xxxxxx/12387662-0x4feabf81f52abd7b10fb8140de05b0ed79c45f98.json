{"status":"1","message":"OK","result":[{"SourceCode":"{\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENCED\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\ncontract Ownable {\\n\\n    address public owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n     * account.\\n     */\\n    constructor(){\\n        owner = msg.sender;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        require(newOwner != address(0));\\n        emit OwnershipTransferred(owner, newOwner);\\n        owner = newOwner;\\n    }\\n}\\n\\n\\n\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\\n\"},\"XIVBettingFlexible.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENCED\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\npragma abicoder v2;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./XIVInterface.sol\\\";\\n\\ncontract XIVBettingFlexible is Ownable{\\n    \\n    using SafeMath for uint256;\\n    address public databaseContractAddress=0x18464e4584759A50CE9FC58eA5997F8B0D1EA1d8;\\n    uint256 constant secondsInADay=24 hours;\\n    address public adminAddress=0x1Cff36DeBD53EEB3264fD75497356132C4067632;\\n    \\n    function betFlexible(uint256 amountOfXIV, uint16 typeOfBet, address _betContractAddress, uint256 betSlabeIndex, uint256 _days) external{\\n        // 0-\\u003e defi Fixed, 1-\\u003edefi flexible, 2-\\u003e index Fixed and 3-\\u003e index flexible 4-\\u003e flash fixed 5-\\u003e flash flexible\\n        require(typeOfBet==1 || typeOfBet==3  || typeOfBet==5, \\\"Invalid bet Type\\\");\\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\\n        require(!dContract.getExistingBetCheckMapping(msg.sender,typeOfBet,_betContractAddress),\\\"you can\\u0027t place bet using these values.\\\");\\n        require(dContract.isDaysAvailable(_days),\\\"Day does not exists.\\\");\\n        Token tokenObj = Token(dContract.getXIVTokenContractAddress());\\n        require((dContract.getBetFactorLP()).mul(dContract.getTokenStakedAmount())\\u003e=\\n                        ((tokenObj.balanceOf(databaseContractAddress)).sub(dContract.getTokenStakedAmount())).add(amountOfXIV),\\n                        \\\"Staking Vaults Have EXCEEDED CAPACITY. Please Check Back in 24hrs?\\\");\\n       \\n        require(amountOfXIV\\u003e=dContract.getMinStakeXIVAmount() \\u0026\\u0026 amountOfXIV\\u003c=dContract.getMaxStakeXIVAmount(),\\\"Please enter amount in the specified range\\\");\\n       \\n        if(typeOfBet==1 || typeOfBet==5){\\n            //defi flexible\\n            require((typeOfBet==1?dContract.getDefiCoinsFlexibleMapping(_betContractAddress):\\n                                    dContract.getDefiCoinsFixedMapping(_betContractAddress,true)).status,\\\"The currency is currently disabled.\\\");\\n            require(isFlexibleDaysAvailable(_days,false),\\\"Day does not exists.\\\");\\n            require(checkTimeForBet(_days),\\\"Staking time closed for the selected day\\\");\\n            require(dContract.getFlexibleDefiCoinArray().length\\u003ebetSlabeIndex,\\\"Day does not exists.\\\");\\n            OracleWrapper oWObject=OracleWrapper(dContract.getOracleWrapperContractAddress());\\n            XIVDatabaseLib.BetInfo memory binfo=XIVDatabaseLib.BetInfo({\\n                id:dContract.getBetId(),\\n                principalAmount:amountOfXIV,\\n                amount:amountOfXIV,\\n                userAddress:msg.sender,\\n                contractAddress:_betContractAddress,\\n                betType:typeOfBet,\\n                currentPrice:uint256(oWObject.getPrice((typeOfBet==1?dContract.getDefiCoinsFlexibleMapping(_betContractAddress):\\n                                    dContract.getDefiCoinsFixedMapping(_betContractAddress,true)).currencySymbol, (typeOfBet==1?dContract.getDefiCoinsFlexibleMapping(_betContractAddress):\\n                                    dContract.getDefiCoinsFixedMapping(_betContractAddress,true)).oracleType)),\\n                betTimePeriod:_days.mul(1 days),\\n                checkpointPercent:dContract.getFlexibleDefiCoinArray()[betSlabeIndex].upDownPercentage,\\n                rewardFactor:dContract.getFlexibleDefiCoinArray()[betSlabeIndex].rewardFactor,\\n                riskFactor:dContract.getFlexibleDefiCoinArray()[betSlabeIndex].riskFactor,\\n                timestamp:block.timestamp,\\n                adminCommissionFee:0,\\n                status:0\\n            });\\n            dContract.updateBetArray(binfo);\\n            dContract.updateFindBetInArrayUsingBetIdMapping(dContract.getBetId(),dContract.getBetArray().length.sub(1));\\n            if(dContract.getBetsAccordingToUserAddress(msg.sender).length==0){\\n                dContract.addUserAddressUsedForBetting(msg.sender);\\n            }\\n            dContract.updateBetAddressesArray(msg.sender,dContract.getBetId());\\n            dContract.updateBetId(dContract.getBetId().add(1));\\n            uint256 betEndTime=(((((binfo.timestamp).div(secondsInADay)).mul(secondsInADay))).add(secondsInADay.div(2)).add(binfo.betTimePeriod).sub(1));\\n            dContract.emitBetDetails(binfo.id,binfo.status,betEndTime);\\n        }else if(typeOfBet==3){\\n            //index flexible\\n            require(isFlexibleDaysAvailable(_days, true),\\\"Day does not exists.\\\");\\n            require(checkTimeForBet(_days),\\\"Staking time closed for the selected day\\\");\\n            require(dContract.getFlexibleIndexArray().length\\u003ebetSlabeIndex,\\\"Day does not exists.\\\");\\n            XIVDatabaseLib.BetInfo memory binfo=XIVDatabaseLib.BetInfo({\\n                id:dContract.getBetId(),\\n                principalAmount:amountOfXIV,\\n                amount:amountOfXIV,\\n                userAddress:msg.sender,\\n                contractAddress:address(0),\\n                betType:typeOfBet,\\n                currentPrice:uint256(calculateIndexValueForFlexibleInternal(dContract.getBetId())),\\n                betTimePeriod:_days.mul(1 days),\\n                checkpointPercent:dContract.getFlexibleIndexArray()[betSlabeIndex].upDownPercentage,\\n                rewardFactor:dContract.getFlexibleIndexArray()[betSlabeIndex].rewardFactor,\\n                riskFactor:dContract.getFlexibleIndexArray()[betSlabeIndex].riskFactor,\\n                timestamp:block.timestamp,\\n                adminCommissionFee:0,\\n                status:0\\n            });\\n            dContract.updateBetArray(binfo);\\n            dContract.updateFindBetInArrayUsingBetIdMapping(dContract.getBetId(),dContract.getBetArray().length.sub(1));\\n            if(dContract.getBetsAccordingToUserAddress(msg.sender).length==0){\\n                dContract.addUserAddressUsedForBetting(msg.sender);\\n            }\\n            dContract.updateBetAddressesArray(msg.sender,dContract.getBetId());\\n            dContract.updateBetId(dContract.getBetId().add(1));\\n            uint256 betEndTime=(((((binfo.timestamp).div(secondsInADay)).mul(secondsInADay))).add(secondsInADay.div(2)).add(binfo.betTimePeriod).sub(1));\\n            dContract.emitBetDetails(binfo.id,binfo.status,betEndTime);\\n        }\\n        dContract.transferFromTokens(dContract.getXIVTokenContractAddress(),msg.sender,databaseContractAddress,amountOfXIV);\\n        dContract.updateTotalTransactions(dContract.getTotalTransactions().add(amountOfXIV));\\n        dContract.updateExistingBetCheckMapping(msg.sender,typeOfBet,_betContractAddress,true);\\n    }\\n    function checkTimeForBet(uint256 _days) internal view returns(bool){\\n        uint256 currentTime=block.timestamp;\\n        uint256 utcNoon=((block.timestamp.div(secondsInADay)).mul(secondsInADay)).add(secondsInADay.div(2));\\n        if(_days==1){\\n            if(((utcNoon).add(4 hours))\\u003ecurrentTime){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }else if(_days==3){\\n            if(((utcNoon).add(12 hours))\\u003ecurrentTime){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    function isFlexibleDaysAvailable(uint256 _days, bool isIndex) internal view returns(bool){\\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\\n        if(isIndex){\\n            for(uint256 i=0;i\\u003cdContract.getFlexibleIndexTimePeriodArray().length;i++){\\n                if(dContract.getFlexibleIndexTimePeriodArray()[i]._days==_days \\u0026\\u0026 dContract.getFlexibleIndexTimePeriodArray()[i].status==true){\\n                    return true;\\n                }\\n            }\\n        }else{\\n            for(uint256 i=0;i\\u003cdContract.getFlexibleDefiCoinTimePeriodArray().length;i++){\\n                if(dContract.getFlexibleDefiCoinTimePeriodArray()[i]._days==_days \\u0026\\u0026 dContract.getFlexibleDefiCoinTimePeriodArray()[i].status==true){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n   function calculateIndexValueForBetActual() external view returns(uint256){\\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\\n        uint256 totalMarketcap;\\n        for(uint256 i=0;i\\u003cdContract.getAllIndexContractAddressArray().length;i++){\\n            Token tObj=Token(dContract.getAllIndexContractAddressArray()[i]);\\n            XIVDatabaseLib.IndexCoin memory iCObj=dContract.getDefiCoinIndexMapping(dContract.getAllIndexContractAddressArray()[i]);\\n            if(iCObj.status){\\n                totalMarketcap=totalMarketcap.add(marketCapValue(iCObj,tObj));\\n            }\\n        }\\n        return totalMarketcap;\\n    }\\n    function calculateIndexValueForBetBase() external view returns(uint256){\\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\\n        uint256 totalMarketcap;\\n        for(uint256 i=0;i\\u003cdContract.getAllIndexContractAddressArray().length;i++){\\n            Token tObj=Token(dContract.getAllIndexContractAddressArray()[i]);\\n            XIVDatabaseLib.IndexCoin memory iCObj=dContract.getDefiCoinIndexMapping(dContract.getAllIndexContractAddressArray()[i]);\\n            if(iCObj.status){\\n                totalMarketcap=totalMarketcap.add(marketCapValue(iCObj,tObj));\\n            }\\n        }\\n         if(dContract.getBetBaseIndexValue()==0){\\n            return (10**11);\\n        }else{\\n            if(totalMarketcap\\u003edContract.getBetActualIndexValue()){\\n                return (dContract.getBetBaseIndexValue().add((\\n                                                     (totalMarketcap.sub(dContract.getBetActualIndexValue()))\\n                                                     .mul(100*10**8)).div(dContract.getBetActualIndexValue())));\\n            }else if(totalMarketcap\\u003cdContract.getBetActualIndexValue()){\\n                return (dContract.getBetBaseIndexValue().sub((\\n                                                     (dContract.getBetActualIndexValue().sub(totalMarketcap))\\n                                                     .mul(100*10**8)).div(dContract.getBetActualIndexValue())));\\n            }\\n        }\\n        return (10**11);\\n    }\\n    \\n    function calculateIndexValueForFlexibleInternal(uint256 _betId) internal returns(uint256){\\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\\n        uint256 totalMarketcap;\\n        for(uint256 i=0;i\\u003cdContract.getAllIndexContractAddressArray().length;i++){\\n            Token tObj=Token(dContract.getAllIndexContractAddressArray()[i]);\\n            XIVDatabaseLib.IndexCoin memory iCObj=dContract.getDefiCoinIndexMapping(dContract.getAllIndexContractAddressArray()[i]);\\n            if(iCObj.status){\\n                totalMarketcap=totalMarketcap.add(marketCapValue(iCObj,tObj));\\n                dContract.updateBetIndexForFlexibleArray(_betId,iCObj);\\n            }\\n        }\\n        XIVDatabaseLib.BetPriceHistory memory bPHObj=XIVDatabaseLib.BetPriceHistory({\\n            baseIndexValue:dContract.getBetBaseIndexValue()==0?10**11:dContract.getBetBaseIndexValue(),\\n            actualIndexValue:totalMarketcap\\n        });\\n        dContract.updateBetPriceHistoryFlexibleMapping(_betId,bPHObj);\\n        if(dContract.getBetBaseIndexValue()==0){\\n            dContract.updateBetBaseIndexValue(10**11);\\n        }else{\\n            if(totalMarketcap\\u003edContract.getBetActualIndexValue()){\\n                dContract.updateBetBaseIndexValue(dContract.getBetBaseIndexValue().add((\\n                                                     (totalMarketcap.sub(dContract.getBetActualIndexValue()))\\n                                                     .mul(100*10**8)).div(dContract.getBetActualIndexValue())));\\n            }else if(totalMarketcap\\u003cdContract.getBetActualIndexValue()){\\n                dContract.updateBetBaseIndexValue(dContract.getBetBaseIndexValue().sub((\\n                                                     (dContract.getBetActualIndexValue().sub(totalMarketcap))\\n                                                     .mul(100*10**8)).div(dContract.getBetActualIndexValue())));\\n            }\\n        }\\n        dContract.updateBetActualIndexValue(totalMarketcap);\\n        return totalMarketcap;\\n    }\\n    \\n    function claimBet(uint256 userBetId) external{\\n        // 0-\\u003e defi Fixed, 1-\\u003edefi flexible, 2-\\u003e index Fixed and 3-\\u003e index flexible\\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\\n        uint256 index=dContract.getFindBetInArrayUsingBetIdMapping(userBetId);\\n        XIVDatabaseLib.BetInfo memory bObject=dContract.getBetArray()[index];\\n        require((bObject.status==0) \\n                || (bObject.status==1)\\n                || (bObject.status==2),\\\"bet is closed.\\\");\\n        if(bObject.status==0){\\n           if(block.timestamp.sub(bObject.timestamp) \\u003e 6 days){\\n                plentyFinal(index,7);\\n                return;\\n            }else if(block.timestamp.sub(bObject.timestamp) \\u003e 5 days){\\n                plentyFinal(index,6);\\n                return;\\n            }else if(block.timestamp.sub(bObject.timestamp) \\u003e 4 days){\\n                plentyFinal(index,5);\\n                return;\\n            }else if(block.timestamp.sub(bObject.timestamp) \\u003e 3 days){\\n                plentyFinal(index,4);\\n                return;\\n            }else if(block.timestamp.sub(bObject.timestamp) \\u003e 2 days){\\n                plentyFinal(index,3);\\n                return;\\n            }else if(block.timestamp.sub(bObject.timestamp) \\u003e 1 days){\\n                plentyFinal(index,2);\\n                return;\\n            }else{\\n                plentyFinal(index,1);\\n                return;\\n            }\\n        }else{\\n            claimBetFinal(index);\\n        }\\n    }\\n    \\n    function claimBetFinal(uint256 index) internal{\\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\\n        XIVDatabaseLib.BetInfo memory bObject=dContract.getBetArray()[index];\\n        require(bObject.userAddress==msg.sender,\\\"Authentication failure\\\");\\n        require(bObject.amount!=0,\\\"Your bet amount is 0\\\");\\n        dContract.transferTokens(dContract.getXIVTokenContractAddress(),msg.sender,(bObject.amount)); \\n        bObject.amount=0; // return 3 times\\n        dContract.updateBetArrayIndex(bObject,index);\\n    }\\n    function plentyFinal(uint256 index, uint256 _days) internal{\\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\\n        XIVDatabaseLib.BetInfo memory bObject=dContract.getBetArray()[index];\\n        uint256 plentyPercentage;\\n        if(bObject.betTimePeriod==1 days){\\n            plentyPercentage=dContract.getPlentyOneDayPercentage();\\n        }else if(bObject.betTimePeriod==3 days){\\n            plentyPercentage=dContract.getPlentyThreeDayPercentage(_days);\\n        }else if(bObject.betTimePeriod==7 days){\\n            plentyPercentage=dContract.getPlentySevenDayPercentage(_days);\\n        }\\n        if(plentyPercentage!=0){\\n            uint256 plentyAmount=((plentyPercentage.mul(bObject.amount)).div(10**4));\\n            uint256 userAmount=(bObject.amount).sub(plentyAmount);\\n            if(userAmount!=0){\\n                dContract.transferTokens(dContract.getXIVTokenContractAddress(),msg.sender,userAmount); \\n            }\\n            if(plentyAmount!=0){\\n                dContract.transferTokens(dContract.getXIVTokenContractAddress(),adminAddress,plentyAmount); \\n            }\\n            bObject.status=3;\\n            bObject.amount=0;\\n            dContract.updateBetArrayIndex(bObject,index);\\n            dContract.updateExistingBetCheckMapping(bObject.userAddress,bObject.betType,bObject.contractAddress,false);\\n        }\\n    }\\n    \\n    function marketCapValue(XIVDatabaseLib.IndexCoin memory iCObj,Token tObj) internal view returns(uint256){\\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\\n        OracleWrapper oWObject=OracleWrapper(dContract.getOracleWrapperContractAddress());\\n         if((keccak256(abi.encodePacked(iCObj.currencySymbol))) == (keccak256(abi.encodePacked(\\\"ETH\\\"))) || (keccak256(abi.encodePacked(iCObj.currencySymbol))) == (keccak256(abi.encodePacked(\\\"BTC\\\")))){\\n            return ((((oWObject.getPrice(iCObj.currencySymbol,iCObj.oracleType))\\n                                        /* .mul(iCObj.contributionPercentage)*/)\\n                                        .div(10**2)));\\n        }else{\\n            return (((tObj.totalSupply().mul(oWObject.getPrice(iCObj.currencySymbol,iCObj.oracleType))\\n                                /*.mul(iCObj.contributionPercentage)*/)\\n                                .div((10**tObj.decimals()).mul(10**2))));\\n        }\\n    }\\n    function getPieChartValue() external view returns(XIVDatabaseLib.IndexCoin[] memory){\\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\\n        uint256 totalMarketcap;\\n        XIVDatabaseLib.IndexCoin[] memory tempIndexArray=new XIVDatabaseLib.IndexCoin[](dContract.getAllIndexContractAddressArray().length);\\n        for(uint256 i=0;i\\u003cdContract.getAllIndexContractAddressArray().length;i++){\\n            Token tObj=Token(dContract.getAllIndexContractAddressArray()[i]);\\n            XIVDatabaseLib.IndexCoin memory iCObj=dContract.getDefiCoinIndexMapping(dContract.getAllIndexContractAddressArray()[i]);\\n            if(iCObj.status){\\n                totalMarketcap=totalMarketcap.add(marketCapValue(iCObj,tObj));\\n            }\\n        }\\n        for(uint256 i=0;i\\u003cdContract.getAllIndexContractAddressArray().length;i++){\\n            Token tObj=Token(dContract.getAllIndexContractAddressArray()[i]);\\n            XIVDatabaseLib.IndexCoin memory iCObj=dContract.getDefiCoinIndexMapping(dContract.getAllIndexContractAddressArray()[i]);\\n            if(iCObj.status){\\n                iCObj.contributionPercentage=(marketCapValue(iCObj,tObj).mul(10**4))/totalMarketcap;\\n                tempIndexArray[i]=iCObj;\\n            }\\n        }\\n        return tempIndexArray;\\n    }\\n    \\n    function updateDatabaseAddress(address _databaseContractAddress) external onlyOwner{\\n        databaseContractAddress=_databaseContractAddress;\\n    }\\n    \\n    function updateAdminAddress(address _adminAddress) external onlyOwner{\\n        adminAddress=_adminAddress;\\n    }\\n}\\n\\n\\n\"},\"XIVDatabaseLib.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENCED\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\npragma abicoder v2;\\n\\nlibrary XIVDatabaseLib{\\n    // deficoin struct for deficoinmappings..\\n    struct DefiCoin{\\n        uint16 oracleType;\\n        string currencySymbol;\\n        bool status;\\n    }\\n    struct TimePeriod{\\n        uint256 _days;\\n        bool status;\\n    }\\n     struct FlexibleInfo{\\n        uint256 id;\\n        uint16 upDownPercentage; //10**2\\n        uint16 riskFactor;       //10**2\\n        uint16 rewardFactor;     //10**2\\n        bool status;\\n    }\\n    struct FixedInfo{\\n        uint256 id;\\n        uint256 daysCount;// integer value\\n        uint16 upDownPercentage; //10**2\\n        uint16 riskFactor;       //10**2\\n        uint16 rewardFactor;     //10**2\\n        bool status;\\n    }\\n    struct IndexCoin{\\n        uint16 oracleType;\\n        string currencySymbol;\\n        address contractAddress;\\n        bool status;\\n        uint256 contributionPercentage; //10**2\\n    }\\n    struct BetPriceHistory{\\n        uint256 baseIndexValue;\\n        uint256 actualIndexValue;\\n    }\\n    struct LPLockedInfo{\\n        uint256 lockedTimeStamp;\\n        uint256 amountLocked;\\n    }\\n    struct StakingInfo{\\n        uint256 investmentId;\\n        uint256 stakeAmount;\\n    }\\n    struct IncentiveInfo{\\n        uint256 tillInvestmentId;\\n        uint256 incentiveAmount;\\n        uint256 totalAmountStakedAtIncentiveTime;\\n    }\\n    struct BetInfo{\\n        uint256 id;\\n        uint256 principalAmount;\\n        uint256 amount;\\n        address userAddress;\\n        address contractAddress;\\n        uint256 betType; //\\n        uint256 currentPrice;\\n        uint256 timestamp;\\n        uint256 betTimePeriod;\\n        uint16 checkpointPercent;\\n        uint16 rewardFactor;\\n        uint16 riskFactor;\\n        uint256 adminCommissionFee;\\n        uint16 status; // 0-\\u003ebet active, 1-\\u003ebet won, 2-\\u003ebet lost, 3-\\u003e withdraw before result\\n    }\\n}\\n\"},\"XIVInterface.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENCED\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\npragma abicoder v2;\\n\\nimport \\\"./XIVDatabaseLib.sol\\\";\\n\\ninterface Token{\\n    function decimals() external view returns(uint256);\\n    function symbol() external view returns(string memory);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address who) external view returns (uint256);\\n    function transfer(address to, uint256 value) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n    function approve(address spender, uint256 value) external returns (bool);\\n}\\n\\n\\ninterface OracleWrapper{\\n    function getPrice(string calldata currencySymbol,uint256 oracleType) external view returns (uint256);\\n}\\ninterface DatabaseContract{\\n    function transferTokens(address contractAddress,address userAddress,uint256 amount) external;\\n    function transferFromTokens(address contractAddress,address fromAddress, address toAddress,uint256 amount) external;\\n    function getTokensStaked(address userAddress) external view returns(uint256);\\n    function updateTokensStaked(address userAddress, uint256 amount) external;\\n    function getTokenStakedAmount() external view returns(uint256);\\n    function updateTokenStakedAmount(uint256 _tokenStakedAmount) external;\\n    function getBetId() external view returns(uint256);\\n    function updateBetId(uint256 _userBetId) external;\\n    function updateBetArray(XIVDatabaseLib.BetInfo memory bObject) external;\\n    function getBetArray() external view returns(XIVDatabaseLib.BetInfo[] memory);\\n    function getFindBetInArrayUsingBetIdMapping(uint256 _betid) external view returns(uint256);\\n    function updateFindBetInArrayUsingBetIdMapping(uint256 _betid, uint256 value) external;\\n    function updateUserStakedAddress(address _address) external;\\n    function updateUserStakedAddress(address[] memory _userStakedAddress) external;\\n    function getUserStakedAddress() external view returns(address[] memory);\\n    function getDefiCoinsFixedMapping(address _betContractAddress,bool isFlashVault) external view returns(XIVDatabaseLib.DefiCoin memory);\\n    function getDefiCoinsFlexibleMapping(address _betContractAddress) external view returns(XIVDatabaseLib.DefiCoin memory);\\n    function getFlexibleDefiCoinArray() external view returns(XIVDatabaseLib.FlexibleInfo[] memory);\\n    function getFlexibleIndexArray() external view returns(XIVDatabaseLib.FlexibleInfo[] memory);\\n    function updateBetArrayIndex(XIVDatabaseLib.BetInfo memory bObject, uint256 index) external;\\n    function updateBetIndexForFixedArray(uint256 _betId, XIVDatabaseLib.IndexCoin memory iCArray) external;\\n    function updateBetBaseIndexValue(uint256 _betBaseIndexValueFixed) external;\\n    function getBetBaseIndexValue() external view returns(uint256);\\n    function updateBetPriceHistoryFixedMapping(uint256 _betId, XIVDatabaseLib.BetPriceHistory memory bPHObj) external;\\n    function updateBetActualIndexValue(uint256 _betActualIndexValueFixed) external;\\n    function getBetActualIndexValue() external view returns(uint256);\\n    function getBetIndexForFixedArray(uint256 _betId) external view returns(XIVDatabaseLib.IndexCoin[] memory);\\n    function getBetPriceHistoryFixedMapping(uint256 _betId) external view returns(XIVDatabaseLib.BetPriceHistory memory);\\n    function getXIVTokenContractAddress() external view returns(address);\\n    function getAllIndexContractAddressArray() external view returns(address[] memory);\\n    function getDefiCoinIndexMapping(address _ContractAddress) external view returns(XIVDatabaseLib.IndexCoin memory);\\n    \\n    function updateBetIndexForFlexibleArray(uint256 _betId, XIVDatabaseLib.IndexCoin memory iCArray) external;\\n    function getBetIndexForFlexibleArray(uint256 _betId) external view returns(XIVDatabaseLib.IndexCoin[] memory);\\n    function updateBetPriceHistoryFlexibleMapping(uint256 _betId, XIVDatabaseLib.BetPriceHistory memory bPHObj) external;\\n    function getBetPriceHistoryFlexibleMapping(uint256 _betId) external view returns(XIVDatabaseLib.BetPriceHistory memory);\\n    \\n    function getOracleWrapperContractAddress() external view returns(address);\\n    function getPlentyOneDayPercentage() external view returns(uint256);\\n    function getPlentyThreeDayPercentage(uint256 _days) external view returns(uint256);\\n    function getPlentySevenDayPercentage(uint256 _days) external view returns(uint256);\\n    function getBetsAccordingToUserAddress(address userAddress) external view returns(uint256[] memory);\\n    function updateBetAddressesArray(address userAddress, uint256 _betId) external;\\n    function getRewardGeneratedAmount() external view returns(uint256);\\n    function updateRewardGeneratedAmount(uint256 _rewardGeneratedAmount) external;\\n    function addUserAddressUsedForBetting(address userAddress) external;\\n    function getUserAddressUsedForBetting() external view returns(address[] memory);\\n    function getFixedDefiCoinArray() external view returns(XIVDatabaseLib.FixedInfo[] memory);\\n    function getFixedDefiIndexArray() external view returns(XIVDatabaseLib.FixedInfo[] memory);\\n    function getMaxStakeXIVAmount() external view returns(uint256);\\n    function getMinStakeXIVAmount() external view returns(uint256);\\n    function getBetFactorLP() external view returns(uint256);\\n    function updateActualAmountStakedByUser(address userAddress, uint256 amount) external;\\n    function getActualAmountStakedByUser(address userAddress) external view returns(uint256);\\n    function isDaysAvailable(uint256 _days) external view returns(bool);\\n    function updateExistingBetCheckMapping(address _userAddress,uint256 _betType, address _BetContractAddress,bool status) external;\\n    function getExistingBetCheckMapping(address _userAddress,uint256 _betType, address _BetContractAddress) external view returns(bool);\\n    function updateTotalTransactions(uint256 _totalTransactions) external;\\n    function getTotalTransactions() external view returns(uint256);\\n    function getFlexibleDefiCoinTimePeriodArray() external view returns(XIVDatabaseLib.TimePeriod[] memory);\\n    function getFlexibleIndexTimePeriodArray() external view returns(XIVDatabaseLib.TimePeriod[] memory);\\n    function getMinLPvalue() external view returns(uint256);\\n    function getLockingPeriodForLPMapping(address userAddress) external view returns(XIVDatabaseLib.LPLockedInfo memory);\\n    function updateLockingPeriodForLPMapping(address userAddress, uint256 _amountLocked, uint256 _lockedTimeStamp) external;\\n    function getStakingInfoMapping(address userAddress) external view returns(XIVDatabaseLib.StakingInfo[] memory);\\n    function updateStakingInfoMapping(address userAddress, XIVDatabaseLib.StakingInfo memory sInfo) external;\\n    function getInvestmentId() external view returns(uint256);\\n    function updateInvestmentId(uint256 _investmentId) external;\\n    function getSlotExecutionId() external view returns(uint256);\\n    function updateSlotExecutionId(uint256 _slotExecutionId) external;\\n    function getSlotId() external view returns(uint256);\\n    function updateSlotId(uint256 _slotId) external;\\n    function updateIncentiveMapping(uint256 _slotId, XIVDatabaseLib.IncentiveInfo memory iInfo) external;\\n    function getIncentiveMapping(uint256 _slotId) external view returns(XIVDatabaseLib.IncentiveInfo[] memory);\\n    function emitBetDetails(uint256  betId, uint256  status, uint256  betEndTime) external;\\n    function emitLPEvent(uint256 typeOfLP, address userAddress, uint256 amount, uint256 timestamp) external ;\\n    function updateIsStakeMapping(address userAddress,bool isStake) external;\\n    function getIsStakeMapping(address userAddress) external view returns(bool);\\n    \\n}\\n\"}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"adminAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOfXIV\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"typeOfBet\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"_betContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"betSlabeIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_days\",\"type\":\"uint256\"}],\"name\":\"betFlexible\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calculateIndexValueForBetActual\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calculateIndexValueForBetBase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"userBetId\",\"type\":\"uint256\"}],\"name\":\"claimBet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"databaseContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPieChartValue\",\"outputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"oracleType\",\"type\":\"uint16\"},{\"internalType\":\"string\",\"name\":\"currencySymbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"contributionPercentage\",\"type\":\"uint256\"}],\"internalType\":\"struct XIVDatabaseLib.IndexCoin[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_adminAddress\",\"type\":\"address\"}],\"name\":\"updateAdminAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_databaseContractAddress\",\"type\":\"address\"}],\"name\":\"updateDatabaseAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"XIVBettingFlexible","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"1","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://8f5b25a99580ceea26b0d4af1c76aeeb7ae7da48bce6780f3423afa766d301a5"}]}