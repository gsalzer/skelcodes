{"status":"1","message":"OK","result":[{"SourceCode":"{\"BondingCurve.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.0;\\n\\nimport { IERC20 } from \\\"./IERC20.sol\\\";\\nimport { BondingCurveFactory } from \\\"./BondingCurveFactory.sol\\\";\\n\\nlibrary AddressUtils {\\n  function isContract(address addr) internal view returns (bool) {\\n    uint256 size;\\n    // solium-disable-next-line security/no-inline-assembly\\n    assembly { size := extcodesize(addr) }\\n    return size \\u003e 0;\\n  }\\n}\\n\\nlibrary SafeMath {\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    assert(c \\u003e= a);\\n    return c;\\n  }\\n\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    assert(b \\u003c= a);\\n    return a - b;\\n  }\\n}\\n\\ninterface ICurve {\\n  function isCurve() external returns (bool);\\n}\\n\\ncontract BondingCurve is IERC20 {\\n  using AddressUtils for address;\\n  using SafeMath for uint256;\\n\\n  // keccak256(\\\"ERC20.decimals\\\")\\n  bytes32 private constant DECIMALS_SLOT = 0x9af4a8efdef7082fbe0a356fe9ce920abbe3461c19ff1888bb79ec1fbee0a564;\\n  // keccak256(\\\"curve.parameters\\\")\\n  bytes32 private constant PARAMETERS_SLOT = 0x9bb186d4e76241ac6fcfb26f9c0c67a7a4288892aa856bb2ef40fc277c0bbbe2;\\n  // keccak256(keccak256(\\\"curve.parameters\\\"))\\n  bytes32 private constant PARAMETERS_SLOT_HASH = 0x22e3a4713640ec908fad4277bc5c59c3802aee5469f8a18fa0b552bf09d2299b;\\n\\n  // bytes4(keccak256(\\\"integral(uint256,uint256)\\\")\\n  bytes4 private constant INTEGRAL_ABI = 0xc3882fef;\\n  // bytes4(keccak256(\\\"valueOf(uint256)\\\")\\n  bytes4 private constant VALUE_OF_ABI = 0xcadf338f;\\n\\n  BondingCurveFactory public factory;\\n\\n  uint256 public supplied = 0;\\n  address public founder;         // the address of the founder\\n  IERC20 public tokenToSell;      // the token to offer\\n  IERC20 public token;            // the token to receive\\n  address public curve;\\n  bool public initialized;        // if token transfer is ready\\n\\n  uint256 public start;           // start time for sale\\n  uint256 public end;             // deadline for sale. After the sale is completed, it will be set to 0 to indicate that contract has ended.\\n  bool public redeemInTime;\\n  uint256 public maximumBalance;  // the maximum number of tokens an account can hold, 0 means no limit.\\n\\n  // ERC20 params\\n\\n  uint256 public override totalSupply;\\n\\n  mapping (address =\\u003e uint256) private _balances;\\n  mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowed;\\n\\n  bool private rentrancyLock;\\n  bool public founderExit;\\n\\n  event Buy(address indexed user, uint256 amount, uint256 prict);\\n  event Sell(address indexed user, uint256 amount, uint256 prict);\\n\\n  /**\\n   * @dev Constructor for the bonding curve\\n   * @param _tokenToSell The address for the token to sell\\n   * @param _token The address for the trading token\\n   * @param _start The start time of token sale\\n   * @param _end The end time of token sale\\n   * @param _redeemInTime Whether the user can redeem immediately after the sale, instead of waiting for the end time.\\n   * @param _maximumBalance the maximum number of tokens an account can hold\\n   * @param _totalSupply The amount of to raise\\n   * @param _founder The address for the token creator founder\\n   * @param _curve curve lib\\n   * @param _params The params list for curve\\n   */\\n  constructor(IERC20 _tokenToSell, IERC20 _token, uint256 _start, uint256 _end, bool _redeemInTime, uint256 _maximumBalance, uint256 _totalSupply, address _founder, address _curve, uint256[] memory _params) {\\n    require(_founder != address(0), \\\"Founder\\u0027s address must not be address(0)\\\");\\n    require(_start \\u003c _end);\\n    require(address(_tokenToSell).isContract());\\n    require(address(_token).isContract());\\n    require(ICurve(_curve).isCurve());\\n\\n    tokenToSell = _tokenToSell;\\n    token = _token;\\n    curve = _curve;\\n    totalSupply = _totalSupply;\\n    founder = _founder;\\n\\n    end = _end;\\n    start = _start;\\n    redeemInTime = _redeemInTime;\\n    maximumBalance = _maximumBalance;\\n\\n    uint256 l = _params.length;\\n    uint256 d = _tokenToSell.decimals();\\n    assembly {\\n      sstore(PARAMETERS_SLOT, l)\\n      sstore(DECIMALS_SLOT, d)\\n    }\\n    for (uint256 i = 0; i \\u003c l; i++) {\\n      uint256 v = _params[i];\\n      assembly {\\n        sstore(add(PARAMETERS_SLOT_HASH, i), v)\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @dev Prevents a contract from calling itself, directly or indirectly.\\n   */\\n  modifier nonReentrant() {\\n    require(!rentrancyLock);\\n    rentrancyLock = true;\\n    _;\\n    rentrancyLock = false;\\n  }\\n\\n  /**\\n   * @dev Modifier for checking the token sale is ended\\n   */\\n  modifier afterEnded() {\\n    bool ended = block.timestamp \\u003e end || (redeemInTime \\u0026\\u0026 supplied \\u003e= totalSupply);\\n    require(ended, \\\"the token sale has not ended\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Modifier for checking the token sale is active\\n   */\\n  modifier active() {\\n    require(initialized, \\\"the contract has not initialized\\\");\\n    require(block.timestamp \\u003e start, \\\"the token sale hasn\\u0027t started\\\");\\n    require(block.timestamp \\u003c end, \\\"the token sale has ended\\\");\\n    require(supplied \\u003c totalSupply, \\\"the token sale has ended\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Initialize checks whether the token has received\\n   */\\n  function initialize(BondingCurveFactory _factory) external {\\n    require(tokenToSell.balanceOf(address(this)) == totalSupply, \\\"token has not received\\\");\\n    factory = _factory;\\n    initialized = true;\\n  }\\n\\n  function parameters() external view returns (uint256[] memory params) {\\n    uint256 l;\\n    assembly {\\n      l := sload(PARAMETERS_SLOT)\\n    }\\n    params = new uint256[](l);\\n    for (uint256 i = 0; i \\u003c l; i++) {\\n      uint256 v;\\n      assembly {\\n        v := sload(add(PARAMETERS_SLOT_HASH, i))\\n      }\\n      params[i] = v;\\n    }\\n  }\\n\\n  function priceNow() external view returns (uint256) {\\n    return priceAt(supplied);\\n  }\\n\\n  function costFor(uint256 amount) external view returns (uint256) {\\n    return totalPriceBetween(supplied, supplied.add(amount));\\n  }\\n\\n  function returnFor(uint256 amount) external view returns (uint256) {\\n    return totalPriceBetween(supplied.sub(amount), supplied);\\n  }\\n\\n  function priceAt(uint256 position) public view returns (uint256 price) {\\n    (bool success, bytes memory data) = address(this).staticcall(abi.encodePacked(VALUE_OF_ABI, position));\\n    require(success);\\n    require(data.length == 32);\\n    assembly {\\n      price := mload(add(data, 32))\\n    }\\n  }\\n\\n  function totalPriceBetween(uint256 left, uint256 right) public view returns (uint256 price) {\\n    (bool success, bytes memory result) = address(this).staticcall(abi.encodePacked(INTEGRAL_ABI, left, right));\\n    require(success);\\n    require(result.length == 32);\\n    assembly {\\n      price := mload(add(result, 32))\\n    }\\n  }\\n\\n  /**\\n   * @dev Buy token with bonding curve \\n   * @param amount The amount of token to mint\\n   */\\n  function buy(uint256 amount) external nonReentrant active  {\\n    uint256 newSupplied = supplied.add(amount);\\n    if (newSupplied \\u003e totalSupply) {\\n      amount = totalSupply - supplied;\\n      newSupplied = totalSupply;\\n    }\\n    uint256 totalCost = totalPriceBetween(supplied, newSupplied);\\n    _mint(msg.sender, amount);\\n    bool success = token.transferFrom(msg.sender, address(this), totalCost);\\n    require(success);\\n\\n    emit Buy(msg.sender, amount, totalCost);\\n  }\\n  \\n  /**\\n   * @dev Sell token with bonding curve \\n   * @param amount The amount of token to burn\\n   */\\n  function sell(uint256 amount) external nonReentrant active {\\n    uint256 newSupplied = supplied.sub(amount);\\n    uint256 totalReturn = totalPriceBetween(newSupplied, supplied);\\n    uint256 afterTax = 99 * totalReturn / 100;\\n    _burn(msg.sender, amount);\\n    bool success = token.transfer(msg.sender, afterTax);\\n    require(success);\\n\\n    emit Sell(msg.sender, amount, afterTax);\\n  }\\n\\n  /**\\n   * @dev Withdraw function allows the founder to withdraw all funds to their founder address\\n   */\\n  function withdrawFund() external afterEnded {\\n    uint256 tokenReceived = token.balanceOf(address(this));\\n    uint256 tax = 3 * tokenReceived / 100;\\n    bool success = token.transfer(factory.feeTo(), tax);\\n    require(success);\\n    success = token.transfer(founder, tokenReceived - tax);\\n    require(success);\\n  }\\n  /**\\n   * @dev Withdraw function allows the founder to withdraw rest to-sell-token.\\n   */\\n  function withdrawToken() external afterEnded {\\n    require(!founderExit);\\n    bool success = tokenToSell.transfer(founder, totalSupply - supplied);\\n    require(success);\\n    founderExit = true;\\n  }\\n\\n  /**\\n   * @dev The function to redeem bToken to the original token\\n   */\\n  function redeem() external afterEnded {\\n    uint256 amountToRedeem = balanceOf(msg.sender);\\n    _balances[msg.sender] = _balances[msg.sender].sub(amountToRedeem);\\n    emit Transfer(msg.sender, address(0), amountToRedeem);\\n    bool success = tokenToSell.transfer(msg.sender, amountToRedeem);\\n    require(success);\\n  }\\n\\n  // ERC20 methods\\n\\n  /**\\n   * @dev Returns the name of the token.\\n   */\\n  function name() public view override returns (string memory) {\\n    return string(abi.encodePacked(\\\"b\\\", tokenToSell.name()));\\n  }\\n\\n  /**\\n   * @dev Returns the symbol of the token, usually a shorter version of the\\n   * name.\\n   */\\n  function symbol() public view override returns (string memory) {\\n    return string(abi.encodePacked(\\\"b\\\", tokenToSell.symbol()));\\n  }\\n\\n  /**\\n   * @dev Returns the symbol of the token, usually a shorter version of the\\n   * name.\\n   */\\n  function decimals() public view override returns (uint256) {\\n    uint256 d;\\n    assembly {\\n      d := sload(DECIMALS_SLOT)\\n    }\\n    return d;\\n  }\\n\\n  function balanceOf(address account) public view override returns (uint256) {\\n    return _balances[account];\\n  }\\n\\n  function transfer(address recipient, uint256 amount) public override returns (bool) {\\n    require(msg.sender != recipient, \\\"Cannot transfer to own account\\\");\\n    _balances[msg.sender] = _balances[msg.sender].sub(amount);\\n    _balances[recipient] = _balances[recipient].add(amount);\\n    require(maximumBalance == 0 || _balances[recipient] \\u003c= maximumBalance);\\n    emit Transfer(msg.sender, recipient, amount);\\n    return true;\\n  }\\n\\n  function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\\n    require(sender != recipient, \\\"Cannot transfer to own account\\\");\\n    _balances[sender] = _balances[sender].sub(amount);\\n    _allowed[sender][msg.sender] = _allowed[sender][msg.sender].sub(amount);\\n    _balances[recipient] = _balances[recipient].add(amount);\\n    require(maximumBalance == 0 || _balances[recipient] \\u003c= maximumBalance);\\n    emit Transfer(sender, recipient, amount);\\n    return true;\\n  }\\n\\n  function approve(address spender, uint256 amount) public override returns (bool) {\\n    require(_allowed[msg.sender][spender] == 0 || amount == 0);\\n    _allowed[msg.sender][spender] = amount;\\n    emit Approval(msg.sender, spender, amount);\\n    return true;\\n  }\\n\\n  function allowance(address owner, address spender) public view override returns (uint256) {\\n    return _allowed[owner][spender];\\n  }\\n\\n  function _mint(address account, uint256 amount) internal virtual {\\n    require (account != address(0));\\n    supplied = supplied.add(amount);\\n    _balances[account] = _balances[account].add(amount);\\n    require(maximumBalance == 0 || _balances[account] \\u003c= maximumBalance);\\n    emit Transfer(address(0), account, amount);\\n  }\\n\\n  function _burn(address account, uint256 amount) internal virtual {\\n    require (account != address(0));\\n    _balances[account] = _balances[account].sub(amount);\\n    supplied = supplied.sub(amount);\\n    emit Transfer(account, address(0), amount);\\n  }\\n\\n  fallback() external {\\n    require(msg.sender == address(this));\\n\\n    (bool success, bytes memory data) = curve.delegatecall(msg.data);\\n    assembly {\\n      switch success\\n        case 0 { revert(add(data, 32), returndatasize()) }\\n        default { return(add(data, 32), returndatasize()) }\\n    }\\n  }\\n}\\n\"},\"BondingCurveFactory.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.0;\\n\\nimport { BondingCurve } from \\\"./BondingCurve.sol\\\";\\nimport { IERC20 } from \\\"./IERC20.sol\\\";\\n\\ncontract BondingCurveFactory {\\n  address public feeTo;\\n  BondingCurve[] public allBondingToken;\\n\\n  /**\\n   * @dev Constructor for the factory contract\\n   * @param _feeTo The receiving address for fees that is generated from withdraw\\n   */\\n  constructor(address _feeTo) {\\n    require(_feeTo != address(0), \\\"Address must not be address(0)\\\");\\n    feeTo = _feeTo;\\n  }\\n\\n  function bondingTokenCount() public view returns (uint256) {\\n    return allBondingToken.length;\\n  }\\n\\n  /**\\n   * @dev Create new bonding curve token\\n   * @param _tokenToSell The address for the token to sell\\n   * @param _token The address for the trading token\\n   * @param _start The start time of token sale\\n   * @param _end The end time of token sale\\n   * @param _redeemInTime Whether the user can redeem immediately after the sale, instead of waiting for the end time.\\n   * @param _maximumBalance the maximum number of tokens an account can hold\\n   * @param _cap The amount of to raise \\n   * @param _team The address for the token creator team\\n   * @param _curve curve lib\\n   * @param _params The params list for curve\\n   */\\n  function createBondingCurveToken(IERC20 _tokenToSell, IERC20 _token, uint256 _start, uint256 _end, bool _redeemInTime, uint256 _maximumBalance, uint256 _cap, address _team, address _curve, uint256[] memory _params) external {\\n    BondingCurve newBondingCurve = new BondingCurve(_tokenToSell, _token, _start, _end, _redeemInTime, _maximumBalance, _cap, _team, _curve, _params);\\n    bool success = _tokenToSell.transferFrom(msg.sender, address(newBondingCurve), _cap);\\n    require(success, \\\"Transfer failed\\\");\\n    newBondingCurve.initialize(this);\\n    allBondingToken.push(newBondingCurve);\\n  }\\n}\\n\\n// 3570785\\n\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view  returns (string memory);\\n\\n    function decimals() external view  returns (uint256);\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() external view  returns (string memory);\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeTo\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allBondingToken\",\"outputs\":[{\"internalType\":\"contract BondingCurve\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bondingTokenCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_tokenToSell\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_end\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_redeemInTime\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_maximumBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_cap\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_team\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_curve\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_params\",\"type\":\"uint256[]\"}],\"name\":\"createBondingCurveToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeTo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"BondingCurveFactory","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000007614ebee52f4733e0ed864429d41516af28560a6","EVMVersion":"Default","Library":"","LicenseType":"Unlicense","Proxy":"0","Implementation":"","SwarmSource":"ipfs://baeb6553cc89af4e138abebfeea2374ff1c8d4728a7caa3c1ee3bc69eea4b8ce"}]}