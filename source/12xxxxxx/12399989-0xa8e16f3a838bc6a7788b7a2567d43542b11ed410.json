{"status":"1","message":"OK","result":[{"SourceCode":"{\"sale.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./token.sol\\\";\\n\\ncontract TokenSale {\\n    address payable admin;\\n    Token public tokenContract;\\n\\n\\n    constructor(Token _tokenContract) public {\\n        admin = msg.sender;\\n        tokenContract = _tokenContract;\\n    }\\n\\n    function buyTokens(uint256 _numberOfTokens) public payable{\\n        \\n        require(\\n            _numberOfTokens == msg.value / 10**14,\\n            \\\"Number of tokens does not match with the value\\\"\\n        );\\n        \\n\\n        require(\\n            tokenContract.balanceOf(address(this)) \\u003e= _numberOfTokens,\\n            \\\"Contact does not have enough tokens\\\"\\n        );\\n        require(\\n            tokenContract.transfer(msg.sender, _numberOfTokens),\\n            \\\"Some problem with token transfer\\\"\\n        );\\n    }\\n\\n    function endSale() public {\\n        require(msg.sender == admin, \\\"Only the admin can call this function\\\");\\n        require(\\n            tokenContract.transfer(\\n                address(0),\\n                tokenContract.balanceOf(address(this))\\n            ),\\n            \\\"Unable to transfer tokens to 0x0000\\\"\\n        );\\n        selfdestruct(admin);\\n    }\\n    \\n    function expenses(uint256 _expenses) public {\\n        require(msg.sender == admin, \\\"Only the admin can call this function\\\");\\n        msg.sender.transfer(_expenses);\\n    }\\n    \\n    function()payable external{}\\n}\"},\"token.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\ncontract Token {\\n    string public name = \\\"Cha Token\\\"; \\n    string public symbol = \\\"CHA\\\"; \\n    uint256 public totalSupply;\\n\\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\\n\\n    event Approval(\\n        address indexed _owner,\\n        address indexed _spender,\\n        uint256 _value\\n    );\\n\\n    mapping(address =\\u003e uint256) public balanceOf;\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) public allowance;\\n\\n    constructor(uint256 _initialSupply) public {\\n        balanceOf[msg.sender] = _initialSupply;\\n        totalSupply = _initialSupply;\\n    }\\n\\n    function transfer(address _to, uint256 _value)\\n        public\\n        returns (bool success)\\n    {\\n        require(balanceOf[msg.sender] \\u003e= _value, \\\"Not enough balance\\\");\\n        balanceOf[msg.sender] -= _value;\\n        balanceOf[_to] += _value;\\n        emit Transfer(msg.sender, _to, _value);\\n        return true;\\n    }\\n\\n    function approve(address _spender, uint256 _value)\\n        public\\n        returns (bool success)\\n    {\\n        allowance[msg.sender][_spender] = _value;\\n        emit Approval(msg.sender, _spender, _value);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    ) public returns (bool success) {\\n        require(\\n            balanceOf[_from] \\u003e= _value,\\n            \\\"_from does not have enough tokens\\\"\\n        );\\n        require(\\n            allowance[_from][msg.sender] \\u003e= _value,\\n            \\\"Spender limit exceeded\\\"\\n        );\\n        balanceOf[_from] -= _value;\\n        balanceOf[_to] += _value;\\n        allowance[_from][msg.sender] -= _value;\\n        emit Transfer(_from, _to, _value);\\n        return true;\\n    }\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract Token\",\"name\":\"_tokenContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_numberOfTokens\",\"type\":\"uint256\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_expenses\",\"type\":\"uint256\"}],\"name\":\"expenses\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenContract\",\"outputs\":[{\"internalType\":\"contract Token\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"TokenSale","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000fc07d3e0fd60e2ab9ad87618da70d25a2506589f","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://90c5ef88894d37766b8ab6a690ee839138102608ca5c696afacaeca6f5a7515a"}]}