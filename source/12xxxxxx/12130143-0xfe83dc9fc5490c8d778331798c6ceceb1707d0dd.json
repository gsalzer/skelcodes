{"status":"1","message":"OK","result":[{"SourceCode":"\"\"\"\r\n@title Greenwood Treasury\r\n@notice Treasury contract for the Greenwood Protocol\r\n@author Greenwood Labs\r\n\"\"\"\r\n\r\n# define the interfaces used by the contract\r\ninterface REGISTRY:\r\n    def getAddress(_contract: String[20], _version: String[11], ) -> address: nonpayable\r\n    def governance() -> address: nonpayable\r\n\r\n# define the events emitted by the contract\r\nevent Fallback:\r\n    value: uint256\r\n    sender: address\r\n    blockNumber: uint256\r\n    \r\nevent SetRegistry:\r\n    previousRegistry: address\r\n    newRegistry: address\r\n    governance: address\r\n    blockNumber: uint256\r\n\r\nevent TransferERC20:\r\n    amount: uint256\r\n    asset: address\r\n    governance: address\r\n    blockNumber: uint256\r\n\r\nevent TransferETH:\r\n    value: uint256\r\n    governance: address\r\n    blockNumber: uint256\r\n\r\n# define the storage variables used by the contract\r\nregistry: public(address)\r\n\r\n@external\r\ndef __init__(_registry: address):\r\n    \"\"\"\r\n    @notice Contract constructor\r\n    @param _registry The address of the Greenwood Registry\r\n    \"\"\"\r\n\r\n    # set the address of the Escrow\r\n    self.registry = _registry\r\n\r\n@internal\r\ndef isGovernance(_caller: address, _role: String[20]) -> bool:\r\n    \"\"\"\r\n    @notice Method for role-based security\r\n    @param _caller The address that called the permissioned method\r\n    @param _role The requested authorization level\r\n    @return True if the caller is the Governance, False otherwise\r\n    \"\"\"\r\n\r\n    # check if the requested role is \"governance\"\r\n    if keccak256(_role) == keccak256(\"governance\"):\r\n\r\n        # get the address of the Governance from the Registry\r\n        governance: address = REGISTRY(self.registry).governance()\r\n\r\n        # return the equality comparison\r\n        return governance == _caller\r\n\r\n    # catch extraneous role arguments\r\n    else:\r\n\r\n        # revert\r\n        raise \"Unhandled role argument\"\r\n\r\n@external\r\n@nonreentrant(\"erc20_lock\")\r\ndef transferERC20(_amount: uint256, _asset: address):\r\n    \"\"\"\r\n    @notice Transfers ERC20 tokens to the Governance\r\n    @param _amount The amount of asset to transfer scaled by the asset's decimals\r\n    @param _asset The underlying address of the asset to transfer\r\n    \"\"\"\r\n\r\n    # require that the method caller is the Governance\r\n    assert self.isGovernance(msg.sender, \"governance\") == True, \"Only Governance can call this method\"\r\n\r\n    # get the address of the Governance from the Registry\r\n    to: address = REGISTRY(self.registry).governance()\r\n\r\n    # require that the Governance is not the zero address\r\n    assert to != ZERO_ADDRESS\r\n\r\n    # transfer collected fees to the Governance\r\n    transferResponse: Bytes[32] = raw_call(\r\n        _asset,\r\n        concat(\r\n            method_id(\"transfer(address,uint256)\"),\r\n            convert(to, bytes32),\r\n            convert(_amount, bytes32),\r\n        ),\r\n        max_outsize=32,\r\n    )\r\n    if len(transferResponse) > 0:\r\n        assert convert(transferResponse, bool), \"Failed safeTransfer\"\r\n\r\n    # emit a TransferERC20 event\r\n    log TransferERC20(_amount, _asset, to, block.number)\r\n\r\n    \r\n@external\r\n@nonreentrant(\"eth_lock\")\r\ndef transferETH(_amount: uint256):\r\n    \"\"\"\r\n    @notice Transfers ETH to the Governance\r\n    @param _amount The amount of ETH to transfer in wei\r\n    \"\"\"\r\n\r\n    # require that the method caller is the Governance\r\n    assert self.isGovernance(msg.sender, \"governance\") == True, \"Only Governance can call this method\"\r\n\r\n    # get the address of the Governance from the Registry\r\n    to: address = REGISTRY(self.registry).governance()\r\n\r\n    # require that the Governance is not the zero address\r\n    assert to != ZERO_ADDRESS\r\n\r\n    # send fees collected in ETH to the governance\r\n    send(to, _amount)\r\n\r\n    # emit a TransferETH event\r\n    log TransferETH(_amount, to, block.number)\r\n\r\n@external\r\n@nonreentrant(\"registry_lock\")\r\ndef setRegistry(_new_registry: address):\r\n    \"\"\"\r\n    @notice Updates the address of the Registry\r\n    @param _new_registry The address of the new Greenwood Registry\r\n    @dev Only the Governance can call this method\r\n    @dev Only call this method with a valid Greenwood Registry or subsequent calls will fail!\r\n    \"\"\"\r\n\r\n    # require that the method caller is the Governance\r\n    assert self.isGovernance(msg.sender, \"governance\") == True, \"Only Governance can call this method\"\r\n\r\n    # get the previous Registry\r\n    previousRegistry: address = self.registry\r\n\r\n    # update the address of the Registry\r\n    self.registry = _new_registry\r\n\r\n    # emit a SetRegistry event\r\n    log SetRegistry(previousRegistry, _new_registry, msg.sender, block.number)\r\n\r\n@external\r\n@payable\r\ndef __default__():\r\n    \"\"\"\r\n    @notice Fallback function for receiving ETH\r\n    \"\"\"\r\n\r\n    log Fallback(msg.value, msg.sender, block.number)","ABI":"[{\"name\":\"Fallback\",\"inputs\":[{\"type\":\"uint256\",\"name\":\"value\",\"indexed\":false},{\"type\":\"address\",\"name\":\"sender\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"blockNumber\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetRegistry\",\"inputs\":[{\"type\":\"address\",\"name\":\"previousRegistry\",\"indexed\":false},{\"type\":\"address\",\"name\":\"newRegistry\",\"indexed\":false},{\"type\":\"address\",\"name\":\"governance\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"blockNumber\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"TransferERC20\",\"inputs\":[{\"type\":\"uint256\",\"name\":\"amount\",\"indexed\":false},{\"type\":\"address\",\"name\":\"asset\",\"indexed\":false},{\"type\":\"address\",\"name\":\"governance\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"blockNumber\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"TransferETH\",\"inputs\":[{\"type\":\"uint256\",\"name\":\"value\",\"indexed\":false},{\"type\":\"address\",\"name\":\"governance\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"blockNumber\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_registry\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"name\":\"transferERC20\",\"outputs\":[],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_amount\"},{\"type\":\"address\",\"name\":\"_asset\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":69535},{\"name\":\"transferETH\",\"outputs\":[],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_amount\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":99635},{\"name\":\"setRegistry\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_new_registry\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":99404},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"name\":\"registry\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1271}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.3","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"0000000000000000000000001ddbb7a21905c6a8dbd76b20b7c6b3a55d1af24f","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":""}]}