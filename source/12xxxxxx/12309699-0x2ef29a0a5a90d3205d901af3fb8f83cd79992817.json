{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/app/contracts/GovernorPACT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./vendors/contracts/AbstractGovernor.sol\\\";\\nimport \\\"./vendors/contracts/access/GovernanceOwnable.sol\\\";\\nimport \\\"./vendors/libraries/SafeMath.sol\\\";\\n\\ncontract GovernorPACT is AbstractGovernor, GovernanceOwnable {\\n    enum VotingSettingsKeys {\\n        DefaultPropose,\\n        FastPropose,\\n        MultiExecutable\\n    }\\n\\n    // etherium - block_generation_frequency_ ~ 15s\\n    // binance smart chain - block_generation_frequency_ ~ 4s\\n    constructor(\\n        address pact_,\\n        uint256 block_generation_frequency_\\n    ) AbstractGovernor(\\\"Governor PACT\\\", pact_) GovernanceOwnable(address(this)) public {\\n        _addAllowedTarget(address(this));\\n        _addAllowedTarget(pact_);\\n\\n        _setVotingSettings(\\n            uint(VotingSettingsKeys.DefaultPropose), // votingSettingsId\\n            SafeMath.div(3 days, block_generation_frequency_),// votingPeriod\\n            SafeMath.div(15 days, block_generation_frequency_),// expirationPeriod\\n            10,// proposalMaxOperations\\n            25,// quorumVotesDelimiter 4% of total PACTs\\n            100// proposalThresholdDelimiter 1% of total PACTs\\n        );\\n        _setVotingSettings(\\n            uint(VotingSettingsKeys.FastPropose), // votingSettingsId\\n            SafeMath.div(1 hours, block_generation_frequency_),// votingPeriod\\n            SafeMath.div(2 hours, block_generation_frequency_),// expirationPeriod\\n            40,// proposalMaxOperations\\n            5,// quorumVotesDelimiter 20% of total PACTs\\n            20// proposalThresholdDelimiter 5% of total PACTs\\n        );\\n        _setVotingSettings(\\n            uint(VotingSettingsKeys.MultiExecutable), // votingSettingsId\\n            SafeMath.div(1 hours, block_generation_frequency_),// votingPeriod\\n            SafeMath.div(365 days, block_generation_frequency_),// expirationPeriod\\n            2,// proposalMaxOperations\\n            5,// quorumVotesDelimiter 20% of total PACTs\\n            20// proposalThresholdDelimiter 5% of total PACTs\\n        );\\n    }\\n\\n    function createDefaultPropose(\\n        address[] memory targets,\\n        uint[] memory values,\\n        string[] memory signatures,\\n        bytes[] memory calldatas,\\n        string memory description\\n    ) public returns (uint) {\\n        for (uint i = 0; i < targets.length; i++) {\\n            require(allowedTargets[targets[i]], \\\"GovernorPACT::createFastPropose: targets - supports only allowedTargets\\\");\\n        }\\n        return _propose(\\n            uint(VotingSettingsKeys.DefaultPropose),\\n            targets,\\n            values,\\n            signatures,\\n            calldatas,\\n            description,\\n            false\\n        );\\n    }\\n\\n    function createFastPropose(\\n        address[] memory targets,\\n        uint[] memory values,\\n        string[] memory signatures,\\n        bytes[] memory calldatas,\\n        string memory description\\n    ) public returns (uint) {\\n        for (uint i = 0; i < targets.length; i++) {\\n            require(allowedTargets[targets[i]], \\\"GovernorPACT::createFastPropose: targets - supports only allowedTargets\\\");\\n        }\\n        return _propose(\\n            uint(VotingSettingsKeys.FastPropose),\\n            targets,\\n            values,\\n            signatures,\\n            calldatas,\\n            description,\\n            false\\n        );\\n    }\\n\\n    function createMultiExecutablePropose(\\n        address[] memory targets,\\n        uint[] memory values,\\n        string[] memory signatures,\\n        bytes[] memory calldatas,\\n        string memory description\\n    ) public returns (uint) {\\n        for (uint i = 0; i < targets.length; i++) {\\n            require(allowedTargets[targets[i]], \\\"GovernorPACT::createMultiExecutablePropose: targets - supports only allowedTargets\\\");\\n        }\\n        return _propose(\\n            uint(VotingSettingsKeys.MultiExecutable),\\n            targets,\\n            values,\\n            signatures,\\n            calldatas,\\n            description,\\n            true\\n        );\\n    }\\n\\n    address[] internal allowedTargetsList;\\n    mapping (address => bool) public allowedTargets;\\n\\n    function addAllowedTarget(address target) public onlyGovernance {\\n        _addAllowedTarget(target);\\n    }\\n    function _addAllowedTarget(address target) internal {\\n        if (allowedTargets[target] == false) {\\n            allowedTargets[target] = true;\\n            allowedTargetsList.push(target);\\n        }\\n    }\\n\\n    function getAllowedTargets() public view returns(address[] memory) {\\n        return allowedTargetsList;\\n    }\\n\\n}\"\r\n    },\r\n    \"/app/contracts/vendors/contracts/AbstractGovernor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../interfaces/IDelegableERC20.sol\\\";\\nimport \\\"./utils/Context.sol\\\";\\n\\nimport \\\"../libraries/SafeMath.sol\\\";\\n\\n// Copied and modified from Compound code:\\n// https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/GovernorAlpha.sol\\nabstract contract AbstractGovernor is Context {\\n    using SafeMath for uint256;\\n\\n    string _name;\\n    IDelegableERC20 public _token;\\n\\n    constructor(\\n        string memory name_,\\n        address token_\\n    ) public {\\n        _name = name_;\\n        _token = IDelegableERC20(token_);\\n    }\\n\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /// @notice all VotingSettings\\n    mapping (uint => VotingSettings) public _votingSettings;\\n\\n    /// @notice votingPeriod - The duration of voting on a proposal, in blocks\\n    /// @notice expirationPeriod - The duration of execution on a proposal after voting, in blocks\\n    /// @notice proposalMaxOperations - The maximum number of actions that can be included in a proposal\\n    /// @notice quorumVotesDelimiter - Number for calculate count of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\\n    /// @notice proposalThresholdDelimiter - Number for calculate count of votes required in order for a voter to become a proposer\\n    struct VotingSettings {\\n        bool isValue;\\n        uint256 votingPeriod;\\n        uint256 expirationPeriod;\\n        uint256 proposalMaxOperations;\\n        uint256 quorumVotesDelimiter;\\n        uint256 proposalThresholdDelimiter;\\n    }\\n\\n    /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\\n    function quorumVotes(uint256 votingSettingsId) public view returns (uint) {\\n        VotingSettings storage votingSettings = _votingSettings[votingSettingsId];\\n        require(votingSettings.isValue, \\\"Governor::quorumVotes: incorrect votingSettingsId\\\");\\n        return _token.totalSupply() / votingSettings.quorumVotesDelimiter;\\n    }\\n\\n    /// @notice The number of votes required in order for a voter to become a proposer\\n    function proposalThreshold(uint256 votingSettingsId) public view returns (uint) {\\n        VotingSettings storage votingSettings = _votingSettings[votingSettingsId];\\n        require(votingSettings.isValue, \\\"Governor::proposalThreshold: incorrect votingSettingsId\\\");\\n        return _token.totalSupply() / votingSettings.proposalThresholdDelimiter;\\n    }\\n\\n    /// @notice The delay before voting on a proposal may take place, once proposed\\n    function _setVotingSettings(\\n        uint256 votingSettingsId,\\n        uint256 votingPeriod,\\n        uint256 expirationPeriod,\\n        uint256 proposalMaxOperations,\\n        uint256 quorumVotesDelimiter,\\n        uint256 proposalThresholdDelimiter\\n    ) internal {\\n        VotingSettings storage votingSettings = _votingSettings[votingSettingsId];\\n        require(votingSettings.isValue == false, \\\"Governor::setVotingSettings: incorrect votingSettingsId\\\");\\n\\n        require(votingPeriod > 0, \\\"Governor::setVotingSettings: shoud be more then 0\\\");\\n        require(expirationPeriod > 0, \\\"Governor::setVotingSettings: shoud be more then 0\\\");\\n        require(proposalMaxOperations > 0, \\\"Governor::setVotingSettings: shoud be more then 0\\\");\\n        require(quorumVotesDelimiter > 0, \\\"Governor::setVotingSettings: shoud be more then 0\\\");\\n        require(proposalThresholdDelimiter > 0, \\\"Governor::setVotingSettings: shoud be more then 0\\\");\\n\\n        VotingSettings memory newVotingSettings = VotingSettings({\\n            isValue: true,\\n            votingPeriod: votingPeriod,\\n            expirationPeriod: expirationPeriod,\\n            proposalMaxOperations: proposalMaxOperations,\\n            quorumVotesDelimiter: quorumVotesDelimiter,\\n            proposalThresholdDelimiter: proposalThresholdDelimiter\\n        });\\n\\n        _votingSettings[votingSettingsId] = newVotingSettings;\\n    }\\n\\n    function getVotingSettings(uint256 votingSettingsId) public view returns (VotingSettings memory) {\\n        return _votingSettings[votingSettingsId];\\n    }\\n\\n    /// @notice The total number of proposals\\n    uint public _proposalCount;\\n\\n    /// @notice id -  Unique id for looking up a proposal\\n    /// @notice proposer -  Creator of the proposal\\n    /// @notice targets -  the ordered list of target addresses for calls to be made\\n    /// @notice values -  The ordered list of values (i.e. msg.value) to be passed to the calls to be made\\n    /// @notice signatures -  The ordered list of function signatures to be called\\n    /// @notice calldatas -  The ordered list of calldata to be passed to each call\\n    /// @notice startBlock -  The block at which voting begins: holders must delegate their votes prior to this block\\n    /// @notice endBlock -  The block at which voting ends: votes must be cast prior to this block\\n    /// @notice expiredBlock -  The block at which successful, but not executed transactions is expired\\n    /// @notice forVotes -  Current number of votes in favor of this proposal\\n    /// @notice againstVotes -  Current number of votes in opposition to this proposal\\n    /// @notice canceled -  Flag marking whether the proposal has been canceled\\n    /// @notice executed -  Flag marking whether the proposal has been executed\\n    /// @notice receipts -  Receipts of ballots for the entire set of voters\\n    struct Proposal {\\n        uint256 votingSettingsId;\\n        uint id;\\n        address proposer;\\n        address[] targets;\\n        uint[] values;\\n        string[] signatures;\\n        bytes[] calldatas;\\n        uint startBlock;\\n        uint endBlock;\\n        uint expiredBlock;\\n        uint forVotes;\\n        uint againstVotes;\\n        bool canceled;\\n        bool executed;\\n        mapping (address => Receipt) receipts;\\n        bool isMultiExecutable;\\n    }\\n\\n    /// @notice Ballot receipt record for a voter\\n    /// @notice hasVoted - Whether or not a vote has been cast\\n    /// @notice support - Whether or not the voter supports the proposal\\n    /// @notice votes - The number of votes the voter had, which were cast\\n    struct Receipt {\\n        bool hasVoted;\\n        bool support;\\n        uint256 votes;\\n    }\\n\\n    /// @notice Possible states that a proposal may be in\\n    enum ProposalState {\\n        Active,\\n        Canceled,\\n        Defeated,\\n        Succeeded,\\n        Expired,\\n        Executed\\n    }\\n\\n    /// @notice The official record of all proposals ever proposed\\n    mapping (uint => Proposal) public _proposals;\\n    /// @notice The official records of all proposals executions\\n    mapping (uint => uint[]) public _proposalsExecutionBlocks;\\n    /// @notice The latest proposal for each proposer\\n    mapping (address => uint) public _latestProposalIds;\\n\\n    /// @notice The EIP-712 typehash for the contract's domain\\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\");\\n\\n    /// @notice The EIP-712 typehash for the ballot struct used by the contract\\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\\\"Ballot(uint256 proposalId,bool support)\\\");\\n\\n    /// @notice An event emitted when a new proposal is created\\n    event ProposalCreated(uint id, address proposer, address[] targets, uint[] values, string[] signatures, bytes[] calldatas, uint startBlock, uint endBlock, string description);\\n\\n    /// @notice An event emitted when a vote has been cast on a proposal\\n    event VoteCast(address voter, uint proposalId, bool support, uint votes);\\n\\n    /// @notice An event emitted when a proposal has been canceled\\n    event ProposalCanceled(uint id);\\n\\n    /// @notice An event emitted when a proposal has been executed\\n    event ProposalExecuted(uint id);\\n\\n    /// @notice An event emitted when a some proposals transaction has been executed\\n    event ExecuteTransaction(address indexed target, uint value, string signature, bytes data);\\n\\n    /// @notice The delay before voting on a proposal may take place, once proposed\\n    function _propose(\\n        uint256 votingSettingsId,\\n        address[] memory targets,\\n        uint[] memory values,\\n        string[] memory signatures,\\n        bytes[] memory calldatas,\\n        string memory description,\\n        bool isMultiExecutable\\n    ) internal returns (uint) {\\n        VotingSettings storage votingSettings = _votingSettings[votingSettingsId];\\n        require(votingSettings.isValue, \\\"Governor::propose: incorrect votingSettingsId\\\");\\n\\n        require(\\n            _token.getPriorVotes(\\n                _msgSender(),\\n                block.number.sub(1, \\\"Governor::propose: block.number - Underflow\\\")\\n            ) > proposalThreshold(votingSettingsId),\\n            \\\"Governor::propose: proposer votes below proposal threshold\\\"\\n        );\\n        require(\\n            targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length,\\n            \\\"Governor::propose: proposal function information arity mismatch\\\"\\n        );\\n        require(\\n            targets.length != 0,\\n            \\\"Governor::propose: must provide actions\\\"\\n        );\\n        require(\\n            targets.length <= votingSettings.proposalMaxOperations,\\n            \\\"Governor::propose: too many actions\\\"\\n        );\\n\\n        uint startBlock = block.number;\\n        uint endBlock = startBlock.add(votingSettings.votingPeriod, \\\"Governor::propose: endBlock - Add Overflow\\\");\\n\\n        _proposalCount++;\\n        Proposal memory newProposal = Proposal({\\n            votingSettingsId: votingSettingsId,\\n            id: _proposalCount,\\n            proposer: _msgSender(),\\n            targets: targets,\\n            values: values,\\n            signatures: signatures,\\n            calldatas: calldatas,\\n            startBlock: startBlock,\\n            endBlock: endBlock,\\n            expiredBlock: endBlock.add(votingSettings.expirationPeriod, \\\"Governor::propose: expiredBlock - Add Overflow\\\"),\\n            //forVotes: _token.getPriorVotes(_msgSender(), 0),\\n            forVotes: 0,\\n            againstVotes: 0,\\n            canceled: false,\\n            executed: false,\\n            isMultiExecutable: isMultiExecutable\\n        });\\n\\n        _proposals[newProposal.id] = newProposal;\\n        _latestProposalIds[newProposal.proposer] = newProposal.id;\\n        _castVote(newProposal.proposer, newProposal.id, true);\\n\\n        emit ProposalCreated(newProposal.id, _msgSender(), targets, values, signatures, calldatas, startBlock, endBlock, description);\\n        return newProposal.id;\\n    }\\n\\n    function execute(uint proposalId) public payable {\\n        require(\\n            state(proposalId) == ProposalState.Succeeded,\\n            \\\"Governor::execute: proposal can only be executed if it is Succeeded\\\"\\n        );\\n        Proposal storage proposal = _proposals[proposalId];\\n        _proposalsExecutionBlocks[proposalId].push(block.number);\\n        if (!proposal.isMultiExecutable) {\\n            proposal.executed = true;\\n        }\\n\\n        for (uint i = 0; i < proposal.targets.length; i++) {\\n            _executeTransaction(\\n                proposal.targets[i],\\n                proposal.values[i],\\n                proposal.signatures[i],\\n                proposal.calldatas[i]\\n            );\\n        }\\n        emit ProposalExecuted(proposalId);\\n    }\\n\\n    function _executeTransaction(\\n        address target,\\n        uint value,\\n        string memory signature,\\n        bytes memory data\\n    ) internal returns (\\n        bytes memory\\n    ) {\\n        bytes memory callData;\\n        if (bytes(signature).length == 0) {\\n            callData = data;\\n        } else {\\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\\n        }\\n\\n        // solium-disable-next-line security/no-call-value\\n        (bool success, bytes memory returnData) = target.call{value: value}(callData);\\n        require(success, \\\"Governor::_executeTransaction: Transaction execution reverted.\\\");\\n\\n        emit ExecuteTransaction(target, value, signature, data);\\n\\n        return returnData;\\n    }\\n\\n    function cancel(uint proposalId) public {\\n        ProposalState state = state(proposalId);\\n        require(state != ProposalState.Executed, \\\"Governor::cancel: cannot cancel executed proposal\\\");\\n\\n        Proposal storage proposal = _proposals[proposalId];\\n\\n        require(\\n            _token.getPriorVotes(\\n                proposal.proposer,\\n                block.number.sub(1, \\\"Governor::cancel: block.number - Underflow\\\")\\n            ) < proposalThreshold(proposal.votingSettingsId),\\n            \\\"Governor::cancel: proposer above threshold\\\"\\n        );\\n\\n        proposal.canceled = true;\\n\\n        emit ProposalCanceled(proposalId);\\n    }\\n\\n    function getActions(\\n        uint proposalId\\n    ) public view returns (\\n        address[] memory targets,\\n        uint[] memory values,\\n        string[] memory signatures,\\n        bytes[] memory calldatas\\n    ) {\\n        Proposal storage p = _proposals[proposalId];\\n        return (p.targets, p.values, p.signatures, p.calldatas);\\n    }\\n\\n    function getReceipt(uint proposalId, address voter) public view returns (Receipt memory) {\\n        return _proposals[proposalId].receipts[voter];\\n    }\\n\\n    function state(uint proposalId) public view returns (ProposalState) {\\n        require(\\n            _proposalCount >= proposalId && proposalId > 0,\\n            \\\"Governor::state: invalid proposal id\\\"\\n        );\\n        Proposal storage proposal = _proposals[proposalId];\\n\\n        if (proposal.canceled) {\\n            return ProposalState.Canceled;\\n        } else if (proposal.executed) {\\n            return ProposalState.Executed;\\n        } else if (block.number <= proposal.endBlock) {\\n            return ProposalState.Active;\\n        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes(proposal.votingSettingsId)) {\\n            return ProposalState.Defeated;\\n        } else if (block.number < proposal.expiredBlock) {\\n            return ProposalState.Succeeded;\\n        } else {\\n            return ProposalState.Expired;\\n        }\\n    }\\n\\n    function castVote(uint proposalId, bool support) public {\\n        return _castVote(_msgSender(), proposalId, support);\\n    }\\n\\n    function castVoteBySig(uint proposalId, bool support, uint8 v, bytes32 r, bytes32 s) public {\\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(_name)), getChainId(), address(this)));\\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\\n        bytes32 digest = keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n        address signatory = ecrecover(digest, v, r, s);\\n        require(signatory != address(0), \\\"Governor::castVoteBySig: invalid signature\\\");\\n        return _castVote(signatory, proposalId, support);\\n    }\\n\\n    function _castVote(address voter, uint proposalId, bool support) internal {\\n        require(state(proposalId) == ProposalState.Active, \\\"Governor::_castVote: voting is closed\\\");\\n        Proposal storage proposal = _proposals[proposalId];\\n        Receipt storage receipt = proposal.receipts[voter];\\n        require(receipt.hasVoted == false, \\\"Governor::_castVote: voter already voted\\\");\\n        uint256 votes = _token.getPriorVotes(voter, proposal.startBlock);\\n\\n        if (support) {\\n            proposal.forVotes = proposal.forVotes.add(votes, \\\"Governor::_castVote: votes - Add Overflow\\\");\\n        } else {\\n            proposal.againstVotes = proposal.againstVotes.add(votes, \\\"Governor::_castVote: votes - Add Overflow\\\");\\n        }\\n\\n        receipt.hasVoted = true;\\n        receipt.support = support;\\n        receipt.votes = votes;\\n\\n        emit VoteCast(voter, proposalId, support, votes);\\n    }\\n\\n    function getChainId() internal pure returns (uint) {\\n        uint chainId;\\n        assembly { chainId := chainid() }\\n        return chainId;\\n    }\\n}\"\r\n    },\r\n    \"/app/contracts/vendors/contracts/access/GovernanceOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\nimport \\\"../../interfaces/IGovernanceOwnable.sol\\\";\\n\\nabstract contract GovernanceOwnable is IGovernanceOwnable {\\n    address private _governanceAddress;\\n\\n    event GovernanceSetTransferred(address indexed previousGovernance, address indexed newGovernance);\\n\\n    constructor (address governance_) public {\\n        require(governance_ != address(0), \\\"Governance address should be not null\\\");\\n        _governanceAddress = governance_;\\n        emit GovernanceSetTransferred(address(0), governance_);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current governanceAddress.\\n     */\\n    function governance() public view override returns (address) {\\n        return _governanceAddress;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the governanceAddress.\\n     */\\n    modifier onlyGovernance() {\\n        require(_governanceAddress == msg.sender, \\\"Governance: caller is not the governance\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev SetGovernance of the contract to a new account (`newGovernance`).\\n     * Can only be called by the current onlyGovernance.\\n     */\\n    function setGovernance(address newGovernance) public virtual override onlyGovernance {\\n        require(newGovernance != address(0), \\\"GovernanceOwnable: new governance is the zero address\\\");\\n        emit GovernanceSetTransferred(_governanceAddress, newGovernance);\\n        _governanceAddress = newGovernance;\\n    }\\n\\n}\"\r\n    },\r\n    \"/app/contracts/vendors/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\n// Copied from OpenZeppelin code:\\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Context.sol\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\"\r\n    },\r\n    \"/app/contracts/vendors/interfaces/IDelegable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.6.12;\\r\\n\\r\\ninterface IDelegable {\\r\\n    function delegate(address delegatee) external;\\r\\n    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) external;\\r\\n    function getCurrentVotes(address account) external view returns (uint256);\\r\\n    function getPriorVotes(address account, uint blockNumber) external view returns (uint256);\\r\\n\\r\\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\\r\\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\\r\\n}\\r\\n\"\r\n    },\r\n    \"/app/contracts/vendors/interfaces/IDelegableERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport \\\"./IDelegable.sol\\\";\\r\\nimport \\\"./IERC20WithMaxTotalSupply.sol\\\";\\r\\n\\r\\ninterface IDelegableERC20 is IDelegable, IERC20WithMaxTotalSupply {}\\r\\n\"\r\n    },\r\n    \"/app/contracts/vendors/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.6.12;\\r\\n\\r\\ninterface IERC20 {\\r\\n    function name() external view returns (string memory);\\r\\n    function symbol() external view returns (string memory);\\r\\n    function decimals() external view returns (uint8);\\r\\n    function totalSupply() external view returns (uint);\\r\\n\\r\\n    function balanceOf(address tokenOwner) external view returns (uint balance);\\r\\n    function allowance(address tokenOwner, address spender) external view returns (uint remaining);\\r\\n    function approve(address spender, uint tokens) external returns (bool success);\\r\\n    function transfer(address to, uint tokens) external returns (bool success);\\r\\n    function transferFrom(address from, address to, uint tokens) external returns (bool success);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint tokens);\\r\\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\\r\\n}\\r\\n\"\r\n    },\r\n    \"/app/contracts/vendors/interfaces/IERC20WithMaxTotalSupply.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\ninterface IERC20WithMaxTotalSupply is IERC20 {\\r\\n    event Mint(address indexed account, uint tokens);\\r\\n    event Burn(address indexed account, uint tokens);\\r\\n    function maxTotalSupply() external view returns (uint);\\r\\n}\\r\\n\"\r\n    },\r\n    \"/app/contracts/vendors/interfaces/IGovernanceOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\n\\ninterface IGovernanceOwnable {\\n    event GovernanceSetTransferred(address indexed previousGovernance, address indexed newGovernance);\\n\\n    function governance() external view returns (address);\\n    function setGovernance(address newGovernance) external;\\n}\"\r\n    },\r\n    \"/app/contracts/vendors/libraries/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nlibrary SafeMath {\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return add(a, b, \\\"SafeMath: Add Overflow\\\");\\r\\n    }\\r\\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, errorMessage);// \\\"SafeMath: Add Overflow\\\"\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: Underflow\\\");\\r\\n    }\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b <= a, errorMessage);\\r\\n        uint256 c = a - b;// \\\"SafeMath: Underflow\\\"\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mul(a, b, \\\"SafeMath: Mul Overflow\\\");\\r\\n    }\\r\\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, errorMessage);// \\\"SafeMath: Mul Overflow\\\"\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b != 0, \\\"SafeMath: division by zero\\\");\\r\\n        uint256 c = a / b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b != 0, \\\"SafeMath: modulo by zero\\\");\\r\\n        return a % b;\\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pact_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"block_generation_frequency_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"signature\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ExecuteTransaction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousGovernance\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newGovernance\",\"type\":\"address\"}],\"name\":\"GovernanceSetTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ProposalCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"string[]\",\"name\":\"signatures\",\"type\":\"string[]\"},{\"indexed\":false,\"internalType\":\"bytes[]\",\"name\":\"calldatas\",\"type\":\"bytes[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"}],\"name\":\"ProposalCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ProposalExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"support\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"votes\",\"type\":\"uint256\"}],\"name\":\"VoteCast\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BALLOT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_latestProposalIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_proposalCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_proposals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"votingSettingsId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiredBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"forVotes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"againstVotes\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"canceled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isMultiExecutable\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_proposalsExecutionBlocks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_token\",\"outputs\":[{\"internalType\":\"contract IDelegableERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_votingSettings\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isValue\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"votingPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"proposalMaxOperations\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quorumVotesDelimiter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"proposalThresholdDelimiter\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"addAllowedTarget\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowedTargets\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"support\",\"type\":\"bool\"}],\"name\":\"castVote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"support\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"castVoteBySig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"signatures\",\"type\":\"string[]\"},{\"internalType\":\"bytes[]\",\"name\":\"calldatas\",\"type\":\"bytes[]\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"}],\"name\":\"createDefaultPropose\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"signatures\",\"type\":\"string[]\"},{\"internalType\":\"bytes[]\",\"name\":\"calldatas\",\"type\":\"bytes[]\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"}],\"name\":\"createFastPropose\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"signatures\",\"type\":\"string[]\"},{\"internalType\":\"bytes[]\",\"name\":\"calldatas\",\"type\":\"bytes[]\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"}],\"name\":\"createMultiExecutablePropose\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"execute\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"getActions\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"signatures\",\"type\":\"string[]\"},{\"internalType\":\"bytes[]\",\"name\":\"calldatas\",\"type\":\"bytes[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllowedTargets\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"getReceipt\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"hasVoted\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"support\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"votes\",\"type\":\"uint256\"}],\"internalType\":\"struct AbstractGovernor.Receipt\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"votingSettingsId\",\"type\":\"uint256\"}],\"name\":\"getVotingSettings\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isValue\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"votingPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"proposalMaxOperations\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quorumVotesDelimiter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"proposalThresholdDelimiter\",\"type\":\"uint256\"}],\"internalType\":\"struct AbstractGovernor.VotingSettings\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"votingSettingsId\",\"type\":\"uint256\"}],\"name\":\"proposalThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"votingSettingsId\",\"type\":\"uint256\"}],\"name\":\"quorumVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGovernance\",\"type\":\"address\"}],\"name\":\"setGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"state\",\"outputs\":[{\"internalType\":\"enum AbstractGovernor.ProposalState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"GovernorPACT","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000080d290a6fdce62709e17669af8affb0d77c6edb8000000000000000000000000000000000000000000000000000000000000000f","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}