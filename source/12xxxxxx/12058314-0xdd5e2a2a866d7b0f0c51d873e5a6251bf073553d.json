{"status":"1","message":"OK","result":[{"SourceCode":"{\"LibBaseAuth.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity =0.7.5;\\r\\n\\r\\nimport \\\"LibRoles.sol\\\";\\r\\nimport \\\"LibIERC20.sol\\\";\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Base auth.\\r\\n */\\r\\ncontract BaseAuth {\\r\\n    using Roles for Roles.Role;\\r\\n\\r\\n    Roles.Role private _agents;\\r\\n\\r\\n    event AgentAdded(address indexed account);\\r\\n    event AgentRemoved(address indexed account);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor ()\\r\\n    {\\r\\n        _agents.add(msg.sender);\\r\\n        emit AgentAdded(msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by account which is not an agent.\\r\\n     */\\r\\n    modifier onlyAgent() {\\r\\n        require(isAgent(msg.sender), \\\"AgentRole: caller does not have the Agent role\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Rescue compatible ERC20 Token\\r\\n     *\\r\\n     * Can only be called by an agent.\\r\\n     */\\r\\n    function rescueToken(\\r\\n        address tokenAddr,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    )\\r\\n        external\\r\\n        onlyAgent\\r\\n    {\\r\\n        IERC20 _token = IERC20(tokenAddr);\\r\\n        require(recipient != address(0), \\\"Rescue: recipient is the zero address\\\");\\r\\n        uint256 balance = _token.balanceOf(address(this));\\r\\n\\r\\n        require(balance \\u003e= amount, \\\"Rescue: amount exceeds balance\\\");\\r\\n        _token.transfer(recipient, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Withdraw Ether\\r\\n     *\\r\\n     * Can only be called by an agent.\\r\\n     */\\r\\n    function withdrawEther(\\r\\n        address payable recipient,\\r\\n        uint256 amount\\r\\n    )\\r\\n        external\\r\\n        onlyAgent\\r\\n    {\\r\\n        require(recipient != address(0), \\\"Withdraw: recipient is the zero address\\\");\\r\\n        uint256 balance = address(this).balance;\\r\\n        require(balance \\u003e= amount, \\\"Withdraw: amount exceeds balance\\\");\\r\\n        recipient.transfer(amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the `account` has the Agent role.\\r\\n     */\\r\\n    function isAgent(address account)\\r\\n        public\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        return _agents.has(account);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Give an `account` access to the Agent role.\\r\\n     *\\r\\n     * Can only be called by an agent.\\r\\n     */\\r\\n    function addAgent(address account)\\r\\n        public\\r\\n        onlyAgent\\r\\n    {\\r\\n        _agents.add(account);\\r\\n        emit AgentAdded(account);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Remove an `account` access from the Agent role.\\r\\n     *\\r\\n     * Can only be called by an agent.\\r\\n     */\\r\\n    function removeAgent(address account)\\r\\n        public\\r\\n        onlyAgent\\r\\n    {\\r\\n        _agents.remove(account);\\r\\n        emit AgentRemoved(account);\\r\\n    }\\r\\n}\\r\\n\\r\\n\"},\"LibIERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity =0.7.5;\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    function name() external view returns (string memory);\\r\\n    function symbol() external view returns (string memory);\\r\\n    function decimals() external view returns (uint8);\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n}\\r\\n\"},\"LibRoles.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity =0.7.5;\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Library for managing addresses assigned to a Role.\\r\\n */\\r\\nlibrary Roles {\\r\\n    struct Role\\r\\n    {\\r\\n        mapping (address =\\u003e bool) bearer;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Give an account access to this role.\\r\\n     */\\r\\n    function add(\\r\\n        Role storage role,\\r\\n        address account\\r\\n    )\\r\\n        internal\\r\\n    {\\r\\n        require(!has(role, account), \\\"Roles: account already has role\\\");\\r\\n        role.bearer[account] = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Remove an account\\u0027s access to this role.\\r\\n     */\\r\\n    function remove(\\r\\n        Role storage role,\\r\\n        address account\\r\\n    )\\r\\n        internal\\r\\n    {\\r\\n        require(has(role, account), \\\"Roles: account does not have role\\\");\\r\\n        role.bearer[account] = false;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Check if an account has this role.\\r\\n     *\\r\\n     * @return bool\\r\\n     */\\r\\n    function has(\\r\\n        Role storage role,\\r\\n        address account\\r\\n    )\\r\\n        internal\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        require(account != address(0), \\\"Roles: account is the zero address\\\");\\r\\n        return role.bearer[account];\\r\\n    }\\r\\n}\\r\\n\"},\"LibSafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity =0.7.5;\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(\\r\\n        uint256 a,\\r\\n        uint256 b\\r\\n    )\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256)\\r\\n    {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(\\r\\n        uint256 a,\\r\\n        uint256 b\\r\\n    )\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    )\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256)\\r\\n    {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(\\r\\n        uint256 a,\\r\\n        uint256 b\\r\\n    )\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256)\\r\\n    {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(\\r\\n        uint256 a,\\r\\n        uint256 b\\r\\n    )\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    )\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256)\\r\\n    {\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(\\r\\n        uint256 a,\\r\\n        uint256 b\\r\\n    )\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    )\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256)\\r\\n    {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\"},\"VokenTBData.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity =0.7.5;\\r\\n\\r\\nimport \\\"LibSafeMath.sol\\\";\\r\\nimport \\\"LibBaseAuth.sol\\\";\\r\\n\\r\\n\\r\\ninterface IVokenTB {\\r\\n    function cap() external view returns (uint256);\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function burningPermilleBorder() external view returns (uint16 min, uint16 max);\\r\\n    function vokenCounter() external view returns (uint256);\\r\\n    \\r\\n    function address2voken(address account) external view returns (uint160);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function vestingOf(address account) external view returns (uint256);\\r\\n    function availableOf(address account) external view returns (uint256);\\r\\n    function isBank(address account) external view returns (bool);\\r\\n    function referrer(address account) external view returns (address payable);\\r\\n}\\r\\n\\r\\n\\r\\ninterface IUniswapV2Router02 {\\r\\n    function WETH() external pure returns (address);\\r\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n}\\r\\n\\r\\n\\r\\ncontract VokenTBData is BaseAuth {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    IUniswapV2Router02 private immutable UniswapV2Router02 = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\r\\n    IVokenTB private immutable VOKEN_TB = IVokenTB(0x1234567a022acaa848E7D6bC351d075dBfa76Dd4);\\r\\n    address private immutable DAI = address(0x6B175474E89094C44Da98b954EedeAC495271d0F);\\r\\n\\r\\n    receive() external payable {}\\r\\n\\r\\n    function data(address account)\\r\\n        public\\r\\n        view\\r\\n        returns (\\r\\n            uint256 etherBalance,\\r\\n            uint256 etherPrice,\\r\\n            uint256 vokenPrice,\\r\\n\\r\\n            uint256 cap,\\r\\n            uint256 totalSupply,\\r\\n            uint16 burningPermilleMin,\\r\\n            uint16 burningPermilleMax,\\r\\n\\r\\n            uint256 vokenCounter,\\r\\n\\r\\n            uint160 vokenInt,\\r\\n            uint256 balance,\\r\\n            uint256 vesting,\\r\\n\\r\\n            bool isBank,\\r\\n            address payable referrer\\r\\n        )\\r\\n    {\\r\\n        etherBalance = account.balance;\\r\\n        etherPrice = _etherPrice();\\r\\n        vokenPrice = _vokenPrice();\\r\\n\\r\\n        cap = VOKEN_TB.cap();\\r\\n        totalSupply = VOKEN_TB.totalSupply();\\r\\n        (burningPermilleMin, burningPermilleMax) = VOKEN_TB.burningPermilleBorder();\\r\\n\\r\\n        vokenCounter = VOKEN_TB.vokenCounter();\\r\\n\\r\\n        vokenInt = VOKEN_TB.address2voken(account);\\r\\n        balance = VOKEN_TB.balanceOf(account);\\r\\n        vesting = VOKEN_TB.vestingOf(account);\\r\\n\\r\\n        isBank = VOKEN_TB.isBank(account);\\r\\n        referrer = VOKEN_TB.referrer(account);\\r\\n    }\\r\\n    \\r\\n    function _etherPrice()\\r\\n        private\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = UniswapV2Router02.WETH();\\r\\n        path[1] = DAI;\\r\\n\\r\\n        return UniswapV2Router02.getAmountsOut(1_000_000, path)[1];\\r\\n    }\\r\\n\\r\\n    function _vokenPrice()\\r\\n        private\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(VOKEN_TB);\\r\\n        path[1] = DAI;\\r\\n        \\r\\n        return UniswapV2Router02.getAmountsOut(1_000_000, path)[1].mul(1_000_000_000).div(1 ether);\\r\\n    }\\r\\n}\\r\\n\"}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AgentAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AgentRemoved\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addAgent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"data\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"etherBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"etherPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vokenPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"burningPermilleMin\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"burningPermilleMax\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"vokenCounter\",\"type\":\"uint256\"},{\"internalType\":\"uint160\",\"name\":\"vokenInt\",\"type\":\"uint160\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vesting\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isBank\",\"type\":\"bool\"},{\"internalType\":\"address payable\",\"name\":\"referrer\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isAgent\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeAgent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"rescueToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"VokenTBData","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://48a63ae2391832ab9b2bdc9d5d08b4b9b9fc533676d4281945ff219487981039"}]}