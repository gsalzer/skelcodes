{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/lp-oracle-contracts/aggregators/UniswapV2PriceProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../interfaces/IUniswapV2Pair.sol\\\";\\nimport \\\"../interfaces/IUniswapV2Factory.sol\\\";\\nimport \\\"../interfaces/IPriceOracle.sol\\\";\\nimport \\\"../interfaces/IExtendedAggregator.sol\\\";\\nimport \\\"../misc/SafeMath.sol\\\";\\nimport \\\"../misc/Math.sol\\\";\\n\\n/** @title UniswapV2PriceProvider\\n * @notice Price provider for a Uniswap V2 pair token\\n * It calculates the price using Chainlink as an external price source and the pair's tokens reserves using the weighted arithmetic mean formula.\\n * If there is a price deviation, instead of the reserves, it uses a weighted geometric mean with the constant invariant K.\\n */\\n\\ncontract UniswapV2PriceProvider is IExtendedAggregator {\\n    using SafeMath for uint256;\\n\\n    IUniswapV2Pair public immutable pair;\\n    address[] public tokens;\\n    bool[] public isPeggedToEth;\\n    uint8[] public decimals;\\n    IPriceOracle immutable priceOracle;\\n    uint256 public immutable maxPriceDeviation;\\n\\n    /**\\n     * UniswapV2PriceProvider constructor.\\n     * @param _pair Uniswap V2 pair address.\\n     * @param _isPeggedToEth For each token, true if it is pegged to ETH.\\n     * @param _decimals Number of decimals for each token.\\n     * @param _priceOracle Aave price oracle.\\n     * @param _maxPriceDeviation Threshold of spot prices deviation: 10Ë†16 represents a 1% deviation.\\n     */\\n    constructor(\\n        IUniswapV2Pair _pair,\\n        bool[] memory _isPeggedToEth,\\n        uint8[] memory _decimals,\\n        IPriceOracle _priceOracle,\\n        uint256 _maxPriceDeviation\\n    ) public {\\n        require(_isPeggedToEth.length == 2, \\\"ERR_INVALID_PEGGED_LENGTH\\\");\\n        require(_decimals.length == 2, \\\"ERR_INVALID_DECIMALS_LENGTH\\\");\\n        require(\\n            _decimals[0] <= 18 && _decimals[1] <= 18,\\n            \\\"ERR_INVALID_DECIMALS\\\"\\n        );\\n        require(\\n            address(_priceOracle) != address(0),\\n            \\\"ERR_INVALID_PRICE_PROVIDER\\\"\\n        );\\n        require(_maxPriceDeviation < Math.BONE, \\\"ERR_INVALID_PRICE_DEVIATION\\\");\\n\\n        pair = _pair;\\n        //Get tokens\\n        tokens.push(_pair.token0());\\n        tokens.push(_pair.token1());\\n        isPeggedToEth = _isPeggedToEth;\\n        decimals = _decimals;\\n        priceOracle = _priceOracle;\\n        maxPriceDeviation = _maxPriceDeviation;\\n    }\\n\\n    /**\\n     * Returns the token balance in ethers by multiplying its reserves with its price in ethers.\\n     * @param index Token index.\\n     * @param reserve Token reserves.\\n     */\\n    function getEthBalanceByToken(uint256 index, uint112 reserve)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 pi =\\n            isPeggedToEth[index]\\n                ? Math.BONE\\n                : uint256(priceOracle.getAssetPrice(tokens[index]));\\n        require(pi > 0, \\\"ERR_NO_ORACLE_PRICE\\\");\\n        uint256 missingDecimals = uint256(18).sub(decimals[index]);\\n        uint256 bi = uint256(reserve).mul(10**(missingDecimals));\\n        return Math.bmul(bi, pi);\\n    }\\n\\n    /**\\n     * Returns true if there is a price deviation.\\n     * @param ethTotal_0 Total eth for token 0.\\n     * @param ethTotal_1 Total eth for token 1.\\n     */\\n    function hasDeviation(uint256 ethTotal_0, uint256 ethTotal_1)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        //Check for a price deviation\\n        uint256 price_deviation = Math.bdiv(ethTotal_0, ethTotal_1);\\n        if (\\n            price_deviation > (Math.BONE.add(maxPriceDeviation)) ||\\n            price_deviation < (Math.BONE.sub(maxPriceDeviation))\\n        ) {\\n            return true;\\n        }\\n        price_deviation = Math.bdiv(ethTotal_1, ethTotal_0);\\n        if (\\n            price_deviation > (Math.BONE.add(maxPriceDeviation)) ||\\n            price_deviation < (Math.BONE.sub(maxPriceDeviation))\\n        ) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     * Calculates the price of the pair token using the formula of arithmetic mean.\\n     * @param ethTotal_0 Total eth for token 0.\\n     * @param ethTotal_1 Total eth for token 1.\\n     */\\n    function getArithmeticMean(uint256 ethTotal_0, uint256 ethTotal_1)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 totalEth = ethTotal_0 + ethTotal_1;\\n        return Math.bdiv(totalEth, getTotalSupplyAtWithdrawal());\\n    }\\n\\n    /**\\n     * Calculates the price of the pair token using the formula of weighted geometric mean.\\n     * @param ethTotal_0 Total eth for token 0.\\n     * @param ethTotal_1 Total eth for token 1.\\n     */\\n    function getWeightedGeometricMean(uint256 ethTotal_0, uint256 ethTotal_1)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 square = Math.bsqrt(Math.bmul(ethTotal_0, ethTotal_1), true);\\n        return\\n            Math.bdiv(\\n                Math.bmul(Math.TWO_BONES, square),\\n                getTotalSupplyAtWithdrawal()\\n            );\\n    }\\n\\n    /**\\n     * Returns Uniswap V2 pair total supply at the time of withdrawal.\\n     */\\n    function getTotalSupplyAtWithdrawal()\\n        private\\n        view\\n        returns (uint256 totalSupply)\\n    {\\n        totalSupply = pair.totalSupply();\\n        address feeTo =\\n            IUniswapV2Factory(IUniswapV2Pair(pair).factory()).feeTo();\\n        bool feeOn = feeTo != address(0);\\n        if (feeOn) {\\n            uint256 kLast = IUniswapV2Pair(pair).kLast();\\n            if (kLast != 0) {\\n                (uint112 reserve_0, uint112 reserve_1, ) = pair.getReserves();\\n                uint256 rootK =\\n                    Math.bsqrt(uint256(reserve_0).mul(reserve_1), false);\\n                uint256 rootKLast = Math.bsqrt(kLast, false);\\n                if (rootK > rootKLast) {\\n                    uint256 numerator = totalSupply.mul(rootK.sub(rootKLast));\\n                    uint256 denominator = rootK.mul(5).add(rootKLast);\\n                    uint256 liquidity = numerator / denominator;\\n                    totalSupply = totalSupply.add(liquidity);\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Returns Uniswap V2 pair address.\\n     */\\n    function getPair() external view returns (IUniswapV2Pair) {\\n        return pair;\\n    }\\n\\n    /**\\n     * Returns all tokens.\\n     */\\n    function getTokens() external view returns (address[] memory) {\\n        return tokens;\\n    }\\n\\n    /**\\n     * @dev Returns the LP shares token\\n     * @return address of the LP shares token\\n     */\\n    function getToken() external view override returns (address) {\\n        return address(pair);\\n    }\\n\\n    /**\\n     * @dev Returns token type for categorization\\n     * @return uint256 1 = Simple (Native or plain ERC20 tokens like DAI), 2 = Complex (LP Tokens, Staked tokens)\\n     */\\n    function getTokenType()\\n        external\\n        pure\\n        override\\n        returns (IExtendedAggregator.TokenType)\\n    {\\n        return IExtendedAggregator.TokenType.Complex;\\n    }\\n\\n    /**\\n     * @dev Returns the number of tokens that composes the LP shares\\n     * @return address[] memory of token addresses\\n     */\\n    function getSubTokens() external view override returns (address[] memory) {\\n        return tokens;\\n    }\\n\\n    /**\\n     * @dev Returns the platform id to categorize the price aggregator\\n     * @return uint256 1 = Uniswap, 2 = Balancer\\n     */\\n    function getPlatformId()\\n        external\\n        pure\\n        override\\n        returns (IExtendedAggregator.PlatformId)\\n    {\\n        return IExtendedAggregator.PlatformId.Uniswap;\\n    }\\n\\n    /**\\n     * @dev Returns the pair's token price.\\n     *   It calculates the price using Chainlink as an external price source and the pair's tokens reserves using the arithmetic mean formula.\\n     *   If there is a price deviation, instead of the reserves, it uses a weighted geometric mean with constant invariant K.\\n     * @return int256 price\\n     */\\n    function latestAnswer() external view override returns (int256) {\\n        //Get token reserves in ethers\\n        (uint112 reserve_0, uint112 reserve_1, ) = pair.getReserves();\\n        uint256 ethTotal_0 = getEthBalanceByToken(0, reserve_0);\\n        uint256 ethTotal_1 = getEthBalanceByToken(1, reserve_1);\\n\\n        if (hasDeviation(ethTotal_0, ethTotal_1)) {\\n            //Calculate the weighted geometric mean\\n            return int256(getWeightedGeometricMean(ethTotal_0, ethTotal_1));\\n        } else {\\n            //Calculate the arithmetic mean\\n            return int256(getArithmeticMean(ethTotal_0, ethTotal_1));\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lp-oracle-contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.6.12;\\n\\ninterface IUniswapV2Pair {\\n  function totalSupply() external view returns (uint256);\\n\\n  function token0() external view returns (address);\\n\\n  function token1() external view returns (address);\\n\\n  function getReserves()\\n    external\\n    view\\n    returns (\\n      uint112 reserve0,\\n      uint112 reserve1,\\n      uint32 blockTimestampLast\\n    );\\n\\n  function kLast() external view returns (uint256);\\n\\n  function factory() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/lp-oracle-contracts/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity 0.6.12;\\n\\ninterface IUniswapV2Factory {\\n  function feeTo() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/lp-oracle-contracts/interfaces/IPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.6.12;\\n\\n/************\\n@title IPriceOracle interface\\n@notice Interface for the Aave price oracle.*/\\ninterface IPriceOracle {\\n  /***********\\n    @dev returns the asset price in ETH\\n     */\\n  function getAssetPrice(address _asset) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/lp-oracle-contracts/interfaces/IExtendedAggregator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity ^0.6.12;\\n\\ninterface IExtendedAggregator {\\n    enum TokenType {Invalid, Simple, Complex}\\n\\n    enum PlatformId {Invalid, Simple, Uniswap, Balancer}\\n\\n    /**\\n     * @dev Returns the LP shares token\\n     * @return address of the LP shares token\\n     */\\n    function getToken() external view returns (address);\\n\\n    /**\\n     * @dev Returns token type for categorization\\n     * @return uint256 1 = Simple (Native or plain ERC20 tokens like DAI), 2 = Complex (LP Tokens, Staked tokens)\\n     */\\n    function getTokenType() external pure returns (TokenType);\\n\\n    /**\\n     * @dev Returns the number of tokens that composes the LP shares\\n     * @return address[] memory of token addresses\\n     */\\n    function getSubTokens() external view returns (address[] memory);\\n\\n    /**\\n     * @dev Returns the platform id to categorize the price aggregator\\n     * @return uint256 1 = Uniswap, 2 = Balancer\\n     */\\n    function getPlatformId() external pure returns (PlatformId);\\n\\n    /**\\n     * @dev Returns the latest price\\n     * @return int256 price\\n     */\\n    function latestAnswer() external view returns (int256);\\n}\\n\"\r\n    },\r\n    \"contracts/lp-oracle-contracts/misc/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.6.12;\\n\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\n\\nlibrary SafeMath {\\n  function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n    require((z = x + y) >= x, 'ds-math-add-overflow');\\n  }\\n\\n  function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n    require((z = x - y) <= x, 'ds-math-sub-underflow');\\n  }\\n\\n  function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n    require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/lp-oracle-contracts/misc/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.6.12;\\n\\n// a library for performing various math operations\\n\\nlibrary Math {\\n  uint256 public constant BONE = 10**18;\\n  uint256 public constant TWO_BONES = 2 * 10**18;\\n\\n  /**\\n   * @notice Returns the square root of an uint256 x using the Babylonian method\\n   * @param y The number to calculate the sqrt from\\n   * @param bone True when y has 18 decimals\\n   */\\n  function bsqrt(uint256 y, bool bone) internal pure returns (uint256 z) {\\n    if (y > 3) {\\n      z = y;\\n      uint256 x = y / 2 + 1;\\n      while (x < z) {\\n        z = x;\\n        if (bone) {\\n          x = (bdiv(y, x) + x) / 2;\\n        } else {\\n          x = (y / x + x) / 2;\\n        }\\n      }\\n    } else if (y != 0) {\\n      z = 1;\\n    }\\n  }\\n\\n  function bmul(\\n    uint256 a,\\n    uint256 b //Bone mul\\n  ) internal pure returns (uint256) {\\n    uint256 c0 = a * b;\\n    require(a == 0 || c0 / a == b, 'ERR_MUL_OVERFLOW');\\n    uint256 c1 = c0 + (BONE / 2);\\n    require(c1 >= c0, 'ERR_MUL_OVERFLOW');\\n    uint256 c2 = c1 / BONE;\\n    return c2;\\n  }\\n\\n  function bdiv(\\n    uint256 a,\\n    uint256 b //Bone div\\n  ) internal pure returns (uint256) {\\n    require(b != 0, 'ERR_DIV_ZERO');\\n    uint256 c0 = a * BONE;\\n    require(a == 0 || c0 / a == BONE, 'ERR_DIV_INTERNAL'); // bmul overflow\\n    uint256 c1 = c0 + (b / 2);\\n    require(c1 >= c0, 'ERR_DIV_INTERNAL'); //  badd require\\n    uint256 c2 = c1 / b;\\n    return c2;\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"_pair\",\"type\":\"address\"},{\"internalType\":\"bool[]\",\"name\":\"_isPeggedToEth\",\"type\":\"bool[]\"},{\"internalType\":\"uint8[]\",\"name\":\"_decimals\",\"type\":\"uint8[]\"},{\"internalType\":\"contract IPriceOracle\",\"name\":\"_priceOracle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxPriceDeviation\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPair\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPlatformId\",\"outputs\":[{\"internalType\":\"enum IExtendedAggregator.PlatformId\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSubTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenType\",\"outputs\":[{\"internalType\":\"enum IExtendedAggregator.TokenType\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isPeggedToEth\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestAnswer\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxPriceDeviation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"UniswapV2PriceProvider","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000bb2b8038a1640196fbe3e38816f3e67cba72d94000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000100000000000000000000000000a50ba011c48153de246e5192c8f9258a2ba79ca900000000000000000000000000000000000000000000000000b1a2bc2ec50000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000012","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}