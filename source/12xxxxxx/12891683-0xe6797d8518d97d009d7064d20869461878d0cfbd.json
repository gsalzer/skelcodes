{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/JPGRegistry/JPGRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\nimport \\\"../Interfaces/ERC721.sol\\\";\\nimport \\\"../Libraries/SignedMessage.sol\\\";\\nimport \\\"../Libraries/Helpers.sol\\\";\\n\\ncontract JPGRegistry is OwnableUpgradeable, SignedMessage, Helpers {\\n    using SafeCast for uint256;\\n\\n    event CuratorAdded(address indexed curator);\\n    event CreateSubRegistry(address indexed curator, bytes32 name, string description);\\n    event UpdateSubRegistry(address indexed curator, bytes32 name, string description);\\n    event RemoveSubRegistry(address indexed curator, bytes32 name);\\n    event ReinstateSubRegistry(address indexed curator, bytes32 name);\\n\\n    event TokensListed(OwnerBundle[] bundles);\\n\\n    event AddNFTToSubRegistry(address indexed curator, bytes32 name, CuratedNFT token);\\n    event RemoveNFTFromSubRegistry(address indexed curator, bytes32 name, NFT token);\\n\\n    event TokenListedForSale(NFT token, uint256 price, address curator, address owner);\\n    event TokenSold(NFT token, uint256 price, address buyer, address seller, address curator);\\n\\n    // Maximum percentage fee, with 2 decimal points beyond 1%\\n    uint16 internal constant MAX_FEE_PERC = 10000;\\n    uint16 internal constant CURATOR_TAKE_PER_10000 = 500;\\n\\n    bool private _initialized;\\n    bool private _initializing;\\n\\n    struct NFT {\\n        address tokenContract;\\n        uint256 tokenId;\\n    }\\n\\n    struct CuratedNFT {\\n        address tokenContract;\\n        uint256 tokenId;\\n        string note;\\n    }\\n\\n    struct Listing {\\n        bytes signedMessage;\\n        NFT nft;\\n    }\\n\\n    struct OwnerBundle {\\n        address owner;\\n        Listing[] listings;\\n    }\\n\\n    struct ListingPrice {\\n        uint256 artistTake;\\n        uint256 curatorTake;\\n        uint256 sellerTake;\\n        uint256 sellPrice;\\n    }\\n\\n    struct SubRegistry {\\n        bool created;\\n        bool removed;\\n        string description;\\n        mapping(address => mapping(uint256 => NFTData)) nfts;\\n    }\\n\\n    struct NFTData {\\n        bool active;\\n        string note;\\n    }\\n\\n    struct SubRegistries {\\n        uint16 feePercentage;\\n        bytes32[] registryNames;\\n        mapping(bytes32 => SubRegistry) subRegistry;\\n        mapping(address => mapping(uint256 => NFTData)) nfts;\\n    }\\n\\n    // We use uint96, since we only support ETH, which 2**96 = 79228162514264337593543950336,\\n    // which is 79228162514.26434 ETH, which is a ridiculous amount of dollar value\\n    // this lets us squeeze this into a single slot\\n    struct InternalPrice {\\n        address curator;\\n        uint96 sellerTake;\\n    }\\n\\n    mapping(address => bool) public curators;\\n    mapping(address => mapping(uint256 => bool)) public mainRegistry;\\n    mapping(address => SubRegistries) internal subRegistries;\\n    mapping(address => mapping(address => mapping(uint256 => InternalPrice))) internal priceList;\\n    mapping(address => uint256) public balances;\\n\\n    function initialize() public {\\n        {\\n            bool either = _initializing || !_initialized;\\n            require(either, \\\"contract initialized\\\");\\n        }\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        curators[msg.sender] = true;\\n        subRegistries[msg.sender].feePercentage = CURATOR_TAKE_PER_10000;\\n        OwnableUpgradeable.__Ownable_init();\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /**\\n     * @notice Public method to list non-fungible token(s) on the main registry\\n     * @dev permissionless listing from dApp - array of tokens (can be one). Will\\n     * ensure token is owned by caller.\\n     * @param tokens An array of NFT struct instances\\n     */\\n    function bulkAddToMainRegistry(NFT[] calldata tokens) public {\\n        NFT[] memory listedTokens = new NFT[](tokens.length);\\n        Listing[] memory bundleListings = new Listing[](tokens.length);\\n\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            mainRegistry[tokens[i].tokenContract][tokens[i].tokenId] = true;\\n            listedTokens[i] = tokens[i];\\n            bundleListings[i] = Listing({signedMessage: bytes(\\\"0\\\"), nft: tokens[i]});\\n        }\\n\\n        OwnerBundle[] memory bundle = new OwnerBundle[](1);\\n        bundle[0] = OwnerBundle({listings: bundleListings, owner: address(msg.sender)});\\n        emit TokensListed(bundle);\\n    }\\n\\n    /**\\n     * @notice Called by token owner to allow JPG Registry to sell an NFT on their behalf\\n     * in a fixed price sale with minimum price\\n     * @param token An instance of an NFT struct\\n     * @param price The minimum price the seller will acccept\\n     * @param curator Address of curator\\n     */\\n    function listForSale(\\n        NFT calldata token,\\n        uint96 price,\\n        address curator\\n    ) public {\\n        require(price > 0, \\\"JPGR:lFS:Price cannot be 0\\\");\\n        require(mainRegistry[token.tokenContract][token.tokenId], \\\"JPGR:lFS:Token not registered\\\");\\n\\n        require(ERC721(token.tokenContract).ownerOf(token.tokenId) == msg.sender, \\\"JPGR:lFS:Not token owner\\\");\\n\\n        priceList[msg.sender][token.tokenContract][token.tokenId] = InternalPrice({\\n            sellerTake: price,\\n            curator: curator\\n        });\\n\\n        emit TokenListedForSale(token, price, curator, msg.sender);\\n    }\\n\\n    /**\\n     * @notice Called by token owner to allow JPG Registry to sell an NFT on their behalf\\n     * in a fixed price sale with minimum price\\n     * @param tokens Array of NFT structs\\n     * @param prices Array of minimum prices the seller will acccept for corresponding tokens\\n     * @param curator Address of curator\\n     */\\n    function bulkListForSale(\\n        NFT[] calldata tokens,\\n        uint96[] calldata prices,\\n        address curator\\n    ) public {\\n        require(tokens.length == prices.length, \\\"JPGR:bLFS:Invalid prices array length\\\");\\n\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            require(prices[i] > 0, \\\"JPGR:bLFS:Price cannot be 0\\\");\\n            require(mainRegistry[tokens[i].tokenContract][tokens[i].tokenId], \\\"JPGR:bLFS:Token not registered\\\");\\n            require(\\n                ERC721(tokens[i].tokenContract).ownerOf(tokens[i].tokenId) == msg.sender,\\n                \\\"JPGR:bLFS:Not token owner\\\"\\n            );\\n\\n            priceList[msg.sender][tokens[i].tokenContract][tokens[i].tokenId] = InternalPrice({\\n                sellerTake: prices[i],\\n                curator: curator\\n            });\\n\\n            emit TokenListedForSale(tokens[i], prices[i], curator, msg.sender);\\n        }\\n    }\\n\\n    /**\\n     * @notice Get price of a specific token\\n     * @param subRegistryName Name of the subregistry the token is hosted on\\n     * @param token An instance of an NFT struct\\n     * @param curator Address of curator\\n     * @param owner Owner of the NFT\\n     */\\n    function getPrice(\\n        bytes32 subRegistryName,\\n        NFT calldata token,\\n        address curator,\\n        address owner\\n    ) public view returns (ListingPrice memory) {\\n        require(mainRegistry[token.tokenContract][token.tokenId], \\\"JPGR:gp:Token not registered\\\");\\n        require(inSubRegistry(subRegistryName, token, curator), \\\"JPGR:gp:Token not curated by curator\\\");\\n\\n        InternalPrice memory priceInternal = priceList[owner][token.tokenContract][token.tokenId];\\n        require(\\n            priceInternal.curator != address(0) && priceInternal.curator == curator,\\n            \\\"JPGR:gp:Curator not approved seller\\\"\\n        );\\n\\n        uint256 sellerTake = priceInternal.sellerTake;\\n\\n        require(sellerTake > 0, \\\"JPGR:bfp:Owner price 0\\\");\\n\\n        uint256 curatorTake = calculateCuratorTake(sellerTake, curator);\\n        // Hardcoded artist take to JPG multisig\\n        uint256 artistTake = sellerTake / 10;\\n        uint256 totalPrice = sellerTake + curatorTake + artistTake;\\n\\n        // TODO: artist royalties\\n        return\\n            ListingPrice({\\n                curatorTake: curatorTake,\\n                sellerTake: sellerTake,\\n                artistTake: artistTake,\\n                sellPrice: totalPrice\\n            });\\n    }\\n\\n    /**\\n     * @notice Called publicly to purchase an NFT that has been approved for fixed price sale\\n     * @param subRegistryName Name of the subregistry the token is hosted on\\n     * @param token An instance of an NFT struct\\n     * @param curator Address of curator\\n     * @param owner Owner of the NFT\\n     */\\n    function buyFixedPrice(\\n        bytes32 subRegistryName,\\n        NFT calldata token,\\n        address curator,\\n        address owner\\n    ) public payable {\\n        ListingPrice memory price = getPrice(subRegistryName, token, curator, owner);\\n        require(msg.value == price.sellPrice, \\\"JPGR:bfp:Price too low\\\");\\n\\n        address jpgOwner = this.owner();\\n\\n        balances[owner] += price.sellerTake;\\n        balances[curator] += price.curatorTake;\\n        // Contract owner temporarily set as royalties recipient\\n        balances[jpgOwner] += price.artistTake;\\n        delete priceList[owner][token.tokenContract][token.tokenId];\\n\\n        ERC721(token.tokenContract).transferFrom(owner, msg.sender, token.tokenId);\\n\\n        emit TokenSold(token, price.sellPrice, msg.sender, owner, curator);\\n    }\\n\\n    /**\\n     * @notice Called publicly to withdraw balance for message sender\\n     */\\n    function withdrawBalance() public {\\n        uint256 balance = balances[msg.sender];\\n        if (balance > 0) {\\n            balances[msg.sender] = 0;\\n            (bool success, ) = msg.sender.call{value: balance}(\\\"\\\");\\n            require(success, \\\"JPGR:wb:Transfer failed\\\");\\n        }\\n    }\\n\\n    /**\\n     * @notice Called internally to determine payout for a fixed price sale\\n     * @param price The current owner of a Token\\n     * @param curator Curator whose exhibit the token was purchased throuh, can be null address\\n     */\\n    function calculateCuratorTake(uint256 price, address curator) internal view returns (uint256) {\\n        return (price * subRegistries[curator].feePercentage) / MAX_FEE_PERC;\\n    }\\n\\n    /**\\n     * @notice Called publicly by token owner to remove from ProtocolRegistry\\n     * @param listing An instance of a Listing struct\\n     */\\n    function removeFromMainRegistry(Listing calldata listing) public {\\n        try ERC721(listing.nft.tokenContract).ownerOf(listing.nft.tokenId) returns (address owner) {\\n            if (owner == msg.sender) {\\n                _removeFromMainRegistry(NFT({tokenContract: listing.nft.tokenContract, tokenId: listing.nft.tokenId}));\\n            }\\n        } catch {} // solhint-disable-line no-empty-blocks\\n    }\\n\\n    /**\\n     * @notice Create subregistry and add array of tokens\\n     * @param subRegistryName The name of the subregistry\\n     * @param subRegistryDescription The description of the subregistry\\n     * @param tokens Array of NFTs\\n     * @param notes Array of notes corresponding to NFTs\\n     */\\n    function createSubregistry(\\n        bytes32 subRegistryName,\\n        string calldata subRegistryDescription,\\n        NFT[] calldata tokens,\\n        string[] calldata notes\\n    ) public {\\n        require(curators[msg.sender], \\\"JPGR:ats:Only allowed curators\\\");\\n        require(!subRegistries[msg.sender].subRegistry[subRegistryName].created, \\\"JPGR:ats:Subregistry exists\\\");\\n\\n        subRegistries[msg.sender].subRegistry[subRegistryName].created = true;\\n        subRegistries[msg.sender].registryNames.push(subRegistryName);\\n        subRegistries[msg.sender].subRegistry[subRegistryName].description = subRegistryDescription;\\n        emit CreateSubRegistry(msg.sender, subRegistryName, subRegistryDescription);\\n\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            mainRegistry[tokens[i].tokenContract][tokens[i].tokenId] = true;\\n            subRegistries[msg.sender].subRegistry[subRegistryName].nfts[tokens[i].tokenContract][tokens[i].tokenId]\\n                .note = notes[i];\\n            subRegistries[msg.sender].subRegistry[subRegistryName].nfts[tokens[i].tokenContract][tokens[i].tokenId]\\n                .active = true;\\n            emit AddNFTToSubRegistry(\\n                msg.sender,\\n                subRegistryName,\\n                CuratedNFT({tokenContract: tokens[i].tokenContract, tokenId: tokens[i].tokenId, note: notes[i]})\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @notice Update existing subregistry\\n     * @param subRegistryName The name of the subregistry\\n     * @param subRegistryDescription The description of the subregistry\\n     * @param tokensToUpsert Array of NFTs to add/update\\n     * @param tokensToRemove Array of NFTs to remove\\n     * @param notes Array of notes corresponding to NFTs\\n     */\\n    function updateSubregistry(\\n        bytes32 subRegistryName,\\n        string calldata subRegistryDescription,\\n        NFT[] calldata tokensToUpsert,\\n        NFT[] calldata tokensToRemove,\\n        string[] calldata notes\\n    ) public {\\n        // Subregistry doesn't belong to msg.sender or hasn't been created\\n        require(subRegistries[msg.sender].subRegistry[subRegistryName].created, \\\"JPGR:ats:Permission denied\\\");\\n        require(tokensToUpsert.length == notes.length, \\\"JPGR:ats:Mismatched array length\\\");\\n\\n        subRegistries[msg.sender].subRegistry[subRegistryName].description = subRegistryDescription;\\n\\n        if (tokensToRemove.length > 0) {\\n            for (uint256 i = 0; i < tokensToRemove.length; i++) {\\n                delete subRegistries[msg.sender].subRegistry[subRegistryName].nfts[tokensToRemove[i].tokenContract][\\n                    tokensToRemove[i].tokenId\\n                ];\\n                emit RemoveNFTFromSubRegistry(msg.sender, subRegistryName, tokensToRemove[i]);\\n            }\\n        }\\n\\n        if (tokensToUpsert.length > 0) {\\n            for (uint256 i = 0; i < tokensToUpsert.length; i++) {\\n                mainRegistry[tokensToUpsert[i].tokenContract][tokensToUpsert[i].tokenId] = true;\\n\\n                subRegistries[msg.sender].subRegistry[subRegistryName].nfts[tokensToUpsert[i].tokenContract][\\n                    tokensToUpsert[i].tokenId\\n                ]\\n                    .note = notes[i];\\n                subRegistries[msg.sender].subRegistry[subRegistryName].nfts[tokensToUpsert[i].tokenContract][\\n                    tokensToUpsert[i].tokenId\\n                ]\\n                    .active = true;\\n\\n                emit AddNFTToSubRegistry(\\n                    msg.sender,\\n                    subRegistryName,\\n                    CuratedNFT({\\n                        tokenContract: tokensToUpsert[i].tokenContract,\\n                        tokenId: tokensToUpsert[i].tokenId,\\n                        note: notes[i]\\n                    })\\n                );\\n            }\\n        }\\n        emit UpdateSubRegistry(msg.sender, subRegistryName, subRegistryDescription);\\n    }\\n\\n    /**\\n     * @notice Add an array of tokens to a subregistry\\n     * @param subRegistryName The name of the subregistry\\n     * @param tokens Array of NFTs\\n     * @param notes Array of notes corresponding to NFTs\\n     */\\n    function addToSubregistry(\\n        bytes32 subRegistryName,\\n        NFT[] calldata tokens,\\n        string[] calldata notes\\n    ) public {\\n        // Subregistry doesn't belong to msg.sender or hasn't been created\\n        require(subRegistries[msg.sender].subRegistry[subRegistryName].created, \\\"JPGR:ats:Permission denied\\\");\\n\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            mainRegistry[tokens[i].tokenContract][tokens[i].tokenId] = true;\\n            subRegistries[msg.sender].subRegistry[subRegistryName].nfts[tokens[i].tokenContract][tokens[i].tokenId]\\n                .active = true;\\n            subRegistries[msg.sender].subRegistry[subRegistryName].nfts[tokens[i].tokenContract][tokens[i].tokenId]\\n                .note = notes[i];\\n            emit AddNFTToSubRegistry(\\n                msg.sender,\\n                subRegistryName,\\n                CuratedNFT({tokenContract: tokens[i].tokenContract, tokenId: tokens[i].tokenId, note: notes[i]})\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @notice Remove a subregistry by tagging it as removed\\n     * @dev Due to `delete` operation not deleting a mapping, we just set a flag\\n     * @param subRegistryName The name of the subregistry\\n     */\\n    function removeSubRegistry(bytes32 subRegistryName) public {\\n        require(curators[msg.sender], \\\"JPGR:ats:Only allowed curators\\\");\\n        subRegistries[msg.sender].subRegistry[subRegistryName].removed = true;\\n        emit RemoveSubRegistry(msg.sender, subRegistryName);\\n    }\\n\\n    /**\\n     * @notice Reinstates a subregistry that was removed\\n     * @dev We never actually delete a subregistry, so we can trivially reinstate one's status\\n     * @param subRegistryName The name of the subregistry\\n     */\\n    function reinstateSubRegistry(bytes32 subRegistryName) public {\\n        require(curators[msg.sender], \\\"JPGR:ats:Only allowed curators\\\");\\n        subRegistries[msg.sender].subRegistry[subRegistryName].removed = false;\\n        emit ReinstateSubRegistry(msg.sender, subRegistryName);\\n    }\\n\\n    /**\\n     * @notice Get all subregistries of a curator\\n     * @param curator Address of the curator\\n     */\\n    function getSubRegistries(address curator) public view returns (string[] memory) {\\n        bytes32[] memory registryNames = subRegistries[curator].registryNames;\\n        // get non-removed registry length\\n        uint256 ctr;\\n        for (uint256 i = 0; i < registryNames.length; i++) {\\n            if (subRegistries[curator].subRegistry[registryNames[i]].removed) {\\n                continue;\\n            }\\n            ctr += 1;\\n        }\\n        // create new array of length non-removed\\n        string[] memory registryStrings = new string[](ctr);\\n        ctr = 0;\\n        for (uint256 i = 0; i < registryNames.length; i++) {\\n            // add to array if non-removed\\n            if (subRegistries[curator].subRegistry[registryNames[i]].removed) {\\n                continue;\\n            }\\n            registryStrings[ctr] = Helpers.bytes32ToString(registryNames[i]);\\n            ctr += 1;\\n        }\\n        return registryStrings;\\n    }\\n\\n    /**\\n     * @notice Called by a curator to remove from their subregistry\\n     * @param subRegistryName name of the subregistry to remove it from\\n     * @param token An instance of an NFT struct\\n     */\\n    function removeFromSubregistry(bytes32 subRegistryName, NFT calldata token) public {\\n        require(curators[msg.sender], \\\"JPGR:rfs:Only allowed curators\\\");\\n        subRegistries[msg.sender].subRegistry[subRegistryName].nfts[token.tokenContract][token.tokenId].active = false;\\n        emit RemoveNFTFromSubRegistry(msg.sender, subRegistryName, token);\\n    }\\n\\n    /**\\n     * @notice Called publicly to determine if NFT is in curator subregistry\\n     * @param nft An instance of an NFT struct\\n     * @param curator Address of a curator\\n     */\\n    function inSubRegistry(\\n        bytes32 subRegistryName,\\n        NFT calldata nft,\\n        address curator\\n    ) public view returns (bool) {\\n        return\\n            mainRegistry[nft.tokenContract][nft.tokenId] &&\\n            !subRegistries[curator].subRegistry[subRegistryName].removed &&\\n            subRegistries[curator].subRegistry[subRegistryName].nfts[nft.tokenContract][nft.tokenId].active;\\n    }\\n\\n    /**\\n     * @notice Called by contract owner admin to add a curator the the list of allowed curators\\n     * @param curator wallet address to add to allow-list of curators\\n     */\\n    function allowCurator(address curator) public onlyOwner {\\n        curators[curator] = true;\\n        subRegistries[curator].feePercentage = CURATOR_TAKE_PER_10000;\\n        emit CuratorAdded(curator);\\n    }\\n\\n    /**\\n     * @notice Public function for curator to set their curation fee as a whole number\\n     * percentage added to the owner list price.\\n     * @param feePercentage Fee percentage, with a base of 10000 == 100%\\n     */\\n    function setCuratorFee(uint16 feePercentage) public {\\n        require(curators[msg.sender], \\\"JPGR:scf:Curator only\\\");\\n        require(feePercentage <= MAX_FEE_PERC, \\\"JPGR:scf:Fee exceeds MAX_FEE\\\");\\n        subRegistries[msg.sender].feePercentage = feePercentage;\\n    }\\n\\n    /**\\n     * @notice Called by contract owner admin to bulk add NFTs to ProtocolRegistry\\n     * @dev This saves listers gas by keeping things off-chain until a bulk add task is run\\n     * @param ownerBundles[] An array of OwnerBundle struct instances\\n     */\\n    function adminBulkAddToMainRegistry(OwnerBundle[] memory ownerBundles) public onlyOwner {\\n        for (uint256 j = 0; j < ownerBundles.length; j++) {\\n            Listing[] memory listings = ownerBundles[j].listings;\\n\\n            for (uint256 i = 0; i < listings.length; i++) {\\n                mainRegistry[listings[i].nft.tokenContract][listings[i].nft.tokenId] = true;\\n            }\\n        }\\n\\n        emit TokensListed(ownerBundles);\\n    }\\n\\n    /**\\n     * @notice Called by contract owner admin to bulk remove NFTs from ProtocolRegistry\\n     * @param tokens[] An array of NFT struct instances\\n     */\\n    function bulkRemoveFromMainRegistry(NFT[] calldata tokens) public onlyOwner {\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            _removeFromMainRegistry(tokens[i]);\\n        }\\n    }\\n\\n    /**\\n     * @notice Called internally to remove from ProtocolRegistry\\n     * @param token An instance of an NFT struct\\n     */\\n    function _removeFromMainRegistry(NFT memory token) internal {\\n        mainRegistry[token.tokenContract][token.tokenId] = false;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal initializer {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value < 2**128, \\\"SafeCast: value doesn\\\\'t fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value < 2**64, \\\"SafeCast: value doesn\\\\'t fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value < 2**32, \\\"SafeCast: value doesn\\\\'t fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value < 2**16, \\\"SafeCast: value doesn\\\\'t fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value < 2**8, \\\"SafeCast: value doesn\\\\'t fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128) {\\n        require(value >= -2**127 && value < 2**127, \\\"SafeCast: value doesn\\\\'t fit in 128 bits\\\");\\n        return int128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64) {\\n        require(value >= -2**63 && value < 2**63, \\\"SafeCast: value doesn\\\\'t fit in 64 bits\\\");\\n        return int64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32) {\\n        require(value >= -2**31 && value < 2**31, \\\"SafeCast: value doesn\\\\'t fit in 32 bits\\\");\\n        return int32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16) {\\n        require(value >= -2**15 && value < 2**15, \\\"SafeCast: value doesn\\\\'t fit in 16 bits\\\");\\n        return int16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8) {\\n        require(value >= -2**7 && value < 2**7, \\\"SafeCast: value doesn\\\\'t fit in 8 bits\\\");\\n        return int8(value);\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        require(value < 2**255, \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Interfaces/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma experimental ABIEncoderV2;\\npragma solidity >=0.8.0 <0.9.0;\\n\\ninterface ERC721 {\\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\\n    ///  may be created and assigned without emitting Transfer. At the time of\\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\\n\\n    /// @dev This emits when the approved address for an NFT is changed or\\n    ///  reaffirmed. The zero address indicates there is no approved address.\\n    ///  When a Transfer event emits, this also indicates that the approved\\n    ///  address for that NFT (if any) is reset to none.\\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\\n\\n    /// @dev This emits when an operator is enabled or disabled for an owner.\\n    ///  The operator can manage all NFTs of the owner.\\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\\n\\n    /// @notice Count all NFTs assigned to an owner\\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\\n    ///  function throws for queries about the zero address.\\n    /// @param _owner An address for whom to query the balance\\n    /// @return The number of NFTs owned by `_owner`, possibly zero\\n    function balanceOf(address _owner) external view returns (uint256);\\n\\n    /// @notice Find the owner of an NFT\\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\\n    ///  about them do throw.\\n    /// @param _tokenId The identifier for an NFT\\n    /// @return The address of the owner of the NFT\\n    function ownerOf(uint256 _tokenId) external view returns (address);\\n\\n    /// @notice Transfers the ownership of an NFT from one address to another address\\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\\n    ///  `onERC721Received` on `_to` and throws if the return value is not\\n    ///  `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\n    /// @param _from The current owner of the NFT\\n    /// @param _to The new owner\\n    /// @param _tokenId The NFT to transfer\\n    /// @param data Additional data with no specified format, sent in call to `_to`\\n    function safeTransferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _tokenId,\\n        bytes calldata data\\n    ) external payable;\\n\\n    /// @notice Transfers the ownership of an NFT from one address to another address\\n    /// @dev This works identically to the other function with an extra data parameter,\\n    ///  except this function just sets data to \\\"\\\".\\n    /// @param _from The current owner of the NFT\\n    /// @param _to The new owner\\n    /// @param _tokenId The NFT to transfer\\n    function safeTransferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _tokenId\\n    ) external payable;\\n\\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\\n    ///  THEY MAY BE PERMANENTLY LOST\\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\\n    ///  `_tokenId` is not a valid NFT.\\n    /// @param _from The current owner of the NFT\\n    /// @param _to The new owner\\n    /// @param _tokenId The NFT to transfer\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _tokenId\\n    ) external payable;\\n\\n    /// @notice Change or reaffirm the approved address for an NFT\\n    /// @dev The zero address indicates there is no approved address.\\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\\n    ///  operator of the current owner.\\n    /// @param _approved The new approved NFT controller\\n    /// @param _tokenId The NFT to approve\\n    function approve(address _approved, uint256 _tokenId) external payable;\\n\\n    /// @notice Enable or disable approval for a third party (\\\"operator\\\") to manage\\n    ///  all of `msg.sender`'s assets\\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\\n    ///  multiple operators per owner.\\n    /// @param _operator Address to add to the set of authorized operators\\n    /// @param _approved True if the operator is approved, false to revoke approval\\n    function setApprovalForAll(address _operator, bool _approved) external;\\n\\n    /// @notice Get the approved address for a single NFT\\n    /// @dev Throws if `_tokenId` is not a valid NFT.\\n    /// @param _tokenId The NFT to find the approved address for\\n    /// @return The approved address for this NFT, or the zero address if there is none\\n    function getApproved(uint256 _tokenId) external view returns (address);\\n\\n    /// @notice Query if an address is an authorized operator for another address\\n    /// @param _owner The address that owns the NFTs\\n    /// @param _operator The address that acts on behalf of the owner\\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/Libraries/SignedMessage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\ncontract SignedMessage {\\n    function getMessageHash(address _tokenContract, uint256 _tokenId) public view returns (bytes32) {\\n        return keccak256(abi.encodePacked(_tokenContract, _tokenId, address(this)));\\n    }\\n\\n    function getEthSignedMessageHash(bytes32 _messageHash) public pure returns (bytes32) {\\n        /*\\n        Signature is produced by signing a keccak256 hash with the following format:\\n        \\\"\\\\x19Ethereum Signed Message\\\\n\\\" + len(msg) + msg\\n        */\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", _messageHash));\\n    }\\n\\n    function getSigner(\\n        address _tokenContract,\\n        uint256 _tokenId,\\n        bytes memory signature\\n    ) public view returns (address) {\\n        bytes32 messageHash = getMessageHash(_tokenContract, _tokenId);\\n        bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);\\n        return recoverSigner(ethSignedMessageHash, signature);\\n    }\\n\\n    function recoverSigner(bytes32 _ethSignedMessageHash, bytes memory _signature) public pure returns (address) {\\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\\n\\n        return ecrecover(_ethSignedMessageHash, v, r, s);\\n    }\\n\\n    function splitSignature(bytes memory sig)\\n        public\\n        pure\\n        returns (\\n            bytes32 r,\\n            bytes32 s,\\n            uint8 v\\n        )\\n    {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            r := mload(add(sig, 32))\\n            s := mload(add(sig, 64))\\n            v := byte(0, mload(add(sig, 96)))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Libraries/Helpers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\ncontract Helpers {\\n    function bytes32ToString(bytes32 _bytes32) public pure returns (string memory) {\\n        uint8 i = 0;\\n        while (i < 32 && _bytes32[i] != 0) {\\n            i++;\\n        }\\n        bytes memory bytesArray = new bytes(i);\\n        for (i = 0; i < 32 && _bytes32[i] != 0; i++) {\\n            bytesArray[i] = _bytes32[i];\\n        }\\n        return string(bytesArray);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"curator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"note\",\"type\":\"string\"}],\"indexed\":false,\"internalType\":\"struct JPGRegistry.CuratedNFT\",\"name\":\"token\",\"type\":\"tuple\"}],\"name\":\"AddNFTToSubRegistry\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"curator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"}],\"name\":\"CreateSubRegistry\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"curator\",\"type\":\"address\"}],\"name\":\"CuratorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"curator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"}],\"name\":\"ReinstateSubRegistry\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"curator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct JPGRegistry.NFT\",\"name\":\"token\",\"type\":\"tuple\"}],\"name\":\"RemoveNFTFromSubRegistry\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"curator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"}],\"name\":\"RemoveSubRegistry\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct JPGRegistry.NFT\",\"name\":\"token\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"curator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"TokenListedForSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct JPGRegistry.NFT\",\"name\":\"token\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"curator\",\"type\":\"address\"}],\"name\":\"TokenSold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"signedMessage\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct JPGRegistry.NFT\",\"name\":\"nft\",\"type\":\"tuple\"}],\"internalType\":\"struct JPGRegistry.Listing[]\",\"name\":\"listings\",\"type\":\"tuple[]\"}],\"indexed\":false,\"internalType\":\"struct JPGRegistry.OwnerBundle[]\",\"name\":\"bundles\",\"type\":\"tuple[]\"}],\"name\":\"TokensListed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"curator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"}],\"name\":\"UpdateSubRegistry\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"subRegistryName\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct JPGRegistry.NFT[]\",\"name\":\"tokens\",\"type\":\"tuple[]\"},{\"internalType\":\"string[]\",\"name\":\"notes\",\"type\":\"string[]\"}],\"name\":\"addToSubregistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"signedMessage\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct JPGRegistry.NFT\",\"name\":\"nft\",\"type\":\"tuple\"}],\"internalType\":\"struct JPGRegistry.Listing[]\",\"name\":\"listings\",\"type\":\"tuple[]\"}],\"internalType\":\"struct JPGRegistry.OwnerBundle[]\",\"name\":\"ownerBundles\",\"type\":\"tuple[]\"}],\"name\":\"adminBulkAddToMainRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"curator\",\"type\":\"address\"}],\"name\":\"allowCurator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct JPGRegistry.NFT[]\",\"name\":\"tokens\",\"type\":\"tuple[]\"}],\"name\":\"bulkAddToMainRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct JPGRegistry.NFT[]\",\"name\":\"tokens\",\"type\":\"tuple[]\"},{\"internalType\":\"uint96[]\",\"name\":\"prices\",\"type\":\"uint96[]\"},{\"internalType\":\"address\",\"name\":\"curator\",\"type\":\"address\"}],\"name\":\"bulkListForSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct JPGRegistry.NFT[]\",\"name\":\"tokens\",\"type\":\"tuple[]\"}],\"name\":\"bulkRemoveFromMainRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"subRegistryName\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct JPGRegistry.NFT\",\"name\":\"token\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"curator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"buyFixedPrice\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_bytes32\",\"type\":\"bytes32\"}],\"name\":\"bytes32ToString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"subRegistryName\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"subRegistryDescription\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct JPGRegistry.NFT[]\",\"name\":\"tokens\",\"type\":\"tuple[]\"},{\"internalType\":\"string[]\",\"name\":\"notes\",\"type\":\"string[]\"}],\"name\":\"createSubregistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"curators\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_messageHash\",\"type\":\"bytes32\"}],\"name\":\"getEthSignedMessageHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getMessageHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"subRegistryName\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct JPGRegistry.NFT\",\"name\":\"token\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"curator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getPrice\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"artistTake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"curatorTake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellerTake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellPrice\",\"type\":\"uint256\"}],\"internalType\":\"struct JPGRegistry.ListingPrice\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"getSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"curator\",\"type\":\"address\"}],\"name\":\"getSubRegistries\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"subRegistryName\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct JPGRegistry.NFT\",\"name\":\"nft\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"curator\",\"type\":\"address\"}],\"name\":\"inSubRegistry\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct JPGRegistry.NFT\",\"name\":\"token\",\"type\":\"tuple\"},{\"internalType\":\"uint96\",\"name\":\"price\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"curator\",\"type\":\"address\"}],\"name\":\"listForSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mainRegistry\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_ethSignedMessageHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"recoverSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"subRegistryName\",\"type\":\"bytes32\"}],\"name\":\"reinstateSubRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"signedMessage\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct JPGRegistry.NFT\",\"name\":\"nft\",\"type\":\"tuple\"}],\"internalType\":\"struct JPGRegistry.Listing\",\"name\":\"listing\",\"type\":\"tuple\"}],\"name\":\"removeFromMainRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"subRegistryName\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct JPGRegistry.NFT\",\"name\":\"token\",\"type\":\"tuple\"}],\"name\":\"removeFromSubregistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"subRegistryName\",\"type\":\"bytes32\"}],\"name\":\"removeSubRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"feePercentage\",\"type\":\"uint16\"}],\"name\":\"setCuratorFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"splitSignature\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"subRegistryName\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"subRegistryDescription\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct JPGRegistry.NFT[]\",\"name\":\"tokensToUpsert\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct JPGRegistry.NFT[]\",\"name\":\"tokensToRemove\",\"type\":\"tuple[]\"},{\"internalType\":\"string[]\",\"name\":\"notes\",\"type\":\"string[]\"}],\"name\":\"updateSubregistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"JPGRegistry","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}