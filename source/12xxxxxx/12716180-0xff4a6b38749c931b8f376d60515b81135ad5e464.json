{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.3;\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor () {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n\r\ncontract Governance is ReentrancyGuard {\r\n\r\n\tuint constant public governance_challenging_period = 10 days;\r\n\tuint constant public governance_freeze_period = 30 days;\r\n\r\n\taddress public votingTokenAddress;\r\n\taddress public governedContractAddress;\r\n\r\n\tmapping(address => uint) public balances;\r\n\r\n\tVotedValue[] public votedValues;\r\n\tmapping(string => VotedValue) public votedValuesMap;\r\n\r\n\r\n\tconstructor(address _governedContractAddress, address _votingTokenAddress){\r\n\t\tinit(_governedContractAddress, _votingTokenAddress);\r\n\t}\r\n\r\n\tfunction init(address _governedContractAddress, address _votingTokenAddress) public {\r\n\t\trequire(governedContractAddress == address(0), \"governance already initialized\");\r\n\t\tgovernedContractAddress = _governedContractAddress;\r\n\t\tvotingTokenAddress = _votingTokenAddress;\r\n\t}\r\n\r\n\tfunction addressBelongsToGovernance(address addr) public view returns (bool) {\r\n\t\tfor (uint i = 0; i < votedValues.length; i++)\r\n\t\t\tif (address(votedValues[i]) == addr)\r\n\t\t\t\treturn true;\r\n\t\treturn false;\r\n\t}\r\n\r\n\tfunction isUntiedFromAllVotes(address addr) public view returns (bool) {\r\n\t\tfor (uint i = 0; i < votedValues.length; i++)\r\n\t\t\tif (votedValues[i].hasVote(addr))\r\n\t\t\t\treturn false;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction addVotedValue(string memory name, VotedValue votedValue) external {\r\n\t\trequire(msg.sender == governedContractAddress, \"not authorized\");\r\n\t\tvotedValues.push(votedValue);\r\n\t\tvotedValuesMap[name] = votedValue;\r\n\t}\r\n\r\n\r\n\t// deposit\r\n\r\n\tfunction deposit(uint amount) payable external {\r\n\t\tdeposit(msg.sender, amount);\r\n\t}\r\n\r\n\tfunction deposit(address from, uint amount) nonReentrant payable public {\r\n\t\trequire(from == msg.sender || addressBelongsToGovernance(msg.sender), \"not allowed\");\r\n\t\tif (votingTokenAddress == address(0))\r\n\t\t\trequire(msg.value == amount, \"wrong amount received\");\r\n\t\telse {\r\n\t\t\trequire(msg.value == 0, \"don't send ETH\");\r\n\t\t\trequire(IERC20(votingTokenAddress).transferFrom(from, address(this), amount), \"failed to pull gov deposit\");\r\n\t\t}\r\n\t\tbalances[from] += amount;\r\n\t}\r\n\r\n\r\n\t// withdrawal functions\r\n\r\n\tfunction withdraw() external {\r\n\t\twithdraw(balances[msg.sender]);\r\n\t}\r\n\r\n\tfunction withdraw(uint amount) nonReentrant public {\r\n\t\trequire(amount > 0, \"zero withdrawal requested\");\r\n\t\trequire(amount <= balances[msg.sender], \"not enough balance\");\r\n\t\trequire(isUntiedFromAllVotes(msg.sender), \"some votes not removed yet\");\r\n\t\tbalances[msg.sender] -= amount;\r\n\t\tif (votingTokenAddress == address(0))\r\n\t\t\tpayable(msg.sender).transfer(amount);\r\n\t\telse\r\n\t\t\trequire(IERC20(votingTokenAddress).transfer(msg.sender, amount), \"failed to withdraw gov deposit\");\r\n\t}\r\n}\r\n\r\n\r\nabstract contract VotedValue is ReentrancyGuard {\r\n\tGovernance public governance;\r\n\tuint public challenging_period_start_ts;\r\n\tmapping(address => bool) public hasVote;\r\n\r\n\tconstructor(Governance _governance){\r\n\t\tgovernance = _governance;\r\n\t}\r\n\r\n\tfunction checkVoteChangeLock() view public {\r\n\t\trequire(challenging_period_start_ts + governance.governance_challenging_period() + governance.governance_freeze_period() < block.timestamp, \"you cannot change your vote yet\");\r\n\t}\r\n\r\n\tfunction checkChallengingPeriodExpiry() view public {\r\n\t\trequire(block.timestamp > challenging_period_start_ts + governance.governance_challenging_period(), \"challenging period not expired yet\");\r\n\t}\r\n}\r\n\r\n\r\n\r\ncontract VotedValueAddress is VotedValue {\r\n\r\n\tfunction(address) external validationCallback;\r\n\tfunction(address) external commitCallback;\r\n\r\n\taddress public leader;\r\n\taddress public current_value;\r\n\r\n\t// mapping(who => value)\r\n\tmapping(address => address) public choices;\r\n\r\n\t// mapping(value => votes)\r\n\tmapping(address => uint) public votesByValue;\r\n\r\n\t// mapping(value => mapping(who => votes))\r\n\tmapping(address => mapping(address => uint)) public votesByValueAddress;\r\n\r\n\tconstructor() VotedValue(Governance(address(0))) {}\r\n\r\n\t// constructor(Governance _governance, address initial_value, function(address) external _validationCallback, function(address) external _commitCallback) VotedValue(_governance) {\r\n\t// \tleader = initial_value;\r\n\t// \tcurrent_value = initial_value;\r\n\t// \tvalidationCallback = _validationCallback;\r\n\t// \tcommitCallback = _commitCallback;\r\n\t// }\r\n\r\n\tfunction init(Governance _governance, address initial_value, function(address) external _validationCallback, function(address) external _commitCallback) external {\r\n\t\trequire(address(governance) == address(0), \"already initialized\");\r\n\t\tgovernance = _governance;\r\n\t\tleader = initial_value;\r\n\t\tcurrent_value = initial_value;\r\n\t\tvalidationCallback = _validationCallback;\r\n\t\tcommitCallback = _commitCallback;\r\n\t}\r\n\r\n\tfunction vote(address value) nonReentrant external {\r\n\t\t_vote(value);\r\n\t}\r\n\r\n\tfunction voteAndDeposit(address value, uint amount) nonReentrant payable external {\r\n\t\tgovernance.deposit{value: msg.value}(msg.sender, amount);\r\n\t\t_vote(value);\r\n\t}\r\n\r\n\tfunction _vote(address value) private {\r\n\t\tvalidationCallback(value);\r\n\t\taddress prev_choice = choices[msg.sender];\r\n\t\tbool hadVote = hasVote[msg.sender];\r\n\t\tif (prev_choice == leader)\r\n\t\t\tcheckVoteChangeLock();\r\n\r\n\t\t// first, remove votes from the previous choice\r\n\t\tif (hadVote)\r\n\t\t\tremoveVote(prev_choice);\r\n\r\n\t\t// then, add them to the new choice\r\n\t\tuint balance = governance.balances(msg.sender);\r\n\t\trequire(balance > 0, \"no balance\");\r\n\t\tvotesByValue[value] += balance;\r\n\t\tvotesByValueAddress[value][msg.sender] = balance;\r\n\t\tchoices[msg.sender] = value;\r\n\t\thasVote[msg.sender] = true;\r\n\r\n\t\t// check if the leader has just changed\r\n\t\tif (votesByValue[value] > votesByValue[leader]){\r\n\t\t\tleader = value;\r\n\t\t\tchallenging_period_start_ts = block.timestamp;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction unvote() external {\r\n\t\tif (!hasVote[msg.sender])\r\n\t\t\treturn;\r\n\t\taddress prev_choice = choices[msg.sender];\r\n\t\tif (prev_choice == leader)\r\n\t\t\tcheckVoteChangeLock();\r\n\t\t\r\n\t\tremoveVote(prev_choice);\r\n\t\tdelete choices[msg.sender];\r\n\t\tdelete hasVote[msg.sender];\r\n\t}\r\n\r\n\tfunction removeVote(address value) internal {\r\n\t\tvotesByValue[value] -= votesByValueAddress[value][msg.sender];\r\n\t\tvotesByValueAddress[value][msg.sender] = 0;\r\n\t}\r\n\r\n\tfunction commit() nonReentrant external {\r\n\t\trequire(leader != current_value, \"already equal to leader\");\r\n\t\tcheckChallengingPeriodExpiry();\r\n\t\tcurrent_value = leader;\r\n\t\tcommitCallback(leader);\r\n\t}\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"challenging_period_start_ts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkChallengingPeriodExpiry\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkVoteChangeLock\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"choices\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"commit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"current_value\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"contract Governance\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasVote\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Governance\",\"name\":\"_governance\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initial_value\",\"type\":\"address\"},{\"internalType\":\"function (address) external\",\"name\":\"_validationCallback\",\"type\":\"function\"},{\"internalType\":\"function (address) external\",\"name\":\"_commitCallback\",\"type\":\"function\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"leader\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unvote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"vote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"voteAndDeposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"votesByValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"votesByValueAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"VotedValueAddress","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://89ab4d99ebf4f03d623d19c7f7aa96d2b3b54db53d7200855b999fec921998c9"}]}