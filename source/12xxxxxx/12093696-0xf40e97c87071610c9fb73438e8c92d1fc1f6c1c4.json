{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/VaultView.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: GPL-3.0-or-later\\\"\\n\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\\\";\\n\\nimport \\\"./IVault.sol\\\";\\nimport \\\"./tokens/IERC20Metadata.sol\\\";\\n\\ncontract VaultView {\\n\\n    struct Vault {\\n        address self;\\n        uint256 liveTime;\\n        uint256 settleTime;\\n        int256 underlyingStart;\\n        int256 underlyingEnd;\\n        uint256 primaryConversion;\\n        uint256 complementConversion;\\n        uint256 protocolFee;\\n        uint256 authorFeeLimit;\\n        uint256 state;\\n        address oracle;\\n        uint oracleDecimals;\\n        address oracleIterator;\\n        address collateralSplit;\\n    }\\n\\n    struct Token {\\n        address self;\\n        string name;\\n        string symbol;\\n        uint8 decimals;\\n        uint userBalance;\\n    }\\n\\n    struct DerivativeSpecification {\\n        address self;\\n        string name;\\n        string symbol;\\n        uint denomination;\\n        uint authorFee;\\n        uint primaryNominalValue;\\n        uint complementNominalValue;\\n        bytes32[] oracleSymbols;\\n    }\\n\\n    function getVaultInfo(address _vault)\\n    external view\\n    returns (\\n        Vault memory vaultData,\\n        DerivativeSpecification memory derivativeSpecificationData,\\n        Token memory collateralData,\\n        uint lockedCollateralAmount,\\n        Token memory primaryData,\\n        Token memory complementData\\n    )\\n    {\\n        IVault vault = IVault(_vault);\\n\\n        int256 underlyingStarts = 0;\\n        if(uint256(vault.state()) > 0) {\\n            underlyingStarts = vault.underlyingStarts(0);\\n        }\\n\\n        int256 underlyingEnds = 0;\\n        if(vault.primaryConversion() > 0 || vault.complementConversion() > 0) {\\n            underlyingEnds = vault.underlyingEnds(0);\\n        }\\n\\n        vaultData = Vault(\\n            address(_vault),\\n            vault.liveTime(),\\n            vault.settleTime(),\\n            underlyingStarts,\\n            underlyingEnds,\\n            vault.primaryConversion(),\\n            vault.complementConversion(),\\n            vault.protocolFee(),\\n            vault.authorFeeLimit(),\\n            uint256(vault.state()),\\n            vault.oracles(0),\\n            AggregatorV3Interface(vault.oracles(0)).decimals(),\\n            vault.oracleIterators(0),\\n            vault.collateralSplit()\\n        );\\n\\n        IDerivativeSpecification specification = vault.derivativeSpecification();\\n        derivativeSpecificationData = DerivativeSpecification(\\n            address(specification),\\n            specification.name(),\\n            specification.symbol(),\\n            specification.primaryNominalValue() + specification.complementNominalValue(),\\n            specification.authorFee(),\\n            specification.primaryNominalValue(),\\n            specification.complementNominalValue(),\\n            specification.oracleSymbols()\\n        );\\n\\n        IERC20Metadata collateral = IERC20Metadata(vault.collateralToken());\\n        IERC20 collateralToken = IERC20(address(collateral));\\n        collateralData = Token(\\n            address(collateral),\\n            collateral.name(),\\n            collateral.symbol(),\\n            collateral.decimals(),\\n            collateralToken.balanceOf(msg.sender)\\n        );\\n        lockedCollateralAmount = collateralToken.balanceOf(address(vault));\\n\\n        IERC20Metadata primary = IERC20Metadata(vault.primaryToken());\\n        primaryData = Token(\\n            address(primary),\\n            primary.name(),\\n            primary.symbol(),\\n            primary.decimals(),\\n            IERC20(address(primary)).balanceOf(msg.sender)\\n        );\\n\\n        IERC20Metadata complement = IERC20Metadata(vault.complementToken());\\n        complementData = Token(\\n            address(complement),\\n            complement.name(),\\n            complement.symbol(),\\n            complement.decimals(),\\n            IERC20(address(complement)).balanceOf(msg.sender)\\n        );\\n    }\\n\\n    function getVaultTokenBalancesByOwner(\\n        address _owner,\\n        address[] calldata _vaults\\n    )\\n        external\\n        view\\n        returns (uint256[] memory primaries, uint256[] memory complements)\\n    {\\n        primaries = new uint256[](_vaults.length);\\n        complements = new uint256[](_vaults.length);\\n\\n        IVault vault;\\n        for (uint256 i = 0; i < _vaults.length; i++) {\\n            vault = IVault(_vaults[i]);\\n            primaries[i] = IERC20(vault.primaryToken()).balanceOf(_owner);\\n            complements[i] = IERC20(vault.complementToken()).balanceOf(_owner);\\n        }\\n    }\\n\\n    function getERC20BalancesByOwner(address _owner, address[] calldata _tokens)\\n        external\\n        view\\n        returns (uint256[] memory balances)\\n    {\\n        balances = new uint256[](_tokens.length);\\n\\n        for (uint256 i = 0; i < _tokens.length; i++) {\\n            balances[i] = IERC20(_tokens[i]).balanceOf(_owner);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0;\\n\\ninterface AggregatorV3Interface {\\n\\n  function decimals() external view returns (uint8);\\n  function description() external view returns (string memory);\\n  function version() external view returns (uint256);\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n}\\n\"\r\n    },\r\n    \"contracts/IVault.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: GPL-3.0-or-later\\\"\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"./IDerivativeSpecification.sol\\\";\\n\\n/// @title Derivative implementation Vault\\n/// @notice A smart contract that references derivative specification and enables users to mint and redeem the derivative\\ninterface IVault {\\n    enum State { Created, Live, Settled }\\n\\n    /// @notice start of live period\\n    function liveTime() external view returns (uint256);\\n\\n    /// @notice end of live period\\n    function settleTime() external view returns (uint256);\\n\\n    /// @notice redeem function can only be called after the end of the Live period + delay\\n    function settlementDelay() external view returns (uint256);\\n\\n    /// @notice underlying value at the start of live period\\n    function underlyingStarts(uint256 index) external view returns (int256);\\n\\n    /// @notice underlying value at the end of live period\\n    function underlyingEnds(uint256 index) external view returns (int256);\\n\\n    /// @notice primary token conversion rate multiplied by 10 ^ 12\\n    function primaryConversion() external view returns (uint256);\\n\\n    /// @notice complement token conversion rate multiplied by 10 ^ 12\\n    function complementConversion() external view returns (uint256);\\n\\n    /// @notice protocol fee multiplied by 10 ^ 12\\n    function protocolFee() external view returns (uint256);\\n\\n    /// @notice limit on author fee multiplied by 10 ^ 12\\n    function authorFeeLimit() external view returns (uint256);\\n\\n    // @notice protocol's fee receiving wallet\\n    function feeWallet() external view returns (address);\\n\\n    // @notice current state of the vault\\n    function state() external view returns (State);\\n\\n    // @notice derivative specification address\\n    function derivativeSpecification()\\n        external\\n        view\\n        returns (IDerivativeSpecification);\\n\\n    // @notice collateral token address\\n    function collateralToken() external view returns (address);\\n\\n    // @notice oracle address\\n    function oracles(uint256 index) external view returns (address);\\n\\n    function oracleIterators(uint256 index) external view returns (address);\\n\\n    // @notice collateral split address\\n    function collateralSplit() external view returns (address);\\n\\n    // @notice derivative's token builder strategy address\\n    function tokenBuilder() external view returns (address);\\n\\n    function feeLogger() external view returns (address);\\n\\n    // @notice primary token address\\n    function primaryToken() external view returns (address);\\n\\n    // @notice complement token address\\n    function complementToken() external view returns (address);\\n\\n    /// @notice Switch to Settled state if appropriate time threshold is passed and\\n    /// set underlyingStarts value and set underlyingEnds value,\\n    /// calculate primaryConversion and complementConversion params\\n    /// @dev Reverts if underlyingStart or underlyingEnd are not available\\n    /// Vault cannot settle when it paused\\n    function settle(uint256[] calldata _underlyingEndRoundHints) external;\\n\\n    function mintTo(address _recipient, uint256 _collateralAmount) external;\\n\\n    /// @notice Mints primary and complement derivative tokens\\n    /// @dev Checks and switches to the right state and does nothing if vault is not in Live state\\n    function mint(uint256 _collateralAmount) external;\\n\\n    /// @notice Refund equal amounts of derivative tokens for collateral at any time\\n    function refund(uint256 _tokenAmount) external;\\n\\n    function refundTo(address _recipient, uint256 _tokenAmount) external;\\n\\n    function redeemTo(\\n        address _recipient,\\n        uint256 _primaryTokenAmount,\\n        uint256 _complementTokenAmount,\\n        uint256[] calldata _underlyingEndRoundHints\\n    ) external;\\n\\n    /// @notice Redeems unequal amounts previously calculated conversions if the vault is in Settled state\\n    function redeem(\\n        uint256 _primaryTokenAmount,\\n        uint256 _complementTokenAmount,\\n        uint256[] calldata _underlyingEndRoundHints\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/IERC20Metadata.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: GPL-3.0-or-later\\\"\\n\\npragma solidity 0.7.6;\\n\\ninterface IERC20Metadata {\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/IDerivativeSpecification.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: GPL-3.0-or-later\\\"\\n\\npragma solidity 0.7.6;\\n\\n/// @title Derivative Specification interface\\n/// @notice Immutable collection of derivative attributes\\n/// @dev Created by the derivative's author and published to the DerivativeSpecificationRegistry\\ninterface IDerivativeSpecification {\\n    /// @notice Proof of a derivative specification\\n    /// @dev Verifies that contract is a derivative specification\\n    /// @return true if contract is a derivative specification\\n    function isDerivativeSpecification() external pure returns (bool);\\n\\n    /// @notice Set of oracles that are relied upon to measure changes in the state of the world\\n    /// between the start and the end of the Live period\\n    /// @dev Should be resolved through OracleRegistry contract\\n    /// @return oracle symbols\\n    function oracleSymbols() external view returns (bytes32[] memory);\\n\\n    /// @notice Algorithm that, for the type of oracle used by the derivative,\\n    /// finds the value closest to a given timestamp\\n    /// @dev Should be resolved through OracleIteratorRegistry contract\\n    /// @return oracle iterator symbols\\n    function oracleIteratorSymbols() external view returns (bytes32[] memory);\\n\\n    /// @notice Type of collateral that users submit to mint the derivative\\n    /// @dev Should be resolved through CollateralTokenRegistry contract\\n    /// @return collateral token symbol\\n    function collateralTokenSymbol() external view returns (bytes32);\\n\\n    /// @notice Mapping from the change in the underlying variable (as defined by the oracle)\\n    /// and the initial collateral split to the final collateral split\\n    /// @dev Should be resolved through CollateralSplitRegistry contract\\n    /// @return collateral split symbol\\n    function collateralSplitSymbol() external view returns (bytes32);\\n\\n    /// @notice Lifecycle parameter that define the length of the derivative's Live period.\\n    /// @dev Set in seconds\\n    /// @return live period value\\n    function livePeriod() external view returns (uint256);\\n\\n    /// @notice Parameter that determines starting nominal value of primary asset\\n    /// @dev Units of collateral theoretically swappable for 1 unit of primary asset\\n    /// @return primary nominal value\\n    function primaryNominalValue() external view returns (uint256);\\n\\n    /// @notice Parameter that determines starting nominal value of complement asset\\n    /// @dev Units of collateral theoretically swappable for 1 unit of complement asset\\n    /// @return complement nominal value\\n    function complementNominalValue() external view returns (uint256);\\n\\n    /// @notice Minting fee rate due to the author of the derivative specification.\\n    /// @dev Percentage fee multiplied by 10 ^ 12\\n    /// @return author fee\\n    function authorFee() external view returns (uint256);\\n\\n    /// @notice Symbol of the derivative\\n    /// @dev Should be resolved through DerivativeSpecificationRegistry contract\\n    /// @return derivative specification symbol\\n    function symbol() external view returns (string memory);\\n\\n    /// @notice Return optional long name of the derivative\\n    /// @dev Isn't used directly in the protocol\\n    /// @return long name\\n    function name() external view returns (string memory);\\n\\n    /// @notice Optional URI to the derivative specs\\n    /// @dev Isn't used directly in the protocol\\n    /// @return URI to the derivative specs\\n    function baseURI() external view returns (string memory);\\n\\n    /// @notice Derivative spec author\\n    /// @dev Used to set and receive author's fee\\n    /// @return address of the author\\n    function author() external view returns (address);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"}],\"name\":\"getERC20BalancesByOwner\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"getVaultInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"self\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liveTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"settleTime\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"underlyingStart\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"underlyingEnd\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"primaryConversion\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"complementConversion\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"authorFeeLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"state\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"oracleDecimals\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"oracleIterator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralSplit\",\"type\":\"address\"}],\"internalType\":\"struct VaultView.Vault\",\"name\":\"vaultData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"self\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"denomination\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"authorFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"primaryNominalValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"complementNominalValue\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"oracleSymbols\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct VaultView.DerivativeSpecification\",\"name\":\"derivativeSpecificationData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"self\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"userBalance\",\"type\":\"uint256\"}],\"internalType\":\"struct VaultView.Token\",\"name\":\"collateralData\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"lockedCollateralAmount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"self\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"userBalance\",\"type\":\"uint256\"}],\"internalType\":\"struct VaultView.Token\",\"name\":\"primaryData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"self\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"userBalance\",\"type\":\"uint256\"}],\"internalType\":\"struct VaultView.Token\",\"name\":\"complementData\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_vaults\",\"type\":\"address[]\"}],\"name\":\"getVaultTokenBalancesByOwner\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"primaries\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"complements\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"VaultView","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}