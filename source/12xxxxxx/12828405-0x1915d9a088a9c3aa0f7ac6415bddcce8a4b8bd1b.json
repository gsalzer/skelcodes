{"status":"1","message":"OK","result":[{"SourceCode":"// Sources flattened with hardhat v2.3.3 https://hardhat.org\r\n\r\n// File contracts/interfaces/IArmorClient.sol\r\n\r\npragma solidity 0.8.4;\r\n\r\ninterface IArmorClient {\r\n    function submitProofOfLoss(uint256[] calldata _ids) external;\r\n}\r\n\r\n\r\n// File contracts/interfaces/IArmorMaster.sol\r\n\r\npragma solidity 0.8.4;\r\n\r\ninterface IArmorMaster {\r\n    function registerModule(bytes32 _key, address _module) external;\r\n    function getModule(bytes32 _key) external view returns(address);\r\n    function keep() external;\r\n}\r\n\r\n\r\n// File contracts/interfaces/IBalanceManager.sol\r\n\r\npragma solidity 0.8.4;\r\n\r\ninterface IBalanceManager {\r\n  event Deposit(address indexed user, uint256 amount);\r\n  event Withdraw(address indexed user, uint256 amount);\r\n  event Loss(address indexed user, uint256 amount);\r\n  event PriceChange(address indexed user, uint256 price);\r\n  event AffiliatePaid(address indexed affiliate, address indexed referral, uint256 amount, uint256 timestamp);\r\n  event ReferralAdded(address indexed affiliate, address indexed referral, uint256 timestamp);\r\n  function expireBalance(address _user) external;\r\n  function deposit(address _referrer) external payable;\r\n  function withdraw(uint256 _amount) external;\r\n  function initialize(address _armormaster, address _devWallet) external;\r\n  function balanceOf(address _user) external view returns (uint256);\r\n  function perSecondPrice(address _user) external view returns(uint256);\r\n  function changePrice(address user, uint64 _newPricePerSec) external;\r\n}\r\n\r\n\r\n// File contracts/interfaces/IPlanManager.sol\r\n\r\npragma solidity 0.8.4;\r\n\r\ninterface IPlanManager {\r\n  // Mapping = protocol => cover amount\r\n  struct Plan {\r\n      uint64 startTime;\r\n      uint64 endTime;\r\n      uint128 length;\r\n  }\r\n  \r\n  struct ProtocolPlan {\r\n      uint64 protocolId;\r\n      uint192 amount;\r\n  }\r\n    \r\n  // Event to notify frontend of plan update.\r\n  event PlanUpdate(address indexed user, address[] protocols, uint256[] amounts, uint256 endTime);\r\n  function userCoverageLimit(address _user, address _protocol) external view returns(uint256);\r\n  function markup() external view returns(uint256);\r\n  function nftCoverPrice(address _protocol) external view returns(uint256);\r\n  function initialize(address _armorManager) external;\r\n  function changePrice(address _scAddress, uint256 _pricePerAmount) external;\r\n  function updatePlan(address[] calldata _protocols, uint256[] calldata _coverAmounts) external;\r\n  function checkCoverage(address _user, address _protocol, uint256 _hacktime, uint256 _amount) external view returns (uint256, bool);\r\n  function coverageLeft(address _protocol) external view returns(uint256);\r\n  function getCurrentPlan(address _user) external view returns(uint256 idx, uint128 start, uint128 end);\r\n  function updateExpireTime(address _user, uint256 _expiry) external;\r\n  function planRedeemed(address _user, uint256 _planIndex, address _protocol) external;\r\n  function totalUsedCover(address _scAddress) external view returns (uint256);\r\n}\r\n\r\n\r\n// File contracts/interfaces/IClaimManager.sol\r\n\r\npragma solidity 0.8.4;\r\n\r\ninterface IClaimManager {\r\n    function initialize(address _armorMaster) external;\r\n    function transferNft(address _to, uint256 _nftId) external;\r\n    function exchangeWithdrawal(uint256 _amount) external;\r\n    function redeemClaim(address _protocol, uint256 _hackTime, uint256 _amount) external;\r\n}\r\n\r\n\r\n// File contracts/interfaces/IStakeManager.sol\r\n\r\npragma solidity 0.8.4;\r\n\r\ninterface IStakeManager {\r\n    function totalStakedAmount(address protocol) external view returns(uint256);\r\n    function protocolAddress(uint64 id) external view returns(address);\r\n    function protocolId(address protocol) external view returns(uint64);\r\n    function initialize(address _armorMaster) external;\r\n    function allowedCover(address _newProtocol, uint256 _newTotalCover) external view returns (bool);\r\n    function subtractTotal(uint256 _nftId, address _protocol, uint256 _subtractAmount) external;\r\n}\r\n\r\n\r\n// File contracts/libraries/ArmorCore.sol\r\n\r\npragma solidity 0.8.4;\r\n\r\n/**\r\n * @dev ArmorCore library simplifies integration of Armor Core into other contracts. It contains most functionality needed for a contract to use arCore.\r\n**/\r\nlibrary ArmorCore {\r\n\r\n    IArmorMaster internal constant armorMaster = IArmorMaster(0x1337DEF1900cEaabf5361C3df6aF653D814c6348);\r\n\r\n    /**\r\n     * @dev Get Armor module such as BalanceManager, PlanManager, etc.\r\n     * @param _name Name of the module (such as \"BALANCE\").\r\n    **/\r\n    function getModule(bytes32 _name) internal view returns(address) {\r\n        return armorMaster.getModule(_name);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate the price per second for a specific amount of Ether.\r\n     * @param _protocol Address of protocol to protect.\r\n     * @param _coverAmount Amount of Ether to cover (in Wei). We div by 1e18 at the end because both _coverAmount and pricePerETH return are 1e18.\r\n     * @return pricePerSec Ether (in Wei) price per second of this coverage.\r\n    **/\r\n    function calculatePricePerSec(address _protocol, uint256 _coverAmount) internal view returns (uint256 pricePerSec) {\r\n        return pricePerETH(_protocol) * _coverAmount / 1e18;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate price per second for an array of protocols and amounts.\r\n     * @param _protocols Protocols to protect.\r\n     * @param _coverAmounts Amounts (in Wei) of Ether to protect.\r\n     * @return pricePerSec Ether (in Wei) price per second of this coverage,\r\n    **/\r\n    function calculatePricePerSec(address[] memory _protocols, uint256[] memory _coverAmounts) internal view returns (uint256 pricePerSec) {\r\n        require(_protocols.length == _coverAmounts.length, \"Armor: array length diff\");\r\n        for(uint256 i = 0; i<_protocols.length; i++){\r\n            pricePerSec = pricePerSec + pricePerETH(_protocols[i]) * _coverAmounts[i];\r\n        }\r\n        return pricePerSec / 1e18;\r\n    }\r\n\r\n    /**\r\n     * @dev Find amount of cover available for the specified protocol (up to amount desired).\r\n     * @param _protocol Protocol to check cover for.\r\n     * @param _amount Max amount of cover you would like.\r\n     * @return available Amount of cover that is available (in Wei) up to full amount desired.\r\n    **/\r\n    function availableCover(address _protocol, uint256 _amount) internal view returns (uint256 available) {\r\n        IPlanManager planManager = IPlanManager(getModule(\"PLAN\"));\r\n        uint256 limit = planManager.userCoverageLimit(address(this), _protocol);\r\n        return limit >= _amount ? _amount : limit;\r\n    }\r\n\r\n    /**  \r\n     * @dev Find the price per second per Ether for the protocol.\r\n     * @param _protocol Protocol we are finding the price for.\r\n     * @return pricePerSecPerETH The price per second per each full Eth for the protocol.\r\n    **/\r\n    function pricePerETH(address _protocol) internal view returns(uint256 pricePerSecPerETH) {\r\n        IPlanManager planManager = IPlanManager(getModule(\"PLAN\"));\r\n        pricePerSecPerETH = planManager.nftCoverPrice(_protocol) * planManager.markup() / 100;\r\n    }\r\n\r\n    /**\r\n     * @dev Subscribe to or update an Armor plan.\r\n     * @param _protocols Protocols to be covered for.\r\n     * @param _coverAmounts Ether amounts (in Wei) to purchase cover for. \r\n    **/\r\n    function subscribe(address[] memory _protocols, uint256[] memory _coverAmounts) internal {\r\n        IPlanManager planManager = IPlanManager(getModule(\"PLAN\"));\r\n        planManager.updatePlan(_protocols, _coverAmounts);\r\n    }\r\n\r\n    /**\r\n     * @dev Subscribe to or update an Armor plan.\r\n     * @param _protocol Protocols to be covered for.\r\n     * @param _coverAmount Ether amounts (in Wei) to purchase cover for. \r\n    **/\r\n    function subscribe(address _protocol, uint256 _coverAmount) internal {\r\n        IPlanManager planManager = IPlanManager(getModule(\"PLAN\"));\r\n        address[] memory protocols = new address[](1);\r\n        protocols[0] = _protocol;\r\n        uint256[] memory amounts = new uint256[](1);\r\n        amounts[0] = _coverAmount;\r\n        planManager.updatePlan(protocols, amounts);\r\n    }\r\n\r\n    /**\r\n     * @dev Return this contract's balance on the Armor Core BalanceManager.\r\n     * @return This contract's ablance on Armor Core.\r\n    **/\r\n    function balanceOf() internal view returns (uint256) {\r\n        IBalanceManager balanceManager = IBalanceManager(getModule(\"BALANCE\"));\r\n        return balanceManager.balanceOf( address(this) );\r\n    }\r\n\r\n    /**\r\n     * @dev Deposit funds into the BalanceManager contract.\r\n     * @param amount Amount of Ether (in Wei) to deposit into the contract.\r\n    **/\r\n    function deposit(uint256 amount) internal {\r\n        IBalanceManager balanceManager = IBalanceManager(getModule(\"BALANCE\"));\r\n        balanceManager.deposit{value:amount}(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw balance from the BalanceManager contract.\r\n     * @param amount Amount (in Wei) if Ether to withdraw from the contract.\r\n    **/\r\n    function withdraw(uint256 amount) internal {\r\n        IBalanceManager balanceManager = IBalanceManager(getModule(\"BALANCE\"));\r\n        balanceManager.withdraw(amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Claim funds after a hack has occurred on a protected protocol.\r\n     * @param _protocol The protocol that was hacked.\r\n     * @param _hackTime The Unix timestamp at which the hack occurred. Determined by Armor DAO.\r\n     * @param _amount Amount of funds to claim (in Ether Wei).\r\n    **/\r\n    function claim(address _protocol, uint256 _hackTime, uint256 _amount) internal {\r\n        IClaimManager claimManager = IClaimManager(getModule(\"CLAIM\"));\r\n        claimManager.redeemClaim(_protocol, _hackTime, _amount);\r\n    }\r\n\r\n    /**\r\n     * @dev End Armor coverage. \r\n    **/\r\n    function cancelPlan() internal {\r\n        IPlanManager planManager = IPlanManager(getModule(\"PLAN\"));\r\n        address[] memory emptyProtocols = new address[](0);\r\n        uint256[] memory emptyAmounts = new uint256[](0);\r\n        planManager.updatePlan(emptyProtocols, emptyAmounts);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/client/ArmorClient.sol\r\n\r\npragma solidity 0.8.4;\r\n\r\n/**\r\n * @dev ArmorClient is the main contract for non-Armor contracts to inherit when connecting to arCore. It contains all functionality needed for a contract to use arCore.\r\n**/\r\ncontract ArmorClient {\r\n\r\n    // Address that has permission to submit proof-of-loss. Armor will assign NFTs for this address to submit proof-of-loss for.\r\n    address public armorController;\r\n\r\n    constructor() {\r\n        armorController = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev ClaimManager calls into this contract to prompt 0 Ether transactions to addresses corresponding to NFTs that this contract must provide proof-of-loss for.\r\n     *      This is required because of Nexus' proof-of-loss system in which an amount of proof-of-loss is required to claim cover that was paid for.\r\n     *      EOAs would generally just sign a message to be sent in, but contracts send transactions to addresses corresponding to a cover ID (0xc1D000...000hex(coverId)).\r\n     * @param _addresses Ethereum addresses to send 0 Ether transactions to.\r\n    **/\r\n    function submitProofOfLoss(address payable[] calldata _addresses) external {\r\n        require(msg.sender == armorController || msg.sender == ArmorCore.getModule(\"CLAIM\"),\"Armor: only Armor controller or Claim Manager may call this function.\");\r\n        for(uint256 i = 0; i < _addresses.length; i++){\r\n            _addresses[i].transfer(0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer the address that is allowed to call sensitive Armor transactions (submitting proof-of-loss).\r\n     * @param _newController Address to set as the new Armor controller. \r\n    **/\r\n    function transferArmorController(address _newController) external {\r\n        require(msg.sender == armorController, \"Armor: only Armor controller may call this function.\");\r\n        armorController = _newController;\r\n    }\r\n\r\n}\r\n\r\n\r\n// File contracts/interfaces/IarShield.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IarShield {\r\n    function initialize(\r\n        address _oracle,\r\n        address _pToken,\r\n        address _arToken,\r\n        address _uTokenLink,\r\n        uint256[] calldata _fees,\r\n        address[] calldata _covBases\r\n    ) \r\n      external;\r\n    function locked() external view returns(bool);\r\n}\r\n\r\n\r\n// File contracts/interfaces/IController.sol\r\n\r\npragma solidity 0.8.4;\r\n\r\ninterface IController {\r\n    function bonus() external view returns (uint256);\r\n    function refFee() external view returns (uint256);\r\n    function governor() external view returns (address);\r\n    function depositAmt() external view returns (uint256);\r\n    function beneficiary() external view returns (address payable);\r\n}\r\n\r\n\r\n// File contracts/core/CoverageBase.sol\r\n\r\n// SPDX-License-Identifier: (c) Armor.Fi, 2021\r\n\r\npragma solidity 0.8.4;\r\n\r\n/**\r\n * @title Coverage Base\r\n * @notice Coverage base takes care of all Armor Core interactions for arShields.\r\n * @author Armor.fi -- Robert M.C. Forster\r\n**/\r\ncontract CoverageBase is ArmorClient {\r\n    \r\n    // Denominator for coverage percent.\r\n    uint256 public constant DENOMINATOR = 10000;\r\n\r\n    // The protocol that this contract purchases coverage for.\r\n    address public protocol;\r\n    // Percent of funds from shields to cover.\r\n    uint256 public coverPct;\r\n    // Current cost per second for all Ether on contract.\r\n    uint256 public totalCostPerSec;\r\n    // Current cost per second per Ether.\r\n    uint256 public costPerEth;\r\n    // sum of cost per Ether for every second -- cumulative lol.\r\n    uint256 public cumCost;\r\n    // Last update of cumCost.\r\n    uint256 public lastUpdate;\r\n    // Total Ether value to be protecting in the contract.\r\n    uint256 public totalEthValue;\r\n    // Separate variable from above because there may be less than coverPct coverage available.\r\n    uint256 public totalEthCoverage;\r\n  \r\n    // Value in Ether and last updates of each shield vault.\r\n    mapping (address => ShieldStats) public shieldStats;\r\n\r\n    // Controller holds governance contract.\r\n    IController public controller;\r\n    \r\n    // Every time a shield updates it saves the full contracts cumulative cost, its Ether value, and \r\n    struct ShieldStats {\r\n        uint128 lastCumCost;\r\n        uint128 ethValue;\r\n        uint128 lastUpdate;\r\n        uint128 unpaid;\r\n    }\r\n    \r\n    // Only let the governance address or the ShieldController edit these functions.\r\n    modifier onlyGov \r\n    {\r\n        require(msg.sender == controller.governor() || msg.sender == address(controller), \"Sender is not governor.\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Just used to set the controller for the coverage base.\r\n     * @param _controller ShieldController proxy address.\r\n     * @param _protocol Address of the protocol to cover (from Nexus Mutual).\r\n     * @param _coverPct Percent of the cover to purchase -- 10000 == 100%.\r\n    **/\r\n    function initialize(\r\n        address _controller,\r\n        address _protocol,\r\n        uint256 _coverPct\r\n    )\r\n      external\r\n    {\r\n        require(protocol == address(0), \"Contract already initialized.\");\r\n        controller = IController(_controller);\r\n        protocol = _protocol;\r\n        coverPct = _coverPct;\r\n    }\r\n    \r\n    // Needed to receive a claim payout.\r\n    receive() external payable {}\r\n\r\n    /**\r\n     * @notice Called by a keeper to update the amount covered by this contract on arCore.\r\n    **/\r\n    function updateCoverage()\r\n      external\r\n    {\r\n        ArmorCore.deposit(address(this).balance);\r\n        uint256 available = getAvailableCover();\r\n        ArmorCore.subscribe(protocol, available);\r\n        totalCostPerSec = getCoverageCost(available);\r\n        totalEthCoverage = available;\r\n        checkpoint();\r\n    }\r\n    \r\n    /**\r\n     * @notice arShield uses this to update the value of funds on their contract and deposit payments to here.\r\n     *      We're okay with being loose-y goose-y here in terms of making sure shields pay (no cut-offs, timeframes, etc.).\r\n     * @param _newEthValue The new Ether value of funds in the shield contract.\r\n    **/\r\n    function updateShield(\r\n        uint256 _newEthValue\r\n    )\r\n      external\r\n      payable\r\n    {\r\n        ShieldStats memory stats = shieldStats[msg.sender];\r\n        require(stats.lastUpdate > 0, \"Only arShields may access this function.\");\r\n        \r\n        // Determine how much the shield owes for the last period.\r\n        uint256 owed = getShieldOwed(msg.sender);\r\n        uint256 unpaid = owed <= msg.value ? \r\n                         0 \r\n                         : owed - msg.value;\r\n\r\n        totalEthValue = totalEthValue \r\n                        - uint256(stats.ethValue)\r\n                        + _newEthValue;\r\n\r\n        checkpoint();\r\n\r\n        shieldStats[msg.sender] = ShieldStats( \r\n                                    uint128(cumCost), \r\n                                    uint128(_newEthValue), \r\n                                    uint128(block.timestamp), \r\n                                    uint128(unpaid) \r\n                                  );\r\n    }\r\n    \r\n    /**\r\n     * @notice CoverageBase tells shield what % of current coverage it must pay.\r\n     * @param _shield Address of the shield to get owed amount for.\r\n     * @return owed Amount of Ether that the shield owes for past coverage.\r\n    **/\r\n    function getShieldOwed(\r\n        address _shield\r\n    )\r\n      public\r\n      view\r\n    returns(\r\n        uint256 owed\r\n    )\r\n    {\r\n        ShieldStats memory stats = shieldStats[_shield];\r\n        \r\n        // difference between current cumulative and cumulative at last shield update\r\n        uint256 pastDiff = cumCost - uint256(stats.lastCumCost);\r\n        uint256 currentDiff = costPerEth * ( block.timestamp - uint256(lastUpdate) );\r\n        \r\n        owed = (uint256(stats.ethValue) \r\n                  * pastDiff\r\n                  / 1 ether)\r\n                + (uint256(stats.ethValue)\r\n                  * currentDiff\r\n                  / 1 ether)\r\n                + uint256(stats.unpaid);\r\n    }\r\n    \r\n    /**\r\n     * @notice Record total values from last period and set new ones.\r\n    **/\r\n    function checkpoint()\r\n      internal\r\n    {\r\n        cumCost += costPerEth * (block.timestamp - lastUpdate);\r\n        costPerEth = totalCostPerSec\r\n                     * 1 ether \r\n                     / totalEthValue;\r\n        lastUpdate = block.timestamp;\r\n    }\r\n    \r\n    /**\r\n     * @notice Get the available amount of coverage for all shields' current values.\r\n    **/\r\n    function getAvailableCover()\r\n      public\r\n      view\r\n    returns(\r\n        uint256\r\n    )\r\n    {\r\n        uint256 ideal = totalEthValue \r\n                        * coverPct \r\n                        / DENOMINATOR;\r\n        return ArmorCore.availableCover(protocol, ideal);\r\n\r\n    }\r\n    \r\n    /**\r\n     * @notice Get the cost of coverage for all shields' current values.\r\n     * @param _amount The amount of coverage to get the cost of.\r\n    **/\r\n    function getCoverageCost(uint256 _amount)\r\n      public\r\n      view\r\n    returns(\r\n        uint256\r\n    )\r\n    {\r\n        return ArmorCore.calculatePricePerSec(protocol, _amount);\r\n    }\r\n    \r\n    /**\r\n     * @notice Check whether a new Ether value is available for purchase.\r\n     * @param _newEthValue The new Ether value of the shield.\r\n     * @return allowed True if we may purchase this much more coverage.\r\n    **/\r\n    function checkCoverage(\r\n      uint256 _newEthValue\r\n    )\r\n      public\r\n      view\r\n    returns(\r\n      bool allowed\r\n    )\r\n    {\r\n      uint256 desired = (totalEthValue \r\n                         + _newEthValue\r\n                         - uint256(shieldStats[msg.sender].ethValue) )\r\n                        * coverPct\r\n                        / DENOMINATOR;\r\n      allowed = ArmorCore.availableCover( protocol, desired ) == desired;\r\n    }\r\n\r\n    /**\r\n     * @notice Either add or delete a shield.\r\n     * @param _shield Address of the shield to edit.\r\n     * @param _active Whether we want it to be added or deleted.\r\n    **/\r\n    function editShield(\r\n        address _shield,\r\n        bool _active\r\n    )\r\n      external\r\n      onlyGov\r\n    {\r\n        // If active, set timestamp of last update to now, else delete.\r\n        if (_active) shieldStats[_shield] = ShieldStats( \r\n                                              uint128(cumCost), \r\n                                              0, \r\n                                              uint128(block.timestamp), \r\n                                              0 );\r\n        else delete shieldStats[_shield]; \r\n    }\r\n    \r\n    /**\r\n     * @notice Withdraw an amount of funds from arCore.\r\n    **/\r\n    function withdraw(address payable _beneficiary, uint256 _amount)\r\n      external\r\n      onlyGov\r\n    {\r\n        ArmorCore.withdraw(_amount);\r\n        _beneficiary.transfer(_amount);\r\n    }\r\n    \r\n    /**\r\n     * @notice Cancel entire arCore plan.\r\n    **/\r\n    function cancelCoverage()\r\n      external\r\n      onlyGov\r\n    {\r\n        ArmorCore.cancelPlan();\r\n    }\r\n    \r\n    /**\r\n     * @notice Governance may call to a redeem a claim for Ether that this contract held.\r\n     * @param _hackTime Time that the hack occurred.\r\n     * @param _amount Amount of funds to be redeemed.\r\n    **/\r\n    function redeemClaim(\r\n        uint256 _hackTime,\r\n        uint256 _amount\r\n    )\r\n      external\r\n      onlyGov\r\n    {\r\n        ArmorCore.claim(protocol, _hackTime, _amount);\r\n    }\r\n    \r\n    /**\r\n     * @notice Governance may disburse funds from a claim to the chosen shields.\r\n     * @param _shield Address of the shield to disburse funds to.\r\n     * @param _amount Amount of funds to disburse to the shield.\r\n    **/\r\n    function disburseClaim(\r\n        address payable _shield,\r\n        uint256 _amount\r\n    )\r\n      external\r\n      onlyGov\r\n    {\r\n        require(shieldStats[_shield].lastUpdate > 0 && IarShield(_shield).locked(), \"Shield is not authorized to use this contract or shield is not locked.\");\r\n        _shield.transfer(_amount);\r\n    }\r\n    \r\n    /**\r\n     * @notice Change the percent of coverage that should be bought. For example, 500 means that 50% of Ether value will be covered.\r\n     * @param _newPct New percent of coverage to be bought--1000 == 100%.\r\n    **/\r\n    function changeCoverPct(\r\n        uint256 _newPct\r\n    )\r\n      external\r\n      onlyGov\r\n    {\r\n        require(_newPct <= 10000, \"Coverage percent may not be greater than 100%.\");\r\n        coverPct = _newPct;    \r\n    }\r\n    \r\n}","ABI":"[{\"inputs\":[],\"name\":\"DENOMINATOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"armorController\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelCoverage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newPct\",\"type\":\"uint256\"}],\"name\":\"changeCoverPct\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newEthValue\",\"type\":\"uint256\"}],\"name\":\"checkCoverage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"contract IController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"costPerEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coverPct\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cumCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_shield\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"disburseClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_shield\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_active\",\"type\":\"bool\"}],\"name\":\"editShield\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAvailableCover\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getCoverageCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_shield\",\"type\":\"address\"}],\"name\":\"getShieldOwed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"owed\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_controller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_protocol\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_coverPct\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastUpdate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocol\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_hackTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"redeemClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"shieldStats\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"lastCumCost\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"ethValue\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"lastUpdate\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"unpaid\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable[]\",\"name\":\"_addresses\",\"type\":\"address[]\"}],\"name\":\"submitProofOfLoss\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalCostPerSec\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalEthCoverage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalEthValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newController\",\"type\":\"address\"}],\"name\":\"transferArmorController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateCoverage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newEthValue\",\"type\":\"uint256\"}],\"name\":\"updateShield\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"CoverageBase","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://a9bec5b5fa8140bffe08db4bb67cfbace72382be60ab11c78f828f9731db1964"}]}