{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/modules/token/TokenFunctions.sol\": {\r\n      \"content\": \"/* Copyright (C) 2020 NexusMutual.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../../interfaces/IPooledStaking.sol\\\";\\nimport \\\"../cover/QuotationData.sol\\\";\\nimport \\\"./NXMToken.sol\\\";\\nimport \\\"./TokenController.sol\\\";\\nimport \\\"./TokenData.sol\\\";\\n\\ncontract TokenFunctions is Iupgradable {\\n  using SafeMath for uint;\\n\\n  NXMToken public tk;\\n  TokenController public tc;\\n  TokenData public td;\\n  QuotationData public qd;\\n  IPooledStaking public pooledStaking;\\n\\n  event BurnCATokens(uint claimId, address addr, uint amount);\\n\\n  /**\\n   * @dev Rewards stakers on purchase of cover on smart contract.\\n   * @param _contractAddress smart contract address.\\n   * @param _coverPriceNXM cover price in NXM.\\n   */\\n  function pushStakerRewards(address _contractAddress, uint _coverPriceNXM) external onlyInternal {\\n    uint rewardValue = _coverPriceNXM.mul(td.stakerCommissionPer()).div(100);\\n    pooledStaking.accumulateReward(_contractAddress, rewardValue);\\n  }\\n\\n  /**\\n   * @dev Returns amount of NXM Tokens locked as Cover Note for given coverId.\\n   * @param _of address of the coverHolder.\\n   * @param _coverId coverId of the cover.\\n   */\\n  function getUserLockedCNTokens(address _of, uint _coverId) external view returns (uint) {\\n    return _getUserLockedCNTokens(_of, _coverId);\\n  }\\n\\n  /**\\n   * @dev to get the all the cover locked tokens of a user\\n   * @param _of is the user address in concern\\n   * @return amount locked\\n   */\\n  function getUserAllLockedCNTokens(address _of) external view returns (uint amount) {\\n    for (uint i = 0; i < qd.getUserCoverLength(_of); i++) {\\n      amount = amount.add(_getUserLockedCNTokens(_of, qd.getAllCoversOfUser(_of)[i]));\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns amount of NXM Tokens locked as Cover Note against given coverId.\\n   * @param _coverId coverId of the cover.\\n   */\\n  function getLockedCNAgainstCover(uint _coverId) external view returns (uint) {\\n    return _getLockedCNAgainstCover(_coverId);\\n  }\\n\\n  /**\\n   * @dev Change Dependent Contract Address\\n   */\\n  function changeDependentContractAddress() public {\\n    tk = NXMToken(ms.tokenAddress());\\n    td = TokenData(ms.getLatestAddress(\\\"TD\\\"));\\n    tc = TokenController(ms.getLatestAddress(\\\"TC\\\"));\\n    qd = QuotationData(ms.getLatestAddress(\\\"QD\\\"));\\n    pooledStaking = IPooledStaking(ms.getLatestAddress(\\\"PS\\\"));\\n  }\\n\\n  /**\\n   * @dev to burn the deposited cover tokens\\n   * @param coverId is id of cover whose tokens have to be burned\\n   * @return the status of the successful burning\\n   */\\n  function burnDepositCN(uint coverId) public onlyInternal returns (bool success) {\\n\\n    address _of = qd.getCoverMemberAddress(coverId);\\n    bytes32 reason = keccak256(abi.encodePacked(\\\"CN\\\", _of, coverId));\\n    uint lockedAmount = tc.tokensLocked(_of, reason);\\n\\n    (uint amount,) = td.depositedCN(coverId);\\n    amount = amount.div(2);\\n\\n    // limit burn amount to actual amount locked\\n    uint burnAmount = lockedAmount < amount ? lockedAmount : amount;\\n\\n    if (burnAmount != 0) {\\n      tc.burnLockedTokens(_of, reason, amount);\\n    }\\n\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Unlocks covernote locked against a given cover\\n   * @param coverId id of cover\\n   */\\n  function unlockCN(uint coverId) public onlyInternal {\\n    address coverHolder = qd.getCoverMemberAddress(coverId);\\n    bytes32 reason = keccak256(abi.encodePacked(\\\"CN\\\", coverHolder, coverId));\\n    uint lockedCN = tc.tokensLocked(coverHolder, reason);\\n    if (lockedCN != 0) {\\n      tc.releaseLockedTokens(coverHolder, reason, lockedCN);\\n    }\\n  }\\n\\n  /**\\n   * @dev Burns tokens used for fraudulent voting against a claim\\n   * @param claimid Claim Id.\\n   * @param _value number of tokens to be burned\\n   * @param _of Claim Assessor's address.\\n   */\\n  function burnCAToken(uint claimid, uint _value, address _of) public {\\n\\n    require(ms.checkIsAuthToGoverned(msg.sender));\\n    tc.burnLockedTokens(_of, \\\"CLA\\\", _value);\\n    emit BurnCATokens(claimid, _of, _value);\\n  }\\n\\n  /**\\n   * @dev to lock cover note tokens\\n   * @param coverNoteAmount is number of tokens to be locked\\n   * @param coverPeriod is cover period in concern\\n   * @param coverId is the cover id of cover in concern\\n   * @param _of address whose tokens are to be locked\\n   */\\n  function lockCN(\\n    uint coverNoteAmount,\\n    uint coverPeriod,\\n    uint coverId,\\n    address _of\\n  )\\n  public\\n  onlyInternal\\n  {\\n    uint gracePeriod = tc.claimSubmissionGracePeriod();\\n    uint validity = (coverPeriod * 1 days).add(gracePeriod);\\n    bytes32 reason = keccak256(abi.encodePacked(\\\"CN\\\", _of, coverId));\\n    td.setDepositCNAmount(coverId, coverNoteAmount);\\n    tc.lockOf(_of, reason, coverNoteAmount, validity);\\n  }\\n\\n  /**\\n   * @dev to check if a  member is locked for member vote\\n   * @param _of is the member address in concern\\n   * @return the boolean status\\n   */\\n  function isLockedForMemberVote(address _of) public view returns (bool) {\\n    return now < tk.isLockedForMV(_of);\\n  }\\n\\n  /**\\n   * @dev Returns amount of NXM Tokens locked as Cover Note for given coverId.\\n   * @param _coverId coverId of the cover.\\n   */\\n  function _getLockedCNAgainstCover(uint _coverId) internal view returns (uint) {\\n    address coverHolder = qd.getCoverMemberAddress(_coverId);\\n    bytes32 reason = keccak256(abi.encodePacked(\\\"CN\\\", coverHolder, _coverId));\\n    return tc.tokensLockedAtTime(coverHolder, reason, now);\\n  }\\n\\n  /**\\n   * @dev Returns amount of NXM Tokens locked as Cover Note for given coverId.\\n   * @param _of address of the coverHolder.\\n   * @param _coverId coverId of the cover.\\n   */\\n  function _getUserLockedCNTokens(address _of, uint _coverId) internal view returns (uint) {\\n    bytes32 reason = keccak256(abi.encodePacked(\\\"CN\\\", _of, _coverId));\\n    return tc.tokensLockedAtTime(_of, reason, now);\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPooledStaking.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n\\ninterface IPooledStaking {\\n\\n  function accumulateReward(address contractAddress, uint amount) external;\\n\\n  function pushBurn(address contractAddress, uint amount) external;\\n\\n  function hasPendingActions() external view returns (bool);\\n\\n  function contractStake(address contractAddress) external view returns (uint);\\n\\n  function stakerReward(address staker) external view returns (uint);\\n\\n  function stakerDeposit(address staker) external view returns (uint);\\n\\n  function stakerContractStake(address staker, address contractAddress) external view returns (uint);\\n\\n  function withdraw(uint amount) external;\\n\\n  function stakerMaxWithdrawable(address stakerAddress) external view returns (uint);\\n\\n  function withdrawReward(address stakerAddress) external;\\n}\\n\"\r\n    },\r\n    \"contracts/modules/cover/QuotationData.sol\": {\r\n      \"content\": \"/* Copyright (C) 2020 NexusMutual.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../../abstract/Iupgradable.sol\\\";\\n\\ncontract QuotationData is Iupgradable {\\n  using SafeMath for uint;\\n\\n  enum HCIDStatus {NA, kycPending, kycPass, kycFailedOrRefunded, kycPassNoCover}\\n\\n  enum CoverStatus {Active, ClaimAccepted, ClaimDenied, CoverExpired, ClaimSubmitted, Requested}\\n\\n  struct Cover {\\n    address payable memberAddress;\\n    bytes4 currencyCode;\\n    uint sumAssured;\\n    uint16 coverPeriod;\\n    uint validUntil;\\n    address scAddress;\\n    uint premiumNXM;\\n  }\\n\\n  struct HoldCover {\\n    uint holdCoverId;\\n    address payable userAddress;\\n    address scAddress;\\n    bytes4 coverCurr;\\n    uint[] coverDetails;\\n    uint16 coverPeriod;\\n  }\\n\\n  address public authQuoteEngine;\\n\\n  mapping(bytes4 => uint) internal currencyCSA;\\n  mapping(address => uint[]) internal userCover;\\n  mapping(address => uint[]) public userHoldedCover;\\n  mapping(address => bool) public refundEligible;\\n  mapping(address => mapping(bytes4 => uint)) internal currencyCSAOfSCAdd;\\n  mapping(uint => uint8) public coverStatus;\\n  mapping(uint => uint) public holdedCoverIDStatus;\\n  mapping(uint => bool) public timestampRepeated;\\n\\n\\n  Cover[] internal allCovers;\\n  HoldCover[] internal allCoverHolded;\\n\\n  uint public stlp;\\n  uint public stl;\\n  uint public pm;\\n  uint public minDays;\\n  uint public tokensRetained;\\n  address public kycAuthAddress;\\n\\n  event CoverDetailsEvent(\\n    uint indexed cid,\\n    address scAdd,\\n    uint sumAssured,\\n    uint expiry,\\n    uint premium,\\n    uint premiumNXM,\\n    bytes4 curr\\n  );\\n\\n  event CoverStatusEvent(uint indexed cid, uint8 statusNum);\\n\\n  constructor(address _authQuoteAdd, address _kycAuthAdd) public {\\n    authQuoteEngine = _authQuoteAdd;\\n    kycAuthAddress = _kycAuthAdd;\\n    stlp = 90;\\n    stl = 100;\\n    pm = 30;\\n    minDays = 30;\\n    tokensRetained = 10;\\n    allCovers.push(Cover(address(0), \\\"0x00\\\", 0, 0, 0, address(0), 0));\\n    uint[] memory arr = new uint[](1);\\n    allCoverHolded.push(HoldCover(0, address(0), address(0), 0x00, arr, 0));\\n\\n  }\\n\\n  /// @dev Adds the amount in Total Sum Assured of a given currency of a given smart contract address.\\n  /// @param _add Smart Contract Address.\\n  /// @param _amount Amount to be added.\\n  function addInTotalSumAssuredSC(address _add, bytes4 _curr, uint _amount) external onlyInternal {\\n    currencyCSAOfSCAdd[_add][_curr] = currencyCSAOfSCAdd[_add][_curr].add(_amount);\\n  }\\n\\n  /// @dev Subtracts the amount from Total Sum Assured of a given currency and smart contract address.\\n  /// @param _add Smart Contract Address.\\n  /// @param _amount Amount to be subtracted.\\n  function subFromTotalSumAssuredSC(address _add, bytes4 _curr, uint _amount) external onlyInternal {\\n    currencyCSAOfSCAdd[_add][_curr] = currencyCSAOfSCAdd[_add][_curr].sub(_amount);\\n  }\\n\\n  /// @dev Subtracts the amount from Total Sum Assured of a given currency.\\n  /// @param _curr Currency Name.\\n  /// @param _amount Amount to be subtracted.\\n  function subFromTotalSumAssured(bytes4 _curr, uint _amount) external onlyInternal {\\n    currencyCSA[_curr] = currencyCSA[_curr].sub(_amount);\\n  }\\n\\n  /// @dev Adds the amount in Total Sum Assured of a given currency.\\n  /// @param _curr Currency Name.\\n  /// @param _amount Amount to be added.\\n  function addInTotalSumAssured(bytes4 _curr, uint _amount) external onlyInternal {\\n    currencyCSA[_curr] = currencyCSA[_curr].add(_amount);\\n  }\\n\\n  /// @dev sets bit for timestamp to avoid replay attacks.\\n  function setTimestampRepeated(uint _timestamp) external onlyInternal {\\n    timestampRepeated[_timestamp] = true;\\n  }\\n\\n  /// @dev Creates a blank new cover.\\n  function addCover(\\n    uint16 _coverPeriod,\\n    uint _sumAssured,\\n    address payable _userAddress,\\n    bytes4 _currencyCode,\\n    address _scAddress,\\n    uint premium,\\n    uint premiumNXM\\n  )\\n  external\\n  onlyInternal\\n  {\\n    uint expiryDate = now.add(uint(_coverPeriod).mul(1 days));\\n    allCovers.push(Cover(_userAddress, _currencyCode,\\n      _sumAssured, _coverPeriod, expiryDate, _scAddress, premiumNXM));\\n    uint cid = allCovers.length.sub(1);\\n    userCover[_userAddress].push(cid);\\n    emit CoverDetailsEvent(cid, _scAddress, _sumAssured, expiryDate, premium, premiumNXM, _currencyCode);\\n  }\\n\\n  /// @dev create holded cover which will process after verdict of KYC.\\n  function addHoldCover(\\n    address payable from,\\n    address scAddress,\\n    bytes4 coverCurr,\\n    uint[] calldata coverDetails,\\n    uint16 coverPeriod\\n  )\\n  external\\n  onlyInternal\\n  {\\n    uint holdedCoverLen = allCoverHolded.length;\\n    holdedCoverIDStatus[holdedCoverLen] = uint(HCIDStatus.kycPending);\\n    allCoverHolded.push(HoldCover(holdedCoverLen, from, scAddress,\\n      coverCurr, coverDetails, coverPeriod));\\n    userHoldedCover[from].push(allCoverHolded.length.sub(1));\\n\\n  }\\n\\n  ///@dev sets refund eligible bit.\\n  ///@param _add user address.\\n  ///@param status indicates if user have pending kyc.\\n  function setRefundEligible(address _add, bool status) external onlyInternal {\\n    refundEligible[_add] = status;\\n  }\\n\\n  /// @dev to set current status of particular holded coverID (1 for not completed KYC,\\n  /// 2 for KYC passed, 3 for failed KYC or full refunded,\\n  /// 4 for KYC completed but cover not processed)\\n  function setHoldedCoverIDStatus(uint holdedCoverID, uint status) external onlyInternal {\\n    holdedCoverIDStatus[holdedCoverID] = status;\\n  }\\n\\n  /**\\n   * @dev to set address of kyc authentication\\n   * @param _add is the new address\\n   */\\n  function setKycAuthAddress(address _add) external onlyInternal {\\n    kycAuthAddress = _add;\\n  }\\n\\n  /// @dev Changes authorised address for generating quote off chain.\\n  function changeAuthQuoteEngine(address _add) external onlyInternal {\\n    authQuoteEngine = _add;\\n  }\\n\\n  /**\\n   * @dev Gets Uint Parameters of a code\\n   * @param code whose details we want\\n   * @return string value of the code\\n   * @return associated amount (time or perc or value) to the code\\n   */\\n  function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val) {\\n    codeVal = code;\\n\\n    if (code == \\\"STLP\\\") {\\n      val = stlp;\\n\\n    } else if (code == \\\"STL\\\") {\\n\\n      val = stl;\\n\\n    } else if (code == \\\"PM\\\") {\\n\\n      val = pm;\\n\\n    } else if (code == \\\"QUOMIND\\\") {\\n\\n      val = minDays;\\n\\n    } else if (code == \\\"QUOTOK\\\") {\\n\\n      val = tokensRetained;\\n\\n    }\\n\\n  }\\n\\n  /// @dev Gets Product details.\\n  /// @return  _minDays minimum cover period.\\n  /// @return  _PM Profit margin.\\n  /// @return  _STL short term Load.\\n  /// @return  _STLP short term load period.\\n  function getProductDetails()\\n  external\\n  view\\n  returns (\\n    uint _minDays,\\n    uint _pm,\\n    uint _stl,\\n    uint _stlp\\n  )\\n  {\\n\\n    _minDays = minDays;\\n    _pm = pm;\\n    _stl = stl;\\n    _stlp = stlp;\\n  }\\n\\n  /// @dev Gets total number covers created till date.\\n  function getCoverLength() external view returns (uint len) {\\n    return (allCovers.length);\\n  }\\n\\n  /// @dev Gets Authorised Engine address.\\n  function getAuthQuoteEngine() external view returns (address _add) {\\n    _add = authQuoteEngine;\\n  }\\n\\n  /// @dev Gets the Total Sum Assured amount of a given currency.\\n  function getTotalSumAssured(bytes4 _curr) external view returns (uint amount) {\\n    amount = currencyCSA[_curr];\\n  }\\n\\n  /// @dev Gets all the Cover ids generated by a given address.\\n  /// @param _add User's address.\\n  /// @return allCover array of covers.\\n  function getAllCoversOfUser(address _add) external view returns (uint[] memory allCover) {\\n    return (userCover[_add]);\\n  }\\n\\n  /// @dev Gets total number of covers generated by a given address\\n  function getUserCoverLength(address _add) external view returns (uint len) {\\n    len = userCover[_add].length;\\n  }\\n\\n  /// @dev Gets the status of a given cover.\\n  function getCoverStatusNo(uint _cid) external view returns (uint8) {\\n    return coverStatus[_cid];\\n  }\\n\\n  /// @dev Gets the Cover Period (in days) of a given cover.\\n  function getCoverPeriod(uint _cid) external view returns (uint32 cp) {\\n    cp = allCovers[_cid].coverPeriod;\\n  }\\n\\n  /// @dev Gets the Sum Assured Amount of a given cover.\\n  function getCoverSumAssured(uint _cid) external view returns (uint sa) {\\n    sa = allCovers[_cid].sumAssured;\\n  }\\n\\n  /// @dev Gets the Currency Name in which a given cover is assured.\\n  function getCurrencyOfCover(uint _cid) external view returns (bytes4 curr) {\\n    curr = allCovers[_cid].currencyCode;\\n  }\\n\\n  /// @dev Gets the validity date (timestamp) of a given cover.\\n  function getValidityOfCover(uint _cid) external view returns (uint date) {\\n    date = allCovers[_cid].validUntil;\\n  }\\n\\n  /// @dev Gets Smart contract address of cover.\\n  function getscAddressOfCover(uint _cid) external view returns (uint, address) {\\n    return (_cid, allCovers[_cid].scAddress);\\n  }\\n\\n  /// @dev Gets the owner address of a given cover.\\n  function getCoverMemberAddress(uint _cid) external view returns (address payable _add) {\\n    _add = allCovers[_cid].memberAddress;\\n  }\\n\\n  /// @dev Gets the premium amount of a given cover in NXM.\\n  function getCoverPremiumNXM(uint _cid) external view returns (uint _premiumNXM) {\\n    _premiumNXM = allCovers[_cid].premiumNXM;\\n  }\\n\\n  /// @dev Provides the details of a cover Id\\n  /// @param _cid cover Id\\n  /// @return memberAddress cover user address.\\n  /// @return scAddress smart contract Address\\n  /// @return currencyCode currency of cover\\n  /// @return sumAssured sum assured of cover\\n  /// @return premiumNXM premium in NXM\\n  function getCoverDetailsByCoverID1(\\n    uint _cid\\n  )\\n  external\\n  view\\n  returns (\\n    uint cid,\\n    address _memberAddress,\\n    address _scAddress,\\n    bytes4 _currencyCode,\\n    uint _sumAssured,\\n    uint premiumNXM\\n  )\\n  {\\n    return (\\n    _cid,\\n    allCovers[_cid].memberAddress,\\n    allCovers[_cid].scAddress,\\n    allCovers[_cid].currencyCode,\\n    allCovers[_cid].sumAssured,\\n    allCovers[_cid].premiumNXM\\n    );\\n  }\\n\\n  /// @dev Provides details of a cover Id\\n  /// @param _cid cover Id\\n  /// @return status status of cover.\\n  /// @return sumAssured Sum assurance of cover.\\n  /// @return coverPeriod Cover Period of cover (in days).\\n  /// @return validUntil is validity of cover.\\n  function getCoverDetailsByCoverID2(\\n    uint _cid\\n  )\\n  external\\n  view\\n  returns (\\n    uint cid,\\n    uint8 status,\\n    uint sumAssured,\\n    uint16 coverPeriod,\\n    uint validUntil\\n  )\\n  {\\n\\n    return (\\n    _cid,\\n    coverStatus[_cid],\\n    allCovers[_cid].sumAssured,\\n    allCovers[_cid].coverPeriod,\\n    allCovers[_cid].validUntil\\n    );\\n  }\\n\\n  /// @dev Provides details of a holded cover Id\\n  /// @param _hcid holded cover Id\\n  /// @return scAddress SmartCover address of cover.\\n  /// @return coverCurr currency of cover.\\n  /// @return coverPeriod Cover Period of cover (in days).\\n  function getHoldedCoverDetailsByID1(\\n    uint _hcid\\n  )\\n  external\\n  view\\n  returns (\\n    uint hcid,\\n    address scAddress,\\n    bytes4 coverCurr,\\n    uint16 coverPeriod\\n  )\\n  {\\n    return (\\n    _hcid,\\n    allCoverHolded[_hcid].scAddress,\\n    allCoverHolded[_hcid].coverCurr,\\n    allCoverHolded[_hcid].coverPeriod\\n    );\\n  }\\n\\n  /// @dev Gets total number holded covers created till date.\\n  function getUserHoldedCoverLength(address _add) external view returns (uint) {\\n    return userHoldedCover[_add].length;\\n  }\\n\\n  /// @dev Gets holded cover index by index of user holded covers.\\n  function getUserHoldedCoverByIndex(address _add, uint index) external view returns (uint) {\\n    return userHoldedCover[_add][index];\\n  }\\n\\n  /// @dev Provides the details of a holded cover Id\\n  /// @param _hcid holded cover Id\\n  /// @return memberAddress holded cover user address.\\n  /// @return coverDetails array contains SA, Cover Currency Price,Price in NXM, Expiration time of Qoute.\\n  function getHoldedCoverDetailsByID2(\\n    uint _hcid\\n  )\\n  external\\n  view\\n  returns (\\n    uint hcid,\\n    address payable memberAddress,\\n    uint[] memory coverDetails\\n  )\\n  {\\n    return (\\n    _hcid,\\n    allCoverHolded[_hcid].userAddress,\\n    allCoverHolded[_hcid].coverDetails\\n    );\\n  }\\n\\n  /// @dev Gets the Total Sum Assured amount of a given currency and smart contract address.\\n  function getTotalSumAssuredSC(address _add, bytes4 _curr) external view returns (uint amount) {\\n    amount = currencyCSAOfSCAdd[_add][_curr];\\n  }\\n\\n  //solhint-disable-next-line\\n  function changeDependentContractAddress() public {}\\n\\n  /// @dev Changes the status of a given cover.\\n  /// @param _cid cover Id.\\n  /// @param _stat New status.\\n  function changeCoverStatusNo(uint _cid, uint8 _stat) public onlyInternal {\\n    coverStatus[_cid] = _stat;\\n    emit CoverStatusEvent(_cid, _stat);\\n  }\\n\\n  /**\\n   * @dev Updates Uint Parameters of a code\\n   * @param code whose details we want to update\\n   * @param val value to set\\n   */\\n  function updateUintParameters(bytes8 code, uint val) public {\\n\\n    require(ms.checkIsAuthToGoverned(msg.sender));\\n    if (code == \\\"STLP\\\") {\\n      _changeSTLP(val);\\n\\n    } else if (code == \\\"STL\\\") {\\n\\n      _changeSTL(val);\\n\\n    } else if (code == \\\"PM\\\") {\\n\\n      _changePM(val);\\n\\n    } else if (code == \\\"QUOMIND\\\") {\\n\\n      _changeMinDays(val);\\n\\n    } else if (code == \\\"QUOTOK\\\") {\\n\\n      _setTokensRetained(val);\\n\\n    } else {\\n\\n      revert(\\\"Invalid param code\\\");\\n    }\\n\\n  }\\n\\n  /// @dev Changes the existing Profit Margin value\\n  function _changePM(uint _pm) internal {\\n    pm = _pm;\\n  }\\n\\n  /// @dev Changes the existing Short Term Load Period (STLP) value.\\n  function _changeSTLP(uint _stlp) internal {\\n    stlp = _stlp;\\n  }\\n\\n  /// @dev Changes the existing Short Term Load (STL) value.\\n  function _changeSTL(uint _stl) internal {\\n    stl = _stl;\\n  }\\n\\n  /// @dev Changes the existing Minimum cover period (in days)\\n  function _changeMinDays(uint _days) internal {\\n    minDays = _days;\\n  }\\n\\n  /**\\n   * @dev to set the the amount of tokens retained\\n   * @param val is the amount retained\\n   */\\n  function _setTokensRetained(uint val) internal {\\n    tokensRetained = val;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/token/NXMToken.sol\": {\r\n      \"content\": \"/* Copyright (C) 2020 NexusMutual.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"./external/OZIERC20.sol\\\";\\nimport \\\"./external/OZSafeMath.sol\\\";\\n\\ncontract NXMToken is OZIERC20 {\\n  using OZSafeMath for uint256;\\n\\n  event WhiteListed(address indexed member);\\n\\n  event BlackListed(address indexed member);\\n\\n  mapping(address => uint256) private _balances;\\n\\n  mapping(address => mapping(address => uint256)) private _allowed;\\n\\n  mapping(address => bool) public whiteListed;\\n\\n  mapping(address => uint) public isLockedForMV;\\n\\n  uint256 private _totalSupply;\\n\\n  string public name = \\\"NXM\\\";\\n  string public symbol = \\\"NXM\\\";\\n  uint8 public decimals = 18;\\n  address public operator;\\n\\n  modifier canTransfer(address _to) {\\n    require(whiteListed[_to]);\\n    _;\\n  }\\n\\n  modifier onlyOperator() {\\n    if (operator != address(0))\\n      require(msg.sender == operator);\\n    _;\\n  }\\n\\n  constructor(address _founderAddress, uint _initialSupply) public {\\n    _mint(_founderAddress, _initialSupply);\\n  }\\n\\n  /**\\n  * @dev Total number of tokens in existence\\n  */\\n  function totalSupply() public view returns (uint256) {\\n    return _totalSupply;\\n  }\\n\\n  /**\\n  * @dev Gets the balance of the specified address.\\n  * @param owner The address to query the balance of.\\n  * @return An uint256 representing the amount owned by the passed address.\\n  */\\n  function balanceOf(address owner) public view returns (uint256) {\\n    return _balances[owner];\\n  }\\n\\n  /**\\n  * @dev Function to check the amount of tokens that an owner allowed to a spender.\\n  * @param owner address The address which owns the funds.\\n  * @param spender address The address which will spend the funds.\\n  * @return A uint256 specifying the amount of tokens still available for the spender.\\n  */\\n  function allowance(\\n    address owner,\\n    address spender\\n  )\\n  public\\n  view\\n  returns (uint256)\\n  {\\n    return _allowed[owner][spender];\\n  }\\n\\n  /**\\n  * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\n  * Beware that changing an allowance with this method brings the risk that someone may use both the old\\n  * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\\n  * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\\n  * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n  * @param spender The address which will spend the funds.\\n  * @param value The amount of tokens to be spent.\\n  */\\n  function approve(address spender, uint256 value) public returns (bool) {\\n    require(spender != address(0));\\n\\n    _allowed[msg.sender][spender] = value;\\n    emit Approval(msg.sender, spender, value);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Increase the amount of tokens that an owner allowed to a spender.\\n  * approve should be called when allowed_[_spender] == 0. To increment\\n  * allowed value is better to use this function to avoid 2 calls (and wait until\\n  * the first transaction is mined)\\n  * From MonolithDAO Token.sol\\n  * @param spender The address which will spend the funds.\\n  * @param addedValue The amount of tokens to increase the allowance by.\\n  */\\n  function increaseAllowance(\\n    address spender,\\n    uint256 addedValue\\n  )\\n  public\\n  returns (bool)\\n  {\\n    require(spender != address(0));\\n\\n    _allowed[msg.sender][spender] = (\\n    _allowed[msg.sender][spender].add(addedValue));\\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Decrease the amount of tokens that an owner allowed to a spender.\\n  * approve should be called when allowed_[_spender] == 0. To decrement\\n  * allowed value is better to use this function to avoid 2 calls (and wait until\\n  * the first transaction is mined)\\n  * From MonolithDAO Token.sol\\n  * @param spender The address which will spend the funds.\\n  * @param subtractedValue The amount of tokens to decrease the allowance by.\\n  */\\n  function decreaseAllowance(\\n    address spender,\\n    uint256 subtractedValue\\n  )\\n  public\\n  returns (bool)\\n  {\\n    require(spender != address(0));\\n\\n    _allowed[msg.sender][spender] = (\\n    _allowed[msg.sender][spender].sub(subtractedValue));\\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Adds a user to whitelist\\n  * @param _member address to add to whitelist\\n  */\\n  function addToWhiteList(address _member) public onlyOperator returns (bool) {\\n    whiteListed[_member] = true;\\n    emit WhiteListed(_member);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev removes a user from whitelist\\n  * @param _member address to remove from whitelist\\n  */\\n  function removeFromWhiteList(address _member) public onlyOperator returns (bool) {\\n    whiteListed[_member] = false;\\n    emit BlackListed(_member);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev change operator address\\n  * @param _newOperator address of new operator\\n  */\\n  function changeOperator(address _newOperator) public onlyOperator returns (bool) {\\n    operator = _newOperator;\\n    return true;\\n  }\\n\\n  /**\\n  * @dev burns an amount of the tokens of the message sender\\n  * account.\\n  * @param amount The amount that will be burnt.\\n  */\\n  function burn(uint256 amount) public returns (bool) {\\n    _burn(msg.sender, amount);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Burns a specific amount of tokens from the target address and decrements allowance\\n  * @param from address The address which you want to send tokens from\\n  * @param value uint256 The amount of token to be burned\\n  */\\n  function burnFrom(address from, uint256 value) public returns (bool) {\\n    _burnFrom(from, value);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev function that mints an amount of the token and assigns it to\\n  * an account.\\n  * @param account The account that will receive the created tokens.\\n  * @param amount The amount that will be created.\\n  */\\n  function mint(address account, uint256 amount) public onlyOperator {\\n    _mint(account, amount);\\n  }\\n\\n  /**\\n  * @dev Transfer token for a specified address\\n  * @param to The address to transfer to.\\n  * @param value The amount to be transferred.\\n  */\\n  function transfer(address to, uint256 value) public canTransfer(to) returns (bool) {\\n\\n    require(isLockedForMV[msg.sender] < now); // if not voted under governance\\n    require(value <= _balances[msg.sender]);\\n    _transfer(to, value);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Transfer tokens to the operator from the specified address\\n  * @param from The address to transfer from.\\n  * @param value The amount to be transferred.\\n  */\\n  function operatorTransfer(address from, uint256 value) public onlyOperator returns (bool) {\\n    require(value <= _balances[from]);\\n    _transferFrom(from, operator, value);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Transfer tokens from one address to another\\n  * @param from address The address which you want to send tokens from\\n  * @param to address The address which you want to transfer to\\n  * @param value uint256 the amount of tokens to be transferred\\n  */\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 value\\n  )\\n  public\\n  canTransfer(to)\\n  returns (bool)\\n  {\\n    require(isLockedForMV[from] < now); // if not voted under governance\\n    require(value <= _balances[from]);\\n    require(value <= _allowed[from][msg.sender]);\\n    _transferFrom(from, to, value);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Lock the user's tokens\\n   * @param _of user's address.\\n   */\\n  function lockForMemberVote(address _of, uint _days) public onlyOperator {\\n    if (_days.add(now) > isLockedForMV[_of])\\n      isLockedForMV[_of] = _days.add(now);\\n  }\\n\\n  /**\\n  * @dev Transfer token for a specified address\\n  * @param to The address to transfer to.\\n  * @param value The amount to be transferred.\\n  */\\n  function _transfer(address to, uint256 value) internal {\\n    _balances[msg.sender] = _balances[msg.sender].sub(value);\\n    _balances[to] = _balances[to].add(value);\\n    emit Transfer(msg.sender, to, value);\\n  }\\n\\n  /**\\n  * @dev Transfer tokens from one address to another\\n  * @param from address The address which you want to send tokens from\\n  * @param to address The address which you want to transfer to\\n  * @param value uint256 the amount of tokens to be transferred\\n  */\\n  function _transferFrom(\\n    address from,\\n    address to,\\n    uint256 value\\n  )\\n  internal\\n  {\\n    _balances[from] = _balances[from].sub(value);\\n    _balances[to] = _balances[to].add(value);\\n    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\\n    emit Transfer(from, to, value);\\n  }\\n\\n  /**\\n  * @dev Internal function that mints an amount of the token and assigns it to\\n  * an account. This encapsulates the modification of balances such that the\\n  * proper events are emitted.\\n  * @param account The account that will receive the created tokens.\\n  * @param amount The amount that will be created.\\n  */\\n  function _mint(address account, uint256 amount) internal {\\n    require(account != address(0));\\n    _totalSupply = _totalSupply.add(amount);\\n    _balances[account] = _balances[account].add(amount);\\n    emit Transfer(address(0), account, amount);\\n  }\\n\\n  /**\\n  * @dev Internal function that burns an amount of the token of a given\\n  * account.\\n  * @param account The account whose tokens will be burnt.\\n  * @param amount The amount that will be burnt.\\n  */\\n  function _burn(address account, uint256 amount) internal {\\n    require(amount <= _balances[account]);\\n\\n    _totalSupply = _totalSupply.sub(amount);\\n    _balances[account] = _balances[account].sub(amount);\\n    emit Transfer(account, address(0), amount);\\n  }\\n\\n  /**\\n  * @dev Internal function that burns an amount of the token of a given\\n  * account, deducting from the sender's allowance for said account. Uses the\\n  * internal burn function.\\n  * @param account The account whose tokens will be burnt.\\n  * @param value The amount that will be burnt.\\n  */\\n  function _burnFrom(address account, uint256 value) internal {\\n    require(value <= _allowed[account][msg.sender]);\\n\\n    // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,\\n    // this function needs to emit an event with the updated approval.\\n    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(\\n      value);\\n    _burn(account, value);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/token/TokenController.sol\": {\r\n      \"content\": \"/* Copyright (C) 2020 NexusMutual.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n  it under the terms of the GNU General Public License as published by\\n  the Free Software Foundation, either version 3 of the License, or\\n  (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n  GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n  along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../../abstract/Iupgradable.sol\\\";\\nimport \\\"../../interfaces/IPooledStaking.sol\\\";\\nimport \\\"../claims/ClaimsData.sol\\\";\\nimport \\\"./NXMToken.sol\\\";\\nimport \\\"./external/LockHandler.sol\\\";\\n\\ncontract TokenController is LockHandler, Iupgradable {\\n  using SafeMath for uint256;\\n\\n  struct CoverInfo {\\n    uint16 claimCount;\\n    bool hasOpenClaim;\\n    bool hasAcceptedClaim;\\n    // note: still 224 bits available here, can be used later\\n  }\\n\\n  NXMToken public token;\\n  IPooledStaking public pooledStaking;\\n\\n  uint public minCALockTime;\\n  uint public claimSubmissionGracePeriod;\\n\\n  // coverId => CoverInfo\\n  mapping(uint => CoverInfo) public coverInfo;\\n\\n  event Locked(address indexed _of, bytes32 indexed _reason, uint256 _amount, uint256 _validity);\\n\\n  event Unlocked(address indexed _of, bytes32 indexed _reason, uint256 _amount);\\n\\n  event Burned(address indexed member, bytes32 lockedUnder, uint256 amount);\\n\\n  modifier onlyGovernance {\\n    require(msg.sender == ms.getLatestAddress(\\\"GV\\\"), \\\"TokenController: Caller is not governance\\\");\\n    _;\\n  }\\n\\n  /**\\n  * @dev Just for interface\\n  */\\n  function changeDependentContractAddress() public {\\n    token = NXMToken(ms.tokenAddress());\\n    pooledStaking = IPooledStaking(ms.getLatestAddress(\\\"PS\\\"));\\n  }\\n\\n  function markCoverClaimOpen(uint coverId) external onlyInternal {\\n\\n    CoverInfo storage info = coverInfo[coverId];\\n\\n    uint16 claimCount;\\n    bool hasOpenClaim;\\n    bool hasAcceptedClaim;\\n\\n    // reads all of them using a single SLOAD\\n    (claimCount, hasOpenClaim, hasAcceptedClaim) = (info.claimCount, info.hasOpenClaim, info.hasAcceptedClaim);\\n\\n    // no safemath for uint16 but should be safe from\\n    // overflows as there're max 2 claims per cover\\n    claimCount = claimCount + 1;\\n\\n    require(claimCount <= 2, \\\"TokenController: Max claim count exceeded\\\");\\n    require(hasOpenClaim == false, \\\"TokenController: Cover already has an open claim\\\");\\n    require(hasAcceptedClaim == false, \\\"TokenController: Cover already has accepted claims\\\");\\n\\n    // should use a single SSTORE for both\\n    (info.claimCount, info.hasOpenClaim) = (claimCount, true);\\n  }\\n\\n  /**\\n   * @param coverId cover id (careful, not claim id!)\\n   * @param isAccepted claim verdict\\n   */\\n  function markCoverClaimClosed(uint coverId, bool isAccepted) external onlyInternal {\\n\\n    CoverInfo storage info = coverInfo[coverId];\\n    require(info.hasOpenClaim == true, \\\"TokenController: Cover claim is not marked as open\\\");\\n\\n    // should use a single SSTORE for both\\n    (info.hasOpenClaim, info.hasAcceptedClaim) = (false, isAccepted);\\n  }\\n\\n  /**\\n   * @dev to change the operator address\\n   * @param _newOperator is the new address of operator\\n   */\\n  function changeOperator(address _newOperator) public onlyInternal {\\n    token.changeOperator(_newOperator);\\n  }\\n\\n  /**\\n   * @dev Proxies token transfer through this contract to allow staking when members are locked for voting\\n   * @param _from   Source address\\n   * @param _to     Destination address\\n   * @param _value  Amount to transfer\\n   */\\n  function operatorTransfer(address _from, address _to, uint _value) external onlyInternal returns (bool) {\\n    require(msg.sender == address(pooledStaking), \\\"TokenController: Call is only allowed from PooledStaking address\\\");\\n    token.operatorTransfer(_from, _value);\\n    token.transfer(_to, _value);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Locks a specified amount of tokens,\\n  *    for CLA reason and for a specified time\\n  * @param _amount Number of tokens to be locked\\n  * @param _time Lock time in seconds\\n  */\\n  function lockClaimAssessmentTokens(uint256 _amount, uint256 _time) external checkPause {\\n    require(minCALockTime <= _time, \\\"TokenController: Must lock for minimum time\\\");\\n    require(_time <= 180 days, \\\"TokenController: Tokens can be locked for 180 days maximum\\\");\\n    // If tokens are already locked, then functions extendLock or\\n    // increaseClaimAssessmentLock should be used to make any changes\\n    _lock(msg.sender, \\\"CLA\\\", _amount, _time);\\n  }\\n\\n  /**\\n  * @dev Locks a specified amount of tokens against an address,\\n  *    for a specified reason and time\\n  * @param _reason The reason to lock tokens\\n  * @param _amount Number of tokens to be locked\\n  * @param _time Lock time in seconds\\n  * @param _of address whose tokens are to be locked\\n  */\\n  function lockOf(address _of, bytes32 _reason, uint256 _amount, uint256 _time)\\n  public\\n  onlyInternal\\n  returns (bool)\\n  {\\n    // If tokens are already locked, then functions extendLock or\\n    // increaseLockAmount should be used to make any changes\\n    _lock(_of, _reason, _amount, _time);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Mints and locks a specified amount of tokens against an address,\\n  *      for a CN reason and time\\n  * @param _of address whose tokens are to be locked\\n  * @param _reason The reason to lock tokens\\n  * @param _amount Number of tokens to be locked\\n  * @param _time Lock time in seconds\\n  */\\n  function mintCoverNote(\\n    address _of,\\n    bytes32 _reason,\\n    uint256 _amount,\\n    uint256 _time\\n  ) external onlyInternal {\\n\\n    require(_tokensLocked(_of, _reason) == 0, \\\"TokenController: An amount of tokens is already locked\\\");\\n    require(_amount != 0, \\\"TokenController: Amount shouldn't be zero\\\");\\n\\n    if (locked[_of][_reason].amount == 0) {\\n      lockReason[_of].push(_reason);\\n    }\\n\\n    token.mint(address(this), _amount);\\n\\n    uint256 lockedUntil = now.add(_time);\\n    locked[_of][_reason] = LockToken(_amount, lockedUntil, false);\\n\\n    emit Locked(_of, _reason, _amount, lockedUntil);\\n  }\\n\\n  /**\\n  * @dev Extends lock for reason CLA for a specified time\\n  * @param _time Lock extension time in seconds\\n  */\\n  function extendClaimAssessmentLock(uint256 _time) external checkPause {\\n    uint256 validity = getLockedTokensValidity(msg.sender, \\\"CLA\\\");\\n    require(validity.add(_time).sub(block.timestamp) <= 180 days, \\\"TokenController: Tokens can be locked for 180 days maximum\\\");\\n    _extendLock(msg.sender, \\\"CLA\\\", _time);\\n  }\\n\\n  /**\\n  * @dev Extends lock for a specified reason and time\\n  * @param _reason The reason to lock tokens\\n  * @param _time Lock extension time in seconds\\n  */\\n  function extendLockOf(address _of, bytes32 _reason, uint256 _time)\\n  public\\n  onlyInternal\\n  returns (bool)\\n  {\\n    _extendLock(_of, _reason, _time);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Increase number of tokens locked for a CLA reason\\n  * @param _amount Number of tokens to be increased\\n  */\\n  function increaseClaimAssessmentLock(uint256 _amount) external checkPause\\n  {\\n    require(_tokensLocked(msg.sender, \\\"CLA\\\") > 0, \\\"TokenController: No tokens locked\\\");\\n    token.operatorTransfer(msg.sender, _amount);\\n\\n    locked[msg.sender][\\\"CLA\\\"].amount = locked[msg.sender][\\\"CLA\\\"].amount.add(_amount);\\n    emit Locked(msg.sender, \\\"CLA\\\", _amount, locked[msg.sender][\\\"CLA\\\"].validity);\\n  }\\n\\n  /**\\n   * @dev burns tokens of an address\\n   * @param _of is the address to burn tokens of\\n   * @param amount is the amount to burn\\n   * @return the boolean status of the burning process\\n   */\\n  function burnFrom(address _of, uint amount) public onlyInternal returns (bool) {\\n    return token.burnFrom(_of, amount);\\n  }\\n\\n  /**\\n  * @dev Burns locked tokens of a user\\n  * @param _of address whose tokens are to be burned\\n  * @param _reason lock reason for which tokens are to be burned\\n  * @param _amount amount of tokens to burn\\n  */\\n  function burnLockedTokens(address _of, bytes32 _reason, uint256 _amount) public onlyInternal {\\n    _burnLockedTokens(_of, _reason, _amount);\\n  }\\n\\n  /**\\n  * @dev reduce lock duration for a specified reason and time\\n  * @param _of The address whose tokens are locked\\n  * @param _reason The reason to lock tokens\\n  * @param _time Lock reduction time in seconds\\n  */\\n  function reduceLock(address _of, bytes32 _reason, uint256 _time) public onlyInternal {\\n    _reduceLock(_of, _reason, _time);\\n  }\\n\\n  /**\\n  * @dev Released locked tokens of an address locked for a specific reason\\n  * @param _of address whose tokens are to be released from lock\\n  * @param _reason reason of the lock\\n  * @param _amount amount of tokens to release\\n  */\\n  function releaseLockedTokens(address _of, bytes32 _reason, uint256 _amount)\\n  public\\n  onlyInternal\\n  {\\n    _releaseLockedTokens(_of, _reason, _amount);\\n  }\\n\\n  /**\\n  * @dev Adds an address to whitelist maintained in the contract\\n  * @param _member address to add to whitelist\\n  */\\n  function addToWhitelist(address _member) public onlyInternal {\\n    token.addToWhiteList(_member);\\n  }\\n\\n  /**\\n  * @dev Removes an address from the whitelist in the token\\n  * @param _member address to remove\\n  */\\n  function removeFromWhitelist(address _member) public onlyInternal {\\n    token.removeFromWhiteList(_member);\\n  }\\n\\n  /**\\n  * @dev Mints new token for an address\\n  * @param _member address to reward the minted tokens\\n  * @param _amount number of tokens to mint\\n  */\\n  function mint(address _member, uint _amount) public onlyInternal {\\n    token.mint(_member, _amount);\\n  }\\n\\n  /**\\n   * @dev Lock the user's tokens\\n   * @param _of user's address.\\n   */\\n  function lockForMemberVote(address _of, uint _days) public onlyInternal {\\n    token.lockForMemberVote(_of, _days);\\n  }\\n\\n  /**\\n  * @dev Unlocks the withdrawable tokens against CLA of a specified address\\n  * @param _of Address of user, claiming back withdrawable tokens against CLA\\n  */\\n  function withdrawClaimAssessmentTokens(address _of) external checkPause {\\n    uint256 withdrawableTokens = _tokensUnlockable(_of, \\\"CLA\\\");\\n    if (withdrawableTokens > 0) {\\n      locked[_of][\\\"CLA\\\"].claimed = true;\\n      emit Unlocked(_of, \\\"CLA\\\", withdrawableTokens);\\n      token.transfer(_of, withdrawableTokens);\\n    }\\n  }\\n\\n  /**\\n   * @dev Updates Uint Parameters of a code\\n   * @param code whose details we want to update\\n   * @param value value to set\\n   */\\n  function updateUintParameters(bytes8 code, uint value) external onlyGovernance {\\n\\n    if (code == \\\"MNCLT\\\") {\\n      minCALockTime = value;\\n      return;\\n    }\\n\\n    if (code == \\\"GRACEPER\\\") {\\n      claimSubmissionGracePeriod = value;\\n      return;\\n    }\\n\\n    revert(\\\"TokenController: invalid param code\\\");\\n  }\\n\\n  function getLockReasons(address _of) external view returns (bytes32[] memory reasons) {\\n    return lockReason[_of];\\n  }\\n\\n  /**\\n  * @dev Gets the validity of locked tokens of a specified address\\n  * @param _of The address to query the validity\\n  * @param reason reason for which tokens were locked\\n  */\\n  function getLockedTokensValidity(address _of, bytes32 reason) public view returns (uint256 validity) {\\n    validity = locked[_of][reason].validity;\\n  }\\n\\n  /**\\n  * @dev Gets the unlockable tokens of a specified address\\n  * @param _of The address to query the the unlockable token count of\\n  */\\n  function getUnlockableTokens(address _of)\\n  public\\n  view\\n  returns (uint256 unlockableTokens)\\n  {\\n    for (uint256 i = 0; i < lockReason[_of].length; i++) {\\n      unlockableTokens = unlockableTokens.add(_tokensUnlockable(_of, lockReason[_of][i]));\\n    }\\n  }\\n\\n  /**\\n  * @dev Returns tokens locked for a specified address for a\\n  *    specified reason\\n  *\\n  * @param _of The address whose tokens are locked\\n  * @param _reason The reason to query the lock tokens for\\n  */\\n  function tokensLocked(address _of, bytes32 _reason)\\n  public\\n  view\\n  returns (uint256 amount)\\n  {\\n    return _tokensLocked(_of, _reason);\\n  }\\n\\n  /**\\n  * @dev Returns tokens locked and validity for a specified address and reason\\n  * @param _of The address whose tokens are locked\\n  * @param _reason The reason to query the lock tokens for\\n  */\\n  function tokensLockedWithValidity(address _of, bytes32 _reason)\\n  public\\n  view\\n  returns (uint256 amount, uint256 validity)\\n  {\\n\\n    bool claimed = locked[_of][_reason].claimed;\\n    amount = locked[_of][_reason].amount;\\n    validity = locked[_of][_reason].validity;\\n\\n    if (claimed) {\\n      amount = 0;\\n    }\\n  }\\n\\n  /**\\n  * @dev Returns unlockable tokens for a specified address for a specified reason\\n  * @param _of The address to query the the unlockable token count of\\n  * @param _reason The reason to query the unlockable tokens for\\n  */\\n  function tokensUnlockable(address _of, bytes32 _reason)\\n  public\\n  view\\n  returns (uint256 amount)\\n  {\\n    return _tokensUnlockable(_of, _reason);\\n  }\\n\\n  function totalSupply() public view returns (uint256)\\n  {\\n    return token.totalSupply();\\n  }\\n\\n  /**\\n  * @dev Returns tokens locked for a specified address for a\\n  *    specified reason at a specific time\\n  *\\n  * @param _of The address whose tokens are locked\\n  * @param _reason The reason to query the lock tokens for\\n  * @param _time The timestamp to query the lock tokens for\\n  */\\n  function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)\\n  public\\n  view\\n  returns (uint256 amount)\\n  {\\n    return _tokensLockedAtTime(_of, _reason, _time);\\n  }\\n\\n  /**\\n  * @dev Returns the total amount of tokens held by an address:\\n  *   transferable + locked + staked for pooled staking - pending burns.\\n  *   Used by Claims and Governance in member voting to calculate the user's vote weight.\\n  *\\n  * @param _of The address to query the total balance of\\n  * @param _of The address to query the total balance of\\n  */\\n  function totalBalanceOf(address _of) public view returns (uint256 amount) {\\n\\n    amount = token.balanceOf(_of);\\n\\n    for (uint256 i = 0; i < lockReason[_of].length; i++) {\\n      amount = amount.add(_tokensLocked(_of, lockReason[_of][i]));\\n    }\\n\\n    uint stakerReward = pooledStaking.stakerReward(_of);\\n    uint stakerDeposit = pooledStaking.stakerDeposit(_of);\\n\\n    amount = amount.add(stakerDeposit).add(stakerReward);\\n  }\\n\\n  /**\\n  * @dev Returns the total amount of locked and staked tokens.\\n  *      Used by MemberRoles to check eligibility for withdraw / switch membership.\\n  *      Includes tokens locked for claim assessment, tokens staked for risk assessment, and locked cover notes\\n  *      Does not take into account pending burns.\\n  * @param _of member whose locked tokens are to be calculate\\n  */\\n  function totalLockedBalance(address _of) public view returns (uint256 amount) {\\n\\n    for (uint256 i = 0; i < lockReason[_of].length; i++) {\\n      amount = amount.add(_tokensLocked(_of, lockReason[_of][i]));\\n    }\\n\\n    amount = amount.add(pooledStaking.stakerDeposit(_of));\\n  }\\n\\n  /**\\n  * @dev Locks a specified amount of tokens against an address,\\n  *    for a specified reason and time\\n  * @param _of address whose tokens are to be locked\\n  * @param _reason The reason to lock tokens\\n  * @param _amount Number of tokens to be locked\\n  * @param _time Lock time in seconds\\n  */\\n  function _lock(address _of, bytes32 _reason, uint256 _amount, uint256 _time) internal {\\n    require(_tokensLocked(_of, _reason) == 0, \\\"TokenController: An amount of tokens is already locked\\\");\\n    require(_amount != 0, \\\"TokenController: Amount shouldn't be zero\\\");\\n\\n    if (locked[_of][_reason].amount == 0) {\\n      lockReason[_of].push(_reason);\\n    }\\n\\n    token.operatorTransfer(_of, _amount);\\n\\n    uint256 validUntil = now.add(_time);\\n    locked[_of][_reason] = LockToken(_amount, validUntil, false);\\n    emit Locked(_of, _reason, _amount, validUntil);\\n  }\\n\\n  /**\\n  * @dev Returns tokens locked for a specified address for a\\n  *    specified reason\\n  *\\n  * @param _of The address whose tokens are locked\\n  * @param _reason The reason to query the lock tokens for\\n  */\\n  function _tokensLocked(address _of, bytes32 _reason)\\n  internal\\n  view\\n  returns (uint256 amount)\\n  {\\n    if (!locked[_of][_reason].claimed) {\\n      amount = locked[_of][_reason].amount;\\n    }\\n  }\\n\\n  /**\\n  * @dev Returns tokens locked for a specified address for a\\n  *    specified reason at a specific time\\n  *\\n  * @param _of The address whose tokens are locked\\n  * @param _reason The reason to query the lock tokens for\\n  * @param _time The timestamp to query the lock tokens for\\n  */\\n  function _tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)\\n  internal\\n  view\\n  returns (uint256 amount)\\n  {\\n    if (locked[_of][_reason].validity > _time) {\\n      amount = locked[_of][_reason].amount;\\n    }\\n  }\\n\\n  /**\\n  * @dev Extends lock for a specified reason and time\\n  * @param _of The address whose tokens are locked\\n  * @param _reason The reason to lock tokens\\n  * @param _time Lock extension time in seconds\\n  */\\n  function _extendLock(address _of, bytes32 _reason, uint256 _time) internal {\\n    require(_tokensLocked(_of, _reason) > 0, \\\"TokenController: No tokens locked\\\");\\n    emit Unlocked(_of, _reason, locked[_of][_reason].amount);\\n    locked[_of][_reason].validity = locked[_of][_reason].validity.add(_time);\\n    emit Locked(_of, _reason, locked[_of][_reason].amount, locked[_of][_reason].validity);\\n  }\\n\\n  /**\\n  * @dev reduce lock duration for a specified reason and time\\n  * @param _of The address whose tokens are locked\\n  * @param _reason The reason to lock tokens\\n  * @param _time Lock reduction time in seconds\\n  */\\n  function _reduceLock(address _of, bytes32 _reason, uint256 _time) internal {\\n    require(_tokensLocked(_of, _reason) > 0, \\\"TokenController: No tokens locked\\\");\\n    emit Unlocked(_of, _reason, locked[_of][_reason].amount);\\n    locked[_of][_reason].validity = locked[_of][_reason].validity.sub(_time);\\n    emit Locked(_of, _reason, locked[_of][_reason].amount, locked[_of][_reason].validity);\\n  }\\n\\n  /**\\n  * @dev Returns unlockable tokens for a specified address for a specified reason\\n  * @param _of The address to query the the unlockable token count of\\n  * @param _reason The reason to query the unlockable tokens for\\n  */\\n  function _tokensUnlockable(address _of, bytes32 _reason) internal view returns (uint256 amount)\\n  {\\n    if (locked[_of][_reason].validity <= now && !locked[_of][_reason].claimed) {\\n      amount = locked[_of][_reason].amount;\\n    }\\n  }\\n\\n  /**\\n  * @dev Burns locked tokens of a user\\n  * @param _of address whose tokens are to be burned\\n  * @param _reason lock reason for which tokens are to be burned\\n  * @param _amount amount of tokens to burn\\n  */\\n  function _burnLockedTokens(address _of, bytes32 _reason, uint256 _amount) internal {\\n    uint256 amount = _tokensLocked(_of, _reason);\\n    require(amount >= _amount, \\\"TokenController: Amount exceedes locked tokens amount\\\");\\n\\n    if (amount == _amount) {\\n      locked[_of][_reason].claimed = true;\\n    }\\n\\n    locked[_of][_reason].amount = locked[_of][_reason].amount.sub(_amount);\\n\\n    // lock reason removal is skipped here: needs to be done from offchain\\n\\n    token.burn(_amount);\\n    emit Burned(_of, _reason, _amount);\\n  }\\n\\n  /**\\n  * @dev Released locked tokens of an address locked for a specific reason\\n  * @param _of address whose tokens are to be released from lock\\n  * @param _reason reason of the lock\\n  * @param _amount amount of tokens to release\\n  */\\n  function _releaseLockedTokens(address _of, bytes32 _reason, uint256 _amount) internal\\n  {\\n    uint256 amount = _tokensLocked(_of, _reason);\\n    require(amount >= _amount, \\\"TokenController: Amount exceedes locked tokens amount\\\");\\n\\n    if (amount == _amount) {\\n      locked[_of][_reason].claimed = true;\\n    }\\n\\n    locked[_of][_reason].amount = locked[_of][_reason].amount.sub(_amount);\\n\\n    // lock reason removal is skipped here: needs to be done from offchain\\n\\n    token.transfer(_of, _amount);\\n    emit Unlocked(_of, _reason, _amount);\\n  }\\n\\n  function withdrawCoverNote(\\n    address _of,\\n    uint[] calldata _coverIds,\\n    uint[] calldata _indexes\\n  ) external onlyInternal {\\n\\n    uint reasonCount = lockReason[_of].length;\\n    uint lastReasonIndex = reasonCount.sub(1, \\\"TokenController: No locked cover notes found\\\");\\n    uint totalAmount = 0;\\n\\n    // The iteration is done from the last to first to prevent reason indexes from\\n    // changing due to the way we delete the items (copy last to current and pop last).\\n    // The provided indexes array must be ordered, otherwise reason index checks will fail.\\n\\n    for (uint i = _coverIds.length; i > 0; i--) {\\n\\n      bool hasOpenClaim = coverInfo[_coverIds[i - 1]].hasOpenClaim;\\n      require(hasOpenClaim == false, \\\"TokenController: Cannot withdraw for cover with an open claim\\\");\\n\\n      // note: cover owner is implicitly checked using the reason hash\\n      bytes32 _reason = keccak256(abi.encodePacked(\\\"CN\\\", _of, _coverIds[i - 1]));\\n      uint _reasonIndex = _indexes[i - 1];\\n      require(lockReason[_of][_reasonIndex] == _reason, \\\"TokenController: Bad reason index\\\");\\n\\n      uint amount = locked[_of][_reason].amount;\\n      totalAmount = totalAmount.add(amount);\\n      delete locked[_of][_reason];\\n\\n      if (lastReasonIndex != _reasonIndex) {\\n        lockReason[_of][_reasonIndex] = lockReason[_of][lastReasonIndex];\\n      }\\n\\n      lockReason[_of].pop();\\n      emit Unlocked(_of, _reason, amount);\\n\\n      if (lastReasonIndex > 0) {\\n        lastReasonIndex = lastReasonIndex.sub(1, \\\"TokenController: Reason count mismatch\\\");\\n      }\\n    }\\n\\n    token.transfer(_of, totalAmount);\\n  }\\n\\n  function removeEmptyReason(address _of, bytes32 _reason, uint _index) external {\\n    _removeEmptyReason(_of, _reason, _index);\\n  }\\n\\n  function removeMultipleEmptyReasons(\\n    address[] calldata _members,\\n    bytes32[] calldata _reasons,\\n    uint[] calldata _indexes\\n  ) external {\\n\\n    require(_members.length == _reasons.length, \\\"TokenController: members and reasons array lengths differ\\\");\\n    require(_reasons.length == _indexes.length, \\\"TokenController: reasons and indexes array lengths differ\\\");\\n\\n    for (uint i = _members.length; i > 0; i--) {\\n      uint idx = i - 1;\\n      _removeEmptyReason(_members[idx], _reasons[idx], _indexes[idx]);\\n    }\\n  }\\n\\n  function _removeEmptyReason(address _of, bytes32 _reason, uint _index) internal {\\n\\n    uint lastReasonIndex = lockReason[_of].length.sub(1, \\\"TokenController: lockReason is empty\\\");\\n\\n    require(lockReason[_of][_index] == _reason, \\\"TokenController: bad reason index\\\");\\n    require(locked[_of][_reason].amount == 0, \\\"TokenController: reason amount is not zero\\\");\\n\\n    if (lastReasonIndex != _index) {\\n      lockReason[_of][_index] = lockReason[_of][lastReasonIndex];\\n    }\\n\\n    lockReason[_of].pop();\\n  }\\n\\n  function initialize() external {\\n    require(claimSubmissionGracePeriod == 0, \\\"TokenController: Already initialized\\\");\\n    claimSubmissionGracePeriod = 120 days;\\n    migrate();\\n  }\\n\\n  function migrate() internal {\\n\\n    ClaimsData cd = ClaimsData(ms.getLatestAddress(\\\"CD\\\"));\\n    uint totalClaims = cd.actualClaimLength() - 1;\\n\\n    // fix stuck claims 21 & 22\\n    cd.changeFinalVerdict(20, -1);\\n    cd.setClaimStatus(20, 6);\\n    cd.changeFinalVerdict(21, -1);\\n    cd.setClaimStatus(21, 6);\\n\\n    // reduce claim assessment lock period for members locked for more than 180 days\\n    // extracted using scripts/extract-ca-locked-more-than-180.js\\n    address payable[3] memory members = [\\n      0x4a9fA34da6d2378c8f3B9F6b83532B169beaEDFc,\\n      0x6b5DCDA27b5c3d88e71867D6b10b35372208361F,\\n      0x8B6D1e5b4db5B6f9aCcc659e2b9619B0Cd90D617\\n    ];\\n\\n    for (uint i = 0; i < members.length; i++) {\\n      if (locked[members[i]][\\\"CLA\\\"].validity > now + 180 days) {\\n        locked[members[i]][\\\"CLA\\\"].validity = now + 180 days;\\n      }\\n    }\\n\\n    for (uint i = 1; i <= totalClaims; i++) {\\n\\n      (/*id*/, uint status) = cd.getClaimStatusNumber(i);\\n      (/*id*/, uint coverId) = cd.getClaimCoverId(i);\\n      int8 verdict = cd.getFinalVerdict(i);\\n\\n      // SLOAD\\n      CoverInfo memory info = coverInfo[coverId];\\n\\n      info.claimCount = info.claimCount + 1;\\n      info.hasAcceptedClaim = (status == 14);\\n      info.hasOpenClaim = (verdict == 0);\\n\\n      // SSTORE\\n      coverInfo[coverId] = info;\\n    }\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/modules/token/TokenData.sol\": {\r\n      \"content\": \"/* Copyright (C) 2020 NexusMutual.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../../abstract/Iupgradable.sol\\\";\\n\\ncontract TokenData is Iupgradable {\\n  using SafeMath for uint;\\n\\n  address payable public walletAddress;\\n  uint public lockTokenTimeAfterCoverExp;\\n  uint public bookTime;\\n  uint public lockCADays;\\n  uint public lockMVDays;\\n  uint public scValidDays;\\n  uint public joiningFee;\\n  uint public stakerCommissionPer;\\n  uint public stakerMaxCommissionPer;\\n  uint public tokenExponent;\\n  uint public priceStep;\\n\\n  struct StakeCommission {\\n    uint commissionEarned;\\n    uint commissionRedeemed;\\n  }\\n\\n  struct Stake {\\n    address stakedContractAddress;\\n    uint stakedContractIndex;\\n    uint dateAdd;\\n    uint stakeAmount;\\n    uint unlockedAmount;\\n    uint burnedAmount;\\n    uint unLockableBeforeLastBurn;\\n  }\\n\\n  struct Staker {\\n    address stakerAddress;\\n    uint stakerIndex;\\n  }\\n\\n  struct CoverNote {\\n    uint amount;\\n    bool isDeposited;\\n  }\\n\\n  /**\\n   * @dev mapping of uw address to array of sc address to fetch\\n   * all staked contract address of underwriter, pushing\\n   * data into this array of Stake returns stakerIndex\\n   */\\n  mapping(address => Stake[]) public stakerStakedContracts;\\n\\n  /**\\n   * @dev mapping of sc address to array of UW address to fetch\\n   * all underwritters of the staked smart contract\\n   * pushing data into this mapped array returns scIndex\\n   */\\n  mapping(address => Staker[]) public stakedContractStakers;\\n\\n  /**\\n   * @dev mapping of staked contract Address to the array of StakeCommission\\n   * here index of this array is stakedContractIndex\\n   */\\n  mapping(address => mapping(uint => StakeCommission)) public stakedContractStakeCommission;\\n\\n  mapping(address => uint) public lastCompletedStakeCommission;\\n\\n  /**\\n   * @dev mapping of the staked contract address to the current\\n   * staker index who will receive commission.\\n   */\\n  mapping(address => uint) public stakedContractCurrentCommissionIndex;\\n\\n  /**\\n   * @dev mapping of the staked contract address to the\\n   * current staker index to burn token from.\\n   */\\n  mapping(address => uint) public stakedContractCurrentBurnIndex;\\n\\n  /**\\n   * @dev mapping to return true if Cover Note deposited against coverId\\n   */\\n  mapping(uint => CoverNote) public depositedCN;\\n\\n  mapping(address => uint) internal isBookedTokens;\\n\\n  event Commission(\\n    address indexed stakedContractAddress,\\n    address indexed stakerAddress,\\n    uint indexed scIndex,\\n    uint commissionAmount\\n  );\\n\\n  constructor(address payable _walletAdd) public {\\n    walletAddress = _walletAdd;\\n    bookTime = 12 hours;\\n    joiningFee = 2000000000000000; // 0.002 Ether\\n    lockTokenTimeAfterCoverExp = 35 days;\\n    scValidDays = 250;\\n    lockCADays = 7 days;\\n    lockMVDays = 2 days;\\n    stakerCommissionPer = 20;\\n    stakerMaxCommissionPer = 50;\\n    tokenExponent = 4;\\n    priceStep = 1000;\\n  }\\n\\n  /**\\n   * @dev Change the wallet address which receive Joining Fee\\n   */\\n  function changeWalletAddress(address payable _address) external onlyInternal {\\n    walletAddress = _address;\\n  }\\n\\n  /**\\n   * @dev Gets Uint Parameters of a code\\n   * @param code whose details we want\\n   * @return string value of the code\\n   * @return associated amount (time or perc or value) to the code\\n   */\\n  function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val) {\\n    codeVal = code;\\n    if (code == \\\"TOKEXP\\\") {\\n\\n      val = tokenExponent;\\n\\n    } else if (code == \\\"TOKSTEP\\\") {\\n\\n      val = priceStep;\\n\\n    } else if (code == \\\"RALOCKT\\\") {\\n\\n      val = scValidDays;\\n\\n    } else if (code == \\\"RACOMM\\\") {\\n\\n      val = stakerCommissionPer;\\n\\n    } else if (code == \\\"RAMAXC\\\") {\\n\\n      val = stakerMaxCommissionPer;\\n\\n    } else if (code == \\\"CABOOKT\\\") {\\n\\n      val = bookTime / (1 hours);\\n\\n    } else if (code == \\\"CALOCKT\\\") {\\n\\n      val = lockCADays / (1 days);\\n\\n    } else if (code == \\\"MVLOCKT\\\") {\\n\\n      val = lockMVDays / (1 days);\\n\\n    } else if (code == \\\"QUOLOCKT\\\") {\\n\\n      val = lockTokenTimeAfterCoverExp / (1 days);\\n\\n    } else if (code == \\\"JOINFEE\\\") {\\n\\n      val = joiningFee;\\n\\n    }\\n  }\\n\\n  /**\\n  * @dev Just for interface\\n  */\\n  function changeDependentContractAddress() public {//solhint-disable-line\\n  }\\n\\n  /**\\n   * @dev to get the contract staked by a staker\\n   * @param _stakerAddress is the address of the staker\\n   * @param _stakerIndex is the index of staker\\n   * @return the address of staked contract\\n   */\\n  function getStakerStakedContractByIndex(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  public\\n  view\\n  returns (address stakedContractAddress)\\n  {\\n    stakedContractAddress = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].stakedContractAddress;\\n  }\\n\\n  /**\\n   * @dev to get the staker's staked burned\\n   * @param _stakerAddress is the address of the staker\\n   * @param _stakerIndex is the index of staker\\n   * @return amount burned\\n   */\\n  function getStakerStakedBurnedByIndex(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  public\\n  view\\n  returns (uint burnedAmount)\\n  {\\n    burnedAmount = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].burnedAmount;\\n  }\\n\\n  /**\\n   * @dev to get the staker's staked unlockable before the last burn\\n   * @param _stakerAddress is the address of the staker\\n   * @param _stakerIndex is the index of staker\\n   * @return unlockable staked tokens\\n   */\\n  function getStakerStakedUnlockableBeforeLastBurnByIndex(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  public\\n  view\\n  returns (uint unlockable)\\n  {\\n    unlockable = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].unLockableBeforeLastBurn;\\n  }\\n\\n  /**\\n   * @dev to get the staker's staked contract index\\n   * @param _stakerAddress is the address of the staker\\n   * @param _stakerIndex is the index of staker\\n   * @return is the index of the smart contract address\\n   */\\n  function getStakerStakedContractIndex(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  public\\n  view\\n  returns (uint scIndex)\\n  {\\n    scIndex = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].stakedContractIndex;\\n  }\\n\\n  /**\\n   * @dev to get the staker index of the staked contract\\n   * @param _stakedContractAddress is the address of the staked contract\\n   * @param _stakedContractIndex is the index of staked contract\\n   * @return is the index of the staker\\n   */\\n  function getStakedContractStakerIndex(\\n    address _stakedContractAddress,\\n    uint _stakedContractIndex\\n  )\\n  public\\n  view\\n  returns (uint sIndex)\\n  {\\n    sIndex = stakedContractStakers[\\n    _stakedContractAddress][_stakedContractIndex].stakerIndex;\\n  }\\n\\n  /**\\n   * @dev to get the staker's initial staked amount on the contract\\n   * @param _stakerAddress is the address of the staker\\n   * @param _stakerIndex is the index of staker\\n   * @return staked amount\\n   */\\n  function getStakerInitialStakedAmountOnContract(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  public\\n  view\\n  returns (uint amount)\\n  {\\n    amount = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].stakeAmount;\\n  }\\n\\n  /**\\n   * @dev to get the staker's staked contract length\\n   * @param _stakerAddress is the address of the staker\\n   * @return length of staked contract\\n   */\\n  function getStakerStakedContractLength(\\n    address _stakerAddress\\n  )\\n  public\\n  view\\n  returns (uint length)\\n  {\\n    length = stakerStakedContracts[_stakerAddress].length;\\n  }\\n\\n  /**\\n   * @dev to get the staker's unlocked tokens which were staked\\n   * @param _stakerAddress is the address of the staker\\n   * @param _stakerIndex is the index of staker\\n   * @return amount\\n   */\\n  function getStakerUnlockedStakedTokens(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  public\\n  view\\n  returns (uint amount)\\n  {\\n    amount = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].unlockedAmount;\\n  }\\n\\n  /**\\n   * @dev pushes the unlocked staked tokens by a staker.\\n   * @param _stakerAddress address of staker.\\n   * @param _stakerIndex index of the staker to distribute commission.\\n   * @param _amount amount to be given as commission.\\n   */\\n  function pushUnlockedStakedTokens(\\n    address _stakerAddress,\\n    uint _stakerIndex,\\n    uint _amount\\n  )\\n  public\\n  onlyInternal\\n  {\\n    stakerStakedContracts[_stakerAddress][\\n    _stakerIndex].unlockedAmount = stakerStakedContracts[_stakerAddress][\\n    _stakerIndex].unlockedAmount.add(_amount);\\n  }\\n\\n  /**\\n   * @dev pushes the Burned tokens for a staker.\\n   * @param _stakerAddress address of staker.\\n   * @param _stakerIndex index of the staker.\\n   * @param _amount amount to be burned.\\n   */\\n  function pushBurnedTokens(\\n    address _stakerAddress,\\n    uint _stakerIndex,\\n    uint _amount\\n  )\\n  public\\n  onlyInternal\\n  {\\n    stakerStakedContracts[_stakerAddress][\\n    _stakerIndex].burnedAmount = stakerStakedContracts[_stakerAddress][\\n    _stakerIndex].burnedAmount.add(_amount);\\n  }\\n\\n  /**\\n   * @dev pushes the unLockable tokens for a staker before last burn.\\n   * @param _stakerAddress address of staker.\\n   * @param _stakerIndex index of the staker.\\n   * @param _amount amount to be added to unlockable.\\n   */\\n  function pushUnlockableBeforeLastBurnTokens(\\n    address _stakerAddress,\\n    uint _stakerIndex,\\n    uint _amount\\n  )\\n  public\\n  onlyInternal\\n  {\\n    stakerStakedContracts[_stakerAddress][\\n    _stakerIndex].unLockableBeforeLastBurn = stakerStakedContracts[_stakerAddress][\\n    _stakerIndex].unLockableBeforeLastBurn.add(_amount);\\n  }\\n\\n  /**\\n   * @dev sets the unLockable tokens for a staker before last burn.\\n   * @param _stakerAddress address of staker.\\n   * @param _stakerIndex index of the staker.\\n   * @param _amount amount to be added to unlockable.\\n   */\\n  function setUnlockableBeforeLastBurnTokens(\\n    address _stakerAddress,\\n    uint _stakerIndex,\\n    uint _amount\\n  )\\n  public\\n  onlyInternal\\n  {\\n    stakerStakedContracts[_stakerAddress][\\n    _stakerIndex].unLockableBeforeLastBurn = _amount;\\n  }\\n\\n  /**\\n   * @dev pushes the earned commission earned by a staker.\\n   * @param _stakerAddress address of staker.\\n   * @param _stakedContractAddress address of smart contract.\\n   * @param _stakedContractIndex index of the staker to distribute commission.\\n   * @param _commissionAmount amount to be given as commission.\\n   */\\n  function pushEarnedStakeCommissions(\\n    address _stakerAddress,\\n    address _stakedContractAddress,\\n    uint _stakedContractIndex,\\n    uint _commissionAmount\\n  )\\n  public\\n  onlyInternal\\n  {\\n    stakedContractStakeCommission[_stakedContractAddress][_stakedContractIndex].\\n    commissionEarned = stakedContractStakeCommission[_stakedContractAddress][\\n    _stakedContractIndex].commissionEarned.add(_commissionAmount);\\n\\n    emit Commission(\\n      _stakerAddress,\\n      _stakedContractAddress,\\n      _stakedContractIndex,\\n      _commissionAmount\\n    );\\n  }\\n\\n  /**\\n   * @dev pushes the redeemed commission redeemed by a staker.\\n   * @param _stakerAddress address of staker.\\n   * @param _stakerIndex index of the staker to distribute commission.\\n   * @param _amount amount to be given as commission.\\n   */\\n  function pushRedeemedStakeCommissions(\\n    address _stakerAddress,\\n    uint _stakerIndex,\\n    uint _amount\\n  )\\n  public\\n  onlyInternal\\n  {\\n    uint stakedContractIndex = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].stakedContractIndex;\\n    address stakedContractAddress = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].stakedContractAddress;\\n    stakedContractStakeCommission[stakedContractAddress][stakedContractIndex].\\n    commissionRedeemed = stakedContractStakeCommission[\\n    stakedContractAddress][stakedContractIndex].commissionRedeemed.add(_amount);\\n  }\\n\\n  /**\\n   * @dev Gets stake commission given to an underwriter\\n   * for particular stakedcontract on given index.\\n   * @param _stakerAddress address of staker.\\n   * @param _stakerIndex index of the staker commission.\\n   */\\n  function getStakerEarnedStakeCommission(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  public\\n  view\\n  returns (uint)\\n  {\\n    return _getStakerEarnedStakeCommission(_stakerAddress, _stakerIndex);\\n  }\\n\\n  /**\\n   * @dev Gets stake commission redeemed by an underwriter\\n   * for particular staked contract on given index.\\n   * @param _stakerAddress address of staker.\\n   * @param _stakerIndex index of the staker commission.\\n   * @return commissionEarned total amount given to staker.\\n   */\\n  function getStakerRedeemedStakeCommission(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  public\\n  view\\n  returns (uint)\\n  {\\n    return _getStakerRedeemedStakeCommission(_stakerAddress, _stakerIndex);\\n  }\\n\\n  /**\\n   * @dev Gets total stake commission given to an underwriter\\n   * @param _stakerAddress address of staker.\\n   * @return totalCommissionEarned total commission earned by staker.\\n   */\\n  function getStakerTotalEarnedStakeCommission(\\n    address _stakerAddress\\n  )\\n  public\\n  view\\n  returns (uint totalCommissionEarned)\\n  {\\n    totalCommissionEarned = 0;\\n    for (uint i = 0; i < stakerStakedContracts[_stakerAddress].length; i++) {\\n      totalCommissionEarned = totalCommissionEarned.\\n      add(_getStakerEarnedStakeCommission(_stakerAddress, i));\\n    }\\n  }\\n\\n  /**\\n   * @dev Gets total stake commission given to an underwriter\\n   * @param _stakerAddress address of staker.\\n   * @return totalCommissionEarned total commission earned by staker.\\n   */\\n  function getStakerTotalReedmedStakeCommission(\\n    address _stakerAddress\\n  )\\n  public\\n  view\\n  returns (uint totalCommissionRedeemed)\\n  {\\n    totalCommissionRedeemed = 0;\\n    for (uint i = 0; i < stakerStakedContracts[_stakerAddress].length; i++) {\\n      totalCommissionRedeemed = totalCommissionRedeemed.add(\\n        _getStakerRedeemedStakeCommission(_stakerAddress, i));\\n    }\\n  }\\n\\n  /**\\n   * @dev set flag to deposit/ undeposit cover note\\n   * against a cover Id\\n   * @param coverId coverId of Cover\\n   * @param flag true/false for deposit/undeposit\\n   */\\n  function setDepositCN(uint coverId, bool flag) public onlyInternal {\\n\\n    if (flag == true) {\\n      require(!depositedCN[coverId].isDeposited, \\\"Cover note already deposited\\\");\\n    }\\n\\n    depositedCN[coverId].isDeposited = flag;\\n  }\\n\\n  /**\\n   * @dev set locked cover note amount\\n   * against a cover Id\\n   * @param coverId coverId of Cover\\n   * @param amount amount of nxm to be locked\\n   */\\n  function setDepositCNAmount(uint coverId, uint amount) public onlyInternal {\\n\\n    depositedCN[coverId].amount = amount;\\n  }\\n\\n  /**\\n   * @dev to get the staker address on a staked contract\\n   * @param _stakedContractAddress is the address of the staked contract in concern\\n   * @param _stakedContractIndex is the index of staked contract's index\\n   * @return address of staker\\n   */\\n  function getStakedContractStakerByIndex(\\n    address _stakedContractAddress,\\n    uint _stakedContractIndex\\n  )\\n  public\\n  view\\n  returns (address stakerAddress)\\n  {\\n    stakerAddress = stakedContractStakers[\\n    _stakedContractAddress][_stakedContractIndex].stakerAddress;\\n  }\\n\\n  /**\\n   * @dev to get the length of stakers on a staked contract\\n   * @param _stakedContractAddress is the address of the staked contract in concern\\n   * @return length in concern\\n   */\\n  function getStakedContractStakersLength(\\n    address _stakedContractAddress\\n  )\\n  public\\n  view\\n  returns (uint length)\\n  {\\n    length = stakedContractStakers[_stakedContractAddress].length;\\n  }\\n\\n  /**\\n   * @dev Adds a new stake record.\\n   * @param _stakerAddress staker address.\\n   * @param _stakedContractAddress smart contract address.\\n   * @param _amount amountof NXM to be staked.\\n   */\\n  function addStake(\\n    address _stakerAddress,\\n    address _stakedContractAddress,\\n    uint _amount\\n  )\\n  public\\n  onlyInternal\\n  returns (uint scIndex)\\n  {\\n    scIndex = (stakedContractStakers[_stakedContractAddress].push(\\n      Staker(_stakerAddress, stakerStakedContracts[_stakerAddress].length))).sub(1);\\n    stakerStakedContracts[_stakerAddress].push(\\n      Stake(_stakedContractAddress, scIndex, now, _amount, 0, 0, 0));\\n  }\\n\\n  /**\\n   * @dev books the user's tokens for maintaining Assessor Velocity,\\n   * i.e. once a token is used to cast a vote as a Claims assessor,\\n   * @param _of user's address.\\n   */\\n  function bookCATokens(address _of) public onlyInternal {\\n    require(!isCATokensBooked(_of), \\\"Tokens already booked\\\");\\n    isBookedTokens[_of] = now.add(bookTime);\\n  }\\n\\n  /**\\n   * @dev to know if claim assessor's tokens are booked or not\\n   * @param _of is the claim assessor's address in concern\\n   * @return boolean representing the status of tokens booked\\n   */\\n  function isCATokensBooked(address _of) public view returns (bool res) {\\n    if (now < isBookedTokens[_of])\\n      res = true;\\n  }\\n\\n  /**\\n   * @dev Sets the index which will receive commission.\\n   * @param _stakedContractAddress smart contract address.\\n   * @param _index current index.\\n   */\\n  function setStakedContractCurrentCommissionIndex(\\n    address _stakedContractAddress,\\n    uint _index\\n  )\\n  public\\n  onlyInternal\\n  {\\n    stakedContractCurrentCommissionIndex[_stakedContractAddress] = _index;\\n  }\\n\\n  /**\\n   * @dev Sets the last complete commission index\\n   * @param _stakerAddress smart contract address.\\n   * @param _index current index.\\n   */\\n  function setLastCompletedStakeCommissionIndex(\\n    address _stakerAddress,\\n    uint _index\\n  )\\n  public\\n  onlyInternal\\n  {\\n    lastCompletedStakeCommission[_stakerAddress] = _index;\\n  }\\n\\n  /**\\n   * @dev Sets the index till which commission is distrubuted.\\n   * @param _stakedContractAddress smart contract address.\\n   * @param _index current index.\\n   */\\n  function setStakedContractCurrentBurnIndex(\\n    address _stakedContractAddress,\\n    uint _index\\n  )\\n  public\\n  onlyInternal\\n  {\\n    stakedContractCurrentBurnIndex[_stakedContractAddress] = _index;\\n  }\\n\\n  /**\\n   * @dev Updates Uint Parameters of a code\\n   * @param code whose details we want to update\\n   * @param val value to set\\n   */\\n  function updateUintParameters(bytes8 code, uint val) public {\\n    require(ms.checkIsAuthToGoverned(msg.sender));\\n    if (code == \\\"TOKEXP\\\") {\\n\\n      _setTokenExponent(val);\\n\\n    } else if (code == \\\"TOKSTEP\\\") {\\n\\n      _setPriceStep(val);\\n\\n    } else if (code == \\\"RALOCKT\\\") {\\n\\n      _changeSCValidDays(val);\\n\\n    } else if (code == \\\"RACOMM\\\") {\\n\\n      _setStakerCommissionPer(val);\\n\\n    } else if (code == \\\"RAMAXC\\\") {\\n\\n      _setStakerMaxCommissionPer(val);\\n\\n    } else if (code == \\\"CABOOKT\\\") {\\n\\n      _changeBookTime(val * 1 hours);\\n\\n    } else if (code == \\\"CALOCKT\\\") {\\n\\n      _changelockCADays(val * 1 days);\\n\\n    } else if (code == \\\"MVLOCKT\\\") {\\n\\n      _changelockMVDays(val * 1 days);\\n\\n    } else if (code == \\\"QUOLOCKT\\\") {\\n\\n      _setLockTokenTimeAfterCoverExp(val * 1 days);\\n\\n    } else if (code == \\\"JOINFEE\\\") {\\n\\n      _setJoiningFee(val);\\n\\n    } else {\\n      revert(\\\"Invalid param code\\\");\\n    }\\n  }\\n\\n  /**\\n   * @dev Internal function to get stake commission given to an\\n   * underwriter for particular stakedcontract on given index.\\n   * @param _stakerAddress address of staker.\\n   * @param _stakerIndex index of the staker commission.\\n   */\\n  function _getStakerEarnedStakeCommission(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  internal\\n  view\\n  returns (uint amount)\\n  {\\n    uint _stakedContractIndex;\\n    address _stakedContractAddress;\\n    _stakedContractAddress = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].stakedContractAddress;\\n    _stakedContractIndex = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].stakedContractIndex;\\n    amount = stakedContractStakeCommission[\\n    _stakedContractAddress][_stakedContractIndex].commissionEarned;\\n  }\\n\\n  /**\\n   * @dev Internal function to get stake commission redeemed by an\\n   * underwriter for particular stakedcontract on given index.\\n   * @param _stakerAddress address of staker.\\n   * @param _stakerIndex index of the staker commission.\\n   */\\n  function _getStakerRedeemedStakeCommission(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  internal\\n  view\\n  returns (uint amount)\\n  {\\n    uint _stakedContractIndex;\\n    address _stakedContractAddress;\\n    _stakedContractAddress = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].stakedContractAddress;\\n    _stakedContractIndex = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].stakedContractIndex;\\n    amount = stakedContractStakeCommission[\\n    _stakedContractAddress][_stakedContractIndex].commissionRedeemed;\\n  }\\n\\n  /**\\n   * @dev to set the percentage of staker commission\\n   * @param _val is new percentage value\\n   */\\n  function _setStakerCommissionPer(uint _val) internal {\\n    stakerCommissionPer = _val;\\n  }\\n\\n  /**\\n   * @dev to set the max percentage of staker commission\\n   * @param _val is new percentage value\\n   */\\n  function _setStakerMaxCommissionPer(uint _val) internal {\\n    stakerMaxCommissionPer = _val;\\n  }\\n\\n  /**\\n   * @dev to set the token exponent value\\n   * @param _val is new value\\n   */\\n  function _setTokenExponent(uint _val) internal {\\n    tokenExponent = _val;\\n  }\\n\\n  /**\\n   * @dev to set the price step\\n   * @param _val is new value\\n   */\\n  function _setPriceStep(uint _val) internal {\\n    priceStep = _val;\\n  }\\n\\n  /**\\n   * @dev Changes number of days for which NXM needs to staked in case of underwriting\\n   */\\n  function _changeSCValidDays(uint _days) internal {\\n    scValidDays = _days;\\n  }\\n\\n  /**\\n   * @dev Changes the time period up to which tokens will be locked.\\n   *      Used to generate the validity period of tokens booked by\\n   *      a user for participating in claim's assessment/claim's voting.\\n   */\\n  function _changeBookTime(uint _time) internal {\\n    bookTime = _time;\\n  }\\n\\n  /**\\n   * @dev Changes lock CA days - number of days for which tokens\\n   * are locked while submitting a vote.\\n   */\\n  function _changelockCADays(uint _val) internal {\\n    lockCADays = _val;\\n  }\\n\\n  /**\\n   * @dev Changes lock MV days - number of days for which tokens are locked\\n   * while submitting a vote.\\n   */\\n  function _changelockMVDays(uint _val) internal {\\n    lockMVDays = _val;\\n  }\\n\\n  /**\\n   * @dev Changes extra lock period for a cover, post its expiry.\\n   */\\n  function _setLockTokenTimeAfterCoverExp(uint time) internal {\\n    lockTokenTimeAfterCoverExp = time;\\n  }\\n\\n  /**\\n   * @dev Set the joining fee for membership\\n   */\\n  function _setJoiningFee(uint _amount) internal {\\n    joiningFee = _amount;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/abstract/Iupgradable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./INXMMaster.sol\\\";\\n\\ncontract Iupgradable {\\n\\n  INXMMaster public ms;\\n  address public nxMasterAddress;\\n\\n  modifier onlyInternal {\\n    require(ms.isInternal(msg.sender));\\n    _;\\n  }\\n\\n  modifier isMemberAndcheckPause {\\n    require(ms.isPause() == false && ms.isMember(msg.sender) == true);\\n    _;\\n  }\\n\\n  modifier onlyOwner {\\n    require(ms.isOwner(msg.sender));\\n    _;\\n  }\\n\\n  modifier checkPause {\\n    require(ms.isPause() == false);\\n    _;\\n  }\\n\\n  modifier isMember {\\n    require(ms.isMember(msg.sender), \\\"Not member\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Iupgradable Interface to update dependent contract address\\n   */\\n  function changeDependentContractAddress() public;\\n\\n  /**\\n   * @dev change master address\\n   * @param _masterAddress is the new address\\n   */\\n  function changeMasterAddress(address _masterAddress) public {\\n    if (address(ms) != address(0)) {\\n      require(address(ms) == msg.sender, \\\"Not master\\\");\\n    }\\n\\n    ms = INXMMaster(_masterAddress);\\n    nxMasterAddress = _masterAddress;\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/abstract/INXMMaster.sol\": {\r\n      \"content\": \"/* Copyright (C) 2020 NexusMutual.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\ncontract INXMMaster {\\n\\n  address public tokenAddress;\\n\\n  address public owner;\\n\\n  uint public pauseTime;\\n\\n  function delegateCallBack(bytes32 myid) external;\\n\\n  function masterInitialized() public view returns (bool);\\n\\n  function isInternal(address _add) public view returns (bool);\\n\\n  function isPause() public view returns (bool check);\\n\\n  function isOwner(address _add) public view returns (bool);\\n\\n  function isMember(address _add) public view returns (bool);\\n\\n  function checkIsAuthToGoverned(address _add) public view returns (bool);\\n\\n  function updatePauseTime(uint _time) public;\\n\\n  function dAppLocker() public view returns (address _add);\\n\\n  function dAppToken() public view returns (address _add);\\n\\n  function getLatestAddress(bytes2 _contractName) public view returns (address payable contractAddress);\\n}\\n\"\r\n    },\r\n    \"contracts/modules/token/external/OZIERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ninterface OZIERC20 {\\n  function transfer(address to, uint256 value) external returns (bool);\\n\\n  function approve(address spender, uint256 value)\\n  external returns (bool);\\n\\n  function transferFrom(address from, address to, uint256 value)\\n  external returns (bool);\\n\\n  function totalSupply() external view returns (uint256);\\n\\n  function balanceOf(address who) external view returns (uint256);\\n\\n  function allowance(address owner, address spender)\\n  external view returns (uint256);\\n\\n  event Transfer(\\n    address indexed from,\\n    address indexed to,\\n    uint256 value\\n  );\\n\\n  event Approval(\\n    address indexed owner,\\n    address indexed spender,\\n    uint256 value\\n  );\\n}\\n\"\r\n    },\r\n    \"contracts/modules/token/external/OZSafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that revert on error\\n */\\nlibrary OZSafeMath {\\n\\n  /**\\n  * @dev Multiplies two numbers, reverts on overflow.\\n  */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b);\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\\n  */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n  */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b <= a);\\n    uint256 c = a - b;\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Adds two numbers, reverts on overflow.\\n  */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a);\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\\n  * reverts when dividing by zero.\\n  */\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0);\\n    return a % b;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/claims/ClaimsData.sol\": {\r\n      \"content\": \"/* Copyright (C) 2020 NexusMutual.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../../abstract/Iupgradable.sol\\\";\\n\\ncontract ClaimsData is Iupgradable {\\n  using SafeMath for uint;\\n\\n  struct Claim {\\n    uint coverId;\\n    uint dateUpd;\\n  }\\n\\n  struct Vote {\\n    address voter;\\n    uint tokens;\\n    uint claimId;\\n    int8 verdict;\\n    bool rewardClaimed;\\n  }\\n\\n  struct ClaimsPause {\\n    uint coverid;\\n    uint dateUpd;\\n    bool submit;\\n  }\\n\\n  struct ClaimPauseVoting {\\n    uint claimid;\\n    uint pendingTime;\\n    bool voting;\\n  }\\n\\n  struct RewardDistributed {\\n    uint lastCAvoteIndex;\\n    uint lastMVvoteIndex;\\n\\n  }\\n\\n  struct ClaimRewardDetails {\\n    uint percCA;\\n    uint percMV;\\n    uint tokenToBeDist;\\n\\n  }\\n\\n  struct ClaimTotalTokens {\\n    uint accept;\\n    uint deny;\\n  }\\n\\n  struct ClaimRewardStatus {\\n    uint percCA;\\n    uint percMV;\\n  }\\n\\n  ClaimRewardStatus[] internal rewardStatus;\\n\\n  Claim[] internal allClaims;\\n  Vote[] internal allvotes;\\n  ClaimsPause[] internal claimPause;\\n  ClaimPauseVoting[] internal claimPauseVotingEP;\\n\\n  mapping(address => RewardDistributed) internal voterVoteRewardReceived;\\n  mapping(uint => ClaimRewardDetails) internal claimRewardDetail;\\n  mapping(uint => ClaimTotalTokens) internal claimTokensCA;\\n  mapping(uint => ClaimTotalTokens) internal claimTokensMV;\\n  mapping(uint => int8) internal claimVote;\\n  mapping(uint => uint) internal claimsStatus;\\n  mapping(uint => uint) internal claimState12Count;\\n  mapping(uint => uint[]) internal claimVoteCA;\\n  mapping(uint => uint[]) internal claimVoteMember;\\n  mapping(address => uint[]) internal voteAddressCA;\\n  mapping(address => uint[]) internal voteAddressMember;\\n  mapping(address => uint[]) internal allClaimsByAddress;\\n  mapping(address => mapping(uint => uint)) internal userClaimVoteCA;\\n  mapping(address => mapping(uint => uint)) internal userClaimVoteMember;\\n  mapping(address => uint) public userClaimVotePausedOn;\\n\\n  uint internal claimPauseLastsubmit;\\n  uint internal claimStartVotingFirstIndex;\\n  uint public pendingClaimStart;\\n  uint public claimDepositTime;\\n  uint public maxVotingTime;\\n  uint public minVotingTime;\\n  uint public payoutRetryTime;\\n  uint public claimRewardPerc;\\n  uint public minVoteThreshold;\\n  uint public maxVoteThreshold;\\n  uint public majorityConsensus;\\n  uint public pauseDaysCA;\\n\\n  event ClaimRaise(\\n    uint indexed coverId,\\n    address indexed userAddress,\\n    uint claimId,\\n    uint dateSubmit\\n  );\\n\\n  event VoteCast(\\n    address indexed userAddress,\\n    uint indexed claimId,\\n    bytes4 indexed typeOf,\\n    uint tokens,\\n    uint submitDate,\\n    int8 verdict\\n  );\\n\\n  constructor() public {\\n    pendingClaimStart = 1;\\n    maxVotingTime = 48 * 1 hours;\\n    minVotingTime = 12 * 1 hours;\\n    payoutRetryTime = 24 * 1 hours;\\n    allvotes.push(Vote(address(0), 0, 0, 0, false));\\n    allClaims.push(Claim(0, 0));\\n    claimDepositTime = 7 days;\\n    claimRewardPerc = 20;\\n    minVoteThreshold = 5;\\n    maxVoteThreshold = 10;\\n    majorityConsensus = 70;\\n    pauseDaysCA = 3 days;\\n    _addRewardIncentive();\\n  }\\n\\n  /**\\n   * @dev Updates the pending claim start variable,\\n   * the lowest claim id with a pending decision/payout.\\n   */\\n  function setpendingClaimStart(uint _start) external onlyInternal {\\n    require(pendingClaimStart <= _start);\\n    pendingClaimStart = _start;\\n  }\\n\\n  /**\\n   * @dev Updates the max vote index for which claim assessor has received reward\\n   * @param _voter address of the voter.\\n   * @param caIndex last index till which reward was distributed for CA\\n   */\\n  function setRewardDistributedIndexCA(address _voter, uint caIndex) external onlyInternal {\\n    voterVoteRewardReceived[_voter].lastCAvoteIndex = caIndex;\\n\\n  }\\n\\n  /**\\n   * @dev Used to pause claim assessor activity for 3 days\\n   * @param user Member address whose claim voting ability needs to be paused\\n   */\\n  function setUserClaimVotePausedOn(address user) external {\\n    require(ms.checkIsAuthToGoverned(msg.sender));\\n    userClaimVotePausedOn[user] = now;\\n  }\\n\\n  /**\\n   * @dev Updates the max vote index for which member has received reward\\n   * @param _voter address of the voter.\\n   * @param mvIndex last index till which reward was distributed for member\\n   */\\n  function setRewardDistributedIndexMV(address _voter, uint mvIndex) external onlyInternal {\\n\\n    voterVoteRewardReceived[_voter].lastMVvoteIndex = mvIndex;\\n  }\\n\\n  /**\\n   * @param claimid claim id.\\n   * @param percCA reward Percentage reward for claim assessor\\n   * @param percMV reward Percentage reward for members\\n   * @param tokens total tokens to be rewarded\\n   */\\n  function setClaimRewardDetail(\\n    uint claimid,\\n    uint percCA,\\n    uint percMV,\\n    uint tokens\\n  )\\n  external\\n  onlyInternal\\n  {\\n    claimRewardDetail[claimid].percCA = percCA;\\n    claimRewardDetail[claimid].percMV = percMV;\\n    claimRewardDetail[claimid].tokenToBeDist = tokens;\\n  }\\n\\n  /**\\n   * @dev Sets the reward claim status against a vote id.\\n   * @param _voteid vote Id.\\n   * @param claimed true if reward for vote is claimed, else false.\\n   */\\n  function setRewardClaimed(uint _voteid, bool claimed) external onlyInternal {\\n    allvotes[_voteid].rewardClaimed = claimed;\\n  }\\n\\n  /**\\n   * @dev Sets the final vote's result(either accepted or declined)of a claim.\\n   * @param _claimId Claim Id.\\n   * @param _verdict 1 if claim is accepted,-1 if declined.\\n   */\\n  function changeFinalVerdict(uint _claimId, int8 _verdict) external onlyInternal {\\n    claimVote[_claimId] = _verdict;\\n  }\\n\\n  /**\\n   * @dev Creates a new claim.\\n   */\\n  function addClaim(\\n    uint _claimId,\\n    uint _coverId,\\n    address _from,\\n    uint _nowtime\\n  )\\n  external\\n  onlyInternal\\n  {\\n    allClaims.push(Claim(_coverId, _nowtime));\\n    allClaimsByAddress[_from].push(_claimId);\\n  }\\n\\n  /**\\n   * @dev Add Vote's details of a given claim.\\n   */\\n  function addVote(\\n    address _voter,\\n    uint _tokens,\\n    uint claimId,\\n    int8 _verdict\\n  )\\n  external\\n  onlyInternal\\n  {\\n    allvotes.push(Vote(_voter, _tokens, claimId, _verdict, false));\\n  }\\n\\n  /**\\n   * @dev Stores the id of the claim assessor vote given to a claim.\\n   * Maintains record of all votes given by all the CA to a claim.\\n   * @param _claimId Claim Id to which vote has given by the CA.\\n   * @param _voteid Vote Id.\\n   */\\n  function addClaimVoteCA(uint _claimId, uint _voteid) external onlyInternal {\\n    claimVoteCA[_claimId].push(_voteid);\\n  }\\n\\n  /**\\n   * @dev Sets the id of the vote.\\n   * @param _from Claim assessor's address who has given the vote.\\n   * @param _claimId Claim Id for which vote has been given by the CA.\\n   * @param _voteid Vote Id which will be stored against the given _from and claimid.\\n   */\\n  function setUserClaimVoteCA(\\n    address _from,\\n    uint _claimId,\\n    uint _voteid\\n  )\\n  external\\n  onlyInternal\\n  {\\n    userClaimVoteCA[_from][_claimId] = _voteid;\\n    voteAddressCA[_from].push(_voteid);\\n  }\\n\\n  /**\\n   * @dev Stores the tokens locked by the Claim Assessors during voting of a given claim.\\n   * @param _claimId Claim Id.\\n   * @param _vote 1 for accept and increases the tokens of claim as accept,\\n   * -1 for deny and increases the tokens of claim as deny.\\n   * @param _tokens Number of tokens.\\n   */\\n  function setClaimTokensCA(uint _claimId, int8 _vote, uint _tokens) external onlyInternal {\\n    if (_vote == 1)\\n      claimTokensCA[_claimId].accept = claimTokensCA[_claimId].accept.add(_tokens);\\n    if (_vote == - 1)\\n      claimTokensCA[_claimId].deny = claimTokensCA[_claimId].deny.add(_tokens);\\n  }\\n\\n  /**\\n   * @dev Stores the tokens locked by the Members during voting of a given claim.\\n   * @param _claimId Claim Id.\\n   * @param _vote 1 for accept and increases the tokens of claim as accept,\\n   * -1 for deny and increases the tokens of claim as deny.\\n   * @param _tokens Number of tokens.\\n   */\\n  function setClaimTokensMV(uint _claimId, int8 _vote, uint _tokens) external onlyInternal {\\n    if (_vote == 1)\\n      claimTokensMV[_claimId].accept = claimTokensMV[_claimId].accept.add(_tokens);\\n    if (_vote == - 1)\\n      claimTokensMV[_claimId].deny = claimTokensMV[_claimId].deny.add(_tokens);\\n  }\\n\\n  /**\\n   * @dev Stores the id of the member vote given to a claim.\\n   * Maintains record of all votes given by all the Members to a claim.\\n   * @param _claimId Claim Id to which vote has been given by the Member.\\n   * @param _voteid Vote Id.\\n   */\\n  function addClaimVotemember(uint _claimId, uint _voteid) external onlyInternal {\\n    claimVoteMember[_claimId].push(_voteid);\\n  }\\n\\n  /**\\n   * @dev Sets the id of the vote.\\n   * @param _from Member's address who has given the vote.\\n   * @param _claimId Claim Id for which vote has been given by the Member.\\n   * @param _voteid Vote Id which will be stored against the given _from and claimid.\\n   */\\n  function setUserClaimVoteMember(\\n    address _from,\\n    uint _claimId,\\n    uint _voteid\\n  )\\n  external\\n  onlyInternal\\n  {\\n    userClaimVoteMember[_from][_claimId] = _voteid;\\n    voteAddressMember[_from].push(_voteid);\\n\\n  }\\n\\n  /**\\n   * @dev Increases the count of failure until payout of a claim is successful.\\n   */\\n  function updateState12Count(uint _claimId, uint _cnt) external onlyInternal {\\n    claimState12Count[_claimId] = claimState12Count[_claimId].add(_cnt);\\n  }\\n\\n  /**\\n   * @dev Sets status of a claim.\\n   * @param _claimId Claim Id.\\n   * @param _stat Status number.\\n   */\\n  function setClaimStatus(uint _claimId, uint _stat) external onlyInternal {\\n    claimsStatus[_claimId] = _stat;\\n  }\\n\\n  /**\\n   * @dev Sets the timestamp of a given claim at which the Claim's details has been updated.\\n   * @param _claimId Claim Id of claim which has been changed.\\n   * @param _dateUpd timestamp at which claim is updated.\\n   */\\n  function setClaimdateUpd(uint _claimId, uint _dateUpd) external onlyInternal {\\n    allClaims[_claimId].dateUpd = _dateUpd;\\n  }\\n\\n  /**\\n   @dev Queues Claims during Emergency Pause.\\n   */\\n  function setClaimAtEmergencyPause(\\n    uint _coverId,\\n    uint _dateUpd,\\n    bool _submit\\n  )\\n  external\\n  onlyInternal\\n  {\\n    claimPause.push(ClaimsPause(_coverId, _dateUpd, _submit));\\n  }\\n\\n  /**\\n   * @dev Set submission flag for Claims queued during emergency pause.\\n   * Set to true after EP is turned off and the claim is submitted .\\n   */\\n  function setClaimSubmittedAtEPTrue(uint _index, bool _submit) external onlyInternal {\\n    claimPause[_index].submit = _submit;\\n  }\\n\\n  /**\\n   * @dev Sets the index from which claim needs to be\\n   * submitted when emergency pause is swithched off.\\n   */\\n  function setFirstClaimIndexToSubmitAfterEP(\\n    uint _firstClaimIndexToSubmit\\n  )\\n  external\\n  onlyInternal\\n  {\\n    claimPauseLastsubmit = _firstClaimIndexToSubmit;\\n  }\\n\\n  /**\\n   * @dev Sets the pending vote duration for a claim in case of emergency pause.\\n   */\\n  function setPendingClaimDetails(\\n    uint _claimId,\\n    uint _pendingTime,\\n    bool _voting\\n  )\\n  external\\n  onlyInternal\\n  {\\n    claimPauseVotingEP.push(ClaimPauseVoting(_claimId, _pendingTime, _voting));\\n  }\\n\\n  /**\\n   * @dev Sets voting flag true after claim is reopened for voting after emergency pause.\\n   */\\n  function setPendingClaimVoteStatus(uint _claimId, bool _vote) external onlyInternal {\\n    claimPauseVotingEP[_claimId].voting = _vote;\\n  }\\n\\n  /**\\n   * @dev Sets the index from which claim needs to be\\n   * reopened when emergency pause is swithched off.\\n   */\\n  function setFirstClaimIndexToStartVotingAfterEP(\\n    uint _claimStartVotingFirstIndex\\n  )\\n  external\\n  onlyInternal\\n  {\\n    claimStartVotingFirstIndex = _claimStartVotingFirstIndex;\\n  }\\n\\n  /**\\n   * @dev Calls Vote Event.\\n   */\\n  function callVoteEvent(\\n    address _userAddress,\\n    uint _claimId,\\n    bytes4 _typeOf,\\n    uint _tokens,\\n    uint _submitDate,\\n    int8 _verdict\\n  )\\n  external\\n  onlyInternal\\n  {\\n    emit VoteCast(\\n      _userAddress,\\n      _claimId,\\n      _typeOf,\\n      _tokens,\\n      _submitDate,\\n      _verdict\\n    );\\n  }\\n\\n  /**\\n   * @dev Calls Claim Event.\\n   */\\n  function callClaimEvent(\\n    uint _coverId,\\n    address _userAddress,\\n    uint _claimId,\\n    uint _datesubmit\\n  )\\n  external\\n  onlyInternal\\n  {\\n    emit ClaimRaise(_coverId, _userAddress, _claimId, _datesubmit);\\n  }\\n\\n  /**\\n   * @dev Gets Uint Parameters by parameter code\\n   * @param code whose details we want\\n   * @return string value of the parameter\\n   * @return associated amount (time or perc or value) to the code\\n   */\\n  function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val) {\\n    codeVal = code;\\n    if (code == \\\"CAMAXVT\\\") {\\n      val = maxVotingTime / (1 hours);\\n\\n    } else if (code == \\\"CAMINVT\\\") {\\n\\n      val = minVotingTime / (1 hours);\\n\\n    } else if (code == \\\"CAPRETRY\\\") {\\n\\n      val = payoutRetryTime / (1 hours);\\n\\n    } else if (code == \\\"CADEPT\\\") {\\n\\n      val = claimDepositTime / (1 days);\\n\\n    } else if (code == \\\"CAREWPER\\\") {\\n\\n      val = claimRewardPerc;\\n\\n    } else if (code == \\\"CAMINTH\\\") {\\n\\n      val = minVoteThreshold;\\n\\n    } else if (code == \\\"CAMAXTH\\\") {\\n\\n      val = maxVoteThreshold;\\n\\n    } else if (code == \\\"CACONPER\\\") {\\n\\n      val = majorityConsensus;\\n\\n    } else if (code == \\\"CAPAUSET\\\") {\\n      val = pauseDaysCA / (1 days);\\n    }\\n\\n  }\\n\\n  /**\\n   * @dev Get claim queued during emergency pause by index.\\n   */\\n  function getClaimOfEmergencyPauseByIndex(\\n    uint _index\\n  )\\n  external\\n  view\\n  returns (\\n    uint coverId,\\n    uint dateUpd,\\n    bool submit\\n  )\\n  {\\n    coverId = claimPause[_index].coverid;\\n    dateUpd = claimPause[_index].dateUpd;\\n    submit = claimPause[_index].submit;\\n  }\\n\\n  /**\\n   * @dev Gets the Claim's details of given claimid.\\n   */\\n  function getAllClaimsByIndex(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint coverId,\\n    int8 vote,\\n    uint status,\\n    uint dateUpd,\\n    uint state12Count\\n  )\\n  {\\n    return (\\n    allClaims[_claimId].coverId,\\n    claimVote[_claimId],\\n    claimsStatus[_claimId],\\n    allClaims[_claimId].dateUpd,\\n    claimState12Count[_claimId]\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets the vote id of a given claim of a given Claim Assessor.\\n   */\\n  function getUserClaimVoteCA(\\n    address _add,\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (uint idVote)\\n  {\\n    return userClaimVoteCA[_add][_claimId];\\n  }\\n\\n  /**\\n   * @dev Gets the vote id of a given claim of a given member.\\n   */\\n  function getUserClaimVoteMember(\\n    address _add,\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (uint idVote)\\n  {\\n    return userClaimVoteMember[_add][_claimId];\\n  }\\n\\n  /**\\n   * @dev Gets the count of all votes.\\n   */\\n  function getAllVoteLength() external view returns (uint voteCount) {\\n    return allvotes.length.sub(1); // Start Index always from 1.\\n  }\\n\\n  /**\\n   * @dev Gets the status number of a given claim.\\n   * @param _claimId Claim id.\\n   * @return statno Status Number.\\n   */\\n  function getClaimStatusNumber(uint _claimId) external view returns (uint claimId, uint statno) {\\n    return (_claimId, claimsStatus[_claimId]);\\n  }\\n\\n  /**\\n   * @dev Gets the reward percentage to be distributed for a given status id\\n   * @param statusNumber the number of type of status\\n   * @return percCA reward Percentage for claim assessor\\n   * @return percMV reward Percentage for members\\n   */\\n  function getRewardStatus(uint statusNumber) external view returns (uint percCA, uint percMV) {\\n    return (rewardStatus[statusNumber].percCA, rewardStatus[statusNumber].percMV);\\n  }\\n\\n  /**\\n   * @dev Gets the number of tries that have been made for a successful payout of a Claim.\\n   */\\n  function getClaimState12Count(uint _claimId) external view returns (uint num) {\\n    num = claimState12Count[_claimId];\\n  }\\n\\n  /**\\n   * @dev Gets the last update date of a claim.\\n   */\\n  function getClaimDateUpd(uint _claimId) external view returns (uint dateupd) {\\n    dateupd = allClaims[_claimId].dateUpd;\\n  }\\n\\n  /**\\n   * @dev Gets all Claims created by a user till date.\\n   * @param _member user's address.\\n   * @return claimarr List of Claims id.\\n   */\\n  function getAllClaimsByAddress(address _member) external view returns (uint[] memory claimarr) {\\n    return allClaimsByAddress[_member];\\n  }\\n\\n  /**\\n   * @dev Gets the number of tokens that has been locked\\n   * while giving vote to a claim by  Claim Assessors.\\n   * @param _claimId Claim Id.\\n   * @return accept Total number of tokens when CA accepts the claim.\\n   * @return deny Total number of tokens when CA declines the claim.\\n   */\\n  function getClaimsTokenCA(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint accept,\\n    uint deny\\n  )\\n  {\\n    return (\\n    _claimId,\\n    claimTokensCA[_claimId].accept,\\n    claimTokensCA[_claimId].deny\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets the number of tokens that have been\\n   * locked while assessing a claim as a member.\\n   * @param _claimId Claim Id.\\n   * @return accept Total number of tokens in acceptance of the claim.\\n   * @return deny Total number of tokens against the claim.\\n   */\\n  function getClaimsTokenMV(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint accept,\\n    uint deny\\n  )\\n  {\\n    return (\\n    _claimId,\\n    claimTokensMV[_claimId].accept,\\n    claimTokensMV[_claimId].deny\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets the total number of votes cast as Claims assessor for/against a given claim\\n   */\\n  function getCaClaimVotesToken(uint _claimId) external view returns (uint claimId, uint cnt) {\\n    claimId = _claimId;\\n    cnt = 0;\\n    for (uint i = 0; i < claimVoteCA[_claimId].length; i++) {\\n      cnt = cnt.add(allvotes[claimVoteCA[_claimId][i]].tokens);\\n    }\\n  }\\n\\n  /**\\n   * @dev Gets the total number of tokens cast as a member for/against a given claim\\n   */\\n  function getMemberClaimVotesToken(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (uint claimId, uint cnt)\\n  {\\n    claimId = _claimId;\\n    cnt = 0;\\n    for (uint i = 0; i < claimVoteMember[_claimId].length; i++) {\\n      cnt = cnt.add(allvotes[claimVoteMember[_claimId][i]].tokens);\\n    }\\n  }\\n\\n  /**\\n   * @dev Provides information of a vote when given its vote id.\\n   * @param _voteid Vote Id.\\n   */\\n  function getVoteDetails(uint _voteid)\\n  external view\\n  returns (\\n    uint tokens,\\n    uint claimId,\\n    int8 verdict,\\n    bool rewardClaimed\\n  )\\n  {\\n    return (\\n    allvotes[_voteid].tokens,\\n    allvotes[_voteid].claimId,\\n    allvotes[_voteid].verdict,\\n    allvotes[_voteid].rewardClaimed\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets the voter's address of a given vote id.\\n   */\\n  function getVoterVote(uint _voteid) external view returns (address voter) {\\n    return allvotes[_voteid].voter;\\n  }\\n\\n  /**\\n   * @dev Provides information of a Claim when given its claim id.\\n   * @param _claimId Claim Id.\\n   */\\n  function getClaim(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint coverId,\\n    int8 vote,\\n    uint status,\\n    uint dateUpd,\\n    uint state12Count\\n  )\\n  {\\n    return (\\n    _claimId,\\n    allClaims[_claimId].coverId,\\n    claimVote[_claimId],\\n    claimsStatus[_claimId],\\n    allClaims[_claimId].dateUpd,\\n    claimState12Count[_claimId]\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets the total number of votes of a given claim.\\n   * @param _claimId Claim Id.\\n   * @param _ca if 1: votes given by Claim Assessors to a claim,\\n   * else returns the number of votes of given by Members to a claim.\\n   * @return len total number of votes for/against a given claim.\\n   */\\n  function getClaimVoteLength(\\n    uint _claimId,\\n    uint8 _ca\\n  )\\n  external\\n  view\\n  returns (uint claimId, uint len)\\n  {\\n    claimId = _claimId;\\n    if (_ca == 1)\\n      len = claimVoteCA[_claimId].length;\\n    else\\n      len = claimVoteMember[_claimId].length;\\n  }\\n\\n  /**\\n   * @dev Gets the verdict of a vote using claim id and index.\\n   * @param _ca 1 for vote given as a CA, else for vote given as a member.\\n   * @return ver 1 if vote was given in favour,-1 if given in against.\\n   */\\n  function getVoteVerdict(\\n    uint _claimId,\\n    uint _index,\\n    uint8 _ca\\n  )\\n  external\\n  view\\n  returns (int8 ver)\\n  {\\n    if (_ca == 1)\\n      ver = allvotes[claimVoteCA[_claimId][_index]].verdict;\\n    else\\n      ver = allvotes[claimVoteMember[_claimId][_index]].verdict;\\n  }\\n\\n  /**\\n   * @dev Gets the Number of tokens of a vote using claim id and index.\\n   * @param _ca 1 for vote given as a CA, else for vote given as a member.\\n   * @return tok Number of tokens.\\n   */\\n  function getVoteToken(\\n    uint _claimId,\\n    uint _index,\\n    uint8 _ca\\n  )\\n  external\\n  view\\n  returns (uint tok)\\n  {\\n    if (_ca == 1)\\n      tok = allvotes[claimVoteCA[_claimId][_index]].tokens;\\n    else\\n      tok = allvotes[claimVoteMember[_claimId][_index]].tokens;\\n  }\\n\\n  /**\\n   * @dev Gets the Voter's address of a vote using claim id and index.\\n   * @param _ca 1 for vote given as a CA, else for vote given as a member.\\n   * @return voter Voter's address.\\n   */\\n  function getVoteVoter(\\n    uint _claimId,\\n    uint _index,\\n    uint8 _ca\\n  )\\n  external\\n  view\\n  returns (address voter)\\n  {\\n    if (_ca == 1)\\n      voter = allvotes[claimVoteCA[_claimId][_index]].voter;\\n    else\\n      voter = allvotes[claimVoteMember[_claimId][_index]].voter;\\n  }\\n\\n  /**\\n   * @dev Gets total number of Claims created by a user till date.\\n   * @param _add User's address.\\n   */\\n  function getUserClaimCount(address _add) external view returns (uint len) {\\n    len = allClaimsByAddress[_add].length;\\n  }\\n\\n  /**\\n   * @dev Calculates number of Claims that are in pending state.\\n   */\\n  function getClaimLength() external view returns (uint len) {\\n    len = allClaims.length.sub(pendingClaimStart);\\n  }\\n\\n  /**\\n   * @dev Gets the Number of all the Claims created till date.\\n   */\\n  function actualClaimLength() external view returns (uint len) {\\n    len = allClaims.length;\\n  }\\n\\n  /**\\n   * @dev Gets details of a claim.\\n   * @param _index claim id = pending claim start + given index\\n   * @param _add User's address.\\n   * @return coverid cover against which claim has been submitted.\\n   * @return claimId Claim  Id.\\n   * @return voteCA verdict of vote given as a Claim Assessor.\\n   * @return voteMV verdict of vote given as a Member.\\n   * @return statusnumber Status of claim.\\n   */\\n  function getClaimFromNewStart(\\n    uint _index,\\n    address _add\\n  )\\n  external\\n  view\\n  returns (\\n    uint coverid,\\n    uint claimId,\\n    int8 voteCA,\\n    int8 voteMV,\\n    uint statusnumber\\n  )\\n  {\\n    uint i = pendingClaimStart.add(_index);\\n    coverid = allClaims[i].coverId;\\n    claimId = i;\\n    if (userClaimVoteCA[_add][i] > 0)\\n      voteCA = allvotes[userClaimVoteCA[_add][i]].verdict;\\n    else\\n      voteCA = 0;\\n\\n    if (userClaimVoteMember[_add][i] > 0)\\n      voteMV = allvotes[userClaimVoteMember[_add][i]].verdict;\\n    else\\n      voteMV = 0;\\n\\n    statusnumber = claimsStatus[i];\\n  }\\n\\n  /**\\n   * @dev Gets details of a claim of a user at a given index.\\n   */\\n  function getUserClaimByIndex(\\n    uint _index,\\n    address _add\\n  )\\n  external\\n  view\\n  returns (\\n    uint status,\\n    uint coverid,\\n    uint claimId\\n  )\\n  {\\n    claimId = allClaimsByAddress[_add][_index];\\n    status = claimsStatus[claimId];\\n    coverid = allClaims[claimId].coverId;\\n  }\\n\\n  /**\\n   * @dev Gets Id of all the votes given to a claim.\\n   * @param _claimId Claim Id.\\n   * @return ca id of all the votes given by Claim assessors to a claim.\\n   * @return mv id of all the votes given by members to a claim.\\n   */\\n  function getAllVotesForClaim(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint[] memory ca,\\n    uint[] memory mv\\n  )\\n  {\\n    return (_claimId, claimVoteCA[_claimId], claimVoteMember[_claimId]);\\n  }\\n\\n  /**\\n   * @dev Gets Number of tokens deposit in a vote using\\n   * Claim assessor's address and claim id.\\n   * @return tokens Number of deposited tokens.\\n   */\\n  function getTokensClaim(\\n    address _of,\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint tokens\\n  )\\n  {\\n    return (_claimId, allvotes[userClaimVoteCA[_of][_claimId]].tokens);\\n  }\\n\\n  /**\\n   * @param _voter address of the voter.\\n   * @return lastCAvoteIndex last index till which reward was distributed for CA\\n   * @return lastMVvoteIndex last index till which reward was distributed for member\\n   */\\n  function getRewardDistributedIndex(\\n    address _voter\\n  )\\n  external\\n  view\\n  returns (\\n    uint lastCAvoteIndex,\\n    uint lastMVvoteIndex\\n  )\\n  {\\n    return (\\n    voterVoteRewardReceived[_voter].lastCAvoteIndex,\\n    voterVoteRewardReceived[_voter].lastMVvoteIndex\\n    );\\n  }\\n\\n  /**\\n   * @param claimid claim id.\\n   * @return perc_CA reward Percentage for claim assessor\\n   * @return perc_MV reward Percentage for members\\n   * @return tokens total tokens to be rewarded\\n   */\\n  function getClaimRewardDetail(\\n    uint claimid\\n  )\\n  external\\n  view\\n  returns (\\n    uint percCA,\\n    uint percMV,\\n    uint tokens\\n  )\\n  {\\n    return (\\n    claimRewardDetail[claimid].percCA,\\n    claimRewardDetail[claimid].percMV,\\n    claimRewardDetail[claimid].tokenToBeDist\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets cover id of a claim.\\n   */\\n  function getClaimCoverId(uint _claimId) external view returns (uint claimId, uint coverid) {\\n    return (_claimId, allClaims[_claimId].coverId);\\n  }\\n\\n  /**\\n   * @dev Gets total number of tokens staked during voting by Claim Assessors.\\n   * @param _claimId Claim Id.\\n   * @param _verdict 1 to get total number of accept tokens, -1 to get total number of deny tokens.\\n   * @return token token Number of tokens(either accept or deny on the basis of verdict given as parameter).\\n   */\\n  function getClaimVote(uint _claimId, int8 _verdict) external view returns (uint claimId, uint token) {\\n    claimId = _claimId;\\n    token = 0;\\n    for (uint i = 0; i < claimVoteCA[_claimId].length; i++) {\\n      if (allvotes[claimVoteCA[_claimId][i]].verdict == _verdict)\\n        token = token.add(allvotes[claimVoteCA[_claimId][i]].tokens);\\n    }\\n  }\\n\\n  /**\\n   * @dev Gets total number of tokens staked during voting by Members.\\n   * @param _claimId Claim Id.\\n   * @param _verdict 1 to get total number of accept tokens,\\n   *  -1 to get total number of deny tokens.\\n   * @return token token Number of tokens(either accept or\\n   * deny on the basis of verdict given as parameter).\\n   */\\n  function getClaimMVote(uint _claimId, int8 _verdict) external view returns (uint claimId, uint token) {\\n    claimId = _claimId;\\n    token = 0;\\n    for (uint i = 0; i < claimVoteMember[_claimId].length; i++) {\\n      if (allvotes[claimVoteMember[_claimId][i]].verdict == _verdict)\\n        token = token.add(allvotes[claimVoteMember[_claimId][i]].tokens);\\n    }\\n  }\\n\\n  /**\\n   * @param _voter address  of voteid\\n   * @param index index to get voteid in CA\\n   */\\n  function getVoteAddressCA(address _voter, uint index) external view returns (uint) {\\n    return voteAddressCA[_voter][index];\\n  }\\n\\n  /**\\n   * @param _voter address  of voter\\n   * @param index index to get voteid in member vote\\n   */\\n  function getVoteAddressMember(address _voter, uint index) external view returns (uint) {\\n    return voteAddressMember[_voter][index];\\n  }\\n\\n  /**\\n   * @param _voter address  of voter\\n   */\\n  function getVoteAddressCALength(address _voter) external view returns (uint) {\\n    return voteAddressCA[_voter].length;\\n  }\\n\\n  /**\\n   * @param _voter address  of voter\\n   */\\n  function getVoteAddressMemberLength(address _voter) external view returns (uint) {\\n    return voteAddressMember[_voter].length;\\n  }\\n\\n  /**\\n   * @dev Gets the Final result of voting of a claim.\\n   * @param _claimId Claim id.\\n   * @return verdict 1 if claim is accepted, -1 if declined.\\n   */\\n  function getFinalVerdict(uint _claimId) external view returns (int8 verdict) {\\n    return claimVote[_claimId];\\n  }\\n\\n  /**\\n   * @dev Get number of Claims queued for submission during emergency pause.\\n   */\\n  function getLengthOfClaimSubmittedAtEP() external view returns (uint len) {\\n    len = claimPause.length;\\n  }\\n\\n  /**\\n   * @dev Gets the index from which claim needs to be\\n   * submitted when emergency pause is swithched off.\\n   */\\n  function getFirstClaimIndexToSubmitAfterEP() external view returns (uint indexToSubmit) {\\n    indexToSubmit = claimPauseLastsubmit;\\n  }\\n\\n  /**\\n   * @dev Gets number of Claims to be reopened for voting post emergency pause period.\\n   */\\n  function getLengthOfClaimVotingPause() external view returns (uint len) {\\n    len = claimPauseVotingEP.length;\\n  }\\n\\n  /**\\n   * @dev Gets claim details to be reopened for voting after emergency pause.\\n   */\\n  function getPendingClaimDetailsByIndex(\\n    uint _index\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint pendingTime,\\n    bool voting\\n  )\\n  {\\n    claimId = claimPauseVotingEP[_index].claimid;\\n    pendingTime = claimPauseVotingEP[_index].pendingTime;\\n    voting = claimPauseVotingEP[_index].voting;\\n  }\\n\\n  /**\\n   * @dev Gets the index from which claim needs to be reopened when emergency pause is swithched off.\\n   */\\n  function getFirstClaimIndexToStartVotingAfterEP() external view returns (uint firstindex) {\\n    firstindex = claimStartVotingFirstIndex;\\n  }\\n\\n  /**\\n   * @dev Updates Uint Parameters of a code\\n   * @param code whose details we want to update\\n   * @param val value to set\\n   */\\n  function updateUintParameters(bytes8 code, uint val) public {\\n    require(ms.checkIsAuthToGoverned(msg.sender));\\n    if (code == \\\"CAMAXVT\\\") {\\n      _setMaxVotingTime(val * 1 hours);\\n\\n    } else if (code == \\\"CAMINVT\\\") {\\n\\n      _setMinVotingTime(val * 1 hours);\\n\\n    } else if (code == \\\"CAPRETRY\\\") {\\n\\n      _setPayoutRetryTime(val * 1 hours);\\n\\n    } else if (code == \\\"CADEPT\\\") {\\n\\n      _setClaimDepositTime(val * 1 days);\\n\\n    } else if (code == \\\"CAREWPER\\\") {\\n\\n      _setClaimRewardPerc(val);\\n\\n    } else if (code == \\\"CAMINTH\\\") {\\n\\n      _setMinVoteThreshold(val);\\n\\n    } else if (code == \\\"CAMAXTH\\\") {\\n\\n      _setMaxVoteThreshold(val);\\n\\n    } else if (code == \\\"CACONPER\\\") {\\n\\n      _setMajorityConsensus(val);\\n\\n    } else if (code == \\\"CAPAUSET\\\") {\\n      _setPauseDaysCA(val * 1 days);\\n    } else {\\n\\n      revert(\\\"Invalid param code\\\");\\n    }\\n\\n  }\\n\\n  /**\\n   * @dev Iupgradable Interface to update dependent contract address\\n   */\\n  function changeDependentContractAddress() public onlyInternal {}\\n\\n  /**\\n   * @dev Adds status under which a claim can lie.\\n   * @param percCA reward percentage for claim assessor\\n   * @param percMV reward percentage for members\\n   */\\n  function _pushStatus(uint percCA, uint percMV) internal {\\n    rewardStatus.push(ClaimRewardStatus(percCA, percMV));\\n  }\\n\\n  /**\\n   * @dev adds reward incentive for all possible claim status for Claim assessors and members\\n   */\\n  function _addRewardIncentive() internal {\\n    _pushStatus(0, 0); // 0  Pending-Claim Assessor Vote\\n    _pushStatus(0, 0); // 1 Pending-Claim Assessor Vote Denied, Pending Member Vote\\n    _pushStatus(0, 0); // 2 Pending-CA Vote Threshold not Reached Accept, Pending Member Vote\\n    _pushStatus(0, 0); // 3 Pending-CA Vote Threshold not Reached Deny, Pending Member Vote\\n    _pushStatus(0, 0); // 4 Pending-CA Consensus not reached Accept, Pending Member Vote\\n    _pushStatus(0, 0); // 5 Pending-CA Consensus not reached Deny, Pending Member Vote\\n    _pushStatus(100, 0); // 6 Final-Claim Assessor Vote Denied\\n    _pushStatus(100, 0); // 7 Final-Claim Assessor Vote Accepted\\n    _pushStatus(0, 100); // 8 Final-Claim Assessor Vote Denied, MV Accepted\\n    _pushStatus(0, 100); // 9 Final-Claim Assessor Vote Denied, MV Denied\\n    _pushStatus(0, 0); // 10 Final-Claim Assessor Vote Accept, MV Nodecision\\n    _pushStatus(0, 0); // 11 Final-Claim Assessor Vote Denied, MV Nodecision\\n    _pushStatus(0, 0); // 12 Claim Accepted Payout Pending\\n    _pushStatus(0, 0); // 13 Claim Accepted No Payout\\n    _pushStatus(0, 0); // 14 Claim Accepted Payout Done\\n  }\\n\\n  /**\\n   * @dev Sets Maximum time(in seconds) for which claim assessment voting is open\\n   */\\n  function _setMaxVotingTime(uint _time) internal {\\n    maxVotingTime = _time;\\n  }\\n\\n  /**\\n   *  @dev Sets Minimum time(in seconds) for which claim assessment voting is open\\n   */\\n  function _setMinVotingTime(uint _time) internal {\\n    minVotingTime = _time;\\n  }\\n\\n  /**\\n   *  @dev Sets Minimum vote threshold required\\n   */\\n  function _setMinVoteThreshold(uint val) internal {\\n    minVoteThreshold = val;\\n  }\\n\\n  /**\\n   *  @dev Sets Maximum vote threshold required\\n   */\\n  function _setMaxVoteThreshold(uint val) internal {\\n    maxVoteThreshold = val;\\n  }\\n\\n  /**\\n   *  @dev Sets the value considered as Majority Consenus in voting\\n   */\\n  function _setMajorityConsensus(uint val) internal {\\n    majorityConsensus = val;\\n  }\\n\\n  /**\\n   * @dev Sets the payout retry time\\n   */\\n  function _setPayoutRetryTime(uint _time) internal {\\n    payoutRetryTime = _time;\\n  }\\n\\n  /**\\n   *  @dev Sets percentage of reward given for claim assessment\\n   */\\n  function _setClaimRewardPerc(uint _val) internal {\\n\\n    claimRewardPerc = _val;\\n  }\\n\\n  /**\\n   * @dev Sets the time for which claim is deposited.\\n   */\\n  function _setClaimDepositTime(uint _time) internal {\\n\\n    claimDepositTime = _time;\\n  }\\n\\n  /**\\n   *  @dev Sets number of days claim assessment will be paused\\n   */\\n  function _setPauseDaysCA(uint val) internal {\\n    pauseDaysCA = val;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/token/external/LockHandler.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @title ERC1132 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/1132\\n */\\n\\ncontract LockHandler {\\n  /**\\n   * @dev Reasons why a user's tokens have been locked\\n   */\\n  mapping(address => bytes32[]) public lockReason;\\n\\n  /**\\n   * @dev locked token structure\\n   */\\n  struct LockToken {\\n    uint256 amount;\\n    uint256 validity;\\n    bool claimed;\\n  }\\n\\n  /**\\n   * @dev Holds number & validity of tokens locked for a given reason for\\n   *      a specified address\\n   */\\n  mapping(address => mapping(bytes32 => LockToken)) public locked;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BurnCATokens\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"claimid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"}],\"name\":\"burnCAToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"coverId\",\"type\":\"uint256\"}],\"name\":\"burnDepositCN\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"changeDependentContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_masterAddress\",\"type\":\"address\"}],\"name\":\"changeMasterAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_coverId\",\"type\":\"uint256\"}],\"name\":\"getLockedCNAgainstCover\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"}],\"name\":\"getUserAllLockedCNTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_coverId\",\"type\":\"uint256\"}],\"name\":\"getUserLockedCNTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"}],\"name\":\"isLockedForMemberVote\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"coverNoteAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coverPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coverId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"}],\"name\":\"lockCN\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ms\",\"outputs\":[{\"internalType\":\"contract INXMMaster\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nxMasterAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pooledStaking\",\"outputs\":[{\"internalType\":\"contract IPooledStaking\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_coverPriceNXM\",\"type\":\"uint256\"}],\"name\":\"pushStakerRewards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"qd\",\"outputs\":[{\"internalType\":\"contract QuotationData\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tc\",\"outputs\":[{\"internalType\":\"contract TokenController\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"td\",\"outputs\":[{\"internalType\":\"contract TokenData\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tk\",\"outputs\":[{\"internalType\":\"contract NXMToken\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"coverId\",\"type\":\"uint256\"}],\"name\":\"unlockCN\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"TokenFunctions","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}