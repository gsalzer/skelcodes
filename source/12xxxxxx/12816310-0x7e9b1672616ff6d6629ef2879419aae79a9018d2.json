{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/dependencies/open-zeppelin/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.5;\\n\\nimport \\\"./Context.sol\\\";\\nimport \\\"./Strings.sol\\\";\\nimport \\\"./ERC165.sol\\\";\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    function grantRole(bytes32 role, address account) external;\\n\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role, _msgSender());\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        Strings.toHexString(uint160(account), 20),\\n                        \\\" is missing role \\\",\\n                        Strings.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\\n        _roles[role].adminRole = adminRole;\\n    }\\n\\n    function _grantRole(bytes32 role, address account) private {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    function _revokeRole(bytes32 role, address account) private {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n  function _msgSender() internal view virtual returns (address payable) {\\n    return msg.sender;\\n  }\\n\\n  function _msgData() internal view virtual returns (bytes memory) {\\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n    return msg.data;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n  bytes16 private constant alphabet = '0123456789abcdef';\\n\\n  /**\\n   * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n   */\\n  function toString(uint256 value) internal pure returns (string memory) {\\n    // Inspired by OraclizeAPI's implementation - MIT licence\\n    // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n    if (value == 0) {\\n      return '0';\\n    }\\n    uint256 temp = value;\\n    uint256 digits;\\n    while (temp != 0) {\\n      digits++;\\n      temp /= 10;\\n    }\\n    bytes memory buffer = new bytes(digits);\\n    while (value != 0) {\\n      digits -= 1;\\n      buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n      value /= 10;\\n    }\\n    return string(buffer);\\n  }\\n\\n  /**\\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n   */\\n  function toHexString(uint256 value) internal pure returns (string memory) {\\n    if (value == 0) {\\n      return '0x00';\\n    }\\n    uint256 temp = value;\\n    uint256 length = 0;\\n    while (temp != 0) {\\n      length++;\\n      temp >>= 8;\\n    }\\n    return toHexString(value, length);\\n  }\\n\\n  /**\\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n   */\\n  function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n    bytes memory buffer = new bytes(2 * length + 2);\\n    buffer[0] = '0';\\n    buffer[1] = 'x';\\n    for (uint256 i = 2 * length + 1; i > 1; --i) {\\n      buffer[i] = alphabet[value & 0xf];\\n      value >>= 4;\\n    }\\n    require(value == 0, 'Strings: hex length insufficient');\\n    return string(buffer);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\nimport './IERC165.sol';\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n  /**\\n   * @dev See {IERC165-supportsInterface}.\\n   */\\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n    return interfaceId == type(IERC165).interfaceId;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n  /**\\n   * @dev Returns true if this contract implements the interface defined by\\n   * `interfaceId`. See the corresponding\\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n   * to learn more about how these ids are created.\\n   *\\n   * This function call must use less than 30 000 gas.\\n   */\\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/governance/DydxGovernor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n//\\n// Contracts by dYdX Foundation. Individual files are released under different licenses.\\n//\\n// https://dydx.community\\n// https://github.com/dydxfoundation/governance-contracts\\n\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport { AccessControl } from '../dependencies/open-zeppelin/AccessControl.sol';\\nimport { SafeMath } from '../dependencies/open-zeppelin/SafeMath.sol';\\nimport { IDydxGovernor } from '../interfaces/IDydxGovernor.sol';\\nimport { IExecutorWithTimelock } from '../interfaces/IExecutorWithTimelock.sol';\\nimport { IGovernanceStrategy } from '../interfaces/IGovernanceStrategy.sol';\\nimport { IProposalValidator } from '../interfaces/IProposalValidator.sol';\\nimport { IVotingStrategy } from '../interfaces/IVotingStrategy.sol';\\nimport { isContract, getChainId } from '../misc/Helpers.sol';\\n\\n/**\\n * @title dYdX governor contract.\\n * @author dYdX\\n *\\n * @notice Main point of interaction for dYdX governance. Holds governance proposals. Delegates to\\n *  the governance strategy contract to determine how voting and proposing powers are counted. The\\n *  content of a proposal is a sequence of function calls. These function calls must be made\\n *  through authorized executor contracts.\\n *\\n *  Functionality includes:\\n *    - Create a proposal\\n *    - Cancel a proposal\\n *    - Queue a proposal\\n *    - Execute a proposal\\n *    - Submit a vote to a proposal\\n *\\n *  Proposal state transitions in success case:\\n *\\n *    Pending => Active => Succeeded => Queued => Executed\\n *\\n *  Proposal state transitions in failure cases:\\n *\\n *    Pending => Active => Failed\\n *    Pending => Active => Succeeded => Queued => Expired\\n *    Pending => Canceled\\n *    Pending => Active => Canceled\\n *    Pending => Active => Succeeded => Canceled\\n *    Pending => Active => Succeeded => Queued => Canceled\\n **/\\ncontract DydxGovernor is\\n  AccessControl,\\n  IDydxGovernor\\n{\\n  using SafeMath for uint256;\\n\\n  // ============ Constants ============\\n\\n  bytes32 public constant OWNER_ROLE = keccak256('OWNER_ROLE');\\n  bytes32 public constant ADD_EXECUTOR_ROLE = keccak256('ADD_EXECUTOR_ROLE');\\n\\n  // ============ Storage ============\\n\\n  address private _governanceStrategy;\\n  uint256 private _votingDelay;\\n  uint256 private _proposalsCount;\\n  mapping(uint256 => Proposal) private _proposals;\\n  mapping(address => bool) private _authorizedExecutors;\\n\\n  bytes32 public constant DOMAIN_TYPEHASH = keccak256(\\n    'EIP712Domain(string name,uint256 chainId,address verifyingContract)'\\n  );\\n  bytes32 public constant VOTE_EMITTED_TYPEHASH = keccak256(\\n    'VoteEmitted(uint256 id,bool support)'\\n  );\\n  string public constant EIP712_DOMAIN_NAME = 'dYdX Governance';\\n\\n  constructor(\\n    address governanceStrategy,\\n    uint256 votingDelay,\\n    address addExecutorAdmin\\n  ) {\\n    _setGovernanceStrategy(governanceStrategy);\\n    _setVotingDelay(votingDelay);\\n\\n    // Assign roles.\\n    _setupRole(OWNER_ROLE, msg.sender);\\n    _setupRole(ADD_EXECUTOR_ROLE, addExecutorAdmin);\\n\\n    // Set OWNER_ROLE as the admin for all roles.\\n    _setRoleAdmin(OWNER_ROLE, OWNER_ROLE);\\n    _setRoleAdmin(ADD_EXECUTOR_ROLE, OWNER_ROLE);\\n  }\\n\\n  struct CreateVars {\\n    uint256 startBlock;\\n    uint256 endBlock;\\n    uint256 previousProposalsCount;\\n  }\\n\\n  /**\\n   * @notice Creates a Proposal (needs to be validated by the Proposal Validator)\\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\\n   * @param targets list of contracts called by proposal's associated transactions\\n   * @param values list of value in wei for each propoposal's associated transaction\\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\\n   * @param withDelegatecalls boolean, true = transaction delegatecalls the taget, else calls the target\\n   * @param ipfsHash IPFS hash of the proposal\\n   **/\\n  function create(\\n    IExecutorWithTimelock executor,\\n    address[] memory targets,\\n    uint256[] memory values,\\n    string[] memory signatures,\\n    bytes[] memory calldatas,\\n    bool[] memory withDelegatecalls,\\n    bytes32 ipfsHash\\n  ) external override returns (uint256) {\\n    require(targets.length != 0, 'INVALID_EMPTY_TARGETS');\\n    require(\\n      targets.length == values.length &&\\n        targets.length == signatures.length &&\\n        targets.length == calldatas.length &&\\n        targets.length == withDelegatecalls.length,\\n      'INCONSISTENT_PARAMS_LENGTH'\\n    );\\n\\n    require(isExecutorAuthorized(address(executor)), 'EXECUTOR_NOT_AUTHORIZED');\\n\\n    require(\\n      IProposalValidator(address(executor)).validateCreatorOfProposal(\\n        this,\\n        msg.sender,\\n        block.number - 1\\n      ),\\n      'PROPOSITION_CREATION_INVALID'\\n    );\\n\\n    CreateVars memory vars;\\n\\n    vars.startBlock = block.number.add(_votingDelay);\\n    vars.endBlock = vars.startBlock.add(IProposalValidator(address(executor)).VOTING_DURATION());\\n\\n    vars.previousProposalsCount = _proposalsCount;\\n\\n    Proposal storage newProposal = _proposals[vars.previousProposalsCount];\\n    newProposal.id = vars.previousProposalsCount;\\n    newProposal.creator = msg.sender;\\n    newProposal.executor = executor;\\n    newProposal.targets = targets;\\n    newProposal.values = values;\\n    newProposal.signatures = signatures;\\n    newProposal.calldatas = calldatas;\\n    newProposal.withDelegatecalls = withDelegatecalls;\\n    newProposal.startBlock = vars.startBlock;\\n    newProposal.endBlock = vars.endBlock;\\n    newProposal.strategy = _governanceStrategy;\\n    newProposal.ipfsHash = ipfsHash;\\n    _proposalsCount = vars.previousProposalsCount + 1;\\n\\n    emit ProposalCreated(\\n      vars.previousProposalsCount,\\n      msg.sender,\\n      executor,\\n      targets,\\n      values,\\n      signatures,\\n      calldatas,\\n      withDelegatecalls,\\n      vars.startBlock,\\n      vars.endBlock,\\n      _governanceStrategy,\\n      ipfsHash\\n    );\\n\\n    return newProposal.id;\\n  }\\n\\n  /**\\n   * @dev Cancels a Proposal. Callable by anyone if the conditions on the executor are fulfilled.\\n   * @param proposalId id of the proposal\\n   **/\\n  function cancel(uint256 proposalId) external override {\\n    ProposalState state = getProposalState(proposalId);\\n    require(\\n      state != ProposalState.Canceled &&\\n        state != ProposalState.Failed &&\\n        state != ProposalState.Expired &&\\n        state != ProposalState.Executed,\\n      'ONLY_BEFORE_EXECUTED'\\n    );\\n\\n    Proposal storage proposal = _proposals[proposalId];\\n    require(\\n      IProposalValidator(address(proposal.executor)).validateProposalCancellation(\\n        this,\\n        proposal.creator,\\n        block.number - 1\\n      ),\\n      'PROPOSITION_CANCELLATION_INVALID'\\n    );\\n    proposal.canceled = true;\\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\\n      proposal.executor.cancelTransaction(\\n        proposal.targets[i],\\n        proposal.values[i],\\n        proposal.signatures[i],\\n        proposal.calldatas[i],\\n        proposal.executionTime,\\n        proposal.withDelegatecalls[i]\\n      );\\n    }\\n\\n    emit ProposalCanceled(proposalId);\\n  }\\n\\n  /**\\n   * @dev Queue the proposal. Requires that the proposal succeeded.\\n   * @param proposalId id of the proposal to queue\\n   **/\\n  function queue(uint256 proposalId) external override {\\n    require(getProposalState(proposalId) == ProposalState.Succeeded, 'INVALID_STATE_FOR_QUEUE');\\n    Proposal storage proposal = _proposals[proposalId];\\n    uint256 executionTime = block.timestamp.add(proposal.executor.getDelay());\\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\\n      _queueOrRevert(\\n        proposal.executor,\\n        proposal.targets[i],\\n        proposal.values[i],\\n        proposal.signatures[i],\\n        proposal.calldatas[i],\\n        executionTime,\\n        proposal.withDelegatecalls[i]\\n      );\\n    }\\n    proposal.executionTime = executionTime;\\n\\n    emit ProposalQueued(proposalId, executionTime, msg.sender);\\n  }\\n\\n  /**\\n   * @dev Execute the proposal. Requires that the proposal is queued.\\n   * @param proposalId id of the proposal to execute\\n   **/\\n  function execute(uint256 proposalId) external payable override {\\n    require(getProposalState(proposalId) == ProposalState.Queued, 'ONLY_QUEUED_PROPOSALS');\\n    Proposal storage proposal = _proposals[proposalId];\\n    proposal.executed = true;\\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\\n      proposal.executor.executeTransaction{value: proposal.values[i]}(\\n        proposal.targets[i],\\n        proposal.values[i],\\n        proposal.signatures[i],\\n        proposal.calldatas[i],\\n        proposal.executionTime,\\n        proposal.withDelegatecalls[i]\\n      );\\n    }\\n    emit ProposalExecuted(proposalId, msg.sender);\\n  }\\n\\n  /**\\n   * @dev Function allowing msg.sender to vote for/against a proposal\\n   * @param proposalId id of the proposal\\n   * @param support boolean, true = vote for, false = vote against\\n   **/\\n  function submitVote(uint256 proposalId, bool support) external override {\\n    return _submitVote(msg.sender, proposalId, support);\\n  }\\n\\n  /**\\n   * @dev Function to register the vote of user that has voted offchain via signature\\n   * @param proposalId id of the proposal\\n   * @param support boolean, true = vote for, false = vote against\\n   * @param v v part of the voter signature\\n   * @param r r part of the voter signature\\n   * @param s s part of the voter signature\\n   **/\\n  function submitVoteBySignature(\\n    uint256 proposalId,\\n    bool support,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external override {\\n    bytes32 digest = keccak256(\\n      abi.encodePacked(\\n        '\\\\x19\\\\x01',\\n        keccak256(\\n          abi.encode(\\n            DOMAIN_TYPEHASH,\\n            keccak256(bytes(EIP712_DOMAIN_NAME)),\\n            getChainId(),\\n            address(this)\\n          )\\n        ),\\n        keccak256(abi.encode(VOTE_EMITTED_TYPEHASH, proposalId, support))\\n      )\\n    );\\n    address signer = ecrecover(digest, v, r, s);\\n    require(signer != address(0), 'INVALID_SIGNATURE');\\n    return _submitVote(signer, proposalId, support);\\n  }\\n\\n  /**\\n   * @dev Set new GovernanceStrategy\\n   * Note: owner should be a timelocked executor, so needs to make a proposal\\n   * @param governanceStrategy new Address of the GovernanceStrategy contract\\n   **/\\n  function setGovernanceStrategy(address governanceStrategy)\\n    external\\n    override\\n    onlyRole(OWNER_ROLE)\\n  {\\n    _setGovernanceStrategy(governanceStrategy);\\n  }\\n\\n  /**\\n   * @dev Set new Voting Delay (delay before a newly created proposal can be voted on)\\n   * Note: owner should be a timelocked executor, so needs to make a proposal\\n   * @param votingDelay new voting delay in terms of blocks\\n   **/\\n  function setVotingDelay(uint256 votingDelay)\\n    external\\n    override\\n    onlyRole(OWNER_ROLE)\\n  {\\n    _setVotingDelay(votingDelay);\\n  }\\n\\n  /**\\n   * @dev Add new addresses to the list of authorized executors\\n   * @param executors list of new addresses to be authorized executors\\n   **/\\n  function authorizeExecutors(address[] memory executors)\\n    public\\n    override\\n    onlyRole(ADD_EXECUTOR_ROLE)\\n  {\\n    for (uint256 i = 0; i < executors.length; i++) {\\n      _authorizeExecutor(executors[i]);\\n    }\\n  }\\n\\n  /**\\n   * @dev Remove addresses to the list of authorized executors\\n   * @param executors list of addresses to be removed as authorized executors\\n   **/\\n  function unauthorizeExecutors(address[] memory executors)\\n    public\\n    override\\n    onlyRole(OWNER_ROLE)\\n  {\\n    for (uint256 i = 0; i < executors.length; i++) {\\n      _unauthorizeExecutor(executors[i]);\\n    }\\n  }\\n\\n  /**\\n   * @dev Getter of the current GovernanceStrategy address\\n   * @return The address of the current GovernanceStrategy contracts\\n   **/\\n  function getGovernanceStrategy() external view override returns (address) {\\n    return _governanceStrategy;\\n  }\\n\\n  /**\\n   * @dev Getter of the current Voting Delay (delay before a created proposal can be voted on)\\n   * Different from the voting duration\\n   * @return The voting delay in number of blocks\\n   **/\\n  function getVotingDelay() external view override returns (uint256) {\\n    return _votingDelay;\\n  }\\n\\n  /**\\n   * @dev Returns whether an address is an authorized executor\\n   * @param executor address to evaluate as authorized executor\\n   * @return true if authorized\\n   **/\\n  function isExecutorAuthorized(address executor) public view override returns (bool) {\\n    return _authorizedExecutors[executor];\\n  }\\n\\n  /**\\n   * @dev Getter of the proposal count (the current number of proposals ever created)\\n   * @return the proposal count\\n   **/\\n  function getProposalsCount() external view override returns (uint256) {\\n    return _proposalsCount;\\n  }\\n\\n  /**\\n   * @dev Getter of a proposal by id\\n   * @param proposalId id of the proposal to get\\n   * @return the proposal as ProposalWithoutVotes memory object\\n   **/\\n  function getProposalById(uint256 proposalId)\\n    external\\n    view\\n    override\\n    returns (ProposalWithoutVotes memory)\\n  {\\n    Proposal storage proposal = _proposals[proposalId];\\n    ProposalWithoutVotes memory proposalWithoutVotes = ProposalWithoutVotes({\\n      id: proposal.id,\\n      creator: proposal.creator,\\n      executor: proposal.executor,\\n      targets: proposal.targets,\\n      values: proposal.values,\\n      signatures: proposal.signatures,\\n      calldatas: proposal.calldatas,\\n      withDelegatecalls: proposal.withDelegatecalls,\\n      startBlock: proposal.startBlock,\\n      endBlock: proposal.endBlock,\\n      executionTime: proposal.executionTime,\\n      forVotes: proposal.forVotes,\\n      againstVotes: proposal.againstVotes,\\n      executed: proposal.executed,\\n      canceled: proposal.canceled,\\n      strategy: proposal.strategy,\\n      ipfsHash: proposal.ipfsHash\\n    });\\n\\n    return proposalWithoutVotes;\\n  }\\n\\n  /**\\n   * @notice Get information about a voter's vote on a proposal.\\n   * Note: Vote is a struct: ({bool support, uint248 votingPower})\\n   * @param proposalId id of the proposal\\n   * @param voter address of the voter\\n   * @return The associated Vote object\\n   **/\\n  function getVoteOnProposal(uint256 proposalId, address voter)\\n    external\\n    view\\n    override\\n    returns (Vote memory)\\n  {\\n    return _proposals[proposalId].votes[voter];\\n  }\\n\\n  /**\\n   * @notice Get the current state of a proposal.\\n   * @param proposalId id of the proposal\\n   * @return The current state of the proposal\\n   **/\\n  function getProposalState(uint256 proposalId) public view override returns (ProposalState) {\\n    require(_proposalsCount > proposalId, 'INVALID_PROPOSAL_ID');\\n    Proposal storage proposal = _proposals[proposalId];\\n    if (proposal.canceled) {\\n      return ProposalState.Canceled;\\n    } else if (block.number <= proposal.startBlock) {\\n      return ProposalState.Pending;\\n    } else if (block.number <= proposal.endBlock) {\\n      return ProposalState.Active;\\n    } else if (!IProposalValidator(address(proposal.executor)).isProposalPassed(this, proposalId)) {\\n      return ProposalState.Failed;\\n    } else if (proposal.executionTime == 0) {\\n      return ProposalState.Succeeded;\\n    } else if (proposal.executed) {\\n      return ProposalState.Executed;\\n    } else if (proposal.executor.isProposalOverGracePeriod(this, proposalId)) {\\n      return ProposalState.Expired;\\n    } else {\\n      return ProposalState.Queued;\\n    }\\n  }\\n\\n  function _queueOrRevert(\\n    IExecutorWithTimelock executor,\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory callData,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  ) internal {\\n    require(\\n      !executor.isActionQueued(\\n        keccak256(abi.encode(target, value, signature, callData, executionTime, withDelegatecall))\\n      ),\\n      'DUPLICATED_ACTION'\\n    );\\n    executor.queueTransaction(target, value, signature, callData, executionTime, withDelegatecall);\\n  }\\n\\n  function _submitVote(\\n    address voter,\\n    uint256 proposalId,\\n    bool support\\n  ) internal {\\n    require(getProposalState(proposalId) == ProposalState.Active, 'VOTING_CLOSED');\\n    Proposal storage proposal = _proposals[proposalId];\\n    Vote storage vote = proposal.votes[voter];\\n\\n    require(vote.votingPower == 0, 'VOTE_ALREADY_SUBMITTED');\\n\\n    uint256 votingPower = IVotingStrategy(proposal.strategy).getVotingPowerAt(\\n      voter,\\n      proposal.startBlock\\n    );\\n\\n    if (support) {\\n      proposal.forVotes = proposal.forVotes.add(votingPower);\\n    } else {\\n      proposal.againstVotes = proposal.againstVotes.add(votingPower);\\n    }\\n\\n    vote.support = support;\\n    vote.votingPower = uint248(votingPower);\\n\\n    emit VoteEmitted(proposalId, voter, support, votingPower);\\n  }\\n\\n  function _setGovernanceStrategy(address governanceStrategy) internal {\\n    _governanceStrategy = governanceStrategy;\\n\\n    emit GovernanceStrategyChanged(governanceStrategy, msg.sender);\\n  }\\n\\n  function _setVotingDelay(uint256 votingDelay) internal {\\n    _votingDelay = votingDelay;\\n\\n    emit VotingDelayChanged(votingDelay, msg.sender);\\n  }\\n\\n  function _authorizeExecutor(address executor) internal {\\n    _authorizedExecutors[executor] = true;\\n    emit ExecutorAuthorized(executor);\\n  }\\n\\n  function _unauthorizeExecutor(address executor) internal {\\n    _authorizedExecutors[executor] = false;\\n    emit ExecutorUnauthorized(executor);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n  /**\\n   * @dev Returns the addition of two unsigned integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity's `+` operator.\\n   *\\n   * Requirements:\\n   * - Addition cannot overflow.\\n   */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a, 'SafeMath: addition overflow');\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, reverting on\\n   * overflow (when the result is negative).\\n   *\\n   * Counterpart to Solidity's `-` operator.\\n   *\\n   * Requirements:\\n   * - Subtraction cannot overflow.\\n   */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return sub(a, b, 'SafeMath: subtraction overflow');\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n   * overflow (when the result is negative).\\n   *\\n   * Counterpart to Solidity's `-` operator.\\n   *\\n   * Requirements:\\n   * - Subtraction cannot overflow.\\n   */\\n  function sub(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b <= a, errorMessage);\\n    uint256 c = a - b;\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the multiplication of two unsigned integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity's `*` operator.\\n   *\\n   * Requirements:\\n   * - Multiplication cannot overflow.\\n   */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b, 'SafeMath: multiplication overflow');\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the integer division of two unsigned integers. Reverts on\\n   * division by zero. The result is rounded towards zero.\\n   *\\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return div(a, b, 'SafeMath: division by zero');\\n  }\\n\\n  /**\\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n   * division by zero. The result is rounded towards zero.\\n   *\\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function div(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    // Solidity only automatically asserts when dividing by 0\\n    require(b > 0, errorMessage);\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n   * Reverts when dividing by zero.\\n   *\\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\n   * invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return mod(a, b, 'SafeMath: modulo by zero');\\n  }\\n\\n  /**\\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n   * Reverts with custom message when dividing by zero.\\n   *\\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\n   * invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function mod(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b != 0, errorMessage);\\n    return a % b;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDydxGovernor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport { IExecutorWithTimelock } from './IExecutorWithTimelock.sol';\\n\\ninterface IDydxGovernor {\\n\\n  enum ProposalState {\\n    Pending,\\n    Canceled,\\n    Active,\\n    Failed,\\n    Succeeded,\\n    Queued,\\n    Expired,\\n    Executed\\n  }\\n\\n  struct Vote {\\n    bool support;\\n    uint248 votingPower;\\n  }\\n\\n  struct Proposal {\\n    uint256 id;\\n    address creator;\\n    IExecutorWithTimelock executor;\\n    address[] targets;\\n    uint256[] values;\\n    string[] signatures;\\n    bytes[] calldatas;\\n    bool[] withDelegatecalls;\\n    uint256 startBlock;\\n    uint256 endBlock;\\n    uint256 executionTime;\\n    uint256 forVotes;\\n    uint256 againstVotes;\\n    bool executed;\\n    bool canceled;\\n    address strategy;\\n    bytes32 ipfsHash;\\n    mapping(address => Vote) votes;\\n  }\\n\\n  struct ProposalWithoutVotes {\\n    uint256 id;\\n    address creator;\\n    IExecutorWithTimelock executor;\\n    address[] targets;\\n    uint256[] values;\\n    string[] signatures;\\n    bytes[] calldatas;\\n    bool[] withDelegatecalls;\\n    uint256 startBlock;\\n    uint256 endBlock;\\n    uint256 executionTime;\\n    uint256 forVotes;\\n    uint256 againstVotes;\\n    bool executed;\\n    bool canceled;\\n    address strategy;\\n    bytes32 ipfsHash;\\n  }\\n\\n  /**\\n   * @dev emitted when a new proposal is created\\n   * @param id Id of the proposal\\n   * @param creator address of the creator\\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\\n   * @param targets list of contracts called by proposal's associated transactions\\n   * @param values list of value in wei for each propoposal's associated transaction\\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\\n   * @param withDelegatecalls boolean, true = transaction delegatecalls the taget, else calls the target\\n   * @param startBlock block number when vote starts\\n   * @param endBlock block number when vote ends\\n   * @param strategy address of the governanceStrategy contract\\n   * @param ipfsHash IPFS hash of the proposal\\n   **/\\n  event ProposalCreated(\\n    uint256 id,\\n    address indexed creator,\\n    IExecutorWithTimelock indexed executor,\\n    address[] targets,\\n    uint256[] values,\\n    string[] signatures,\\n    bytes[] calldatas,\\n    bool[] withDelegatecalls,\\n    uint256 startBlock,\\n    uint256 endBlock,\\n    address strategy,\\n    bytes32 ipfsHash\\n  );\\n\\n  /**\\n   * @dev emitted when a proposal is canceled\\n   * @param id Id of the proposal\\n   **/\\n  event ProposalCanceled(uint256 id);\\n\\n  /**\\n   * @dev emitted when a proposal is queued\\n   * @param id Id of the proposal\\n   * @param executionTime time when proposal underlying transactions can be executed\\n   * @param initiatorQueueing address of the initiator of the queuing transaction\\n   **/\\n  event ProposalQueued(uint256 id, uint256 executionTime, address indexed initiatorQueueing);\\n  /**\\n   * @dev emitted when a proposal is executed\\n   * @param id Id of the proposal\\n   * @param initiatorExecution address of the initiator of the execution transaction\\n   **/\\n  event ProposalExecuted(uint256 id, address indexed initiatorExecution);\\n  /**\\n   * @dev emitted when a vote is registered\\n   * @param id Id of the proposal\\n   * @param voter address of the voter\\n   * @param support boolean, true = vote for, false = vote against\\n   * @param votingPower Power of the voter/vote\\n   **/\\n  event VoteEmitted(uint256 id, address indexed voter, bool support, uint256 votingPower);\\n\\n  event GovernanceStrategyChanged(address indexed newStrategy, address indexed initiatorChange);\\n\\n  event VotingDelayChanged(uint256 newVotingDelay, address indexed initiatorChange);\\n\\n  event ExecutorAuthorized(address executor);\\n\\n  event ExecutorUnauthorized(address executor);\\n\\n  /**\\n   * @dev Creates a Proposal (needs Proposition Power of creator > Threshold)\\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\\n   * @param targets list of contracts called by proposal's associated transactions\\n   * @param values list of value in wei for each propoposal's associated transaction\\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\\n   * @param withDelegatecalls if true, transaction delegatecalls the taget, else calls the target\\n   * @param ipfsHash IPFS hash of the proposal\\n   **/\\n  function create(\\n    IExecutorWithTimelock executor,\\n    address[] memory targets,\\n    uint256[] memory values,\\n    string[] memory signatures,\\n    bytes[] memory calldatas,\\n    bool[] memory withDelegatecalls,\\n    bytes32 ipfsHash\\n  ) external returns (uint256);\\n\\n  /**\\n   * @dev Cancels a Proposal, when proposal is Pending/Active and threshold no longer reached\\n   * @param proposalId id of the proposal\\n   **/\\n  function cancel(uint256 proposalId) external;\\n\\n  /**\\n   * @dev Queue the proposal (If Proposal Succeeded)\\n   * @param proposalId id of the proposal to queue\\n   **/\\n  function queue(uint256 proposalId) external;\\n\\n  /**\\n   * @dev Execute the proposal (If Proposal Queued)\\n   * @param proposalId id of the proposal to execute\\n   **/\\n  function execute(uint256 proposalId) external payable;\\n\\n  /**\\n   * @dev Function allowing msg.sender to vote for/against a proposal\\n   * @param proposalId id of the proposal\\n   * @param support boolean, true = vote for, false = vote against\\n   **/\\n  function submitVote(uint256 proposalId, bool support) external;\\n\\n  /**\\n   * @dev Function to register the vote of user that has voted offchain via signature\\n   * @param proposalId id of the proposal\\n   * @param support boolean, true = vote for, false = vote against\\n   * @param v v part of the voter signature\\n   * @param r r part of the voter signature\\n   * @param s s part of the voter signature\\n   **/\\n  function submitVoteBySignature(\\n    uint256 proposalId,\\n    bool support,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external;\\n\\n  /**\\n   * @dev Set new GovernanceStrategy\\n   * Note: owner should be a timelocked executor, so needs to make a proposal\\n   * @param governanceStrategy new Address of the GovernanceStrategy contract\\n   **/\\n  function setGovernanceStrategy(address governanceStrategy) external;\\n\\n  /**\\n   * @dev Set new Voting Delay (delay before a newly created proposal can be voted on)\\n   * Note: owner should be a timelocked executor, so needs to make a proposal\\n   * @param votingDelay new voting delay in seconds\\n   **/\\n  function setVotingDelay(uint256 votingDelay) external;\\n\\n  /**\\n   * @dev Add new addresses to the list of authorized executors\\n   * @param executors list of new addresses to be authorized executors\\n   **/\\n  function authorizeExecutors(address[] memory executors) external;\\n\\n  /**\\n   * @dev Remove addresses to the list of authorized executors\\n   * @param executors list of addresses to be removed as authorized executors\\n   **/\\n  function unauthorizeExecutors(address[] memory executors) external;\\n\\n  /**\\n   * @dev Getter of the current GovernanceStrategy address\\n   * @return The address of the current GovernanceStrategy contracts\\n   **/\\n  function getGovernanceStrategy() external view returns (address);\\n\\n  /**\\n   * @dev Getter of the current Voting Delay (delay before a created proposal can be voted on)\\n   * Different from the voting duration\\n   * @return The voting delay in seconds\\n   **/\\n  function getVotingDelay() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns whether an address is an authorized executor\\n   * @param executor address to evaluate as authorized executor\\n   * @return true if authorized\\n   **/\\n  function isExecutorAuthorized(address executor) external view returns (bool);\\n\\n  /**\\n   * @dev Getter of the proposal count (the current number of proposals ever created)\\n   * @return the proposal count\\n   **/\\n  function getProposalsCount() external view returns (uint256);\\n\\n  /**\\n   * @dev Getter of a proposal by id\\n   * @param proposalId id of the proposal to get\\n   * @return the proposal as ProposalWithoutVotes memory object\\n   **/\\n  function getProposalById(uint256 proposalId) external view returns (ProposalWithoutVotes memory);\\n\\n  /**\\n   * @dev Getter of the Vote of a voter about a proposal\\n   * Note: Vote is a struct: ({bool support, uint248 votingPower})\\n   * @param proposalId id of the proposal\\n   * @param voter address of the voter\\n   * @return The associated Vote memory object\\n   **/\\n  function getVoteOnProposal(uint256 proposalId, address voter) external view returns (Vote memory);\\n\\n  /**\\n   * @dev Get the current state of a proposal\\n   * @param proposalId id of the proposal\\n   * @return The current state if the proposal\\n   **/\\n  function getProposalState(uint256 proposalId) external view returns (ProposalState);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IExecutorWithTimelock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport { IDydxGovernor } from './IDydxGovernor.sol';\\n\\ninterface IExecutorWithTimelock {\\n  /**\\n   * @dev emitted when a new pending admin is set\\n   * @param newPendingAdmin address of the new pending admin\\n   **/\\n  event NewPendingAdmin(address newPendingAdmin);\\n\\n  /**\\n   * @dev emitted when a new admin is set\\n   * @param newAdmin address of the new admin\\n   **/\\n  event NewAdmin(address newAdmin);\\n\\n  /**\\n   * @dev emitted when a new delay (between queueing and execution) is set\\n   * @param delay new delay\\n   **/\\n  event NewDelay(uint256 delay);\\n\\n  /**\\n   * @dev emitted when a new (trans)action is Queued.\\n   * @param actionHash hash of the action\\n   * @param target address of the targeted contract\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   **/\\n  event QueuedAction(\\n    bytes32 actionHash,\\n    address indexed target,\\n    uint256 value,\\n    string signature,\\n    bytes data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  );\\n\\n  /**\\n   * @dev emitted when an action is Cancelled\\n   * @param actionHash hash of the action\\n   * @param target address of the targeted contract\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   **/\\n  event CancelledAction(\\n    bytes32 actionHash,\\n    address indexed target,\\n    uint256 value,\\n    string signature,\\n    bytes data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  );\\n\\n  /**\\n   * @dev emitted when an action is Cancelled\\n   * @param actionHash hash of the action\\n   * @param target address of the targeted contract\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   * @param resultData the actual callData used on the target\\n   **/\\n  event ExecutedAction(\\n    bytes32 actionHash,\\n    address indexed target,\\n    uint256 value,\\n    string signature,\\n    bytes data,\\n    uint256 executionTime,\\n    bool withDelegatecall,\\n    bytes resultData\\n  );\\n\\n  /**\\n   * @dev Getter of the current admin address (should be governance)\\n   * @return The address of the current admin\\n   **/\\n  function getAdmin() external view returns (address);\\n\\n  /**\\n   * @dev Getter of the current pending admin address\\n   * @return The address of the pending admin\\n   **/\\n  function getPendingAdmin() external view returns (address);\\n\\n  /**\\n   * @dev Getter of the delay between queuing and execution\\n   * @return The delay in seconds\\n   **/\\n  function getDelay() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns whether an action (via actionHash) is queued\\n   * @param actionHash hash of the action to be checked\\n   * keccak256(abi.encode(target, value, signature, data, executionTime, withDelegatecall))\\n   * @return true if underlying action of actionHash is queued\\n   **/\\n  function isActionQueued(bytes32 actionHash) external view returns (bool);\\n\\n  /**\\n   * @dev Checks whether a proposal is over its grace period\\n   * @param governance Governance contract\\n   * @param proposalId Id of the proposal against which to test\\n   * @return true of proposal is over grace period\\n   **/\\n  function isProposalOverGracePeriod(IDydxGovernor governance, uint256 proposalId)\\n    external\\n    view\\n    returns (bool);\\n\\n  /**\\n   * @dev Getter of grace period constant\\n   * @return grace period in seconds\\n   **/\\n  function GRACE_PERIOD() external view returns (uint256);\\n\\n  /**\\n   * @dev Getter of minimum delay constant\\n   * @return minimum delay in seconds\\n   **/\\n  function MINIMUM_DELAY() external view returns (uint256);\\n\\n  /**\\n   * @dev Getter of maximum delay constant\\n   * @return maximum delay in seconds\\n   **/\\n  function MAXIMUM_DELAY() external view returns (uint256);\\n\\n  /**\\n   * @dev Function, called by Governance, that queue a transaction, returns action hash\\n   * @param target smart contract target\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   **/\\n  function queueTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  ) external returns (bytes32);\\n\\n  /**\\n   * @dev Function, called by Governance, that executes a transaction, returns the callData executed\\n   * @param target smart contract target\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   **/\\n  function executeTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  ) external payable returns (bytes memory);\\n\\n  /**\\n   * @dev Function, called by Governance, that cancels a transaction, returns action hash\\n   * @param target smart contract target\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   **/\\n  function cancelTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  ) external returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGovernanceStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\ninterface IGovernanceStrategy {\\n\\n  /**\\n   * @dev Returns the Proposition Power of a user at a specific block number.\\n   * @param user Address of the user.\\n   * @param blockNumber Blocknumber at which to fetch Proposition Power\\n   * @return Power number\\n   **/\\n  function getPropositionPowerAt(address user, uint256 blockNumber) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the total supply of Outstanding Proposition Tokens\\n   * @param blockNumber Blocknumber at which to evaluate\\n   * @return total supply at blockNumber\\n   **/\\n  function getTotalPropositionSupplyAt(uint256 blockNumber) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the total supply of Outstanding Voting Tokens\\n   * @param blockNumber Blocknumber at which to evaluate\\n   * @return total supply at blockNumber\\n   **/\\n  function getTotalVotingSupplyAt(uint256 blockNumber) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the Vote Power of a user at a specific block number.\\n   * @param user Address of the user.\\n   * @param blockNumber Blocknumber at which to fetch Vote Power\\n   * @return Vote number\\n   **/\\n  function getVotingPowerAt(address user, uint256 blockNumber) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IProposalValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport { IDydxGovernor } from './IDydxGovernor.sol';\\n\\ninterface IProposalValidator {\\n\\n  /**\\n   * @dev Called to validate a proposal (e.g when creating new proposal in Governance)\\n   * @param governance Governance Contract\\n   * @param user Address of the proposal creator\\n   * @param blockNumber Block Number against which to make the test (e.g proposal creation block -1).\\n   * @return boolean, true if can be created\\n   **/\\n  function validateCreatorOfProposal(\\n    IDydxGovernor governance,\\n    address user,\\n    uint256 blockNumber\\n  ) external view returns (bool);\\n\\n  /**\\n   * @dev Called to validate the cancellation of a proposal\\n   * @param governance Governance Contract\\n   * @param user Address of the proposal creator\\n   * @param blockNumber Block Number against which to make the test (e.g proposal creation block -1).\\n   * @return boolean, true if can be cancelled\\n   **/\\n  function validateProposalCancellation(\\n    IDydxGovernor governance,\\n    address user,\\n    uint256 blockNumber\\n  ) external view returns (bool);\\n\\n  /**\\n   * @dev Returns whether a user has enough Proposition Power to make a proposal.\\n   * @param governance Governance Contract\\n   * @param user Address of the user to be challenged.\\n   * @param blockNumber Block Number against which to make the challenge.\\n   * @return true if user has enough power\\n   **/\\n  function isPropositionPowerEnough(\\n    IDydxGovernor governance,\\n    address user,\\n    uint256 blockNumber\\n  ) external view returns (bool);\\n\\n  /**\\n   * @dev Returns the minimum Proposition Power needed to create a proposition.\\n   * @param governance Governance Contract\\n   * @param blockNumber Blocknumber at which to evaluate\\n   * @return minimum Proposition Power needed\\n   **/\\n  function getMinimumPropositionPowerNeeded(IDydxGovernor governance, uint256 blockNumber)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n   * @dev Returns whether a proposal passed or not\\n   * @param governance Governance Contract\\n   * @param proposalId Id of the proposal to set\\n   * @return true if proposal passed\\n   **/\\n  function isProposalPassed(IDydxGovernor governance, uint256 proposalId)\\n    external\\n    view\\n    returns (bool);\\n\\n  /**\\n   * @dev Check whether a proposal has reached quorum, ie has enough FOR-voting-power\\n   * Here quorum is not to understand as number of votes reached, but number of for-votes reached\\n   * @param governance Governance Contract\\n   * @param proposalId Id of the proposal to verify\\n   * @return voting power needed for a proposal to pass\\n   **/\\n  function isQuorumValid(IDydxGovernor governance, uint256 proposalId)\\n    external\\n    view\\n    returns (bool);\\n\\n  /**\\n   * @dev Check whether a proposal has enough extra FOR-votes than AGAINST-votes\\n   * FOR VOTES - AGAINST VOTES > VOTE_DIFFERENTIAL * voting supply\\n   * @param governance Governance Contract\\n   * @param proposalId Id of the proposal to verify\\n   * @return true if enough For-Votes\\n   **/\\n  function isVoteDifferentialValid(IDydxGovernor governance, uint256 proposalId)\\n    external\\n    view\\n    returns (bool);\\n\\n  /**\\n   * @dev Calculates the minimum amount of Voting Power needed for a proposal to Pass\\n   * @param votingSupply Total number of oustanding voting tokens\\n   * @return voting power needed for a proposal to pass\\n   **/\\n  function getMinimumVotingPowerNeeded(uint256 votingSupply) external view returns (uint256);\\n\\n  /**\\n   * @dev Get proposition threshold constant value\\n   * @return the proposition threshold value (100 <=> 1%)\\n   **/\\n  function PROPOSITION_THRESHOLD() external view returns (uint256);\\n\\n  /**\\n   * @dev Get voting duration constant value\\n   * @return the voting duration value in seconds\\n   **/\\n  function VOTING_DURATION() external view returns (uint256);\\n\\n  /**\\n   * @dev Get the vote differential threshold constant value\\n   * to compare with % of for votes/total supply - % of against votes/total supply\\n   * @return the vote differential threshold value (100 <=> 1%)\\n   **/\\n  function VOTE_DIFFERENTIAL() external view returns (uint256);\\n\\n  /**\\n   * @dev Get quorum threshold constant value\\n   * to compare with % of for votes/total supply\\n   * @return the quorum threshold value (100 <=> 1%)\\n   **/\\n  function MINIMUM_QUORUM() external view returns (uint256);\\n\\n  /**\\n   * @dev precision helper: 100% = 10000\\n   * @return one hundred percents with our chosen precision\\n   **/\\n  function ONE_HUNDRED_WITH_PRECISION() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVotingStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\ninterface IVotingStrategy {\\n  function getVotingPowerAt(address user, uint256 blockNumber) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/misc/Helpers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nfunction getChainId() pure returns (uint256) {\\n  uint256 chainId;\\n  assembly {\\n    chainId := chainid()\\n  }\\n  return chainId;\\n}\\n\\nfunction isContract(address account) view returns (bool) {\\n  // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n  // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n  // for accounts without code, i.e. `keccak256('')`\\n  bytes32 codehash;\\n  bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n  // solhint-disable-next-line no-inline-assembly\\n  assembly {\\n    codehash := extcodehash(account)\\n  }\\n  return (codehash != accountHash && codehash != 0x0);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governanceStrategy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"votingDelay\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addExecutorAdmin\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"}],\"name\":\"ExecutorAuthorized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"}],\"name\":\"ExecutorUnauthorized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newStrategy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"initiatorChange\",\"type\":\"address\"}],\"name\":\"GovernanceStrategyChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ProposalCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IExecutorWithTimelock\",\"name\":\"executor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"string[]\",\"name\":\"signatures\",\"type\":\"string[]\"},{\"indexed\":false,\"internalType\":\"bytes[]\",\"name\":\"calldatas\",\"type\":\"bytes[]\"},{\"indexed\":false,\"internalType\":\"bool[]\",\"name\":\"withDelegatecalls\",\"type\":\"bool[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"ipfsHash\",\"type\":\"bytes32\"}],\"name\":\"ProposalCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"initiatorExecution\",\"type\":\"address\"}],\"name\":\"ProposalExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"executionTime\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"initiatorQueueing\",\"type\":\"address\"}],\"name\":\"ProposalQueued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"support\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"votingPower\",\"type\":\"uint256\"}],\"name\":\"VoteEmitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newVotingDelay\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"initiatorChange\",\"type\":\"address\"}],\"name\":\"VotingDelayChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ADD_EXECUTOR_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EIP712_DOMAIN_NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OWNER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VOTE_EMITTED_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"executors\",\"type\":\"address[]\"}],\"name\":\"authorizeExecutors\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IExecutorWithTimelock\",\"name\":\"executor\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"signatures\",\"type\":\"string[]\"},{\"internalType\":\"bytes[]\",\"name\":\"calldatas\",\"type\":\"bytes[]\"},{\"internalType\":\"bool[]\",\"name\":\"withDelegatecalls\",\"type\":\"bool[]\"},{\"internalType\":\"bytes32\",\"name\":\"ipfsHash\",\"type\":\"bytes32\"}],\"name\":\"create\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"execute\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGovernanceStrategy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"getProposalById\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"contract IExecutorWithTimelock\",\"name\":\"executor\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"signatures\",\"type\":\"string[]\"},{\"internalType\":\"bytes[]\",\"name\":\"calldatas\",\"type\":\"bytes[]\"},{\"internalType\":\"bool[]\",\"name\":\"withDelegatecalls\",\"type\":\"bool[]\"},{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"executionTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"forVotes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"againstVotes\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canceled\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"ipfsHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct IDydxGovernor.ProposalWithoutVotes\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"getProposalState\",\"outputs\":[{\"internalType\":\"enum IDydxGovernor.ProposalState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProposalsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"getVoteOnProposal\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"support\",\"type\":\"bool\"},{\"internalType\":\"uint248\",\"name\":\"votingPower\",\"type\":\"uint248\"}],\"internalType\":\"struct IDydxGovernor.Vote\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVotingDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"}],\"name\":\"isExecutorAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"queue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governanceStrategy\",\"type\":\"address\"}],\"name\":\"setGovernanceStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"votingDelay\",\"type\":\"uint256\"}],\"name\":\"setVotingDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"support\",\"type\":\"bool\"}],\"name\":\"submitVote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"support\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"submitVoteBySignature\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"executors\",\"type\":\"address[]\"}],\"name\":\"unauthorizeExecutors\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"DydxGovernor","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000019aa000000000000000000000000301df37d653b281af83a1ddf4464ef21a622ec83","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}