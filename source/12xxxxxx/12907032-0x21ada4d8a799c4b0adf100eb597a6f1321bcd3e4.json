{"status":"1","message":"OK","result":[{"SourceCode":"// Sources flattened with hardhat v2.4.3 https://hardhat.org\r\n\r\n// File @animoca/ethereum-contracts-core-1.1.1/contracts/utils/types/AddressIsContract.sol@v1.1.1\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\n// Partially derived from OpenZeppelin:\r\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/406c83649bd6169fc1b578e08506d78f0873b276/contracts/utils/Address.sol\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n/**\r\n * @dev Upgrades the address type to check if it is a contract.\r\n */\r\nlibrary AddressIsContract {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-core-1.1.1/contracts/utils/ERC20Wrapper.sol@v1.1.1\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n/**\r\n * @title ERC20Wrapper\r\n * Wraps ERC20 functions to support non-standard implementations which do not return a bool value.\r\n * Calls to the wrapped functions revert only if they throw or if they return false.\r\n */\r\nlibrary ERC20Wrapper {\r\n    using AddressIsContract for address;\r\n\r\n    function wrappedTransfer(\r\n        IWrappedERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callWithOptionalReturnData(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function wrappedTransferFrom(\r\n        IWrappedERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callWithOptionalReturnData(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function wrappedApprove(\r\n        IWrappedERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        _callWithOptionalReturnData(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function _callWithOptionalReturnData(IWrappedERC20 token, bytes memory callData) internal {\r\n        address target = address(token);\r\n        require(target.isContract(), \"ERC20Wrapper: non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory data) = target.call(callData);\r\n        if (success) {\r\n            if (data.length != 0) {\r\n                require(abi.decode(data, (bool)), \"ERC20Wrapper: operation failed\");\r\n            }\r\n        } else {\r\n            // revert using a standard revert message\r\n            if (data.length == 0) {\r\n                revert(\"ERC20Wrapper: operation failed\");\r\n            }\r\n\r\n            // revert using the revert message coming from the call\r\n            assembly {\r\n                let size := mload(data)\r\n                revert(add(32, data), size)\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ninterface IWrappedERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-core-1.1.1/contracts/metatx/ManagedIdentity.sol@v1.1.1\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n/*\r\n * Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner.\r\n */\r\nabstract contract ManagedIdentity {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-core-1.1.1/contracts/bridging/ITokenPredicate.sol@v1.1.1\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n/**\r\n * @title Token predicate interface for all POS portal predicates.\r\n * Abstract interface that defines methods for custom predicates.\r\n */\r\ninterface ITokenPredicate {\r\n    /**\r\n     * @notice Deposit tokens into POS portal.\r\n     * @dev When `depositor` deposits tokens into POS portal, tokens get locked into predicate contract.\r\n     * @param depositor Address who wants to deposit tokens\r\n     * @param depositReceiver Address (address) who wants to receive tokens on side chain\r\n     * @param rootToken Token which gets deposited\r\n     * @param depositData Extra data for deposit (amount for ERC20, token id for ERC721 etc.) [ABI encoded]\r\n     */\r\n    function lockTokens(\r\n        address depositor,\r\n        address depositReceiver,\r\n        address rootToken,\r\n        bytes calldata depositData\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Validates and processes exit while withdraw process\r\n     * @dev Validates exit log emitted on sidechain. Reverts if validation fails.\r\n     * @dev Processes withdraw based on custom logic. Example: transfer ERC20/ERC721, mint ERC721 if mintable withdraw\r\n     * @param sender Address\r\n     * @param rootToken Token which gets withdrawn\r\n     * @param logRLPList Valid sidechain log for data like amount, token id etc.\r\n     */\r\n    function exitTokens(\r\n        address sender,\r\n        address rootToken,\r\n        bytes calldata logRLPList\r\n    ) external;\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-core-1.1.1/contracts/utils/RLPReader.sol@v1.1.1\r\n\r\n/*\r\n * @author Hamdi Allam hamdi.allam97@gmail.com\r\n * Please reach out with any questions or concerns\r\n * https://github.com/hamdiallam/Solidity-RLP/blob/e681e25a376dbd5426b509380bc03446f05d0f97/contracts/RLPReader.sol\r\n */\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\nlibrary RLPReader {\r\n    uint8 private constant _STRING_SHORT_START = 0x80;\r\n    uint8 private constant _STRING_LONG_START = 0xb8;\r\n    uint8 private constant _LIST_SHORT_START = 0xc0;\r\n    uint8 private constant _LIST_LONG_START = 0xf8;\r\n    uint8 private constant _WORD_SIZE = 32;\r\n\r\n    struct RLPItem {\r\n        uint256 len;\r\n        uint256 memPtr;\r\n    }\r\n\r\n    /*\r\n     * @param item RLP encoded bytes\r\n     */\r\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\r\n        require(item.length > 0, \"RLPReader: INVALID_BYTES_LENGTH\");\r\n        uint256 memPtr;\r\n        assembly {\r\n            memPtr := add(item, 0x20)\r\n        }\r\n\r\n        return RLPItem(item.length, memPtr);\r\n    }\r\n\r\n    /*\r\n     * @param item RLP encoded list in bytes\r\n     */\r\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\r\n        require(isList(item), \"RLP: ITEM_NOT_LIST\");\r\n\r\n        uint256 items = numItems(item);\r\n        RLPItem[] memory result = new RLPItem[](items);\r\n        uint256 listLength = _itemLength(item.memPtr);\r\n        require(listLength == item.len, \"RLP: LIST_LENGTH_MISMATCH\");\r\n\r\n        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\r\n        uint256 dataLen;\r\n        for (uint256 i = 0; i < items; i++) {\r\n            dataLen = _itemLength(memPtr);\r\n            result[i] = RLPItem(dataLen, memPtr);\r\n            memPtr = memPtr + dataLen;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\r\n    function isList(RLPItem memory item) internal pure returns (bool) {\r\n        uint8 byte0;\r\n        uint256 memPtr = item.memPtr;\r\n        assembly {\r\n            byte0 := byte(0, mload(memPtr))\r\n        }\r\n\r\n        if (byte0 < _LIST_SHORT_START) return false;\r\n        return true;\r\n    }\r\n\r\n    /** RLPItem conversions into data types **/\r\n\r\n    // @returns raw rlp encoding in bytes\r\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\r\n        bytes memory result = new bytes(item.len);\r\n\r\n        uint256 ptr;\r\n        assembly {\r\n            ptr := add(0x20, result)\r\n        }\r\n\r\n        copy(item.memPtr, ptr, item.len);\r\n        return result;\r\n    }\r\n\r\n    function toAddress(RLPItem memory item) internal pure returns (address) {\r\n        require(!isList(item), \"RLP: DECODING_LIST_AS_ADDRESS\");\r\n        // 1 byte for the length prefix\r\n        require(item.len == 21, \"RLP: INVALID_ADDRESS_LEN\");\r\n\r\n        return address(toUint(item));\r\n    }\r\n\r\n    function toUint(RLPItem memory item) internal pure returns (uint256) {\r\n        require(!isList(item), \"RLP: DECODING_LIST_AS_UINT\");\r\n        require(item.len <= 33, \"RLP: INVALID_UINT_LEN\");\r\n\r\n        uint256 itemLength = _itemLength(item.memPtr);\r\n        require(itemLength == item.len, \"RLP: UINT_LEN_MISMATCH\");\r\n\r\n        uint256 offset = _payloadOffset(item.memPtr);\r\n        uint256 len = item.len - offset;\r\n        uint256 result;\r\n        uint256 memPtr = item.memPtr + offset;\r\n        assembly {\r\n            result := mload(memPtr)\r\n\r\n            // shfit to the correct location if neccesary\r\n            if lt(len, 32) {\r\n                result := div(result, exp(256, sub(32, len)))\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // enforces 32 byte length\r\n    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {\r\n        uint256 itemLength = _itemLength(item.memPtr);\r\n        require(itemLength == item.len, \"RLP: UINT_STRICT_LEN_MISMATCH\");\r\n        // one byte prefix\r\n        require(item.len == 33, \"RLP: INVALID_UINT_STRICT_LEN\");\r\n\r\n        uint256 result;\r\n        uint256 memPtr = item.memPtr + 1;\r\n        assembly {\r\n            result := mload(memPtr)\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\r\n        uint256 listLength = _itemLength(item.memPtr);\r\n        require(listLength == item.len, \"RLP: BYTES_LEN_MISMATCH\");\r\n        uint256 offset = _payloadOffset(item.memPtr);\r\n\r\n        uint256 len = item.len - offset; // data length\r\n        bytes memory result = new bytes(len);\r\n\r\n        uint256 destPtr;\r\n        assembly {\r\n            destPtr := add(0x20, result)\r\n        }\r\n\r\n        copy(item.memPtr + offset, destPtr, len);\r\n        return result;\r\n    }\r\n\r\n    /*\r\n     * Private Helpers\r\n     */\r\n\r\n    // @return number of payload items inside an encoded list.\r\n    function numItems(RLPItem memory item) private pure returns (uint256) {\r\n        // add `isList` check if `item` is expected to be passsed without a check from calling function\r\n        // require(isList(item), \"RLPReader: NUM_ITEMS_NOT_LIST\");\r\n\r\n        uint256 count = 0;\r\n        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);\r\n        uint256 endPtr = item.memPtr + item.len;\r\n        while (currPtr < endPtr) {\r\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\r\n            require(currPtr <= endPtr, \"RLP: NUM_ITEMS_LEN_MISMATCH\");\r\n            count++;\r\n        }\r\n\r\n        return count;\r\n    }\r\n\r\n    // @return entire rlp item byte length\r\n    function _itemLength(uint256 memPtr) private pure returns (uint256) {\r\n        uint256 itemLen;\r\n        uint256 byte0;\r\n        assembly {\r\n            byte0 := byte(0, mload(memPtr))\r\n        }\r\n\r\n        if (byte0 < _STRING_SHORT_START) itemLen = 1;\r\n        else if (byte0 < _STRING_LONG_START) itemLen = byte0 - _STRING_SHORT_START + 1;\r\n        else if (byte0 < _LIST_SHORT_START) {\r\n            assembly {\r\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\r\n                memPtr := add(memPtr, 1) // skip over the first byte\r\n\r\n                /* 32 byte word size */\r\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\r\n                itemLen := add(dataLen, add(byteLen, 1))\r\n            }\r\n        } else if (byte0 < _LIST_LONG_START) {\r\n            itemLen = byte0 - _LIST_SHORT_START + 1;\r\n        } else {\r\n            assembly {\r\n                let byteLen := sub(byte0, 0xf7)\r\n                memPtr := add(memPtr, 1)\r\n\r\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\r\n                itemLen := add(dataLen, add(byteLen, 1))\r\n            }\r\n        }\r\n\r\n        return itemLen;\r\n    }\r\n\r\n    // @return number of bytes until the data\r\n    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {\r\n        uint256 byte0;\r\n        assembly {\r\n            byte0 := byte(0, mload(memPtr))\r\n        }\r\n\r\n        if (byte0 < _STRING_SHORT_START) return 0;\r\n        else if (byte0 < _STRING_LONG_START || (byte0 >= _LIST_SHORT_START && byte0 < _LIST_LONG_START)) return 1;\r\n        else if (byte0 < _LIST_SHORT_START)\r\n            // being explicit\r\n            return byte0 - (_STRING_LONG_START - 1) + 1;\r\n        else return byte0 - (_LIST_LONG_START - 1) + 1;\r\n    }\r\n\r\n    /*\r\n     * @param src Pointer to source\r\n     * @param dest Pointer to destination\r\n     * @param len Amount of memory to copy from the source\r\n     */\r\n    function copy(\r\n        uint256 src,\r\n        uint256 dest,\r\n        uint256 len\r\n    ) private pure {\r\n        if (len == 0) return;\r\n\r\n        // copy as many word sizes as possible\r\n        for (; len >= _WORD_SIZE; len -= _WORD_SIZE) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n\r\n            src += _WORD_SIZE;\r\n            dest += _WORD_SIZE;\r\n        }\r\n\r\n        // left over bytes. Mask is used to remove unwanted bytes from the word\r\n        uint256 mask = 256**(_WORD_SIZE - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask)) // zero out src\r\n            let destpart := and(mload(dest), mask) // retrieve the bytes\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/bridging/ERC20BasePredicate.sol\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n\r\n/**\r\n * Polygon (MATIC) bridging base ERC20 predicate to be deployed on the root chain (Ethereum mainnet).\r\n */\r\nabstract contract ERC20BasePredicate is ITokenPredicate {\r\n    using RLPReader for bytes;\r\n    using RLPReader for RLPReader.RLPItem;\r\n\r\n    event LockedERC20(address indexed depositor, address indexed depositReceiver, address indexed rootToken, uint256 amount);\r\n\r\n    bytes32 public constant WITHDRAWN_EVENT_SIG = 0x7084f5476618d8e60b11ef0d7d3f06914655adb8793e28ff7f018d4c76d505d5;\r\n\r\n    // see https://github.com/maticnetwork/pos-portal/blob/master/contracts/root/RootChainManager/RootChainManager.sol\r\n    address public rootChainManager;\r\n\r\n    /**\r\n     * Constructor\r\n     * @param rootChainManager_ the Polygon/MATIC RootChainManager proxy address.\r\n     */\r\n    constructor(address rootChainManager_) {\r\n        rootChainManager = rootChainManager_;\r\n    }\r\n\r\n    function _requireManagerRole(address account) internal view {\r\n        require(account == rootChainManager, \"Predicate: only manager\");\r\n    }\r\n\r\n    function _verifyWithdrawalLog(bytes memory log) internal pure returns (address withdrawer, uint256 amount) {\r\n        RLPReader.RLPItem[] memory logRLPList = log.toRlpItem().toList();\r\n        RLPReader.RLPItem[] memory logTopicRLPList = logRLPList[1].toList(); // topics\r\n\r\n        require(\r\n            bytes32(logTopicRLPList[0].toUint()) == WITHDRAWN_EVENT_SIG, // topic0 is event sig\r\n            \"Predicate: invalid signature\"\r\n        );\r\n\r\n        bytes memory logData = logRLPList[2].toBytes();\r\n        (withdrawer, amount) = abi.decode(logData, (address, uint256));\r\n    }\r\n}\r\n\r\n\r\n// File contracts/bridging/ERC20EscrowPredicate.sol\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n\r\n\r\n/**\r\n * Polygon (MATIC) bridging ERC20 escrowing predicate to be deployed on the root chain (Ethereum mainnet).\r\n * This predicate must be used for non-mintable/non-burnable tokens.\r\n */\r\ncontract ERC20EscrowPredicate is ERC20BasePredicate, ManagedIdentity {\r\n    using ERC20Wrapper for IWrappedERC20;\r\n\r\n    constructor(address rootChainManager_) ERC20BasePredicate(rootChainManager_) {}\r\n\r\n    /**\r\n     * Locks ERC20 tokens for deposit.\r\n     * @dev Reverts if not called by the manager (RootChainManager).\r\n     * @param depositor Address who wants to deposit tokens.\r\n     * @param depositReceiver Address (address) who wants to receive tokens on child chain.\r\n     * @param rootToken Token which gets deposited.\r\n     * @param depositData ABI encoded amount.\r\n     */\r\n    function lockTokens(\r\n        address depositor,\r\n        address depositReceiver,\r\n        address rootToken,\r\n        bytes calldata depositData\r\n    ) external override {\r\n        _requireManagerRole(_msgSender());\r\n        uint256 amount = abi.decode(depositData, (uint256));\r\n        emit LockedERC20(depositor, depositReceiver, rootToken, amount);\r\n        IWrappedERC20(rootToken).wrappedTransferFrom(depositor, address(this), amount);\r\n    }\r\n\r\n    /**\r\n     * Validates the {Withdrawn} log signature, then sends the correct amount to withdrawer.\r\n     * @dev Reverts if not called only by the manager (RootChainManager).\r\n     * @param rootToken Token which gets withdrawn\r\n     * @param log Valid ERC20 burn log from child chain\r\n     */\r\n    function exitTokens(\r\n        address,\r\n        address rootToken,\r\n        bytes memory log\r\n    ) public override {\r\n        _requireManagerRole(_msgSender());\r\n        (address withdrawer, uint256 amount) = _verifyWithdrawalLog(log);\r\n        IWrappedERC20(rootToken).wrappedTransfer(withdrawer, amount);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rootChainManager_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"depositReceiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"rootToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LockedERC20\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"WITHDRAWN_EVENT_SIG\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rootToken\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"log\",\"type\":\"bytes\"}],\"name\":\"exitTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"depositReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rootToken\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"depositData\",\"type\":\"bytes\"}],\"name\":\"lockTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rootChainManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ERC20EscrowPredicate","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"000000000000000000000000a0c68c638235ee32657e8f720a23cec1bfc77c77","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://8a6717ce2769ab75fd9c5d5a44947c6a3679f343e41bc251fba416d7a301e369"}]}