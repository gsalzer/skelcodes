{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.4;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address account) external view returns (uint);\r\n    function transfer(address recipient, uint amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function approve(address spender, uint amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract Ownable {\r\n    \r\n    /// @notice The owner of the contract\r\n    address public owner;\r\n    \r\n    /// @notice Event to notify when the ownership of this contract changed\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /// @notice Set the owner of this contract to its creator\r\n    constructor () {\r\n        owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n    \r\n    modifier onlyOwner() {\r\n        require(owner == msg.sender, \"caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer ownership to `newOwner`\r\n     * @param newOwner The address to transfer the ownership to\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0), \"new owner is the zero address\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract TokenMigrator is Ownable {\r\n    \r\n    /// @notice Token to migrate from\r\n    IERC20 public fromToken;\r\n    \r\n    /// @notice Token to migrate to\r\n    IERC20 public toToken;\r\n    \r\n    /// @notice The address where fromToken should be burned\r\n    address public constant BURN_ADDRESS = 0x0000000000000000000000000000000000000008;\r\n    \r\n    /// @notice Notice period before migration can be closed\r\n    uint256 public constant endMigrationNoticePeriod = 2 weeks;\r\n\r\n    /// @notice Flag that indicates whether migration is possible\r\n    bool public migrationEnabled = false;\r\n    \r\n    /// @notice The migration end date\r\n    uint256 public endMigrationDate = type(uint256).max;\r\n    \r\n    /// @notice Event to notify when the endMigrationDate is set\r\n    event CloseMigrationNotice(uint256 epochTime);\r\n    \r\n    /**\r\n     * @notice Construct a Migration contract\r\n     * @param migrateFromToken The token to migrate from\r\n     * @param migrateToToken The token to migrate into\r\n     */\r\n    constructor(address migrateFromToken, address migrateToToken) {\r\n        fromToken = IERC20(migrateFromToken);\r\n        toToken = IERC20(migrateToToken);\r\n    }\r\n    \r\n    modifier whenMigrationEnabled() {\r\n        require(migrationEnabled, \"migration not enabled\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @notice Start the migration. Can only be called if this contract has enough balance of toToken\r\n     */\r\n    function startMigration() public {\r\n        uint256 requiredToTokenBalance = fromToken.totalSupply() - fromToken.balanceOf(BURN_ADDRESS);\r\n        \r\n        require(toToken.balanceOf(address(this)) >= requiredToTokenBalance, \"not enough toToken balance\");\r\n        \r\n        migrationEnabled = true;\r\n    }\r\n    \r\n    /**\r\n     * @notice Migrate `amount` of tokens\r\n     * @param amount How many tokens to migrate\r\n     */\r\n    function migrate(uint256 amount) public whenMigrationEnabled returns (bool success) {\r\n        require(fromToken.transferFrom(msg.sender, BURN_ADDRESS, amount), \"burning fromToken failed\");\r\n        require(toToken.transfer(msg.sender, amount), \"sending toToken failed\");\r\n        \r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @notice Announce the migration can be closed after `endMigrationNoticePeriod` \r\n     */\r\n    function announceMigrationEnd() public onlyOwner whenMigrationEnabled {\r\n        endMigrationDate = block.timestamp + endMigrationNoticePeriod;\r\n        emit CloseMigrationNotice(endMigrationDate);\r\n    }\r\n    \r\n    /**\r\n     * @notice End the migration period. Can only be called after `endMigrationDate`\r\n     *  This also transfers the remainingBalance of toToken back to the owner\r\n     */\r\n    function closeMigration() public onlyOwner whenMigrationEnabled {\r\n        require(block.timestamp > endMigrationDate, \"migration cannot be closed yet\");\r\n        migrationEnabled = false;\r\n        uint256 remainingBalance = toToken.balanceOf(address(this));\r\n        require(toToken.transfer(owner, remainingBalance), \"recovering toToken failed\");\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"migrateFromToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"migrateToToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epochTime\",\"type\":\"uint256\"}],\"name\":\"CloseMigrationNotice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BURN_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"announceMigrationEnd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"closeMigration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endMigrationDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endMigrationNoticePeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fromToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"migrate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrationEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startMigration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"TokenMigrator","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000028cb7e841ee97947a86b06fa4090c8451f64c0be00000000000000000000000072377f31e30a405282b522d588aebbea202b4f23","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://a4d534b84a26eefa33d804b12d0ba95f666dbbc718267f7ed616438ae9bb6128"}]}