{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/modules/token/TokenController.sol\": {\r\n      \"content\": \"/* Copyright (C) 2020 NexusMutual.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n  it under the terms of the GNU General Public License as published by\\n  the Free Software Foundation, either version 3 of the License, or\\n  (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n  GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n  along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../../abstract/Iupgradable.sol\\\";\\nimport \\\"../../interfaces/IPooledStaking.sol\\\";\\nimport \\\"../claims/ClaimsData.sol\\\";\\nimport \\\"./NXMToken.sol\\\";\\nimport \\\"./external/LockHandler.sol\\\";\\n\\ncontract TokenController is LockHandler, Iupgradable {\\n  using SafeMath for uint256;\\n\\n  struct CoverInfo {\\n    uint16 claimCount;\\n    bool hasOpenClaim;\\n    bool hasAcceptedClaim;\\n    // note: still 224 bits available here, can be used later\\n  }\\n\\n  NXMToken public token;\\n  IPooledStaking public pooledStaking;\\n\\n  uint public minCALockTime;\\n  uint public claimSubmissionGracePeriod;\\n\\n  // coverId => CoverInfo\\n  mapping(uint => CoverInfo) public coverInfo;\\n\\n  event Locked(address indexed _of, bytes32 indexed _reason, uint256 _amount, uint256 _validity);\\n\\n  event Unlocked(address indexed _of, bytes32 indexed _reason, uint256 _amount);\\n\\n  event Burned(address indexed member, bytes32 lockedUnder, uint256 amount);\\n\\n  modifier onlyGovernance {\\n    require(msg.sender == ms.getLatestAddress(\\\"GV\\\"), \\\"TokenController: Caller is not governance\\\");\\n    _;\\n  }\\n\\n  /**\\n  * @dev Just for interface\\n  */\\n  function changeDependentContractAddress() public {\\n    token = NXMToken(ms.tokenAddress());\\n    pooledStaking = IPooledStaking(ms.getLatestAddress(\\\"PS\\\"));\\n  }\\n\\n  function markCoverClaimOpen(uint coverId) external onlyInternal {\\n\\n    CoverInfo storage info = coverInfo[coverId];\\n\\n    uint16 claimCount;\\n    bool hasOpenClaim;\\n    bool hasAcceptedClaim;\\n\\n    // reads all of them using a single SLOAD\\n    (claimCount, hasOpenClaim, hasAcceptedClaim) = (info.claimCount, info.hasOpenClaim, info.hasAcceptedClaim);\\n\\n    // no safemath for uint16 but should be safe from\\n    // overflows as there're max 2 claims per cover\\n    claimCount = claimCount + 1;\\n\\n    require(claimCount <= 2, \\\"TokenController: Max claim count exceeded\\\");\\n    require(hasOpenClaim == false, \\\"TokenController: Cover already has an open claim\\\");\\n    require(hasAcceptedClaim == false, \\\"TokenController: Cover already has accepted claims\\\");\\n\\n    // should use a single SSTORE for both\\n    (info.claimCount, info.hasOpenClaim) = (claimCount, true);\\n  }\\n\\n  /**\\n   * @param coverId cover id (careful, not claim id!)\\n   * @param isAccepted claim verdict\\n   */\\n  function markCoverClaimClosed(uint coverId, bool isAccepted) external onlyInternal {\\n\\n    CoverInfo storage info = coverInfo[coverId];\\n    require(info.hasOpenClaim == true, \\\"TokenController: Cover claim is not marked as open\\\");\\n\\n    // should use a single SSTORE for both\\n    (info.hasOpenClaim, info.hasAcceptedClaim) = (false, isAccepted);\\n  }\\n\\n  /**\\n   * @dev to change the operator address\\n   * @param _newOperator is the new address of operator\\n   */\\n  function changeOperator(address _newOperator) public onlyInternal {\\n    token.changeOperator(_newOperator);\\n  }\\n\\n  /**\\n   * @dev Proxies token transfer through this contract to allow staking when members are locked for voting\\n   * @param _from   Source address\\n   * @param _to     Destination address\\n   * @param _value  Amount to transfer\\n   */\\n  function operatorTransfer(address _from, address _to, uint _value) external onlyInternal returns (bool) {\\n    require(msg.sender == address(pooledStaking), \\\"TokenController: Call is only allowed from PooledStaking address\\\");\\n    token.operatorTransfer(_from, _value);\\n    token.transfer(_to, _value);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Locks a specified amount of tokens,\\n  *    for CLA reason and for a specified time\\n  * @param _amount Number of tokens to be locked\\n  * @param _time Lock time in seconds\\n  */\\n  function lockClaimAssessmentTokens(uint256 _amount, uint256 _time) external checkPause {\\n    require(minCALockTime <= _time, \\\"TokenController: Must lock for minimum time\\\");\\n    require(_time <= 180 days, \\\"TokenController: Tokens can be locked for 180 days maximum\\\");\\n    // If tokens are already locked, then functions extendLock or\\n    // increaseClaimAssessmentLock should be used to make any changes\\n    _lock(msg.sender, \\\"CLA\\\", _amount, _time);\\n  }\\n\\n  /**\\n  * @dev Locks a specified amount of tokens against an address,\\n  *    for a specified reason and time\\n  * @param _reason The reason to lock tokens\\n  * @param _amount Number of tokens to be locked\\n  * @param _time Lock time in seconds\\n  * @param _of address whose tokens are to be locked\\n  */\\n  function lockOf(address _of, bytes32 _reason, uint256 _amount, uint256 _time)\\n  public\\n  onlyInternal\\n  returns (bool)\\n  {\\n    // If tokens are already locked, then functions extendLock or\\n    // increaseLockAmount should be used to make any changes\\n    _lock(_of, _reason, _amount, _time);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Mints and locks a specified amount of tokens against an address,\\n  *      for a CN reason and time\\n  * @param _of address whose tokens are to be locked\\n  * @param _reason The reason to lock tokens\\n  * @param _amount Number of tokens to be locked\\n  * @param _time Lock time in seconds\\n  */\\n  function mintCoverNote(\\n    address _of,\\n    bytes32 _reason,\\n    uint256 _amount,\\n    uint256 _time\\n  ) external onlyInternal {\\n\\n    require(_tokensLocked(_of, _reason) == 0, \\\"TokenController: An amount of tokens is already locked\\\");\\n    require(_amount != 0, \\\"TokenController: Amount shouldn't be zero\\\");\\n\\n    if (locked[_of][_reason].amount == 0) {\\n      lockReason[_of].push(_reason);\\n    }\\n\\n    token.mint(address(this), _amount);\\n\\n    uint256 lockedUntil = now.add(_time);\\n    locked[_of][_reason] = LockToken(_amount, lockedUntil, false);\\n\\n    emit Locked(_of, _reason, _amount, lockedUntil);\\n  }\\n\\n  /**\\n  * @dev Extends lock for reason CLA for a specified time\\n  * @param _time Lock extension time in seconds\\n  */\\n  function extendClaimAssessmentLock(uint256 _time) external checkPause {\\n    uint256 validity = getLockedTokensValidity(msg.sender, \\\"CLA\\\");\\n    require(validity.add(_time).sub(block.timestamp) <= 180 days, \\\"TokenController: Tokens can be locked for 180 days maximum\\\");\\n    _extendLock(msg.sender, \\\"CLA\\\", _time);\\n  }\\n\\n  /**\\n  * @dev Extends lock for a specified reason and time\\n  * @param _reason The reason to lock tokens\\n  * @param _time Lock extension time in seconds\\n  */\\n  function extendLockOf(address _of, bytes32 _reason, uint256 _time)\\n  public\\n  onlyInternal\\n  returns (bool)\\n  {\\n    _extendLock(_of, _reason, _time);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Increase number of tokens locked for a CLA reason\\n  * @param _amount Number of tokens to be increased\\n  */\\n  function increaseClaimAssessmentLock(uint256 _amount) external checkPause\\n  {\\n    require(_tokensLocked(msg.sender, \\\"CLA\\\") > 0, \\\"TokenController: No tokens locked\\\");\\n    token.operatorTransfer(msg.sender, _amount);\\n\\n    locked[msg.sender][\\\"CLA\\\"].amount = locked[msg.sender][\\\"CLA\\\"].amount.add(_amount);\\n    emit Locked(msg.sender, \\\"CLA\\\", _amount, locked[msg.sender][\\\"CLA\\\"].validity);\\n  }\\n\\n  /**\\n   * @dev burns tokens of an address\\n   * @param _of is the address to burn tokens of\\n   * @param amount is the amount to burn\\n   * @return the boolean status of the burning process\\n   */\\n  function burnFrom(address _of, uint amount) public onlyInternal returns (bool) {\\n    return token.burnFrom(_of, amount);\\n  }\\n\\n  /**\\n  * @dev Burns locked tokens of a user\\n  * @param _of address whose tokens are to be burned\\n  * @param _reason lock reason for which tokens are to be burned\\n  * @param _amount amount of tokens to burn\\n  */\\n  function burnLockedTokens(address _of, bytes32 _reason, uint256 _amount) public onlyInternal {\\n    _burnLockedTokens(_of, _reason, _amount);\\n  }\\n\\n  /**\\n  * @dev reduce lock duration for a specified reason and time\\n  * @param _of The address whose tokens are locked\\n  * @param _reason The reason to lock tokens\\n  * @param _time Lock reduction time in seconds\\n  */\\n  function reduceLock(address _of, bytes32 _reason, uint256 _time) public onlyInternal {\\n    _reduceLock(_of, _reason, _time);\\n  }\\n\\n  /**\\n  * @dev Released locked tokens of an address locked for a specific reason\\n  * @param _of address whose tokens are to be released from lock\\n  * @param _reason reason of the lock\\n  * @param _amount amount of tokens to release\\n  */\\n  function releaseLockedTokens(address _of, bytes32 _reason, uint256 _amount)\\n  public\\n  onlyInternal\\n  {\\n    _releaseLockedTokens(_of, _reason, _amount);\\n  }\\n\\n  /**\\n  * @dev Adds an address to whitelist maintained in the contract\\n  * @param _member address to add to whitelist\\n  */\\n  function addToWhitelist(address _member) public onlyInternal {\\n    token.addToWhiteList(_member);\\n  }\\n\\n  /**\\n  * @dev Removes an address from the whitelist in the token\\n  * @param _member address to remove\\n  */\\n  function removeFromWhitelist(address _member) public onlyInternal {\\n    token.removeFromWhiteList(_member);\\n  }\\n\\n  /**\\n  * @dev Mints new token for an address\\n  * @param _member address to reward the minted tokens\\n  * @param _amount number of tokens to mint\\n  */\\n  function mint(address _member, uint _amount) public onlyInternal {\\n    token.mint(_member, _amount);\\n  }\\n\\n  /**\\n   * @dev Lock the user's tokens\\n   * @param _of user's address.\\n   */\\n  function lockForMemberVote(address _of, uint _days) public onlyInternal {\\n    token.lockForMemberVote(_of, _days);\\n  }\\n\\n  /**\\n  * @dev Unlocks the withdrawable tokens against CLA of a specified address\\n  * @param _of Address of user, claiming back withdrawable tokens against CLA\\n  */\\n  function withdrawClaimAssessmentTokens(address _of) external checkPause {\\n    uint256 withdrawableTokens = _tokensUnlockable(_of, \\\"CLA\\\");\\n    if (withdrawableTokens > 0) {\\n      locked[_of][\\\"CLA\\\"].claimed = true;\\n      emit Unlocked(_of, \\\"CLA\\\", withdrawableTokens);\\n      token.transfer(_of, withdrawableTokens);\\n    }\\n  }\\n\\n  /**\\n   * @dev Updates Uint Parameters of a code\\n   * @param code whose details we want to update\\n   * @param value value to set\\n   */\\n  function updateUintParameters(bytes8 code, uint value) external onlyGovernance {\\n\\n    if (code == \\\"MNCLT\\\") {\\n      minCALockTime = value;\\n      return;\\n    }\\n\\n    if (code == \\\"GRACEPER\\\") {\\n      claimSubmissionGracePeriod = value;\\n      return;\\n    }\\n\\n    revert(\\\"TokenController: invalid param code\\\");\\n  }\\n\\n  function getLockReasons(address _of) external view returns (bytes32[] memory reasons) {\\n    return lockReason[_of];\\n  }\\n\\n  /**\\n  * @dev Gets the validity of locked tokens of a specified address\\n  * @param _of The address to query the validity\\n  * @param reason reason for which tokens were locked\\n  */\\n  function getLockedTokensValidity(address _of, bytes32 reason) public view returns (uint256 validity) {\\n    validity = locked[_of][reason].validity;\\n  }\\n\\n  /**\\n  * @dev Gets the unlockable tokens of a specified address\\n  * @param _of The address to query the the unlockable token count of\\n  */\\n  function getUnlockableTokens(address _of)\\n  public\\n  view\\n  returns (uint256 unlockableTokens)\\n  {\\n    for (uint256 i = 0; i < lockReason[_of].length; i++) {\\n      unlockableTokens = unlockableTokens.add(_tokensUnlockable(_of, lockReason[_of][i]));\\n    }\\n  }\\n\\n  /**\\n  * @dev Returns tokens locked for a specified address for a\\n  *    specified reason\\n  *\\n  * @param _of The address whose tokens are locked\\n  * @param _reason The reason to query the lock tokens for\\n  */\\n  function tokensLocked(address _of, bytes32 _reason)\\n  public\\n  view\\n  returns (uint256 amount)\\n  {\\n    return _tokensLocked(_of, _reason);\\n  }\\n\\n  /**\\n  * @dev Returns tokens locked and validity for a specified address and reason\\n  * @param _of The address whose tokens are locked\\n  * @param _reason The reason to query the lock tokens for\\n  */\\n  function tokensLockedWithValidity(address _of, bytes32 _reason)\\n  public\\n  view\\n  returns (uint256 amount, uint256 validity)\\n  {\\n\\n    bool claimed = locked[_of][_reason].claimed;\\n    amount = locked[_of][_reason].amount;\\n    validity = locked[_of][_reason].validity;\\n\\n    if (claimed) {\\n      amount = 0;\\n    }\\n  }\\n\\n  /**\\n  * @dev Returns unlockable tokens for a specified address for a specified reason\\n  * @param _of The address to query the the unlockable token count of\\n  * @param _reason The reason to query the unlockable tokens for\\n  */\\n  function tokensUnlockable(address _of, bytes32 _reason)\\n  public\\n  view\\n  returns (uint256 amount)\\n  {\\n    return _tokensUnlockable(_of, _reason);\\n  }\\n\\n  function totalSupply() public view returns (uint256)\\n  {\\n    return token.totalSupply();\\n  }\\n\\n  /**\\n  * @dev Returns tokens locked for a specified address for a\\n  *    specified reason at a specific time\\n  *\\n  * @param _of The address whose tokens are locked\\n  * @param _reason The reason to query the lock tokens for\\n  * @param _time The timestamp to query the lock tokens for\\n  */\\n  function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)\\n  public\\n  view\\n  returns (uint256 amount)\\n  {\\n    return _tokensLockedAtTime(_of, _reason, _time);\\n  }\\n\\n  /**\\n  * @dev Returns the total amount of tokens held by an address:\\n  *   transferable + locked + staked for pooled staking - pending burns.\\n  *   Used by Claims and Governance in member voting to calculate the user's vote weight.\\n  *\\n  * @param _of The address to query the total balance of\\n  * @param _of The address to query the total balance of\\n  */\\n  function totalBalanceOf(address _of) public view returns (uint256 amount) {\\n\\n    amount = token.balanceOf(_of);\\n\\n    for (uint256 i = 0; i < lockReason[_of].length; i++) {\\n      amount = amount.add(_tokensLocked(_of, lockReason[_of][i]));\\n    }\\n\\n    uint stakerReward = pooledStaking.stakerReward(_of);\\n    uint stakerDeposit = pooledStaking.stakerDeposit(_of);\\n\\n    amount = amount.add(stakerDeposit).add(stakerReward);\\n  }\\n\\n  /**\\n  * @dev Returns the total amount of locked and staked tokens.\\n  *      Used by MemberRoles to check eligibility for withdraw / switch membership.\\n  *      Includes tokens locked for claim assessment, tokens staked for risk assessment, and locked cover notes\\n  *      Does not take into account pending burns.\\n  * @param _of member whose locked tokens are to be calculate\\n  */\\n  function totalLockedBalance(address _of) public view returns (uint256 amount) {\\n\\n    for (uint256 i = 0; i < lockReason[_of].length; i++) {\\n      amount = amount.add(_tokensLocked(_of, lockReason[_of][i]));\\n    }\\n\\n    amount = amount.add(pooledStaking.stakerDeposit(_of));\\n  }\\n\\n  /**\\n  * @dev Locks a specified amount of tokens against an address,\\n  *    for a specified reason and time\\n  * @param _of address whose tokens are to be locked\\n  * @param _reason The reason to lock tokens\\n  * @param _amount Number of tokens to be locked\\n  * @param _time Lock time in seconds\\n  */\\n  function _lock(address _of, bytes32 _reason, uint256 _amount, uint256 _time) internal {\\n    require(_tokensLocked(_of, _reason) == 0, \\\"TokenController: An amount of tokens is already locked\\\");\\n    require(_amount != 0, \\\"TokenController: Amount shouldn't be zero\\\");\\n\\n    if (locked[_of][_reason].amount == 0) {\\n      lockReason[_of].push(_reason);\\n    }\\n\\n    token.operatorTransfer(_of, _amount);\\n\\n    uint256 validUntil = now.add(_time);\\n    locked[_of][_reason] = LockToken(_amount, validUntil, false);\\n    emit Locked(_of, _reason, _amount, validUntil);\\n  }\\n\\n  /**\\n  * @dev Returns tokens locked for a specified address for a\\n  *    specified reason\\n  *\\n  * @param _of The address whose tokens are locked\\n  * @param _reason The reason to query the lock tokens for\\n  */\\n  function _tokensLocked(address _of, bytes32 _reason)\\n  internal\\n  view\\n  returns (uint256 amount)\\n  {\\n    if (!locked[_of][_reason].claimed) {\\n      amount = locked[_of][_reason].amount;\\n    }\\n  }\\n\\n  /**\\n  * @dev Returns tokens locked for a specified address for a\\n  *    specified reason at a specific time\\n  *\\n  * @param _of The address whose tokens are locked\\n  * @param _reason The reason to query the lock tokens for\\n  * @param _time The timestamp to query the lock tokens for\\n  */\\n  function _tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)\\n  internal\\n  view\\n  returns (uint256 amount)\\n  {\\n    if (locked[_of][_reason].validity > _time) {\\n      amount = locked[_of][_reason].amount;\\n    }\\n  }\\n\\n  /**\\n  * @dev Extends lock for a specified reason and time\\n  * @param _of The address whose tokens are locked\\n  * @param _reason The reason to lock tokens\\n  * @param _time Lock extension time in seconds\\n  */\\n  function _extendLock(address _of, bytes32 _reason, uint256 _time) internal {\\n    require(_tokensLocked(_of, _reason) > 0, \\\"TokenController: No tokens locked\\\");\\n    emit Unlocked(_of, _reason, locked[_of][_reason].amount);\\n    locked[_of][_reason].validity = locked[_of][_reason].validity.add(_time);\\n    emit Locked(_of, _reason, locked[_of][_reason].amount, locked[_of][_reason].validity);\\n  }\\n\\n  /**\\n  * @dev reduce lock duration for a specified reason and time\\n  * @param _of The address whose tokens are locked\\n  * @param _reason The reason to lock tokens\\n  * @param _time Lock reduction time in seconds\\n  */\\n  function _reduceLock(address _of, bytes32 _reason, uint256 _time) internal {\\n    require(_tokensLocked(_of, _reason) > 0, \\\"TokenController: No tokens locked\\\");\\n    emit Unlocked(_of, _reason, locked[_of][_reason].amount);\\n    locked[_of][_reason].validity = locked[_of][_reason].validity.sub(_time);\\n    emit Locked(_of, _reason, locked[_of][_reason].amount, locked[_of][_reason].validity);\\n  }\\n\\n  /**\\n  * @dev Returns unlockable tokens for a specified address for a specified reason\\n  * @param _of The address to query the the unlockable token count of\\n  * @param _reason The reason to query the unlockable tokens for\\n  */\\n  function _tokensUnlockable(address _of, bytes32 _reason) internal view returns (uint256 amount)\\n  {\\n    if (locked[_of][_reason].validity <= now && !locked[_of][_reason].claimed) {\\n      amount = locked[_of][_reason].amount;\\n    }\\n  }\\n\\n  /**\\n  * @dev Burns locked tokens of a user\\n  * @param _of address whose tokens are to be burned\\n  * @param _reason lock reason for which tokens are to be burned\\n  * @param _amount amount of tokens to burn\\n  */\\n  function _burnLockedTokens(address _of, bytes32 _reason, uint256 _amount) internal {\\n    uint256 amount = _tokensLocked(_of, _reason);\\n    require(amount >= _amount, \\\"TokenController: Amount exceedes locked tokens amount\\\");\\n\\n    if (amount == _amount) {\\n      locked[_of][_reason].claimed = true;\\n    }\\n\\n    locked[_of][_reason].amount = locked[_of][_reason].amount.sub(_amount);\\n\\n    // lock reason removal is skipped here: needs to be done from offchain\\n\\n    token.burn(_amount);\\n    emit Burned(_of, _reason, _amount);\\n  }\\n\\n  /**\\n  * @dev Released locked tokens of an address locked for a specific reason\\n  * @param _of address whose tokens are to be released from lock\\n  * @param _reason reason of the lock\\n  * @param _amount amount of tokens to release\\n  */\\n  function _releaseLockedTokens(address _of, bytes32 _reason, uint256 _amount) internal\\n  {\\n    uint256 amount = _tokensLocked(_of, _reason);\\n    require(amount >= _amount, \\\"TokenController: Amount exceedes locked tokens amount\\\");\\n\\n    if (amount == _amount) {\\n      locked[_of][_reason].claimed = true;\\n    }\\n\\n    locked[_of][_reason].amount = locked[_of][_reason].amount.sub(_amount);\\n\\n    // lock reason removal is skipped here: needs to be done from offchain\\n\\n    token.transfer(_of, _amount);\\n    emit Unlocked(_of, _reason, _amount);\\n  }\\n\\n  function withdrawCoverNote(\\n    address _of,\\n    uint[] calldata _coverIds,\\n    uint[] calldata _indexes\\n  ) external onlyInternal {\\n\\n    uint reasonCount = lockReason[_of].length;\\n    uint lastReasonIndex = reasonCount.sub(1, \\\"TokenController: No locked cover notes found\\\");\\n    uint totalAmount = 0;\\n\\n    // The iteration is done from the last to first to prevent reason indexes from\\n    // changing due to the way we delete the items (copy last to current and pop last).\\n    // The provided indexes array must be ordered, otherwise reason index checks will fail.\\n\\n    for (uint i = _coverIds.length; i > 0; i--) {\\n\\n      bool hasOpenClaim = coverInfo[_coverIds[i - 1]].hasOpenClaim;\\n      require(hasOpenClaim == false, \\\"TokenController: Cannot withdraw for cover with an open claim\\\");\\n\\n      // note: cover owner is implicitly checked using the reason hash\\n      bytes32 _reason = keccak256(abi.encodePacked(\\\"CN\\\", _of, _coverIds[i - 1]));\\n      uint _reasonIndex = _indexes[i - 1];\\n      require(lockReason[_of][_reasonIndex] == _reason, \\\"TokenController: Bad reason index\\\");\\n\\n      uint amount = locked[_of][_reason].amount;\\n      totalAmount = totalAmount.add(amount);\\n      delete locked[_of][_reason];\\n\\n      if (lastReasonIndex != _reasonIndex) {\\n        lockReason[_of][_reasonIndex] = lockReason[_of][lastReasonIndex];\\n      }\\n\\n      lockReason[_of].pop();\\n      emit Unlocked(_of, _reason, amount);\\n\\n      if (lastReasonIndex > 0) {\\n        lastReasonIndex = lastReasonIndex.sub(1, \\\"TokenController: Reason count mismatch\\\");\\n      }\\n    }\\n\\n    token.transfer(_of, totalAmount);\\n  }\\n\\n  function removeEmptyReason(address _of, bytes32 _reason, uint _index) external {\\n    _removeEmptyReason(_of, _reason, _index);\\n  }\\n\\n  function removeMultipleEmptyReasons(\\n    address[] calldata _members,\\n    bytes32[] calldata _reasons,\\n    uint[] calldata _indexes\\n  ) external {\\n\\n    require(_members.length == _reasons.length, \\\"TokenController: members and reasons array lengths differ\\\");\\n    require(_reasons.length == _indexes.length, \\\"TokenController: reasons and indexes array lengths differ\\\");\\n\\n    for (uint i = _members.length; i > 0; i--) {\\n      uint idx = i - 1;\\n      _removeEmptyReason(_members[idx], _reasons[idx], _indexes[idx]);\\n    }\\n  }\\n\\n  function _removeEmptyReason(address _of, bytes32 _reason, uint _index) internal {\\n\\n    uint lastReasonIndex = lockReason[_of].length.sub(1, \\\"TokenController: lockReason is empty\\\");\\n\\n    require(lockReason[_of][_index] == _reason, \\\"TokenController: bad reason index\\\");\\n    require(locked[_of][_reason].amount == 0, \\\"TokenController: reason amount is not zero\\\");\\n\\n    if (lastReasonIndex != _index) {\\n      lockReason[_of][_index] = lockReason[_of][lastReasonIndex];\\n    }\\n\\n    lockReason[_of].pop();\\n  }\\n\\n  function initialize() external {\\n    require(claimSubmissionGracePeriod == 0, \\\"TokenController: Already initialized\\\");\\n    claimSubmissionGracePeriod = 120 days;\\n    migrate();\\n  }\\n\\n  function migrate() internal {\\n\\n    ClaimsData cd = ClaimsData(ms.getLatestAddress(\\\"CD\\\"));\\n    uint totalClaims = cd.actualClaimLength() - 1;\\n\\n    // fix stuck claims 21 & 22\\n    cd.changeFinalVerdict(20, -1);\\n    cd.setClaimStatus(20, 6);\\n    cd.changeFinalVerdict(21, -1);\\n    cd.setClaimStatus(21, 6);\\n\\n    // reduce claim assessment lock period for members locked for more than 180 days\\n    // extracted using scripts/extract-ca-locked-more-than-180.js\\n    address payable[3] memory members = [\\n      0x4a9fA34da6d2378c8f3B9F6b83532B169beaEDFc,\\n      0x6b5DCDA27b5c3d88e71867D6b10b35372208361F,\\n      0x8B6D1e5b4db5B6f9aCcc659e2b9619B0Cd90D617\\n    ];\\n\\n    for (uint i = 0; i < members.length; i++) {\\n      if (locked[members[i]][\\\"CLA\\\"].validity > now + 180 days) {\\n        locked[members[i]][\\\"CLA\\\"].validity = now + 180 days;\\n      }\\n    }\\n\\n    for (uint i = 1; i <= totalClaims; i++) {\\n\\n      (/*id*/, uint status) = cd.getClaimStatusNumber(i);\\n      (/*id*/, uint coverId) = cd.getClaimCoverId(i);\\n      int8 verdict = cd.getFinalVerdict(i);\\n\\n      // SLOAD\\n      CoverInfo memory info = coverInfo[coverId];\\n\\n      info.claimCount = info.claimCount + 1;\\n      info.hasAcceptedClaim = (status == 14);\\n      info.hasOpenClaim = (verdict == 0);\\n\\n      // SSTORE\\n      coverInfo[coverId] = info;\\n    }\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/abstract/Iupgradable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./INXMMaster.sol\\\";\\n\\ncontract Iupgradable {\\n\\n  INXMMaster public ms;\\n  address public nxMasterAddress;\\n\\n  modifier onlyInternal {\\n    require(ms.isInternal(msg.sender));\\n    _;\\n  }\\n\\n  modifier isMemberAndcheckPause {\\n    require(ms.isPause() == false && ms.isMember(msg.sender) == true);\\n    _;\\n  }\\n\\n  modifier onlyOwner {\\n    require(ms.isOwner(msg.sender));\\n    _;\\n  }\\n\\n  modifier checkPause {\\n    require(ms.isPause() == false);\\n    _;\\n  }\\n\\n  modifier isMember {\\n    require(ms.isMember(msg.sender), \\\"Not member\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Iupgradable Interface to update dependent contract address\\n   */\\n  function changeDependentContractAddress() public;\\n\\n  /**\\n   * @dev change master address\\n   * @param _masterAddress is the new address\\n   */\\n  function changeMasterAddress(address _masterAddress) public {\\n    if (address(ms) != address(0)) {\\n      require(address(ms) == msg.sender, \\\"Not master\\\");\\n    }\\n\\n    ms = INXMMaster(_masterAddress);\\n    nxMasterAddress = _masterAddress;\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPooledStaking.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n\\ninterface IPooledStaking {\\n\\n  function accumulateReward(address contractAddress, uint amount) external;\\n\\n  function pushBurn(address contractAddress, uint amount) external;\\n\\n  function hasPendingActions() external view returns (bool);\\n\\n  function contractStake(address contractAddress) external view returns (uint);\\n\\n  function stakerReward(address staker) external view returns (uint);\\n\\n  function stakerDeposit(address staker) external view returns (uint);\\n\\n  function stakerContractStake(address staker, address contractAddress) external view returns (uint);\\n\\n  function withdraw(uint amount) external;\\n\\n  function stakerMaxWithdrawable(address stakerAddress) external view returns (uint);\\n\\n  function withdrawReward(address stakerAddress) external;\\n}\\n\"\r\n    },\r\n    \"contracts/modules/claims/ClaimsData.sol\": {\r\n      \"content\": \"/* Copyright (C) 2020 NexusMutual.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../../abstract/Iupgradable.sol\\\";\\n\\ncontract ClaimsData is Iupgradable {\\n  using SafeMath for uint;\\n\\n  struct Claim {\\n    uint coverId;\\n    uint dateUpd;\\n  }\\n\\n  struct Vote {\\n    address voter;\\n    uint tokens;\\n    uint claimId;\\n    int8 verdict;\\n    bool rewardClaimed;\\n  }\\n\\n  struct ClaimsPause {\\n    uint coverid;\\n    uint dateUpd;\\n    bool submit;\\n  }\\n\\n  struct ClaimPauseVoting {\\n    uint claimid;\\n    uint pendingTime;\\n    bool voting;\\n  }\\n\\n  struct RewardDistributed {\\n    uint lastCAvoteIndex;\\n    uint lastMVvoteIndex;\\n\\n  }\\n\\n  struct ClaimRewardDetails {\\n    uint percCA;\\n    uint percMV;\\n    uint tokenToBeDist;\\n\\n  }\\n\\n  struct ClaimTotalTokens {\\n    uint accept;\\n    uint deny;\\n  }\\n\\n  struct ClaimRewardStatus {\\n    uint percCA;\\n    uint percMV;\\n  }\\n\\n  ClaimRewardStatus[] internal rewardStatus;\\n\\n  Claim[] internal allClaims;\\n  Vote[] internal allvotes;\\n  ClaimsPause[] internal claimPause;\\n  ClaimPauseVoting[] internal claimPauseVotingEP;\\n\\n  mapping(address => RewardDistributed) internal voterVoteRewardReceived;\\n  mapping(uint => ClaimRewardDetails) internal claimRewardDetail;\\n  mapping(uint => ClaimTotalTokens) internal claimTokensCA;\\n  mapping(uint => ClaimTotalTokens) internal claimTokensMV;\\n  mapping(uint => int8) internal claimVote;\\n  mapping(uint => uint) internal claimsStatus;\\n  mapping(uint => uint) internal claimState12Count;\\n  mapping(uint => uint[]) internal claimVoteCA;\\n  mapping(uint => uint[]) internal claimVoteMember;\\n  mapping(address => uint[]) internal voteAddressCA;\\n  mapping(address => uint[]) internal voteAddressMember;\\n  mapping(address => uint[]) internal allClaimsByAddress;\\n  mapping(address => mapping(uint => uint)) internal userClaimVoteCA;\\n  mapping(address => mapping(uint => uint)) internal userClaimVoteMember;\\n  mapping(address => uint) public userClaimVotePausedOn;\\n\\n  uint internal claimPauseLastsubmit;\\n  uint internal claimStartVotingFirstIndex;\\n  uint public pendingClaimStart;\\n  uint public claimDepositTime;\\n  uint public maxVotingTime;\\n  uint public minVotingTime;\\n  uint public payoutRetryTime;\\n  uint public claimRewardPerc;\\n  uint public minVoteThreshold;\\n  uint public maxVoteThreshold;\\n  uint public majorityConsensus;\\n  uint public pauseDaysCA;\\n\\n  event ClaimRaise(\\n    uint indexed coverId,\\n    address indexed userAddress,\\n    uint claimId,\\n    uint dateSubmit\\n  );\\n\\n  event VoteCast(\\n    address indexed userAddress,\\n    uint indexed claimId,\\n    bytes4 indexed typeOf,\\n    uint tokens,\\n    uint submitDate,\\n    int8 verdict\\n  );\\n\\n  constructor() public {\\n    pendingClaimStart = 1;\\n    maxVotingTime = 48 * 1 hours;\\n    minVotingTime = 12 * 1 hours;\\n    payoutRetryTime = 24 * 1 hours;\\n    allvotes.push(Vote(address(0), 0, 0, 0, false));\\n    allClaims.push(Claim(0, 0));\\n    claimDepositTime = 7 days;\\n    claimRewardPerc = 20;\\n    minVoteThreshold = 5;\\n    maxVoteThreshold = 10;\\n    majorityConsensus = 70;\\n    pauseDaysCA = 3 days;\\n    _addRewardIncentive();\\n  }\\n\\n  /**\\n   * @dev Updates the pending claim start variable,\\n   * the lowest claim id with a pending decision/payout.\\n   */\\n  function setpendingClaimStart(uint _start) external onlyInternal {\\n    require(pendingClaimStart <= _start);\\n    pendingClaimStart = _start;\\n  }\\n\\n  /**\\n   * @dev Updates the max vote index for which claim assessor has received reward\\n   * @param _voter address of the voter.\\n   * @param caIndex last index till which reward was distributed for CA\\n   */\\n  function setRewardDistributedIndexCA(address _voter, uint caIndex) external onlyInternal {\\n    voterVoteRewardReceived[_voter].lastCAvoteIndex = caIndex;\\n\\n  }\\n\\n  /**\\n   * @dev Used to pause claim assessor activity for 3 days\\n   * @param user Member address whose claim voting ability needs to be paused\\n   */\\n  function setUserClaimVotePausedOn(address user) external {\\n    require(ms.checkIsAuthToGoverned(msg.sender));\\n    userClaimVotePausedOn[user] = now;\\n  }\\n\\n  /**\\n   * @dev Updates the max vote index for which member has received reward\\n   * @param _voter address of the voter.\\n   * @param mvIndex last index till which reward was distributed for member\\n   */\\n  function setRewardDistributedIndexMV(address _voter, uint mvIndex) external onlyInternal {\\n\\n    voterVoteRewardReceived[_voter].lastMVvoteIndex = mvIndex;\\n  }\\n\\n  /**\\n   * @param claimid claim id.\\n   * @param percCA reward Percentage reward for claim assessor\\n   * @param percMV reward Percentage reward for members\\n   * @param tokens total tokens to be rewarded\\n   */\\n  function setClaimRewardDetail(\\n    uint claimid,\\n    uint percCA,\\n    uint percMV,\\n    uint tokens\\n  )\\n  external\\n  onlyInternal\\n  {\\n    claimRewardDetail[claimid].percCA = percCA;\\n    claimRewardDetail[claimid].percMV = percMV;\\n    claimRewardDetail[claimid].tokenToBeDist = tokens;\\n  }\\n\\n  /**\\n   * @dev Sets the reward claim status against a vote id.\\n   * @param _voteid vote Id.\\n   * @param claimed true if reward for vote is claimed, else false.\\n   */\\n  function setRewardClaimed(uint _voteid, bool claimed) external onlyInternal {\\n    allvotes[_voteid].rewardClaimed = claimed;\\n  }\\n\\n  /**\\n   * @dev Sets the final vote's result(either accepted or declined)of a claim.\\n   * @param _claimId Claim Id.\\n   * @param _verdict 1 if claim is accepted,-1 if declined.\\n   */\\n  function changeFinalVerdict(uint _claimId, int8 _verdict) external onlyInternal {\\n    claimVote[_claimId] = _verdict;\\n  }\\n\\n  /**\\n   * @dev Creates a new claim.\\n   */\\n  function addClaim(\\n    uint _claimId,\\n    uint _coverId,\\n    address _from,\\n    uint _nowtime\\n  )\\n  external\\n  onlyInternal\\n  {\\n    allClaims.push(Claim(_coverId, _nowtime));\\n    allClaimsByAddress[_from].push(_claimId);\\n  }\\n\\n  /**\\n   * @dev Add Vote's details of a given claim.\\n   */\\n  function addVote(\\n    address _voter,\\n    uint _tokens,\\n    uint claimId,\\n    int8 _verdict\\n  )\\n  external\\n  onlyInternal\\n  {\\n    allvotes.push(Vote(_voter, _tokens, claimId, _verdict, false));\\n  }\\n\\n  /**\\n   * @dev Stores the id of the claim assessor vote given to a claim.\\n   * Maintains record of all votes given by all the CA to a claim.\\n   * @param _claimId Claim Id to which vote has given by the CA.\\n   * @param _voteid Vote Id.\\n   */\\n  function addClaimVoteCA(uint _claimId, uint _voteid) external onlyInternal {\\n    claimVoteCA[_claimId].push(_voteid);\\n  }\\n\\n  /**\\n   * @dev Sets the id of the vote.\\n   * @param _from Claim assessor's address who has given the vote.\\n   * @param _claimId Claim Id for which vote has been given by the CA.\\n   * @param _voteid Vote Id which will be stored against the given _from and claimid.\\n   */\\n  function setUserClaimVoteCA(\\n    address _from,\\n    uint _claimId,\\n    uint _voteid\\n  )\\n  external\\n  onlyInternal\\n  {\\n    userClaimVoteCA[_from][_claimId] = _voteid;\\n    voteAddressCA[_from].push(_voteid);\\n  }\\n\\n  /**\\n   * @dev Stores the tokens locked by the Claim Assessors during voting of a given claim.\\n   * @param _claimId Claim Id.\\n   * @param _vote 1 for accept and increases the tokens of claim as accept,\\n   * -1 for deny and increases the tokens of claim as deny.\\n   * @param _tokens Number of tokens.\\n   */\\n  function setClaimTokensCA(uint _claimId, int8 _vote, uint _tokens) external onlyInternal {\\n    if (_vote == 1)\\n      claimTokensCA[_claimId].accept = claimTokensCA[_claimId].accept.add(_tokens);\\n    if (_vote == - 1)\\n      claimTokensCA[_claimId].deny = claimTokensCA[_claimId].deny.add(_tokens);\\n  }\\n\\n  /**\\n   * @dev Stores the tokens locked by the Members during voting of a given claim.\\n   * @param _claimId Claim Id.\\n   * @param _vote 1 for accept and increases the tokens of claim as accept,\\n   * -1 for deny and increases the tokens of claim as deny.\\n   * @param _tokens Number of tokens.\\n   */\\n  function setClaimTokensMV(uint _claimId, int8 _vote, uint _tokens) external onlyInternal {\\n    if (_vote == 1)\\n      claimTokensMV[_claimId].accept = claimTokensMV[_claimId].accept.add(_tokens);\\n    if (_vote == - 1)\\n      claimTokensMV[_claimId].deny = claimTokensMV[_claimId].deny.add(_tokens);\\n  }\\n\\n  /**\\n   * @dev Stores the id of the member vote given to a claim.\\n   * Maintains record of all votes given by all the Members to a claim.\\n   * @param _claimId Claim Id to which vote has been given by the Member.\\n   * @param _voteid Vote Id.\\n   */\\n  function addClaimVotemember(uint _claimId, uint _voteid) external onlyInternal {\\n    claimVoteMember[_claimId].push(_voteid);\\n  }\\n\\n  /**\\n   * @dev Sets the id of the vote.\\n   * @param _from Member's address who has given the vote.\\n   * @param _claimId Claim Id for which vote has been given by the Member.\\n   * @param _voteid Vote Id which will be stored against the given _from and claimid.\\n   */\\n  function setUserClaimVoteMember(\\n    address _from,\\n    uint _claimId,\\n    uint _voteid\\n  )\\n  external\\n  onlyInternal\\n  {\\n    userClaimVoteMember[_from][_claimId] = _voteid;\\n    voteAddressMember[_from].push(_voteid);\\n\\n  }\\n\\n  /**\\n   * @dev Increases the count of failure until payout of a claim is successful.\\n   */\\n  function updateState12Count(uint _claimId, uint _cnt) external onlyInternal {\\n    claimState12Count[_claimId] = claimState12Count[_claimId].add(_cnt);\\n  }\\n\\n  /**\\n   * @dev Sets status of a claim.\\n   * @param _claimId Claim Id.\\n   * @param _stat Status number.\\n   */\\n  function setClaimStatus(uint _claimId, uint _stat) external onlyInternal {\\n    claimsStatus[_claimId] = _stat;\\n  }\\n\\n  /**\\n   * @dev Sets the timestamp of a given claim at which the Claim's details has been updated.\\n   * @param _claimId Claim Id of claim which has been changed.\\n   * @param _dateUpd timestamp at which claim is updated.\\n   */\\n  function setClaimdateUpd(uint _claimId, uint _dateUpd) external onlyInternal {\\n    allClaims[_claimId].dateUpd = _dateUpd;\\n  }\\n\\n  /**\\n   @dev Queues Claims during Emergency Pause.\\n   */\\n  function setClaimAtEmergencyPause(\\n    uint _coverId,\\n    uint _dateUpd,\\n    bool _submit\\n  )\\n  external\\n  onlyInternal\\n  {\\n    claimPause.push(ClaimsPause(_coverId, _dateUpd, _submit));\\n  }\\n\\n  /**\\n   * @dev Set submission flag for Claims queued during emergency pause.\\n   * Set to true after EP is turned off and the claim is submitted .\\n   */\\n  function setClaimSubmittedAtEPTrue(uint _index, bool _submit) external onlyInternal {\\n    claimPause[_index].submit = _submit;\\n  }\\n\\n  /**\\n   * @dev Sets the index from which claim needs to be\\n   * submitted when emergency pause is swithched off.\\n   */\\n  function setFirstClaimIndexToSubmitAfterEP(\\n    uint _firstClaimIndexToSubmit\\n  )\\n  external\\n  onlyInternal\\n  {\\n    claimPauseLastsubmit = _firstClaimIndexToSubmit;\\n  }\\n\\n  /**\\n   * @dev Sets the pending vote duration for a claim in case of emergency pause.\\n   */\\n  function setPendingClaimDetails(\\n    uint _claimId,\\n    uint _pendingTime,\\n    bool _voting\\n  )\\n  external\\n  onlyInternal\\n  {\\n    claimPauseVotingEP.push(ClaimPauseVoting(_claimId, _pendingTime, _voting));\\n  }\\n\\n  /**\\n   * @dev Sets voting flag true after claim is reopened for voting after emergency pause.\\n   */\\n  function setPendingClaimVoteStatus(uint _claimId, bool _vote) external onlyInternal {\\n    claimPauseVotingEP[_claimId].voting = _vote;\\n  }\\n\\n  /**\\n   * @dev Sets the index from which claim needs to be\\n   * reopened when emergency pause is swithched off.\\n   */\\n  function setFirstClaimIndexToStartVotingAfterEP(\\n    uint _claimStartVotingFirstIndex\\n  )\\n  external\\n  onlyInternal\\n  {\\n    claimStartVotingFirstIndex = _claimStartVotingFirstIndex;\\n  }\\n\\n  /**\\n   * @dev Calls Vote Event.\\n   */\\n  function callVoteEvent(\\n    address _userAddress,\\n    uint _claimId,\\n    bytes4 _typeOf,\\n    uint _tokens,\\n    uint _submitDate,\\n    int8 _verdict\\n  )\\n  external\\n  onlyInternal\\n  {\\n    emit VoteCast(\\n      _userAddress,\\n      _claimId,\\n      _typeOf,\\n      _tokens,\\n      _submitDate,\\n      _verdict\\n    );\\n  }\\n\\n  /**\\n   * @dev Calls Claim Event.\\n   */\\n  function callClaimEvent(\\n    uint _coverId,\\n    address _userAddress,\\n    uint _claimId,\\n    uint _datesubmit\\n  )\\n  external\\n  onlyInternal\\n  {\\n    emit ClaimRaise(_coverId, _userAddress, _claimId, _datesubmit);\\n  }\\n\\n  /**\\n   * @dev Gets Uint Parameters by parameter code\\n   * @param code whose details we want\\n   * @return string value of the parameter\\n   * @return associated amount (time or perc or value) to the code\\n   */\\n  function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val) {\\n    codeVal = code;\\n    if (code == \\\"CAMAXVT\\\") {\\n      val = maxVotingTime / (1 hours);\\n\\n    } else if (code == \\\"CAMINVT\\\") {\\n\\n      val = minVotingTime / (1 hours);\\n\\n    } else if (code == \\\"CAPRETRY\\\") {\\n\\n      val = payoutRetryTime / (1 hours);\\n\\n    } else if (code == \\\"CADEPT\\\") {\\n\\n      val = claimDepositTime / (1 days);\\n\\n    } else if (code == \\\"CAREWPER\\\") {\\n\\n      val = claimRewardPerc;\\n\\n    } else if (code == \\\"CAMINTH\\\") {\\n\\n      val = minVoteThreshold;\\n\\n    } else if (code == \\\"CAMAXTH\\\") {\\n\\n      val = maxVoteThreshold;\\n\\n    } else if (code == \\\"CACONPER\\\") {\\n\\n      val = majorityConsensus;\\n\\n    } else if (code == \\\"CAPAUSET\\\") {\\n      val = pauseDaysCA / (1 days);\\n    }\\n\\n  }\\n\\n  /**\\n   * @dev Get claim queued during emergency pause by index.\\n   */\\n  function getClaimOfEmergencyPauseByIndex(\\n    uint _index\\n  )\\n  external\\n  view\\n  returns (\\n    uint coverId,\\n    uint dateUpd,\\n    bool submit\\n  )\\n  {\\n    coverId = claimPause[_index].coverid;\\n    dateUpd = claimPause[_index].dateUpd;\\n    submit = claimPause[_index].submit;\\n  }\\n\\n  /**\\n   * @dev Gets the Claim's details of given claimid.\\n   */\\n  function getAllClaimsByIndex(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint coverId,\\n    int8 vote,\\n    uint status,\\n    uint dateUpd,\\n    uint state12Count\\n  )\\n  {\\n    return (\\n    allClaims[_claimId].coverId,\\n    claimVote[_claimId],\\n    claimsStatus[_claimId],\\n    allClaims[_claimId].dateUpd,\\n    claimState12Count[_claimId]\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets the vote id of a given claim of a given Claim Assessor.\\n   */\\n  function getUserClaimVoteCA(\\n    address _add,\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (uint idVote)\\n  {\\n    return userClaimVoteCA[_add][_claimId];\\n  }\\n\\n  /**\\n   * @dev Gets the vote id of a given claim of a given member.\\n   */\\n  function getUserClaimVoteMember(\\n    address _add,\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (uint idVote)\\n  {\\n    return userClaimVoteMember[_add][_claimId];\\n  }\\n\\n  /**\\n   * @dev Gets the count of all votes.\\n   */\\n  function getAllVoteLength() external view returns (uint voteCount) {\\n    return allvotes.length.sub(1); // Start Index always from 1.\\n  }\\n\\n  /**\\n   * @dev Gets the status number of a given claim.\\n   * @param _claimId Claim id.\\n   * @return statno Status Number.\\n   */\\n  function getClaimStatusNumber(uint _claimId) external view returns (uint claimId, uint statno) {\\n    return (_claimId, claimsStatus[_claimId]);\\n  }\\n\\n  /**\\n   * @dev Gets the reward percentage to be distributed for a given status id\\n   * @param statusNumber the number of type of status\\n   * @return percCA reward Percentage for claim assessor\\n   * @return percMV reward Percentage for members\\n   */\\n  function getRewardStatus(uint statusNumber) external view returns (uint percCA, uint percMV) {\\n    return (rewardStatus[statusNumber].percCA, rewardStatus[statusNumber].percMV);\\n  }\\n\\n  /**\\n   * @dev Gets the number of tries that have been made for a successful payout of a Claim.\\n   */\\n  function getClaimState12Count(uint _claimId) external view returns (uint num) {\\n    num = claimState12Count[_claimId];\\n  }\\n\\n  /**\\n   * @dev Gets the last update date of a claim.\\n   */\\n  function getClaimDateUpd(uint _claimId) external view returns (uint dateupd) {\\n    dateupd = allClaims[_claimId].dateUpd;\\n  }\\n\\n  /**\\n   * @dev Gets all Claims created by a user till date.\\n   * @param _member user's address.\\n   * @return claimarr List of Claims id.\\n   */\\n  function getAllClaimsByAddress(address _member) external view returns (uint[] memory claimarr) {\\n    return allClaimsByAddress[_member];\\n  }\\n\\n  /**\\n   * @dev Gets the number of tokens that has been locked\\n   * while giving vote to a claim by  Claim Assessors.\\n   * @param _claimId Claim Id.\\n   * @return accept Total number of tokens when CA accepts the claim.\\n   * @return deny Total number of tokens when CA declines the claim.\\n   */\\n  function getClaimsTokenCA(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint accept,\\n    uint deny\\n  )\\n  {\\n    return (\\n    _claimId,\\n    claimTokensCA[_claimId].accept,\\n    claimTokensCA[_claimId].deny\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets the number of tokens that have been\\n   * locked while assessing a claim as a member.\\n   * @param _claimId Claim Id.\\n   * @return accept Total number of tokens in acceptance of the claim.\\n   * @return deny Total number of tokens against the claim.\\n   */\\n  function getClaimsTokenMV(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint accept,\\n    uint deny\\n  )\\n  {\\n    return (\\n    _claimId,\\n    claimTokensMV[_claimId].accept,\\n    claimTokensMV[_claimId].deny\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets the total number of votes cast as Claims assessor for/against a given claim\\n   */\\n  function getCaClaimVotesToken(uint _claimId) external view returns (uint claimId, uint cnt) {\\n    claimId = _claimId;\\n    cnt = 0;\\n    for (uint i = 0; i < claimVoteCA[_claimId].length; i++) {\\n      cnt = cnt.add(allvotes[claimVoteCA[_claimId][i]].tokens);\\n    }\\n  }\\n\\n  /**\\n   * @dev Gets the total number of tokens cast as a member for/against a given claim\\n   */\\n  function getMemberClaimVotesToken(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (uint claimId, uint cnt)\\n  {\\n    claimId = _claimId;\\n    cnt = 0;\\n    for (uint i = 0; i < claimVoteMember[_claimId].length; i++) {\\n      cnt = cnt.add(allvotes[claimVoteMember[_claimId][i]].tokens);\\n    }\\n  }\\n\\n  /**\\n   * @dev Provides information of a vote when given its vote id.\\n   * @param _voteid Vote Id.\\n   */\\n  function getVoteDetails(uint _voteid)\\n  external view\\n  returns (\\n    uint tokens,\\n    uint claimId,\\n    int8 verdict,\\n    bool rewardClaimed\\n  )\\n  {\\n    return (\\n    allvotes[_voteid].tokens,\\n    allvotes[_voteid].claimId,\\n    allvotes[_voteid].verdict,\\n    allvotes[_voteid].rewardClaimed\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets the voter's address of a given vote id.\\n   */\\n  function getVoterVote(uint _voteid) external view returns (address voter) {\\n    return allvotes[_voteid].voter;\\n  }\\n\\n  /**\\n   * @dev Provides information of a Claim when given its claim id.\\n   * @param _claimId Claim Id.\\n   */\\n  function getClaim(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint coverId,\\n    int8 vote,\\n    uint status,\\n    uint dateUpd,\\n    uint state12Count\\n  )\\n  {\\n    return (\\n    _claimId,\\n    allClaims[_claimId].coverId,\\n    claimVote[_claimId],\\n    claimsStatus[_claimId],\\n    allClaims[_claimId].dateUpd,\\n    claimState12Count[_claimId]\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets the total number of votes of a given claim.\\n   * @param _claimId Claim Id.\\n   * @param _ca if 1: votes given by Claim Assessors to a claim,\\n   * else returns the number of votes of given by Members to a claim.\\n   * @return len total number of votes for/against a given claim.\\n   */\\n  function getClaimVoteLength(\\n    uint _claimId,\\n    uint8 _ca\\n  )\\n  external\\n  view\\n  returns (uint claimId, uint len)\\n  {\\n    claimId = _claimId;\\n    if (_ca == 1)\\n      len = claimVoteCA[_claimId].length;\\n    else\\n      len = claimVoteMember[_claimId].length;\\n  }\\n\\n  /**\\n   * @dev Gets the verdict of a vote using claim id and index.\\n   * @param _ca 1 for vote given as a CA, else for vote given as a member.\\n   * @return ver 1 if vote was given in favour,-1 if given in against.\\n   */\\n  function getVoteVerdict(\\n    uint _claimId,\\n    uint _index,\\n    uint8 _ca\\n  )\\n  external\\n  view\\n  returns (int8 ver)\\n  {\\n    if (_ca == 1)\\n      ver = allvotes[claimVoteCA[_claimId][_index]].verdict;\\n    else\\n      ver = allvotes[claimVoteMember[_claimId][_index]].verdict;\\n  }\\n\\n  /**\\n   * @dev Gets the Number of tokens of a vote using claim id and index.\\n   * @param _ca 1 for vote given as a CA, else for vote given as a member.\\n   * @return tok Number of tokens.\\n   */\\n  function getVoteToken(\\n    uint _claimId,\\n    uint _index,\\n    uint8 _ca\\n  )\\n  external\\n  view\\n  returns (uint tok)\\n  {\\n    if (_ca == 1)\\n      tok = allvotes[claimVoteCA[_claimId][_index]].tokens;\\n    else\\n      tok = allvotes[claimVoteMember[_claimId][_index]].tokens;\\n  }\\n\\n  /**\\n   * @dev Gets the Voter's address of a vote using claim id and index.\\n   * @param _ca 1 for vote given as a CA, else for vote given as a member.\\n   * @return voter Voter's address.\\n   */\\n  function getVoteVoter(\\n    uint _claimId,\\n    uint _index,\\n    uint8 _ca\\n  )\\n  external\\n  view\\n  returns (address voter)\\n  {\\n    if (_ca == 1)\\n      voter = allvotes[claimVoteCA[_claimId][_index]].voter;\\n    else\\n      voter = allvotes[claimVoteMember[_claimId][_index]].voter;\\n  }\\n\\n  /**\\n   * @dev Gets total number of Claims created by a user till date.\\n   * @param _add User's address.\\n   */\\n  function getUserClaimCount(address _add) external view returns (uint len) {\\n    len = allClaimsByAddress[_add].length;\\n  }\\n\\n  /**\\n   * @dev Calculates number of Claims that are in pending state.\\n   */\\n  function getClaimLength() external view returns (uint len) {\\n    len = allClaims.length.sub(pendingClaimStart);\\n  }\\n\\n  /**\\n   * @dev Gets the Number of all the Claims created till date.\\n   */\\n  function actualClaimLength() external view returns (uint len) {\\n    len = allClaims.length;\\n  }\\n\\n  /**\\n   * @dev Gets details of a claim.\\n   * @param _index claim id = pending claim start + given index\\n   * @param _add User's address.\\n   * @return coverid cover against which claim has been submitted.\\n   * @return claimId Claim  Id.\\n   * @return voteCA verdict of vote given as a Claim Assessor.\\n   * @return voteMV verdict of vote given as a Member.\\n   * @return statusnumber Status of claim.\\n   */\\n  function getClaimFromNewStart(\\n    uint _index,\\n    address _add\\n  )\\n  external\\n  view\\n  returns (\\n    uint coverid,\\n    uint claimId,\\n    int8 voteCA,\\n    int8 voteMV,\\n    uint statusnumber\\n  )\\n  {\\n    uint i = pendingClaimStart.add(_index);\\n    coverid = allClaims[i].coverId;\\n    claimId = i;\\n    if (userClaimVoteCA[_add][i] > 0)\\n      voteCA = allvotes[userClaimVoteCA[_add][i]].verdict;\\n    else\\n      voteCA = 0;\\n\\n    if (userClaimVoteMember[_add][i] > 0)\\n      voteMV = allvotes[userClaimVoteMember[_add][i]].verdict;\\n    else\\n      voteMV = 0;\\n\\n    statusnumber = claimsStatus[i];\\n  }\\n\\n  /**\\n   * @dev Gets details of a claim of a user at a given index.\\n   */\\n  function getUserClaimByIndex(\\n    uint _index,\\n    address _add\\n  )\\n  external\\n  view\\n  returns (\\n    uint status,\\n    uint coverid,\\n    uint claimId\\n  )\\n  {\\n    claimId = allClaimsByAddress[_add][_index];\\n    status = claimsStatus[claimId];\\n    coverid = allClaims[claimId].coverId;\\n  }\\n\\n  /**\\n   * @dev Gets Id of all the votes given to a claim.\\n   * @param _claimId Claim Id.\\n   * @return ca id of all the votes given by Claim assessors to a claim.\\n   * @return mv id of all the votes given by members to a claim.\\n   */\\n  function getAllVotesForClaim(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint[] memory ca,\\n    uint[] memory mv\\n  )\\n  {\\n    return (_claimId, claimVoteCA[_claimId], claimVoteMember[_claimId]);\\n  }\\n\\n  /**\\n   * @dev Gets Number of tokens deposit in a vote using\\n   * Claim assessor's address and claim id.\\n   * @return tokens Number of deposited tokens.\\n   */\\n  function getTokensClaim(\\n    address _of,\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint tokens\\n  )\\n  {\\n    return (_claimId, allvotes[userClaimVoteCA[_of][_claimId]].tokens);\\n  }\\n\\n  /**\\n   * @param _voter address of the voter.\\n   * @return lastCAvoteIndex last index till which reward was distributed for CA\\n   * @return lastMVvoteIndex last index till which reward was distributed for member\\n   */\\n  function getRewardDistributedIndex(\\n    address _voter\\n  )\\n  external\\n  view\\n  returns (\\n    uint lastCAvoteIndex,\\n    uint lastMVvoteIndex\\n  )\\n  {\\n    return (\\n    voterVoteRewardReceived[_voter].lastCAvoteIndex,\\n    voterVoteRewardReceived[_voter].lastMVvoteIndex\\n    );\\n  }\\n\\n  /**\\n   * @param claimid claim id.\\n   * @return perc_CA reward Percentage for claim assessor\\n   * @return perc_MV reward Percentage for members\\n   * @return tokens total tokens to be rewarded\\n   */\\n  function getClaimRewardDetail(\\n    uint claimid\\n  )\\n  external\\n  view\\n  returns (\\n    uint percCA,\\n    uint percMV,\\n    uint tokens\\n  )\\n  {\\n    return (\\n    claimRewardDetail[claimid].percCA,\\n    claimRewardDetail[claimid].percMV,\\n    claimRewardDetail[claimid].tokenToBeDist\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets cover id of a claim.\\n   */\\n  function getClaimCoverId(uint _claimId) external view returns (uint claimId, uint coverid) {\\n    return (_claimId, allClaims[_claimId].coverId);\\n  }\\n\\n  /**\\n   * @dev Gets total number of tokens staked during voting by Claim Assessors.\\n   * @param _claimId Claim Id.\\n   * @param _verdict 1 to get total number of accept tokens, -1 to get total number of deny tokens.\\n   * @return token token Number of tokens(either accept or deny on the basis of verdict given as parameter).\\n   */\\n  function getClaimVote(uint _claimId, int8 _verdict) external view returns (uint claimId, uint token) {\\n    claimId = _claimId;\\n    token = 0;\\n    for (uint i = 0; i < claimVoteCA[_claimId].length; i++) {\\n      if (allvotes[claimVoteCA[_claimId][i]].verdict == _verdict)\\n        token = token.add(allvotes[claimVoteCA[_claimId][i]].tokens);\\n    }\\n  }\\n\\n  /**\\n   * @dev Gets total number of tokens staked during voting by Members.\\n   * @param _claimId Claim Id.\\n   * @param _verdict 1 to get total number of accept tokens,\\n   *  -1 to get total number of deny tokens.\\n   * @return token token Number of tokens(either accept or\\n   * deny on the basis of verdict given as parameter).\\n   */\\n  function getClaimMVote(uint _claimId, int8 _verdict) external view returns (uint claimId, uint token) {\\n    claimId = _claimId;\\n    token = 0;\\n    for (uint i = 0; i < claimVoteMember[_claimId].length; i++) {\\n      if (allvotes[claimVoteMember[_claimId][i]].verdict == _verdict)\\n        token = token.add(allvotes[claimVoteMember[_claimId][i]].tokens);\\n    }\\n  }\\n\\n  /**\\n   * @param _voter address  of voteid\\n   * @param index index to get voteid in CA\\n   */\\n  function getVoteAddressCA(address _voter, uint index) external view returns (uint) {\\n    return voteAddressCA[_voter][index];\\n  }\\n\\n  /**\\n   * @param _voter address  of voter\\n   * @param index index to get voteid in member vote\\n   */\\n  function getVoteAddressMember(address _voter, uint index) external view returns (uint) {\\n    return voteAddressMember[_voter][index];\\n  }\\n\\n  /**\\n   * @param _voter address  of voter\\n   */\\n  function getVoteAddressCALength(address _voter) external view returns (uint) {\\n    return voteAddressCA[_voter].length;\\n  }\\n\\n  /**\\n   * @param _voter address  of voter\\n   */\\n  function getVoteAddressMemberLength(address _voter) external view returns (uint) {\\n    return voteAddressMember[_voter].length;\\n  }\\n\\n  /**\\n   * @dev Gets the Final result of voting of a claim.\\n   * @param _claimId Claim id.\\n   * @return verdict 1 if claim is accepted, -1 if declined.\\n   */\\n  function getFinalVerdict(uint _claimId) external view returns (int8 verdict) {\\n    return claimVote[_claimId];\\n  }\\n\\n  /**\\n   * @dev Get number of Claims queued for submission during emergency pause.\\n   */\\n  function getLengthOfClaimSubmittedAtEP() external view returns (uint len) {\\n    len = claimPause.length;\\n  }\\n\\n  /**\\n   * @dev Gets the index from which claim needs to be\\n   * submitted when emergency pause is swithched off.\\n   */\\n  function getFirstClaimIndexToSubmitAfterEP() external view returns (uint indexToSubmit) {\\n    indexToSubmit = claimPauseLastsubmit;\\n  }\\n\\n  /**\\n   * @dev Gets number of Claims to be reopened for voting post emergency pause period.\\n   */\\n  function getLengthOfClaimVotingPause() external view returns (uint len) {\\n    len = claimPauseVotingEP.length;\\n  }\\n\\n  /**\\n   * @dev Gets claim details to be reopened for voting after emergency pause.\\n   */\\n  function getPendingClaimDetailsByIndex(\\n    uint _index\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint pendingTime,\\n    bool voting\\n  )\\n  {\\n    claimId = claimPauseVotingEP[_index].claimid;\\n    pendingTime = claimPauseVotingEP[_index].pendingTime;\\n    voting = claimPauseVotingEP[_index].voting;\\n  }\\n\\n  /**\\n   * @dev Gets the index from which claim needs to be reopened when emergency pause is swithched off.\\n   */\\n  function getFirstClaimIndexToStartVotingAfterEP() external view returns (uint firstindex) {\\n    firstindex = claimStartVotingFirstIndex;\\n  }\\n\\n  /**\\n   * @dev Updates Uint Parameters of a code\\n   * @param code whose details we want to update\\n   * @param val value to set\\n   */\\n  function updateUintParameters(bytes8 code, uint val) public {\\n    require(ms.checkIsAuthToGoverned(msg.sender));\\n    if (code == \\\"CAMAXVT\\\") {\\n      _setMaxVotingTime(val * 1 hours);\\n\\n    } else if (code == \\\"CAMINVT\\\") {\\n\\n      _setMinVotingTime(val * 1 hours);\\n\\n    } else if (code == \\\"CAPRETRY\\\") {\\n\\n      _setPayoutRetryTime(val * 1 hours);\\n\\n    } else if (code == \\\"CADEPT\\\") {\\n\\n      _setClaimDepositTime(val * 1 days);\\n\\n    } else if (code == \\\"CAREWPER\\\") {\\n\\n      _setClaimRewardPerc(val);\\n\\n    } else if (code == \\\"CAMINTH\\\") {\\n\\n      _setMinVoteThreshold(val);\\n\\n    } else if (code == \\\"CAMAXTH\\\") {\\n\\n      _setMaxVoteThreshold(val);\\n\\n    } else if (code == \\\"CACONPER\\\") {\\n\\n      _setMajorityConsensus(val);\\n\\n    } else if (code == \\\"CAPAUSET\\\") {\\n      _setPauseDaysCA(val * 1 days);\\n    } else {\\n\\n      revert(\\\"Invalid param code\\\");\\n    }\\n\\n  }\\n\\n  /**\\n   * @dev Iupgradable Interface to update dependent contract address\\n   */\\n  function changeDependentContractAddress() public onlyInternal {}\\n\\n  /**\\n   * @dev Adds status under which a claim can lie.\\n   * @param percCA reward percentage for claim assessor\\n   * @param percMV reward percentage for members\\n   */\\n  function _pushStatus(uint percCA, uint percMV) internal {\\n    rewardStatus.push(ClaimRewardStatus(percCA, percMV));\\n  }\\n\\n  /**\\n   * @dev adds reward incentive for all possible claim status for Claim assessors and members\\n   */\\n  function _addRewardIncentive() internal {\\n    _pushStatus(0, 0); // 0  Pending-Claim Assessor Vote\\n    _pushStatus(0, 0); // 1 Pending-Claim Assessor Vote Denied, Pending Member Vote\\n    _pushStatus(0, 0); // 2 Pending-CA Vote Threshold not Reached Accept, Pending Member Vote\\n    _pushStatus(0, 0); // 3 Pending-CA Vote Threshold not Reached Deny, Pending Member Vote\\n    _pushStatus(0, 0); // 4 Pending-CA Consensus not reached Accept, Pending Member Vote\\n    _pushStatus(0, 0); // 5 Pending-CA Consensus not reached Deny, Pending Member Vote\\n    _pushStatus(100, 0); // 6 Final-Claim Assessor Vote Denied\\n    _pushStatus(100, 0); // 7 Final-Claim Assessor Vote Accepted\\n    _pushStatus(0, 100); // 8 Final-Claim Assessor Vote Denied, MV Accepted\\n    _pushStatus(0, 100); // 9 Final-Claim Assessor Vote Denied, MV Denied\\n    _pushStatus(0, 0); // 10 Final-Claim Assessor Vote Accept, MV Nodecision\\n    _pushStatus(0, 0); // 11 Final-Claim Assessor Vote Denied, MV Nodecision\\n    _pushStatus(0, 0); // 12 Claim Accepted Payout Pending\\n    _pushStatus(0, 0); // 13 Claim Accepted No Payout\\n    _pushStatus(0, 0); // 14 Claim Accepted Payout Done\\n  }\\n\\n  /**\\n   * @dev Sets Maximum time(in seconds) for which claim assessment voting is open\\n   */\\n  function _setMaxVotingTime(uint _time) internal {\\n    maxVotingTime = _time;\\n  }\\n\\n  /**\\n   *  @dev Sets Minimum time(in seconds) for which claim assessment voting is open\\n   */\\n  function _setMinVotingTime(uint _time) internal {\\n    minVotingTime = _time;\\n  }\\n\\n  /**\\n   *  @dev Sets Minimum vote threshold required\\n   */\\n  function _setMinVoteThreshold(uint val) internal {\\n    minVoteThreshold = val;\\n  }\\n\\n  /**\\n   *  @dev Sets Maximum vote threshold required\\n   */\\n  function _setMaxVoteThreshold(uint val) internal {\\n    maxVoteThreshold = val;\\n  }\\n\\n  /**\\n   *  @dev Sets the value considered as Majority Consenus in voting\\n   */\\n  function _setMajorityConsensus(uint val) internal {\\n    majorityConsensus = val;\\n  }\\n\\n  /**\\n   * @dev Sets the payout retry time\\n   */\\n  function _setPayoutRetryTime(uint _time) internal {\\n    payoutRetryTime = _time;\\n  }\\n\\n  /**\\n   *  @dev Sets percentage of reward given for claim assessment\\n   */\\n  function _setClaimRewardPerc(uint _val) internal {\\n\\n    claimRewardPerc = _val;\\n  }\\n\\n  /**\\n   * @dev Sets the time for which claim is deposited.\\n   */\\n  function _setClaimDepositTime(uint _time) internal {\\n\\n    claimDepositTime = _time;\\n  }\\n\\n  /**\\n   *  @dev Sets number of days claim assessment will be paused\\n   */\\n  function _setPauseDaysCA(uint val) internal {\\n    pauseDaysCA = val;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/token/NXMToken.sol\": {\r\n      \"content\": \"/* Copyright (C) 2020 NexusMutual.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"./external/OZIERC20.sol\\\";\\nimport \\\"./external/OZSafeMath.sol\\\";\\n\\ncontract NXMToken is OZIERC20 {\\n  using OZSafeMath for uint256;\\n\\n  event WhiteListed(address indexed member);\\n\\n  event BlackListed(address indexed member);\\n\\n  mapping(address => uint256) private _balances;\\n\\n  mapping(address => mapping(address => uint256)) private _allowed;\\n\\n  mapping(address => bool) public whiteListed;\\n\\n  mapping(address => uint) public isLockedForMV;\\n\\n  uint256 private _totalSupply;\\n\\n  string public name = \\\"NXM\\\";\\n  string public symbol = \\\"NXM\\\";\\n  uint8 public decimals = 18;\\n  address public operator;\\n\\n  modifier canTransfer(address _to) {\\n    require(whiteListed[_to]);\\n    _;\\n  }\\n\\n  modifier onlyOperator() {\\n    if (operator != address(0))\\n      require(msg.sender == operator);\\n    _;\\n  }\\n\\n  constructor(address _founderAddress, uint _initialSupply) public {\\n    _mint(_founderAddress, _initialSupply);\\n  }\\n\\n  /**\\n  * @dev Total number of tokens in existence\\n  */\\n  function totalSupply() public view returns (uint256) {\\n    return _totalSupply;\\n  }\\n\\n  /**\\n  * @dev Gets the balance of the specified address.\\n  * @param owner The address to query the balance of.\\n  * @return An uint256 representing the amount owned by the passed address.\\n  */\\n  function balanceOf(address owner) public view returns (uint256) {\\n    return _balances[owner];\\n  }\\n\\n  /**\\n  * @dev Function to check the amount of tokens that an owner allowed to a spender.\\n  * @param owner address The address which owns the funds.\\n  * @param spender address The address which will spend the funds.\\n  * @return A uint256 specifying the amount of tokens still available for the spender.\\n  */\\n  function allowance(\\n    address owner,\\n    address spender\\n  )\\n  public\\n  view\\n  returns (uint256)\\n  {\\n    return _allowed[owner][spender];\\n  }\\n\\n  /**\\n  * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\n  * Beware that changing an allowance with this method brings the risk that someone may use both the old\\n  * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\\n  * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\\n  * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n  * @param spender The address which will spend the funds.\\n  * @param value The amount of tokens to be spent.\\n  */\\n  function approve(address spender, uint256 value) public returns (bool) {\\n    require(spender != address(0));\\n\\n    _allowed[msg.sender][spender] = value;\\n    emit Approval(msg.sender, spender, value);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Increase the amount of tokens that an owner allowed to a spender.\\n  * approve should be called when allowed_[_spender] == 0. To increment\\n  * allowed value is better to use this function to avoid 2 calls (and wait until\\n  * the first transaction is mined)\\n  * From MonolithDAO Token.sol\\n  * @param spender The address which will spend the funds.\\n  * @param addedValue The amount of tokens to increase the allowance by.\\n  */\\n  function increaseAllowance(\\n    address spender,\\n    uint256 addedValue\\n  )\\n  public\\n  returns (bool)\\n  {\\n    require(spender != address(0));\\n\\n    _allowed[msg.sender][spender] = (\\n    _allowed[msg.sender][spender].add(addedValue));\\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Decrease the amount of tokens that an owner allowed to a spender.\\n  * approve should be called when allowed_[_spender] == 0. To decrement\\n  * allowed value is better to use this function to avoid 2 calls (and wait until\\n  * the first transaction is mined)\\n  * From MonolithDAO Token.sol\\n  * @param spender The address which will spend the funds.\\n  * @param subtractedValue The amount of tokens to decrease the allowance by.\\n  */\\n  function decreaseAllowance(\\n    address spender,\\n    uint256 subtractedValue\\n  )\\n  public\\n  returns (bool)\\n  {\\n    require(spender != address(0));\\n\\n    _allowed[msg.sender][spender] = (\\n    _allowed[msg.sender][spender].sub(subtractedValue));\\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Adds a user to whitelist\\n  * @param _member address to add to whitelist\\n  */\\n  function addToWhiteList(address _member) public onlyOperator returns (bool) {\\n    whiteListed[_member] = true;\\n    emit WhiteListed(_member);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev removes a user from whitelist\\n  * @param _member address to remove from whitelist\\n  */\\n  function removeFromWhiteList(address _member) public onlyOperator returns (bool) {\\n    whiteListed[_member] = false;\\n    emit BlackListed(_member);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev change operator address\\n  * @param _newOperator address of new operator\\n  */\\n  function changeOperator(address _newOperator) public onlyOperator returns (bool) {\\n    operator = _newOperator;\\n    return true;\\n  }\\n\\n  /**\\n  * @dev burns an amount of the tokens of the message sender\\n  * account.\\n  * @param amount The amount that will be burnt.\\n  */\\n  function burn(uint256 amount) public returns (bool) {\\n    _burn(msg.sender, amount);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Burns a specific amount of tokens from the target address and decrements allowance\\n  * @param from address The address which you want to send tokens from\\n  * @param value uint256 The amount of token to be burned\\n  */\\n  function burnFrom(address from, uint256 value) public returns (bool) {\\n    _burnFrom(from, value);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev function that mints an amount of the token and assigns it to\\n  * an account.\\n  * @param account The account that will receive the created tokens.\\n  * @param amount The amount that will be created.\\n  */\\n  function mint(address account, uint256 amount) public onlyOperator {\\n    _mint(account, amount);\\n  }\\n\\n  /**\\n  * @dev Transfer token for a specified address\\n  * @param to The address to transfer to.\\n  * @param value The amount to be transferred.\\n  */\\n  function transfer(address to, uint256 value) public canTransfer(to) returns (bool) {\\n\\n    require(isLockedForMV[msg.sender] < now); // if not voted under governance\\n    require(value <= _balances[msg.sender]);\\n    _transfer(to, value);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Transfer tokens to the operator from the specified address\\n  * @param from The address to transfer from.\\n  * @param value The amount to be transferred.\\n  */\\n  function operatorTransfer(address from, uint256 value) public onlyOperator returns (bool) {\\n    require(value <= _balances[from]);\\n    _transferFrom(from, operator, value);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Transfer tokens from one address to another\\n  * @param from address The address which you want to send tokens from\\n  * @param to address The address which you want to transfer to\\n  * @param value uint256 the amount of tokens to be transferred\\n  */\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 value\\n  )\\n  public\\n  canTransfer(to)\\n  returns (bool)\\n  {\\n    require(isLockedForMV[from] < now); // if not voted under governance\\n    require(value <= _balances[from]);\\n    require(value <= _allowed[from][msg.sender]);\\n    _transferFrom(from, to, value);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Lock the user's tokens\\n   * @param _of user's address.\\n   */\\n  function lockForMemberVote(address _of, uint _days) public onlyOperator {\\n    if (_days.add(now) > isLockedForMV[_of])\\n      isLockedForMV[_of] = _days.add(now);\\n  }\\n\\n  /**\\n  * @dev Transfer token for a specified address\\n  * @param to The address to transfer to.\\n  * @param value The amount to be transferred.\\n  */\\n  function _transfer(address to, uint256 value) internal {\\n    _balances[msg.sender] = _balances[msg.sender].sub(value);\\n    _balances[to] = _balances[to].add(value);\\n    emit Transfer(msg.sender, to, value);\\n  }\\n\\n  /**\\n  * @dev Transfer tokens from one address to another\\n  * @param from address The address which you want to send tokens from\\n  * @param to address The address which you want to transfer to\\n  * @param value uint256 the amount of tokens to be transferred\\n  */\\n  function _transferFrom(\\n    address from,\\n    address to,\\n    uint256 value\\n  )\\n  internal\\n  {\\n    _balances[from] = _balances[from].sub(value);\\n    _balances[to] = _balances[to].add(value);\\n    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\\n    emit Transfer(from, to, value);\\n  }\\n\\n  /**\\n  * @dev Internal function that mints an amount of the token and assigns it to\\n  * an account. This encapsulates the modification of balances such that the\\n  * proper events are emitted.\\n  * @param account The account that will receive the created tokens.\\n  * @param amount The amount that will be created.\\n  */\\n  function _mint(address account, uint256 amount) internal {\\n    require(account != address(0));\\n    _totalSupply = _totalSupply.add(amount);\\n    _balances[account] = _balances[account].add(amount);\\n    emit Transfer(address(0), account, amount);\\n  }\\n\\n  /**\\n  * @dev Internal function that burns an amount of the token of a given\\n  * account.\\n  * @param account The account whose tokens will be burnt.\\n  * @param amount The amount that will be burnt.\\n  */\\n  function _burn(address account, uint256 amount) internal {\\n    require(amount <= _balances[account]);\\n\\n    _totalSupply = _totalSupply.sub(amount);\\n    _balances[account] = _balances[account].sub(amount);\\n    emit Transfer(account, address(0), amount);\\n  }\\n\\n  /**\\n  * @dev Internal function that burns an amount of the token of a given\\n  * account, deducting from the sender's allowance for said account. Uses the\\n  * internal burn function.\\n  * @param account The account whose tokens will be burnt.\\n  * @param value The amount that will be burnt.\\n  */\\n  function _burnFrom(address account, uint256 value) internal {\\n    require(value <= _allowed[account][msg.sender]);\\n\\n    // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,\\n    // this function needs to emit an event with the updated approval.\\n    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(\\n      value);\\n    _burn(account, value);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/token/external/LockHandler.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @title ERC1132 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/1132\\n */\\n\\ncontract LockHandler {\\n  /**\\n   * @dev Reasons why a user's tokens have been locked\\n   */\\n  mapping(address => bytes32[]) public lockReason;\\n\\n  /**\\n   * @dev locked token structure\\n   */\\n  struct LockToken {\\n    uint256 amount;\\n    uint256 validity;\\n    bool claimed;\\n  }\\n\\n  /**\\n   * @dev Holds number & validity of tokens locked for a given reason for\\n   *      a specified address\\n   */\\n  mapping(address => mapping(bytes32 => LockToken)) public locked;\\n}\\n\"\r\n    },\r\n    \"contracts/abstract/INXMMaster.sol\": {\r\n      \"content\": \"/* Copyright (C) 2020 NexusMutual.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\ncontract INXMMaster {\\n\\n  address public tokenAddress;\\n\\n  address public owner;\\n\\n  uint public pauseTime;\\n\\n  function delegateCallBack(bytes32 myid) external;\\n\\n  function masterInitialized() public view returns (bool);\\n\\n  function isInternal(address _add) public view returns (bool);\\n\\n  function isPause() public view returns (bool check);\\n\\n  function isOwner(address _add) public view returns (bool);\\n\\n  function isMember(address _add) public view returns (bool);\\n\\n  function checkIsAuthToGoverned(address _add) public view returns (bool);\\n\\n  function updatePauseTime(uint _time) public;\\n\\n  function dAppLocker() public view returns (address _add);\\n\\n  function dAppToken() public view returns (address _add);\\n\\n  function getLatestAddress(bytes2 _contractName) public view returns (address payable contractAddress);\\n}\\n\"\r\n    },\r\n    \"contracts/modules/token/external/OZIERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ninterface OZIERC20 {\\n  function transfer(address to, uint256 value) external returns (bool);\\n\\n  function approve(address spender, uint256 value)\\n  external returns (bool);\\n\\n  function transferFrom(address from, address to, uint256 value)\\n  external returns (bool);\\n\\n  function totalSupply() external view returns (uint256);\\n\\n  function balanceOf(address who) external view returns (uint256);\\n\\n  function allowance(address owner, address spender)\\n  external view returns (uint256);\\n\\n  event Transfer(\\n    address indexed from,\\n    address indexed to,\\n    uint256 value\\n  );\\n\\n  event Approval(\\n    address indexed owner,\\n    address indexed spender,\\n    uint256 value\\n  );\\n}\\n\"\r\n    },\r\n    \"contracts/modules/token/external/OZSafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that revert on error\\n */\\nlibrary OZSafeMath {\\n\\n  /**\\n  * @dev Multiplies two numbers, reverts on overflow.\\n  */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b);\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\\n  */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n  */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b <= a);\\n    uint256 c = a - b;\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Adds two numbers, reverts on overflow.\\n  */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a);\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\\n  * reverts when dividing by zero.\\n  */\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0);\\n    return a % b;\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"lockedUnder\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Burned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_reason\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_validity\",\"type\":\"uint256\"}],\"name\":\"Locked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_reason\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Unlocked\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"addToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_reason\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burnLockedTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"changeDependentContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_masterAddress\",\"type\":\"address\"}],\"name\":\"changeMasterAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOperator\",\"type\":\"address\"}],\"name\":\"changeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"claimSubmissionGracePeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"coverInfo\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"claimCount\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"hasOpenClaim\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"hasAcceptedClaim\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"extendClaimAssessmentLock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_reason\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"extendLockOf\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"}],\"name\":\"getLockReasons\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"reasons\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"reason\",\"type\":\"bytes32\"}],\"name\":\"getLockedTokensValidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"validity\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"}],\"name\":\"getUnlockableTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"unlockableTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"increaseClaimAssessmentLock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"lockClaimAssessmentTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_days\",\"type\":\"uint256\"}],\"name\":\"lockForMemberVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_reason\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"lockOf\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lockReason\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"locked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validity\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"claimed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"coverId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isAccepted\",\"type\":\"bool\"}],\"name\":\"markCoverClaimClosed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"coverId\",\"type\":\"uint256\"}],\"name\":\"markCoverClaimOpen\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minCALockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_member\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_reason\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"mintCoverNote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ms\",\"outputs\":[{\"internalType\":\"contract INXMMaster\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nxMasterAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"operatorTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pooledStaking\",\"outputs\":[{\"internalType\":\"contract IPooledStaking\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_reason\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"reduceLock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_reason\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"releaseLockedTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_reason\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"removeEmptyReason\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"removeFromWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_members\",\"type\":\"address[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_reasons\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_indexes\",\"type\":\"uint256[]\"}],\"name\":\"removeMultipleEmptyReasons\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract NXMToken\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_reason\",\"type\":\"bytes32\"}],\"name\":\"tokensLocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_reason\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"tokensLockedAtTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_reason\",\"type\":\"bytes32\"}],\"name\":\"tokensLockedWithValidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validity\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_reason\",\"type\":\"bytes32\"}],\"name\":\"tokensUnlockable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"}],\"name\":\"totalBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"}],\"name\":\"totalLockedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes8\",\"name\":\"code\",\"type\":\"bytes8\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"updateUintParameters\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"}],\"name\":\"withdrawClaimAssessmentTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_coverIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_indexes\",\"type\":\"uint256[]\"}],\"name\":\"withdrawCoverNote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"TokenController","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}