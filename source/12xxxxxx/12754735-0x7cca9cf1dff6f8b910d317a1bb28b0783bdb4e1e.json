{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/ivannikov/work/snake-jungle/3-cosmobosh/cosmobosh/contracts/contracts/CosmoDoodle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\n\\nimport \\\"./utils/Ownable.sol\\\";\\nimport \\\"./CosmoDoodleERC721.sol\\\";\\n\\ninterface IERC20BurnTransfer {\\n    function burn(uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n}\\n\\ninterface ICosmoDoodle {\\n    function isMintedBeforeReveal(uint256 index) external view returns (bool);\\n}\\n\\n\\ncontract OwnableDelegateProxy {}\\ncontract ProxyRegistry {\\n    mapping(address => OwnableDelegateProxy) public proxies;\\n}\\n\\n\\n// https://eips.ethereum.org/EIPS/eip-721 tokenURI\\n/**\\n * @title CosmoDoodle contract\\n * @dev Extends ERC721 Non-Fungible Token Standard basic implementation\\n */\\ncontract CosmoDoodle is Ownable, CosmoDoodleERC721, ICosmoDoodle {\\n    using SafeMath for uint256;\\n\\n    // This is the provenance record of all CosmoDoodle artwork in existence\\n    uint256 public constant COSMO_PRICE = 1_500_000_000_000e18;\\n    uint256 public constant CUP_PRICE = 7_500e18;\\n    uint256 public constant NAME_CHANGE_PRICE = 1_830e18;\\n    \\n    uint256 public constant SECONDS_IN_A_DAY = 86400;\\n    uint256 public constant MAX_SUPPLY = 16410;\\n    string  public constant PROVENANCE = \\\"d13299f09395904e2a53366161121cd8f1250bce078afb73b34d410c8bdabb24\\\";\\n    uint256 public constant SALE_START_TIMESTAMP = 1625324400; // \\\"2021-07-03T15:00:00.000Z\\\"\\n    // Time after which CosmoDoodle are randomized and allotted\\n    uint256 public constant REVEAL_TIMESTAMP = 1626534000; // \\\"2021-07-17T15:00:00.000Z\\\"\\n\\n    uint256 public startingIndexBlock;\\n    uint256 public startingIndex;\\n\\n    // tokens\\n    address public nftPower;\\n    address public constant tokenCosmo = 0x27cd7375478F189bdcF55616b088BE03d9c4339c;\\n    address public constant tokenCup = 0x1faDbb8D7c2D84DAad1c6f52f92480ceF8c96024;\\n\\n    address public proxyRegistryAddress;\\n    string private _contractURI;\\n\\n    // Mapping from token ID to name\\n    mapping(uint256 => string) private _tokenName;\\n    // Mapping if certain name string has already been reserved\\n    mapping(string => bool) private _nameReserved;\\n    // Mapping from token ID to whether the CosmoMask was minted before reveal\\n    mapping(uint256 => bool) private _mintedBeforeReveal;\\n\\n    event NameChange(uint256 indexed tokenId, string newName);\\n    event SetStartingIndexBlock(uint256 startingIndexBlock);\\n    event SetStartingIndex(uint256 startingIndex);\\n\\n\\n    constructor(address _nftPowerAddress, address _proxyRegistryAddress) public CosmoDoodleERC721(\\\"CosmoDoodle\\\", \\\"COSDDL\\\") {\\n        nftPower = _nftPowerAddress;\\n        proxyRegistryAddress = _proxyRegistryAddress;\\n        _setURL(\\\"https://thecosmodoodle.com/\\\");\\n        _setBaseURI(\\\"https://thecosmodoodle.com/metadata/\\\");\\n        _contractURI = \\\"https://thecosmodoodle.com/metadata/contract.json\\\";\\n    }\\n\\n\\n    function contractURI() public view returns (string memory) {\\n        return _contractURI;\\n    }\\n\\n    /**\\n     * @dev Returns name of the CosmoMask at index.\\n     */\\n    function tokenNameByIndex(uint256 index) public view returns (string memory) {\\n        return _tokenName[index];\\n    }\\n\\n    /**\\n     * @dev Returns if the name has been reserved.\\n     */\\n    function isNameReserved(string memory nameString) public view returns (bool) {\\n        return _nameReserved[toLower(nameString)];\\n    }\\n\\n    /**\\n     * @dev Returns if the CosmoMask has been minted before reveal phase\\n     */\\n    function isMintedBeforeReveal(uint256 index) public view override returns (bool) {\\n        return _mintedBeforeReveal[index];\\n    }\\n\\n    /**\\n     * @dev Gets current CosmoMask Price\\n     */\\n    function getPrice() public view returns (uint256) {\\n        require(block.timestamp >= SALE_START_TIMESTAMP, \\\"CosmoDoodle: sale has not started\\\");\\n        require(totalSupply() < MAX_SUPPLY, \\\"CosmoDoodle: sale has already ended\\\");\\n\\n        uint256 currentSupply = totalSupply();\\n\\n        if (currentSupply >= 16409) {\\n            return 3_000_000e18;\\n        } else if (currentSupply >= 16407) {\\n            return 300_000e18;\\n        } else if (currentSupply >= 16400) {\\n            return 30_000e18;\\n        } else if (currentSupply >= 16381) {\\n            return 3_000e18;\\n        } else if (currentSupply >= 16000) {\\n            return 300e18;\\n        } else if (currentSupply >= 15000) {\\n            return 51e18;\\n        } else if (currentSupply >= 11000) {\\n            return 27e18;\\n        } else if (currentSupply >= 7000) {\\n            return 15e18;\\n        } else if (currentSupply >= 3000) {\\n            return 9e18;\\n        } else {\\n            return 3e18;\\n        }\\n    }\\n\\n    /**\\n    * @dev Mints CosmoDoodle\\n    */\\n    function mint(uint256 numberOfMasks) public payable {\\n        require(totalSupply() < MAX_SUPPLY, \\\"CosmoDoodle: sale has already ended\\\");\\n        require(numberOfMasks > 0, \\\"CosmoDoodle: numberOfMasks cannot be 0\\\");\\n        require(numberOfMasks <= 20, \\\"CosmoDoodle: You may not buy more than 20 CosmoDoodle at once\\\");\\n        require(totalSupply().add(numberOfMasks) <= MAX_SUPPLY, \\\"CosmoDoodle: Exceeds MAX_SUPPLY\\\");\\n        require(getPrice().mul(numberOfMasks) == msg.value, \\\"CosmoDoodle: Ether value sent is not correct\\\");\\n\\n        for (uint256 i = 0; i < numberOfMasks; i++) {\\n            uint256 mintIndex = totalSupply();\\n            if (block.timestamp < REVEAL_TIMESTAMP) {\\n                _mintedBeforeReveal[mintIndex] = true;\\n            }\\n            _safeMint(msg.sender, mintIndex);\\n        }\\n\\n        if (startingIndex == 0 && (totalSupply() == MAX_SUPPLY || block.timestamp >= REVEAL_TIMESTAMP)) {\\n            _setStartingIndex();\\n        }\\n    }\\n\\n    function mintByCosmo(uint256 numberOfMasks) public {\\n        require(totalSupply() < MAX_SUPPLY, \\\"CosmoDoodle: sale has already ended\\\");\\n        require(numberOfMasks > 0, \\\"CosmoDoodle: numberOfMasks cannot be 0\\\");\\n        require(numberOfMasks <= 20, \\\"CosmoDoodle: You may not buy more than 20 CosmoDoodle at once\\\");\\n        require(totalSupply().add(numberOfMasks) <= (MAX_SUPPLY - 10), \\\"CosmoDoodle: The last 10 masks can only be purchased for ETH\\\");\\n\\n        uint256 purchaseAmount = COSMO_PRICE.mul(numberOfMasks);\\n        require(\\n            IERC20BurnTransfer(tokenCosmo).transferFrom(msg.sender, address(this), purchaseAmount),\\n            \\\"CosmoDoodle: Transfer COSMO amount exceeds allowance\\\"\\n        );\\n\\n        for (uint256 i = 0; i < numberOfMasks; i++) {\\n            uint256 mintIndex = totalSupply();\\n            if (block.timestamp < REVEAL_TIMESTAMP) {\\n                _mintedBeforeReveal[mintIndex] = true;\\n            }\\n            _safeMint(msg.sender, mintIndex);\\n        }\\n\\n        if (startingIndex == 0 && (totalSupply() == MAX_SUPPLY || block.timestamp >= REVEAL_TIMESTAMP)) {\\n            _setStartingIndex();\\n        }\\n\\n        IERC20BurnTransfer(tokenCosmo).burn(purchaseAmount);\\n    }\\n\\n    function mintByCup(uint256 numberOfMasks) public {\\n        require(totalSupply() < MAX_SUPPLY, \\\"CosmoDoodle: sale has already ended\\\");\\n        require(numberOfMasks > 0, \\\"CosmoDoodle: numberOfMasks cannot be 0\\\");\\n        require(numberOfMasks <= 20, \\\"CosmoDoodle: You may not buy more than 20 CosmoDoodle at once\\\");\\n        require(totalSupply().add(numberOfMasks) <= (MAX_SUPPLY - 10), \\\"CosmoDoodle: The last 10 masks can only be purchased for ETH\\\");\\n\\n        uint256 purchaseAmount = CUP_PRICE.mul(numberOfMasks);\\n        require(\\n            IERC20BurnTransfer(tokenCup).transferFrom(msg.sender, address(this), purchaseAmount),\\n            \\\"CosmoDoodle: Transfer CUP amount exceeds allowance\\\"\\n        );\\n\\n        for (uint256 i = 0; i < numberOfMasks; i++) {\\n            uint256 mintIndex = totalSupply();\\n            if (block.timestamp < REVEAL_TIMESTAMP) {\\n                _mintedBeforeReveal[mintIndex] = true;\\n            }\\n            _safeMint(msg.sender, mintIndex);\\n        }\\n\\n        if (startingIndex == 0 && (totalSupply() == MAX_SUPPLY || block.timestamp >= REVEAL_TIMESTAMP)) {\\n            _setStartingIndex();\\n        }\\n\\n        IERC20BurnTransfer(tokenCup).burn(purchaseAmount);\\n    }\\n\\n    function isApprovedForAll(address owner, address operator) public view override returns (bool) {\\n        // Whitelist OpenSea proxy contract for easy trading.\\n        ProxyRegistry proxyRegistry = ProxyRegistry(proxyRegistryAddress);\\n        if (address(proxyRegistry.proxies(owner)) == operator) {\\n            return true;\\n        }\\n        return super.isApprovedForAll(owner, operator);\\n    }\\n\\n    /**\\n     * @dev Finalize starting index\\n     */\\n    function finalizeStartingIndex() public {\\n        require(startingIndex == 0, \\\"CosmoDoodle: starting index is already set\\\");\\n        require(block.timestamp >= REVEAL_TIMESTAMP, \\\"CosmoDoodle: Too early\\\");\\n        _setStartingIndex();\\n    }\\n\\n    function _setStartingIndex() internal {\\n        startingIndexBlock = block.number - 1;\\n        emit SetStartingIndexBlock(startingIndexBlock);\\n\\n        startingIndex = uint256(blockhash(startingIndexBlock)) % 16400;\\n        // Prevent default sequence\\n        if (startingIndex == 0) {\\n            startingIndex = startingIndex.add(1);\\n        }\\n        emit SetStartingIndex(startingIndex);\\n    }\\n\\n    /**\\n     * @dev Changes the name for CosmoMask tokenId\\n     */\\n    function changeName(uint256 tokenId, string memory newName) public {\\n        address owner = ownerOf(tokenId);\\n        require(_msgSender() == owner, \\\"CosmoDoodle: caller is not the token owner\\\");\\n        require(validateName(newName) == true, \\\"CosmoDoodle: not a valid new name\\\");\\n        require(sha256(bytes(newName)) != sha256(bytes(_tokenName[tokenId])), \\\"CosmoDoodle: new name is same as the current one\\\");\\n        require(isNameReserved(newName) == false, \\\"CosmoDoodle: name already reserved\\\");\\n\\n        IERC20BurnTransfer(nftPower).transferFrom(msg.sender, address(this), NAME_CHANGE_PRICE);\\n\\n        // If already named, dereserve old name\\n        if (bytes(_tokenName[tokenId]).length > 0) {\\n            toggleReserveName(_tokenName[tokenId], false);\\n        }\\n        toggleReserveName(newName, true);\\n        _tokenName[tokenId] = newName;\\n        IERC20BurnTransfer(nftPower).burn(NAME_CHANGE_PRICE);\\n        emit NameChange(tokenId, newName);\\n    }\\n\\n    /**\\n     * @dev Withdraw ether from this contract (Callable by owner)\\n     */\\n    function withdraw() public onlyOwner {\\n        uint256 balance = address(this).balance;\\n        msg.sender.transfer(balance);\\n    }\\n\\n    /**\\n     * @dev Reserves the name if isReserve is set to true, de-reserves if set to false\\n     */\\n    function toggleReserveName(string memory str, bool isReserve) internal {\\n        _nameReserved[toLower(str)] = isReserve;\\n    }\\n\\n    /**\\n     * @dev Check if the name string is valid (Alphanumeric and spaces without leading or trailing space)\\n     */\\n    function validateName(string memory str) public pure returns (bool) {\\n        bytes memory b = bytes(str);\\n        if (b.length < 1)\\n            return false;\\n        // Cannot be longer than 25 characters\\n        if (b.length > 25)\\n            return false;\\n        // Leading space\\n        if (b[0] == 0x20)\\n            return false;\\n        // Trailing space\\n        if (b[b.length - 1] == 0x20)\\n            return false;\\n\\n        bytes1 lastChar = b[0];\\n\\n        for (uint256 i; i < b.length; i++) {\\n            bytes1 char = b[i];\\n            // Cannot contain continous spaces\\n            if (char == 0x20 && lastChar == 0x20)\\n                return false;\\n            if (\\n                !(char >= 0x30 && char <= 0x39) && //9-0\\n                !(char >= 0x41 && char <= 0x5A) && //A-Z\\n                !(char >= 0x61 && char <= 0x7A) && //a-z\\n                !(char == 0x20) //space\\n            )\\n                return false;\\n            lastChar = char;\\n        }\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Converts the string to lowercase\\n     */\\n    function toLower(string memory str) public pure returns (string memory) {\\n        bytes memory bStr = bytes(str);\\n        bytes memory bLower = new bytes(bStr.length);\\n        for (uint256 i = 0; i < bStr.length; i++) {\\n            // Uppercase character\\n            if ((uint8(bStr[i]) >= 65) && (uint8(bStr[i]) <= 90))\\n                bLower[i] = bytes1(uint8(bStr[i]) + 32);\\n            else\\n                bLower[i] = bStr[i];\\n        }\\n        return string(bLower);\\n    }\\n\\n    function setBaseURI(string memory baseURI_) public onlyOwner {\\n        _setBaseURI(baseURI_);\\n    }\\n\\n    function setContractURI(string memory contractURI_) public onlyOwner {\\n        _contractURI = contractURI_;\\n    }\\n\\n    function setURL(string memory newUrl) public onlyOwner {\\n        _setURL(newUrl);\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/ivannikov/work/snake-jungle/3-cosmobosh/cosmobosh/contracts/contracts/CosmoDoodleERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./libraries/SafeMath.sol\\\";\\nimport \\\"./libraries/Address.sol\\\";\\nimport \\\"./libraries/EnumerableSet.sol\\\";\\nimport \\\"./libraries/EnumerableMap.sol\\\";\\nimport \\\"./libraries/Strings.sol\\\";\\nimport \\\"./utils/Context.sol\\\";\\n\\ninterface ICosmoDoodleERC721 {\\n    // IERC165\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n    // IERC721Enumerable\\n    function totalSupply() external view returns (uint256);\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n    // IERC721Metadata\\n    function name() external view returns (string memory _name);\\n    function symbol() external view returns (string memory _symbol);\\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\\n    // ERC721\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n    function approve(address to, uint256 tokenId) external;\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n    function setApprovalForAll(address operator, bool _approved) external;\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n}\\n\\ninterface IERC721Receiver {\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\\n}\\n\\n\\n/**\\n * @title ERC721 Non-Fungible Token Standard basic implementation\\n * @dev see https://eips.ethereum.org/EIPS/eip-721\\n */\\nabstract contract CosmoDoodleERC721 is Context, ICosmoDoodleERC721 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n    using EnumerableSet for EnumerableSet.UintSet;\\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\\n    using Strings for uint256;\\n\\n    // ERC165\\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\\n    mapping(bytes4 => bool) private _supportedInterfaces;\\n\\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA_SHORT = 0x93254542;\\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\\n\\n    mapping(address => EnumerableSet.UintSet) private _holderTokens;\\n    EnumerableMap.UintToAddressMap private _tokenOwners;\\n    mapping(uint256 => address) private _tokenApprovals;\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    string private _name;\\n    string private _symbol;\\n    string private _baseURI;\\n    string private _url;\\n\\n\\n    constructor(string memory name_, string memory symbol_) internal {\\n        _name = name_;\\n        _symbol = symbol_;\\n\\n        _registerInterface(_INTERFACE_ID_ERC165);\\n        _registerInterface(_INTERFACE_ID_ERC721);\\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA_SHORT);\\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\\n    }\\n\\n    function balanceOf(address owner) public view override returns (uint256) {\\n        require(owner != address(0), \\\"CosmoDoodle: balance query for the zero address\\\");\\n        return _holderTokens[owner].length();\\n    }\\n\\n    function ownerOf(uint256 tokenId) public view override returns (address) {\\n        return _tokenOwners.get(tokenId, \\\"CosmoDoodle: owner query for nonexistent token\\\");\\n    }\\n\\n    function name() public view override returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\\n        require(_exists(tokenId), \\\"CosmoDoodle: URI query for nonexistent token\\\");\\n        string memory base = baseURI();\\n        return string(abi.encodePacked(base, tokenId.toString(), \\\".json\\\"));\\n    }\\n\\n    function baseURI() public view returns (string memory) {\\n        return _baseURI;\\n    }\\n\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view override returns (uint256) {\\n        return _holderTokens[owner].at(index);\\n    }\\n\\n    function totalSupply() public view override returns (uint256) {\\n        return _tokenOwners.length();\\n    }\\n\\n    function tokenByIndex(uint256 index) public view override returns (uint256) {\\n        (uint256 tokenId, ) = _tokenOwners.at(index);\\n        return tokenId;\\n    }\\n\\n    function approve(address to, uint256 tokenId) public override {\\n        address owner = ownerOf(tokenId);\\n        require(to != owner, \\\"CosmoDoodle: approval to current owner\\\");\\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"CosmoDoodle: approve caller is not owner nor approved for all\\\"\\n        );\\n        _approve(to, tokenId);\\n    }\\n\\n    function getApproved(uint256 tokenId) public view override returns (address) {\\n        require(_exists(tokenId), \\\"CosmoDoodle: approved query for nonexistent token\\\");\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public override {\\n        require(operator != _msgSender(), \\\"CosmoDoodle: approve to caller\\\");\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    function transferFrom(address from, address to, uint256 tokenId) public override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"CosmoDoodle: transfer caller is not owner nor approved\\\");\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"CosmoDoodle: transfer caller is not owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"CosmoDoodle: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    function _exists(uint256 tokenId) internal view returns (bool) {\\n        return _tokenOwners.contains(tokenId);\\n    }\\n\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\\n        require(_exists(tokenId), \\\"CosmoDoodle: operator query for nonexistent token\\\");\\n        address owner = ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\n    }\\n\\n    function _safeMint(address to, uint256 tokenId) internal {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal {\\n        _mint(to, tokenId);\\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \\\"CosmoDoodle: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    function _mint(address to, uint256 tokenId) internal {\\n        require(to != address(0), \\\"CosmoDoodle: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"CosmoDoodle: token already minted\\\");\\n        _holderTokens[to].add(tokenId);\\n        _tokenOwners.set(tokenId, to);\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    function _burn(uint256 tokenId) internal {\\n        address owner = ownerOf(tokenId);\\n        _approve(address(0), tokenId);\\n        _holderTokens[owner].remove(tokenId);\\n        _tokenOwners.remove(tokenId);\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    function _transfer(address from, address to, uint256 tokenId) internal {\\n        require(ownerOf(tokenId) == from, \\\"CosmoDoodle: transfer of token that is not own\\\");\\n        require(to != address(0), \\\"CosmoDoodle: transfer to the zero address\\\");\\n        _approve(address(0), tokenId);\\n        _holderTokens[from].remove(tokenId);\\n        _holderTokens[to].add(tokenId);\\n        _tokenOwners.set(tokenId, to);\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    function _setBaseURI(string memory baseURI_) internal {\\n        _baseURI = baseURI_;\\n    }\\n\\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data) private returns (bool) {\\n        if (!to.isContract()) {\\n            return true;\\n        }\\n        bytes memory returndata = to.functionCall(abi.encodeWithSelector(\\n            IERC721Receiver(to).onERC721Received.selector,\\n            _msgSender(),\\n            from,\\n            tokenId,\\n            _data\\n        ), \\\"CosmoDoodle: transfer to non ERC721Receiver implementer\\\");\\n        bytes4 retval = abi.decode(returndata, (bytes4));\\n        return (retval == _ERC721_RECEIVED);\\n    }\\n\\n    function _approve(address to, uint256 tokenId) private {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    function _setURL(string memory newUrl) internal {\\n        _url = newUrl;\\n    }\\n\\n    // ERC165\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return _supportedInterfaces[interfaceId];\\n    }\\n\\n    function _registerInterface(bytes4 interfaceId) internal virtual {\\n        require(interfaceId != 0xffffffff, \\\"CosmoDoodle: invalid interface id\\\");\\n        _supportedInterfaces[interfaceId] = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/ivannikov/work/snake-jungle/3-cosmobosh/cosmobosh/contracts/contracts/libraries/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    function functionCall(address target, bytes memory data, string memory errorMessage ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            if (returndata.length > 0) {\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/ivannikov/work/snake-jungle/3-cosmobosh/cosmobosh/contracts/contracts/libraries/EnumerableMap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Library for managing an enumerable variant of Solidity's\\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\\n * type.\\n */\\nlibrary EnumerableMap {\\n    struct MapEntry {\\n        bytes32 _key;\\n        bytes32 _value;\\n    }\\n\\n    struct Map {\\n        MapEntry[] _entries;\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    function _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {\\n        uint256 keyIndex = map._indexes[key];\\n        if (keyIndex == 0) {\\n            map._entries.push(MapEntry({_key: key, _value: value}));\\n            map._indexes[key] = map._entries.length;\\n            return true;\\n        } else {\\n            map._entries[keyIndex - 1]._value = value;\\n            return false;\\n        }\\n    }\\n\\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\\n        uint256 keyIndex = map._indexes[key];\\n        if (keyIndex != 0) {\\n            uint256 toDeleteIndex = keyIndex - 1;\\n            uint256 lastIndex = map._entries.length - 1;\\n            MapEntry storage lastEntry = map._entries[lastIndex];\\n            map._entries[toDeleteIndex] = lastEntry;\\n            map._indexes[lastEntry._key] = toDeleteIndex + 1;\\n            map._entries.pop();\\n            delete map._indexes[key];\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\\n        return map._indexes[key] != 0;\\n    }\\n\\n    function _length(Map storage map) private view returns (uint256) {\\n        return map._entries.length;\\n    }\\n\\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\\n        require(map._entries.length > index, \\\"EnumerableMap: index out of bounds\\\");\\n        MapEntry storage entry = map._entries[index];\\n        return (entry._key, entry._value);\\n    }\\n\\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\\n        uint256 keyIndex = map._indexes[key];\\n        if (keyIndex == 0) return (false, 0);\\n        return (true, map._entries[keyIndex - 1]._value);\\n    }\\n\\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\\n        uint256 keyIndex = map._indexes[key];\\n        require(keyIndex != 0, \\\"EnumerableMap: nonexistent key\\\");\\n        return map._entries[keyIndex - 1]._value;\\n    }\\n\\n    function _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {\\n        uint256 keyIndex = map._indexes[key];\\n        require(keyIndex != 0, errorMessage);\\n        return map._entries[keyIndex - 1]._value;\\n    }\\n\\n    // UintToAddressMap\\n    struct UintToAddressMap {\\n        Map _inner;\\n    }\\n\\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\\n    }\\n\\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\\n        return _remove(map._inner, bytes32(key));\\n    }\\n\\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\\n        return _contains(map._inner, bytes32(key));\\n    }\\n\\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\\n        return _length(map._inner);\\n    }\\n\\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\\n        return (uint256(key), address(uint160(uint256(value))));\\n    }\\n\\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\\n        return (success, address(uint160(uint256(value))));\\n    }\\n\\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\\n    }\\n\\n    function get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {\\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/ivannikov/work/snake-jungle/3-cosmobosh/cosmobosh/contracts/contracts/libraries/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n */\\nlibrary EnumerableSet {\\n    struct Set {\\n        bytes32[] _values;\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        uint256 valueIndex = set._indexes[value];\\n        if (valueIndex != 0) {\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n            bytes32 lastvalue = set._values[lastIndex];\\n            set._values[toDeleteIndex] = lastvalue;\\n            set._indexes[lastvalue] = toDeleteIndex + 1;\\n            set._values.pop();\\n            delete set._indexes[value];\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // UintSet\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/ivannikov/work/snake-jungle/3-cosmobosh/cosmobosh/contracts/contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n */\\nlibrary SafeMath {\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/ivannikov/work/snake-jungle/3-cosmobosh/cosmobosh/contracts/contracts/libraries/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        uint256 index = digits - 1;\\n        temp = value;\\n        while (temp != 0) {\\n            buffer[index--] = bytes1(uint8(48 + (temp % 10)));\\n            temp /= 10;\\n        }\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/ivannikov/work/snake-jungle/3-cosmobosh/cosmobosh/contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view returns (address payable) {\\n        return msg.sender;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/ivannikov/work/snake-jungle/3-cosmobosh/cosmobosh/contracts/contracts/utils/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    constructor() internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nftPowerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_proxyRegistryAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newName\",\"type\":\"string\"}],\"name\":\"NameChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startingIndex\",\"type\":\"uint256\"}],\"name\":\"SetStartingIndex\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startingIndexBlock\",\"type\":\"uint256\"}],\"name\":\"SetStartingIndexBlock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"COSMO_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CUP_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NAME_CHANGE_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PROVENANCE\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REVEAL_TIMESTAMP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SALE_START_TIMESTAMP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SECONDS_IN_A_DAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"newName\",\"type\":\"string\"}],\"name\":\"changeName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalizeStartingIndex\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"isMintedBeforeReveal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"nameString\",\"type\":\"string\"}],\"name\":\"isNameReserved\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numberOfMasks\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numberOfMasks\",\"type\":\"uint256\"}],\"name\":\"mintByCosmo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numberOfMasks\",\"type\":\"uint256\"}],\"name\":\"mintByCup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftPower\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxyRegistryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"baseURI_\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"contractURI_\",\"type\":\"string\"}],\"name\":\"setContractURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newUrl\",\"type\":\"string\"}],\"name\":\"setURL\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startingIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startingIndexBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"str\",\"type\":\"string\"}],\"name\":\"toLower\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenCosmo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenCup\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenNameByIndex\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"str\",\"type\":\"string\"}],\"name\":\"validateName\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CosmoDoodle","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"000000000000000000000000c8a790116e6caa0ac18ca9c81ad541c116db4d9e000000000000000000000000a5409ec958c83c3f309868babaca7c86dcb077c1","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}