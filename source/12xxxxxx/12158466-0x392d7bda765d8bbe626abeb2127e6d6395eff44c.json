{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.17;\r\n\r\n\r\n/**\r\n\r\nBuy The Floor \r\n\r\nDemand-side NFT exchange that allows buyers to make offchain blanket bids for NFTs based on type.  \r\n\r\n*/\r\n\r\n \r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n \r\n \r\n interface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard\r\n       /// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n       ///  Note: the ERC-165 identifier for this interface is 0x80ac58cd\r\n       interface ERC721 /* is ERC165 */ {\r\n           /// @dev This emits when ownership of any NFT changes by any mechanism.\r\n           ///  This event emits when NFTs are created (`from` == 0) and destroyed\r\n           ///  (`to` == 0). Exception: during contract creation, any number of NFTs\r\n           ///  may be created and assigned without emitting Transfer. At the time of\r\n           ///  any transfer, the approved address for that NFT (if any) is reset to none.\r\n           event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n\r\n           /// @dev This emits when the approved address for an NFT is changed or\r\n           ///  reaffirmed. The zero address indicates there is no approved address.\r\n           ///  When a Transfer event emits, this also indicates that the approved\r\n           ///  address for that NFT (if any) is reset to none.\r\n           event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n\r\n           /// @dev This emits when an operator is enabled or disabled for an owner.\r\n           ///  The operator can manage all NFTs of the owner.\r\n           event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n           /// @notice Count all NFTs assigned to an owner\r\n           /// @dev NFTs assigned to the zero address are considered invalid, and this\r\n           ///  function throws for queries about the zero address.\r\n           /// @param _owner An address for whom to query the balance\r\n           /// @return The number of NFTs owned by `_owner`, possibly zero\r\n           function balanceOf(address _owner) external view returns (uint256);\r\n\r\n           /// @notice Find the owner of an NFT\r\n           /// @dev NFTs assigned to zero address are considered invalid, and queries\r\n           ///  about them do throw.\r\n           /// @param _tokenId The identifier for an NFT\r\n           /// @return The address of the owner of the NFT\r\n           function ownerOf(uint256 _tokenId) external view returns (address);\r\n\r\n           /// @notice Transfers the ownership of an NFT from one address to another address\r\n           /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n           ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n           ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n           ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n           ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n           ///  `onERC721Received` on `_to` and throws if the return value is not\r\n           ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n           /// @param _from The current owner of the NFT\r\n           /// @param _to The new owner\r\n           /// @param _tokenId The NFT to transfer\r\n           /// @param data Additional data with no specified format, sent in call to `_to`\r\n           function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable;\r\n\r\n           /// @notice Transfers the ownership of an NFT from one address to another address\r\n           /// @dev This works identically to the other function with an extra data parameter,\r\n           ///  except this function just sets data to \"\"\r\n           /// @param _from The current owner of the NFT\r\n           /// @param _to The new owner\r\n           /// @param _tokenId The NFT to transfer\r\n           function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n           /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n           ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n           ///  THEY MAY BE PERMANENTLY LOST\r\n           /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n           ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n           ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n           ///  `_tokenId` is not a valid NFT.\r\n           /// @param _from The current owner of the NFT\r\n           /// @param _to The new owner\r\n           /// @param _tokenId The NFT to transfer\r\n           function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n           /// @notice Set or reaffirm the approved address for an NFT\r\n           /// @dev The zero address indicates there is no approved address.\r\n           /// @dev Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n           ///  operator of the current owner.\r\n           /// @param _approved The new approved NFT controller\r\n           /// @param _tokenId The NFT to approve\r\n           function approve(address _approved, uint256 _tokenId) external payable;\r\n\r\n           /// @notice Enable or disable approval for a third party (\"operator\") to manage\r\n           ///  all of `msg.sender`'s assets.\r\n           /// @dev Emits the ApprovalForAll event. The contract MUST allow\r\n           ///  multiple operators per owner.\r\n           /// @param _operator Address to add to the set of authorized operators.\r\n           /// @param _approved True if the operator is approved, false to revoke approval\r\n           function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n           /// @notice Get the approved address for a single NFT\r\n           /// @dev Throws if `_tokenId` is not a valid NFT\r\n           /// @param _tokenId The NFT to find the approved address for\r\n           /// @return The approved address for this NFT, or the zero address if there is none\r\n           function getApproved(uint256 _tokenId) external view returns (address);\r\n\r\n           /// @notice Query if an address is an authorized operator for another address\r\n           /// @param _owner The address that owns the NFTs\r\n           /// @param _operator The address that acts on behalf of the owner\r\n           /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n           function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n       }\r\n\r\n       interface ERC165 {\r\n           /// @notice Query if a contract implements an interface\r\n           /// @param interfaceID The interface identifier, as specified in ERC-165\r\n           /// @dev Interface identification is specified in ERC-165. This function\r\n           ///  uses less than 30,000 gas.\r\n           /// @return `true` if the contract implements `interfaceID` and\r\n           ///  `interfaceID` is not 0xffffffff, `false` otherwise\r\n           function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n       }\r\n\r\n       interface ERC721TokenReceiver {\r\n           /// @notice Handle the receipt of an NFT\r\n           /// @dev The ERC721 smart contract calls this function on the\r\n           /// recipient after a `transfer`. This function MAY throw to revert and reject the transfer. Return\r\n           /// of other than the magic value MUST result in the transaction being reverted.\r\n           /// @notice The contract address is always the message sender.\r\n           /// @param _operator The address which called `safeTransferFrom` function\r\n           /// @param _from The address which previously owned the token\r\n           /// @param _tokenId The NFT identifier which is being transferred\r\n           /// @param _data Additional data with no specified format\r\n           /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n           /// unless throwing\r\n           function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\r\n        }\r\n        \r\n        interface ProjectBasedNFT {\r\n            function tokenIdToProjectId(uint256 tokenId) external returns(uint256);\r\n        }\r\n\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n\r\n// Owned contract\r\n\r\n// ----------------------------------------------------------------------------\r\n\r\ncontract Owned {\r\n\r\n    address public owner;\r\n\r\n    address public newOwner;\r\n\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n\r\n    constructor() public {\r\n\r\n        owner = msg.sender;\r\n\r\n    }\r\n\r\n\r\n    modifier onlyOwner {\r\n\r\n        require(msg.sender == owner);\r\n\r\n        _;\r\n\r\n    }\r\n\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n\r\n        newOwner = _newOwner;\r\n\r\n    }\r\n\r\n    function acceptOwnership() public {\r\n\r\n        require(msg.sender == newOwner);\r\n\r\n        emit OwnershipTransferred(owner, newOwner);\r\n\r\n        owner = newOwner;\r\n\r\n        newOwner = address(0);\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\ncontract ECRecovery {\r\n\r\n  /**\r\n   * @dev Recover signer address from a message by using their signature\r\n   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n   * @param sig bytes signature, the signature is generated using web3.eth.sign()\r\n   */\r\n  function recover(bytes32 hash, bytes memory sig) internal  pure returns (address) {\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n\r\n    //Check the signature length\r\n    if (sig.length != 65) {\r\n      return (address(0));\r\n    }\r\n\r\n    // Divide the signature in r, s and v variables\r\n    assembly {\r\n      r := mload(add(sig, 32))\r\n      s := mload(add(sig, 64))\r\n      v := byte(0, mload(add(sig, 96)))\r\n    }\r\n\r\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n    if (v < 27) {\r\n      v += 27;\r\n    }\r\n\r\n    // If the version is correct return the signer address\r\n    if (v != 27 && v != 28) {\r\n      return (address(0));\r\n    } else {\r\n      return ecrecover(hash, v, r, s);\r\n    }\r\n  }\r\n\r\n}\r\n\r\n\r\n/*\r\nERC20 tokens must be approved to this contract ! \r\nThen, the buyer will perform an offchain metatx personalsign for their bid \r\n\r\nNFT must also be approved to this contract - setApprovalForAll\r\n*/\r\n\r\ncontract BuyTheFloorExchange is Owned, ECRecovery  {\r\n\r\n  using SafeMath for uint;\r\n\r\n    \r\n  mapping (bytes32 => uint) public burnedSignatures; \r\n    \r\n  uint256 public _fee_pct;\r\n  uint256 public _chain_id;\r\n \r\n  constructor( uint chainId, uint fee_pct) public { \r\n    require(fee_pct >= 0 && fee_pct <100);\r\n\r\n    _fee_pct = fee_pct;\r\n    _chain_id = chainId;\r\n  }\r\n\r\n\r\n  //Do not allow ETH to enter\r\n   function() external payable {\r\n    revert();\r\n  }\r\n  \r\n  event BuyTheFloor(address indexed bidderAddress, address indexed sellerAddress, address indexed nftContractAddress, uint256 tokenId, address currencyTokenAddress, uint currencyTokenAmount);\r\n  event SignatureBurned(address indexed bidderAddress, bytes32 hash);\r\n  \r\n  struct BidPacket {\r\n    address bidderAddress;\r\n    address nftContractAddress;\r\n    address currencyTokenAddress;\r\n    uint256 currencyTokenAmount;\r\n    bool requireProjectId;\r\n    uint256 projectId;\r\n    uint256 expires;\r\n  }\r\n  \r\n  \r\n     bytes32 constant EIP712DOMAIN_TYPEHASH = keccak256(\r\n          \"EIP712Domain(string contractName,string version,uint256 chainId,address verifyingContract)\"\r\n      );\r\n\r\n   function getBidDomainTypehash() public pure returns (bytes32) {\r\n      return EIP712DOMAIN_TYPEHASH;\r\n   }\r\n\r\n   function getEIP712DomainHash(string memory contractName, string memory version, uint256 chainId, address verifyingContract) public pure returns (bytes32) {\r\n\r\n      return keccak256(abi.encode(\r\n            EIP712DOMAIN_TYPEHASH,\r\n            keccak256(bytes(contractName)),\r\n            keccak256(bytes(version)),\r\n            chainId,\r\n            verifyingContract\r\n        ));\r\n    }\r\n\r\n\r\n  bytes32 constant BIDPACKET_TYPEHASH = keccak256(\r\n      \"BidPacket(address bidderAddress,address nftContractAddress,address currencyTokenAddress,uint256 currencyTokenAmount,bool requireProjectId,uint256 projectId,uint256 expires)\"\r\n  );\r\n\r\n\r\n\r\n    function getBidPacketTypehash()  public pure returns (bytes32) {\r\n      return BIDPACKET_TYPEHASH;\r\n  }\r\n  \r\n  function getBidPacketHash(address bidderAddress,address nftContractAddress,address currencyTokenAddress, uint256 currencyTokenAmount,bool requireProjectId,uint256 projectId,uint256 expires) public pure returns (bytes32) {\r\n          return keccak256(abi.encode(\r\n              BIDPACKET_TYPEHASH,\r\n              bidderAddress,\r\n              nftContractAddress,\r\n              currencyTokenAddress,\r\n              currencyTokenAmount,\r\n              requireProjectId,\r\n              projectId,\r\n              expires\r\n          ));\r\n      }\r\n\r\n  function getBidTypedDataHash(address bidderAddress,address nftContractAddress,address currencyTokenAddress, uint256 currencyTokenAmount,bool requireProjectId,uint256 projectId,uint256 expires) public view returns (bytes32) {\r\n\r\n\r\n              \r\n              bytes32 digest = keccak256(abi.encodePacked(\r\n                  \"\\x19\\x01\",\r\n                  getEIP712DomainHash('BuyTheFloor','2',_chain_id,address(this)),\r\n                  getBidPacketHash(bidderAddress,nftContractAddress,currencyTokenAddress,currencyTokenAmount,requireProjectId,projectId,expires)\r\n              ));\r\n              return digest;\r\n          }\r\n  \r\n\r\n  //require pre-approval from the buyer in the form of a personal sign \r\n  function sellNFT(address nftContractAddress, uint256 tokenId, address from, address to, address currencyToken, uint256 currencyAmount, bool requireProjectId,uint256 projectId, uint256 expires, bytes memory buyerSignature) public returns (bool){\r\n      \r\n      //require personalsign from buyer to be submitted by seller  \r\n      bytes32 sigHash = getBidTypedDataHash(to,nftContractAddress,currencyToken,currencyAmount,requireProjectId,projectId,expires);\r\n\r\n      address recoveredSignatureSigner = recover(sigHash,buyerSignature);\r\n\r\n\r\n      //make sure the signer is the depositor of the tokens\r\n      require(to == recoveredSignatureSigner, 'Invalid signature');\r\n      require(from == msg.sender, 'Not NFT Owner');\r\n      \r\n      \r\n      require(block.number < expires || expires == 0, 'bid expired');\r\n     \r\n      require(burnedSignatures[sigHash] == 0, 'signature already used');\r\n      burnedSignatures[sigHash] = 0x1;\r\n      \r\n      if(requireProjectId){\r\n          require(ProjectBasedNFT(nftContractAddress).tokenIdToProjectId(tokenId) == projectId , 'Incorrect Project Id');\r\n      }\r\n      \r\n      \r\n      ERC721(nftContractAddress).safeTransferFrom(from, to, tokenId);\r\n      \r\n      _transferCurrencyForSale(from,to,currencyToken,currencyAmount);\r\n      \r\n      \r\n      emit BuyTheFloor(to, from, nftContractAddress, tokenId, currencyToken, currencyAmount);\r\n      emit SignatureBurned(to, sigHash);\r\n\r\n      return true;\r\n  }\r\n  \r\n  function _transferCurrencyForSale(address from, address to, address currencyToken, uint256 currencyAmount) internal returns (bool){\r\n    uint256 feeAmount = currencyAmount.mul(_fee_pct).div(100);\r\n\r\n    require( IERC20(currencyToken).transferFrom(to, from, currencyAmount.sub(feeAmount) ), 'unable to pay' );\r\n    require( IERC20(currencyToken).transferFrom(to, owner, feeAmount ), 'unable to pay'  );\r\n    \r\n    return true;\r\n  }\r\n  \r\n   \r\n  function cancelBid(address nftContractAddress, address to, address currencyToken, uint256 currencyAmount,  bool requireProjectId, uint256 projectId, uint256 expires, bytes memory buyerSignature ) public returns (bool){\r\n      bytes32 sigHash = getBidTypedDataHash(to,nftContractAddress,currencyToken,currencyAmount,requireProjectId,projectId,expires);\r\n      address recoveredSignatureSigner = recover(sigHash,buyerSignature);\r\n      \r\n      require(to == recoveredSignatureSigner, 'Invalid signature');\r\n      require(msg.sender == recoveredSignatureSigner, 'Not bid owner');\r\n      require(burnedSignatures[sigHash]==0, 'Already burned');\r\n      \r\n      burnedSignatures[sigHash] = 0x2;\r\n      emit SignatureBurned(to, sigHash);\r\n      \r\n      return true;\r\n  }\r\n  \r\n  \r\n  \r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee_pct\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bidderAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sellerAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftContractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"currencyTokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currencyTokenAmount\",\"type\":\"uint256\"}],\"name\":\"BuyTheFloor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bidderAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"SignatureBurned\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"_chain_id\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_fee_pct\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"burnedSignatures\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currencyToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"requireProjectId\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expires\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"buyerSignature\",\"type\":\"bytes\"}],\"name\":\"cancelBid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBidDomainTypehash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"bidderAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nftContractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currencyTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"requireProjectId\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expires\",\"type\":\"uint256\"}],\"name\":\"getBidPacketHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBidPacketTypehash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"bidderAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nftContractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currencyTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"requireProjectId\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expires\",\"type\":\"uint256\"}],\"name\":\"getBidTypedDataHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"contractName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"verifyingContract\",\"type\":\"address\"}],\"name\":\"getEIP712DomainHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currencyToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"requireProjectId\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expires\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"buyerSignature\",\"type\":\"bytes\"}],\"name\":\"sellNFT\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"BuyTheFloorExchange","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://c67ee6eab09a2dfdc92e74f66bce1651a014197b31ab07c02c1182b920bfe822"}]}