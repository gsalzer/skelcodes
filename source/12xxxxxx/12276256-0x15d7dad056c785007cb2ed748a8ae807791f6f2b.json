{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/incentives/StakedTokenIncentivesController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\nimport {SafeERC20} from '@aave/aave-stake/contracts/lib/SafeERC20.sol';\\nimport {SafeMath} from '../lib/SafeMath.sol';\\nimport {DistributionTypes} from '../lib/DistributionTypes.sol';\\nimport {VersionedInitializable} from '@aave/aave-stake/contracts/utils/VersionedInitializable.sol';\\nimport {DistributionManager} from './DistributionManager.sol';\\nimport {IStakedTokenWithConfig} from '../interfaces/IStakedTokenWithConfig.sol';\\nimport {IERC20} from '@aave/aave-stake/contracts/interfaces/IERC20.sol';\\nimport {IScaledBalanceToken} from '../interfaces/IScaledBalanceToken.sol';\\nimport {IAaveIncentivesController} from '../interfaces/IAaveIncentivesController.sol';\\n\\n/**\\n * @title StakedTokenIncentivesController\\n * @notice Distributor contract for rewards to the Aave protocol, using a staked token as rewards asset.\\n * The contract stakes the rewards before redistributing them to the Aave protocol participants.\\n * The reference staked token implementation is at https://github.com/aave/aave-stake-v2\\n * @author Aave\\n **/\\ncontract StakedTokenIncentivesController is\\n  IAaveIncentivesController,\\n  VersionedInitializable,\\n  DistributionManager\\n{\\n  using SafeMath for uint256;\\n  using SafeERC20 for IERC20;\\n\\n  uint256 public constant REVISION = 1;\\n\\n  IStakedTokenWithConfig public immutable STAKE_TOKEN;\\n\\n  mapping(address => uint256) internal _usersUnclaimedRewards;\\n\\n  // this mapping allows whitelisted addresses to claim on behalf of others\\n  // useful for contracts that hold tokens to be rewarded but don't have any native logic to claim Liquidity Mining rewards\\n  mapping(address => address) internal _authorizedClaimers;\\n\\n  modifier onlyAuthorizedClaimers(address claimer, address user) {\\n    require(_authorizedClaimers[user] == claimer, 'CLAIMER_UNAUTHORIZED');\\n    _;\\n  }\\n\\n  constructor(IStakedTokenWithConfig stakeToken, address emissionManager)\\n    DistributionManager(emissionManager)\\n  {\\n    STAKE_TOKEN = stakeToken;\\n  }\\n\\n  /**\\n   * @dev Initialize IStakedTokenIncentivesController\\n   **/\\n  function initialize() external initializer {\\n    //approves the safety module to allow staking\\n    IERC20(STAKE_TOKEN.STAKED_TOKEN()).safeApprove(address(STAKE_TOKEN), type(uint256).max);\\n  }\\n\\n  /// @inheritdoc IAaveIncentivesController\\n  function configureAssets(address[] calldata assets, uint256[] calldata emissionsPerSecond)\\n    external\\n    override\\n    onlyEmissionManager\\n  {\\n    require(assets.length == emissionsPerSecond.length, 'INVALID_CONFIGURATION');\\n\\n    DistributionTypes.AssetConfigInput[] memory assetsConfig =\\n      new DistributionTypes.AssetConfigInput[](assets.length);\\n\\n    for (uint256 i = 0; i < assets.length; i++) {\\n      assetsConfig[i].underlyingAsset = assets[i];\\n      assetsConfig[i].emissionPerSecond = uint104(emissionsPerSecond[i]);\\n\\n      require(assetsConfig[i].emissionPerSecond == emissionsPerSecond[i], 'INVALID_CONFIGURATION');\\n\\n      assetsConfig[i].totalStaked = IScaledBalanceToken(assets[i]).scaledTotalSupply();\\n    }\\n    _configureAssets(assetsConfig);\\n  }\\n\\n  /// @inheritdoc IAaveIncentivesController\\n  function handleAction(\\n    address user,\\n    uint256 totalSupply,\\n    uint256 userBalance\\n  ) external override {\\n    uint256 accruedRewards = _updateUserAssetInternal(user, msg.sender, userBalance, totalSupply);\\n    if (accruedRewards != 0) {\\n      _usersUnclaimedRewards[user] = _usersUnclaimedRewards[user].add(accruedRewards);\\n      emit RewardsAccrued(user, accruedRewards);\\n    }\\n  }\\n\\n  /// @inheritdoc IAaveIncentivesController\\n  function getRewardsBalance(address[] calldata assets, address user)\\n    external\\n    view\\n    override\\n    returns (uint256)\\n  {\\n    uint256 unclaimedRewards = _usersUnclaimedRewards[user];\\n\\n    DistributionTypes.UserStakeInput[] memory userState =\\n      new DistributionTypes.UserStakeInput[](assets.length);\\n    for (uint256 i = 0; i < assets.length; i++) {\\n      userState[i].underlyingAsset = assets[i];\\n      (userState[i].stakedByUser, userState[i].totalStaked) = IScaledBalanceToken(assets[i])\\n        .getScaledUserBalanceAndSupply(user);\\n    }\\n    unclaimedRewards = unclaimedRewards.add(_getUnclaimedRewards(user, userState));\\n    return unclaimedRewards;\\n  }\\n\\n  /// @inheritdoc IAaveIncentivesController\\n  function claimRewards(\\n    address[] calldata assets,\\n    uint256 amount,\\n    address to\\n  ) external override returns (uint256) {\\n    require(to != address(0), 'INVALID_TO_ADDRESS');\\n    return _claimRewards(assets, amount, msg.sender, msg.sender, to);\\n  }\\n\\n  /// @inheritdoc IAaveIncentivesController\\n  function claimRewardsOnBehalf(\\n    address[] calldata assets,\\n    uint256 amount,\\n    address user,\\n    address to\\n  ) external override onlyAuthorizedClaimers(msg.sender, user) returns (uint256) {\\n    require(user != address(0), 'INVALID_USER_ADDRESS');\\n    require(to != address(0), 'INVALID_TO_ADDRESS');\\n    return _claimRewards(assets, amount, msg.sender, user, to);\\n  }\\n\\n  /**\\n   * @dev Claims reward for an user on behalf, on all the assets of the lending pool, accumulating the pending rewards.\\n   * @param amount Amount of rewards to claim\\n   * @param user Address to check and claim rewards\\n   * @param to Address that will be receiving the rewards\\n   * @return Rewards claimed\\n   **/\\n\\n  /// @inheritdoc IAaveIncentivesController\\n  function setClaimer(address user, address caller) external override onlyEmissionManager {\\n    _authorizedClaimers[user] = caller;\\n    emit ClaimerSet(user, caller);\\n  }\\n\\n  /// @inheritdoc IAaveIncentivesController\\n  function getClaimer(address user) external view override returns (address) {\\n    return _authorizedClaimers[user];\\n  }\\n\\n  /// @inheritdoc IAaveIncentivesController\\n  function getUserUnclaimedRewards(address _user) external view override returns (uint256) {\\n    return _usersUnclaimedRewards[_user];\\n  }\\n\\n  /// @inheritdoc IAaveIncentivesController\\n  function REWARD_TOKEN() external view override returns (address) {\\n    return address(STAKE_TOKEN);\\n  }\\n\\n  /**\\n   * @dev returns the revision of the implementation contract\\n   */\\n  function getRevision() internal pure override returns (uint256) {\\n    return REVISION;\\n  }\\n\\n  /**\\n   * @dev Claims reward for an user on behalf, on all the assets of the lending pool, accumulating the pending rewards.\\n   * @param amount Amount of rewards to claim\\n   * @param user Address to check and claim rewards\\n   * @param to Address that will be receiving the rewards\\n   * @return Rewards claimed\\n   **/\\n  function _claimRewards(\\n    address[] calldata assets,\\n    uint256 amount,\\n    address claimer,\\n    address user,\\n    address to\\n  ) internal returns (uint256) {\\n    if (amount == 0) {\\n      return 0;\\n    }\\n    uint256 unclaimedRewards = _usersUnclaimedRewards[user];\\n\\n    DistributionTypes.UserStakeInput[] memory userState =\\n      new DistributionTypes.UserStakeInput[](assets.length);\\n    for (uint256 i = 0; i < assets.length; i++) {\\n      userState[i].underlyingAsset = assets[i];\\n      (userState[i].stakedByUser, userState[i].totalStaked) = IScaledBalanceToken(assets[i])\\n        .getScaledUserBalanceAndSupply(user);\\n    }\\n\\n    uint256 accruedRewards = _claimRewards(user, userState);\\n    if (accruedRewards != 0) {\\n      unclaimedRewards = unclaimedRewards.add(accruedRewards);\\n      emit RewardsAccrued(user, accruedRewards);\\n    }\\n\\n    if (unclaimedRewards == 0) {\\n      return 0;\\n    }\\n\\n    uint256 amountToClaim = amount > unclaimedRewards ? unclaimedRewards : amount;\\n    _usersUnclaimedRewards[user] = unclaimedRewards - amountToClaim; // Safe due to the previous line\\n\\n    STAKE_TOKEN.stake(to, amountToClaim);\\n    emit RewardsClaimed(user, to, claimer, amountToClaim);\\n\\n    return amountToClaim;\\n  }\\n}\\n\"\r\n    },\r\n    \"@aave/aave-stake/contracts/lib/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.5;\\n\\nimport {IERC20} from '../interfaces/IERC20.sol';\\nimport {SafeMath} from './SafeMath.sol';\\nimport {Address} from './Address.sol';\\n\\n/**\\n * @title SafeERC20\\n * @dev From https://github.com/OpenZeppelin/openzeppelin-contracts\\n * Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n  using SafeMath for uint256;\\n  using Address for address;\\n\\n  function safeTransfer(\\n    IERC20 token,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n  }\\n\\n  function safeTransferFrom(\\n    IERC20 token,\\n    address from,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n  }\\n\\n  function safeApprove(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    require(\\n      (value == 0) || (token.allowance(address(this), spender) == 0),\\n      'SafeERC20: approve from non-zero to non-zero allowance'\\n    );\\n    callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n  }\\n\\n  function callOptionalReturn(IERC20 token, bytes memory data) private {\\n    require(address(token).isContract(), 'SafeERC20: call to non-contract');\\n\\n    // solhint-disable-next-line avoid-low-level-calls\\n    (bool success, bytes memory returndata) = address(token).call(data);\\n    require(success, 'SafeERC20: low-level call failed');\\n\\n    if (returndata.length > 0) {\\n      // Return data is optional\\n      // solhint-disable-next-line max-line-length\\n      require(abi.decode(returndata, (bool)), 'SafeERC20: ERC20 operation did not succeed');\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"@aave/aave-stake/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n * From https://github.com/OpenZeppelin/openzeppelin-contracts\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@aave/aave-stake/contracts/lib/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\n\\n/**\\n * @dev From https://github.com/OpenZeppelin/openzeppelin-contracts\\n * Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n  /**\\n   * @dev Returns the addition of two unsigned integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity's `+` operator.\\n   *\\n   * Requirements:\\n   * - Addition cannot overflow.\\n   */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a, 'SafeMath: addition overflow');\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, reverting on\\n   * overflow (when the result is negative).\\n   *\\n   * Counterpart to Solidity's `-` operator.\\n   *\\n   * Requirements:\\n   * - Subtraction cannot overflow.\\n   */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return sub(a, b, 'SafeMath: subtraction overflow');\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n   * overflow (when the result is negative).\\n   *\\n   * Counterpart to Solidity's `-` operator.\\n   *\\n   * Requirements:\\n   * - Subtraction cannot overflow.\\n   */\\n  function sub(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b <= a, errorMessage);\\n    uint256 c = a - b;\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the multiplication of two unsigned integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity's `*` operator.\\n   *\\n   * Requirements:\\n   * - Multiplication cannot overflow.\\n   */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b, 'SafeMath: multiplication overflow');\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the integer division of two unsigned integers. Reverts on\\n   * division by zero. The result is rounded towards zero.\\n   *\\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return div(a, b, 'SafeMath: division by zero');\\n  }\\n\\n  /**\\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n   * division by zero. The result is rounded towards zero.\\n   *\\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function div(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    // Solidity only automatically asserts when dividing by 0\\n    require(b > 0, errorMessage);\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n   * Reverts when dividing by zero.\\n   *\\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\n   * invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return mod(a, b, 'SafeMath: modulo by zero');\\n  }\\n\\n  /**\\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n   * Reverts with custom message when dividing by zero.\\n   *\\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\n   * invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function mod(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b != 0, errorMessage);\\n    return a % b;\\n  }\\n}\\n\"\r\n    },\r\n    \"@aave/aave-stake/contracts/lib/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n * From https://github.com/OpenZeppelin/openzeppelin-contracts\\n */\\nlibrary Address {\\n  /**\\n   * @dev Returns true if `account` is a contract.\\n   *\\n   * [IMPORTANT]\\n   * ====\\n   * It is unsafe to assume that an address for which this function returns\\n   * false is an externally-owned account (EOA) and not a contract.\\n   *\\n   * Among others, `isContract` will return false for the following\\n   * types of addresses:\\n   *\\n   *  - an externally-owned account\\n   *  - a contract in construction\\n   *  - an address where a contract will be created\\n   *  - an address where a contract lived, but was destroyed\\n   * ====\\n   */\\n  function isContract(address account) internal view returns (bool) {\\n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n    // for accounts without code, i.e. `keccak256('')`\\n    bytes32 codehash;\\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      codehash := extcodehash(account)\\n    }\\n    return (codehash != accountHash && codehash != 0x0);\\n  }\\n\\n  /**\\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n   * `recipient`, forwarding all available gas and reverting on errors.\\n   *\\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n   * imposed by `transfer`, making them unable to receive funds via\\n   * `transfer`. {sendValue} removes this limitation.\\n   *\\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n   *\\n   * IMPORTANT: because control is transferred to `recipient`, care must be\\n   * taken to not create reentrancy vulnerabilities. Consider using\\n   * {ReentrancyGuard} or the\\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n   */\\n  function sendValue(address payable recipient, uint256 amount) internal {\\n    require(address(this).balance >= amount, 'Address: insufficient balance');\\n\\n    // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n    (bool success, ) = recipient.call{value: amount}('');\\n    require(success, 'Address: unable to send value, recipient may have reverted');\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/SafeMath.sol\": {\r\n      \"content\": \"\\n// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.7.5;\\n\\n/// @title Optimized overflow and underflow safe math operations\\n/// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost\\n/// inspired by uniswap V3\\nlibrary SafeMath {\\n    /// @notice Returns x + y, reverts if sum overflows uint256\\n    /// @param x The augend\\n    /// @param y The addend\\n    /// @return z The sum of x and y\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x + y) >= x);\\n    }\\n\\n    /// @notice Returns x - y, reverts if underflows\\n    /// @param x The minuend\\n    /// @param y The subtrahend\\n    /// @return z The difference of x and y\\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x - y) <= x);\\n    }\\n\\n    /// @notice Returns x * y, reverts if overflows\\n    /// @param x The multiplicand\\n    /// @param y The multiplier\\n    /// @return z The product of x and y\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require(x == 0 || (z = x * y) / x == y);\\n    }\\n\\n    function div(uint256 x, uint256 y) internal pure returns(uint256) {\\n        // no need to check for division by zero - solidity already reverts\\n        return x / y;\\n    }\\n}\"\r\n    },\r\n    \"contracts/lib/DistributionTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\nlibrary DistributionTypes {\\n  struct AssetConfigInput {\\n    uint104 emissionPerSecond;\\n    uint256 totalStaked;\\n    address underlyingAsset;\\n  }\\n\\n  struct UserStakeInput {\\n    address underlyingAsset;\\n    uint256 stakedByUser;\\n    uint256 totalStaked;\\n  }\\n}\\n\"\r\n    },\r\n    \"@aave/aave-stake/contracts/utils/VersionedInitializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\n\\n/**\\n * @title VersionedInitializable\\n *\\n * @dev Helper contract to support initializer functions. To use it, replace\\n * the constructor with a function that has the `initializer` modifier.\\n * WARNING: Unlike constructors, initializer functions must be manually\\n * invoked. This applies both to deploying an Initializable contract, as well\\n * as extending an Initializable contract via inheritance.\\n * WARNING: When used with inheritance, manual care must be taken to not invoke\\n * a parent initializer twice, or ensure that all initializers are idempotent,\\n * because this is not dealt with automatically as with constructors.\\n *\\n * @author Aave, inspired by the OpenZeppelin Initializable contract\\n */\\nabstract contract VersionedInitializable {\\n  /**\\n   * @dev Indicates that the contract has been initialized.\\n   */\\n  uint256 internal lastInitializedRevision = 0;\\n\\n  /**\\n   * @dev Modifier to use in the initializer function of a contract.\\n   */\\n  modifier initializer() {\\n    uint256 revision = getRevision();\\n    require(revision > lastInitializedRevision, 'Contract instance has already been initialized');\\n\\n    lastInitializedRevision = revision;\\n\\n    _;\\n  }\\n\\n  /// @dev returns the revision number of the contract.\\n  /// Needs to be defined in the inherited class as a constant.\\n  function getRevision() internal pure virtual returns (uint256);\\n\\n  // Reserved storage space to allow for layout changes in the future.\\n  uint256[50] private ______gap;\\n}\\n\"\r\n    },\r\n    \"contracts/incentives/DistributionManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\nimport {IAaveDistributionManager} from '../interfaces/IAaveDistributionManager.sol';\\nimport {SafeMath} from '../lib/SafeMath.sol';\\nimport {DistributionTypes} from '../lib/DistributionTypes.sol';\\n\\n/**\\n * @title DistributionManager\\n * @notice Accounting contract to manage multiple staking distributions\\n * @author Aave\\n **/\\ncontract DistributionManager is IAaveDistributionManager {\\n  using SafeMath for uint256;\\n\\n  struct AssetData {\\n    uint104 emissionPerSecond;\\n    uint104 index;\\n    uint40 lastUpdateTimestamp;\\n    mapping(address => uint256) users;\\n  }\\n\\n  address public immutable EMISSION_MANAGER;\\n\\n  uint8 public constant PRECISION = 18;\\n\\n  mapping(address => AssetData) public assets;\\n\\n  uint256 internal _distributionEnd;\\n\\n  modifier onlyEmissionManager() {\\n    require(msg.sender == EMISSION_MANAGER, 'ONLY_EMISSION_MANAGER');\\n    _;\\n  }\\n\\n  constructor(address emissionManager) {\\n    EMISSION_MANAGER = emissionManager;\\n  }\\n\\n  /// @inheritdoc IAaveDistributionManager\\n  function setDistributionEnd(uint256 distributionEnd) external override onlyEmissionManager {\\n    _distributionEnd = distributionEnd;\\n    emit DistributionEndUpdated(distributionEnd);\\n  }\\n\\n  /// @inheritdoc IAaveDistributionManager\\n  function getDistributionEnd() external view override returns (uint256) {\\n    return _distributionEnd;\\n  }\\n\\n  /// @inheritdoc IAaveDistributionManager\\n  function DISTRIBUTION_END() external view override returns (uint256) {\\n    return _distributionEnd;\\n  }\\n\\n  /// @inheritdoc IAaveDistributionManager\\n  function getUserAssetData(address user, address asset) public view override returns (uint256) {\\n    return assets[asset].users[user];\\n  }\\n\\n  /**\\n   * @dev Configure the assets for a specific emission\\n   * @param assetsConfigInput The array of each asset configuration\\n   **/\\n  function _configureAssets(DistributionTypes.AssetConfigInput[] memory assetsConfigInput)\\n    internal\\n  {\\n    for (uint256 i = 0; i < assetsConfigInput.length; i++) {\\n      AssetData storage assetConfig = assets[assetsConfigInput[i].underlyingAsset];\\n\\n      _updateAssetStateInternal(\\n        assetsConfigInput[i].underlyingAsset,\\n        assetConfig,\\n        assetsConfigInput[i].totalStaked\\n      );\\n\\n      assetConfig.emissionPerSecond = assetsConfigInput[i].emissionPerSecond;\\n\\n      emit AssetConfigUpdated(\\n        assetsConfigInput[i].underlyingAsset,\\n        assetsConfigInput[i].emissionPerSecond\\n      );\\n    }\\n  }\\n\\n  /**\\n   * @dev Updates the state of one distribution, mainly rewards index and timestamp\\n   * @param asset The address of the asset being updated\\n   * @param assetConfig Storage pointer to the distribution's config\\n   * @param totalStaked Current total of staked assets for this distribution\\n   * @return The new distribution index\\n   **/\\n  function _updateAssetStateInternal(\\n    address asset,\\n    AssetData storage assetConfig,\\n    uint256 totalStaked\\n  ) internal returns (uint256) {\\n    uint256 oldIndex = assetConfig.index;\\n    uint256 emissionPerSecond = assetConfig.emissionPerSecond;\\n    uint128 lastUpdateTimestamp = assetConfig.lastUpdateTimestamp;\\n\\n    if (block.timestamp == lastUpdateTimestamp) {\\n      return oldIndex;\\n    }\\n\\n    uint256 newIndex =\\n      _getAssetIndex(oldIndex, emissionPerSecond, lastUpdateTimestamp, totalStaked);\\n\\n    if (newIndex != oldIndex) {\\n      require(uint104(newIndex) == newIndex, 'Index overflow');\\n      //optimization: storing one after another saves one SSTORE\\n      assetConfig.index = uint104(newIndex);\\n      assetConfig.lastUpdateTimestamp = uint40(block.timestamp);\\n      emit AssetIndexUpdated(asset, newIndex);\\n    } else {\\n      assetConfig.lastUpdateTimestamp = uint40(block.timestamp);\\n    }\\n\\n    return newIndex;\\n  }\\n\\n  /**\\n   * @dev Updates the state of an user in a distribution\\n   * @param user The user's address\\n   * @param asset The address of the reference asset of the distribution\\n   * @param stakedByUser Amount of tokens staked by the user in the distribution at the moment\\n   * @param totalStaked Total tokens staked in the distribution\\n   * @return The accrued rewards for the user until the moment\\n   **/\\n  function _updateUserAssetInternal(\\n    address user,\\n    address asset,\\n    uint256 stakedByUser,\\n    uint256 totalStaked\\n  ) internal returns (uint256) {\\n    AssetData storage assetData = assets[asset];\\n    uint256 userIndex = assetData.users[user];\\n    uint256 accruedRewards = 0;\\n\\n    uint256 newIndex = _updateAssetStateInternal(asset, assetData, totalStaked);\\n\\n    if (userIndex != newIndex) {\\n      if (stakedByUser != 0) {\\n        accruedRewards = _getRewards(stakedByUser, newIndex, userIndex);\\n      }\\n\\n      assetData.users[user] = newIndex;\\n      emit UserIndexUpdated(user, asset, newIndex);\\n    }\\n\\n    return accruedRewards;\\n  }\\n\\n  /**\\n   * @dev Used by \\\"frontend\\\" stake contracts to update the data of an user when claiming rewards from there\\n   * @param user The address of the user\\n   * @param stakes List of structs of the user data related with his stake\\n   * @return The accrued rewards for the user until the moment\\n   **/\\n  function _claimRewards(address user, DistributionTypes.UserStakeInput[] memory stakes)\\n    internal\\n    returns (uint256)\\n  {\\n    uint256 accruedRewards = 0;\\n\\n    for (uint256 i = 0; i < stakes.length; i++) {\\n      accruedRewards = accruedRewards.add(\\n        _updateUserAssetInternal(\\n          user,\\n          stakes[i].underlyingAsset,\\n          stakes[i].stakedByUser,\\n          stakes[i].totalStaked\\n        )\\n      );\\n    }\\n\\n    return accruedRewards;\\n  }\\n\\n  /**\\n   * @dev Return the accrued rewards for an user over a list of distribution\\n   * @param user The address of the user\\n   * @param stakes List of structs of the user data related with his stake\\n   * @return The accrued rewards for the user until the moment\\n   **/\\n  function _getUnclaimedRewards(address user, DistributionTypes.UserStakeInput[] memory stakes)\\n    internal\\n    view\\n    returns (uint256)\\n  {\\n    uint256 accruedRewards = 0;\\n\\n    for (uint256 i = 0; i < stakes.length; i++) {\\n      AssetData storage assetConfig = assets[stakes[i].underlyingAsset];\\n      uint256 assetIndex =\\n        _getAssetIndex(\\n          assetConfig.index,\\n          assetConfig.emissionPerSecond,\\n          assetConfig.lastUpdateTimestamp,\\n          stakes[i].totalStaked\\n        );\\n\\n      accruedRewards = accruedRewards.add(\\n        _getRewards(stakes[i].stakedByUser, assetIndex, assetConfig.users[user])\\n      );\\n    }\\n    return accruedRewards;\\n  }\\n\\n  /**\\n   * @dev Internal function for the calculation of user's rewards on a distribution\\n   * @param principalUserBalance Amount staked by the user on a distribution\\n   * @param reserveIndex Current index of the distribution\\n   * @param userIndex Index stored for the user, representation his staking moment\\n   * @return The rewards\\n   **/\\n  function _getRewards(\\n    uint256 principalUserBalance,\\n    uint256 reserveIndex,\\n    uint256 userIndex\\n  ) internal pure returns (uint256) {\\n    return principalUserBalance.mul(reserveIndex.sub(userIndex)) / 10**uint256(PRECISION);\\n  }\\n\\n  /**\\n   * @dev Calculates the next value of an specific distribution index, with validations\\n   * @param currentIndex Current index of the distribution\\n   * @param emissionPerSecond Representing the total rewards distributed per second per asset unit, on the distribution\\n   * @param lastUpdateTimestamp Last moment this distribution was updated\\n   * @param totalBalance of tokens considered for the distribution\\n   * @return The new index.\\n   **/\\n  function _getAssetIndex(\\n    uint256 currentIndex,\\n    uint256 emissionPerSecond,\\n    uint128 lastUpdateTimestamp,\\n    uint256 totalBalance\\n  ) internal view returns (uint256) {\\n    uint256 distributionEnd = _distributionEnd;\\n    if (\\n      emissionPerSecond == 0 ||\\n      totalBalance == 0 ||\\n      lastUpdateTimestamp == block.timestamp ||\\n      lastUpdateTimestamp >= distributionEnd\\n    ) {\\n      return currentIndex;\\n    }\\n\\n    uint256 currentTimestamp =\\n      block.timestamp > distributionEnd ? distributionEnd : block.timestamp;\\n    uint256 timeDelta = currentTimestamp.sub(lastUpdateTimestamp);\\n    return\\n      emissionPerSecond.mul(timeDelta).mul(10**uint256(PRECISION)).div(totalBalance).add(\\n        currentIndex\\n      );\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAaveDistributionManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\nimport {DistributionTypes} from '../lib/DistributionTypes.sol';\\n\\ninterface IAaveDistributionManager {\\n  \\n  event AssetConfigUpdated(address indexed asset, uint256 emission);\\n  event AssetIndexUpdated(address indexed asset, uint256 index);\\n  event UserIndexUpdated(address indexed user, address indexed asset, uint256 index);\\n  event DistributionEndUpdated(uint256 newDistributionEnd);\\n\\n  /**\\n  * @dev Sets the end date for the distribution\\n  * @param distributionEnd The end date timestamp\\n  **/\\n  function setDistributionEnd(uint256 distributionEnd) external;\\n\\n  /**\\n  * @dev Gets the end date for the distribution\\n  * @return The end of the distribution\\n  **/\\n  function getDistributionEnd() external view returns (uint256);\\n\\n  /**\\n  * @dev for backwards compatibility with the previous DistributionManager used\\n  * @return The end of the distribution\\n  **/\\n  function DISTRIBUTION_END() external view returns(uint256);\\n\\n   /**\\n   * @dev Returns the data of an user on a distribution\\n   * @param user Address of the user\\n   * @param asset The address of the reference asset of the distribution\\n   * @return The new index\\n   **/\\n   function getUserAssetData(address user, address asset) external view returns (uint256);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStakedTokenWithConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.7.5;\\n\\nimport {IStakedToken} from '@aave/aave-stake/contracts/interfaces/IStakedToken.sol';\\n\\ninterface IStakedTokenWithConfig is IStakedToken {\\n  function STAKED_TOKEN() external view returns(address);\\n}\"\r\n    },\r\n    \"@aave/aave-stake/contracts/interfaces/IStakedToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\n\\ninterface IStakedToken {\\n  \\n  function stake(address to, uint256 amount) external;\\n\\n  function redeem(address to, uint256 amount) external;\\n\\n  function cooldown() external;\\n\\n  function claimRewards(address to, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IScaledBalanceToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\n\\ninterface IScaledBalanceToken {\\n  /**\\n   * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the\\n   * updated stored balance divided by the reserve's liquidity index at the moment of the update\\n   * @param user The user whose balance is calculated\\n   * @return The scaled balance of the user\\n   **/\\n  function scaledBalanceOf(address user) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the scaled balance of the user and the scaled total supply.\\n   * @param user The address of the user\\n   * @return The scaled balance of the user\\n   * @return The scaled balance and the scaled total supply\\n   **/\\n  function getScaledUserBalanceAndSupply(address user) external view returns (uint256, uint256);\\n\\n  /**\\n   * @dev Returns the scaled total supply of the token. Represents sum(debt/index)\\n   * @return The scaled total supply\\n   **/\\n  function scaledTotalSupply() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAaveIncentivesController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\n\\npragma experimental ABIEncoderV2;\\n\\nimport {IAaveDistributionManager} from '../interfaces/IAaveDistributionManager.sol';\\n\\ninterface IAaveIncentivesController is IAaveDistributionManager {\\n  \\n  event RewardsAccrued(address indexed user, uint256 amount);\\n  \\n  event RewardsClaimed(\\n    address indexed user,\\n    address indexed to,\\n    address indexed claimer,\\n    uint256 amount\\n  );\\n\\n  event ClaimerSet(address indexed user, address indexed claimer);\\n\\n  /**\\n   * @dev Whitelists an address to claim the rewards on behalf of another address\\n   * @param user The address of the user\\n   * @param claimer The address of the claimer\\n   */\\n  function setClaimer(address user, address claimer) external;\\n\\n  /**\\n   * @dev Returns the whitelisted claimer for a certain address (0x0 if not set)\\n   * @param user The address of the user\\n   * @return The claimer address\\n   */\\n  function getClaimer(address user) external view returns (address);\\n\\n  /**\\n   * @dev Configure assets for a certain rewards emission\\n   * @param assets The assets to incentivize\\n   * @param emissionsPerSecond The emission for each asset\\n   */\\n  function configureAssets(address[] calldata assets, uint256[] calldata emissionsPerSecond)\\n    external;\\n\\n\\n  /**\\n   * @dev Called by the corresponding asset on any update that affects the rewards distribution\\n   * @param asset The address of the user\\n   * @param userBalance The balance of the user of the asset in the lending pool\\n   * @param totalSupply The total supply of the asset in the lending pool\\n   **/\\n  function handleAction(\\n    address asset,\\n    uint256 userBalance,\\n    uint256 totalSupply\\n  ) external;\\n\\n  /**\\n   * @dev Returns the total of rewards of an user, already accrued + not yet accrued\\n   * @param user The address of the user\\n   * @return The rewards\\n   **/\\n  function getRewardsBalance(address[] calldata assets, address user)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n   * @dev Claims reward for an user, on all the assets of the lending pool, accumulating the pending rewards\\n   * @param amount Amount of rewards to claim\\n   * @param to Address that will be receiving the rewards\\n   * @return Rewards claimed\\n   **/\\n  function claimRewards(\\n    address[] calldata assets,\\n    uint256 amount,\\n    address to\\n  ) external returns (uint256);\\n\\n  /**\\n   * @dev Claims reward for an user on behalf, on all the assets of the lending pool, accumulating the pending rewards. The caller must\\n   * be whitelisted via \\\"allowClaimOnBehalf\\\" function by the RewardsAdmin role manager\\n   * @param amount Amount of rewards to claim\\n   * @param user Address to check and claim rewards\\n   * @param to Address that will be receiving the rewards\\n   * @return Rewards claimed\\n   **/\\n  function claimRewardsOnBehalf(\\n    address[] calldata assets,\\n    uint256 amount,\\n    address user,\\n    address to\\n  ) external returns (uint256);\\n\\n  /**\\n   * @dev returns the unclaimed rewards of the user\\n   * @param user the address of the user\\n   * @return the unclaimed user rewards\\n   */\\n  function getUserUnclaimedRewards(address user) external view returns (uint256);\\n\\n  /**\\n  * @dev for backward compatibility with previous implementation of the Incentives controller\\n  */\\n  function REWARD_TOKEN() external view returns (address);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IStakedTokenWithConfig\",\"name\":\"stakeToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"emissionManager\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"emission\",\"type\":\"uint256\"}],\"name\":\"AssetConfigUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"AssetIndexUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"}],\"name\":\"ClaimerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDistributionEnd\",\"type\":\"uint256\"}],\"name\":\"DistributionEndUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardsAccrued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardsClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"UserIndexUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DISTRIBUTION_END\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EMISSION_MANAGER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRECISION\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REVISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REWARD_TOKEN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STAKE_TOKEN\",\"outputs\":[{\"internalType\":\"contract IStakedTokenWithConfig\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"assets\",\"outputs\":[{\"internalType\":\"uint104\",\"name\":\"emissionPerSecond\",\"type\":\"uint104\"},{\"internalType\":\"uint104\",\"name\":\"index\",\"type\":\"uint104\"},{\"internalType\":\"uint40\",\"name\":\"lastUpdateTimestamp\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"assets\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"claimRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"assets\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"claimRewardsOnBehalf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"assets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"emissionsPerSecond\",\"type\":\"uint256[]\"}],\"name\":\"configureAssets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getClaimer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDistributionEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"assets\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getRewardsBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"getUserAssetData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserUnclaimedRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userBalance\",\"type\":\"uint256\"}],\"name\":\"handleAction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"setClaimer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"distributionEnd\",\"type\":\"uint256\"}],\"name\":\"setDistributionEnd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"StakedTokenIncentivesController","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000004da27a545c0c5b758a6ba100e3a049001de870f5000000000000000000000000ee56e2b3d491590b5b31738cc34d5232f378a8d5","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}