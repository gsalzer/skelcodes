{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.3;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\ninterface ILToken is IERC20 {\\n  /**\\n   * @dev Emitted after lTokens are minted\\n   * @param account The receiver of minted lToken\\n   * @param amount The amount being minted\\n   * @param index The new liquidity index of the reserve\\n   **/\\n  event Mint(address indexed account, uint256 amount, uint256 index);\\n\\n  /**\\n   * @dev Emitted after lTokens are burned\\n   * @param account The owner of the lTokens, getting them burned\\n   * @param underlyingAssetReceiver The address that will receive the underlying asset\\n   * @param amount The amount being burned\\n   * @param index The new liquidity index of the reserve\\n   **/\\n  event Burn(\\n    address indexed account,\\n    address indexed underlyingAssetReceiver,\\n    uint256 amount,\\n    uint256 index\\n  );\\n\\n  /**\\n   * @dev Emitted during the transfer action\\n   * @param account The account whose tokens are being transferred\\n   * @param to The recipient\\n   * @param amount The amount being transferred\\n   * @param index The new liquidity index of the reserve\\n   **/\\n  event BalanceTransfer(address indexed account, address indexed to, uint256 amount, uint256 index);\\n\\n  function mint(\\n    address account,\\n    uint256 amount,\\n    uint256 index\\n  ) external;\\n\\n  /**\\n   * @dev Burns lTokens account `account` and sends the equivalent amount of underlying to `receiver`\\n   * @param account The owner of the lTokens, getting them burned\\n   * @param receiver The address that will receive the underlying\\n   * @param amount The amount being burned\\n   * @param index The new liquidity index of the reserve\\n   **/\\n  function burn(\\n    address account,\\n    address receiver,\\n    uint256 amount,\\n    uint256 index\\n  ) external;\\n\\n  /**\\n   * @dev Returns the address of the underlying asset of this LTokens (E.g. WETH for aWETH)\\n   **/\\n  function getUnderlyingAsset() external view returns (address);\\n\\n  function implicitBalanceOf(address account) external view returns (uint256);\\n\\n  function implicitTotalSupply() external view returns (uint256);\\n\\n  function transferUnderlyingTo(address underlyingAssetReceiver, uint256 amount) external;\\n\\n  function updateIncentivePool(address newIncentivePool) external;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/DataStruct.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.3;\\n\\nlibrary DataStruct {\\n  /**\\n    @notice The main reserve data struct.\\n   */\\n  struct ReserveData {\\n    uint256 moneyPoolFactor;\\n    uint256 lTokenInterestIndex;\\n    uint256 borrowAPY;\\n    uint256 depositAPY;\\n    uint256 lastUpdateTimestamp;\\n    address lTokenAddress;\\n    address dTokenAddress;\\n    address interestModelAddress;\\n    address tokenizerAddress;\\n    uint8 id;\\n    bool isPaused;\\n    bool isActivated;\\n  }\\n\\n  /**\\n   * @notice The asset bond data struct.\\n   * @param ipfsHash The IPFS hash that contains the informations and contracts\\n   * between Collateral Service Provider and lender.\\n   * @param maturityTimestamp The amount of time measured in seconds that can elapse\\n   * before the NPL company liquidate the loan and seize the asset bond collateral.\\n   * @param borrower The address of the borrower.\\n   */\\n  struct AssetBondData {\\n    AssetBondState state;\\n    address borrower;\\n    address signer;\\n    address collateralServiceProvider;\\n    uint256 principal;\\n    uint256 debtCeiling;\\n    uint256 couponRate;\\n    uint256 interestRate;\\n    uint256 delinquencyRate;\\n    uint256 loanStartTimestamp;\\n    uint256 collateralizeTimestamp;\\n    uint256 maturityTimestamp;\\n    uint256 liquidationTimestamp;\\n    string ipfsHash; // refactor : gas\\n    string signerOpinionHash;\\n  }\\n\\n  struct AssetBondIdData {\\n    uint256 nonce;\\n    uint256 countryCode;\\n    uint256 collateralServiceProviderIdentificationNumber;\\n    uint256 collateralLatitude;\\n    uint256 collateralLatitudeSign;\\n    uint256 collateralLongitude;\\n    uint256 collateralLongitudeSign;\\n    uint256 collateralDetail;\\n    uint256 collateralCategory;\\n    uint256 productNumber;\\n  }\\n\\n  /**\\n    @notice The states of asset bond\\n    * EMPTY: After\\n    * SETTLED:\\n    * CONFIRMED:\\n    * COLLATERALIZED:\\n    * DELINQUENT:\\n    * REDEEMED:\\n    * LIQUIDATED:\\n   */\\n  enum AssetBondState {\\n    EMPTY,\\n    SETTLED,\\n    CONFIRMED,\\n    COLLATERALIZED,\\n    DELINQUENT,\\n    REDEEMED,\\n    LIQUIDATED\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.3;\\n\\nimport './WadRayMath.sol';\\n\\nlibrary Math {\\n  using WadRayMath for uint256;\\n\\n  uint256 internal constant SECONDSPERYEAR = 365 days;\\n\\n  function calculateLinearInterest(\\n    uint256 rate,\\n    uint256 lastUpdateTimestamp,\\n    uint256 currentTimestamp\\n  ) internal pure returns (uint256) {\\n    uint256 timeDelta = currentTimestamp - uint256(lastUpdateTimestamp);\\n\\n    return ((rate * timeDelta) / SECONDSPERYEAR) + WadRayMath.ray();\\n  }\\n\\n  /**\\n   * @notice Author : AAVE\\n   * @dev Function to calculate the interest using a compounded interest rate formula\\n   * To avoid expensive exponentiation, the calculation is performed using a binomial approximation:\\n   *  (1+x)^n = 1+n*x+[n/2*(n-1)]*x^2+[n/6*(n-1)*(n-2)*x^3...\\n   *\\n   * The approximation slightly underpays liquidity providers and undercharges borrowers, with the advantage of great gas cost reductions\\n   * The whitepaper contains reference to the approximation and a table showing the margin of error per different time periods\\n   *\\n   * @param rate The interest rate, in ray\\n   * @param lastUpdateTimestamp The timestamp of the last update of the interest\\n   * @return The interest rate compounded during the timeDelta, in ray\\n   **/\\n  function calculateCompoundedInterest(\\n    uint256 rate,\\n    uint256 lastUpdateTimestamp,\\n    uint256 currentTimestamp\\n  ) internal pure returns (uint256) {\\n    //solium-disable-next-line\\n    uint256 exp = currentTimestamp - lastUpdateTimestamp;\\n\\n    if (exp == 0) {\\n      return WadRayMath.ray();\\n    }\\n\\n    uint256 expMinusOne = exp - 1;\\n\\n    uint256 expMinusTwo = exp > 2 ? exp - 2 : 0;\\n\\n    // loss of precision is endurable\\n    // slither-disable-next-line divide-before-multiply\\n    uint256 ratePerSecond = rate / SECONDSPERYEAR;\\n\\n    uint256 basePowerTwo = ratePerSecond.rayMul(ratePerSecond);\\n    uint256 basePowerThree = basePowerTwo.rayMul(ratePerSecond);\\n\\n    uint256 secondTerm = (exp * expMinusOne * basePowerTwo) / 2;\\n    uint256 thirdTerm = (exp * expMinusOne * expMinusTwo * basePowerThree) / 6;\\n\\n    return WadRayMath.ray() + (ratePerSecond * exp) + secondTerm + thirdTerm;\\n  }\\n\\n  function calculateRateInIncreasingBalance(\\n    uint256 averageRate,\\n    uint256 totalBalance,\\n    uint256 amountIn,\\n    uint256 rate\\n  ) internal pure returns (uint256, uint256) {\\n    uint256 weightedAverageRate = totalBalance.wadToRay().rayMul(averageRate);\\n    uint256 weightedAmountRate = amountIn.wadToRay().rayMul(rate);\\n\\n    uint256 newTotalBalance = totalBalance + amountIn;\\n    uint256 newAverageRate = (weightedAverageRate + weightedAmountRate).rayDiv(\\n      newTotalBalance.wadToRay()\\n    );\\n\\n    return (newTotalBalance, newAverageRate);\\n  }\\n\\n  function calculateRateInDecreasingBalance(\\n    uint256 averageRate,\\n    uint256 totalBalance,\\n    uint256 amountOut,\\n    uint256 rate\\n  ) internal pure returns (uint256, uint256) {\\n    // if decreasing amount exceeds totalBalance,\\n    // overall rate and balacne would be set 0\\n    if (totalBalance <= amountOut) {\\n      return (0, 0);\\n    }\\n\\n    uint256 weightedAverageRate = totalBalance.wadToRay().rayMul(averageRate);\\n    uint256 weightedAmountRate = amountOut.wadToRay().rayMul(rate);\\n\\n    if (weightedAverageRate <= weightedAmountRate) {\\n      return (0, 0);\\n    }\\n\\n    uint256 newTotalBalance = totalBalance - amountOut;\\n\\n    uint256 newAverageRate = (weightedAverageRate - weightedAmountRate).rayDiv(\\n      newTotalBalance.wadToRay()\\n    );\\n\\n    return (newTotalBalance, newAverageRate);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/WadRayMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.3;\\n\\n/**\\n * @title WadRayMath library\\n * @author Aave\\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\\n **/\\n\\nlibrary WadRayMath {\\n  uint256 internal constant WAD = 1e18;\\n  uint256 internal constant halfWAD = WAD / 2;\\n\\n  uint256 internal constant RAY = 1e27;\\n  uint256 internal constant halfRAY = RAY / 2;\\n\\n  uint256 internal constant WAD_RAY_RATIO = 1e9;\\n\\n  /**\\n   * @return One ray, 1e27\\n   **/\\n  function ray() internal pure returns (uint256) {\\n    return RAY;\\n  }\\n\\n  /**\\n   * @return One wad, 1e18\\n   **/\\n\\n  function wad() internal pure returns (uint256) {\\n    return WAD;\\n  }\\n\\n  /**\\n   * @return Half ray, 1e27/2\\n   **/\\n  function halfRay() internal pure returns (uint256) {\\n    return halfRAY;\\n  }\\n\\n  /**\\n   * @return Half ray, 1e18/2\\n   **/\\n  function halfWad() internal pure returns (uint256) {\\n    return halfWAD;\\n  }\\n\\n  /**\\n   * @dev Multiplies two wad, rounding half up to the nearest wad\\n   * @param a Wad\\n   * @param b Wad\\n   * @return The result of a*b, in wad\\n   **/\\n  function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a == 0 || b == 0) {\\n      return 0;\\n    }\\n    return (a * b + halfWAD) / WAD;\\n  }\\n\\n  /**\\n   * @dev Divides two wad, rounding half up to the nearest wad\\n   * @param a Wad\\n   * @param b Wad\\n   * @return The result of a/b, in wad\\n   **/\\n  function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0, 'Division by Zero');\\n    uint256 halfB = b / 2;\\n    return (a * WAD + halfB) / b;\\n  }\\n\\n  /**\\n   * @dev Multiplies two ray, rounding half up to the nearest ray\\n   * @param a Ray\\n   * @param b Ray\\n   * @return The result of a*b, in ray\\n   **/\\n  function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a == 0 || b == 0) {\\n      return 0;\\n    }\\n    return (a * b + halfRAY) / RAY;\\n  }\\n\\n  /**\\n   * @dev Divides two ray, rounding half up to the nearest ray\\n   * @param a Ray\\n   * @param b Ray\\n   * @return The result of a/b, in ray\\n   **/\\n  function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0, 'Division by Zero');\\n    uint256 halfB = b / 2;\\n    return (a * RAY + halfB) / b;\\n  }\\n\\n  /**\\n   * @dev Casts ray down to wad\\n   * @param a Ray\\n   * @return a casted to wad, rounded half up to the nearest wad\\n   **/\\n  function rayToWad(uint256 a) internal pure returns (uint256) {\\n    uint256 halfRatio = WAD_RAY_RATIO / 2;\\n    uint256 result = halfRatio + a;\\n    return result / WAD_RAY_RATIO;\\n  }\\n\\n  /**\\n   * @dev Converts wad up to ray\\n   * @param a Wad\\n   * @return a converted in ray\\n   **/\\n  function wadToRay(uint256 a) internal pure returns (uint256) {\\n    uint256 result = a * WAD_RAY_RATIO;\\n    return result;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/logic/Validation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.3;\\n\\nimport '../libraries/DataStruct.sol';\\nimport '../libraries/Math.sol';\\n\\nimport '../interfaces/ILToken.sol';\\n\\nlibrary Validation {\\n  using WadRayMath for uint256;\\n  using Validation for DataStruct.ReserveData;\\n\\n  /**\\n   * @dev Validate Deposit\\n   * Check reserve state\\n   * @param reserve The reserve object\\n   * @param amount Deposit amount\\n   **/\\n  function validateDeposit(DataStruct.ReserveData storage reserve, uint256 amount) public view {\\n    require(amount != 0, 'InvalidAmount');\\n    require(!reserve.isPaused, 'ReservePaused');\\n    require(reserve.isActivated, 'ReserveInactivated');\\n  }\\n\\n  /**\\n   * @dev Validate Withdraw\\n   * Check reserve state\\n   * Check user amount\\n   * Check user total debt(later)\\n   * @param reserve The reserve object\\n   * @param amount Withdraw amount\\n   **/\\n  function validateWithdraw(\\n    DataStruct.ReserveData storage reserve,\\n    address asset,\\n    uint256 amount,\\n    uint256 userLTokenBalance\\n  ) public view {\\n    require(amount != 0, 'InvalidAmount');\\n    require(!reserve.isPaused, 'ReservePaused');\\n    require(reserve.isActivated, 'ReserveInactivated');\\n    require(amount <= userLTokenBalance, 'InsufficientBalance');\\n    uint256 availableLiquidity = IERC20(asset).balanceOf(reserve.lTokenAddress);\\n    require(availableLiquidity >= amount, 'NotEnoughLiquidity');\\n  }\\n\\n  function validateBorrow(\\n    DataStruct.ReserveData storage reserve,\\n    DataStruct.AssetBondData memory assetBond,\\n    address asset,\\n    uint256 borrowAmount\\n  ) public view {\\n    require(!reserve.isPaused, 'ReservePaused');\\n    require(reserve.isActivated, 'ReserveInactivated');\\n    require(assetBond.state == DataStruct.AssetBondState.CONFIRMED, 'OnlySignedTokenBorrowAllowed');\\n    require(msg.sender == assetBond.collateralServiceProvider, 'OnlyOwnerBorrowAllowed');\\n    uint256 availableLiquidity = IERC20(asset).balanceOf(reserve.lTokenAddress);\\n    require(availableLiquidity >= borrowAmount, 'NotEnoughLiquidity');\\n    require(block.timestamp >= assetBond.loanStartTimestamp, 'NotTimeForLoanStart');\\n    require(assetBond.loanStartTimestamp + 18 hours >= block.timestamp, 'TimeOutForCollateralize');\\n  }\\n\\n  function validateLTokenTrasfer() internal pure {}\\n\\n  function validateRepay(\\n    DataStruct.ReserveData storage reserve,\\n    DataStruct.AssetBondData memory assetBond\\n  ) public view {\\n    require(reserve.isActivated, 'ReserveInactivated');\\n    require(block.timestamp < assetBond.liquidationTimestamp, 'LoanExpired');\\n    require(\\n      (assetBond.state == DataStruct.AssetBondState.COLLATERALIZED ||\\n        assetBond.state == DataStruct.AssetBondState.DELINQUENT),\\n      'NotRepayableState'\\n    );\\n  }\\n\\n  function validateLiquidation(\\n    DataStruct.ReserveData storage reserve,\\n    DataStruct.AssetBondData memory assetBond\\n  ) public view {\\n    require(reserve.isActivated, 'ReserveInactivated');\\n    require(assetBond.state == DataStruct.AssetBondState.LIQUIDATED, 'NotLiquidatbleState');\\n  }\\n\\n  function validateSignAssetBond(DataStruct.AssetBondData storage assetBond) public view {\\n    require(assetBond.state == DataStruct.AssetBondState.SETTLED, 'OnlySettledTokenSignAllowed');\\n    require(assetBond.signer == msg.sender, 'NotAllowedSigner');\\n  }\\n\\n  function validateSettleAssetBond(DataStruct.AssetBondData memory assetBond) public view {\\n    require(block.timestamp < assetBond.loanStartTimestamp, 'OnlySettledSigned');\\n    require(assetBond.loanStartTimestamp != assetBond.maturityTimestamp, 'LoanDurationInvalid');\\n  }\\n\\n  function validateTokenId(DataStruct.AssetBondIdData memory idData) internal pure {\\n    require(idData.collateralLatitude < 9000000, 'InvaildLatitude');\\n    require(idData.collateralLongitude < 18000000, 'InvaildLongitude');\\n  }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"components\":[{\"internalType\":\"enum DataStruct.AssetBondState\",\"name\":\"state\",\"type\":\"DataStruct.AssetBondState\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralServiceProvider\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtCeiling\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"couponRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delinquencyRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanStartTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralizeTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maturityTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"ipfsHash\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"signerOpinionHash\",\"type\":\"string\"}],\"internalType\":\"struct DataStruct.AssetBondData\",\"name\":\"assetBond\",\"type\":\"tuple\"}],\"name\":\"validateSettleAssetBond\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Validation","CompilerVersion":"v0.8.3+commit.8d00100c","OptimizationUsed":"1","Runs":"1","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}