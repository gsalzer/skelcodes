{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Staking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.5.13;\\n\\n/*\\n    Main functionality:\\n    \\t2% fee on entry and 2% fee on exit deducted from input/output amount and distributed\\n    \\tto all current share holders proportional to their position in the pool\\n\\n\\tExtended stake bonuses [optional]:\\n\\t\\t30 days = 50%\\n\\t\\t60 days = 125%\\n\\t\\t90 days = 238%\\n\\n\\t    -15% penalty when unstaking extended stake early (distributed to share holders similar to entry/exit fee)\\n\\n\\tFeature #1 - The airdrop:\\n\\t    Admin (or anyone else) can distribute 100% of their deposit among all active share holders\\n\\n\\tFeature #2 - The drip:\\n\\t    Earn \\\"emissionRate\\\" set by admin per second per 1 token deposited into the pool\\n\\t    default emissionRate is 0.00000001 tokens per second per 1 token user has deposited\\n*/\\n\\ncontract Staking {\\n\\tconstructor(address _stakingToken, uint256 _emissionRate) public {\\n\\t\\terc20 = TOKEN(address(_stakingToken)); // set the staking token\\n\\t\\tadmin = msg.sender; // set the admin\\n\\t\\temissionRate = _emissionRate; // set the default emission rate (admin can change this later)\\n\\n\\t\\t// set the extended staking options\\n\\t\\tstakeOptions[0] = StakeOption(30 days, 50); // 50% after 30 days\\n\\t\\tstakeOptions[1] = StakeOption(60 days, 125); // 125% after 60 days\\n\\t\\tstakeOptions[2] = StakeOption(90 days, 238); // 238% after 90 days\\n\\t}\\n\\n\\tusing SafeMath for uint256;\\n\\n\\t// Declare the staking token\\n\\tTOKEN erc20;\\n\\n\\t// Admin is payable so they can withdraw any ETH that may be sent here accidentally\\n\\taddress payable admin;\\n\\n\\t// Total balance of all users in the pool\\n\\t// This has the entry fee already applied so should always be < erc20.balanceOf(address(this))\\n\\tuint256 public totalBalance;\\n\\n\\t// How many staking tokens to reward per second per 1 deposited token\\n\\tuint256 public emissionRate;\\n\\n\\t// All providers aka. the users / stakers in the system\\n\\tmapping(address => Provider) public provider;\\n\\n\\t// All stakes mapped to their owners\\n\\tmapping(address => Stake[]) public stakes;\\n\\n\\t// Extended stake options\\n\\tmapping(uint8 => StakeOption) public stakeOptions;\\n\\n\\t// For admin only functions\\n\\tmodifier isAdmin() {\\n\\t\\trequire(admin == msg.sender, \\\"Admin only function\\\");\\n\\t\\t_;\\n\\t}\\n\\n\\t// Events\\n\\tevent Deposit(address _user, uint256 _amount, uint256 _timestamp);\\n\\tevent Withdraw(address _user, uint256 _amount, uint256 _timestamp);\\n\\tevent ExtendedStake(address _user, uint256 _amount, uint8 _stakeOption, uint256 _timestamp);\\n\\tevent StakeEndWithBonus(address _user, uint256 _bonus, uint256 _timestamp);\\n\\tevent StakeEndWithPenalty(address _user, uint256 _amount, uint256 _timestamp);\\n\\tevent ClaimDrip(address _user, uint256 _amount, uint256 _timestamp);\\n\\tevent Airdrop(address _sender, uint256 _amount, uint256 _timestamp);\\n\\tevent EmissionRateChanged(uint256 _newEmissionRate);\\n\\n\\t// Extended stake\\n\\tstruct Stake {\\n\\t\\tuint256 amount; // amount of tokens staked\\n\\t\\tuint32 unlockDate; // unlocks at this timestamp\\n\\t\\tuint8 stakeBonus; // the +% bonus this stake gives\\n\\t}\\n\\n\\t// Stake option, we have 3 of them\\n\\tstruct StakeOption {\\n\\t\\tuint32 duration;\\n\\t\\tuint8 bonusPercent;\\n\\t}\\n\\n\\t// User data\\n\\tstruct Provider {\\n\\t\\tuint256 commitAmount; // user's extended stake aka. the locked amount\\n\\t\\tuint256 balance; // user's available balance (to extended stake or to withdraw)\\n\\t\\tuint256 dripBalance; // total drips collected before last deposit\\n\\t\\tuint32 lastUpdateAt; // timestamp for last update when dripBalance was calculated\\n\\t}\\n\\n\\t// Function to deposit tokens into the pool\\n\\tfunction depositIntoPool(uint256 _depositAmount) public {\\n\\t\\t// Check and transfer tokens here\\n\\t\\trequire(\\n\\t\\t\\terc20.transferFrom(msg.sender, address(this), _depositAmount) == true,\\n\\t\\t\\t\\\"transferFrom did not succeed. Are we approved?\\\"\\n\\t\\t);\\n\\n\\t\\t// Declare the user\\n\\t\\tProvider storage user = provider[msg.sender];\\n\\n\\t\\tif (user.balance > 0) {\\n\\t\\t\\t// User has previously staked so calculate the new dripBalance\\n\\t\\t\\tuser.dripBalance = dripBalance(msg.sender);\\n\\t\\t}\\n\\n\\t\\t// deduct the 2% entry fee\\n\\t\\tuint256 balanceToAdd = SafeMath.sub(_depositAmount, SafeMath.div(_depositAmount, 50));\\n\\t\\tuser.balance = SafeMath.add(user.balance, balanceToAdd);\\n\\n\\t\\tuser.lastUpdateAt = uint32(now);\\n\\t\\ttotalBalance = SafeMath.add(totalBalance, balanceToAdd);\\n\\n\\t\\temit Deposit(msg.sender, _depositAmount, now);\\n\\t}\\n\\n\\t// Function to withdraw all available balance (including dripped rewards) from the pool\\n\\t// Does not include the extended stake (locked) balances, if any exist\\n\\tfunction withdrawFromPool(uint256 _amount) public {\\n\\t\\tProvider storage user = provider[msg.sender];\\n\\t\\tuint256 availableBalance = SafeMath.sub(user.balance, user.commitAmount);\\n\\t\\trequire(_amount <= availableBalance, \\\"Amount withdrawn exceeds available balance\\\");\\n\\n\\t\\t// Claim all dripped rewards first\\n\\t\\tclaimDrip();\\n\\n\\t\\t// deduct the 2% exit fee\\n\\t\\tuint256 amountToWithdraw = SafeMath.div(SafeMath.mul(_amount, 49), 50);\\n\\n\\t\\tuint256 contractBalance = erc20.balanceOf(address(this));\\n\\n\\t\\t// tokens in the contract * withdraw amount with fee / total balance with fee(s)\\n\\t\\tuint256 amountToSend =\\n\\t\\t\\tSafeMath.div(SafeMath.mul(contractBalance, amountToWithdraw), totalBalance);\\n\\n\\t\\t// Subtract the amount\\n\\t\\tuser.balance = SafeMath.sub(user.balance, _amount);\\n\\t\\ttotalBalance = SafeMath.sub(totalBalance, _amount);\\n\\n\\t\\t// Transfer\\n\\t\\terc20.transfer(msg.sender, amountToSend);\\n\\n\\t\\temit Withdraw(msg.sender, _amount, now);\\n\\t}\\n\\n\\t// Function to enter an extended stake for a fixed period of time\\n\\tfunction extendedStake(uint256 _amount, uint8 _stakeOption) public {\\n\\t\\t// We only have 0, 1, 2 options\\n\\t\\trequire(_stakeOption <= 2, \\\"Invalid staking option\\\");\\n\\n\\t\\tProvider storage user = provider[msg.sender];\\n\\n\\t\\tuint256 availableBalance = SafeMath.sub(user.balance, user.commitAmount);\\n\\t\\trequire(_amount <= availableBalance, \\\"Stake amount exceeds available balance\\\");\\n\\n\\t\\t// Set unlock date and bonus from chosen option\\n\\t\\tuint32 unlockDate = uint32(now) + stakeOptions[_stakeOption].duration;\\n\\t\\tuint8 stakeBonus = stakeOptions[_stakeOption].bonusPercent;\\n\\n\\t\\t// Add as commitAmount\\n\\t\\tuser.commitAmount = SafeMath.add(user.commitAmount, _amount);\\n\\n\\t\\t// Push the new stake\\n\\t\\tstakes[msg.sender].push(Stake(_amount, unlockDate, stakeBonus));\\n\\n\\t\\temit ExtendedStake(msg.sender, _amount, _stakeOption, now);\\n\\t}\\n\\n\\t// Function to exit an extended stake\\n\\t// Distributes reward if unlockDate has passed or deducts a -15% penalty if it's a premature exit\\n\\tfunction claimStake(uint256 _stakeId) public {\\n\\t\\t// Make sure the _stakeId provided is within range\\n\\t\\tuint256 playerStakeCount = stakes[msg.sender].length;\\n\\t\\trequire(_stakeId < playerStakeCount, \\\"Stake does not exist\\\");\\n\\n\\t\\t// Declare a user's stake & require it to have an amount\\n\\t\\tStake memory stake = stakes[msg.sender][_stakeId];\\n\\t\\trequire(stake.amount > 0, \\\"Invalid stake amount\\\");\\n\\n\\t\\t// Maintains the stake array length\\n\\t\\tif (playerStakeCount > 1) {\\n\\t\\t\\tstakes[msg.sender][_stakeId] = stakes[msg.sender][playerStakeCount - 1];\\n\\t\\t}\\n\\t\\tdelete stakes[msg.sender][playerStakeCount - 1];\\n\\t\\tstakes[msg.sender].length--;\\n\\n\\t\\tProvider storage user = provider[msg.sender];\\n\\n\\t\\tif (stake.unlockDate <= now) {\\n\\t\\t\\t// Stake duration has passed here. Distribute the stakeBonus reward!\\n\\t\\t\\tuint256 balanceToAdd = SafeMath.div(SafeMath.mul(stake.amount, stake.stakeBonus), 100);\\n\\t\\t\\ttotalBalance = SafeMath.add(totalBalance, balanceToAdd);\\n\\t\\t\\tuser.commitAmount = SafeMath.sub(user.commitAmount, stake.amount);\\n\\t\\t\\tuser.balance = SafeMath.add(user.balance, balanceToAdd);\\n\\t\\t\\temit StakeEndWithBonus(msg.sender, balanceToAdd, now);\\n\\t\\t} else {\\n\\t\\t\\t// Stake duration has not passed. Apply the 15% penalty\\n\\t\\t\\tuint256 weightToRemove = SafeMath.div(SafeMath.mul(3, stake.amount), 20);\\n\\t\\t\\tuser.balance = SafeMath.sub(user.balance, weightToRemove);\\n\\t\\t\\ttotalBalance = SafeMath.sub(totalBalance, weightToRemove);\\n\\t\\t\\tuser.commitAmount = SafeMath.sub(user.commitAmount, stake.amount);\\n\\t\\t\\temit StakeEndWithPenalty(msg.sender, weightToRemove, now);\\n\\t\\t}\\n\\t}\\n\\n\\t// Function to claim dripped rewards\\n\\tfunction claimDrip() public {\\n\\t\\tProvider storage user = provider[msg.sender];\\n\\t\\tuint256 amountToSend = dripBalance(msg.sender);\\n\\t\\tuser.dripBalance = 0;\\n\\t\\tuser.lastUpdateAt = uint32(now);\\n\\t\\terc20.transfer(msg.sender, amountToSend);\\n\\t\\temit ClaimDrip(msg.sender, amountToSend, now);\\n\\t}\\n\\n\\t// Airdrop to pool\\n\\t// Anyone can airdrop tokens into the pool. Since withdrawFromPool() uses contractBalance = erc20.balanceOf(address(this))\\n\\t// in its calculations, everything extra sent to our contract will get distributed proportionally when user withdraws from pool\\n\\tfunction airdrop(uint256 _amount) external {\\n\\t\\trequire(\\n\\t\\t\\terc20.transferFrom(msg.sender, address(this), _amount) == true,\\n\\t\\t\\t\\\"transferFrom did not succeed. Are we approved?\\\"\\n\\t\\t);\\n\\t\\temit Airdrop(msg.sender, _amount, now);\\n\\t}\\n\\n\\t// Admin can edit the emissionRate\\n\\tfunction changeEmissionRate(uint256 _emissionRate) external isAdmin {\\n\\t\\tif (emissionRate != _emissionRate) {\\n\\t\\t\\temissionRate = _emissionRate;\\n\\t\\t\\temit EmissionRateChanged(_emissionRate);\\n\\t\\t}\\n\\t}\\n\\n\\t// Admin can withdraw any ETH that might be accidentally sent here\\n\\tfunction withdrawETH() external isAdmin {\\n\\t\\tadmin.transfer(address(this).balance);\\n\\t}\\n\\n\\t// transfer admin to another address\\n\\tfunction transferAdmin(address _newAdmin) external isAdmin {\\n\\t\\tadmin = address(uint160(_newAdmin));\\n\\t}\\n\\n\\t// Admin can withdraw any ERC20 token that might be accidentally sent here\\n\\t// Excluding of course the staking token itself (funds are safu)\\n\\tfunction withdrawERC20(TOKEN token) public isAdmin {\\n\\t\\trequire(address(token) != address(0), \\\"Invalid address\\\");\\n\\t\\trequire(address(token) != address(erc20), \\\"Cannot withdraw the staking token\\\");\\n\\t\\tuint256 balance = token.balanceOf(address(this));\\n\\t\\ttoken.transfer(admin, balance);\\n\\t}\\n\\n\\t// Calculates the undebited drip rewards\\n\\t// Formula: Seconds staked X emission rate X user's total deposit / 10^18\\n\\tfunction _unDebitedDrips(Provider memory user) internal view returns (uint256) {\\n\\t\\t// (now - user.lastUpdateAt) * emissionRate * user.balance / 1e18\\n\\t\\treturn\\n\\t\\t\\tSafeMath.div(\\n\\t\\t\\t\\tSafeMath.mul(\\n\\t\\t\\t\\t\\tSafeMath.mul(SafeMath.sub(now, uint256(user.lastUpdateAt)), emissionRate),\\n\\t\\t\\t\\t\\tuser.balance\\n\\t\\t\\t\\t),\\n\\t\\t\\t\\t1e18\\n\\t\\t\\t);\\n\\t}\\n\\n\\t// Calculte how many dripped tokens an address currently has\\n\\tfunction dripBalance(address _user) public view returns (uint256) {\\n\\t\\tProvider memory user = provider[_user];\\n\\t\\treturn SafeMath.add(user.dripBalance, _unDebitedDrips(user));\\n\\t}\\n\\n\\t// Fetch all active stakes for a given user\\n\\tfunction stakesOf(address _user) public view returns (uint256[3][] memory) {\\n\\t\\tuint256 userStakeCount = stakes[_user].length;\\n\\t\\tuint256[3][] memory data = new uint256[3][](userStakeCount);\\n\\t\\tfor (uint256 i = 0; i < userStakeCount; i++) {\\n\\t\\t\\tStake memory stake = stakes[_user][i];\\n\\t\\t\\tdata[i][0] = stake.amount;\\n\\t\\t\\tdata[i][1] = stake.unlockDate;\\n\\t\\t\\tdata[i][2] = stake.stakeBonus;\\n\\t\\t}\\n\\t\\treturn (data);\\n\\t}\\n}\\n\\ncontract TOKEN {\\n\\tfunction balanceOf(address account) external view returns (uint256);\\n\\n\\tfunction transfer(address recipient, uint256 amount) external returns (bool);\\n\\n\\tfunction transferFrom(\\n\\t\\taddress sender,\\n\\t\\taddress recipient,\\n\\t\\tuint256 amount\\n\\t) external returns (bool);\\n}\\n\\nlibrary SafeMath {\\n\\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n\\t\\tif (a == 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tc = a * b;\\n\\t\\tassert(c / a == b);\\n\\t\\treturn c;\\n\\t}\\n\\n\\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\treturn a / b;\\n\\t}\\n\\n\\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\tassert(b <= a);\\n\\t\\treturn a - b;\\n\\t}\\n\\n\\tfunction add(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n\\t\\tc = a + b;\\n\\t\\tassert(c >= a);\\n\\t\\treturn c;\\n\\t}\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakingToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_emissionRate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"Airdrop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"ClaimDrip\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newEmissionRate\",\"type\":\"uint256\"}],\"name\":\"EmissionRateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_stakeOption\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"ExtendedStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_bonus\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"StakeEndWithBonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"StakeEndWithPenalty\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"airdrop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_emissionRate\",\"type\":\"uint256\"}],\"name\":\"changeEmissionRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimDrip\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakeId\",\"type\":\"uint256\"}],\"name\":\"claimStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_depositAmount\",\"type\":\"uint256\"}],\"name\":\"depositIntoPool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"dripBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"emissionRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_stakeOption\",\"type\":\"uint8\"}],\"name\":\"extendedStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"provider\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"commitAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dripBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"lastUpdateAt\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"stakeOptions\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"duration\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"bonusPercent\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"unlockDate\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"stakeBonus\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"stakesOf\",\"outputs\":[{\"internalType\":\"uint256[3][]\",\"name\":\"\",\"type\":\"uint256[3][]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract TOKEN\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdrawERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFromPool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Staking","CompilerVersion":"v0.5.13+commit.5b0b510c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000009b02dd390a603add5c07f9fd9175b7dabe8d63b700000000000000000000000000000000000000000000000000000003e16926aa","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}