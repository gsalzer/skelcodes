{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {_setPendingOwner} and {_acceptOwner}.\r\n */\r\ncontract Ownable {\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    address payable public owner;\r\n\r\n    /**\r\n     * @dev Returns the address of the current pending owner.\r\n     */\r\n    address payable public pendingOwner;\r\n\r\n    event NewOwner(address indexed previousOwner, address indexed newOwner);\r\n    event NewPendingOwner(\r\n        address indexed oldPendingOwner,\r\n        address indexed newPendingOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner == msg.sender, \"onlyOwner: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    function __Ownable_init() internal {\r\n        owner = msg.sender;\r\n        emit NewOwner(address(0), msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer contract control to a new owner. The newPendingOwner must call `_acceptOwner` to finish the transfer.\r\n     * @param newPendingOwner New pending owner.\r\n     *\r\n     * TODO: Maybe the new pending owenr should not be the current owner at the same time.\r\n     */\r\n    function _setPendingOwner(address payable newPendingOwner)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(\r\n            newPendingOwner != address(0),\r\n            \"_setPendingOwner: New owenr can not be zero address!\"\r\n        );\r\n        require(\r\n            newPendingOwner != pendingOwner,\r\n            \"_setPendingOwner: This owner has been set!\"\r\n        );\r\n\r\n        // Gets current owner.\r\n        address oldPendingOwner = pendingOwner;\r\n\r\n        // Sets new pending owner.\r\n        pendingOwner = newPendingOwner;\r\n\r\n        emit NewPendingOwner(oldPendingOwner, newPendingOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Accepts the admin rights, but only for pendingOwenr.\r\n     */\r\n    function _acceptOwner() external {\r\n        require(\r\n            msg.sender == pendingOwner,\r\n            \"_acceptOwner: Only for pending owner!\"\r\n        );\r\n\r\n        // Gets current values for events.\r\n        address oldOwner = owner;\r\n        address oldPendingOwner = pendingOwner;\r\n\r\n        // Set the new contract owner.\r\n        owner = pendingOwner;\r\n\r\n        // Clear the pendingOwner.\r\n        pendingOwner = address(0);\r\n\r\n        emit NewOwner(oldOwner, owner);\r\n        emit NewPendingOwner(oldPendingOwner, pendingOwner);\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\r\n    }\r\n\r\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\r\n    }\r\n\r\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\r\n    }\r\n\r\n    function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require(y > 0, \"ds-math-div-overflow\");\r\n        z = x / y;\r\n    }\r\n}\r\n\r\nlibrary SafeRatioMath {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 private constant BASE = 10**18;\r\n\r\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = x.mul(y).div(BASE);\r\n    }\r\n\r\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = x.mul(BASE).div(y);\r\n    }\r\n\r\n    function rpow(\r\n        uint256 x,\r\n        uint256 n,\r\n        uint256 base\r\n    ) internal pure returns (uint256 z) {\r\n        assembly {\r\n            switch x\r\n                case 0 {\r\n                    switch n\r\n                        case 0 {\r\n                            z := base\r\n                        }\r\n                        default {\r\n                            z := 0\r\n                        }\r\n                }\r\n                default {\r\n                    switch mod(n, 2)\r\n                        case 0 {\r\n                            z := base\r\n                        }\r\n                        default {\r\n                            z := x\r\n                        }\r\n                    let half := div(base, 2) // for rounding.\r\n\r\n                    for {\r\n                        n := div(n, 2)\r\n                    } n {\r\n                        n := div(n, 2)\r\n                    } {\r\n                        let xx := mul(x, x)\r\n                        if iszero(eq(div(xx, x), x)) {\r\n                            revert(0, 0)\r\n                        }\r\n                        let xxRound := add(xx, half)\r\n                        if lt(xxRound, xx) {\r\n                            revert(0, 0)\r\n                        }\r\n                        x := div(xxRound, base)\r\n                        if mod(n, 2) {\r\n                            let zx := mul(z, x)\r\n                            if and(\r\n                                iszero(iszero(x)),\r\n                                iszero(eq(div(zx, x), z))\r\n                            ) {\r\n                                revert(0, 0)\r\n                            }\r\n                            let zxRound := add(zx, half)\r\n                            if lt(zxRound, zx) {\r\n                                revert(0, 0)\r\n                            }\r\n                            z := div(zxRound, base)\r\n                        }\r\n                    }\r\n                }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external;\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external;\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    // This function is not a standard ERC20 interface, just for compitable with market.\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\ninterface IInterestRateModel {\r\n    function blocksPerYear() external view returns (uint256);\r\n}\r\n\r\ninterface IPriceOracle {\r\n    /**\r\n     * @notice Get the underlying price of a iToken asset\r\n     * @param _iToken The iToken to get the underlying price of\r\n     * @return The underlying asset price mantissa (scaled by 1e18).\r\n     *  Zero means the price is unavailable.\r\n     */\r\n    function getUnderlyingPrice(IiToken _iToken)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @notice Get the price of a underlying asset\r\n     * @param _iToken The iToken to get the underlying price of\r\n     * @return The underlying asset price mantissa (scaled by 1e18).\r\n     *  Zero means the price is unavailable and whether the price is valid.\r\n     */\r\n    function getUnderlyingPriceAndStatus(IiToken _iToken)\r\n        external\r\n        view\r\n        returns (uint256, bool);\r\n    function getAssetPriceStatus(IiToken _iToken) external view returns (bool);\r\n}\r\n\r\ninterface IRewardDistributor {\r\n    function updateDistributionState(IiToken _iToken, bool _isBorrow) external;\r\n\r\n    function updateReward(\r\n        IiToken _iToken,\r\n        address _account,\r\n        bool _isBorrow\r\n    ) external;\r\n\r\n    function updateRewardBatch(\r\n        address[] memory _holders,\r\n        IiToken[] memory _iTokens\r\n    ) external;\r\n\r\n    function reward(address _account) external view returns (uint256);\r\n}\r\n\r\ninterface IController {\r\n    function getAlliTokens() external view returns (IiToken[] memory);\r\n\r\n    function getEnteredMarkets(address _account)\r\n        external\r\n        view\r\n        returns (IiToken[] memory);\r\n    \r\n    function getBorrowedAssets(address _account) external view returns (IiToken[] memory);\r\n\r\n    function hasEnteredMarket(address _account, IiToken _iToken)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function hasBorrowed(address _account, IiToken _iToken)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function priceOracle() external view returns (IPriceOracle);\r\n\r\n    function markets(IiToken _asset)\r\n        external\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            bool,\r\n            bool,\r\n            bool\r\n        );\r\n\r\n    function calcAccountEquity(address _account)\r\n        external\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        );\r\n\r\n    function beforeRedeem(\r\n        address iToken,\r\n        address redeemer,\r\n        uint256 redeemAmount\r\n    ) external returns (bool);\r\n\r\n    function closeFactorMantissa() external view returns (uint256);\r\n\r\n    function liquidationIncentiveMantissa() external view returns (uint256);\r\n\r\n    function rewardDistributor() external view returns (address);\r\n}\r\n\r\ninterface IiToken {\r\n    function decimals() external view returns (uint8);\r\n\r\n    function balanceOf(address _account) external view returns (uint256);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function isSupported() external view returns (bool);\r\n    \r\n    function isiToken() external view returns (bool);\r\n\r\n    function underlying() external view returns (IERC20);\r\n\r\n    function getCash() external view returns (uint256);\r\n\r\n    function supplyRatePerBlock() external view returns (uint256);\r\n\r\n    function borrowRatePerBlock() external view returns (uint256);\r\n\r\n    function balanceOfUnderlying(address _account) external returns (uint256);\r\n\r\n    function borrowBalanceStored(address _account)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function borrowBalanceCurrent(address _account) external returns (uint256);\r\n\r\n    function totalBorrowsCurrent() external returns (uint256);\r\n\r\n    function totalBorrows() external view returns (uint256);\r\n\r\n    function exchangeRateStored() external view returns (uint256);\r\n\r\n    function exchangeRateCurrent() external returns (uint256);\r\n\r\n    function updateInterest() external returns (bool);\r\n\r\n    function interestRateModel() external view returns (IInterestRateModel);\r\n}\r\n\r\ncontract LendingDataV2 is Ownable {\r\n    using SafeMath for uint256;\r\n    using SafeRatioMath for uint256;\r\n    bool private initialized;\r\n\r\n    uint256 constant BASE = 1e18;\r\n\r\n    uint256 public blocksPerYear;\r\n    uint256 constant daysPerYear = 365;\r\n\r\n    IController public controller;\r\n    IiToken public priceToken;\r\n\r\n    IiToken[] public tokens;\r\n    uint256[] public amounts;\r\n    uint8[] public decimals;\r\n\r\n    constructor(\r\n        address _controller,\r\n        IiToken _priceToken\r\n    ) public {\r\n        initialize(_controller, _priceToken);\r\n    }\r\n\r\n    function initialize(\r\n        address _controller,\r\n        IiToken _priceToken\r\n    ) public {\r\n        require(!initialized, \"initialize: Already initialized!\");\r\n        __Ownable_init();\r\n        controller = IController(_controller);\r\n        priceToken = _priceToken;\r\n        initialized = true;\r\n    }\r\n\r\n    function setController(IController _newController) external onlyOwner {\r\n        // Sets to new controller.\r\n        controller = _newController;\r\n    }\r\n\r\n    function setPriceToken(IiToken _newAsset) external onlyOwner {\r\n        priceToken = _newAsset;\r\n    }\r\n\r\n    struct totalValueLocalVars {\r\n        IiToken[] iTokens;\r\n        IController controller;\r\n        IPriceOracle priceOracle;\r\n        uint256 assetPrice;\r\n        uint256 collateralFactor;\r\n        uint256 sumCollateral;\r\n        uint256 sumBorrowed;\r\n        uint256 supplyValue;\r\n        uint256 collateralVaule;\r\n        uint256 borrowValue;\r\n    }\r\n\r\n    function getAccountTotalValue(address _account)\r\n        external\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        totalValueLocalVars memory _var;\r\n        _var.controller = controller;\r\n        _var.iTokens = _var.controller.getAlliTokens();\r\n        _var.priceOracle = _var.controller.priceOracle();\r\n        for (uint256 i = 0; i < _var.iTokens.length; i++) {\r\n            _var.assetPrice = _var.priceOracle.getUnderlyingPrice(\r\n                _var.iTokens[i]\r\n            );\r\n            _var.supplyValue = _var.supplyValue.add(\r\n                _var.iTokens[i].balanceOfUnderlying(_account).mul(\r\n                    _var.assetPrice\r\n                )\r\n            );\r\n            (_var.collateralFactor, , , , , , ) = controller.markets(_var.iTokens[i]);\r\n            if (\r\n                _var.controller.hasEnteredMarket(_account, _var.iTokens[i]) &&\r\n                _var.collateralFactor > 0\r\n            )\r\n                _var.collateralVaule = _var.collateralVaule.add(\r\n                    _var.iTokens[i].balanceOfUnderlying(_account).mul(\r\n                        _var.assetPrice\r\n                    )\r\n                );\r\n\r\n            if (_var.controller.hasBorrowed(_account, _var.iTokens[i]))\r\n                _var.borrowValue = _var.borrowValue.add(\r\n                    _var.iTokens[i].borrowBalanceCurrent(_account).mul(\r\n                        _var.assetPrice\r\n                    )\r\n                );\r\n        }\r\n        _var.assetPrice = getAssetUSDPrice(priceToken);\r\n        if (_var.assetPrice == 0) return (0, 0, 0, 0);\r\n\r\n        _var.supplyValue = _var.supplyValue.div(_var.assetPrice);\r\n        _var.collateralVaule = _var.collateralVaule.div(_var.assetPrice);\r\n        _var.borrowValue = _var.borrowValue.div(_var.assetPrice);\r\n        (, , _var.sumCollateral, _var.sumBorrowed) = calcAccountEquity(_account);\r\n        return (\r\n            _var.supplyValue,\r\n            _var.collateralVaule,\r\n            _var.borrowValue,\r\n            _var.sumBorrowed == 0 ? 0 : _var.sumCollateral.rdiv(_var.sumBorrowed)\r\n        );\r\n    }\r\n\r\n    function getAccountAssetStatus(IiToken _asset, address _account, uint256 _type) internal returns (bool, uint256) {\r\n        uint256 _balance;\r\n        if (_type == 0) {\r\n            _balance = _asset.balanceOfUnderlying(_account);\r\n            return ( _balance == 0 ? false : true, _balance);\r\n        }\r\n\r\n        bool _isiToken = _asset.isiToken();\r\n        if ((_type & 1 > 0 && _isiToken) || (_type & 2 > 0 && !_isiToken))\r\n            _balance = _asset.borrowBalanceCurrent(_account);\r\n\r\n        return ( _balance == 0 ? false : true, _balance);\r\n    }\r\n\r\n    function getAccountAssets(address _account, uint256 _type)\r\n        internal\r\n        returns (\r\n            IiToken[] memory,\r\n            uint256[] memory,\r\n            uint8[] memory\r\n        )\r\n    {\r\n        delete tokens;\r\n        delete amounts;\r\n        delete decimals;\r\n        uint256 _balance;\r\n        bool _status;\r\n        IiToken[] memory _iTokens = controller.getAlliTokens();\r\n        for (uint256 i = 0; i < _iTokens.length; i++) {\r\n            (_status, _balance) = getAccountAssetStatus(_iTokens[i], _account, _type);\r\n            if (_status) {\r\n                tokens.push(_iTokens[i]);\r\n                amounts.push(_balance);\r\n                decimals.push(_iTokens[i].decimals());\r\n            }\r\n        }\r\n\r\n        return (tokens, amounts, decimals);\r\n    }\r\n\r\n    \r\n    function getAccountSupplyTokens(address _account)\r\n        public\r\n        returns (\r\n            IiToken[] memory,\r\n            uint256[] memory,\r\n            uint8[] memory\r\n        )\r\n    {\r\n        return getAccountAssets(_account, 0);\r\n    }\r\n\r\n    function getAccountBorrowTokens(address _account)\r\n        public\r\n        returns (\r\n            IiToken[] memory,\r\n            uint256[] memory,\r\n            uint8[] memory\r\n        )\r\n    {\r\n        return getAccountAssets(_account, 1);\r\n    }\r\n\r\n    function getAccountMSDTokens(address _account)\r\n        public\r\n        returns (\r\n            IiToken[] memory,\r\n            uint256[] memory,\r\n            uint8[] memory\r\n        )\r\n    {\r\n        return getAccountAssets(_account, 2);\r\n    }\r\n\r\n    function getAccountTokens(address _account)\r\n        external\r\n        returns (\r\n            IiToken[] memory _supplyTokens,\r\n            uint256[] memory _supplyAmounts,\r\n            uint8[] memory _supplyDecimals,\r\n            IiToken[] memory _borrowTokens,\r\n            uint256[] memory _borrowAmounts,\r\n            uint8[] memory _borrowDecimals\r\n        )\r\n    {\r\n        (\r\n            _supplyTokens,\r\n            _supplyAmounts,\r\n            _supplyDecimals\r\n        ) = getAccountAssets(_account, 0);\r\n        (\r\n            _borrowTokens,\r\n            _borrowAmounts,\r\n            _borrowDecimals\r\n        ) = getAccountAssets(_account, 3);\r\n    }\r\n\r\n    function getAssetUSDPrice(IiToken _asset) public view returns (uint256) {\r\n        uint256 _USDPrice = controller.priceOracle().getUnderlyingPrice(\r\n                priceToken\r\n            );\r\n        if (_USDPrice == 0) return 0;\r\n\r\n        uint256 _assetUSDPrice = controller.priceOracle()\r\n                .getUnderlyingPrice(_asset)\r\n                .rdiv(_USDPrice);\r\n        uint8 _assetDecimals = _asset.decimals();\r\n        uint8 _priceTokenDecimals = priceToken.decimals();\r\n\r\n        return\r\n            _assetDecimals > _priceTokenDecimals\r\n                ? _assetUSDPrice.mul(\r\n                    10**(uint256(_assetDecimals - _priceTokenDecimals))\r\n                )\r\n                : _assetUSDPrice.div(\r\n                    10**(uint256(_priceTokenDecimals - _assetDecimals))\r\n                );\r\n    }\r\n\r\n    function getSupplyTokenData(IiToken _asset)\r\n        public\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        (uint256 _collateralFactor, , , , , , ) = controller.markets(_asset);\r\n        if (_asset.isiToken()) {\r\n            uint256 _blocksPerDay = _asset.supplyRatePerBlock() * _asset.interestRateModel().blocksPerYear() / daysPerYear;\r\n            return (\r\n                (_blocksPerDay + BASE).rpow(\r\n                    daysPerYear,\r\n                    BASE\r\n                ) - BASE,\r\n                _collateralFactor,\r\n                getAssetUSDPrice(_asset)\r\n            );\r\n        }\r\n        return (0, _collateralFactor, getAssetUSDPrice(_asset));\r\n    }\r\n\r\n    function getAccountSupplyInfo(\r\n        IiToken _asset,\r\n        address _account,\r\n        uint256 _safeMaxFactor\r\n    )\r\n        public\r\n        returns (\r\n            uint256 _assetPrice,\r\n            bool _asCollateral,\r\n            bool _executed,\r\n            bool _accountAvailable\r\n        )\r\n    {\r\n        _asCollateral = controller.hasEnteredMarket(_account, _asset);\r\n        if (!_asCollateral) {\r\n            (uint256 _collateralFactor, , , , , , ) = controller.markets(_asset);\r\n            _executed = _collateralFactor > 0 ? true : false;\r\n            _accountAvailable = true;\r\n        } else {\r\n            _executed = canAccountRemoveFromCollateral(\r\n                _asset,\r\n                _account,\r\n                _safeMaxFactor\r\n            );\r\n            _accountAvailable = getAccountAvailable(_account);\r\n        }\r\n        \r\n        uint256 _USDPrice = controller.priceOracle().getUnderlyingPrice(priceToken);\r\n        _assetPrice = _USDPrice == 0 ? 0 : getBalance(_asset, _account).mul(controller.priceOracle().getUnderlyingPrice(_asset)).div(_USDPrice);\r\n    }\r\n\r\n    struct removeFromCollateralLocalVars {\r\n        uint256 assetPrice;\r\n        uint256 collateralFactor;\r\n        uint256 accountEquity;\r\n        uint256 sumCollateral;\r\n        uint256 sumBorrowed;\r\n        uint256 safeAvailableToken;\r\n    }\r\n\r\n    function canAccountRemoveFromCollateral(\r\n        IiToken _asset,\r\n        address _account,\r\n        uint256 _safeMaxFactor\r\n    ) public returns (bool) {\r\n        if (getAccountBorrowStatus(_account)) {\r\n            removeFromCollateralLocalVars memory _var;\r\n\r\n            (_var.collateralFactor, , , , , , ) = controller.markets(_asset);\r\n            (\r\n                _var.accountEquity,\r\n                ,\r\n                _var.sumCollateral,\r\n                _var.sumBorrowed\r\n            ) = calcAccountEquity(_account);\r\n            if (_var.collateralFactor == 0 && _var.accountEquity > 0)\r\n                return true;\r\n\r\n            _var.assetPrice = controller.priceOracle()\r\n                .getUnderlyingPrice(_asset);\r\n            if (\r\n                _var.assetPrice == 0 ||\r\n                _var.collateralFactor == 0 ||\r\n                _var.accountEquity == 0\r\n            ) return false;\r\n\r\n            _var.safeAvailableToken = _var.sumCollateral >\r\n                _var.sumBorrowed.rdiv(_safeMaxFactor)\r\n                ? _var.sumCollateral.sub(_var.sumBorrowed.rdiv(_safeMaxFactor))\r\n                : 0;\r\n            _var.safeAvailableToken = _var\r\n                .safeAvailableToken\r\n                .div(_var.assetPrice)\r\n                .rdiv(_var.collateralFactor);\r\n\r\n            return\r\n                _var.safeAvailableToken >=\r\n                IiToken(_asset).balanceOfUnderlying(_account);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    struct supplyLocalVars {\r\n        uint256 cash;\r\n        uint256 assetPrice;\r\n        uint256 collateralFactor;\r\n        uint256 supplyCapacity;\r\n        uint256 totalUnderlying;\r\n        uint256 accountEquity;\r\n        uint256 sumCollateral;\r\n        uint256 sumBorrowed;\r\n        uint256 availableToken;\r\n        uint256 safeAvailableToken;\r\n        uint256 suppliedBalance;\r\n        uint256 accountBalance;\r\n        uint256 maxMintAmount;\r\n        uint256 availableToWithdraw;\r\n        uint256 safeAvailableToWithdraw;\r\n        uint256 iTokenBalance;\r\n        uint8 decimals;\r\n    }\r\n\r\n    function getAccountSupplyData(\r\n        IiToken _asset,\r\n        address _account,\r\n        uint256 _safeMaxFactor\r\n    )\r\n        public\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint8\r\n        )\r\n    {\r\n        supplyLocalVars memory _var;\r\n        _var.suppliedBalance = _asset.balanceOfUnderlying(_account);\r\n        _var.accountBalance = getBalance(_asset, _account);\r\n        _var.iTokenBalance = _asset.balanceOf(_account);\r\n        _var.decimals = _asset.decimals();\r\n\r\n        _var.maxMintAmount = 0;\r\n        (_var.collateralFactor, , , _var.supplyCapacity, , ,) = controller.markets(\r\n            _asset\r\n        );\r\n        _var.totalUnderlying = _asset.totalSupply().rmul(\r\n            _asset.exchangeRateStored()\r\n        );\r\n        if (_var.supplyCapacity > _var.totalUnderlying) {\r\n            _var.maxMintAmount = _var.supplyCapacity.sub(_var.totalUnderlying);\r\n            _var.maxMintAmount = _var.maxMintAmount > _var.accountBalance\r\n                ? _var.accountBalance\r\n                : _var.maxMintAmount;\r\n        }\r\n\r\n        if (_asset.isiToken()) {\r\n            _var.cash = _asset.getCash();\r\n            _var.availableToWithdraw = _var.cash > _var.suppliedBalance\r\n                ? _var.suppliedBalance\r\n                : _var.cash;\r\n        }\r\n        _var.safeAvailableToWithdraw = _var.availableToWithdraw;\r\n\r\n        if (\r\n            controller.hasEnteredMarket(_account, _asset) &&\r\n            getAccountBorrowStatus(_account)\r\n        ) {\r\n            (\r\n                _var.accountEquity,\r\n                ,\r\n                _var.sumCollateral,\r\n                _var.sumBorrowed\r\n            ) = calcAccountEquity(_account);\r\n            if (_var.collateralFactor == 0 && _var.accountEquity > 0)\r\n                return (\r\n                    _var.suppliedBalance,\r\n                    _var.accountBalance,\r\n                    _var.maxMintAmount,\r\n                    _var.availableToWithdraw,\r\n                    _var.safeAvailableToWithdraw,\r\n                    _var.iTokenBalance,\r\n                    _var.decimals\r\n                );\r\n\r\n            _var.assetPrice = controller.priceOracle()\r\n                .getUnderlyingPrice(_asset);\r\n            if (\r\n                _var.assetPrice == 0 ||\r\n                _var.collateralFactor == 0 ||\r\n                _var.accountEquity == 0\r\n            )\r\n                return (\r\n                    _var.suppliedBalance,\r\n                    _var.accountBalance,\r\n                    _var.maxMintAmount,\r\n                    0,\r\n                    0,\r\n                    0,\r\n                    _var.decimals\r\n                );\r\n\r\n            _var.availableToken = _var.accountEquity.div(_var.assetPrice).rdiv(\r\n                _var.collateralFactor\r\n            );\r\n            _var.availableToWithdraw = _var.availableToWithdraw >\r\n                _var.availableToken\r\n                ? _var.availableToken\r\n                : _var.availableToWithdraw;\r\n\r\n            _var.safeAvailableToken = _var.sumCollateral >\r\n                _var.sumBorrowed.rdiv(_safeMaxFactor)\r\n                ? _var.sumCollateral.sub(_var.sumBorrowed.rdiv(_safeMaxFactor))\r\n                : 0;\r\n            _var.safeAvailableToken = _var\r\n                .safeAvailableToken\r\n                .div(_var.assetPrice)\r\n                .rdiv(_var.collateralFactor);\r\n            _var.safeAvailableToWithdraw = _var.safeAvailableToWithdraw >\r\n                _var.safeAvailableToken\r\n                ? _var.safeAvailableToken\r\n                : _var.safeAvailableToWithdraw;\r\n\r\n            _var.safeAvailableToWithdraw = _var.safeAvailableToWithdraw >\r\n                _var.availableToWithdraw\r\n                ? _var.availableToWithdraw\r\n                : _var.safeAvailableToWithdraw;\r\n        }\r\n\r\n        return (\r\n            _var.suppliedBalance,\r\n            _var.accountBalance,\r\n            _var.maxMintAmount,\r\n            _var.availableToWithdraw,\r\n            _var.safeAvailableToWithdraw,\r\n            _var.iTokenBalance,\r\n            _var.decimals\r\n        );\r\n    }\r\n\r\n    function getAccountBorrowValue(address _account) public returns (uint256 _borrowValue) {\r\n        IiToken[] memory _iTokens = controller.getAlliTokens();\r\n        IPriceOracle _priceOracle = controller.priceOracle();\r\n        for (uint256 i = 0; i < _iTokens.length; i++) {\r\n            if (controller.hasBorrowed(_account, _iTokens[i]))\r\n                _borrowValue = _borrowValue.add(\r\n                    _iTokens[i].borrowBalanceCurrent(_account).mul(_priceOracle.getUnderlyingPrice(_iTokens[i]))\r\n                );\r\n        }\r\n        return _borrowValue;\r\n    }\r\n\r\n    function getAccountBorrowStatus(address _account)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        IiToken[] memory _iTokens = controller.getAlliTokens();\r\n        for (uint256 i = 0; i < _iTokens.length; i++)\r\n            if (_iTokens[i].borrowBalanceStored(_account) > 0)\r\n                return true;\r\n\r\n        return false;\r\n    }\r\n\r\n    function getBorrowTokenData(IiToken _asset)\r\n        public\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        if (_asset.isSupported()) {\r\n            (, uint256 _borrowFactor, , , , , ) = controller.markets(_asset);\r\n            return (\r\n                _asset.getCash(),\r\n                _borrowFactor,\r\n                (_asset.borrowRatePerBlock() * _asset.interestRateModel().blocksPerYear() / daysPerYear + BASE).rpow(\r\n                    daysPerYear,\r\n                    BASE\r\n                ) - BASE,\r\n                getAssetUSDPrice(_asset)\r\n            );\r\n        }\r\n        return (0, 0, 0, 0);\r\n    }\r\n\r\n    struct borrowInfoLocalVars {\r\n        IPriceOracle oracle;\r\n        uint256 assetPrice;\r\n        uint256 USDPrice;\r\n        uint256 accountEquity;\r\n        uint256 sumCollateral;\r\n        uint256 sumBorrowed;\r\n        uint256 borrowFactor;\r\n        uint256 maxBorrowValue;\r\n        uint256 safeBorrowValue;\r\n        bool accountAvailable;\r\n    }\r\n\r\n    function getAccountBorrowInfo(\r\n        IiToken _asset,\r\n        address _account,\r\n        uint256 _safeMaxFactor\r\n    )\r\n        public\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            bool\r\n        )\r\n    {\r\n        borrowInfoLocalVars memory _var;\r\n        _var.oracle = controller.priceOracle();\r\n        _var.USDPrice = _var.oracle.getUnderlyingPrice(priceToken);\r\n        if (_var.oracle.getAssetPriceStatus(_asset))\r\n            _var.accountAvailable = getAccountAvailable(_account);\r\n\r\n        if (_var.USDPrice == 0) return (0, 0, 0, _var.accountAvailable);\r\n\r\n        IiToken(_asset).updateInterest();\r\n        (\r\n            _var.accountEquity,\r\n            ,\r\n            _var.sumCollateral,\r\n            _var.sumBorrowed\r\n        ) = calcAccountEquity(_account);\r\n        (, _var.borrowFactor, , , , , ) = controller.markets(_asset);\r\n\r\n        _var.maxBorrowValue = _var.accountEquity.rmul(_var.borrowFactor).div(\r\n            _var.USDPrice\r\n        );\r\n        _var.safeBorrowValue = _var.sumCollateral.rmul(_safeMaxFactor) >\r\n            _var.sumBorrowed\r\n            ? _var.sumCollateral.rmul(_safeMaxFactor).sub(_var.sumBorrowed)\r\n            : 0;\r\n        _var.safeBorrowValue = _var.safeBorrowValue.rmul(_var.borrowFactor).div(\r\n            _var.USDPrice\r\n        );\r\n\r\n        _var.assetPrice = _var.oracle.getUnderlyingPrice(_asset);\r\n        return (\r\n            _var.maxBorrowValue,\r\n            _var.safeBorrowValue,\r\n            getBalance(_asset, _account).mul(_var.assetPrice).div(_var.USDPrice),\r\n            _var.accountAvailable\r\n        );\r\n    }\r\n\r\n    struct borrowLocalVars {\r\n        uint256 cash;\r\n        uint256 assetPrice;\r\n        uint256 borrowCapacity;\r\n        uint256 accountEquity;\r\n        uint256 sumCollateral;\r\n        uint256 sumBorrowed;\r\n        uint256 borrowFactor;\r\n        uint256 totalBorrows;\r\n        uint256 canBorrows;\r\n        uint256 borrowedBalance;\r\n        uint256 availableToBorrow;\r\n        uint256 safeAvailableToBorrow;\r\n        uint256 accountBalance;\r\n        uint256 maxRepay;\r\n    }\r\n\r\n    function getAccountBorrowData(\r\n        IiToken _asset,\r\n        address _account,\r\n        uint256 _safeMaxFactor\r\n    )\r\n        public\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint8\r\n        )\r\n    {\r\n        borrowLocalVars memory _var;\r\n        _var.borrowedBalance = _asset.borrowBalanceCurrent(_account);\r\n        _var.accountBalance = getBalance(_asset, _account);\r\n        _var.maxRepay = _var.borrowedBalance > _var.accountBalance\r\n            ? _var.accountBalance\r\n            : _var.borrowedBalance;\r\n\r\n        _var.assetPrice = controller.priceOracle()\r\n            .getUnderlyingPrice(_asset);\r\n        (, _var.borrowFactor, _var.borrowCapacity, , , , ) = controller.markets(\r\n            _asset\r\n        );\r\n        if (\r\n            _var.assetPrice == 0 ||\r\n            _var.borrowCapacity == 0 ||\r\n            _var.borrowFactor == 0\r\n        )\r\n            return (\r\n                _var.borrowedBalance,\r\n                0,\r\n                0,\r\n                _var.accountBalance,\r\n                _var.maxRepay,\r\n                _asset.decimals()\r\n            );\r\n\r\n        (\r\n            _var.accountEquity,\r\n            ,\r\n            _var.sumCollateral,\r\n            _var.sumBorrowed\r\n        ) = calcAccountEquity(_account);\r\n        _var.availableToBorrow = _var.accountEquity.rmul(_var.borrowFactor).div(\r\n            _var.assetPrice\r\n        );\r\n\r\n        _var.safeAvailableToBorrow = _var.sumCollateral.rmul(_safeMaxFactor) >\r\n            _var.sumBorrowed\r\n            ? _var.sumCollateral.rmul(_safeMaxFactor).sub(_var.sumBorrowed)\r\n            : 0;\r\n        _var.safeAvailableToBorrow = _var\r\n            .safeAvailableToBorrow\r\n            .rmul(_var.borrowFactor)\r\n            .div(_var.assetPrice);\r\n\r\n        if (_asset.isiToken()) {\r\n            _var.cash = _asset.getCash();\r\n            _var.availableToBorrow = _var.availableToBorrow > _var.cash\r\n                ? _var.cash\r\n                : _var.availableToBorrow;\r\n\r\n            _var.safeAvailableToBorrow = _var.safeAvailableToBorrow > _var.cash\r\n                ? _var.cash\r\n                : _var.safeAvailableToBorrow;\r\n        }\r\n\r\n        _var.totalBorrows = _asset.totalBorrowsCurrent();\r\n        _var.canBorrows = _var.totalBorrows >= _var.borrowCapacity\r\n            ? 0\r\n            : _var.borrowCapacity.sub(_var.totalBorrows);\r\n\r\n        _var.availableToBorrow = _var.availableToBorrow > _var.canBorrows\r\n            ? _var.canBorrows\r\n            : _var.availableToBorrow;\r\n\r\n        _var.safeAvailableToBorrow = _var.safeAvailableToBorrow >\r\n            _var.canBorrows\r\n            ? _var.canBorrows\r\n            : _var.safeAvailableToBorrow;\r\n\r\n        return (\r\n            _var.borrowedBalance,\r\n            _var.canBorrows,\r\n            _var.safeAvailableToBorrow,\r\n            _var.accountBalance,\r\n            _var.maxRepay,\r\n            _asset.decimals()\r\n        );\r\n    }\r\n\r\n    struct availableToBorrowLocalVars {\r\n        uint256 borrowFactor;\r\n        uint256 accountEquity;\r\n        uint256 sumCollateral;\r\n        uint256 sumBorrowed;\r\n        uint256 availableToBorrow;\r\n        uint256 safeAvailableToBorrow;\r\n    }\r\n\r\n    function getBalance(IiToken _asset, address _account)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return\r\n            _asset.underlying() == IERC20(0)\r\n                ? _account.balance\r\n                : _asset.underlying().balanceOf(_account);\r\n    }\r\n\r\n    struct liquidateLocalVars {\r\n        IPriceOracle oracle;\r\n        uint256 priceBorrowed;\r\n        uint256 priceCollateral;\r\n        uint256 liquidatorBalance;\r\n        uint256 borrowerCollateralBalance;\r\n        uint256 shortfall;\r\n        uint256 exchangeRateCollateral;\r\n        uint256 maxRepay;\r\n        uint256 maxSeizediToken;\r\n        uint256 maxRepayByCollateral;\r\n        bool available;\r\n    }\r\n\r\n    function getLiquidationInfo(\r\n        address _borrower,\r\n        address _liquidator,\r\n        IiToken _assetBorrowed,\r\n        IiToken _assetCollateral\r\n    )\r\n        public\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            bool\r\n        )\r\n    {\r\n        liquidateLocalVars memory _var;\r\n\r\n        _var.oracle = controller.priceOracle();\r\n        if (_var.oracle.getAssetPriceStatus(_assetCollateral))\r\n            _var.available = getAccountAvailable(_borrower);\r\n\r\n        _var.maxRepay = _assetBorrowed.borrowBalanceCurrent(_borrower)\r\n            .rmul(controller.closeFactorMantissa());\r\n        _var.exchangeRateCollateral = _assetCollateral.exchangeRateCurrent();\r\n\r\n        _var.liquidatorBalance = getBalance(_assetBorrowed, _liquidator);\r\n        (, _var.shortfall, , ) = calcAccountEquity(_borrower);\r\n        if (_var.shortfall == 0 || _borrower == _liquidator)\r\n            return (0, 0, _var.liquidatorBalance, _var.available);\r\n\r\n        _var.priceBorrowed = _var.oracle.getUnderlyingPrice(_assetBorrowed);\r\n        _var.priceCollateral = _var.oracle.getUnderlyingPrice(_assetCollateral);\r\n\r\n        _var.maxSeizediToken = _var\r\n            .maxRepay\r\n            .mul(_var.priceBorrowed)\r\n            .rmul(controller.liquidationIncentiveMantissa())\r\n            .rdiv(_var.exchangeRateCollateral)\r\n            .div(_var.priceCollateral);\r\n        _var.borrowerCollateralBalance = _assetCollateral.balanceOf(\r\n            _borrower\r\n        );\r\n        if (_var.maxSeizediToken < _var.borrowerCollateralBalance)\r\n            return (\r\n                _var.maxRepay,\r\n                _var.maxRepay,\r\n                _var.liquidatorBalance,\r\n                _var.available\r\n            );\r\n\r\n        _var.maxRepayByCollateral = _var\r\n            .borrowerCollateralBalance\r\n            .rmul(_var.exchangeRateCollateral)\r\n            .mul(_var.priceCollateral)\r\n            .div(_var.priceBorrowed)\r\n            .rdiv(controller.liquidationIncentiveMantissa());\r\n        return (\r\n            _var.maxRepay,\r\n            _var.maxRepayByCollateral,\r\n            _var.liquidatorBalance,\r\n            _var.available\r\n        );\r\n    }\r\n\r\n    function getAccountRewardAmount(address _account) external returns (uint256) {\r\n\r\n        IRewardDistributor _rewardDistributor = IRewardDistributor(controller.rewardDistributor());\r\n        address[] memory _accounts = new address[](1);\r\n        _accounts[0] = _account;\r\n        _rewardDistributor.updateRewardBatch(_accounts ,controller.getAlliTokens());\r\n        return _rewardDistributor.reward(_account);\r\n    }\r\n\r\n    struct AccountEquityLocalVars {\r\n        IiToken[] collateralITokens;\r\n        IiToken[] borrowedITokens;\r\n        uint256 collateralFactor;\r\n        uint256 borrowFactor;\r\n        uint256 sumCollateral;\r\n        uint256 sumBorrowed;\r\n    }\r\n\r\n    function calcAccountEquity(address _account) public view returns (uint256, uint256, uint256, uint256) {\r\n        AccountEquityLocalVars memory _var;\r\n        _var.collateralITokens = controller.getEnteredMarkets(_account);\r\n        for (uint256 i = 0; i < _var.collateralITokens.length; i++) {\r\n            (_var.collateralFactor, , , , , , ) = controller.markets(_var.collateralITokens[i]);\r\n            _var.sumCollateral = _var.sumCollateral.add(\r\n                _var.collateralITokens[i].balanceOf(_account)\r\n                .mul(controller.priceOracle().getUnderlyingPrice(_var.collateralITokens[i]))\r\n                .rmul(_var.collateralITokens[i].exchangeRateStored())\r\n                .rmul(_var.collateralFactor)\r\n            );\r\n        }\r\n        _var.borrowedITokens = controller.getBorrowedAssets(_account);\r\n        for (uint256 i = 0; i < _var.borrowedITokens.length; i++) {\r\n            (, _var.borrowFactor, , , , , ) = controller.markets(_var.borrowedITokens[i]);\r\n            _var.sumBorrowed = _var.sumBorrowed.add(\r\n                _var.borrowedITokens[i].borrowBalanceStored(_account)\r\n                .mul(controller.priceOracle().getUnderlyingPrice(_var.borrowedITokens[i]))\r\n                .rdiv(_var.borrowFactor)\r\n            );\r\n        }\r\n        return\r\n            _var.sumCollateral > _var.sumBorrowed\r\n                ? (\r\n                    _var.sumCollateral - _var.sumBorrowed,\r\n                    uint256(0),\r\n                    _var.sumCollateral,\r\n                    _var.sumBorrowed\r\n                )\r\n                : (\r\n                    uint256(0),\r\n                    _var.sumBorrowed - _var.sumCollateral,\r\n                    _var.sumCollateral,\r\n                    _var.sumBorrowed\r\n                );\r\n    }\r\n\r\n    function getAccountAvailable(address _account) public view returns (bool) {\r\n        \r\n        IiToken[] memory _collateralITokens = controller.getEnteredMarkets(_account);\r\n        for (uint256 i = 0; i < _collateralITokens.length; i++) {\r\n            if (!controller.priceOracle().getAssetPriceStatus(_collateralITokens[i]))\r\n                return false;\r\n        }\r\n        IiToken[] memory _borrowedITokens = controller.getBorrowedAssets(_account);\r\n        for (uint256 i = 0; i < _borrowedITokens.length; i++) {\r\n            if (!controller.priceOracle().getAssetPriceStatus(_borrowedITokens[i]))\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_controller\",\"type\":\"address\"},{\"internalType\":\"contract IiToken\",\"name\":\"_priceToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"NewOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldPendingOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newPendingOwner\",\"type\":\"address\"}],\"name\":\"NewPendingOwner\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_acceptOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newPendingOwner\",\"type\":\"address\"}],\"name\":\"_setPendingOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"amounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blocksPerYear\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"calcAccountEquity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IiToken\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_safeMaxFactor\",\"type\":\"uint256\"}],\"name\":\"canAccountRemoveFromCollateral\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"contract IController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getAccountAvailable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IiToken\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_safeMaxFactor\",\"type\":\"uint256\"}],\"name\":\"getAccountBorrowData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IiToken\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_safeMaxFactor\",\"type\":\"uint256\"}],\"name\":\"getAccountBorrowInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getAccountBorrowStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getAccountBorrowTokens\",\"outputs\":[{\"internalType\":\"contract IiToken[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint8[]\",\"name\":\"\",\"type\":\"uint8[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getAccountBorrowValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_borrowValue\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getAccountMSDTokens\",\"outputs\":[{\"internalType\":\"contract IiToken[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint8[]\",\"name\":\"\",\"type\":\"uint8[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getAccountRewardAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IiToken\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_safeMaxFactor\",\"type\":\"uint256\"}],\"name\":\"getAccountSupplyData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IiToken\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_safeMaxFactor\",\"type\":\"uint256\"}],\"name\":\"getAccountSupplyInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_assetPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_asCollateral\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_executed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_accountAvailable\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getAccountSupplyTokens\",\"outputs\":[{\"internalType\":\"contract IiToken[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint8[]\",\"name\":\"\",\"type\":\"uint8[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getAccountTokens\",\"outputs\":[{\"internalType\":\"contract IiToken[]\",\"name\":\"_supplyTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_supplyAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint8[]\",\"name\":\"_supplyDecimals\",\"type\":\"uint8[]\"},{\"internalType\":\"contract IiToken[]\",\"name\":\"_borrowTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_borrowAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint8[]\",\"name\":\"_borrowDecimals\",\"type\":\"uint8[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getAccountTotalValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IiToken\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"getAssetUSDPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IiToken\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IiToken\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"getBorrowTokenData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_liquidator\",\"type\":\"address\"},{\"internalType\":\"contract IiToken\",\"name\":\"_assetBorrowed\",\"type\":\"address\"},{\"internalType\":\"contract IiToken\",\"name\":\"_assetCollateral\",\"type\":\"address\"}],\"name\":\"getLiquidationInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IiToken\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"getSupplyTokenData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_controller\",\"type\":\"address\"},{\"internalType\":\"contract IiToken\",\"name\":\"_priceToken\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceToken\",\"outputs\":[{\"internalType\":\"contract IiToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IController\",\"name\":\"_newController\",\"type\":\"address\"}],\"name\":\"setController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IiToken\",\"name\":\"_newAsset\",\"type\":\"address\"}],\"name\":\"setPriceToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"contract IiToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"LendingDataV2","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000008b53ab2c0df3230ea327017c91eb909f815ad1130000000000000000000000002f956b2f801c6dad74e87e7f45c94f6283bf0f45","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://bd3cb192c42d0b64624f72a8b75af3753389e887201c7d7bf6d4eb16b6ac40c6"}]}