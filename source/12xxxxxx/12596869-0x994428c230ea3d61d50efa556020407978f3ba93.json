{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/NarwhalRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\n\\nimport \\\"./libraries/NarwhalLibrary.sol\\\";\\nimport \\\"./libraries/TransferHelper.sol\\\";\\nimport \\\"./interfaces/INarwhalRouter.sol\\\";\\nimport \\\"./interfaces/IUniswapV2Factory.sol\\\";\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/IWETH.sol\\\";\\n\\n\\ncontract NarwhalRouter is INarwhalRouter {\\n  using TransferHelper for address;\\n  using NarwhalLibrary for bytes32;\\n\\n  address public immutable override WETH;\\n\\n  modifier ensure(uint256 deadline) {\\n    require(deadline >= block.timestamp, \\\"NarwhalRouter: EXPIRED\\\");\\n    _;\\n  }\\n\\n  constructor(address _WETH) {\\n    WETH = _WETH;\\n  }\\n\\n  receive() external payable {\\n    assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\\n  }\\n\\n  // **** SWAP ****\\n  // requires the initial amount to have already been sent to the first pair\\n  function _swap(\\n    uint256[] memory amounts,\\n    bytes32[] memory path,\\n    address _to\\n  ) private {\\n    for (uint256 i; i < path.length; i++) {\\n      (bool zeroForOne, address pair) = path[i].unpack();\\n      uint256 amountOut = amounts[i + 1];\\n      (uint256 amount0Out, uint256 amount1Out) = zeroForOne ? (uint256(0), amountOut) : (amountOut, uint256(0));\\n      address to = i < path.length - 1 ? path[i + 1].readPair() : _to;\\n      IUniswapV2Pair(pair).swap(amount0Out, amount1Out, to, new bytes(0));\\n    }\\n  }\\n\\n  function swapExactTokensForTokens(\\n    uint256 amountIn,\\n    uint256 amountOutMin,\\n    bytes32[] calldata path,\\n    address to,\\n    uint256 deadline\\n  ) external override ensure(deadline) returns (uint256[] memory amounts) {\\n    amounts = NarwhalLibrary.getAmountsOut(amountIn, path);\\n    require(amounts[amounts.length - 1] >= amountOutMin, \\\"NarwhalRouter: INSUFFICIENT_OUTPUT\\\");\\n    path[0].tokenIn().safeTransferFrom(\\n      msg.sender,\\n      path[0].readPair(),\\n      amounts[0]\\n    );\\n    _swap(amounts, path, to);\\n  }\\n\\n  function swapTokensForExactTokens(\\n    uint256 amountOut,\\n    uint256 amountInMax,\\n    bytes32[] calldata path,\\n    address to,\\n    uint256 deadline\\n  ) external override ensure(deadline) returns (uint256[] memory amounts) {\\n    amounts = NarwhalLibrary.getAmountsIn(amountOut, path);\\n    require(amounts[0] <= amountInMax, \\\"NarwhalRouter: EXCESSIVE_INPUT\\\");\\n    path[0].tokenIn().safeTransferFrom(\\n      msg.sender,\\n      path[0].readPair(),\\n      amounts[0]\\n    );\\n    _swap(amounts, path, to);\\n  }\\n\\n  function swapExactETHForTokens(\\n    uint256 amountOutMin,\\n    bytes32[] calldata path,\\n    address to,\\n    uint256 deadline\\n  ) external payable override ensure(deadline) returns (uint256[] memory amounts) {\\n    require(path[0].tokenIn() == WETH, \\\"NarwhalRouter: INVALID_PATH\\\");\\n    amounts = NarwhalLibrary.getAmountsOut(msg.value, path);\\n    require(amounts[amounts.length - 1] >= amountOutMin, \\\"NarwhalRouter: INSUFFICIENT_OUTPUT\\\");\\n    IWETH(WETH).deposit{value: amounts[0]}();\\n    assert(IWETH(WETH).transfer(path[0].readPair(), amounts[0]));\\n    _swap(amounts, path, to);\\n  }\\n\\n  function swapTokensForExactETH(\\n    uint256 amountOut,\\n    uint256 amountInMax,\\n    bytes32[] calldata path,\\n    address to,\\n    uint256 deadline\\n  ) external override ensure(deadline) returns (uint256[] memory amounts) {\\n    require(path[path.length - 1].tokenOut() == WETH, \\\"NarwhalRouter: INVALID_PATH\\\");\\n    amounts = NarwhalLibrary.getAmountsIn(amountOut, path);\\n    require(amounts[0] <= amountInMax, \\\"NarwhalRouter: EXCESSIVE_INPUT\\\");\\n    path[0].tokenIn().safeTransferFrom(\\n      msg.sender,\\n      path[0].readPair(),\\n      amounts[0]\\n    );\\n    _swap(amounts, path, address(this));\\n    IWETH(WETH).withdraw(amounts[amounts.length - 1]);\\n    TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\\n  }\\n\\n  function swapExactTokensForETH(\\n    uint256 amountIn,\\n    uint256 amountOutMin,\\n    bytes32[] calldata path,\\n    address to,\\n    uint256 deadline\\n  ) external override ensure(deadline) returns (uint256[] memory amounts) {\\n    require(path[path.length - 1].tokenOut() == WETH, \\\"NarwhalRouter: INVALID_PATH\\\");\\n    amounts = NarwhalLibrary.getAmountsOut(amountIn, path);\\n    require(amounts[amounts.length - 1] >= amountOutMin, \\\"NarwhalRouter: INSUFFICIENT_OUTPUT\\\");\\n    path[0].tokenIn().safeTransferFrom(\\n      msg.sender,\\n      path[0].readPair(),\\n      amounts[0]\\n    );\\n    _swap(amounts, path, address(this));\\n    IWETH(WETH).withdraw(amounts[amounts.length - 1]);\\n    TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\\n  }\\n\\n  function swapETHForExactTokens(\\n    uint256 amountOut,\\n    bytes32[] calldata path,\\n    address to,\\n    uint256 deadline\\n  ) external payable override ensure(deadline) returns (uint256[] memory amounts) {\\n    require(path[0].tokenIn() == WETH, \\\"NarwhalRouter: INVALID_PATH\\\");\\n    amounts = NarwhalLibrary.getAmountsIn(amountOut, path);\\n    require(amounts[0] <= msg.value, \\\"NarwhalRouter: EXCESSIVE_INPUT\\\");\\n    IWETH(WETH).deposit{value: amounts[0]}();\\n    assert(IWETH(WETH).transfer(path[0].readPair(), amounts[0]));\\n    _swap(amounts, path, to);\\n    if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]); // refund dust eth, if any\\n  }\\n\\n  function getAmountsOut(uint256 amountIn, bytes32[] memory path)\\n    public\\n    view\\n    override\\n    returns (uint256[] memory amounts)\\n  {\\n    return NarwhalLibrary.getAmountsOut(amountIn, path);\\n  }\\n\\n  function getAmountsIn(uint256 amountOut, bytes32[] memory path)\\n    public\\n    view\\n    override\\n    returns (uint256[] memory amounts)\\n  {\\n    return NarwhalLibrary.getAmountsIn(amountOut, path);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0;\\n\\n\\ninterface IERC20 {\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n  function totalSupply() external view returns (uint256);\\n  function balanceOf(address account) external view returns (uint256);\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n  function allowance(address owner, address spender) external view returns (uint256);\\n  function approve(address spender, uint256 amount) external returns (bool);\\n  function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\\n  function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n}\"\r\n    },\r\n    \"contracts/interfaces/INarwhalRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2;\\n\\ninterface INarwhalRouter {\\n  function WETH() external view returns (address);\\n\\n  function swapExactTokensForTokens(\\n    uint256 amountIn,\\n    uint256 amountOutMin,\\n    bytes32[] calldata path,\\n    address to,\\n    uint256 deadline\\n  ) external returns (uint256[] memory amounts);\\n\\n  function swapTokensForExactTokens(\\n    uint256 amountOut,\\n    uint256 amountInMax,\\n    bytes32[] calldata path,\\n    address to,\\n    uint256 deadline\\n  ) external returns (uint256[] memory amounts);\\n\\n  function swapExactETHForTokens(\\n    uint256 amountOutMin,\\n    bytes32[] calldata path,\\n    address to,\\n    uint256 deadline\\n  ) external payable returns (uint256[] memory amounts);\\n\\n  function swapTokensForExactETH(\\n    uint256 amountOut,\\n    uint256 amountInMax,\\n    bytes32[] calldata path,\\n    address to,\\n    uint256 deadline\\n  ) external returns (uint256[] memory amounts);\\n\\n  function swapExactTokensForETH(\\n    uint256 amountIn,\\n    uint256 amountOutMin,\\n    bytes32[] calldata path,\\n    address to,\\n    uint256 deadline\\n  ) external returns (uint256[] memory amounts);\\n\\n  function swapETHForExactTokens(\\n    uint256 amountOut,\\n    bytes32[] calldata path,\\n    address to,\\n    uint256 deadline\\n  ) external payable returns (uint256[] memory amounts);\\n\\n  function getAmountsOut(uint256 amountIn, bytes32[] calldata path) external view returns (uint256[] memory amounts);\\n\\n  function getAmountsIn(uint256 amountOut, bytes32[] calldata path) external view returns (uint256[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0;\\n\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0;\\n\\n\\ninterface IUniswapV2Pair {\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  function name() external pure returns (string memory);\\n\\n  function symbol() external pure returns (string memory);\\n\\n  function decimals() external pure returns (uint8);\\n\\n  function totalSupply() external view returns (uint256);\\n\\n  function balanceOf(address owner) external view returns (uint256);\\n\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  function approve(address spender, uint256 value) external returns (bool);\\n\\n  function transfer(address to, uint256 value) external returns (bool);\\n\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 value\\n  ) external returns (bool);\\n\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n  function nonces(address owner) external view returns (uint256);\\n\\n  function permit(\\n    address owner,\\n    address spender,\\n    uint256 value,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external;\\n\\n  event Mint(address indexed sender, uint256 amount0, uint256 amount1);\\n  event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\\n  event Swap(\\n    address indexed sender,\\n    uint256 amount0In,\\n    uint256 amount1In,\\n    uint256 amount0Out,\\n    uint256 amount1Out,\\n    address indexed to\\n  );\\n  event Sync(uint112 reserve0, uint112 reserve1);\\n\\n  function MINIMUM_LIQUIDITY() external pure returns (uint256);\\n\\n  function factory() external view returns (address);\\n\\n  function token0() external view returns (address);\\n\\n  function token1() external view returns (address);\\n\\n  function getReserves()\\n    external\\n    view\\n    returns (\\n      uint112 reserve0,\\n      uint112 reserve1,\\n      uint32 blockTimestampLast\\n    );\\n\\n  function price0CumulativeLast() external view returns (uint256);\\n\\n  function price1CumulativeLast() external view returns (uint256);\\n\\n  function kLast() external view returns (uint256);\\n\\n  function mint(address to) external returns (uint256 liquidity);\\n\\n  function burn(address to) external returns (uint256 amount0, uint256 amount1);\\n\\n  function swap(\\n    uint256 amount0Out,\\n    uint256 amount1Out,\\n    address to,\\n    bytes calldata data\\n  ) external;\\n\\n  function skim(address to) external;\\n\\n  function sync() external;\\n\\n  function initialize(address, address) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n    function transfer(address to, uint value) external returns (bool);\\n    function withdraw(uint) external;\\n}\"\r\n    },\r\n    \"contracts/libraries/NarwhalLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\n\\nimport \\\"../interfaces/IUniswapV2Pair.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n\\nlibrary NarwhalLibrary {\\n  using SafeMath for uint256;\\n\\n  function unpack(bytes32 pairInfo) internal pure returns (bool zeroForOne, address pair) {\\n    assembly {\\n      zeroForOne := byte(31, pairInfo)\\n      pair := shr(8, pairInfo)\\n    }\\n  }\\n\\n  function readPair(bytes32 pairInfo) internal pure returns (address pair) {\\n    assembly {\\n      pair := shr(8, pairInfo)\\n    }\\n  }\\n\\n  function tokenIn(bytes32 pairInfo) internal view returns (address token) {\\n    (bool zeroForOne, address pair) = unpack(pairInfo);\\n    token = zeroForOne ? IUniswapV2Pair(pair).token0() : IUniswapV2Pair(pair).token1();\\n  }\\n\\n  function tokenOut(bytes32 pairInfo) internal view returns (address token) {\\n    (bool zeroForOne, address pair) = unpack(pairInfo);\\n    token = zeroForOne ? IUniswapV2Pair(pair).token1() : IUniswapV2Pair(pair).token0();\\n  }\\n\\n  function getReserves(bytes32 pairInfo) internal view returns (uint256 reserveIn, uint256 reserveOut) {\\n    (bool zeroForOne, address pair) = unpack(pairInfo);\\n    (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(pair).getReserves();\\n    (reserveIn, reserveOut) = zeroForOne ? (reserve0, reserve1) : (reserve1, reserve0);\\n  }\\n\\n  function getAmountOut(bytes32 pairInfo, uint256 amountIn) internal view returns (uint256 amountOut) {\\n    require(amountIn > 0, \\\"Narwhal: INSUFFICIENT INPUT\\\");\\n    (uint256 reserveIn, uint256 reserveOut) = getReserves(pairInfo);\\n    require(reserveIn > 0 && reserveOut > 0, \\\"Narwhal: INSUFFICIENT_LIQUIDITY\\\");\\n    uint256 amountInWithFee = amountIn.mul(997);\\n    uint256 numerator = amountInWithFee.mul(reserveOut);\\n    uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\\n    amountOut = numerator / denominator;\\n  }\\n\\n  function getAmountIn(bytes32 pairInfo, uint256 amountOut)\\n    internal\\n    view\\n    returns (uint256 amountIn)\\n  {\\n    require(amountOut > 0, \\\"Narwhal: INSUFFICIENT_OUTPUT\\\");\\n    (uint256 reserveIn, uint256 reserveOut) = getReserves(pairInfo);\\n    require(reserveIn > 0 && reserveOut > 0, \\\"Narwhal: INSUFFICIENT_LIQUIDITY\\\");\\n    uint256 numerator = reserveIn.mul(amountOut).mul(1000);\\n    uint256 denominator = reserveOut.sub(amountOut).mul(997);\\n    amountIn = (numerator / denominator).add(1);\\n  }\\n\\n  function getAmountsOut(\\n    uint256 amountIn,\\n    bytes32[] memory path\\n  ) internal view returns (uint256[] memory amounts) {\\n    require(path.length >= 1, \\\"Narwhal: INVALID_PATH\\\");\\n    amounts = new uint256[](path.length + 1);\\n    amounts[0] = amountIn;\\n    for (uint256 i; i < path.length; i++) {\\n      amounts[i + 1] = getAmountOut(path[i], amounts[i]);\\n    }\\n  }\\n\\n  // performs chained getAmountIn calculations on any number of pairs\\n  function getAmountsIn(uint256 amountOut, bytes32[] memory path)\\n    internal\\n    view\\n    returns (uint256[] memory amounts)\\n  {\\n    require(path.length >= 1, \\\"Narwhal: INVALID_PATH\\\");\\n    amounts = new uint256[](path.length + 1);\\n    amounts[amounts.length - 1] = amountOut;\\n    for (uint256 i = amounts.length - 1; i > 0; i--) {\\n      amounts[i - 1] = getAmountIn(path[i - 1], amounts[i]);\\n    }\\n  }\\n}\"\r\n    },\r\n    \"contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\n\\n\\nlibrary SafeMath {\\n  function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n    require((z = x + y) >= x, \\\"ds-math-add-overflow\\\");\\n  }\\n\\n  function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n    require((z = x - y) <= x, \\\"ds-math-sub-underflow\\\");\\n  }\\n\\n  function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n    require(y == 0 || (z = x * y) / y == x, \\\"ds-math-mul-overflow\\\");\\n  }\\n}\"\r\n    },\r\n    \"contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.7.6;\\n\\n/************************************************************************************************\\nOriginally from https://github.com/Uniswap/uniswap-lib/blob/master/contracts/libraries/TransferHelper.sol\\n\\nThis source code has been modified from the original, which was copied from the github repository\\nat commit hash cfedb1f55864dcf8cc0831fdd8ec18eb045b7fd1.\\n\\nSubject to the MIT license\\n*************************************************************************************************/\\n\\n\\nlibrary TransferHelper {\\n  function safeApproveMax(address token, address to) internal {\\n    safeApprove(token, to, type(uint256).max);\\n  }\\n\\n  function safeUnapprove(address token, address to) internal {\\n    safeApprove(token, to, 0);\\n  }\\n\\n  function safeApprove(address token, address to, uint value) internal {\\n    // bytes4(keccak256(bytes(\\\"approve(address,uint256)\\\")));\\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n    require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TH:SA\\\");\\n  }\\n\\n  function safeTransfer(address token, address to, uint value) internal {\\n    // bytes4(keccak256(bytes(\\\"transfer(address,uint256)\\\")));\\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n    require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TH:ST\\\");\\n  }\\n\\n  function safeTransferFrom(address token, address from, address to, uint value) internal {\\n    // bytes4(keccak256(bytes(\\\"transferFrom(address,address,uint256)\\\")));\\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n    require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TH:STF\\\");\\n  }\\n\\n  function safeTransferETH(address to, uint256 value) internal {\\n    (bool success, ) = to.call{value: value}(\\\"\\\");\\n    require(success, \\\"TH:STE\\\");\\n  }\\n}\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_WETH\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"path\",\"type\":\"bytes32[]\"}],\"name\":\"getAmountsIn\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"path\",\"type\":\"bytes32[]\"}],\"name\":\"getAmountsOut\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"path\",\"type\":\"bytes32[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapETHForExactTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"path\",\"type\":\"bytes32[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactETHForTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"path\",\"type\":\"bytes32[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForETH\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"path\",\"type\":\"bytes32[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMax\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"path\",\"type\":\"bytes32[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapTokensForExactETH\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMax\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"path\",\"type\":\"bytes32[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapTokensForExactTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"NarwhalRouter","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"800","ConstructorArguments":"000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}