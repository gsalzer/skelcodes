{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/v1/markets/eth/uniswap/UniswapV2Exchange.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"../../../../../interfaces/markets/tokens/IERC20.sol\\\";\\n\\ninterface Uni {\\n    function swapExactTokensForTokens(\\n        uint256,\\n        uint256,\\n        address[] calldata,\\n        address,\\n        uint256\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapTokensForExactTokens(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapTokensForExactETH(\\n        uint amountOut, \\n        uint amountInMax, \\n        address[] calldata path, \\n        address to, \\n        uint deadline)\\n    external\\n    returns (uint[] memory amounts);\\n\\n    function swapExactTokensForETH(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapETHForExactTokens(\\n        uint256 amountOut,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n\\n    function swapExactETHForTokens(\\n        uint amountOutMin, \\n        address[] calldata path, \\n        address to, \\n        uint deadline\\n    ) external payable returns (uint[] memory amounts);\\n\\n    function getAmountsOut(\\n        uint amountIn, \\n        address[] memory path\\n    ) external view returns (uint[] memory amounts);\\n}\\n\\nlibrary UniswapV2Exchange {\\n    address public constant DEX = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\\n    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n    function _approve(address _token, uint256 _amount) internal {\\n        if (IERC20(_token).allowance(address(this), DEX) < _amount) {\\n            IERC20(_token).approve(DEX, ~uint256(0));\\n        }\\n    }\\n\\n    function _checkCallResult(bool _success) internal pure {\\n        if (!_success) {\\n            // Copy revert reason from call\\n            assembly {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    function swapExactERC20ForERC20(\\n        address _from,\\n        address _to,\\n        address _recipient,\\n        uint256 _fromAmount,\\n        uint256 _toAmount\\n    ) external {\\n        // approve tokens to the DEX \\n        _approve(_from, _fromAmount);\\n\\n        address[] memory _path = new address[](3);\\n        _path[0] = _from;\\n        _path[1] = WETH;\\n        _path[2] = _to;\\n\\n        Uni(DEX).swapExactTokensForTokens(\\n            IERC20(_from).balanceOf(address(this)),\\n            _toAmount,\\n            _path,\\n            _recipient,\\n            block.timestamp + 1800\\n        );\\n    }\\n\\n    function swapERC20ForExactERC20(\\n        address _from,\\n        address _to,\\n        address _recipient,\\n        uint256 _fromAmount,\\n        uint256 _toAmount\\n    ) external {\\n        // approve tokens to the DEX\\n        _approve(_from, _fromAmount);\\n\\n        address[] memory _path = new address[](3);\\n        _path[0] = _from;\\n        _path[1] = WETH;\\n        _path[2] = _to;\\n\\n        Uni(DEX).swapTokensForExactTokens(\\n            _toAmount,\\n            _fromAmount,\\n            _path,\\n            _recipient,\\n            block.timestamp + 1800\\n        );\\n    }\\n\\n    function swapERC20ForExactETH(\\n        address _from,\\n        address _recipient,\\n        uint256 _fromAmount,\\n        uint256 _toAmount\\n    ) external {\\n        // approve tokens to the DEX\\n        _approve(_from, _fromAmount);\\n\\n        address[] memory _path = new address[](2);\\n        _path[0] = _from;\\n        _path[1] = WETH;\\n\\n        Uni(DEX).swapTokensForExactETH(\\n            _toAmount,\\n            _fromAmount,\\n            _path,\\n            _recipient,\\n            block.timestamp + 1800\\n        );\\n    }\\n\\n    function swapExactERC20ForETH(\\n        address _from,\\n        address _recipient,\\n        uint256 _fromAmount,\\n        uint256 _toAmount\\n    ) external {\\n        // approve tokens to the DEX\\n        _approve(_from, _fromAmount);\\n\\n        address[] memory _path = new address[](2);\\n        _path[0] = _from;\\n        _path[1] = WETH;\\n\\n        Uni(DEX).swapExactTokensForETH(\\n            IERC20(_from).balanceOf(address(this)),\\n            _toAmount,\\n            _path,\\n            _recipient,\\n            block.timestamp + 1800\\n        );\\n    }\\n\\n    function swapETHForExactERC20(\\n        address _to,\\n        address _recipient,\\n        uint256 _fromAmount,\\n        uint256 _toAmount\\n    ) external {        \\n        address[] memory _path = new address[](2);\\n        _path[0] = WETH;\\n        _path[1] = _to;\\n\\n        bytes memory _data = abi.encodeWithSelector(Uni.swapETHForExactTokens.selector, _toAmount, _path, _recipient, block.timestamp + 1800);\\n\\n        (bool success, ) = DEX.call{value:_fromAmount}(_data);\\n        _checkCallResult(success);\\n    }\\n\\n    function swapExactETHForERC20(\\n        address _to,\\n        address _recipient,\\n        uint256 _toAmount\\n    ) external {        \\n        address[] memory _path = new address[](2);\\n        _path[0] = WETH;\\n        _path[1] = _to;\\n\\n        bytes memory _data = abi.encodeWithSelector(Uni.swapExactETHForTokens.selector, _toAmount, _path, _recipient, block.timestamp + 1800);\\n\\n        (bool success, ) = DEX.call{value:address(this).balance}(_data);\\n        _checkCallResult(success);\\n    }\\n}\\n\"\r\n    },\r\n    \"interfaces/markets/tokens/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.4;\\n\\ninterface IERC20 {\\n    /**\\n        * @dev Returns the amount of tokens owned by `account`.\\n        */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n        * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n        *\\n        * Returns a boolean value indicating whether the operation succeeded.\\n        *\\n        * Emits a {Transfer} event.\\n        */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"name\":\"DEX\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"UniswapV2Exchange","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}