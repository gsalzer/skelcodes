{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/dom/repos/rad-contracts/contracts/IRadRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';\\n\\ninterface IRadRouter is IERC721Receiver {\\n  /**\\n   * @dev Emitted when a retail revenue split is updated for asset ledger `ledger`\\n   */\\n  event RetailRevenueSplitChange(address indexed ledger, address indexed stakeholder, uint256 share, uint256 totalStakeholders, uint256 totalSplit);\\n\\n  /**\\n   * @dev Emitted when a resale revenue split is updated for asset ledger `ledger`\\n   */\\n  event ResaleRevenueSplitChange(address indexed ledger, address indexed stakeholder, uint256 share, uint256 totalStakeholders, uint256 totalSplit);\\n\\n  /**\\n   * @dev Emitted when the minimum price of asset `assetId` is updated\\n   */\\n  event AssetMinPriceChange(address indexed ledger, uint256 indexed assetId, uint256 minPrice);\\n\\n  /**\\n   * @dev Emitted when seller `seller` changes ownership for asset `assetId` in ledger `ledger` to or from this escrow. `escrowed` is true for deposits and false for withdrawals\\n   */\\n  event SellerEscrowChange(address indexed ledger, uint256 indexed assetId, address indexed seller, bool escrowed);\\n\\n  /**\\n   * @dev Emitted when buyer `buyer` deposits or withdraws ETH from this escrow for asset `assetId` in ledger `ledger`. `escrowed` is true for deposits and false for withdrawals\\n   */\\n  event BuyerEscrowChange(address indexed ledger, uint256 indexed assetId, address indexed buyer, bool escrowed);\\n\\n  /**\\n   * @dev Emitted when stakeholder `stakeholder` is paid out from a retail sale or resale\\n   */\\n  event StakeholderPayout(address indexed ledger, uint256 indexed assetId, address indexed stakeholder, uint256 payout, uint256 share, bool retail);\\n\\n  /**\\n   * @dev Emitted when buyer `buyer` deposits or withdraws ETH from this escrow for asset `assetId` in ledger `ledger`. `escrowed` is true for deposits and false for withdrawals\\n   */\\n  event EscrowFulfill(address indexed ledger, uint256 indexed assetId, address seller, address buyer, uint256 value);\\n\\n  /**\\n   * @dev Sets a stakeholder's revenue share for an asset ledger. If `retail` is true, sets retail revenue splits; otherwise sets resale revenue splits\\n   *\\n   * Requirements:\\n   *\\n   * - `_ledger` cannot be the zero address.\\n   * - `_stakeholder` cannot be the zero address.\\n   * - `_share` must be >= 0 and <= 100\\n   * - Revenue cannot be split more than 5 ways\\n   *\\n   * Emits a {RetailRevenueSplitChange|ResaleRevenueSplitChange} event.\\n   */\\n  function setRevenueSplit(address _ledger, address payable _stakeholder, uint256 _share, bool _retail) external returns (bool success);\\n\\n  /**\\n   * @dev Returns the revenue share of `_stakeholder` for ledger `_ledger`\\n   *\\n   * See {setRevenueSplit}\\n   */\\n  function getRevenueSplit(address _ledger, address payable _stakeholder, bool _retail) external view returns (uint256 share);\\n\\n  /**\\n   * @dev Sets multiple stakeholders' revenue shares for an asset ledger. Overwrites any existing revenue share. If `retail` is true, sets retail revenue splits; otherwise sets resale revenue splits\\n   * See {setRevenueSplit}\\n   *\\n   * Requirements:\\n   *\\n   * - `_ledger` cannot be the zero address.\\n   * - `_stakeholders` cannot contain zero addresses.\\n   * - `_shares` must be >= 0 and <= 100\\n   * - Revenue cannot be split more than 5 ways\\n   *\\n   * Emits a {RetailRevenueSplitChange|ResaleRevenueSplitChange} event.\\n   */\\n  function setRevenueSplits(address _ledger, address payable[] calldata _stakeholders, uint256[] calldata _shares, bool _retail) external returns (bool success);\\n\\n  /**\\n   * @dev For ledger `_ledger`, returns retail revenue stakeholders if `_retail` is true, otherwise returns resale revenue stakeholders.\\n   */\\n  function getRevenueStakeholders(address _ledger, bool _retail) external view returns (address[] memory stakeholders);\\n\\n  /**\\n   * @dev Sets the minimum price for asset `_assetId`\\n   *\\n   * Requirements:\\n   *\\n   * - `_ledger` cannot be the zero address.\\n   * - `_owner` must first approve this contract as an operator for ledger `_ledger`\\n   * - `_minPrice` is in wei\\n   *\\n   * Emits a {AssetMinPriceChange} event.\\n   */\\n  function setAssetMinPrice(address _ledger, uint256 _assetId, uint256 _minPrice) external returns (bool success);\\n\\n  /**\\n   * @dev Sets a stakeholder's revenue share for an asset ledger. If `retail` is true, sets retail revenue splits; otherwise sets resale revenue splits.\\n   * Also sets the minimum price for asset `_assetId`\\n   * See {setAssetMinPrice | setRevenueSplits}\\n   *\\n   * Requirements:\\n   *\\n   * - `_ledger` cannot be the zero address.\\n   * - `_stakeholder` cannot be the zero address.\\n   * - `_share` must be > 0 and <= 100\\n   * - Revenue cannot be split more than 5 ways\\n   * - `_owner` must first approve this contract as an operator for ledger `_ledger`\\n   * - `_minPrice` is in wei\\n   *\\n   * Emits a {RetailRevenueSplitChange|ResaleRevenueSplitChange} event.\\n   */\\n  function setAssetMinPriceAndRevenueSplits(address _ledger, address payable[] calldata _stakeholders, uint256[] calldata _shares, bool _retail, uint256 _assetId, uint256 _minPrice) external returns (bool success);\\n\\n  /**\\n   * @dev Returns the minium price of asset `_assetId` in ledger `_ledger`\\n   *\\n   * See {setAssetMinPrice}\\n   */\\n  function getAssetMinPrice(address _ledger, uint256 _assetId) external view returns (uint256 minPrice);\\n\\n  /**\\n   * @dev Transfers ownership of asset `_assetId` to this contract for escrow.\\n   * If buyer has already escrowed, triggers escrow fulfillment.\\n   * See {fulfill}\\n   *\\n   * Requirements:\\n   *\\n   * - `_ledger` cannot be the zero address.\\n   * - `_owner` must first approve this contract as an operator for ledger `_ledger`\\n   *\\n   * Emits a {SellerEscrowChange} event.\\n   */\\n  function sellerEscrowDeposit(address _ledger, uint256 _assetId) external returns (bool success);\\n\\n  /**\\n   * @dev Transfers ownership of asset `_assetId` to this contract for escrow.\\n   * If buyer has already escrowed, triggers escrow fulfillment.\\n   * See {fulfill}\\n   *\\n   * Requirements:\\n   *\\n   * - `_ledger` cannot be the zero address.\\n   * - `_owner` must first approve this contract as an operator for ledger `_ledger`\\n   *\\n   * Emits a {SellerEscrowChange} event.\\n   */\\n  function sellerEscrowDepositWithCreatorShare(address _ledger, uint256 _assetId, uint256 _creatorResaleShare) external returns (bool success);\\n\\n  function sellerEscrowDepositWithCreatorShareBatch(address _ledger, uint256[] calldata _assetIds, uint256 _creatorResaleShare) external returns (bool success);\\n\\n  /**\\n   * @dev Transfers ownership of asset `_assetId` to this contract for escrow.\\n   * If buyer has already escrowed, triggers escrow fulfillment.\\n   * See {fulfill}\\n   *\\n   * Requirements:\\n   *\\n   * - `_ledger` cannot be the zero address.\\n   * - `_owner` must first approve this contract as an operator for ledger `_ledger`\\n   *\\n   * Emits a {SellerEscrowChange} event.\\n   */\\n  function sellerEscrowDepositWithCreatorShareWithMinPrice(address _ledger, uint256 _assetId, uint256 _creatorResaleShare, uint256 _minPrice) external returns (bool success);\\n\\n  function sellerEscrowDepositWithCreatorShareWithMinPriceBatch(address _ledger, uint256[] calldata _assetIds, uint256 _creatorResaleShare, uint256 _minPrice) external returns (bool success);\\n\\n  /**\\n   * @dev Transfers ownership of asset `_assetId` to this contract for escrow.\\n   * Sets asset min price to `_minPrice` if `_setMinPrice` is true. Reverts if `_setMinPrice` is true and buyer has already escrowed. Otherwise, if buyer has already escrowed, triggers escrow fulfillment.\\n   * See {fulfill | setAssetMinPrice}\\n   *\\n   * Requirements:\\n   *\\n   * - `_ledger` cannot be the zero address.\\n   * - `_owner` must first approve this contract as an operator for ledger `_ledger`\\n   * - `_minPrice` is in wei\\n   *\\n   * Emits a {SellerEscrowChange} event.\\n   */\\n  function sellerEscrowDeposit(address _ledger, uint256 _assetId, bool _setMinPrice, uint256 _minPrice) external returns (bool success);\\n\\n  /**\\n   * @dev Transfers ownership of all assets `_assetIds` to this contract for escrow.\\n   * If any buyers have already escrowed, triggers escrow fulfillment for the respective asset.\\n   * See {fulfill}\\n   *\\n   * Requirements:\\n   *\\n   * - `_ledger` cannot be the zero address.\\n   * - `_owner` must first approve this contract as an operator for ledger `_ledger`\\n   *\\n   * Emits a {SellerEscrowChange} event.\\n   */\\n  function sellerEscrowDepositBatch(address _ledger, uint256[] calldata _assetIds) external returns (bool success);\\n\\n  /**\\n   * @dev Transfers ownership of all assets `_assetIds` to this contract for escrow.\\n   * Sets each asset min price to `_minPrice` if `_setMinPrice` is true. Reverts if `_setMinPrice` is true and buyer has already escrowed. Otherwise, if any buyers have already escrowed, triggers escrow fulfillment for the respective asset.\\n   * See {fulfill | setAssetMinPrice}\\n   *\\n   * Requirements:\\n   *\\n   * - `_ledger` cannot be the zero address.\\n   * - `_owner` must first approve this contract as an operator for ledger `_ledger`\\n   * - `_minPrice` is in wei\\n   *\\n   * Emits a {SellerEscrowChange} event.\\n   */\\n  function sellerEscrowDepositBatch(address _ledger, uint256[] calldata _assetIds, bool _setMinPrice, uint256 _minPrice) external returns (bool success);\\n\\n  /**\\n   * @dev Transfers ownership of asset `_assetId` from this contract for escrow back to seller.\\n   *\\n   * Requirements:\\n   *\\n   * - `_ledger` cannot be the zero address.\\n   *\\n   * Emits a {SellerEscrowChange} event.\\n   */\\n  function sellerEscrowWithdraw(address _ledger, uint256 _assetId) external returns (bool success);\\n\\n  /**\\n   * @dev Accepts buyer's `msg.sender` funds into escrow for asset `_assetId` in ledger `_ledger`.\\n   * If seller has already escrowed, triggers escrow fulfillment.\\n   * See {fulfill}\\n   *\\n   * Requirements:\\n   *\\n   * - `_ledger` cannot be the zero address.\\n   * - `msg.value` must be at least the seller's listed price\\n   * - `_assetId` in `ledger` cannot already have an escrowed buyer\\n   *\\n   * Emits a {BuyerEscrowChange} event.\\n   */\\n  function buyerEscrowDeposit(address _ledger, uint256 _assetId) external payable returns (bool success);\\n\\n  /**\\n   * @dev Returns buyer's `msg.sender` funds back from escrow for asset `_assetId` in ledger `_ledger`.\\n   *\\n   * Requirements:\\n   *\\n   * - `_ledger` cannot be the zero address.\\n   * - `msg.sender` must be the escrowed buyer for asset `_assetId` in ledger `_ledger`, asset owner, or Rad operator\\n   *\\n   * Emits a {BuyerEscrowChange} event.\\n   */\\n  function buyerEscrowWithdraw(address _ledger, uint256 _assetId) external returns (bool success);\\n\\n  /**\\n   * @dev Returns the wallet address of the seller of asset `_assetId`\\n   *\\n   * See {sellerEscrowDeposit}\\n   */\\n  function getSellerWallet(address _ledger, uint256 _assetId) external view returns (address wallet);\\n\\n  /**\\n   * @dev Returns the wallet address of the buyer of asset `_assetId`\\n   *\\n   * See {buyerEscrowDeposit}\\n   */\\n  function getBuyerWallet(address _ledger, uint256 _assetId) external view returns (address wallet);\\n\\n  /**\\n   * @dev Returns the escrowed amount by the buyer of asset `_assetId`\\n   *\\n   * See {buyerEscrowDeposit}\\n   */\\n  function getBuyerDeposit(address _ledger, uint256 _assetId) external view returns (uint256 amount);\\n\\n  /**\\n   * @dev Returns the wallet address of the creator of asset `_assetId`\\n   *\\n   * See {sellerEscrowDeposit}\\n   */\\n  function getCreatorWallet(address _ledger, uint256 _assetId) external view returns (address wallet);\\n\\n  /**\\n   * @dev Returns the amount of the creator's share of asset `_assetId`\\n   *\\n   * See {sellerEscrowDeposit}\\n   */\\n  function getCreatorShare(address _ledger, uint256 _assetId) external view returns (uint256 amount);\\n\\n  /**\\n   * @dev Returns true if an asset has been sold for retail and will be considered resale moving forward\\n   */\\n  function getAssetIsResale(address _ledger, uint256 _assetId) external view returns (bool resale);\\n\\n  /**\\n   * @dev Returns an array of all retailed asset IDs for ledger `_ledger`\\n   */\\n  function getRetailedAssets(address _ledger) external view returns (uint256[] memory assets);\\n}\\n\"\r\n    },\r\n    \"/Users/dom/repos/rad-contracts/contracts/RadRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\nimport './IRadRouter.sol';\\nimport './RevenueSplitMapping.sol';\\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\\nimport '@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol';\\n\\ncontract RadRouter is IRadRouter, ERC721Holder {\\n  using RevenueSplitMapping for RevMap;\\n\\n  struct Ledger {\\n    RevMap RetailSplits;\\n    RevMap ResaleSplits;\\n    mapping (uint256 => Asset) Assets;\\n    uint256[] retailedAssets;\\n  }\\n\\n  struct Asset {\\n    address owner; // does not change on escrow, only through sale\\n    uint256 minPrice;\\n    bool resale;\\n    Creator creator;\\n    Buyer buyer;\\n  }\\n\\n  struct Creator {\\n    address wallet;\\n    uint256 share;\\n  }\\n\\n  struct Buyer {\\n    address wallet;\\n    uint256 amountEscrowed;\\n  }\\n\\n  modifier onlyBy(address _account)\\n  {\\n    require(\\n      msg.sender == _account,\\n      'Sender not authorized'\\n    );\\n    _;\\n  }\\n\\n  address public administrator_; // Rad administrator account\\n  mapping(address => Ledger) private Ledgers;\\n\\n  /**\\n   * @dev Initializes the contract and sets the router administrator `administrator_`\\n   */\\n  constructor() { administrator_ = msg.sender; }\\n\\n  /**\\n   * @dev See {IRadRouter-setRevenueSplit}.\\n   */\\n  function setRevenueSplit(address _ledger, address payable _stakeholder, uint256 _share, bool _retail) public onlyBy(administrator_) virtual override returns (bool success) {\\n    require(_ledger != address(0), 'Asset ledger cannot be the zero address');\\n    require(_stakeholder != address(0), 'Stakeholder cannot be the zero address');\\n    require(_share >= 0 && _share <= 100, 'Stakeholder share must be at least 0% and at most 100%');\\n\\n    uint256 total;\\n\\n    if (_retail) {\\n      if (_share == 0) {\\n        Ledgers[_ledger].RetailSplits.remove(_stakeholder);\\n        emit RetailRevenueSplitChange(_ledger, _stakeholder, _share, Ledgers[_ledger].RetailSplits.size(), Ledgers[_ledger].RetailSplits.total);\\n        return true;\\n      }\\n      if (Ledgers[_ledger].RetailSplits.contains(_stakeholder)) {\\n        require(Ledgers[_ledger].RetailSplits.size() <= 5, 'Cannot split revenue more than 5 ways.');\\n        total = Ledgers[_ledger].RetailSplits.total - Ledgers[_ledger].RetailSplits.get(_stakeholder);\\n      } else {\\n        require(Ledgers[_ledger].RetailSplits.size() < 5, 'Cannot split revenue more than 5 ways.');\\n        total = Ledgers[_ledger].RetailSplits.total;\\n      }\\n    } else {\\n      if (_share == 0) {\\n        Ledgers[_ledger].ResaleSplits.remove(_stakeholder);\\n        emit ResaleRevenueSplitChange(_ledger, _stakeholder, _share, Ledgers[_ledger].ResaleSplits.size(), Ledgers[_ledger].ResaleSplits.total);\\n        return true;\\n      }\\n      if (Ledgers[_ledger].ResaleSplits.contains(_stakeholder)) {\\n        require(Ledgers[_ledger].ResaleSplits.size() <= 5, 'Cannot split revenue more than 5 ways.');\\n        total = Ledgers[_ledger].ResaleSplits.total - Ledgers[_ledger].RetailSplits.get(_stakeholder);\\n      } else {\\n        require(Ledgers[_ledger].ResaleSplits.size() < 5, 'Cannot split revenue more than 5 ways.');\\n        total = Ledgers[_ledger].ResaleSplits.total;\\n      }\\n    }\\n    require(_share + total <= 100, 'Total revenue split cannot exceed 100%');\\n\\n    if (_retail) {\\n      Ledgers[_ledger].RetailSplits.set(_stakeholder, _share);\\n      emit RetailRevenueSplitChange(_ledger, _stakeholder, _share, Ledgers[_ledger].RetailSplits.size(), Ledgers[_ledger].RetailSplits.total);\\n    } else {\\n      Ledgers[_ledger].ResaleSplits.set(_stakeholder, _share);\\n      emit ResaleRevenueSplitChange(_ledger, _stakeholder, _share, Ledgers[_ledger].ResaleSplits.size(), Ledgers[_ledger].ResaleSplits.total);\\n    }\\n\\n    success = true;\\n  }\\n\\n  /**\\n   * @dev See {IRadRouter-getRevenueSplit}.\\n   */\\n  function getRevenueSplit(address _ledger, address payable _stakeholder, bool _retail) external view virtual override returns (uint256 share) {\\n    if (_retail) {\\n      share = Ledgers[_ledger].RetailSplits.get(_stakeholder);\\n    } else {\\n      share = Ledgers[_ledger].ResaleSplits.get(_stakeholder);\\n    }\\n  }\\n\\n  /**\\n   * @dev See {IRadRouter-setRevenueSplits}.\\n   */\\n  function setRevenueSplits(address _ledger, address payable[] calldata _stakeholders, uint256[] calldata _shares, bool _retail) public virtual override returns (bool success) {\\n    require(_stakeholders.length == _shares.length, 'Stakeholders and shares must have equal length');\\n    require(_stakeholders.length <= 5, 'Cannot split revenue more than 5 ways.');\\n    if (_retail) {\\n      Ledgers[_ledger].RetailSplits.clear();\\n    } else {\\n      Ledgers[_ledger].ResaleSplits.clear();\\n    }\\n    for (uint256 i = 0; i < _stakeholders.length; i++) {\\n      setRevenueSplit(_ledger, _stakeholders[i], _shares[i], _retail);\\n    }\\n\\n    success = true;\\n  }\\n\\n  function getRevenueStakeholders(address _ledger, bool _retail) external view virtual override returns (address[] memory stakeholders) {\\n    if (_retail) {\\n      stakeholders = Ledgers[_ledger].RetailSplits.keys;\\n    } else {\\n      stakeholders = Ledgers[_ledger].ResaleSplits.keys;\\n    }\\n  }\\n\\n  /**\\n   * @dev See {IRadRouter-setAssetMinPrice}.\\n   */\\n  function setAssetMinPrice(address _ledger, uint256 _assetId, uint256 _minPrice) public virtual override returns (bool success) {\\n    require(_ledger != address(0), 'Asset ledger cannot be the zero address');\\n    IERC721 ledger = IERC721(_ledger);\\n    address owner = ledger.ownerOf(_assetId);\\n    require(msg.sender == owner || msg.sender == administrator_, 'Only the asset owner or Rad administrator can set the asset minimum price');\\n    require(owner == address(this) || ledger.isApprovedForAll(owner, address(this)) || ledger.getApproved(_assetId) == address(this), 'Must approve Rad Router as an operator before setting minimum price.');\\n\\n    Ledgers[_ledger].Assets[_assetId].owner = owner;\\n    Ledgers[_ledger].Assets[_assetId].minPrice = _minPrice;\\n\\n    emit AssetMinPriceChange(_ledger, _assetId, _minPrice);\\n\\n    success = true;\\n  }\\n\\n  /**\\n   * @dev See {IRadRouter-getAssetMinPrice}.\\n   */\\n  function getAssetMinPrice(address _ledger, uint256 _assetId) external view virtual override returns (uint256 minPrice) {\\n    minPrice = Ledgers[_ledger].Assets[_assetId].minPrice;\\n  }\\n\\n  /**\\n   * @dev See {IRadRouter-setAssetMinPriceAndRevenueSplits}.\\n   */\\n  function setAssetMinPriceAndRevenueSplits(address _ledger, address payable[] calldata _stakeholders, uint256[] calldata _shares, bool _retail, uint256 _assetId, uint256 _minPrice) public virtual override returns (bool success) {\\n    success = setRevenueSplits(_ledger, _stakeholders, _shares, _retail) && setAssetMinPrice(_ledger, _assetId, _minPrice);\\n  }\\n\\n  /**\\n   * @dev See {IRadRouter-sellerEscrowDeposit}.\\n   */\\n  function sellerEscrowDeposit(address _ledger, uint256 _assetId) public virtual override returns (bool success) {\\n    success = sellerEscrowDeposit(_ledger, _assetId, false, 0);\\n  }\\n\\n  /**\\n   * @dev See {IRadRouter-sellerEscrowDepositWithCreatorShare}.\\n   */\\n  function sellerEscrowDepositWithCreatorShare(address _ledger, uint256 _assetId, uint256 _creatorResaleShare) public virtual override returns (bool success) {\\n    require(_ledger != address(0), 'Asset ledger cannot be the zero address');\\n    require(_creatorResaleShare >= 0 && _creatorResaleShare <= 100, 'Creator share must be at least 0% and at most 100%');\\n\\n    IERC721 ledger = IERC721(_ledger);\\n    address owner = ledger.ownerOf(_assetId);\\n\\n    require(\\n      msg.sender == owner ||\\n      msg.sender == administrator_,\\n      'Only the asset owner or Rad administrator can change asset ownership'\\n    );\\n\\n    require(\\n      ledger.isApprovedForAll(owner, address(this)) ||\\n      ledger.getApproved(_assetId) == address(this),\\n      'Must set Rad Router as an operator for all assets before depositing to escrow.'\\n    );\\n\\n    if (\\n      Ledgers[_ledger].Assets[_assetId].creator.wallet == address(0) ||\\n      Ledgers[_ledger].Assets[_assetId].creator.wallet == owner ||\\n      Ledgers[_ledger].Assets[_assetId].owner == owner\\n    ) {\\n      if (Ledgers[_ledger].Assets[_assetId].creator.wallet == address(0)) {\\n        Ledgers[_ledger].Assets[_assetId].creator.wallet = owner;\\n      }\\n\\n      require(\\n        Ledgers[_ledger].Assets[_assetId].creator.wallet == owner ||\\n        Ledgers[_ledger].Assets[_assetId].creator.share == 0 ||\\n        Ledgers[_ledger].Assets[_assetId].owner == owner,\\n        'Cannot set creator share.'\\n      );\\n\\n      uint256 total = Ledgers[_ledger].Assets[_assetId].creator.share;\\n      address[] storage stakeholders = Ledgers[_ledger].ResaleSplits.keys;\\n\\n      for (uint256 i = 0; i < stakeholders.length; i++) {\\n        total += Ledgers[_ledger].ResaleSplits.get(stakeholders[i]);\\n      }\\n\\n      require(total <= 100, 'Creator share cannot exceed total ledger stakeholder when it is 100.');\\n\\n      Ledgers[_ledger].Assets[_assetId].creator.share = _creatorResaleShare;\\n    }\\n\\n    success = sellerEscrowDeposit(_ledger, _assetId, false, 0);\\n  }\\n\\n  /**\\n   * @dev See {IRadRouter-sellerEscrowDepositWithCreatorShareBatch}.\\n   */\\n  function sellerEscrowDepositWithCreatorShareBatch(address _ledger, uint256[] calldata _assetIds, uint256 _creatorResaleShare) public virtual override returns (bool success) {\\n    success = false;\\n\\n    for (uint256 i = 0; i < _assetIds.length; i++) {\\n      if (!sellerEscrowDepositWithCreatorShare(_ledger, _assetIds[i], _creatorResaleShare)) {\\n        success = false;\\n        break;\\n      } else {\\n        success = true;\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @dev See {IRadRouter-sellerEscrowDepositWithCreatorShareWithMinPrice}.\\n   */\\n  function sellerEscrowDepositWithCreatorShareWithMinPrice(address _ledger, uint256 _assetId, uint256 _creatorResaleShare, uint256 _minPrice) public virtual override returns (bool success) {\\n    require(_ledger != address(0), 'Asset ledger cannot be the zero address');\\n    require(_creatorResaleShare >= 0 && _creatorResaleShare <= 100, 'Creator share must be at least 0% and at most 100%');\\n\\n    IERC721 ledger = IERC721(_ledger);\\n    address owner = ledger.ownerOf(_assetId);\\n\\n    require(\\n      msg.sender == owner ||\\n      msg.sender == administrator_,\\n      'Only the asset owner or Rad administrator can change asset ownership'\\n    );\\n\\n    require(\\n      ledger.isApprovedForAll(owner, address(this)) ||\\n      ledger.getApproved(_assetId) == address(this),\\n      'Must set Rad Router as an operator for all assets before depositing to escrow.'\\n    );\\n\\n    if (\\n      Ledgers[_ledger].Assets[_assetId].creator.wallet == address(0) ||\\n      Ledgers[_ledger].Assets[_assetId].creator.wallet == owner ||\\n      Ledgers[_ledger].Assets[_assetId].owner == owner\\n    ) {\\n      if (Ledgers[_ledger].Assets[_assetId].creator.wallet == address(0)) {\\n        Ledgers[_ledger].Assets[_assetId].creator.wallet = owner;\\n      }\\n\\n      require(\\n        Ledgers[_ledger].Assets[_assetId].creator.wallet == owner ||\\n        Ledgers[_ledger].Assets[_assetId].creator.share == 0 ||\\n        Ledgers[_ledger].Assets[_assetId].owner == owner,\\n        'Cannot set creator share.'\\n      );\\n\\n      uint256 total = Ledgers[_ledger].Assets[_assetId].creator.share;\\n      address[] storage stakeholders = Ledgers[_ledger].ResaleSplits.keys;\\n\\n      for (uint256 i = 0; i < stakeholders.length; i++) {\\n        total += Ledgers[_ledger].ResaleSplits.get(stakeholders[i]);\\n      }\\n\\n      require(total <= 100, 'Creator share cannot exceed total ledger stakeholder when it is 100.');\\n\\n      Ledgers[_ledger].Assets[_assetId].creator.share = _creatorResaleShare;\\n    }\\n\\n    success = sellerEscrowDeposit(_ledger, _assetId, true, _minPrice);\\n  }\\n\\n  /**\\n   * @dev See {IRadRouter-sellerEscrowDepositWithCreatorShareWithMinPriceBatch}.\\n   */\\n  function sellerEscrowDepositWithCreatorShareWithMinPriceBatch(address _ledger, uint256[] calldata _assetIds, uint256 _creatorResaleShare, uint256 _minPrice) public virtual override returns (bool success) {\\n    success = false;\\n    for (uint256 i = 0; i < _assetIds.length; i++) {\\n      if (!sellerEscrowDepositWithCreatorShareWithMinPrice(_ledger, _assetIds[i], _creatorResaleShare, _minPrice)) {\\n        success = false;\\n        break;\\n      } else {\\n        success = true;\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @dev See {IRadRouter-sellerEscrowDeposit}.\\n   */\\n  function sellerEscrowDeposit(address _ledger, uint256 _assetId, bool _setMinPrice, uint256 _minPrice) public virtual override returns (bool success) {\\n    require(_ledger != address(0), 'Asset ledger cannot be the zero address');\\n    IERC721 ledger = IERC721(_ledger);\\n    address owner = ledger.ownerOf(_assetId);\\n    require(msg.sender == owner || msg.sender == administrator_, 'Only the asset owner or Rad administrator can change asset ownership');\\n    require(ledger.isApprovedForAll(owner, address(this)) || ledger.getApproved(_assetId) == address(this), 'Must set Rad Router as an operator for all assets before depositing to escrow');\\n\\n    if (_setMinPrice) {\\n      require(Ledgers[_ledger].Assets[_assetId].buyer.wallet == address(0), 'Buyer cannot escrow first when seller batch escrow deposits with set asset min price.');\\n      setAssetMinPrice(_ledger, _assetId, _minPrice);\\n    }\\n\\n    Ledgers[_ledger].Assets[_assetId].owner = owner;\\n\\n    ledger.safeTransferFrom(owner, address(this), _assetId);\\n\\n    if (Ledgers[_ledger].Assets[_assetId].buyer.wallet != address(0)) {\\n      _fulfill(_ledger, _assetId);\\n    }\\n\\n    emit SellerEscrowChange(_ledger, _assetId, owner, true);\\n\\n    success = true;\\n  }\\n\\n  /**\\n   * @dev See {IRadRouter-sellerEscrowDepositBatch}.\\n   */\\n  function sellerEscrowDepositBatch(address _ledger, uint256[] calldata _assetIds) external virtual override returns (bool success) {\\n    success = sellerEscrowDepositBatch(_ledger, _assetIds, false, 0);\\n  }\\n\\n  /**\\n   * @dev See {IRadRouter-sellerEscrowDepositBatch}.\\n   */\\n  function sellerEscrowDepositBatch(address _ledger, uint256[] calldata _assetIds, bool _setMinPrice, uint256 _minPrice) public virtual override returns (bool success) {\\n    for (uint256 i = 0; i < _assetIds.length; i++) {\\n      sellerEscrowDeposit(_ledger, _assetIds[i], _setMinPrice, _minPrice);\\n    }\\n\\n    success = true;\\n  }\\n\\n  /**\\n   * @dev See {IRadRouter-sellerEscrowWithdraw}.\\n   */\\n  function sellerEscrowWithdraw(address _ledger, uint256 _assetId) external virtual override returns (bool success) {\\n    require(_ledger != address(0), 'Asset ledger cannot be the zero address');\\n    IERC721 ledger = IERC721(_ledger);\\n    address owner = Ledgers[_ledger].Assets[_assetId].owner;\\n    require(msg.sender == owner || msg.sender == administrator_, 'Only the asset owner or Rad administrator can change asset ownership');\\n    require(ledger.isApprovedForAll(owner, address(this)), 'Must set Rad Router as an operator for all assets before depositing to escrow');\\n\\n    Ledgers[_ledger].Assets[_assetId].creator.wallet = address(0);\\n    Ledgers[_ledger].Assets[_assetId].creator.share = 0;\\n\\n    ledger.safeTransferFrom(address(this), owner, _assetId);\\n\\n    emit SellerEscrowChange(_ledger, _assetId, owner, false);\\n\\n    success = true;\\n  }\\n\\n  /**\\n   * @dev See {IRadRouter-buyerEscrowDeposit}.\\n   */\\n  function buyerEscrowDeposit(address _ledger, uint256 _assetId) external payable virtual override returns (bool success) {\\n    require(_ledger != address(0), 'Asset ledger cannot be the zero address');\\n    require(Ledgers[_ledger].Assets[_assetId].owner != address(0), 'Asset is not being tracked');\\n    require(msg.value >= Ledgers[_ledger].Assets[_assetId].minPrice, 'Buyer did not send enough ETH');\\n    require (Ledgers[_ledger].Assets[_assetId].buyer.wallet == address(0), 'Another buyer has already escrowed');\\n    Ledgers[_ledger].Assets[_assetId].buyer.wallet = msg.sender;\\n    Ledgers[_ledger].Assets[_assetId].buyer.amountEscrowed = msg.value;\\n\\n    IERC721 ledger = IERC721(_ledger);\\n    if (ledger.ownerOf(_assetId) == address(this)) {\\n      _fulfill(_ledger, _assetId);\\n    }\\n\\n    emit BuyerEscrowChange(_ledger, _assetId, msg.sender, true);\\n\\n    success = true;\\n  }\\n\\n  /**\\n   * @dev See {IRadRouter-buyerEscrowWithdraw}.\\n   */\\n  function buyerEscrowWithdraw(address _ledger, uint256 _assetId) external virtual override returns (bool success) {\\n    require(msg.sender == Ledgers[_ledger].Assets[_assetId].buyer.wallet || msg.sender == Ledgers[_ledger].Assets[_assetId].owner || msg.sender == administrator_, 'msg.sender must be the buyer, seller, or Rad operator');\\n    require(_ledger != address(0), 'Asset ledger cannot be the zero address');\\n    Ledgers[_ledger].Assets[_assetId].buyer.wallet = address(0);\\n    Ledgers[_ledger].Assets[_assetId].buyer.amountEscrowed = 0;\\n    payable(Ledgers[_ledger].Assets[_assetId].buyer.wallet).transfer(Ledgers[_ledger].Assets[_assetId].buyer.amountEscrowed);\\n\\n    emit BuyerEscrowChange(_ledger, _assetId, msg.sender, false);\\n\\n    success = true;\\n  }\\n\\n  /**\\n   * @dev See {IRadRouter-getSellerWallet}.\\n   */\\n  function getSellerWallet(address _ledger, uint256 _assetId) public view override returns (address wallet) {\\n    if (Ledgers[_ledger].Assets[_assetId].owner == address(0)) {\\n      require(_ledger != address(0), 'Asset ledger cannot be the zero address');\\n      IERC721 ledger = IERC721(_ledger);\\n      wallet = ledger.ownerOf(_assetId);\\n    } else {\\n      wallet = Ledgers[_ledger].Assets[_assetId].owner;\\n    }\\n  }\\n\\n  /**\\n   * @dev See {IRadRouter-getBuyerWallet}.\\n   */\\n  function getBuyerWallet(address _ledger, uint256 _assetId) public view override returns (address wallet) {\\n    wallet = Ledgers[_ledger].Assets[_assetId].buyer.wallet;\\n  }\\n\\n  /**\\n   * @dev See {IRadRouter-getBuyerEscrow}.\\n   */\\n  function getBuyerDeposit(address _ledger, uint256 _assetId) public view override returns (uint256 amount) {\\n    amount = Ledgers[_ledger].Assets[_assetId].buyer.amountEscrowed;\\n  }\\n\\n  /**\\n   * @dev See {IRadRouter-getAssetIsResale}.\\n   */\\n  function getAssetIsResale(address _ledger, uint256 _assetId) public view override returns (bool resale) {\\n    resale = Ledgers[_ledger].Assets[_assetId].resale;\\n  }\\n\\n  /**\\n   * @dev See {IRadRouter-getRetailedAssets}.\\n   */\\n  function getRetailedAssets(address _ledger) public view override returns (uint256[] memory assets) {\\n    assets = Ledgers[_ledger].retailedAssets;\\n  }\\n\\n  /**\\n   * @dev See {IRadRouter-getCreatorWallet}.\\n   */\\n  function getCreatorWallet(address _ledger, uint256 _assetId) public view override returns (address wallet) {\\n    wallet = Ledgers[_ledger].Assets[_assetId].creator.wallet;\\n  }\\n\\n  /**\\n   * @dev See {IRadRouter-getCreatorShare}.\\n   */\\n  function getCreatorShare(address _ledger, uint256 _assetId) public view override returns (uint256 amount) {\\n    amount = Ledgers[_ledger].Assets[_assetId].creator.share;\\n  }\\n\\n  /**\\n   * @dev Fulfills asset sale transaction and pays out all revenue split stakeholders\\n   *\\n   * Requirements:\\n   *\\n   * - `_ledger` cannot be the zero address.\\n   * - `_assetId` owner must be this contract\\n   * - `_assetId` buyer must not be the zero address\\n   *\\n   * Emits a {EscrowFulfill} event.\\n   */\\n  function _fulfill(address _ledger, uint256 _assetId) internal virtual returns (bool success) {\\n    IERC721 ledger = IERC721(_ledger);\\n\\n    require(\\n      ledger.ownerOf(_assetId) == address(this),\\n      'Seller has not escrowed'\\n    );\\n\\n    require(\\n      Ledgers[_ledger].Assets[_assetId].buyer.wallet != address(0),\\n      'Buyer has not escrowed'\\n    );\\n\\n    ledger.safeTransferFrom(\\n      address(this),\\n      Ledgers[_ledger].Assets[_assetId].buyer.wallet,\\n      _assetId\\n    );\\n\\n    if (!Ledgers[_ledger].Assets[_assetId].resale) {\\n      if (Ledgers[_ledger].RetailSplits.size() > 0) {\\n        uint256 totalShareSplit = 0;\\n\\n        for (uint256 i = 0; i < Ledgers[_ledger].RetailSplits.size(); i++) {\\n          address stakeholder = Ledgers[_ledger].RetailSplits.getKeyAtIndex(i);\\n          uint256 share = Ledgers[_ledger].RetailSplits.get(stakeholder);\\n\\n          if (totalShareSplit + share > 100) {\\n            share = totalShareSplit + share - 100;\\n          }\\n\\n          uint256 payout = Ledgers[_ledger].Assets[_assetId].buyer.amountEscrowed * share / 100;\\n          payable(stakeholder).transfer(payout);\\n          emit StakeholderPayout(_ledger, _assetId, stakeholder, payout, share, true);\\n          totalShareSplit += share;\\n\\n          // ignore other share stake holders if total max split has been reached\\n          if (totalShareSplit >= 100) {\\n            break;\\n          }\\n        }\\n\\n        if (totalShareSplit < 100) {\\n          uint256 remainingShare = 100 - totalShareSplit;\\n          uint256 payout = Ledgers[_ledger].Assets[_assetId].buyer.amountEscrowed * remainingShare / 100;\\n          payable(Ledgers[_ledger].Assets[_assetId].owner).transfer(payout);\\n          emit StakeholderPayout(_ledger, _assetId, Ledgers[_ledger].Assets[_assetId].owner, payout, remainingShare, true);\\n        }\\n      } else { // if no revenue split is defined, send all to asset owner\\n        uint256 payout = Ledgers[_ledger].Assets[_assetId].buyer.amountEscrowed;\\n        payable(ledger.ownerOf(_assetId)).transfer(payout);\\n        emit StakeholderPayout(_ledger, _assetId, ledger.ownerOf(_assetId), payout, 100, true);\\n      }\\n\\n      Ledgers[_ledger].Assets[_assetId].resale = true;\\n      Ledgers[_ledger].retailedAssets.push(_assetId);\\n    } else {\\n      uint256 creatorResaleShare = Ledgers[_ledger].Assets[_assetId].creator.share;\\n      uint256 totalShareSplit = 0;\\n      uint256 creatorPayout = Ledgers[_ledger].Assets[_assetId].buyer.amountEscrowed * creatorResaleShare / 100;\\n      address creator = Ledgers[_ledger].Assets[_assetId].creator.wallet;\\n\\n      if (creatorResaleShare > 0) {\\n        totalShareSplit = creatorResaleShare;\\n        payable(creator).transfer(creatorPayout);\\n        emit StakeholderPayout(_ledger, _assetId, creator, creatorPayout, creatorResaleShare, false);\\n      }\\n\\n      if (Ledgers[_ledger].ResaleSplits.size() > 0) {\\n        for (uint256 i = 0; i < Ledgers[_ledger].ResaleSplits.size(); i++) {\\n          address stakeholder = Ledgers[_ledger].ResaleSplits.getKeyAtIndex(i);\\n          uint256 share = Ledgers[_ledger].ResaleSplits.get(stakeholder) - (creatorResaleShare / 100);\\n\\n          if (totalShareSplit + share > 100) {\\n            share = totalShareSplit + share - 100;\\n          }\\n\\n          uint256 payout = Ledgers[_ledger].Assets[_assetId].buyer.amountEscrowed * share / 100;\\n\\n          payable(stakeholder).transfer(payout);\\n          emit StakeholderPayout(_ledger, _assetId, stakeholder, payout, share, false);\\n\\n          totalShareSplit += share;\\n\\n          // ignore other share stake holders if total max split has been reached\\n          if (totalShareSplit >= 100) {\\n            break;\\n          }\\n        }\\n\\n        if (totalShareSplit < 100) {\\n          uint256 remainingShare = 100 - totalShareSplit;\\n          uint256 payout = Ledgers[_ledger].Assets[_assetId].buyer.amountEscrowed * remainingShare / 100;\\n          payable(Ledgers[_ledger].Assets[_assetId].owner).transfer(payout);\\n          emit StakeholderPayout(_ledger, _assetId, Ledgers[_ledger].Assets[_assetId].owner, payout, remainingShare, false);\\n        }\\n      } else { // if no revenue split is defined, send all to asset owner\\n        uint256 remainingShare = 100 - totalShareSplit;\\n        uint256 payout = Ledgers[_ledger].Assets[_assetId].buyer.amountEscrowed * remainingShare / 100;\\n        payable(ledger.ownerOf(_assetId)).transfer(payout);\\n        emit StakeholderPayout(_ledger, _assetId, ledger.ownerOf(_assetId), payout, remainingShare, false);\\n      }\\n    }\\n\\n    emit EscrowFulfill(\\n      _ledger,\\n      _assetId,\\n      Ledgers[_ledger].Assets[_assetId].owner,\\n      Ledgers[_ledger].Assets[_assetId].buyer.wallet,\\n      Ledgers[_ledger].Assets[_assetId].buyer.amountEscrowed\\n    );\\n\\n    Ledgers[_ledger].Assets[_assetId].owner = Ledgers[_ledger].Assets[_assetId].buyer.wallet;\\n    Ledgers[_ledger].Assets[_assetId].minPrice = 0;\\n    Ledgers[_ledger].Assets[_assetId].buyer.wallet = address(0);\\n    Ledgers[_ledger].Assets[_assetId].buyer.amountEscrowed = 0;\\n\\n    success = true;\\n  }\\n}\\n\"\r\n    },\r\n    \"/Users/dom/repos/rad-contracts/contracts/RevenueSplitMapping.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity >=0.6.8 <0.9.0;\\n\\nstruct RevMap {\\n    address[] keys;\\n    uint256 total;\\n    mapping(address => IndexValue) values;\\n}\\n\\nstruct IndexValue {\\n    uint256 value;\\n    uint256 indexOf;\\n    bool inserted;\\n}\\n\\n// https://solidity-by-example.org/app/iterable-mapping/\\nlibrary RevenueSplitMapping {\\n    function get(RevMap storage map, address key) external view returns (uint256) {\\n        return map.values[key].value;\\n    }\\n\\n    function getKeyAtIndex(RevMap storage map, uint256 index) external view returns (address) {\\n        return map.keys[index];\\n    }\\n\\n    function size(RevMap storage map) external view returns (uint256) {\\n        return map.keys.length;\\n    }\\n\\n    function set(RevMap storage map, address key, uint256 val) external {\\n        if (map.values[key].inserted) {\\n            map.total-=map.values[key].value;\\n            map.values[key].value = val;\\n            map.total+=val;\\n        } else {\\n            map.values[key].inserted = true;\\n            map.values[key].value = val;\\n            map.total+=val;\\n            map.values[key].indexOf = map.keys.length;\\n            map.keys.push(key);\\n        }\\n    }\\n\\n    function remove(RevMap storage map, address key) external {\\n        if (!map.values[key].inserted) {\\n            return;\\n        }\\n\\n        map.total-=map.values[key].value;\\n\\n        uint256 index = map.values[key].indexOf;\\n        uint256 lastIndex = map.keys.length - 1;\\n        address lastKey = map.keys[lastIndex];\\n\\n        map.values[lastKey].indexOf = index;\\n        delete map.values[key];\\n\\n        map.keys[index] = lastKey;\\n        map.keys.pop();\\n    }\\n\\n    function contains(RevMap storage map, address key) external view returns(bool) {\\n        return map.values[key].inserted;\\n    }\\n\\n    function clear(RevMap storage map) external {\\n        for (uint256 i = 0; i < map.keys.length; i++) {\\n            delete map.values[map.keys[i]];\\n        }\\n        delete map.keys;\\n        map.total = 0;\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\\n      *\\n      * Requirements:\\n      *\\n      * - `from` cannot be the zero address.\\n      * - `to` cannot be the zero address.\\n      * - `tokenId` token must exist and be owned by `from`.\\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n      *\\n      * Emits a {Transfer} event.\\n      */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721Receiver.sol\\\";\\n\\n  /**\\n   * @dev Implementation of the {IERC721Receiver} interface.\\n   *\\n   * Accepts all token transfers.\\n   * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\\n   */\\ncontract ERC721Holder is IERC721Receiver {\\n\\n    /**\\n     * @dev See {IERC721Receiver-onERC721Received}.\\n     *\\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {\r\n      \"/Users/dom/repos/rad-contracts/contracts/RevenueSplitMapping.sol\": {\r\n        \"RevenueSplitMapping\": \"0xB9cEab7949087adE9b48AF49b9e5B0947cCD31E8\"\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ledger\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minPrice\",\"type\":\"uint256\"}],\"name\":\"AssetMinPriceChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ledger\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"escrowed\",\"type\":\"bool\"}],\"name\":\"BuyerEscrowChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ledger\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"EscrowFulfill\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ledger\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakeholder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"share\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalStakeholders\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalSplit\",\"type\":\"uint256\"}],\"name\":\"ResaleRevenueSplitChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ledger\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakeholder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"share\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalStakeholders\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalSplit\",\"type\":\"uint256\"}],\"name\":\"RetailRevenueSplitChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ledger\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"escrowed\",\"type\":\"bool\"}],\"name\":\"SellerEscrowChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ledger\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakeholder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"share\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"retail\",\"type\":\"bool\"}],\"name\":\"StakeholderPayout\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"administrator_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ledger\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_assetId\",\"type\":\"uint256\"}],\"name\":\"buyerEscrowDeposit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ledger\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_assetId\",\"type\":\"uint256\"}],\"name\":\"buyerEscrowWithdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ledger\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_assetId\",\"type\":\"uint256\"}],\"name\":\"getAssetIsResale\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"resale\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ledger\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_assetId\",\"type\":\"uint256\"}],\"name\":\"getAssetMinPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ledger\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_assetId\",\"type\":\"uint256\"}],\"name\":\"getBuyerDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ledger\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_assetId\",\"type\":\"uint256\"}],\"name\":\"getBuyerWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ledger\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_assetId\",\"type\":\"uint256\"}],\"name\":\"getCreatorShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ledger\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_assetId\",\"type\":\"uint256\"}],\"name\":\"getCreatorWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ledger\",\"type\":\"address\"}],\"name\":\"getRetailedAssets\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"assets\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ledger\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_stakeholder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_retail\",\"type\":\"bool\"}],\"name\":\"getRevenueSplit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"share\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ledger\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_retail\",\"type\":\"bool\"}],\"name\":\"getRevenueStakeholders\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"stakeholders\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ledger\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_assetId\",\"type\":\"uint256\"}],\"name\":\"getSellerWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ledger\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_assetId\",\"type\":\"uint256\"}],\"name\":\"sellerEscrowDeposit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ledger\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_assetId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_setMinPrice\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_minPrice\",\"type\":\"uint256\"}],\"name\":\"sellerEscrowDeposit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ledger\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_assetIds\",\"type\":\"uint256[]\"}],\"name\":\"sellerEscrowDepositBatch\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ledger\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_assetIds\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"_setMinPrice\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_minPrice\",\"type\":\"uint256\"}],\"name\":\"sellerEscrowDepositBatch\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ledger\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_assetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_creatorResaleShare\",\"type\":\"uint256\"}],\"name\":\"sellerEscrowDepositWithCreatorShare\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ledger\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_assetIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_creatorResaleShare\",\"type\":\"uint256\"}],\"name\":\"sellerEscrowDepositWithCreatorShareBatch\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ledger\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_assetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_creatorResaleShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minPrice\",\"type\":\"uint256\"}],\"name\":\"sellerEscrowDepositWithCreatorShareWithMinPrice\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ledger\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_assetIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_creatorResaleShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minPrice\",\"type\":\"uint256\"}],\"name\":\"sellerEscrowDepositWithCreatorShareWithMinPriceBatch\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ledger\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_assetId\",\"type\":\"uint256\"}],\"name\":\"sellerEscrowWithdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ledger\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_assetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minPrice\",\"type\":\"uint256\"}],\"name\":\"setAssetMinPrice\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ledger\",\"type\":\"address\"},{\"internalType\":\"address payable[]\",\"name\":\"_stakeholders\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_shares\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"_retail\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_assetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minPrice\",\"type\":\"uint256\"}],\"name\":\"setAssetMinPriceAndRevenueSplits\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ledger\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_stakeholder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_share\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_retail\",\"type\":\"bool\"}],\"name\":\"setRevenueSplit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ledger\",\"type\":\"address\"},{\"internalType\":\"address payable[]\",\"name\":\"_stakeholders\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_shares\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"_retail\",\"type\":\"bool\"}],\"name\":\"setRevenueSplits\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"RadRouter","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}