{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at polygonscan.com on 2021-07-23\r\n*/\r\n\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/roles/Roles.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping(address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev Give an account access to this role.\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(!has(role, account), 'Roles: account already has role');\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove an account's access to this role.\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(has(role, account), 'Roles: account does not have role');\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if an account has this role.\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0), 'Roles: account is the zero address');\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n// File: contracts/roles/AgentRole.sol\r\n\r\n// SPDX-License-Identifier: GPL-3.0\r\n/**\r\n *     NOTICE\r\n *\r\n *     The T-REX software is licensed under a proprietary license or the GPL v.3.\r\n *     If you choose to receive it under the GPL v.3 license, the following applies:\r\n *     T-REX is a suite of smart contracts developed by Tokeny to manage and transfer financial assets on the ethereum blockchain\r\n *\r\n *     Copyright (C) 2019, Tokeny s√†rl.\r\n *\r\n *     This program is free software: you can redistribute it and/or modify\r\n *     it under the terms of the GNU General Public License as published by\r\n *     the Free Software Foundation, either version 3 of the License, or\r\n *     (at your option) any later version.\r\n *\r\n *     This program is distributed in the hope that it will be useful,\r\n *     but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *     GNU General Public License for more details.\r\n *\r\n *     You should have received a copy of the GNU General Public License\r\n *     along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n */\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\ncontract AgentRole is Ownable {\r\n    using Roles for Roles.Role;\r\n\r\n    event AgentAdded(address indexed _agent);\r\n    event AgentRemoved(address indexed _agent);\r\n\r\n    Roles.Role private _agents;\r\n\r\n    modifier onlyAgent() {\r\n        require(isAgent(msg.sender), 'AgentRole: caller does not have the Agent role');\r\n        _;\r\n    }\r\n\r\n    function isAgent(address _agent) public view returns (bool) {\r\n        return _agents.has(_agent);\r\n    }\r\n\r\n    function addAgent(address _agent) public onlyOwner {\r\n        _agents.add(_agent);\r\n        emit AgentAdded(_agent);\r\n    }\r\n\r\n    function removeAgent(address _agent) public onlyOwner {\r\n        _agents.remove(_agent);\r\n        emit AgentRemoved(_agent);\r\n    }\r\n}\r\n\r\n// File: @onchain-id/solidity/contracts/interface/IERC734.sol\r\n\r\n/**\r\n * @dev interface of the ERC734 (Key Holder) standard as defined in the EIP.\r\n */\r\ninterface IERC734 {\r\n\r\n    /**\r\n     * @dev Emitted when an execution request was approved.\r\n     *\r\n     * Specification: MUST be triggered when approve was successfully called.\r\n     */\r\n    event Approved(uint256 indexed executionId, bool approved);\r\n\r\n    /**\r\n     * @dev Emitted when an execute operation was approved and successfully performed.\r\n     *\r\n     * Specification: MUST be triggered when approve was called and the execution was successfully approved.\r\n     */\r\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\r\n\r\n    /**\r\n     * @dev Emitted when an execution request was performed via `execute`.\r\n     *\r\n     * Specification: MUST be triggered when execute was successfully called.\r\n     */\r\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\r\n\r\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\r\n\r\n    /**\r\n     * @dev Emitted when a key was added to the Identity.\r\n     *\r\n     * Specification: MUST be triggered when addKey was successfully called.\r\n     */\r\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\r\n\r\n    /**\r\n     * @dev Emitted when a key was removed from the Identity.\r\n     *\r\n     * Specification: MUST be triggered when removeKey was successfully called.\r\n     */\r\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\r\n\r\n    /**\r\n     * @dev Emitted when the list of required keys to perform an action was updated.\r\n     *\r\n     * Specification: MUST be triggered when changeKeysRequired was successfully called.\r\n     */\r\n    event KeysRequiredChanged(uint256 purpose, uint256 number);\r\n\r\n\r\n    /**\r\n     * @dev Adds a _key to the identity. The _purpose specifies the purpose of the key.\r\n     *\r\n     * Triggers Event: `KeyAdded`\r\n     *\r\n     * Specification: MUST only be done by keys of purpose 1, or the identity itself. If it's the identity itself, the approval process will determine its approval.\r\n     */\r\n    function addKey(bytes32 _key, uint256 _purpose, uint256 _keyType) external returns (bool success);\r\n\r\n    /**\r\n    * @dev Approves an execution or claim addition.\r\n    *\r\n    * Triggers Event: `Approved`, `Executed`\r\n    *\r\n    * Specification:\r\n    * This SHOULD require n of m approvals of keys purpose 1, if the _to of the execution is the identity contract itself, to successfully approve an execution.\r\n    * And COULD require n of m approvals of keys purpose 2, if the _to of the execution is another contract, to successfully approve an execution.\r\n    */\r\n    function approve(uint256 _id, bool _approve) external returns (bool success);\r\n\r\n    /**\r\n     * @dev Passes an execution instruction to an ERC725 identity.\r\n     *\r\n     * Triggers Event: `ExecutionRequested`, `Executed`\r\n     *\r\n     * Specification:\r\n     * SHOULD require approve to be called with one or more keys of purpose 1 or 2 to approve this execution.\r\n     * Execute COULD be used as the only accessor for `addKey` and `removeKey`.\r\n     */\r\n    function execute(address _to, uint256 _value, bytes calldata _data) external payable returns (uint256 executionId);\r\n\r\n    /**\r\n     * @dev Returns the full key data, if present in the identity.\r\n     */\r\n    function getKey(bytes32 _key) external view returns (uint256[] memory purposes, uint256 keyType, bytes32 key);\r\n\r\n    /**\r\n     * @dev Returns the list of purposes associated with a key.\r\n     */\r\n    function getKeyPurposes(bytes32 _key) external view returns(uint256[] memory _purposes);\r\n\r\n    /**\r\n     * @dev Returns an array of public key bytes32 held by this identity.\r\n     */\r\n    function getKeysByPurpose(uint256 _purpose) external view returns (bytes32[] memory keys);\r\n\r\n    /**\r\n     * @dev Returns TRUE if a key is present and has the given purpose. If the key is not present it returns FALSE.\r\n     */\r\n    function keyHasPurpose(bytes32 _key, uint256 _purpose) external view returns (bool exists);\r\n\r\n    /**\r\n     * @dev Removes _purpose for _key from the identity.\r\n     *\r\n     * Triggers Event: `KeyRemoved`\r\n     *\r\n     * Specification: MUST only be done by keys of purpose 1, or the identity itself. If it's the identity itself, the approval process will determine its approval.\r\n     */\r\n    function removeKey(bytes32 _key, uint256 _purpose) external returns (bool success);\r\n}\r\n\r\n// File: @onchain-id/solidity/contracts/interface/IERC735.sol\r\n\r\n\r\n/**\r\n * @dev interface of the ERC735 (Claim Holder) standard as defined in the EIP.\r\n */\r\ninterface IERC735 {\r\n\r\n    /**\r\n     * @dev Emitted when a claim request was performed.\r\n     *\r\n     * Specification: Is not clear\r\n     */\r\n    event ClaimRequested(uint256 indexed claimRequestId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\r\n\r\n    /**\r\n     * @dev Emitted when a claim was added.\r\n     *\r\n     * Specification: MUST be triggered when a claim was successfully added.\r\n     */\r\n    event ClaimAdded(bytes32 indexed claimId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\r\n\r\n    /**\r\n     * @dev Emitted when a claim was removed.\r\n     *\r\n     * Specification: MUST be triggered when removeClaim was successfully called.\r\n     */\r\n    event ClaimRemoved(bytes32 indexed claimId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\r\n\r\n    /**\r\n     * @dev Emitted when a claim was changed.\r\n     *\r\n     * Specification: MUST be triggered when changeClaim was successfully called.\r\n     */\r\n    event ClaimChanged(bytes32 indexed claimId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\r\n\r\n    /**\r\n     * @dev Get a claim by its ID.\r\n     *\r\n     * Claim IDs are generated using `keccak256(abi.encode(address issuer_address, uint256 topic))`.\r\n     */\r\n    function getClaim(bytes32 _claimId) external view returns(uint256 topic, uint256 scheme, address issuer, bytes memory signature, bytes memory data, string memory uri);\r\n\r\n    /**\r\n     * @dev Returns an array of claim IDs by topic.\r\n     */\r\n    function getClaimIdsByTopic(uint256 _topic) external view returns(bytes32[] memory claimIds);\r\n\r\n    /**\r\n     * @dev Add or update a claim.\r\n     *\r\n     * Triggers Event: `ClaimRequested`, `ClaimAdded`, `ClaimChanged`\r\n     *\r\n     * Specification: Requests the ADDITION or the CHANGE of a claim from an issuer.\r\n     * Claims can requested to be added by anybody, including the claim holder itself (self issued).\r\n     *\r\n     * _signature is a signed message of the following structure: `keccak256(abi.encode(address identityHolder_address, uint256 topic, bytes data))`.\r\n     * Claim IDs are generated using `keccak256(abi.encode(address issuer_address + uint256 topic))`.\r\n     *\r\n     * This COULD implement an approval process for pending claims, or add them right away.\r\n     * MUST return a claimRequestId (use claim ID) that COULD be sent to the approve function.\r\n     */\r\n    function addClaim(uint256 _topic, uint256 _scheme, address issuer, bytes calldata _signature, bytes calldata _data, string calldata _uri) external returns (bytes32 claimRequestId);\r\n\r\n    /**\r\n     * @dev Removes a claim.\r\n     *\r\n     * Triggers Event: `ClaimRemoved`\r\n     *\r\n     * Claim IDs are generated using `keccak256(abi.encode(address issuer_address, uint256 topic))`.\r\n     */\r\n    function removeClaim(bytes32 _claimId) external returns (bool success);\r\n}\r\n\r\n// File: @onchain-id/solidity/contracts/interface/IIdentity.sol\r\n\r\n\r\n\r\n\r\ninterface IIdentity is IERC734, IERC735 {}\r\n\r\n// File: @onchain-id/solidity/contracts/interface/IClaimIssuer.sol\r\n\r\ninterface IClaimIssuer is IIdentity {\r\n    function revokeClaim(bytes32 _claimId, address _identity) external returns(bool);\r\n    function getRecoveredAddress(bytes calldata sig, bytes32 dataHash) external pure returns (address);\r\n    function isClaimRevoked(bytes calldata _sig) external view returns (bool);\r\n    function isClaimValid(IIdentity _identity, uint256 claimTopic, bytes calldata sig, bytes calldata data) external view returns (bool);\r\n}\r\n\r\n// File: contracts/registry/ITrustedIssuersRegistry.sol\r\n\r\n\r\ninterface ITrustedIssuersRegistry {\r\n    /**\r\n     *  this event is emitted when a trusted issuer is added in the registry.\r\n     *  the event is emitted by the addTrustedIssuer function\r\n     *  `trustedIssuer` is the address of the trusted issuer's ClaimIssuer contract\r\n     *  `claimTopics` is the set of claims that the trusted issuer is allowed to emit\r\n     */\r\n    event TrustedIssuerAdded(IClaimIssuer indexed trustedIssuer, uint256[] claimTopics);\r\n\r\n    /**\r\n     *  this event is emitted when a trusted issuer is removed from the registry.\r\n     *  the event is emitted by the removeTrustedIssuer function\r\n     *  `trustedIssuer` is the address of the trusted issuer's ClaimIssuer contract\r\n     */\r\n    event TrustedIssuerRemoved(IClaimIssuer indexed trustedIssuer);\r\n\r\n    /**\r\n     *  this event is emitted when the set of claim topics is changed for a given trusted issuer.\r\n     *  the event is emitted by the updateIssuerClaimTopics function\r\n     *  `trustedIssuer` is the address of the trusted issuer's ClaimIssuer contract\r\n     *  `claimTopics` is the set of claims that the trusted issuer is allowed to emit\r\n     */\r\n    event ClaimTopicsUpdated(IClaimIssuer indexed trustedIssuer, uint256[] claimTopics);\r\n\r\n    /**\r\n     *  @dev registers a ClaimIssuer contract as trusted claim issuer.\r\n     *  Requires that a ClaimIssuer contract doesn't already exist\r\n     *  Requires that the claimTopics set is not empty\r\n     *  @param _trustedIssuer The ClaimIssuer contract address of the trusted claim issuer.\r\n     *  @param _claimTopics the set of claim topics that the trusted issuer is allowed to emit\r\n     *  This function can only be called by the owner of the Trusted Issuers Registry contract\r\n     *  emits a `TrustedIssuerAdded` event\r\n     */\r\n    function addTrustedIssuer(IClaimIssuer _trustedIssuer, uint256[] calldata _claimTopics) external;\r\n\r\n    /**\r\n     *  @dev Removes the ClaimIssuer contract of a trusted claim issuer.\r\n     *  Requires that the claim issuer contract to be registered first\r\n     *  @param _trustedIssuer the claim issuer to remove.\r\n     *  This function can only be called by the owner of the Trusted Issuers Registry contract\r\n     *  emits a `TrustedIssuerRemoved` event\r\n     */\r\n    function removeTrustedIssuer(IClaimIssuer _trustedIssuer) external;\r\n\r\n    /**\r\n     *  @dev Updates the set of claim topics that a trusted issuer is allowed to emit.\r\n     *  Requires that this ClaimIssuer contract already exists in the registry\r\n     *  Requires that the provided claimTopics set is not empty\r\n     *  @param _trustedIssuer the claim issuer to update.\r\n     *  @param _claimTopics the set of claim topics that the trusted issuer is allowed to emit\r\n     *  This function can only be called by the owner of the Trusted Issuers Registry contract\r\n     *  emits a `ClaimTopicsUpdated` event\r\n     */\r\n    function updateIssuerClaimTopics(IClaimIssuer _trustedIssuer, uint256[] calldata _claimTopics) external;\r\n\r\n    /**\r\n     *  @dev Function for getting all the trusted claim issuers stored.\r\n     *  @return array of all claim issuers registered.\r\n     */\r\n    function getTrustedIssuers() external view returns (IClaimIssuer[] memory);\r\n\r\n    /**\r\n     *  @dev Checks if the ClaimIssuer contract is trusted\r\n     *  @param _issuer the address of the ClaimIssuer contract\r\n     *  @return true if the issuer is trusted, false otherwise.\r\n     */\r\n    function isTrustedIssuer(address _issuer) external view returns (bool);\r\n\r\n    /**\r\n     *  @dev Function for getting all the claim topic of trusted claim issuer\r\n     *  Requires the provided ClaimIssuer contract to be registered in the trusted issuers registry.\r\n     *  @param _trustedIssuer the trusted issuer concerned.\r\n     *  @return The set of claim topics that the trusted issuer is allowed to emit\r\n     */\r\n    function getTrustedIssuerClaimTopics(IClaimIssuer _trustedIssuer) external view returns (uint256[] memory);\r\n\r\n    /**\r\n     *  @dev Function for checking if the trusted claim issuer is allowed\r\n     *  to emit a certain claim topic\r\n     *  @param _issuer the address of the trusted issuer's ClaimIssuer contract\r\n     *  @param _claimTopic the Claim Topic that has to be checked to know if the `issuer` is allowed to emit it\r\n     *  @return true if the issuer is trusted for this claim topic.\r\n     */\r\n    function hasClaimTopic(address _issuer, uint256 _claimTopic) external view returns (bool);\r\n\r\n    /**\r\n     *  @dev Transfers the Ownership of TrustedIssuersRegistry to a new Owner.\r\n     *  @param _newOwner The new owner of this contract.\r\n     *  This function can only be called by the owner of the Trusted Issuers Registry contract\r\n     *  emits an `OwnershipTransferred` event\r\n     */\r\n    function transferOwnershipOnIssuersRegistryContract(address _newOwner) external;\r\n}\r\n\r\n// File: contracts/registry/IClaimTopicsRegistry.sol\r\n\r\ninterface IClaimTopicsRegistry {\r\n    /**\r\n     *  this event is emitted when a claim topic has been added to the ClaimTopicsRegistry\r\n     *  the event is emitted by the 'addClaimTopic' function\r\n     *  `claimTopic` is the required claim added to the Claim Topics Registry\r\n     */\r\n    event ClaimTopicAdded(uint256 indexed claimTopic);\r\n\r\n    /**\r\n     *  this event is emitted when a claim topic has been removed from the ClaimTopicsRegistry\r\n     *  the event is emitted by the 'removeClaimTopic' function\r\n     *  `claimTopic` is the required claim removed from the Claim Topics Registry\r\n     */\r\n    event ClaimTopicRemoved(uint256 indexed claimTopic);\r\n\r\n    /**\r\n     * @dev Add a trusted claim topic (For example: KYC=1, AML=2).\r\n     * Only owner can call.\r\n     * emits `ClaimTopicAdded` event\r\n     * @param _claimTopic The claim topic index\r\n     */\r\n    function addClaimTopic(uint256 _claimTopic) external;\r\n\r\n    /**\r\n     *  @dev Remove a trusted claim topic (For example: KYC=1, AML=2).\r\n     *  Only owner can call.\r\n     *  emits `ClaimTopicRemoved` event\r\n     *  @param _claimTopic The claim topic index\r\n     */\r\n    function removeClaimTopic(uint256 _claimTopic) external;\r\n\r\n    /**\r\n     *  @dev Get the trusted claim topics for the security token\r\n     *  @return Array of trusted claim topics\r\n     */\r\n    function getClaimTopics() external view returns (uint256[] memory);\r\n\r\n    /**\r\n     *  @dev Transfers the Ownership of ClaimTopics to a new Owner.\r\n     *  Only owner can call.\r\n     *  @param _newOwner The new owner of this contract.\r\n     */\r\n    function transferOwnershipOnClaimTopicsRegistryContract(address _newOwner) external;\r\n}\r\n\r\n// File: contracts/registry/IIdentityRegistryStorage.sol\r\n\r\ninterface IIdentityRegistryStorage {\r\n    /**\r\n     *  this event is emitted when an Identity is registered into the storage contract.\r\n     *  the event is emitted by the 'registerIdentity' function\r\n     *  `investorAddress` is the address of the investor's wallet\r\n     *  `identity` is the address of the Identity smart contract (onchainID)\r\n     */\r\n    event IdentityStored(address indexed investorAddress, IIdentity indexed identity);\r\n\r\n    /**\r\n     *  this event is emitted when an Identity is removed from the storage contract.\r\n     *  the event is emitted by the 'deleteIdentity' function\r\n     *  `investorAddress` is the address of the investor's wallet\r\n     *  `identity` is the address of the Identity smart contract (onchainID)\r\n     */\r\n    event IdentityUnstored(address indexed investorAddress, IIdentity indexed identity);\r\n\r\n    /**\r\n     *  this event is emitted when an Identity has been updated\r\n     *  the event is emitted by the 'updateIdentity' function\r\n     *  `oldIdentity` is the old Identity contract's address to update\r\n     *  `newIdentity` is the new Identity contract's\r\n     */\r\n    event IdentityModified(IIdentity indexed oldIdentity, IIdentity indexed newIdentity);\r\n\r\n    /**\r\n     *  this event is emitted when an Identity's country has been updated\r\n     *  the event is emitted by the 'updateCountry' function\r\n     *  `investorAddress` is the address on which the country has been updated\r\n     *  `country` is the numeric code (ISO 3166-1) of the new country\r\n     */\r\n    event CountryModified(address indexed investorAddress, uint16 indexed country);\r\n\r\n    /**\r\n     *  this event is emitted when an Identity Registry is bound to the storage contract\r\n     *  the event is emitted by the 'addIdentityRegistry' function\r\n     *  `identityRegistry` is the address of the identity registry added\r\n     */\r\n    event IdentityRegistryBound(address indexed identityRegistry);\r\n\r\n    /**\r\n     *  this event is emitted when an Identity Registry is unbound from the storage contract\r\n     *  the event is emitted by the 'removeIdentityRegistry' function\r\n     *  `identityRegistry` is the address of the identity registry removed\r\n     */\r\n    event IdentityRegistryUnbound(address indexed identityRegistry);\r\n\r\n    /**\r\n     *  @dev Returns the identity registries linked to the storage contract\r\n     */\r\n    function linkedIdentityRegistries() external view returns (address[] memory);\r\n\r\n    /**\r\n     *  @dev Returns the onchainID of an investor.\r\n     *  @param _userAddress The wallet of the investor\r\n     */\r\n    function storedIdentity(address _userAddress) external view returns (IIdentity);\r\n\r\n    /**\r\n     *  @dev Returns the country code of an investor.\r\n     *  @param _userAddress The wallet of the investor\r\n     */\r\n    function storedInvestorCountry(address _userAddress) external view returns (uint16);\r\n\r\n    /**\r\n     *  @dev adds an identity contract corresponding to a user address in the storage.\r\n     *  Requires that the user doesn't have an identity contract already registered.\r\n     *  This function can only be called by an address set as agent of the smart contract\r\n     *  @param _userAddress The address of the user\r\n     *  @param _identity The address of the user's identity contract\r\n     *  @param _country The country of the investor\r\n     *  emits `IdentityStored` event\r\n     */\r\n    function addIdentityToStorage(\r\n        address _userAddress,\r\n        IIdentity _identity,\r\n        uint16 _country\r\n    ) external;\r\n\r\n    /**\r\n     *  @dev Removes an user from the storage.\r\n     *  Requires that the user have an identity contract already deployed that will be deleted.\r\n     *  This function can only be called by an address set as agent of the smart contract\r\n     *  @param _userAddress The address of the user to be removed\r\n     *  emits `IdentityUnstored` event\r\n     */\r\n    function removeIdentityFromStorage(address _userAddress) external;\r\n\r\n    /**\r\n     *  @dev Updates the country corresponding to a user address.\r\n     *  Requires that the user should have an identity contract already deployed that will be replaced.\r\n     *  This function can only be called by an address set as agent of the smart contract\r\n     *  @param _userAddress The address of the user\r\n     *  @param _country The new country of the user\r\n     *  emits `CountryModified` event\r\n     */\r\n    function modifyStoredInvestorCountry(address _userAddress, uint16 _country) external;\r\n\r\n    /**\r\n     *  @dev Updates an identity contract corresponding to a user address.\r\n     *  Requires that the user address should be the owner of the identity contract.\r\n     *  Requires that the user should have an identity contract already deployed that will be replaced.\r\n     *  This function can only be called by an address set as agent of the smart contract\r\n     *  @param _userAddress The address of the user\r\n     *  @param _identity The address of the user's new identity contract\r\n     *  emits `IdentityModified` event\r\n     */\r\n    function modifyStoredIdentity(address _userAddress, IIdentity _identity) external;\r\n\r\n    /**\r\n     *  @notice Transfers the Ownership of the Identity Registry Storage to a new Owner.\r\n     *  This function can only be called by the wallet set as owner of the smart contract\r\n     *  @param _newOwner The new owner of this contract.\r\n     */\r\n    function transferOwnershipOnIdentityRegistryStorage(address _newOwner) external;\r\n\r\n    /**\r\n     *  @notice Adds an identity registry as agent of the Identity Registry Storage Contract.\r\n     *  This function can only be called by the wallet set as owner of the smart contract\r\n     *  This function adds the identity registry to the list of identityRegistries linked to the storage contract\r\n     *  @param _identityRegistry The identity registry address to add.\r\n     */\r\n    function bindIdentityRegistry(address _identityRegistry) external;\r\n\r\n    /**\r\n     *  @notice Removes an identity registry from being agent of the Identity Registry Storage Contract.\r\n     *  This function can only be called by the wallet set as owner of the smart contract\r\n     *  This function removes the identity registry from the list of identityRegistries linked to the storage contract\r\n     *  @param _identityRegistry The identity registry address to remove.\r\n     */\r\n    function unbindIdentityRegistry(address _identityRegistry) external;\r\n}\r\n\r\n// File: contracts/registry/IIdentityRegistry.sol\r\n\r\ninterface IIdentityRegistry {\r\n    /**\r\n     *  this event is emitted when the ClaimTopicsRegistry has been set for the IdentityRegistry\r\n     *  the event is emitted by the IdentityRegistry constructor\r\n     *  `claimTopicsRegistry` is the address of the Claim Topics Registry contract\r\n     */\r\n    event ClaimTopicsRegistrySet(address indexed claimTopicsRegistry);\r\n\r\n    /**\r\n     *  this event is emitted when the IdentityRegistryStorage has been set for the IdentityRegistry\r\n     *  the event is emitted by the IdentityRegistry constructor\r\n     *  `identityStorage` is the address of the Identity Registry Storage contract\r\n     */\r\n    event IdentityStorageSet(address indexed identityStorage);\r\n\r\n    /**\r\n     *  this event is emitted when the ClaimTopicsRegistry has been set for the IdentityRegistry\r\n     *  the event is emitted by the IdentityRegistry constructor\r\n     *  `trustedIssuersRegistry` is the address of the Trusted Issuers Registry contract\r\n     */\r\n    event TrustedIssuersRegistrySet(address indexed trustedIssuersRegistry);\r\n\r\n    /**\r\n     *  this event is emitted when an Identity is registered into the Identity Registry.\r\n     *  the event is emitted by the 'registerIdentity' function\r\n     *  `investorAddress` is the address of the investor's wallet\r\n     *  `identity` is the address of the Identity smart contract (onchainID)\r\n     */\r\n    event IdentityRegistered(address indexed investorAddress, IIdentity indexed identity);\r\n\r\n    /**\r\n     *  this event is emitted when an Identity is removed from the Identity Registry.\r\n     *  the event is emitted by the 'deleteIdentity' function\r\n     *  `investorAddress` is the address of the investor's wallet\r\n     *  `identity` is the address of the Identity smart contract (onchainID)\r\n     */\r\n    event IdentityRemoved(address indexed investorAddress, IIdentity indexed identity);\r\n\r\n    /**\r\n     *  this event is emitted when an Identity has been updated\r\n     *  the event is emitted by the 'updateIdentity' function\r\n     *  `oldIdentity` is the old Identity contract's address to update\r\n     *  `newIdentity` is the new Identity contract's\r\n     */\r\n    event IdentityUpdated(IIdentity indexed oldIdentity, IIdentity indexed newIdentity);\r\n\r\n    /**\r\n     *  this event is emitted when an Identity's country has been updated\r\n     *  the event is emitted by the 'updateCountry' function\r\n     *  `investorAddress` is the address on which the country has been updated\r\n     *  `country` is the numeric code (ISO 3166-1) of the new country\r\n     */\r\n    event CountryUpdated(address indexed investorAddress, uint16 indexed country);\r\n\r\n    /**\r\n     *  @dev Register an identity contract corresponding to a user address.\r\n     *  Requires that the user doesn't have an identity contract already registered.\r\n     *  This function can only be called by a wallet set as agent of the smart contract\r\n     *  @param _userAddress The address of the user\r\n     *  @param _identity The address of the user's identity contract\r\n     *  @param _country The country of the investor\r\n     *  emits `IdentityRegistered` event\r\n     */\r\n    function registerIdentity(\r\n        address _userAddress,\r\n        IIdentity _identity,\r\n        uint16 _country\r\n    ) external;\r\n\r\n    /**\r\n     *  @dev Removes an user from the identity registry.\r\n     *  Requires that the user have an identity contract already deployed that will be deleted.\r\n     *  This function can only be called by a wallet set as agent of the smart contract\r\n     *  @param _userAddress The address of the user to be removed\r\n     *  emits `IdentityRemoved` event\r\n     */\r\n    function deleteIdentity(address _userAddress) external;\r\n\r\n    /**\r\n     *  @dev Replace the actual identityRegistryStorage contract with a new one.\r\n     *  This function can only be called by the wallet set as owner of the smart contract\r\n     *  @param _identityRegistryStorage The address of the new Identity Registry Storage\r\n     *  emits `IdentityStorageSet` event\r\n     */\r\n    function setIdentityRegistryStorage(address _identityRegistryStorage) external;\r\n\r\n    /**\r\n     *  @dev Replace the actual claimTopicsRegistry contract with a new one.\r\n     *  This function can only be called by the wallet set as owner of the smart contract\r\n     *  @param _claimTopicsRegistry The address of the new claim Topics Registry\r\n     *  emits `ClaimTopicsRegistrySet` event\r\n     */\r\n    function setClaimTopicsRegistry(address _claimTopicsRegistry) external;\r\n\r\n    /**\r\n     *  @dev Replace the actual trustedIssuersRegistry contract with a new one.\r\n     *  This function can only be called by the wallet set as owner of the smart contract\r\n     *  @param _trustedIssuersRegistry The address of the new Trusted Issuers Registry\r\n     *  emits `TrustedIssuersRegistrySet` event\r\n     */\r\n    function setTrustedIssuersRegistry(address _trustedIssuersRegistry) external;\r\n\r\n    /**\r\n     *  @dev Updates the country corresponding to a user address.\r\n     *  Requires that the user should have an identity contract already deployed that will be replaced.\r\n     *  This function can only be called by a wallet set as agent of the smart contract\r\n     *  @param _userAddress The address of the user\r\n     *  @param _country The new country of the user\r\n     *  emits `CountryUpdated` event\r\n     */\r\n    function updateCountry(address _userAddress, uint16 _country) external;\r\n\r\n    /**\r\n     *  @dev Updates an identity contract corresponding to a user address.\r\n     *  Requires that the user address should be the owner of the identity contract.\r\n     *  Requires that the user should have an identity contract already deployed that will be replaced.\r\n     *  This function can only be called by a wallet set as agent of the smart contract\r\n     *  @param _userAddress The address of the user\r\n     *  @param _identity The address of the user's new identity contract\r\n     *  emits `IdentityUpdated` event\r\n     */\r\n    function updateIdentity(address _userAddress, IIdentity _identity) external;\r\n\r\n    /**\r\n     *  @dev function allowing to register identities in batch\r\n     *  This function can only be called by a wallet set as agent of the smart contract\r\n     *  Requires that none of the users has an identity contract already registered.\r\n     *  IMPORTANT : THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_userAddresses.length` IS TOO HIGH,\r\n     *  USE WITH CARE OR YOU COULD LOSE TX FEES WITH AN \"OUT OF GAS\" TRANSACTION\r\n     *  @param _userAddresses The addresses of the users\r\n     *  @param _identities The addresses of the corresponding identity contracts\r\n     *  @param _countries The countries of the corresponding investors\r\n     *  emits _userAddresses.length `IdentityRegistered` events\r\n     */\r\n    function batchRegisterIdentity(\r\n        address[] calldata _userAddresses,\r\n        IIdentity[] calldata _identities,\r\n        uint16[] calldata _countries\r\n    ) external;\r\n\r\n    /**\r\n     *  @dev This functions checks whether a wallet has its Identity registered or not\r\n     *  in the Identity Registry.\r\n     *  @param _userAddress The address of the user to be checked.\r\n     *  @return 'True' if the address is contained in the Identity Registry, 'false' if not.\r\n     */\r\n    function contains(address _userAddress) external view returns (bool);\r\n\r\n    /**\r\n     *  @dev This functions checks whether an identity contract\r\n     *  corresponding to the provided user address has the required claims or not based\r\n     *  on the data fetched from trusted issuers registry and from the claim topics registry\r\n     *  @param _userAddress The address of the user to be verified.\r\n     *  @return 'True' if the address is verified, 'false' if not.\r\n     */\r\n    function isVerified(address _userAddress) external view returns (bool);\r\n\r\n    /**\r\n     *  @dev Returns the onchainID of an investor.\r\n     *  @param _userAddress The wallet of the investor\r\n     */\r\n    function identity(address _userAddress) external view returns (IIdentity);\r\n\r\n    /**\r\n     *  @dev Returns the country code of an investor.\r\n     *  @param _userAddress The wallet of the investor\r\n     */\r\n    function investorCountry(address _userAddress) external view returns (uint16);\r\n\r\n    /**\r\n     *  @dev Returns the IdentityRegistryStorage linked to the current IdentityRegistry.\r\n     */\r\n    function identityStorage() external view returns (IIdentityRegistryStorage);\r\n\r\n    /**\r\n     *  @dev Returns the TrustedIssuersRegistry linked to the current IdentityRegistry.\r\n     */\r\n    function issuersRegistry() external view returns (ITrustedIssuersRegistry);\r\n\r\n    /**\r\n     *  @dev Returns the ClaimTopicsRegistry linked to the current IdentityRegistry.\r\n     */\r\n    function topicsRegistry() external view returns (IClaimTopicsRegistry);\r\n\r\n    /**\r\n     *  @notice Transfers the Ownership of the Identity Registry to a new Owner.\r\n     *  This function can only be called by the wallet set as owner of the smart contract\r\n     *  @param _newOwner The new owner of this contract.\r\n     */\r\n    function transferOwnershipOnIdentityRegistryContract(address _newOwner) external;\r\n\r\n    /**\r\n     *  @notice Adds an address as _agent of the Identity Registry Contract.\r\n     *  This function can only be called by the wallet set as owner of the smart contract\r\n     *  @param _agent The _agent's address to add.\r\n     */\r\n    function addAgentOnIdentityRegistryContract(address _agent) external;\r\n\r\n    /**\r\n     *  @notice Removes an address from being _agent of the Identity Registry Contract.\r\n     *  This function can only be called by the wallet set as owner of the smart contract\r\n     *  @param _agent The _agent's address to remove.\r\n     */\r\n    function removeAgentOnIdentityRegistryContract(address _agent) external;\r\n}\r\n\r\n// File: contracts/compliance/ICompliance.sol\r\n\r\ninterface ICompliance {\r\n    /**\r\n     *  this event is emitted when the Agent has been added on the allowedList of this Compliance.\r\n     *  the event is emitted by the Compliance constructor and by the addTokenAgent function\r\n     *  `_agentAddress` is the address of the Agent to add\r\n     */\r\n    event TokenAgentAdded(address _agentAddress);\r\n\r\n    /**\r\n     *  this event is emitted when the Agent has been removed from the agent list of this Compliance.\r\n     *  the event is emitted by the Compliance constructor and by the removeTokenAgent function\r\n     *  `_agentAddress` is the address of the Agent to remove\r\n     */\r\n    event TokenAgentRemoved(address _agentAddress);\r\n\r\n    /**\r\n     *  this event is emitted when a token has been bound to the compliance contract\r\n     *  the event is emitted by the bindToken function\r\n     *  `_token` is the address of the token to bind\r\n     */\r\n    event TokenBound(address _token);\r\n\r\n    /**\r\n     *  this event is emitted when a token has been unbound from the compliance contract\r\n     *  the event is emitted by the unbindToken function\r\n     *  `_token` is the address of the token to unbind\r\n     */\r\n    event TokenUnbound(address _token);\r\n\r\n    /**\r\n     *  @dev Returns true if the Address is in the list of token agents\r\n     *  @param _agentAddress address of this agent\r\n     */\r\n    function isTokenAgent(address _agentAddress) external view returns (bool);\r\n\r\n    /**\r\n     *  @dev Returns true if the address given corresponds to a token that is bound with the Compliance contract\r\n     *  @param _token address of the token\r\n     */\r\n    function isTokenBound(address _token) external view returns (bool);\r\n\r\n    /**\r\n     *  @dev adds an agent to the list of token agents\r\n     *  @param _agentAddress address of the agent to be added\r\n     *  Emits a TokenAgentAdded event\r\n     */\r\n    function addTokenAgent(address _agentAddress) external;\r\n\r\n    /**\r\n     *  @dev remove Agent from the list of token agents\r\n     *  @param _agentAddress address of the agent to be removed (must be added first)\r\n     *  Emits a TokenAgentRemoved event\r\n     */\r\n    function removeTokenAgent(address _agentAddress) external;\r\n\r\n    /**\r\n     *  @dev binds a token to the compliance contract\r\n     *  @param _token address of the token to bind\r\n     *  Emits a TokenBound event\r\n     */\r\n    function bindToken(address _token) external;\r\n\r\n    /**\r\n     *  @dev unbinds a token from the compliance contract\r\n     *  @param _token address of the token to unbind\r\n     *  Emits a TokenUnbound event\r\n     */\r\n    function unbindToken(address _token) external;\r\n\r\n    /**\r\n     *  @dev checks that the transfer is compliant.\r\n     *  default compliance always returns true\r\n     *  READ ONLY FUNCTION, this function cannot be used to increment\r\n     *  counters, emit events, ...\r\n     *  @param _from The address of the sender\r\n     *  @param _to The address of the receiver\r\n     *  @param _amount The amount of tokens involved in the transfer\r\n     */\r\n    function canTransfer(\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    ) external view returns (bool);\r\n\r\n    /**\r\n     *  @dev function called whenever tokens are transferred\r\n     *  from one wallet to another\r\n     *  this function can update state variables in the compliance contract\r\n     *  these state variables being used by `canTransfer` to decide if a transfer\r\n     *  is compliant or not depending on the values stored in these state variables and on\r\n     *  the parameters of the compliance smart contract\r\n     *  @param _from The address of the sender\r\n     *  @param _to The address of the receiver\r\n     *  @param _amount The amount of tokens involved in the transfer\r\n     */\r\n    function transferred(\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    ) external;\r\n\r\n    /**\r\n     *  @dev function called whenever tokens are created\r\n     *  on a wallet\r\n     *  this function can update state variables in the compliance contract\r\n     *  these state variables being used by `canTransfer` to decide if a transfer\r\n     *  is compliant or not depending on the values stored in these state variables and on\r\n     *  the parameters of the compliance smart contract\r\n     *  @param _to The address of the receiver\r\n     *  @param _amount The amount of tokens involved in the transfer\r\n     */\r\n    function created(address _to, uint256 _amount) external;\r\n\r\n    /**\r\n     *  @dev function called whenever tokens are destroyed\r\n     *  this function can update state variables in the compliance contract\r\n     *  these state variables being used by `canTransfer` to decide if a transfer\r\n     *  is compliant or not depending on the values stored in these state variables and on\r\n     *  the parameters of the compliance smart contract\r\n     *  @param _from The address of the receiver\r\n     *  @param _amount The amount of tokens involved in the transfer\r\n     */\r\n    function destroyed(address _from, uint256 _amount) external;\r\n\r\n    /**\r\n     *  @dev function used to transfer the ownership of the compliance contract\r\n     *  to a new owner, giving him access to the `OnlyOwner` functions implemented on the contract\r\n     *  @param newOwner The address of the new owner of the compliance contract\r\n     *  This function can only be called by the owner of the compliance contract\r\n     *  emits an `OwnershipTransferred` event\r\n     */\r\n    function transferOwnershipOnComplianceContract(address newOwner) external;\r\n}\r\n\r\n// File: contracts/token/IERC20.sol\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/token/IToken.sol\r\n\r\n/// @dev interface\r\ninterface IToken is IERC20 {\r\n    /**\r\n     *  this event is emitted when the token information is updated.\r\n     *  the event is emitted by the token constructor and by the setTokenInformation function\r\n     *  `_newName` is the name of the token\r\n     *  `_newSymbol` is the symbol of the token\r\n     *  `_newDecimals` is the decimals of the token\r\n     *  `_newVersion` is the version of the token, current version is 3.0\r\n     *  `_newOnchainID` is the address of the onchainID of the token\r\n     */\r\n    event UpdatedTokenInformation(string _newName, string _newSymbol, uint8 _newDecimals, string _newVersion, address _newOnchainID);\r\n\r\n    /**\r\n     *  this event is emitted when the IdentityRegistry has been set for the token\r\n     *  the event is emitted by the token constructor and by the setIdentityRegistry function\r\n     *  `_identityRegistry` is the address of the Identity Registry of the token\r\n     */\r\n    event IdentityRegistryAdded(address indexed _identityRegistry);\r\n\r\n    /**\r\n     *  this event is emitted when the Compliance has been set for the token\r\n     *  the event is emitted by the token constructor and by the setCompliance function\r\n     *  `_compliance` is the address of the Compliance contract of the token\r\n     */\r\n    event ComplianceAdded(address indexed _compliance);\r\n\r\n    /**\r\n     *  this event is emitted when an investor successfully recovers his tokens\r\n     *  the event is emitted by the recoveryAddress function\r\n     *  `_lostWallet` is the address of the wallet that the investor lost access to\r\n     *  `_newWallet` is the address of the wallet that the investor provided for the recovery\r\n     *  `_investorOnchainID` is the address of the onchainID of the investor who asked for a recovery\r\n     */\r\n    event RecoverySuccess(address _lostWallet, address _newWallet, address _investorOnchainID);\r\n\r\n    /**\r\n     *  this event is emitted when the wallet of an investor is frozen or unfrozen\r\n     *  the event is emitted by setAddressFrozen and batchSetAddressFrozen functions\r\n     *  `_userAddress` is the wallet of the investor that is concerned by the freezing status\r\n     *  `_isFrozen` is the freezing status of the wallet\r\n     *  if `_isFrozen` equals `true` the wallet is frozen after emission of the event\r\n     *  if `_isFrozen` equals `false` the wallet is unfrozen after emission of the event\r\n     *  `_owner` is the address of the agent who called the function to freeze the wallet\r\n     */\r\n    event AddressFrozen(address indexed _userAddress, bool indexed _isFrozen, address indexed _owner);\r\n\r\n    /**\r\n     *  this event is emitted when a certain amount of tokens is frozen on a wallet\r\n     *  the event is emitted by freezePartialTokens and batchFreezePartialTokens functions\r\n     *  `_userAddress` is the wallet of the investor that is concerned by the freezing status\r\n     *  `_amount` is the amount of tokens that are frozen\r\n     */\r\n    event TokensFrozen(address indexed _userAddress, uint256 _amount);\r\n\r\n    /**\r\n     *  this event is emitted when a certain amount of tokens is unfrozen on a wallet\r\n     *  the event is emitted by unfreezePartialTokens and batchUnfreezePartialTokens functions\r\n     *  `_userAddress` is the wallet of the investor that is concerned by the freezing status\r\n     *  `_amount` is the amount of tokens that are unfrozen\r\n     */\r\n    event TokensUnfrozen(address indexed _userAddress, uint256 _amount);\r\n\r\n    /**\r\n     *  this event is emitted when the token is paused\r\n     *  the event is emitted by the pause function\r\n     *  `_userAddress` is the address of the wallet that called the pause function\r\n     */\r\n    event Paused(address _userAddress);\r\n\r\n    /**\r\n     *  this event is emitted when the token is unpaused\r\n     *  the event is emitted by the unpause function\r\n     *  `_userAddress` is the address of the wallet that called the unpause function\r\n     */\r\n    event Unpaused(address _userAddress);\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 1 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * balanceOf() and transfer().\r\n     */\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the address of the onchainID of the token.\r\n     * the onchainID of the token gives all the information available\r\n     * about the token and is managed by the token issuer or his agent.\r\n     */\r\n    function onchainID() external view returns (address);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the TREX version of the token.\r\n     * current version is 3.0.0\r\n     */\r\n    function version() external view returns (string memory);\r\n\r\n    /**\r\n     *  @dev Returns the Identity Registry linked to the token\r\n     */\r\n    function identityRegistry() external view returns (IIdentityRegistry);\r\n\r\n    /**\r\n     *  @dev Returns the Compliance contract linked to the token\r\n     */\r\n    function compliance() external view returns (ICompliance);\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() external view returns (bool);\r\n\r\n    /**\r\n     *  @dev Returns the freezing status of a wallet\r\n     *  if isFrozen returns `true` the wallet is frozen\r\n     *  if isFrozen returns `false` the wallet is not frozen\r\n     *  isFrozen returning `true` doesn't mean that the balance is free, tokens could be blocked by\r\n     *  a partial freeze or the whole token could be blocked by pause\r\n     *  @param _userAddress the address of the wallet on which isFrozen is called\r\n     */\r\n    function isFrozen(address _userAddress) external view returns (bool);\r\n\r\n    /**\r\n     *  @dev Returns the amount of tokens that are partially frozen on a wallet\r\n     *  the amount of frozen tokens is always <= to the total balance of the wallet\r\n     *  @param _userAddress the address of the wallet on which getFrozenTokens is called\r\n     */\r\n    function getFrozenTokens(address _userAddress) external view returns (uint256);\r\n\r\n    /**\r\n     *  @dev sets the token name\r\n     *  @param _name the name of token to set\r\n     *  Only the owner of the token smart contract can call this function\r\n     *  emits a `UpdatedTokenInformation` event\r\n     */\r\n    function setName(string calldata _name) external;\r\n\r\n    /**\r\n     *  @dev sets the token symbol\r\n     *  @param _symbol the token symbol to set\r\n     *  Only the owner of the token smart contract can call this function\r\n     *  emits a `UpdatedTokenInformation` event\r\n     */\r\n    function setSymbol(string calldata _symbol) external;\r\n\r\n    /**\r\n     *  @dev sets the onchain ID of the token\r\n     *  @param _onchainID the address of the onchain ID to set\r\n     *  Only the owner of the token smart contract can call this function\r\n     *  emits a `UpdatedTokenInformation` event\r\n     */\r\n    function setOnchainID(address _onchainID) external;\r\n\r\n    /**\r\n     *  @dev pauses the token contract, when contract is paused investors cannot transfer tokens anymore\r\n     *  This function can only be called by a wallet set as agent of the token\r\n     *  emits a `Paused` event\r\n     */\r\n    function pause() external;\r\n\r\n    /**\r\n     *  @dev unpauses the token contract, when contract is unpaused investors can transfer tokens\r\n     *  if their wallet is not blocked & if the amount to transfer is <= to the amount of free tokens\r\n     *  This function can only be called by a wallet set as agent of the token\r\n     *  emits an `Unpaused` event\r\n     */\r\n    function unpause() external;\r\n\r\n    /**\r\n     *  @dev sets an address frozen status for this token.\r\n     *  @param _userAddress The address for which to update frozen status\r\n     *  @param _freeze Frozen status of the address\r\n     *  This function can only be called by a wallet set as agent of the token\r\n     *  emits an `AddressFrozen` event\r\n     */\r\n    function setAddressFrozen(address _userAddress, bool _freeze) external;\r\n\r\n    /**\r\n     *  @dev freezes token amount specified for given address.\r\n     *  @param _userAddress The address for which to update frozen tokens\r\n     *  @param _amount Amount of Tokens to be frozen\r\n     *  This function can only be called by a wallet set as agent of the token\r\n     *  emits a `TokensFrozen` event\r\n     */\r\n    function freezePartialTokens(address _userAddress, uint256 _amount) external;\r\n\r\n    /**\r\n     *  @dev unfreezes token amount specified for given address\r\n     *  @param _userAddress The address for which to update frozen tokens\r\n     *  @param _amount Amount of Tokens to be unfrozen\r\n     *  This function can only be called by a wallet set as agent of the token\r\n     *  emits a `TokensUnfrozen` event\r\n     */\r\n    function unfreezePartialTokens(address _userAddress, uint256 _amount) external;\r\n\r\n    /**\r\n     *  @dev sets the Identity Registry for the token\r\n     *  @param _identityRegistry the address of the Identity Registry to set\r\n     *  Only the owner of the token smart contract can call this function\r\n     *  emits an `IdentityRegistryAdded` event\r\n     */\r\n    function setIdentityRegistry(address _identityRegistry) external;\r\n\r\n    /**\r\n     *  @dev sets the compliance contract of the token\r\n     *  @param _compliance the address of the compliance contract to set\r\n     *  Only the owner of the token smart contract can call this function\r\n     *  emits a `ComplianceAdded` event\r\n     */\r\n    function setCompliance(address _compliance) external;\r\n\r\n    /**\r\n     *  @dev force a transfer of tokens between 2 whitelisted wallets\r\n     *  In case the `from` address has not enough free tokens (unfrozen tokens)\r\n     *  but has a total balance higher or equal to the `amount`\r\n     *  the amount of frozen tokens is reduced in order to have enough free tokens\r\n     *  to proceed the transfer, in such a case, the remaining balance on the `from`\r\n     *  account is 100% composed of frozen tokens post-transfer.\r\n     *  Require that the `to` address is a verified address,\r\n     *  @param _from The address of the sender\r\n     *  @param _to The address of the receiver\r\n     *  @param _amount The number of tokens to transfer\r\n     *  @return `true` if successful and revert if unsuccessful\r\n     *  This function can only be called by a wallet set as agent of the token\r\n     *  emits a `TokensUnfrozen` event if `_amount` is higher than the free balance of `_from`\r\n     *  emits a `Transfer` event\r\n     */\r\n    function forcedTransfer(\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     *  @dev mint tokens on a wallet\r\n     *  Improved version of default mint method. Tokens can be minted\r\n     *  to an address if only it is a verified address as per the security token.\r\n     *  @param _to Address to mint the tokens to.\r\n     *  @param _amount Amount of tokens to mint.\r\n     *  This function can only be called by a wallet set as agent of the token\r\n     *  emits a `Transfer` event\r\n     */\r\n    function mint(address _to, uint256 _amount) external;\r\n\r\n    /**\r\n     *  @dev burn tokens on a wallet\r\n     *  In case the `account` address has not enough free tokens (unfrozen tokens)\r\n     *  but has a total balance higher or equal to the `value` amount\r\n     *  the amount of frozen tokens is reduced in order to have enough free tokens\r\n     *  to proceed the burn, in such a case, the remaining balance on the `account`\r\n     *  is 100% composed of frozen tokens post-transaction.\r\n     *  @param _userAddress Address to burn the tokens from.\r\n     *  @param _amount Amount of tokens to burn.\r\n     *  This function can only be called by a wallet set as agent of the token\r\n     *  emits a `TokensUnfrozen` event if `_amount` is higher than the free balance of `_userAddress`\r\n     *  emits a `Transfer` event\r\n     */\r\n    function burn(address _userAddress, uint256 _amount) external;\r\n\r\n    /**\r\n     *  @dev recovery function used to force transfer tokens from a\r\n     *  lost wallet to a new wallet for an investor.\r\n     *  @param _lostWallet the wallet that the investor lost\r\n     *  @param _newWallet the newly provided wallet on which tokens have to be transferred\r\n     *  @param _investorOnchainID the onchainID of the investor asking for a recovery\r\n     *  This function can only be called by a wallet set as agent of the token\r\n     *  emits a `TokensUnfrozen` event if there is some frozen tokens on the lost wallet if the recovery process is successful\r\n     *  emits a `Transfer` event if the recovery process is successful\r\n     *  emits a `RecoverySuccess` event if the recovery process is successful\r\n     *  emits a `RecoveryFails` event if the recovery process fails\r\n     */\r\n    function recoveryAddress(\r\n        address _lostWallet,\r\n        address _newWallet,\r\n        address _investorOnchainID\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     *  @dev function allowing to issue transfers in batch\r\n     *  Require that the msg.sender and `to` addresses are not frozen.\r\n     *  Require that the total value should not exceed available balance.\r\n     *  Require that the `to` addresses are all verified addresses,\r\n     *  IMPORTANT : THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_toList.length` IS TOO HIGH,\r\n     *  USE WITH CARE OR YOU COULD LOSE TX FEES WITH AN \"OUT OF GAS\" TRANSACTION\r\n     *  @param _toList The addresses of the receivers\r\n     *  @param _amounts The number of tokens to transfer to the corresponding receiver\r\n     *  emits _toList.length `Transfer` events\r\n     */\r\n    function batchTransfer(address[] calldata _toList, uint256[] calldata _amounts) external;\r\n\r\n    /**\r\n     *  @dev function allowing to issue forced transfers in batch\r\n     *  Require that `_amounts[i]` should not exceed available balance of `_fromList[i]`.\r\n     *  Require that the `_toList` addresses are all verified addresses\r\n     *  IMPORTANT : THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_fromList.length` IS TOO HIGH,\r\n     *  USE WITH CARE OR YOU COULD LOSE TX FEES WITH AN \"OUT OF GAS\" TRANSACTION\r\n     *  @param _fromList The addresses of the senders\r\n     *  @param _toList The addresses of the receivers\r\n     *  @param _amounts The number of tokens to transfer to the corresponding receiver\r\n     *  This function can only be called by a wallet set as agent of the token\r\n     *  emits `TokensUnfrozen` events if `_amounts[i]` is higher than the free balance of `_fromList[i]`\r\n     *  emits _fromList.length `Transfer` events\r\n     */\r\n    function batchForcedTransfer(\r\n        address[] calldata _fromList,\r\n        address[] calldata _toList,\r\n        uint256[] calldata _amounts\r\n    ) external;\r\n\r\n    /**\r\n     *  @dev function allowing to mint tokens in batch\r\n     *  Require that the `_toList` addresses are all verified addresses\r\n     *  IMPORTANT : THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_toList.length` IS TOO HIGH,\r\n     *  USE WITH CARE OR YOU COULD LOSE TX FEES WITH AN \"OUT OF GAS\" TRANSACTION\r\n     *  @param _toList The addresses of the receivers\r\n     *  @param _amounts The number of tokens to mint to the corresponding receiver\r\n     *  This function can only be called by a wallet set as agent of the token\r\n     *  emits _toList.length `Transfer` events\r\n     */\r\n    function batchMint(address[] calldata _toList, uint256[] calldata _amounts) external;\r\n\r\n    /**\r\n     *  @dev function allowing to burn tokens in batch\r\n     *  Require that the `_userAddresses` addresses are all verified addresses\r\n     *  IMPORTANT : THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_userAddresses.length` IS TOO HIGH,\r\n     *  USE WITH CARE OR YOU COULD LOSE TX FEES WITH AN \"OUT OF GAS\" TRANSACTION\r\n     *  @param _userAddresses The addresses of the wallets concerned by the burn\r\n     *  @param _amounts The number of tokens to burn from the corresponding wallets\r\n     *  This function can only be called by a wallet set as agent of the token\r\n     *  emits _userAddresses.length `Transfer` events\r\n     */\r\n    function batchBurn(address[] calldata _userAddresses, uint256[] calldata _amounts) external;\r\n\r\n    /**\r\n     *  @dev function allowing to set frozen addresses in batch\r\n     *  IMPORTANT : THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_userAddresses.length` IS TOO HIGH,\r\n     *  USE WITH CARE OR YOU COULD LOSE TX FEES WITH AN \"OUT OF GAS\" TRANSACTION\r\n     *  @param _userAddresses The addresses for which to update frozen status\r\n     *  @param _freeze Frozen status of the corresponding address\r\n     *  This function can only be called by a wallet set as agent of the token\r\n     *  emits _userAddresses.length `AddressFrozen` events\r\n     */\r\n    function batchSetAddressFrozen(address[] calldata _userAddresses, bool[] calldata _freeze) external;\r\n\r\n    /**\r\n     *  @dev function allowing to freeze tokens partially in batch\r\n     *  IMPORTANT : THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_userAddresses.length` IS TOO HIGH,\r\n     *  USE WITH CARE OR YOU COULD LOSE TX FEES WITH AN \"OUT OF GAS\" TRANSACTION\r\n     *  @param _userAddresses The addresses on which tokens need to be frozen\r\n     *  @param _amounts the amount of tokens to freeze on the corresponding address\r\n     *  This function can only be called by a wallet set as agent of the token\r\n     *  emits _userAddresses.length `TokensFrozen` events\r\n     */\r\n    function batchFreezePartialTokens(address[] calldata _userAddresses, uint256[] calldata _amounts) external;\r\n\r\n    /**\r\n     *  @dev function allowing to unfreeze tokens partially in batch\r\n     *  IMPORTANT : THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_userAddresses.length` IS TOO HIGH,\r\n     *  USE WITH CARE OR YOU COULD LOSE TX FEES WITH AN \"OUT OF GAS\" TRANSACTION\r\n     *  @param _userAddresses The addresses on which tokens need to be unfrozen\r\n     *  @param _amounts the amount of tokens to unfreeze on the corresponding address\r\n     *  This function can only be called by a wallet set as agent of the token\r\n     *  emits _userAddresses.length `TokensUnfrozen` events\r\n     */\r\n    function batchUnfreezePartialTokens(address[] calldata _userAddresses, uint256[] calldata _amounts) external;\r\n\r\n    /**\r\n     *  @dev transfers the ownership of the token smart contract\r\n     *  @param _newOwner the address of the new token smart contract owner\r\n     *  This function can only be called by the owner of the token\r\n     *  emits an `OwnershipTransferred` event\r\n     */\r\n    function transferOwnershipOnTokenContract(address _newOwner) external;\r\n\r\n    /**\r\n     *  @dev adds an agent to the token smart contract\r\n     *  @param _agent the address of the new agent of the token smart contract\r\n     *  This function can only be called by the owner of the token\r\n     *  emits an `AgentAdded` event\r\n     */\r\n    function addAgentOnTokenContract(address _agent) external;\r\n\r\n    /**\r\n     *  @dev remove an agent from the token smart contract\r\n     *  @param _agent the address of the agent to remove\r\n     *  This function can only be called by the owner of the token\r\n     *  emits an `AgentRemoved` event\r\n     */\r\n    function removeAgentOnTokenContract(address _agent) external;\r\n}\r\n\r\n// File: contracts/DVD/DVDTransferManager.sol\r\n\r\ncontract DVDTransferManager is Ownable {\r\n\r\n    /**\r\n     * @dev Emitted when a DVD transfer is initiated by `maker` to swap `token1Amount` tokens `token1` (TREX or not)\r\n     * for `token2Amount` tokens `token2` with `taker`\r\n     * this event is emitted by the `initiateDVDTransfer` function\r\n     */\r\n    event DVDTransferInitiated(bytes32 indexed transferID, address maker, address indexed token1, uint256 token1Amount, address taker, address indexed token2, uint256 token2Amount);\r\n\r\n    /**\r\n     * @dev Emitted when a DVD transfer is validated by `taker` and executed either by `taker` either by the agent of the TREX token\r\n     * if the TREX token is subject to conditional transfers\r\n     * this event is emitted by the `takeDVDTransfer` function\r\n     */\r\n    event DVDTransferExecuted(bytes32 indexed transferID);\r\n\r\n    /**\r\n     * @dev Emitted when a DVD transfer is cancelled\r\n     * this event is emitted by the `cancelDVDTransfer` function\r\n     */\r\n    event DVDTransferCancelled(bytes32 indexed transferID);\r\n\r\n    /**\r\n     * @dev Emitted when a DVD transfer is cancelled\r\n     * this event is emitted by the `cancelDVDTransfer` function\r\n     */\r\n    event FeeModified(bytes32 indexed parity, address token1, address token2, uint fee1, uint fee2, uint feeBase, address fee1Wallet, address fee2Wallet);\r\n\r\n    struct Delivery {\r\n        address counterpart;\r\n        address token;\r\n        uint256 amount;\r\n    }\r\n\r\n    struct Fee {\r\n        uint token1Fee;\r\n        uint token2Fee;\r\n        uint feeBase;\r\n        address fee1Wallet;\r\n        address fee2Wallet;\r\n    }\r\n\r\n    struct TxFees {\r\n        uint txFee1;\r\n        uint txFee2;\r\n        address fee1Wallet;\r\n        address fee2Wallet;\r\n    }\r\n\r\n    // fee details linked to a parity of tokens\r\n    mapping(bytes32 => Fee) public fee;\r\n\r\n    // tokens to deliver by DVD transfer maker\r\n    mapping(bytes32 => Delivery) public token1ToDeliver;\r\n\r\n    // tokens to deliver by DVD transfer taker\r\n    mapping(bytes32 => Delivery) public token2ToDeliver;\r\n\r\n    // nonce of the transaction allowing the creation of unique transferID\r\n    uint256 public txNonce;\r\n\r\n    // initiates the nonce at 0\r\n    constructor(){\r\n        txNonce = 0;\r\n    }\r\n\r\n\r\n    /**\r\n     *  @dev calculates the parity byte signature\r\n     *  @param _token1 the address of the base token\r\n     *  @param _token2 the address of the counterpart token\r\n     *  return the byte signature of the parity\r\n     */\r\n    function calculateParity (address _token1, address _token2) public pure returns (bytes32) {\r\n        bytes32 parity = keccak256(abi.encode(_token1, _token2));\r\n        return parity;\r\n    }\r\n\r\n    /**\r\n     *  @dev check if `_token` corresponds to a functional TREX token (with identity registry initiated)\r\n     *  @param _token the address token to check\r\n     *  the function will try to call `identityRegistry()` on the address, which is a getter specific to TREX tokens\r\n     *  if the call pass and returns an address it means that the token is a TREX, otherwise it's not a TREX\r\n     *  return `true` if the token is a TREX, `false` otherwise\r\n     */\r\n    function isTREX(address _token) public view returns (bool) {\r\n        try IToken(_token).identityRegistry() returns (IIdentityRegistry _ir) {\r\n            if (address(_ir) != address(0)) {\r\n                return true;\r\n            }\r\n        return false;\r\n        }\r\n        catch {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     *  @dev check if `_user` is a TREX agent of `_token`\r\n     *  @param _token the address token to check\r\n     *  @param _user the wallet address\r\n     *  if `_token` is a TREX token this function will check if `_user` is registered as an agent on it\r\n     *  return `true` if `_user` is agent of `_token`, return `false` otherwise\r\n     */\r\n    function isTREXAgent(address _token, address _user) public view returns (bool) {\r\n    if (isTREX(_token)){\r\n        return AgentRole(_token).isAgent(_user);\r\n    }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     *  @dev check if `_user` is a TREX owner of `_token`\r\n     *  @param _token the address token to check\r\n     *  @param _user the wallet address\r\n     *  if `_token` is a TREX token this function will check if `_user` is registered as an owner on it\r\n     *  return `true` if `_user` is owner of `_token`, return `false` otherwise\r\n     */\r\n    function isTREXOwner(address _token, address _user) public view returns (bool) {\r\n        if (isTREX(_token)){\r\n            return Ownable(_token).owner() == _user;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     *  @dev calculates the transferID depending on DVD transfer parameters\r\n     *  @param _nonce the nonce of the transfer on the smart contract\r\n     *  @param _maker the address of the DVD transfer maker (initiator of the transfer)\r\n     *  @param _token1 the address of the token that the maker is providing\r\n     *  @param _token1Amount the amount of tokens `_token1` provided by the maker\r\n     *  @param _taker the address of the DVD transfer taker (executor of the transfer)\r\n     *  @param _token2 the address of the token that the taker is providing\r\n     *  @param _token2Amount the amount of tokens `_token2` provided by the taker\r\n     *  return the identifier of the DVD transfer as a byte signature\r\n     */\r\n    function calculateTransferID (\r\n        uint256 _nonce,\r\n        address _maker,\r\n        address _token1,\r\n        uint256 _token1Amount,\r\n        address _taker,\r\n        address _token2,\r\n        uint256 _token2Amount\r\n    ) public pure returns (bytes32){\r\n        bytes32 transferID = keccak256(abi.encode(_nonce, _maker, _token1, _token1Amount, _taker, _token2, _token2Amount));\r\n        return transferID;\r\n    }\r\n\r\n    /**\r\n     *  @dev modify the fees applied to a parity of tokens (tokens can be TREX or ERC20)\r\n     *  @param _token1 the address of the base token for the parity `_token1`/`_token2`\r\n     *  @param _token2 the address of the counterpart token for the parity `_token1`/`_token2`\r\n     *  @param _fee1 the fee to apply on `_token1` leg of the DVD transfer per 10^`_feeBase`\r\n     *  @param _fee2 the fee to apply on `_token2` leg of the DVD transfer per 10^`_feeBase`\r\n     *  @param _feeBase the precision of the fee setting, e.g. if `_feeBase` == 2 then `_fee1` and `_fee2` are in % (fee/10^`_feeBase`)\r\n     *  @param _fee1Wallet the wallet address receiving fees applied on `_token1`\r\n     *  @param _fee2Wallet the wallet address receiving fees applied on `_token2`\r\n     *  `_token1` and `_token2` need to be ERC20 or TREX tokens addresses, otherwise the transaction will fail\r\n     *  `msg.sender` has to be owner of the DVD contract or the owner of the TREX token involved in the parity (if any)\r\n     *  requires fees to be lower than 100%\r\n     *  requires `_feeBase` to be higher or equal to 2 (precision 10^2)\r\n     *  requires `_feeBase` to be lower or equal to 5 (precision 10^5) to avoid overflows\r\n     *  requires `_fee1Wallet` & `_fee2Wallet` to be non empty addresses if `_fee1` & `_fee2` are respectively set\r\n     *  note that if fees are not set for a parity the default fee is basically 0%\r\n     *  emits a `FeeModified` event\r\n     */\r\n    function modifyFee(address _token1, address _token2, uint _fee1, uint _fee2, uint _feeBase, address _fee1Wallet, address _fee2Wallet) external {\r\n        require(msg.sender == owner() || isTREXOwner(_token1, msg.sender) || isTREXOwner(_token2, msg.sender), 'Ownable: only owner can call');\r\n        require(IERC20(_token1).totalSupply() != 0 && IERC20(_token2).totalSupply() != 0, 'invalid address : address is not an ERC20');\r\n        require(_fee1 <= 10**_feeBase && _fee1 >= 0 && _fee2 <= 10**_feeBase && _fee2 >= 0 && _feeBase <= 5 && _feeBase >= 2, 'invalid fee settings');\r\n        if (_fee1 > 0) {\r\n            require(_fee1Wallet != address(0), 'fee wallet 1 cannot be zero address');\r\n        }\r\n        if (_fee2 > 0) {\r\n            require(_fee2Wallet != address(0), 'fee wallet 2 cannot be zero address');\r\n        }\r\n        bytes32 _parity = calculateParity(_token1, _token2);\r\n        Fee memory parityFee;\r\n        parityFee.token1Fee = _fee1;\r\n        parityFee.token2Fee = _fee2;\r\n        parityFee.feeBase = _feeBase;\r\n        parityFee.fee1Wallet = _fee1Wallet;\r\n        parityFee.fee2Wallet = _fee2Wallet;\r\n        fee[_parity] = parityFee;\r\n        emit FeeModified(_parity, _token1, _token2, _fee1, _fee2, _feeBase, _fee1Wallet, _fee2Wallet);\r\n        bytes32 _reflectParity = calculateParity(_token2, _token1);\r\n        Fee memory reflectParityFee;\r\n        reflectParityFee.token1Fee = _fee2;\r\n        reflectParityFee.token2Fee = _fee1;\r\n        reflectParityFee.feeBase = _feeBase;\r\n        reflectParityFee.fee1Wallet = _fee2Wallet;\r\n        reflectParityFee.fee2Wallet = _fee1Wallet;\r\n        fee[_reflectParity] = reflectParityFee;\r\n        emit FeeModified(_reflectParity, _token2, _token1, _fee2, _fee1, _feeBase, _fee2Wallet, _fee1Wallet);\r\n    }\r\n\r\n    /**\r\n     *  @dev initiates a DVD transfer between `msg.sender` & `_counterpart`\r\n     *  @param _token1 the address of the token (ERC20 or TREX) provided by `msg.sender`\r\n     *  @param _token1Amount the amount of `_token1` that `msg.sender` will send to `_counterpart` at DVD execution time\r\n     *  @param _counterpart the address of the counterpart, which will receive `_token1Amount` of `_token1` in exchange for\r\n     *  `_token2Amount` of `_token2`\r\n     *  @param _token2 the address of the token (ERC20 or TREX) provided by `_counterpart`\r\n     *  @param _token2Amount the amount of `_token2` that `_counterpart` will send to `msg.sender` at DVD execution time\r\n     *  requires `msg.sender` to have enough `_token1` tokens to process the DVD transfer\r\n     *  requires `DVDTransferManager` contract to have the necessary allowance to process the DVD transfer on `msg.sender`\r\n     *  requires `_counterpart` to not be the 0 address\r\n     *  requires `_token1` & `_token2` to be valid token addresses\r\n     *  emits a `DVDTransferInitiated` event\r\n     */\r\n    function initiateDVDTransfer(address _token1, uint256 _token1Amount, address _counterpart, address _token2, uint256 _token2Amount) external {\r\n        require(IERC20(_token1).balanceOf(msg.sender) >= _token1Amount, 'Not enough tokens in balance');\r\n        require(IERC20(_token1).allowance(msg.sender, address(this)) >= _token1Amount, 'not enough allowance to initiate transfer');\r\n        require (_counterpart != address(0), 'counterpart cannot be null');\r\n        require(IERC20(_token2).totalSupply() != 0, 'invalid address : address is not an ERC20');\r\n        Delivery memory token1;\r\n        token1.counterpart = msg.sender;\r\n        token1.token = _token1;\r\n        token1.amount = _token1Amount;\r\n        Delivery memory token2;\r\n        token2.counterpart = _counterpart;\r\n        token2.token = _token2;\r\n        token2.amount = _token2Amount;\r\n        bytes32 transferID = calculateTransferID(txNonce, token1.counterpart, token1.token, token1.amount, token2.counterpart, token2.token, token2.amount);\r\n        token1ToDeliver[transferID] = token1;\r\n        token2ToDeliver[transferID] = token2;\r\n        emit DVDTransferInitiated(transferID,token1.counterpart, token1.token, token1.amount, token2.counterpart, token2.token, token2.amount);\r\n        txNonce++;\r\n    }\r\n\r\n    /**\r\n     *  @dev execute a DVD transfer that was previously initiated through the `initiateDVDTransfer` function\r\n     *  @param _transferID the DVD transfer identifier as calculated through the `calculateTransferID` function for the initiated DVD transfer to execute\r\n     *  requires `_transferID` to exist (DVD transfer has to be initiated)\r\n     *  requires that taker (counterpart sending token2) has enough tokens in balance to process the DVD transfer\r\n     *  requires that `DVDTransferManager` contract has enough allowance to process the `token2` leg of the DVD transfer\r\n     *  requires that `msg.sender` is the taker OR the TREX agent in case a TREX token is involved in the transfer (in case of conditional transfer\r\n     *  the agent can call the function when the transfer has been approved)\r\n     *  if fees apply on one side or both sides of the transfer the fees will be sent, at transaction time, to the fees wallet previously set\r\n     *  in case fees apply the counterparts will receive less than the amounts included in the DVD transfer as part of the transfer is redirected to the\r\n     *  fee wallet at transfer execution time\r\n     *  if one or both legs of the transfer are TREX, then all the relevant checks apply on the transaction (compliance + identity checks)\r\n     *  and the transaction WILL FAIL if the TREX conditions of transfer are not respected, please refer to {Token-transfer} and {Token-transferFrom} to\r\n     *  know more about TREX conditions for transfers\r\n     *  once the DVD transfer is executed the `_transferID` is removed from the pending `_transferID` pool\r\n     *  emits a `DVDTransferExecuted` event\r\n     */\r\n    function takeDVDTransfer(bytes32 _transferID) external {\r\n        Delivery memory token1 = token1ToDeliver[_transferID];\r\n        Delivery memory token2 = token2ToDeliver[_transferID];\r\n        require(token1.counterpart != address(0) && token2.counterpart != address(0), 'transfer ID does not exist');\r\n        IERC20 token1Contract = IERC20(token1.token);\r\n        IERC20 token2Contract = IERC20(token2.token);\r\n        require (msg.sender == token2.counterpart || isTREXAgent(token1.token, msg.sender) || isTREXAgent(token2.token, msg.sender), 'transfer has to be done by the counterpart or by owner');\r\n        require(token2Contract.balanceOf(token2.counterpart) >= token2.amount, 'Not enough tokens in balance');\r\n        require(token2Contract.allowance(token2.counterpart, address(this)) >= token2.amount, 'not enough allowance to transfer');\r\n        TxFees memory fees = calculateFee(_transferID);\r\n        if (fees.txFee1 != 0) {\r\n        token1Contract.transferFrom(token1.counterpart, token2.counterpart, (token1.amount - fees.txFee1));\r\n        token1Contract.transferFrom(token1.counterpart, fees.fee1Wallet, fees.txFee1);\r\n        }\r\n        if (fees.txFee1 == 0) {\r\n            token1Contract.transferFrom(token1.counterpart, token2.counterpart, token1.amount);\r\n        }\r\n        if (fees.txFee2 != 0) {\r\n            token2Contract.transferFrom(token2.counterpart, token1.counterpart, (token2.amount - fees.txFee2));\r\n            token2Contract.transferFrom(token2.counterpart, fees.fee2Wallet, fees.txFee2);\r\n        }\r\n        if (fees.txFee2 == 0) {\r\n            token2Contract.transferFrom(token2.counterpart, token1.counterpart, token2.amount);\r\n        }\r\n        delete token1ToDeliver[_transferID];\r\n        delete token2ToDeliver[_transferID];\r\n        emit DVDTransferExecuted(_transferID);\r\n    }\r\n\r\n    /**\r\n     *  @dev delete a pending DVD transfer that was previously initiated through the `initiateDVDTransfer` function from the pool\r\n     *  @param _transferID the DVD transfer identifier as calculated through the `calculateTransferID` function for the initiated DVD transfer to delete\r\n     *  requires `_transferID` to exist (DVD transfer has to be initiated)\r\n     *  requires that `msg.sender` is the taker or the maker or the `DVDTransferManager` contract owner or the TREX agent in case a TREX token is involved in the transfer\r\n     *  once the `cancelDVDTransfer` is executed the `_transferID` is removed from the pending `_transferID` pool\r\n     *  emits a `DVDTransferCancelled` event\r\n     */\r\n    function cancelDVDTransfer(bytes32 _transferID) external {\r\n        Delivery memory token1 = token1ToDeliver[_transferID];\r\n        Delivery memory token2 = token2ToDeliver[_transferID];\r\n        require(token1.counterpart != address(0) && token2.counterpart != address(0), 'transfer ID does not exist');\r\n        require (msg.sender == token2.counterpart || msg.sender == token1.counterpart || msg.sender == owner() || isTREXAgent(token1.token, msg.sender) || isTREXAgent(token2.token, msg.sender), 'you are not allowed to cancel this transfer');\r\n        delete token1ToDeliver[_transferID];\r\n        delete token2ToDeliver[_transferID];\r\n        emit DVDTransferCancelled(_transferID);\r\n    }\r\n\r\n    /**\r\n     *  @dev calculates the fees to apply to a specific transfer depending on the fees applied to the parity used in the transfer\r\n     *  @param _transferID the DVD transfer identifier as calculated through the `calculateTransferID` function for the transfer to calculate fees on\r\n     *  requires `_transferID` to exist (DVD transfer has to be initiated)\r\n     *  returns the fees to apply on each leg of the transfer in the form of a `TxFees` struct\r\n     */\r\n    function calculateFee(bytes32 _transferID) public view returns(TxFees memory) {\r\n        TxFees memory fees;\r\n        Delivery memory token1 = token1ToDeliver[_transferID];\r\n        Delivery memory token2 = token2ToDeliver[_transferID];\r\n        require(token1.counterpart != address(0) && token2.counterpart != address(0), 'transfer ID does not exist');\r\n        bytes32 parity = calculateParity(token1.token, token2.token);\r\n        Fee memory feeDetails = fee[parity];\r\n        if (feeDetails.token1Fee != 0 || feeDetails.token2Fee != 0 ){\r\n            uint _txFee1 = (token1.amount * feeDetails.token1Fee * 10**(feeDetails.feeBase - 2)) / (10**feeDetails.feeBase);\r\n            uint _txFee2 = (token2.amount * feeDetails.token2Fee * 10**(feeDetails.feeBase - 2)) / (10**feeDetails.feeBase);\r\n            fees.txFee1 = _txFee1;\r\n            fees.txFee2 = _txFee2;\r\n            fees.fee1Wallet = feeDetails.fee1Wallet;\r\n            fees.fee2Wallet = feeDetails.fee2Wallet;\r\n            return fees;\r\n        }\r\n        else {\r\n            fees.txFee1 = 0;\r\n            fees.txFee2 = 0;\r\n            fees.fee1Wallet = address(0);\r\n            fees.fee2Wallet = address(0);\r\n            return fees;\r\n        }\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transferID\",\"type\":\"bytes32\"}],\"name\":\"DVDTransferCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transferID\",\"type\":\"bytes32\"}],\"name\":\"DVDTransferExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transferID\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"token1Amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token2\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"token2Amount\",\"type\":\"uint256\"}],\"name\":\"DVDTransferInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"parity\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token2\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee2\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeBase\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fee1Wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fee2Wallet\",\"type\":\"address\"}],\"name\":\"FeeModified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_transferID\",\"type\":\"bytes32\"}],\"name\":\"calculateFee\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"txFee1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"txFee2\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"fee1Wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fee2Wallet\",\"type\":\"address\"}],\"internalType\":\"struct DVDTransferManager.TxFees\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token2\",\"type\":\"address\"}],\"name\":\"calculateParity\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_maker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_token1Amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_taker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token2\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_token2Amount\",\"type\":\"uint256\"}],\"name\":\"calculateTransferID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_transferID\",\"type\":\"bytes32\"}],\"name\":\"cancelDVDTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"token1Fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token2Fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeBase\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"fee1Wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fee2Wallet\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_token1Amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_counterpart\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token2\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_token2Amount\",\"type\":\"uint256\"}],\"name\":\"initiateDVDTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"isTREX\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"isTREXAgent\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"isTREXOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token2\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_fee1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fee2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feeBase\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_fee1Wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_fee2Wallet\",\"type\":\"address\"}],\"name\":\"modifyFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_transferID\",\"type\":\"bytes32\"}],\"name\":\"takeDVDTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"token1ToDeliver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"counterpart\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"token2ToDeliver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"counterpart\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"txNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"DVDTransferManager","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://3a51c3cff94b1f460aae23fa47191843f1b2770e57c7f71992999352bb30521a"}]}