{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n/**\r\n * This file is part of the 1st Solidity Gas Golfing Contest.\r\n *\r\n * Author: Zachary Williamson\r\n *\r\n * This work is licensed under Creative Commons Attribution ShareAlike 3.0.\r\n * https://creativecommons.org/licenses/by-sa/3.0/\r\n */\r\n\r\nlibrary UniqueAddresses {\r\n    function uniquify(uint[]) external view returns(address[]) {\r\n        assembly {\r\n            // first, let's check there's actually some data to operate on\r\n            0x24 calldataload 0x01 lt has_data jumpi\r\n            calldatacopy(0, 0x04, calldatasize)\r\n            return(0x00, sub(calldatasize, 0x04))\r\n        has_data:\r\n            0x44\r\n            dup1 calldataload\r\n            dup2 0x20 add calldataload\r\n        test_run:\r\n            lt input_is_ordered jumpi\r\n            jump(maybe_has_non_trivial_structure)\r\n        input_is_ordered:\r\n            0x20 add\r\n            dup1 calldataload\r\n            dup2 0x20 add calldataload\r\n            0x140 calldatasize sub dup4 lt test_run jumpi\r\n        calldatacopy(0, 0x04, calldatasize)\r\n        return(0x00, sub(calldatasize, 0x04))\r\n\r\n        maybe_has_non_trivial_structure:\r\n            pop\r\n            0x44\r\n            dup1 calldataload\r\n            dup2 0x20 add calldataload\r\n        test_reverse_run:\r\n            gt input_is_reverse_ordered jumpi\r\n            jump(probably_has_non_trivial_structure)\r\n        input_is_reverse_ordered:\r\n            0x20 add\r\n            dup1 calldataload\r\n            dup2 0x20 add calldataload\r\n            0x140 calldatasize sub dup4 lt test_reverse_run jumpi\r\n        calldatacopy(0, 0x04, calldatasize)\r\n        return(0x00, sub(calldatasize, 0x04))\r\n\r\n        probably_has_non_trivial_structure:\r\n        pop\r\n        0x64 0x44 calldataload         // prev index\r\n        test_identical_loop:\r\n            dup2 calldataload              // current prev index\r\n            dup1 swap2                     // prev current current index\r\n            eq iszero somewhat_likely_has_non_trivial_structure jumpi         // prev index        \r\n            swap1 0x20 add swap1           // prev i'\r\n            dup2 0x140 gt test_identical_loop jumpi\r\n            0x20 0x00 mstore\r\n            0x01 0x20 mstore\r\n            0x44 calldataload 0x40 mstore\r\n        return(0x00, 0x60) // hey, everything is the same!\r\n\r\n        somewhat_likely_has_non_trivial_structure:\r\n        pop pop\r\n        0x44 0x44 calldataload\r\n        test_pairs_outer_loop:\r\n            swap1 0x20 add swap1            // prev i'\r\n            dup2 calldataload               // current prev index\r\n            dup1 swap2                      // prev current current index\r\n            eq test_pairs_outer_loop jumpi  // current index\r\n            // ok, now we have two unique elements  // a index\r\n            0x44 calldataload                   // b a index\r\n            test_pairs_inner_loop:\r\n                swap2 0x20 add swap2            // b a index\r\n                dup2                        // a b a index\r\n                dup4 calldataload           // x a b a index\r\n                dup3 dup2                   // x b x a b a index\r\n                eq                          // (x=b?) x a b a\r\n                swap2 eq or                 // (x=a|b) b a index\r\n                iszero definitely_has_non_trivial_structure jumpi   // b a index\r\n                dup3 0x140 calldatasize sub gt test_pairs_inner_loop jumpi\r\n                // hey! There are only two elements!\r\n                0x20 0x00 mstore\r\n                0x02 0x20 mstore\r\n                0x40 mstore\r\n                0x60 mstore\r\n                0x80 0x00 return\r\n\r\n\r\n        definitely_has_non_trivial_structure:\r\n            pop pop pop\r\n            // Ok, at this point we have some interesting data to work on and this is where the algorithm really begins.\r\n            // Push the calldata pointer onto the stack. First array element will be at index 0x44\r\n            0x44\r\n            // Create the hash table: converts a 8-bit key into a 256-bit\r\n            // value. Only one bit is set high and there are 256 unique\r\n            // permutations in the lookup table\r\n            1 0x0 mstore\r\n            2 0x20 mstore\r\n            4 0x40 mstore\r\n            8 0x60 mstore\r\n            16 0x80 mstore\r\n            32 0xa0 mstore\r\n            64 0xc0 mstore\r\n            128 0xe0 mstore\r\n\r\n            // We want to use 'msize' as our pointer to the next element in our\r\n            // output array. It's self-incrementing, so we don't need to call\r\n            // '0x20 add' every iteration. It also costs 2 gas, as opposed to\r\n            // duplicating a stack-based pointer which costs 3 gas.\r\n            // Reducing the stack depth also removes the need for 1 swap op (3 gas),\r\n            // as we would otherwise need to increment both the output array pointer\r\n            // and the calldata pointer, which requires a swap\r\n            // Total gas saving: 10 gas per iteration\r\n\r\n            // in order to do this, we store data in a word that is one word after the\r\n            // reserved bloom filter memory.\r\n            // We use the memory from 0x100 to 0x900 to store our bloom filter,\r\n            // which is 64 machine words. Having a value that is a power of 2 allows for\r\n            // very cheap indexing in our main loop, which is worth the extra gas costs of a larger filter\r\n            0x01 0x500 mstore\r\n    // ### MAIN LOOP\r\n    // We know there's at least one array element, so fall into the loop\r\n        loop_start:\r\n            dup1 calldataload           // stack state: v\r\n            0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47 mul // stack state: h s\r\n            dup1 0x3e0 and 0x100 add    // stack state: i h s\r\n            swap1 28 byte mload         // stack state: b i s\r\n            dup2 mload dup2 and skip_add_to_set jumpi\r\n                dup3 calldataload msize mstore\r\n                dup2 mload or           // stack state: r i s\r\n                swap1 mstore            // stack state: s\r\n                0x20 add                // stack state: s'\r\n\r\n        // 2nd iteration\r\n            dup1 calldataload           // stack state: v\r\n            0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47 mul // stack state: h s\r\n            dup1 0x3e0 and 0x100 add    // stack state: i h s\r\n            swap1 28 byte mload         // stack state: b i s\r\n            dup2 mload dup2 and skip_add_to_set jumpi\r\n                dup3 calldataload msize mstore\r\n                dup2 mload or           // stack state: r i s\r\n                swap1 mstore            // stack state: s\r\n                0x20 add                // stack state: s'\r\n\r\n            calldatasize dup2 lt loop_start jumpi\r\n\r\n            0x20 0x4e0 mstore          // stack state: s\r\n            0x520 msize sub            // stack state: l s\r\n            0x20 dup2 div 0x500 mstore // stack state: l s\r\n            0x40 add 0x4e0 return\r\n\r\n            skip_add_to_set:\r\n                pop pop\r\n                0x20 add\r\n                calldatasize dup2 lt loop_start jumpi\r\n            0x20 0x4e0 mstore          // stack state:\r\n            0x520 msize sub            // stack state: l\r\n            0x20 dup2 div 0x500 mstore // stack state: l\r\n            0x40 add 0x4e0 return\r\n\r\n            // the variable number of 'pop' instructions in the main loop upsets the compiler, poor thing\r\n            // pop a stack variable to prevent it from throwing errors\r\n            pop\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"name\":\"uniquify\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"UniqueAddresses","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://08691cd9aa2874889d6019d66e1eae8f51747e721290e6c647016df8ab906fbd"}]}