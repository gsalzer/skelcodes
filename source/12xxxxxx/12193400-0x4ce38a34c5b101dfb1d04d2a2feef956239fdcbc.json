{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"sources\": {\r\n    \"Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.5;\\n\\n// a library for performing various math operations\\n\\nlibrary Math {\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = x < y ? x : y;\\n    }\\n\\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = x > y ? x : y;\\n    }\\n\\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\\n        if (y > 3) {\\n            z = y;\\n            uint256 x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.5;\\n\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\n\\nlibrary SafeMath {\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x + y) >= x, 'SM_ADD_OVERFLOW');\\n    }\\n\\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = sub(x, y, 'SM_SUB_UNDERFLOW');\\n    }\\n\\n    function sub(\\n        uint256 x,\\n        uint256 y,\\n        string memory message\\n    ) internal pure returns (uint256 z) {\\n        require((z = x - y) <= x, message);\\n    }\\n\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require(y == 0 || (z = x * y) / y == x, 'SM_MUL_OVERFLOW');\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, 'SM_DIV_BY_ZERO');\\n        uint256 c = a / b;\\n        return c;\\n    }\\n}\\n\"\r\n    },\r\n    \"FixedSafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.5;\\n\\nimport 'Math.sol';\\nimport 'SafeMath.sol';\\n\\nlibrary FixedSafeMath {\\n    int256 private constant _INT256_MIN = -2**255;\\n    int256 internal constant ONE = 10**18;\\n\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a + b;\\n        require((b >= 0 && c >= a) || (b < 0 && c < a), 'FM_ADDITION_OVERFLOW');\\n\\n        return c;\\n    }\\n\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a - b;\\n        require((b >= 0 && c <= a) || (b < 0 && c > a), 'FM_SUBTRACTION_OVERFLOW');\\n\\n        return c;\\n    }\\n\\n    function f18Mul(int256 a, int256 b) internal pure returns (int256) {\\n        return _div(_mul(a, b), ONE);\\n    }\\n\\n    function f18Div(int256 a, int256 b) internal pure returns (int256) {\\n        return _div(_mul(a, ONE), b);\\n    }\\n\\n    function f18Sqrt(int256 value) internal pure returns (int256) {\\n        require(value >= 0, 'FM_SQUARE_ROOT_OF_NEGATIVE');\\n        return int256(Math.sqrt(SafeMath.mul(uint256(value), uint256(ONE))));\\n    }\\n\\n    function _mul(int256 a, int256 b) private pure returns (int256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        require(!(a == -1 && b == _INT256_MIN), 'FM_MULTIPLICATION_OVERFLOW');\\n\\n        int256 c = a * b;\\n        require(c / a == b, 'FM_MULTIPLICATION_OVERFLOW');\\n\\n        return c;\\n    }\\n\\n    function _div(int256 a, int256 b) private pure returns (int256) {\\n        require(b != 0, 'FM_DIVISION_BY_ZERO');\\n        require(!(b == -1 && a == _INT256_MIN), 'FM_DIVISION_OVERFLOW');\\n\\n        int256 c = a / b;\\n\\n        return c;\\n    }\\n}\\n\"\r\n    },\r\n    \"Normalizer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.5;\\n\\nimport 'SafeMath.sol';\\n\\nlibrary Normalizer {\\n    using SafeMath for uint256;\\n\\n    function normalize(uint256 amount, uint8 decimals) internal pure returns (uint256) {\\n        if (decimals == 18) {\\n            return amount;\\n        } else if (decimals > 18) {\\n            return amount.div(10**(decimals - 18));\\n        } else {\\n            return amount.mul(10**(18 - decimals));\\n        }\\n    }\\n\\n    function denormalize(uint256 amount, uint8 decimals) internal pure returns (uint256) {\\n        if (decimals == 18) {\\n            return amount;\\n        } else if (decimals > 18) {\\n            return amount.mul(10**(decimals - 18));\\n        } else {\\n            return amount.div(10**(18 - decimals));\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"IIntegralOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.5;\\n\\ninterface IIntegralOracle {\\n    event OwnerSet(address owner);\\n    event UniswapPairSet(address uniswapPair);\\n    event PriceUpdateIntervalSet(uint32 interval);\\n    event ParametersSet(uint32 epoch, int256[] bidExponents, int256[] bidQs, int256[] askExponents, int256[] askQs);\\n\\n    function owner() external view returns (address);\\n\\n    function setOwner(address) external;\\n\\n    function epoch() external view returns (uint32);\\n\\n    function xDecimals() external view returns (uint8);\\n\\n    function yDecimals() external view returns (uint8);\\n\\n    function getParameters()\\n        external\\n        view\\n        returns (\\n            int256[] memory bidExponents,\\n            int256[] memory bidQs,\\n            int256[] memory askExponents,\\n            int256[] memory askQs\\n        );\\n\\n    function setParameters(\\n        int256[] calldata bidExponents,\\n        int256[] calldata bidQs,\\n        int256[] calldata askExponents,\\n        int256[] calldata askQs\\n    ) external;\\n\\n    function price() external view returns (int256);\\n\\n    function priceUpdateInterval() external view returns (uint32);\\n\\n    function updatePrice() external returns (uint32 _epoch);\\n\\n    function setPriceUpdateInterval(uint32 interval) external;\\n\\n    function price0CumulativeLast() external view returns (uint256);\\n\\n    function blockTimestampLast() external view returns (uint32);\\n\\n    function tradeX(\\n        uint256 xAfter,\\n        uint256 xBefore,\\n        uint256 yBefore\\n    ) external view returns (uint256 yAfter);\\n\\n    function tradeY(\\n        uint256 yAfter,\\n        uint256 xBefore,\\n        uint256 yBefore\\n    ) external view returns (uint256 xAfter);\\n\\n    function getSpotPrice(uint256 xCurrent, uint256 xBefore) external view returns (uint256 spotPrice);\\n}\\n\"\r\n    },\r\n    \"IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    },\r\n    \"FixedPoint.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.0;\\n\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\nlibrary FixedPoint {\\n    // range: [0, 2**112 - 1]\\n    // resolution: 1 / 2**112\\n    struct uq112x112 {\\n        uint224 _x;\\n    }\\n\\n    // range: [0, 2**144 - 1]\\n    // resolution: 1 / 2**112\\n    struct uq144x112 {\\n        uint _x;\\n    }\\n\\n    uint8 private constant RESOLUTION = 112;\\n\\n    // encode a uint112 as a UQ112x112\\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\\n        return uq112x112(uint224(x) << RESOLUTION);\\n    }\\n\\n    // encodes a uint144 as a UQ144x112\\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\\n        return uq144x112(uint256(x) << RESOLUTION);\\n    }\\n\\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\\n    function div(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {\\n        require(x != 0, 'FixedPoint: DIV_BY_ZERO');\\n        return uq112x112(self._x / uint224(x));\\n    }\\n\\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\\n    // reverts on overflow\\n    function mul(uq112x112 memory self, uint y) internal pure returns (uq144x112 memory) {\\n        uint z;\\n        require(y == 0 || (z = uint(self._x) * y) / y == uint(self._x), \\\"FixedPoint: MULTIPLICATION_OVERFLOW\\\");\\n        return uq144x112(z);\\n    }\\n\\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\\n    // equivalent to encode(numerator).div(denominator)\\n    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\\n        require(denominator > 0, \\\"FixedPoint: DIV_BY_ZERO\\\");\\n        return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\\n    }\\n\\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\\n        return uint112(self._x >> RESOLUTION);\\n    }\\n\\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\\n        return uint144(self._x >> RESOLUTION);\\n    }\\n}\\n\"\r\n    },\r\n    \"UniswapV2OracleLibrary.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\nimport 'IUniswapV2Pair.sol';\\nimport 'FixedPoint.sol';\\n\\n// library with helper methods for oracles that are concerned with computing average prices\\nlibrary UniswapV2OracleLibrary {\\n    using FixedPoint for *;\\n\\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\\n    function currentBlockTimestamp() internal view returns (uint32) {\\n        return uint32(block.timestamp % 2 ** 32);\\n    }\\n\\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\\n    function currentCumulativePrices(\\n        address pair\\n    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\\n        blockTimestamp = currentBlockTimestamp();\\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\\n\\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\\n        if (blockTimestampLast != blockTimestamp) {\\n            // subtraction overflow is desired\\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\\n            // addition overflow is desired\\n            // counterfactual\\n            price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\\n            // counterfactual\\n            price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"IntegralOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.5;\\n\\nimport 'FixedSafeMath.sol';\\nimport 'SafeMath.sol';\\nimport 'Normalizer.sol';\\nimport 'IIntegralOracle.sol';\\nimport 'UniswapV2OracleLibrary.sol';\\n\\ncontract IntegralOracle is IIntegralOracle {\\n    using FixedSafeMath for int256;\\n    using SafeMath for uint256;\\n    using Normalizer for uint256;\\n\\n    address public override owner;\\n    address public uniswapPair;\\n\\n    int256 public override price;\\n    uint32 public override epoch;\\n\\n    int256 private constant _POINT_FIVE = 5 * 10**17;\\n    int256 private constant _TWO = 2 * 10**18;\\n    int256 private constant _FOUR = 4 * 10**18;\\n\\n    uint8 public override xDecimals;\\n    uint8 public override yDecimals;\\n\\n    int256[] private bidExponents;\\n    int256[] private bidQs;\\n    int256[] private askExponents;\\n    int256[] private askQs;\\n\\n    uint32 public override priceUpdateInterval = 5 minutes;\\n    uint256 public override price0CumulativeLast;\\n    uint32 public override blockTimestampLast;\\n\\n    constructor(uint8 _xDecimals, uint8 _yDecimals) {\\n        require(_xDecimals <= 100 && _yDecimals <= 100, 'IO_DECIMALS_HIGHER_THAN_100');\\n        owner = msg.sender;\\n        xDecimals = _xDecimals;\\n        yDecimals = _yDecimals;\\n    }\\n\\n    function isContract(address addr) private view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(addr)\\n        }\\n        return size > 0;\\n    }\\n\\n    function setOwner(address _owner) external override {\\n        require(msg.sender == owner, 'IO_FORBIDDEN');\\n        owner = _owner;\\n        emit OwnerSet(owner);\\n    }\\n\\n    function setUniswapPair(address _uniswapPair) external {\\n        require(msg.sender == owner, 'IO_FORBIDDEN');\\n        require(_uniswapPair != address(0), 'IO_ADDRESS_ZERO');\\n        require(isContract(_uniswapPair), 'IO_UNISWAP_PAIR_MUST_BE_CONTRACT');\\n        uniswapPair = _uniswapPair;\\n        emit UniswapPairSet(uniswapPair);\\n\\n        price0CumulativeLast = IUniswapV2Pair(uniswapPair).price0CumulativeLast();\\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestamp) = IUniswapV2Pair(uniswapPair).getReserves();\\n        require(reserve0 != 0 && reserve1 != 0, 'IO_NO_UNISWAP_RESERVES');\\n        blockTimestampLast = blockTimestamp;\\n        emit UniswapPairSet(uniswapPair);\\n    }\\n\\n    function setPriceUpdateInterval(uint32 interval) public override {\\n        require(msg.sender == owner, 'IO_FORBIDDEN');\\n        require(interval > 0, 'IO_INTERVAL_CANNOT_BE_ZERO');\\n        priceUpdateInterval = interval;\\n        emit PriceUpdateIntervalSet(interval);\\n    }\\n\\n    function updatePrice() public override returns (uint32 _epoch) {\\n        if (uniswapPair == address(0)) {\\n            return epoch;\\n        }\\n\\n        (uint256 price0Cumulative, , uint32 blockTimestamp) = UniswapV2OracleLibrary.currentCumulativePrices(\\n            uniswapPair\\n        );\\n\\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\\n        if (timeElapsed >= priceUpdateInterval) {\\n            FixedPoint.uq112x112 memory price0Average = FixedPoint.uq112x112(\\n                uint224((price0Cumulative - price0CumulativeLast) / timeElapsed)\\n            );\\n            uint256 multiplyBy = xDecimals > yDecimals ? 10**(xDecimals - yDecimals) : 1;\\n            uint256 divideBy = yDecimals > xDecimals ? 10**(yDecimals - xDecimals) : 1;\\n            price = int256(uint256(price0Average._x).mul(10**18).mul(multiplyBy).div(divideBy).div(2**112));\\n            price0CumulativeLast = price0Cumulative;\\n            blockTimestampLast = blockTimestamp;\\n\\n            epoch += 1; // overflow is desired\\n        }\\n\\n        return epoch;\\n    }\\n\\n    function normalizeAmount(uint8 decimals, uint256 amount) internal pure returns (int256 result) {\\n        result = int256(amount.normalize(decimals));\\n        require(result >= 0, 'IO_INPUT_OVERFLOW');\\n    }\\n\\n    function getParameters()\\n        external\\n        view\\n        override\\n        returns (\\n            int256[] memory _bidExponents,\\n            int256[] memory _bidQs,\\n            int256[] memory _askExponents,\\n            int256[] memory _askQs\\n        )\\n    {\\n        _bidExponents = bidExponents;\\n        _bidQs = bidQs;\\n        _askExponents = askExponents;\\n        _askQs = askQs;\\n    }\\n\\n    function setParameters(\\n        int256[] calldata _bidExponents,\\n        int256[] calldata _bidQs,\\n        int256[] calldata _askExponents,\\n        int256[] calldata _askQs\\n    ) public override {\\n        require(msg.sender == owner, 'IO_FORBIDDEN');\\n        require(_bidExponents.length == _bidQs.length, 'IO_LENGTH_MISMATCH');\\n        require(_askExponents.length == _askQs.length, 'IO_LENGTH_MISMATCH');\\n\\n        bidExponents = _bidExponents;\\n        bidQs = _bidQs;\\n        askExponents = _askExponents;\\n        askQs = _askQs;\\n\\n        epoch += 1; // overflow is desired\\n        emit ParametersSet(epoch, bidExponents, bidQs, askExponents, askQs);\\n    }\\n\\n    // TRADE\\n\\n    function tradeX(\\n        uint256 xAfter,\\n        uint256 xBefore,\\n        uint256 yBefore\\n    ) public view override returns (uint256 yAfter) {\\n        int256 xAfterInt = normalizeAmount(xDecimals, xAfter);\\n        int256 xBeforeInt = normalizeAmount(xDecimals, xBefore);\\n        int256 yBeforeInt = normalizeAmount(yDecimals, yBefore);\\n        // We define the balances in terms of change from the the beginning of the epoch\\n        int256 yAfterInt = yBeforeInt.sub(integral(xAfterInt.sub(xBeforeInt)));\\n        require(yAfterInt >= 0, 'IO_NEGATIVE_Y_BALANCE');\\n        return uint256(yAfterInt).denormalize(yDecimals);\\n    }\\n\\n    function tradeY(\\n        uint256 yAfter,\\n        uint256 xBefore,\\n        uint256 yBefore\\n    ) public view override returns (uint256 xAfter) {\\n        int256 yAfterInt = normalizeAmount(yDecimals, yAfter);\\n        int256 xBeforeInt = normalizeAmount(xDecimals, xBefore);\\n        int256 yBeforeInt = normalizeAmount(yDecimals, yBefore);\\n        // We define the balances in terms of change from the the beginning of the epoch\\n        int256 xAfterInt = xBeforeInt.add(integralInverted(yBeforeInt.sub(yAfterInt)));\\n        require(xAfterInt >= 0, 'IO_NEGATIVE_X_BALANCE');\\n        return uint256(xAfterInt).denormalize(xDecimals);\\n    }\\n\\n    // INTEGRALS\\n\\n    function integral(int256 q) private view returns (int256) {\\n        // we are integrating over a curve that represents the order book\\n        if (q > 0) {\\n            // integrate over bid orders, our trade can be a bid or an ask\\n            return integralBid(q);\\n        } else if (q < 0) {\\n            // integrate over ask orders, our trade can be a bid or an ask\\n            return integralAsk(q);\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    function integralBid(int256 q) private view returns (int256) {\\n        int256 C = 0;\\n        for (uint256 i = 1; i < bidExponents.length; i++) {\\n            // find the corresponding range of prices for the piecewise function  (pPrevious, pCurrent)\\n            // price * e^(i-1) = price * constant, so we can create a lookup table\\n            int256 pPrevious = price.f18Mul(bidExponents[i - 1]);\\n            int256 pCurrent = price.f18Mul(bidExponents[i]);\\n\\n            // pull the corresponding accumulated quantity up to pPrevious and pCurrent\\n            int256 qPrevious = bidQs[i - 1];\\n            int256 qCurrent = bidQs[i];\\n\\n            // the quantity q falls between the range (pPrevious, pCurrent)\\n            if (q <= qCurrent) {\\n                // We've fitted a linear function y = ax + b between the points (pPrevious, qPrevious) and (pCurrent, qCurrent)\\n                // We use this equation to find the price, p, that corresponds to q\\n                int256 z = q.sub(qCurrent);\\n                int256 x = (pCurrent.sub(pPrevious)).f18Mul(z).f18Div(qCurrent.sub(qPrevious));\\n\\n                int256 p = x.add(pCurrent);\\n                // evaluate integral from pPrevious to p\\n                int256 A = _POINT_FIVE.f18Mul(pPrevious.add(p)).f18Mul(q.sub(qPrevious));\\n                return C.add(A);\\n            } else {\\n                // the quantity q exceeds the current range (pPrevious, pCurrent)\\n                // evaluate integral of entire segment\\n                int256 A = _POINT_FIVE.f18Mul(pPrevious.add(pCurrent)).f18Mul(qCurrent.sub(qPrevious));\\n                C = C.add(A);\\n            }\\n        }\\n        // this means we've run out of quantity in our curve's orderbook to satisfy the order quantity\\n        // this is highly unlikely, but it is possible if the user specifies an extremely large order or\\n        // the orderbook has gone too far in a single direction\\n        // but if things are operating correctly, this should almost never happen\\n        revert('IO_OVERFLOW');\\n    }\\n\\n    function integralAsk(int256 q) private view returns (int256) {\\n        int256 C = 0;\\n        for (uint256 i = 1; i < askExponents.length; i++) {\\n            int256 pPrevious = price.f18Mul(askExponents[i - 1]);\\n            int256 pCurrent = price.f18Mul(askExponents[i]);\\n\\n            int256 qPrevious = askQs[i - 1];\\n            int256 qCurrent = askQs[i];\\n\\n            if (q >= qCurrent) {\\n                int256 p = (pCurrent.sub(pPrevious)).f18Mul(q.sub(qCurrent)).f18Div(qCurrent.sub(qPrevious)).add(\\n                    pCurrent\\n                );\\n                int256 A = _POINT_FIVE.f18Mul(pPrevious.add(p)).f18Mul(q.sub(qPrevious));\\n                return C.add(A);\\n            } else {\\n                int256 A = _POINT_FIVE.f18Mul(pPrevious.add(pCurrent)).f18Mul(qCurrent.sub(qPrevious));\\n                C = C.add(A);\\n            }\\n        }\\n        revert('IO_OVERFLOW');\\n    }\\n\\n    function integralInverted(int256 s) private view returns (int256) {\\n        if (s > 0) {\\n            return integralBidInverted(s);\\n        } else if (s < 0) {\\n            return integralAskInverted(s);\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    function integralBidInverted(int256 s) private view returns (int256) {\\n        int256 C = 0;\\n        for (uint256 i = 1; i < bidExponents.length; i++) {\\n            int256 pPrevious = price.f18Mul(bidExponents[i - 1]);\\n            int256 pCurrent = price.f18Mul(bidExponents[i]);\\n            int256 qPrevious = bidQs[i - 1];\\n            int256 qCurrent = bidQs[i];\\n            int256 A = _POINT_FIVE.f18Mul(pPrevious.add(pCurrent)).f18Mul(qCurrent.sub(qPrevious));\\n            if (s <= C.add(A)) {\\n                int256 c = C.sub(s);\\n                int256 b = pPrevious;\\n                int256 a = pCurrent.sub(b);\\n                int256 d = qCurrent.sub(qPrevious);\\n                int256 insideSqrt = b.f18Mul(b).sub(_TWO.f18Mul(a).f18Mul(c).f18Div(d));\\n                int256 sqrt = insideSqrt.f18Sqrt();\\n                int256 h = (sqrt.sub(b)).f18Mul(d).f18Div(a);\\n                return qPrevious.add(h);\\n            } else {\\n                C = C.add(A);\\n            }\\n        }\\n        revert('IO_OVERFLOW');\\n    }\\n\\n    function integralAskInverted(int256 s) private view returns (int256) {\\n        int256 C = 0;\\n        for (uint256 i = 1; i < askExponents.length; i++) {\\n            int256 pPrevious = price.f18Mul(askExponents[i - 1]);\\n            int256 pCurrent = price.f18Mul(askExponents[i]);\\n            int256 qPrevious = askQs[i - 1];\\n            int256 qCurrent = askQs[i];\\n            int256 A = _POINT_FIVE.f18Mul(pPrevious.add(pCurrent)).f18Mul(qCurrent.sub(qPrevious));\\n            if (s >= C.add(A)) {\\n                int256 a = pCurrent.sub(pPrevious);\\n                int256 d = qCurrent.sub(qPrevious);\\n                int256 b = pPrevious;\\n                int256 c = C.sub(s);\\n                int256 inside = b.f18Mul(b).sub(c.f18Mul(_TWO).f18Mul(a).f18Div(d));\\n                int256 h = inside.f18Sqrt().sub(b).f18Mul(d).f18Div(a);\\n                return qPrevious.add(h);\\n            } else {\\n                C = C.add(A);\\n            }\\n        }\\n        revert('IO_OVERFLOW');\\n    }\\n\\n    // SPOT PRICE\\n\\n    function getSpotPrice(uint256 xCurrent, uint256 xBefore) public view override returns (uint256 spotPrice) {\\n        int256 xCurrentInt = normalizeAmount(xDecimals, xCurrent);\\n        int256 xBeforeInt = normalizeAmount(xDecimals, xBefore);\\n        int256 spotPriceInt = derivative(xCurrentInt.sub(xBeforeInt));\\n        require(spotPriceInt >= 0, 'IO_NEGATIVE_SPOT_PRICE');\\n        return uint256(spotPriceInt);\\n    }\\n\\n    // DERIVATIVES\\n\\n    function derivative(int256 t) public view returns (int256) {\\n        if (t > 0) {\\n            return derivativeBid(t);\\n        } else if (t < 0) {\\n            return derivativeAsk(t);\\n        } else {\\n            return price;\\n        }\\n    }\\n\\n    function derivativeBid(int256 t) public view returns (int256) {\\n        for (uint256 i = 1; i < bidExponents.length; i++) {\\n            int256 pPrevious = price.f18Mul(bidExponents[i - 1]);\\n            int256 pCurrent = price.f18Mul(bidExponents[i]);\\n            int256 qPrevious = bidQs[i - 1];\\n            int256 qCurrent = bidQs[i];\\n            if (t <= qCurrent) {\\n                return (pCurrent.sub(pPrevious)).f18Mul(t.sub(qCurrent)).f18Div(qCurrent.sub(qPrevious)).add(pCurrent);\\n            }\\n        }\\n        revert('IO_OVERFLOW');\\n    }\\n\\n    function derivativeAsk(int256 t) public view returns (int256) {\\n        for (uint256 i = 1; i < askExponents.length; i++) {\\n            int256 pPrevious = price.f18Mul(askExponents[i - 1]);\\n            int256 pCurrent = price.f18Mul(askExponents[i]);\\n            int256 qPrevious = askQs[i - 1];\\n            int256 qCurrent = askQs[i];\\n            if (t >= qCurrent) {\\n                return (pCurrent.sub(pPrevious)).f18Mul(t.sub(qCurrent)).f18Div(qCurrent.sub(qPrevious)).add(pCurrent);\\n            }\\n        }\\n        revert('IO_OVERFLOW');\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"libraries\": {\r\n      \"Math.sol\": {},\r\n      \"SafeMath.sol\": {},\r\n      \"FixedSafeMath.sol\": {},\r\n      \"Normalizer.sol\": {},\r\n      \"IIntegralOracle.sol\": {},\r\n      \"IUniswapV2Pair.sol\": {},\r\n      \"FixedPoint.sol\": {},\r\n      \"UniswapV2OracleLibrary.sol\": {},\r\n      \"IntegralOracle.sol\": {}\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"language\": \"Solidity\"\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_xDecimals\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_yDecimals\",\"type\":\"uint8\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"epoch\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"int256[]\",\"name\":\"bidExponents\",\"type\":\"int256[]\"},{\"indexed\":false,\"internalType\":\"int256[]\",\"name\":\"bidQs\",\"type\":\"int256[]\"},{\"indexed\":false,\"internalType\":\"int256[]\",\"name\":\"askExponents\",\"type\":\"int256[]\"},{\"indexed\":false,\"internalType\":\"int256[]\",\"name\":\"askQs\",\"type\":\"int256[]\"}],\"name\":\"ParametersSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"interval\",\"type\":\"uint32\"}],\"name\":\"PriceUpdateIntervalSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"uniswapPair\",\"type\":\"address\"}],\"name\":\"UniswapPairSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"blockTimestampLast\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"t\",\"type\":\"int256\"}],\"name\":\"derivative\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"t\",\"type\":\"int256\"}],\"name\":\"derivativeAsk\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"t\",\"type\":\"int256\"}],\"name\":\"derivativeBid\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epoch\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getParameters\",\"outputs\":[{\"internalType\":\"int256[]\",\"name\":\"_bidExponents\",\"type\":\"int256[]\"},{\"internalType\":\"int256[]\",\"name\":\"_bidQs\",\"type\":\"int256[]\"},{\"internalType\":\"int256[]\",\"name\":\"_askExponents\",\"type\":\"int256[]\"},{\"internalType\":\"int256[]\",\"name\":\"_askQs\",\"type\":\"int256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"xCurrent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"xBefore\",\"type\":\"uint256\"}],\"name\":\"getSpotPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"spotPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price0CumulativeLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceUpdateInterval\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256[]\",\"name\":\"_bidExponents\",\"type\":\"int256[]\"},{\"internalType\":\"int256[]\",\"name\":\"_bidQs\",\"type\":\"int256[]\"},{\"internalType\":\"int256[]\",\"name\":\"_askExponents\",\"type\":\"int256[]\"},{\"internalType\":\"int256[]\",\"name\":\"_askQs\",\"type\":\"int256[]\"}],\"name\":\"setParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"interval\",\"type\":\"uint32\"}],\"name\":\"setPriceUpdateInterval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_uniswapPair\",\"type\":\"address\"}],\"name\":\"setUniswapPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"xAfter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"xBefore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"yBefore\",\"type\":\"uint256\"}],\"name\":\"tradeX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"yAfter\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"yAfter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"xBefore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"yBefore\",\"type\":\"uint256\"}],\"name\":\"tradeY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"xAfter\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updatePrice\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"_epoch\",\"type\":\"uint32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"xDecimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yDecimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"IntegralOracle","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000012","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":""}]}