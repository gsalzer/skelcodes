{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"./contracts/liquidators/LiquidationTriggerChainlinkMainAsset.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: bsl-1.1\\n\\n/*\\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\\n*/\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../helpers/ERC20Like.sol\\\";\\nimport \\\"../helpers/ReentrancyGuard.sol\\\";\\nimport \\\"./LiquidationTriggerBase.sol\\\";\\nimport \\\"../oracles/OracleSimple.sol\\\";\\n\\n\\n/**\\n * @title LiquidationTriggerChainlinkMainAsset\\n * @dev Manages liquidation process triggering of main asset-based positions\\n **/\\ncontract LiquidationTriggerChainlinkMainAsset is LiquidationTriggerBase, ReentrancyGuard {\\n    using SafeMath for uint;\\n\\n    // uniswap-based oracle contract\\n    ChainlinkedOracleSimple public immutable chainlinkedOracleMainAsset;\\n\\n    uint public constant Q112 = 2**112;\\n\\n    /**\\n     * @param _vaultManagerParameters The address of the contract with vault manager parameters\\n     * @param _chainlinkedOracleMainAsset The address of Chainlink-based oracle wrapper for main assets\\n     **/\\n    constructor(\\n        address _vaultManagerParameters,\\n        address _chainlinkedOracleMainAsset\\n    )\\n    public\\n    LiquidationTriggerBase(_vaultManagerParameters, 5)\\n    {\\n        chainlinkedOracleMainAsset = ChainlinkedOracleSimple(_chainlinkedOracleMainAsset);\\n    }\\n\\n    /**\\n     * @dev Triggers liquidation of a position\\n     * @param asset The address of the main collateral token of a position\\n     * @param user The owner of a position\\n     **/\\n    function triggerLiquidation(address asset, address user) public override nonReentrant {\\n        // USD value of the main collateral\\n        uint mainUsdValue_q112 = chainlinkedOracleMainAsset.assetToUsd(asset, vault.collaterals(asset, user));\\n\\n        // reverts if a position is not liquidatable\\n        require(isLiquidatablePosition(asset, user, mainUsdValue_q112), \\\"Unit Protocol: SAFE_POSITION\\\");\\n\\n        uint liquidationDiscount_q112 = mainUsdValue_q112.mul(\\n            vaultManagerParameters.liquidationDiscount(asset)\\n        ).div(DENOMINATOR_1E5);\\n\\n        uint initialLiquidationPrice = mainUsdValue_q112.sub(liquidationDiscount_q112).div(Q112);\\n\\n        // sends liquidation command to the Vault\\n        vault.triggerLiquidation(asset, user, initialLiquidationPrice);\\n\\n        // fire an liquidation event\\n        emit LiquidationTriggered(asset, user);\\n    }\\n\\n    /**\\n     * @dev Determines whether a position is liquidatable\\n     * @param asset The address of the main collateral token of a position\\n     * @param user The owner of a position\\n     * @param mainUsdValue_q112 Q112-encoded USD value of the collateral\\n     * @return boolean value, whether a position is liquidatable\\n     **/\\n    function isLiquidatablePosition(\\n        address asset,\\n        address user,\\n        uint mainUsdValue_q112\\n    ) public override view returns (bool) {\\n        uint debt = vault.getTotalDebt(asset, user);\\n\\n        // position is collateralized if there is no debt\\n        if (debt == 0) return false;\\n\\n        require(vault.oracleType(asset, user) == oracleType, \\\"Unit Protocol: INCORRECT_ORACLE_TYPE\\\");\\n\\n        return UR(mainUsdValue_q112, debt) >= vaultManagerParameters.liquidationRatio(asset);\\n    }\\n\\n    /**\\n     * @dev Calculates position's utilization ratio\\n     * @param mainUsdValue_q112 Q112-encoded USD value of the collateral\\n     * @param debt USDP borrowed\\n     * @return utilization ratio of a position\\n     **/\\n    function UR(uint mainUsdValue_q112, uint debt) public override pure returns (uint) {\\n        return debt.mul(100).mul(Q112).div(mainUsdValue_q112);\\n    }\\n}\\n\"\r\n    },\r\n    \"./contracts/helpers/ERC20Like.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: bsl-1.1\\n\\n/*\\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\\n*/\\npragma solidity ^0.7.1;\\n\\n\\ninterface ERC20Like {\\n    function balanceOf(address) external view returns (uint);\\n    function decimals() external view returns (uint8);\\n    function transfer(address, uint256) external returns (bool);\\n    function transferFrom(address, address, uint256) external returns (bool);\\n    function totalSupply() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"./contracts/helpers/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.1;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\ncontract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () public {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"./contracts/liquidators/LiquidationTriggerBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: bsl-1.1\\n\\n/*\\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\\n*/\\npragma solidity ^0.7.1;\\n\\nimport \\\"../Vault.sol\\\";\\nimport \\\"../vault-managers/VaultManagerParameters.sol\\\";\\nimport \\\"../helpers/ReentrancyGuard.sol\\\";\\n\\n\\n/**\\n * @title LiquidationTriggerSimple\\n * @dev Manages triggering of liquidation process\\n **/\\nabstract contract LiquidationTriggerBase {\\n    using SafeMath for uint;\\n\\n    uint public constant DENOMINATOR_1E5 = 1e5;\\n    uint public constant DENOMINATOR_1E2 = 1e2;\\n\\n    // vault manager parameters contract\\n    VaultManagerParameters public immutable vaultManagerParameters;\\n\\n    uint public immutable oracleType;\\n\\n    // Vault contract\\n    Vault public immutable vault;\\n\\n    /**\\n     * @dev Trigger when liquidations are initiated\\n    **/\\n    event LiquidationTriggered(address indexed token, address indexed user);\\n\\n    /**\\n     * @param _vaultManagerParameters The address of the contract with vault manager parameters\\n     * @param _oracleType The id of the oracle type\\n     **/\\n    constructor(address _vaultManagerParameters, uint _oracleType) internal {\\n        vaultManagerParameters = VaultManagerParameters(_vaultManagerParameters);\\n        vault = Vault(VaultManagerParameters(_vaultManagerParameters).vaultParameters().vault());\\n        oracleType = _oracleType;\\n    }\\n\\n    /**\\n     * @dev Triggers liquidation of a position\\n     * @param asset The address of the main collateral token of a position\\n     * @param user The owner of a position\\n     **/\\n    function triggerLiquidation(address asset, address user) external virtual {}\\n\\n    /**\\n     * @dev Determines whether a position is liquidatable\\n     * @param asset The address of the main collateral token of a position\\n     * @param user The owner of a position\\n     * @param collateralUsdValue USD value of the collateral\\n     * @return boolean value, whether a position is liquidatable\\n     **/\\n    function isLiquidatablePosition(\\n        address asset,\\n        address user,\\n        uint collateralUsdValue\\n    ) public virtual view returns (bool);\\n\\n    /**\\n     * @dev Calculates position's utilization ratio\\n     * @param collateralUsdValue USD value of collateral\\n     * @param debt USDP borrowed\\n     * @return utilization ratio of a position\\n     **/\\n    function UR(uint collateralUsdValue, uint debt) public virtual pure returns (uint);\\n}\\n\"\r\n    },\r\n    \"./contracts/Vault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: bsl-1.1\\n\\n/*\\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\\n*/\\npragma solidity ^0.7.1;\\n\\nimport \\\"./helpers/SafeMath.sol\\\";\\nimport \\\"./VaultParameters.sol\\\";\\nimport \\\"./helpers/TransferHelper.sol\\\";\\nimport \\\"./USDP.sol\\\";\\nimport \\\"./helpers/IWETH.sol\\\";\\n\\n\\n/**\\n * @title Vault\\n * @notice Vault is the core of Unit Protocol USDP Stablecoin system\\n * @notice Vault stores and manages collateral funds of all positions and counts debts\\n * @notice Only Vault can manage supply of USDP token\\n * @notice Vault will not be changed/upgraded after initial deployment for the current stablecoin version\\n **/\\ncontract Vault is Auth {\\n    using SafeMath for uint;\\n\\n    // COL token address\\n    address public immutable col;\\n\\n    // WETH token address\\n    address payable public immutable weth;\\n\\n    uint public constant DENOMINATOR_1E5 = 1e5;\\n\\n    uint public constant DENOMINATOR_1E2 = 1e2;\\n\\n    // USDP token address\\n    address public immutable usdp;\\n\\n    // collaterals whitelist\\n    mapping(address => mapping(address => uint)) public collaterals;\\n\\n    // COL token collaterals\\n    mapping(address => mapping(address => uint)) public colToken;\\n\\n    // user debts\\n    mapping(address => mapping(address => uint)) public debts;\\n\\n    // block number of liquidation trigger\\n    mapping(address => mapping(address => uint)) public liquidationBlock;\\n\\n    // initial price of collateral\\n    mapping(address => mapping(address => uint)) public liquidationPrice;\\n\\n    // debts of tokens\\n    mapping(address => uint) public tokenDebts;\\n\\n    // stability fee pinned to each position\\n    mapping(address => mapping(address => uint)) public stabilityFee;\\n\\n    // liquidation fee pinned to each position, 0 decimals\\n    mapping(address => mapping(address => uint)) public liquidationFee;\\n\\n    // type of using oracle pinned for each position\\n    mapping(address => mapping(address => uint)) public oracleType;\\n\\n    // timestamp of the last update\\n    mapping(address => mapping(address => uint)) public lastUpdate;\\n\\n    modifier notLiquidating(address asset, address user) {\\n        require(liquidationBlock[asset][user] == 0, \\\"Unit Protocol: LIQUIDATING_POSITION\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @param _parameters The address of the system parameters\\n     * @param _col COL token address\\n     * @param _usdp USDP token address\\n     **/\\n    constructor(address _parameters, address _col, address _usdp, address payable _weth) public Auth(_parameters) {\\n        col = _col;\\n        usdp = _usdp;\\n        weth = _weth;\\n    }\\n\\n    // only accept ETH via fallback from the WETH contract\\n    receive() external payable {\\n        require(msg.sender == weth, \\\"Unit Protocol: RESTRICTED\\\");\\n    }\\n\\n    /**\\n     * @dev Updates parameters of the position to the current ones\\n     * @param asset The address of the main collateral token\\n     * @param user The owner of a position\\n     **/\\n    function update(address asset, address user) public hasVaultAccess notLiquidating(asset, user) {\\n\\n        // calculate fee using stored stability fee\\n        uint debtWithFee = getTotalDebt(asset, user);\\n        tokenDebts[asset] = tokenDebts[asset].sub(debts[asset][user]).add(debtWithFee);\\n        debts[asset][user] = debtWithFee;\\n\\n        stabilityFee[asset][user] = vaultParameters.stabilityFee(asset);\\n        liquidationFee[asset][user] = vaultParameters.liquidationFee(asset);\\n        lastUpdate[asset][user] = block.timestamp;\\n    }\\n\\n    /**\\n     * @dev Creates new position for user\\n     * @param asset The address of the main collateral token\\n     * @param user The address of a position's owner\\n     * @param _oracleType The type of an oracle\\n     **/\\n    function spawn(address asset, address user, uint _oracleType) external hasVaultAccess notLiquidating(asset, user) {\\n        oracleType[asset][user] = _oracleType;\\n        delete liquidationBlock[asset][user];\\n    }\\n\\n    /**\\n     * @dev Clears unused storage variables\\n     * @param asset The address of the main collateral token\\n     * @param user The address of a position's owner\\n     **/\\n    function destroy(address asset, address user) public hasVaultAccess notLiquidating(asset, user) {\\n        delete stabilityFee[asset][user];\\n        delete oracleType[asset][user];\\n        delete lastUpdate[asset][user];\\n        delete liquidationFee[asset][user];\\n    }\\n\\n    /**\\n     * @notice Tokens must be pre-approved\\n     * @dev Adds main collateral to a position\\n     * @param asset The address of the main collateral token\\n     * @param user The address of a position's owner\\n     * @param amount The amount of tokens to deposit\\n     **/\\n    function depositMain(address asset, address user, uint amount) external hasVaultAccess notLiquidating(asset, user) {\\n        collaterals[asset][user] = collaterals[asset][user].add(amount);\\n        TransferHelper.safeTransferFrom(asset, user, address(this), amount);\\n    }\\n\\n    /**\\n     * @dev Converts ETH to WETH and adds main collateral to a position\\n     * @param user The address of a position's owner\\n     **/\\n    function depositEth(address user) external payable notLiquidating(weth, user) {\\n        IWETH(weth).deposit{value: msg.value}();\\n        collaterals[weth][user] = collaterals[weth][user].add(msg.value);\\n    }\\n\\n    /**\\n     * @dev Withdraws main collateral from a position\\n     * @param asset The address of the main collateral token\\n     * @param user The address of a position's owner\\n     * @param amount The amount of tokens to withdraw\\n     **/\\n    function withdrawMain(address asset, address user, uint amount) external hasVaultAccess notLiquidating(asset, user) {\\n        collaterals[asset][user] = collaterals[asset][user].sub(amount);\\n        TransferHelper.safeTransfer(asset, user, amount);\\n    }\\n\\n    /**\\n     * @dev Withdraws WETH collateral from a position converting WETH to ETH\\n     * @param user The address of a position's owner\\n     * @param amount The amount of ETH to withdraw\\n     **/\\n    function withdrawEth(address payable user, uint amount) external hasVaultAccess notLiquidating(weth, user) {\\n        collaterals[weth][user] = collaterals[weth][user].sub(amount);\\n        IWETH(weth).withdraw(amount);\\n        TransferHelper.safeTransferETH(user, amount);\\n    }\\n\\n    /**\\n     * @notice Tokens must be pre-approved\\n     * @dev Adds COL token to a position\\n     * @param asset The address of the main collateral token\\n     * @param user The address of a position's owner\\n     * @param amount The amount of tokens to deposit\\n     **/\\n    function depositCol(address asset, address user, uint amount) external hasVaultAccess notLiquidating(asset, user) {\\n        colToken[asset][user] = colToken[asset][user].add(amount);\\n        TransferHelper.safeTransferFrom(col, user, address(this), amount);\\n    }\\n\\n    /**\\n     * @dev Withdraws COL token from a position\\n     * @param asset The address of the main collateral token\\n     * @param user The address of a position's owner\\n     * @param amount The amount of tokens to withdraw\\n     **/\\n    function withdrawCol(address asset, address user, uint amount) external hasVaultAccess notLiquidating(asset, user) {\\n        colToken[asset][user] = colToken[asset][user].sub(amount);\\n        TransferHelper.safeTransfer(col, user, amount);\\n    }\\n\\n    /**\\n     * @dev Increases position's debt and mints USDP token\\n     * @param asset The address of the main collateral token\\n     * @param user The address of a position's owner\\n     * @param amount The amount of USDP to borrow\\n     **/\\n    function borrow(\\n        address asset,\\n        address user,\\n        uint amount\\n    )\\n    external\\n    hasVaultAccess\\n    notLiquidating(asset, user)\\n    returns(uint)\\n    {\\n        require(vaultParameters.isOracleTypeEnabled(oracleType[asset][user], asset), \\\"Unit Protocol: WRONG_ORACLE_TYPE\\\");\\n        update(asset, user);\\n        debts[asset][user] = debts[asset][user].add(amount);\\n        tokenDebts[asset] = tokenDebts[asset].add(amount);\\n\\n        // check USDP limit for token\\n        require(tokenDebts[asset] <= vaultParameters.tokenDebtLimit(asset), \\\"Unit Protocol: ASSET_DEBT_LIMIT\\\");\\n\\n        USDP(usdp).mint(user, amount);\\n\\n        return debts[asset][user];\\n    }\\n\\n    /**\\n     * @dev Decreases position's debt and burns USDP token\\n     * @param asset The address of the main collateral token\\n     * @param user The address of a position's owner\\n     * @param amount The amount of USDP to repay\\n     * @return updated debt of a position\\n     **/\\n    function repay(\\n        address asset,\\n        address user,\\n        uint amount\\n    )\\n    external\\n    hasVaultAccess\\n    notLiquidating(asset, user)\\n    returns(uint)\\n    {\\n        uint debt = debts[asset][user];\\n        debts[asset][user] = debt.sub(amount);\\n        tokenDebts[asset] = tokenDebts[asset].sub(amount);\\n        USDP(usdp).burn(user, amount);\\n\\n        return debts[asset][user];\\n    }\\n\\n    /**\\n     * @dev Transfers fee to foundation\\n     * @param asset The address of the fee asset\\n     * @param user The address to transfer funds from\\n     * @param amount The amount of asset to transfer\\n     **/\\n    function chargeFee(address asset, address user, uint amount) external hasVaultAccess notLiquidating(asset, user) {\\n        if (amount != 0) {\\n            TransferHelper.safeTransferFrom(asset, user, vaultParameters.foundation(), amount);\\n        }\\n    }\\n\\n    /**\\n     * @dev Deletes position and transfers collateral to liquidation system\\n     * @param asset The address of the main collateral token\\n     * @param positionOwner The address of a position's owner\\n     * @param initialPrice The starting price of collateral in USDP\\n     **/\\n    function triggerLiquidation(\\n        address asset,\\n        address positionOwner,\\n        uint initialPrice\\n    )\\n    external\\n    hasVaultAccess\\n    notLiquidating(asset, positionOwner)\\n    {\\n        // reverts if oracle type is disabled\\n        require(vaultParameters.isOracleTypeEnabled(oracleType[asset][positionOwner], asset), \\\"Unit Protocol: WRONG_ORACLE_TYPE\\\");\\n\\n        // fix the debt\\n        debts[asset][positionOwner] = getTotalDebt(asset, positionOwner);\\n\\n        liquidationBlock[asset][positionOwner] = block.number;\\n        liquidationPrice[asset][positionOwner] = initialPrice;\\n    }\\n\\n    /**\\n     * @dev Internal liquidation process\\n     * @param asset The address of the main collateral token\\n     * @param positionOwner The address of a position's owner\\n     * @param mainAssetToLiquidator The amount of main asset to send to a liquidator\\n     * @param colToLiquidator The amount of COL to send to a liquidator\\n     * @param mainAssetToPositionOwner The amount of main asset to send to a position owner\\n     * @param colToPositionOwner The amount of COL to send to a position owner\\n     * @param repayment The repayment in USDP\\n     * @param penalty The liquidation penalty in USDP\\n     * @param liquidator The address of a liquidator\\n     **/\\n    function liquidate(\\n        address asset,\\n        address positionOwner,\\n        uint mainAssetToLiquidator,\\n        uint colToLiquidator,\\n        uint mainAssetToPositionOwner,\\n        uint colToPositionOwner,\\n        uint repayment,\\n        uint penalty,\\n        address liquidator\\n    )\\n        external\\n        hasVaultAccess\\n    {\\n        require(liquidationBlock[asset][positionOwner] != 0, \\\"Unit Protocol: NOT_TRIGGERED_LIQUIDATION\\\");\\n\\n        uint mainAssetInPosition = collaterals[asset][positionOwner];\\n        uint mainAssetToFoundation = mainAssetInPosition.sub(mainAssetToLiquidator).sub(mainAssetToPositionOwner);\\n\\n        uint colInPosition = colToken[asset][positionOwner];\\n        uint colToFoundation = colInPosition.sub(colToLiquidator).sub(colToPositionOwner);\\n\\n        delete liquidationPrice[asset][positionOwner];\\n        delete liquidationBlock[asset][positionOwner];\\n        delete debts[asset][positionOwner];\\n        delete collaterals[asset][positionOwner];\\n        delete colToken[asset][positionOwner];\\n\\n        destroy(asset, positionOwner);\\n\\n        // charge liquidation fee and burn USDP\\n        if (repayment > penalty) {\\n            if (penalty != 0) {\\n                TransferHelper.safeTransferFrom(usdp, liquidator, vaultParameters.foundation(), penalty);\\n            }\\n            USDP(usdp).burn(liquidator, repayment.sub(penalty));\\n        } else {\\n            if (repayment != 0) {\\n                TransferHelper.safeTransferFrom(usdp, liquidator, vaultParameters.foundation(), repayment);\\n            }\\n        }\\n\\n        // send the part of collateral to a liquidator\\n        if (mainAssetToLiquidator != 0) {\\n            TransferHelper.safeTransfer(asset, liquidator, mainAssetToLiquidator);\\n        }\\n\\n        if (colToLiquidator != 0) {\\n            TransferHelper.safeTransfer(col, liquidator, colToLiquidator);\\n        }\\n\\n        // send the rest of collateral to a position owner\\n        if (mainAssetToPositionOwner != 0) {\\n            TransferHelper.safeTransfer(asset, positionOwner, mainAssetToPositionOwner);\\n        }\\n\\n        if (colToPositionOwner != 0) {\\n            TransferHelper.safeTransfer(col, positionOwner, colToPositionOwner);\\n        }\\n\\n        if (mainAssetToFoundation != 0) {\\n            TransferHelper.safeTransfer(asset, vaultParameters.foundation(), mainAssetToFoundation);\\n        }\\n\\n        if (colToFoundation != 0) {\\n            TransferHelper.safeTransfer(col, vaultParameters.foundation(), colToFoundation);\\n        }\\n    }\\n\\n    /**\\n     * @notice Only manager can call this function\\n     * @dev Changes broken oracle type to the correct one\\n     * @param asset The address of the main collateral token\\n     * @param user The address of a position's owner\\n     * @param newOracleType The new type of an oracle\\n     **/\\n    function changeOracleType(address asset, address user, uint newOracleType) external onlyManager {\\n        oracleType[asset][user] = newOracleType;\\n    }\\n\\n    /**\\n     * @dev Calculates the total amount of position's debt based on elapsed time\\n     * @param asset The address of the main collateral token\\n     * @param user The address of a position's owner\\n     * @return user debt of a position plus accumulated fee\\n     **/\\n    function getTotalDebt(address asset, address user) public view returns (uint) {\\n        uint debt = debts[asset][user];\\n        if (liquidationBlock[asset][user] != 0) return debt;\\n        uint fee = calculateFee(asset, user, debt);\\n        return debt.add(fee);\\n    }\\n\\n    /**\\n     * @dev Calculates the amount of fee based on elapsed time and repayment amount\\n     * @param asset The address of the main collateral token\\n     * @param user The address of a position's owner\\n     * @param amount The repayment amount\\n     * @return fee amount\\n     **/\\n    function calculateFee(address asset, address user, uint amount) public view returns (uint) {\\n        uint sFeePercent = stabilityFee[asset][user];\\n        uint timePast = block.timestamp.sub(lastUpdate[asset][user]);\\n\\n        return amount.mul(sFeePercent).mul(timePast).div(365 days).div(DENOMINATOR_1E5);\\n    }\\n}\\n\"\r\n    },\r\n    \"./contracts/helpers/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: bsl-1.1\\n\\n/*\\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\\n*/\\npragma solidity ^0.7.1;\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error\\n */\\nlibrary SafeMath {\\n\\n    /**\\n    * @dev Multiplies two numbers, throws on overflow.\\n    */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n        c = a * b;\\n        assert(c / a == b);\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Integer division of two numbers, truncating the quotient.\\n    */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\n    */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        assert(b <= a);\\n        return a - b;\\n    }\\n\\n    /**\\n    * @dev Adds two numbers, throws on overflow.\\n    */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        c = a + b;\\n        assert(c >= a);\\n        return c;\\n    }\\n}\\n\"\r\n    },\r\n    \"./contracts/VaultParameters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: bsl-1.1\\n\\n/*\\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\\n*/\\npragma solidity ^0.7.1;\\n\\n\\n/**\\n * @title Auth\\n * @dev Manages USDP's system access\\n **/\\ncontract Auth {\\n\\n    // address of the the contract with vault parameters\\n    VaultParameters public vaultParameters;\\n\\n    constructor(address _parameters) public {\\n        vaultParameters = VaultParameters(_parameters);\\n    }\\n\\n    // ensures tx's sender is a manager\\n    modifier onlyManager() {\\n        require(vaultParameters.isManager(msg.sender), \\\"Unit Protocol: AUTH_FAILED\\\");\\n        _;\\n    }\\n\\n    // ensures tx's sender is able to modify the Vault\\n    modifier hasVaultAccess() {\\n        require(vaultParameters.canModifyVault(msg.sender), \\\"Unit Protocol: AUTH_FAILED\\\");\\n        _;\\n    }\\n\\n    // ensures tx's sender is the Vault\\n    modifier onlyVault() {\\n        require(msg.sender == vaultParameters.vault(), \\\"Unit Protocol: AUTH_FAILED\\\");\\n        _;\\n    }\\n}\\n\\n\\n/**\\n * @title VaultParameters\\n **/\\ncontract VaultParameters is Auth {\\n\\n    // map token to stability fee percentage; 3 decimals\\n    mapping(address => uint) public stabilityFee;\\n\\n    // map token to liquidation fee percentage, 0 decimals\\n    mapping(address => uint) public liquidationFee;\\n\\n    // map token to USDP mint limit\\n    mapping(address => uint) public tokenDebtLimit;\\n\\n    // permissions to modify the Vault\\n    mapping(address => bool) public canModifyVault;\\n\\n    // managers\\n    mapping(address => bool) public isManager;\\n\\n    // enabled oracle types\\n    mapping(uint => mapping (address => bool)) public isOracleTypeEnabled;\\n\\n    // address of the Vault\\n    address payable public vault;\\n\\n    // The foundation address\\n    address public foundation;\\n\\n    /**\\n     * The address for an Ethereum contract is deterministically computed from the address of its creator (sender)\\n     * and how many transactions the creator has sent (nonce). The sender and nonce are RLP encoded and then\\n     * hashed with Keccak-256.\\n     * Therefore, the Vault address can be pre-computed and passed as an argument before deployment.\\n    **/\\n    constructor(address payable _vault, address _foundation) public Auth(address(this)) {\\n        require(_vault != address(0), \\\"Unit Protocol: ZERO_ADDRESS\\\");\\n        require(_foundation != address(0), \\\"Unit Protocol: ZERO_ADDRESS\\\");\\n\\n        isManager[msg.sender] = true;\\n        vault = _vault;\\n        foundation = _foundation;\\n    }\\n\\n    /**\\n     * @notice Only manager is able to call this function\\n     * @dev Grants and revokes manager's status of any address\\n     * @param who The target address\\n     * @param permit The permission flag\\n     **/\\n    function setManager(address who, bool permit) external onlyManager {\\n        isManager[who] = permit;\\n    }\\n\\n    /**\\n     * @notice Only manager is able to call this function\\n     * @dev Sets the foundation address\\n     * @param newFoundation The new foundation address\\n     **/\\n    function setFoundation(address newFoundation) external onlyManager {\\n        require(newFoundation != address(0), \\\"Unit Protocol: ZERO_ADDRESS\\\");\\n        foundation = newFoundation;\\n    }\\n\\n    /**\\n     * @notice Only manager is able to call this function\\n     * @dev Sets ability to use token as the main collateral\\n     * @param asset The address of the main collateral token\\n     * @param stabilityFeeValue The percentage of the year stability fee (3 decimals)\\n     * @param liquidationFeeValue The liquidation fee percentage (0 decimals)\\n     * @param usdpLimit The USDP token issue limit\\n     * @param oracles The enables oracle types\\n     **/\\n    function setCollateral(\\n        address asset,\\n        uint stabilityFeeValue,\\n        uint liquidationFeeValue,\\n        uint usdpLimit,\\n        uint[] calldata oracles\\n    ) external onlyManager {\\n        setStabilityFee(asset, stabilityFeeValue);\\n        setLiquidationFee(asset, liquidationFeeValue);\\n        setTokenDebtLimit(asset, usdpLimit);\\n        for (uint i=0; i < oracles.length; i++) {\\n            setOracleType(oracles[i], asset, true);\\n        }\\n    }\\n\\n    /**\\n     * @notice Only manager is able to call this function\\n     * @dev Sets a permission for an address to modify the Vault\\n     * @param who The target address\\n     * @param permit The permission flag\\n     **/\\n    function setVaultAccess(address who, bool permit) external onlyManager {\\n        canModifyVault[who] = permit;\\n    }\\n\\n    /**\\n     * @notice Only manager is able to call this function\\n     * @dev Sets the percentage of the year stability fee for a particular collateral\\n     * @param asset The address of the main collateral token\\n     * @param newValue The stability fee percentage (3 decimals)\\n     **/\\n    function setStabilityFee(address asset, uint newValue) public onlyManager {\\n        stabilityFee[asset] = newValue;\\n    }\\n\\n    /**\\n     * @notice Only manager is able to call this function\\n     * @dev Sets the percentage of the liquidation fee for a particular collateral\\n     * @param asset The address of the main collateral token\\n     * @param newValue The liquidation fee percentage (0 decimals)\\n     **/\\n    function setLiquidationFee(address asset, uint newValue) public onlyManager {\\n        require(newValue <= 100, \\\"Unit Protocol: VALUE_OUT_OF_RANGE\\\");\\n        liquidationFee[asset] = newValue;\\n    }\\n\\n    /**\\n     * @notice Only manager is able to call this function\\n     * @dev Enables/disables oracle types\\n     * @param _type The type of the oracle\\n     * @param asset The address of the main collateral token\\n     * @param enabled The control flag\\n     **/\\n    function setOracleType(uint _type, address asset, bool enabled) public onlyManager {\\n        isOracleTypeEnabled[_type][asset] = enabled;\\n    }\\n\\n    /**\\n     * @notice Only manager is able to call this function\\n     * @dev Sets USDP limit for a specific collateral\\n     * @param asset The address of the main collateral token\\n     * @param limit The limit number\\n     **/\\n    function setTokenDebtLimit(address asset, uint limit) public onlyManager {\\n        tokenDebtLimit[asset] = limit;\\n    }\\n}\\n\"\r\n    },\r\n    \"./contracts/helpers/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\n/*\\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\\n*/\\npragma solidity ^0.7.1;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\\n    }\\n\\n    function safeTransfer(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\\n    }\\n\\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\\n    }\\n\\n    function safeTransferETH(address to, uint value) internal {\\n        (bool success,) = to.call{value:value}(new bytes(0));\\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\\n    }\\n}\\n\"\r\n    },\r\n    \"./contracts/USDP.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: bsl-1.1\\n\\n/*\\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\\n*/\\npragma solidity ^0.7.1;\\n\\nimport \\\"./VaultParameters.sol\\\";\\nimport \\\"./helpers/SafeMath.sol\\\";\\n\\n\\n/**\\n * @title USDP token implementation\\n * @dev ERC20 token\\n **/\\ncontract USDP is Auth {\\n    using SafeMath for uint;\\n\\n    // name of the token\\n    string public constant name = \\\"USDP Stablecoin\\\";\\n\\n    // symbol of the token\\n    string public constant symbol = \\\"USDP\\\";\\n\\n    // version of the token\\n    string public constant version = \\\"1\\\";\\n\\n    // number of decimals the token uses\\n    uint8 public constant decimals = 18;\\n\\n    // total token supply\\n    uint public totalSupply;\\n\\n    // balance information map\\n    mapping(address => uint) public balanceOf;\\n\\n    // token allowance mapping\\n    mapping(address => mapping(address => uint)) public allowance;\\n\\n    /**\\n     * @dev Trigger on any successful call to approve(address spender, uint amount)\\n    **/\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n\\n    /**\\n     * @dev Trigger when tokens are transferred, including zero value transfers\\n    **/\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    /**\\n      * @param _parameters The address of system parameters contract\\n     **/\\n    constructor(address _parameters) public Auth(_parameters) {}\\n\\n    /**\\n      * @notice Only Vault can mint USDP\\n      * @dev Mints 'amount' of tokens to address 'to', and MUST fire the\\n      * Transfer event\\n      * @param to The address of the recipient\\n      * @param amount The amount of token to be minted\\n     **/\\n    function mint(address to, uint amount) external onlyVault {\\n        require(to != address(0), \\\"Unit Protocol: ZERO_ADDRESS\\\");\\n\\n        balanceOf[to] = balanceOf[to].add(amount);\\n        totalSupply = totalSupply.add(amount);\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    /**\\n      * @notice Only manager can burn tokens from manager's balance\\n      * @dev Burns 'amount' of tokens, and MUST fire the Transfer event\\n      * @param amount The amount of token to be burned\\n     **/\\n    function burn(uint amount) external onlyManager {\\n        _burn(msg.sender, amount);\\n    }\\n\\n    /**\\n      * @notice Only Vault can burn tokens from any balance\\n      * @dev Burns 'amount' of tokens from 'from' address, and MUST fire the Transfer event\\n      * @param from The address of the balance owner\\n      * @param amount The amount of token to be burned\\n     **/\\n    function burn(address from, uint amount) external onlyVault {\\n        _burn(from, amount);\\n    }\\n\\n    /**\\n      * @dev Transfers 'amount' of tokens to address 'to', and MUST fire the Transfer event. The\\n      * function SHOULD throw if the _from account balance does not have enough tokens to spend.\\n      * @param to The address of the recipient\\n      * @param amount The amount of token to be transferred\\n     **/\\n    function transfer(address to, uint amount) external returns (bool) {\\n        return transferFrom(msg.sender, to, amount);\\n    }\\n\\n    /**\\n      * @dev Transfers 'amount' of tokens from address 'from' to address 'to', and MUST fire the\\n      * Transfer event\\n      * @param from The address of the sender\\n      * @param to The address of the recipient\\n      * @param amount The amount of token to be transferred\\n     **/\\n    function transferFrom(address from, address to, uint amount) public returns (bool) {\\n        require(to != address(0), \\\"Unit Protocol: ZERO_ADDRESS\\\");\\n        require(balanceOf[from] >= amount, \\\"Unit Protocol: INSUFFICIENT_BALANCE\\\");\\n\\n        if (from != msg.sender) {\\n            require(allowance[from][msg.sender] >= amount, \\\"Unit Protocol: INSUFFICIENT_ALLOWANCE\\\");\\n            _approve(from, msg.sender, allowance[from][msg.sender].sub(amount));\\n        }\\n        balanceOf[from] = balanceOf[from].sub(amount);\\n        balanceOf[to] = balanceOf[to].add(amount);\\n\\n        emit Transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n      * @dev Allows 'spender' to withdraw from your account multiple times, up to the 'amount' amount. If\\n      * this function is called again it overwrites the current allowance with 'amount'.\\n      * @param spender The address of the account able to transfer the tokens\\n      * @param amount The amount of tokens to be approved for transfer\\n     **/\\n    function approve(address spender, uint amount) external returns (bool) {\\n        _approve(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to `approve` that can be used as a mitigation for\\n     * problems described in `IERC20.approve`.\\n     *\\n     * Emits an `Approval` event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint addedValue) public virtual returns (bool) {\\n        _approve(msg.sender, spender, allowance[msg.sender][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to `approve` that can be used as a mitigation for\\n     * problems described in `IERC20.approve`.\\n     *\\n     * Emits an `Approval` event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint subtractedValue) public virtual returns (bool) {\\n        _approve(msg.sender, spender, allowance[msg.sender][spender].sub(subtractedValue));\\n        return true;\\n    }\\n\\n    function _approve(address owner, address spender, uint amount) internal virtual {\\n        require(owner != address(0), \\\"Unit Protocol: approve from the zero address\\\");\\n        require(spender != address(0), \\\"Unit Protocol: approve to the zero address\\\");\\n\\n        allowance[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    function _burn(address from, uint amount) internal virtual {\\n        balanceOf[from] = balanceOf[from].sub(amount);\\n        totalSupply = totalSupply.sub(amount);\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"./contracts/helpers/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\n/*\\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\\n*/\\npragma solidity ^0.7.1;\\n\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n    function transfer(address to, uint value) external returns (bool);\\n    function withdraw(uint) external;\\n}\\n\"\r\n    },\r\n    \"./contracts/vault-managers/VaultManagerParameters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: bsl-1.1\\n\\n/*\\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\\n*/\\npragma solidity ^0.7.1;\\n\\nimport \\\"../VaultParameters.sol\\\";\\n\\n\\n/**\\n * @title VaultManagerParameters\\n **/\\ncontract VaultManagerParameters is Auth {\\n\\n    // determines the minimum percentage of COL token part in collateral, 0 decimals\\n    mapping(address => uint) public minColPercent;\\n\\n    // determines the maximum percentage of COL token part in collateral, 0 decimals\\n    mapping(address => uint) public maxColPercent;\\n\\n    // map token to initial collateralization ratio; 0 decimals\\n    mapping(address => uint) public initialCollateralRatio;\\n\\n    // map token to liquidation ratio; 0 decimals\\n    mapping(address => uint) public liquidationRatio;\\n\\n    // map token to liquidation discount; 3 decimals\\n    mapping(address => uint) public liquidationDiscount;\\n\\n    // map token to devaluation period in blocks\\n    mapping(address => uint) public devaluationPeriod;\\n\\n    constructor(address _vaultParameters) public Auth(_vaultParameters) {}\\n\\n    /**\\n     * @notice Only manager is able to call this function\\n     * @dev Sets ability to use token as the main collateral\\n     * @param asset The address of the main collateral token\\n     * @param stabilityFeeValue The percentage of the year stability fee (3 decimals)\\n     * @param liquidationFeeValue The liquidation fee percentage (0 decimals)\\n     * @param initialCollateralRatioValue The initial collateralization ratio\\n     * @param liquidationRatioValue The liquidation ratio\\n     * @param liquidationDiscountValue The liquidation discount (3 decimals)\\n     * @param devaluationPeriodValue The devaluation period in blocks\\n     * @param usdpLimit The USDP token issue limit\\n     * @param oracles The enabled oracles type IDs\\n     * @param minColP The min percentage of COL value in position (0 decimals)\\n     * @param maxColP The max percentage of COL value in position (0 decimals)\\n     **/\\n    function setCollateral(\\n        address asset,\\n        uint stabilityFeeValue,\\n        uint liquidationFeeValue,\\n        uint initialCollateralRatioValue,\\n        uint liquidationRatioValue,\\n        uint liquidationDiscountValue,\\n        uint devaluationPeriodValue,\\n        uint usdpLimit,\\n        uint[] calldata oracles,\\n        uint minColP,\\n        uint maxColP\\n    ) external onlyManager {\\n        vaultParameters.setCollateral(asset, stabilityFeeValue, liquidationFeeValue, usdpLimit, oracles);\\n        setInitialCollateralRatio(asset, initialCollateralRatioValue);\\n        setLiquidationRatio(asset, liquidationRatioValue);\\n        setDevaluationPeriod(asset, devaluationPeriodValue);\\n        setLiquidationDiscount(asset, liquidationDiscountValue);\\n        setColPartRange(asset, minColP, maxColP);\\n    }\\n\\n    /**\\n     * @notice Only manager is able to call this function\\n     * @dev Sets the initial collateral ratio\\n     * @param asset The address of the main collateral token\\n     * @param newValue The collateralization ratio (0 decimals)\\n     **/\\n    function setInitialCollateralRatio(address asset, uint newValue) public onlyManager {\\n        require(newValue != 0 && newValue <= 100, \\\"Unit Protocol: INCORRECT_COLLATERALIZATION_VALUE\\\");\\n        initialCollateralRatio[asset] = newValue;\\n    }\\n\\n    /**\\n     * @notice Only manager is able to call this function\\n     * @dev Sets the liquidation ratio\\n     * @param asset The address of the main collateral token\\n     * @param newValue The liquidation ratio (0 decimals)\\n     **/\\n    function setLiquidationRatio(address asset, uint newValue) public onlyManager {\\n        require(newValue != 0 && newValue >= initialCollateralRatio[asset], \\\"Unit Protocol: INCORRECT_COLLATERALIZATION_VALUE\\\");\\n        liquidationRatio[asset] = newValue;\\n    }\\n\\n    /**\\n     * @notice Only manager is able to call this function\\n     * @dev Sets the liquidation discount\\n     * @param asset The address of the main collateral token\\n     * @param newValue The liquidation discount (3 decimals)\\n     **/\\n    function setLiquidationDiscount(address asset, uint newValue) public onlyManager {\\n        require(newValue < 1e5, \\\"Unit Protocol: INCORRECT_DISCOUNT_VALUE\\\");\\n        liquidationDiscount[asset] = newValue;\\n    }\\n\\n    /**\\n     * @notice Only manager is able to call this function\\n     * @dev Sets the devaluation period of collateral after liquidation\\n     * @param asset The address of the main collateral token\\n     * @param newValue The devaluation period in blocks\\n     **/\\n    function setDevaluationPeriod(address asset, uint newValue) public onlyManager {\\n        require(newValue != 0, \\\"Unit Protocol: INCORRECT_DEVALUATION_VALUE\\\");\\n        devaluationPeriod[asset] = newValue;\\n    }\\n\\n    /**\\n     * @notice Only manager is able to call this function\\n     * @dev Sets the percentage range of the COL token part for specific collateral token\\n     * @param asset The address of the main collateral token\\n     * @param min The min percentage (0 decimals)\\n     * @param max The max percentage (0 decimals)\\n     **/\\n    function setColPartRange(address asset, uint min, uint max) public onlyManager {\\n        require(max <= 100 && min <= max, \\\"Unit Protocol: WRONG_RANGE\\\");\\n        minColPercent[asset] = min;\\n        maxColPercent[asset] = max;\\n    }\\n}\\n\"\r\n    },\r\n    \"./contracts/oracles/OracleSimple.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: bsl-1.1\\n\\n/*\\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\\n*/\\npragma solidity ^0.7.1;\\n\\n\\n/**\\n * @title OracleSimple\\n **/\\nabstract contract OracleSimple {\\n    function assetToUsd(address asset, uint amount) public virtual view returns (uint);\\n}\\n\\n\\n/**\\n * @title OracleSimplePoolToken\\n **/\\nabstract contract OracleSimplePoolToken is OracleSimple {\\n    ChainlinkedOracleSimple public oracleMainAsset;\\n}\\n\\n\\n/**\\n * @title ChainlinkedOracleSimple\\n **/\\nabstract contract ChainlinkedOracleSimple is OracleSimple {\\n    address public WETH;\\n    function ethToUsd(uint ethAmount) public virtual view returns (uint);\\n    function assetToEth(address asset, uint amount) public virtual view returns (uint);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultManagerParameters\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_chainlinkedOracleMainAsset\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"LiquidationTriggered\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DENOMINATOR_1E2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DENOMINATOR_1E5\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Q112\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mainUsdValue_q112\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debt\",\"type\":\"uint256\"}],\"name\":\"UR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chainlinkedOracleMainAsset\",\"outputs\":[{\"internalType\":\"contract ChainlinkedOracleSimple\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"mainUsdValue_q112\",\"type\":\"uint256\"}],\"name\":\"isLiquidatablePosition\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracleType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"triggerLiquidation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"contract Vault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultManagerParameters\",\"outputs\":[{\"internalType\":\"contract VaultManagerParameters\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"LiquidationTriggerChainlinkMainAsset","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000203153522b9eaef4ae17c6e99851ee7b2f7d312e0000000000000000000000000b17546514aad0d5453f9e2d0a56a19cb5dae774","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://127c23902036bf355d93453741844b986c1e67d77478977dd7cd0baaa114d232"}]}