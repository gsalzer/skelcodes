{"status":"1","message":"OK","result":[{"SourceCode":"//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.1;\r\n\r\ninterface IERC20_Vesting {\r\n  /// @notice this function allows the conroller or permitted issuer to issue tokens from this contract itself (no tranches) into the specified tranche\r\n  function issue_into_tranche(address user, uint8 tranche_id, uint256 amount) external;\r\n}\r\n\r\n/// @title Claim_Codes\r\n/// @author Vega Protocol\r\n/// @notice This contract manages claim code redeption and issue limits\r\n/// @dev run ERC20_Vesting.permit_issuer(this contract, amount) prior to claims\r\ncontract Claim_Codes {\r\n\r\n  event Issuer_Permitted(address indexed issuer, uint256 amount);\r\n  event Issuer_Revoked(address indexed issuer);\r\n  event Controller_Set(address indexed new_controller);\r\n  event Claimed(bytes32 indexed message_hash);\r\n\r\n  /// @notice this is the address of the 'owner' of this contract. Only the controller can permit_issuer\r\n  address public controller;\r\n  /// @notice this is the address of the ERC20_Vesting smart contract whos issue_into_tranche command this contract calls\r\n  address public vesting_address;\r\n  /// @notice nonce => has been used\r\n  mapping(uint256 => bool) public nonces;\r\n  /// @notice 2 char ISO country codes ASCII to hex string (like 0x12Af) => is allowed country\r\n  mapping(bytes2 => bool) public allowed_countries;\r\n  /// @notice this is a mapping of all of the commited, but unclaimed untargeted claim codes\r\n  /// @notice the bytes32 hash is: keccak256(abi.encode(claim_code, claimer))\r\n  mapping(bytes32 => bool) public commits;\r\n  /// @notice issuer address => permitted issuance allowance\r\n  mapping(address => uint256) public permitted_issuance;\r\n\r\n  /// @param _vesting_address The target ERC20_Vesting contract\r\n  /// @param _controller address of the 'admin' of this contract\r\n  /// @notice _vesting_address cannot be changed once deployed\r\n  constructor(address _vesting_address, address _controller){\r\n    controller = _controller;\r\n    vesting_address = _vesting_address;\r\n    emit Controller_Set(_controller);\r\n  }\r\n\r\n  /// @notice this function removes the provided country codes from list of allowed countries\r\n  /// @param country_codes Array of 2 char ISO country codes ASCII to hex string (like 0x12Af) that will be blocked\r\n  function block_countries(bytes2[] calldata country_codes) public only_controller {\r\n    for (uint256 i = 0; i < country_codes.length; i++) {\r\n      allowed_countries[country_codes[i]] = false;\r\n    }\r\n  }\r\n\r\n  /// @notice this function adds the provided country codes to list of allowed countries\r\n  /// @param country_codes Array of 2 char ISO country codes ASCII to hex string (like 0x12Af) that will be allowed\r\n  function allow_countries(bytes2[] calldata country_codes) public only_controller {\r\n    for (uint256 i = 0; i < country_codes.length; i++) {\r\n      allowed_countries[country_codes[i]] = true;\r\n    }\r\n  }\r\n\r\n  function verify_signature(bytes calldata claim_code, bytes32 message_hash) internal pure returns(address) {\r\n    //recover address from that msg\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n\r\n      assembly {\r\n        // first 32 bytes, after the length prefix\r\n       r := calldataload(claim_code.offset)\r\n       // second 32 bytes\r\n       s := calldataload(add(claim_code.offset, 32))\r\n       // final byte (first byte of the next 32 bytes)\r\n       v := byte(0,calldataload(add(claim_code.offset, 64)))\r\n      }\r\n    // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n    // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n    // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\r\n    // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n    //\r\n    // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n    // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n    // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n    // these malleable signatures as well.\r\n    require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"Mallable signature error\");\r\n\r\n    if (v < 27) v += 27;\r\n\r\n    return ecrecover(message_hash, v, r, s);\r\n  }\r\n\r\n  /// @notice this function redeems claim codes that have been issued to a specific Ethereum address\r\n  /// @notice this function verifies that the claim code and provided params are correct, then issues 'denomination' amount of tokens into provided tranche\r\n  /// @notice this function calls ERC20_Vesting.issue_into_tranche\r\n  /// @notice code issuer must have permitted_issuance balance >= denomination\r\n  /// @notice only the targeted address encoded into the claim_code can run this function\r\n  /// @param claim_code this is the signed hash: keccak256(abi.encode(denomination, tranche, expiry, nonce, target))\r\n  /// @param denomination amount of tokens to be claimed\r\n  /// @param tranche the tranche_id of tranche into which the tokens will be issued\r\n  /// @param expiry expiration unix timestap (in seconds) of the code being claimed\r\n  /// @param nonce the unique randomly generated number of the code being claimed\r\n  /// @param country_code the 2 char ISO country code ASCII to hex string (like 0x12Af) of the claimer\r\n  /// @notice Crimea is excluded from both Russia and Ukraine for the purpose of processing claim codes, the substitute ISO code for Crimera region is \"RC\"\r\n  function redeem_targeted(bytes calldata claim_code, uint256 denomination, uint8 tranche, uint256 expiry, uint256 nonce, bytes2 country_code) public {\r\n    require(expiry == 0 || block.timestamp <= expiry, \"this code has expired\");\r\n    require(!nonces[nonce], \"already redeemed\");\r\n    require(allowed_countries[country_code], \"restricted country\");\r\n\r\n    bytes32 message_hash = keccak256(abi.encode(denomination, tranche, expiry, nonce, msg.sender));\r\n\r\n    address recovered_address = verify_signature(claim_code, message_hash);\r\n    require(recovered_address != address(0), \"bad claim code\");\r\n    require(recovered_address != msg.sender, \"cannot issue to self\");\r\n    if(permitted_issuance[recovered_address] > 0){\r\n      /// @dev if code gets here, they are an issuer if not they must be the controller to continue\r\n      require(permitted_issuance[recovered_address] >= denomination, \"not enough permitted balance\");\r\n      permitted_issuance[recovered_address] -= denomination;\r\n    } else {\r\n      require(recovered_address == controller, \"unauthorized issuer\");\r\n    }\r\n\r\n    nonces[nonce] = true;\r\n    IERC20_Vesting(vesting_address).issue_into_tranche(msg.sender, tranche, denomination);\r\n    emit Claimed(message_hash);\r\n  }\r\n\r\n  /// @notice this function returns the hash of the claim_code + the address of the wallet that runs this.\r\n  /// @notice the hash generated by this fucntion is the expected hash for commit_untargeted_code\r\n  /// @param claim_code the untargeted claim code which is the signed hash: keccak256(abi.encode(denomination, tranche, expiry, nonce))\r\n  function get_code_hash(bytes memory claim_code) public view returns (bytes32){\r\n    return keccak256(abi.encode(claim_code, msg.sender));\r\n  }\r\n\r\n  /// @notice this function is the commit step of the commit/reveal procedure to prevent frontrunning of untargeted claim codes\r\n  /// @param hash this is the hash of the claim_code mixed with the claimer's address: keccak256(abi.encode(claim_code, claimer_address))\r\n  /// @notice this step MUST be completed before redeem_untargeted_code will work, otherwise the claimer will recieve the error: \"code has not been commited\"\r\n  function commit_untargeted_code(bytes32 hash) public {\r\n    commits[hash] = true;\r\n  }\r\n\r\n  /// @notice this function redeems untargeted claim codes to the address that runs it\r\n  /// @notice this function verifies that the claim code and provided params are correct, then issues 'denomination' amount of tokens into provided tranche\r\n  /// @notice this function calls ERC20_Vesting.issue_into_tranche\r\n  /// @notice code issuer must have permitted_issuance balance >= denomination\r\n  /// @notice claimer MUST run commit_untargeted_code first\r\n  /// @param claim_code this is the signed hash: keccak256(abi.encode(denomination, tranche, expiry, nonce, target))\r\n  /// @param denomination amount of tokens to be claimed\r\n  /// @param tranche the tranche_id of tranche into which the tokens will be issued\r\n  /// @param expiry expiration unix timestap (in seconds) of the code being claimed\r\n  /// @param nonce the unique randomly generated number of the code being claimed\r\n  /// @param country_code the 2 char ISO country code ASCII to hex string (like 0x12Af) of the claimer\r\n  /// @notice Crimea is excluded from both Russia and Ukraine for the purpose of processing claim codes, the substitute ISO code for Crimera region is \"RC\"\r\n  function redeem_untargeted_code(bytes calldata claim_code, uint256 denomination, uint8 tranche, uint256 expiry, uint256 nonce, bytes2 country_code) public {\r\n    require(expiry == 0 || block.timestamp <= expiry, \"this code has expired\");\r\n    require(!nonces[nonce], \"already redeemed\");\r\n    require(allowed_countries[country_code], \"restricted country\");\r\n\r\n    bytes32 message_hash = keccak256(abi.encode(denomination, tranche, expiry, nonce));\r\n    bytes32 commit_msg = keccak256(abi.encode(claim_code, msg.sender));\r\n    require(commits[commit_msg], \"code has not been commited\");\r\n\r\n    address recovered_address = verify_signature(claim_code, message_hash);\r\n    require(recovered_address != address(0), \"bad claim code\");\r\n    require(recovered_address != msg.sender, \"cannot issue to self\");\r\n    if(permitted_issuance[recovered_address] > 0){\r\n      /// @dev if code gets here, they are an issuer if not they must be the controller to continue\r\n      require(permitted_issuance[recovered_address] >= denomination, \"not enough permitted balance\");\r\n      permitted_issuance[recovered_address] -= denomination;\r\n    } else {\r\n      require(recovered_address == controller, \"unauthorized issuer\");\r\n    }\r\n    delete(commits[commit_msg]);\r\n    nonces[nonce] = true;\r\n    IERC20_Vesting(vesting_address).issue_into_tranche(msg.sender, tranche, denomination);\r\n    emit Claimed(message_hash);\r\n  }\r\n\r\n  /// @notice This function allows the controller to permit the given address to issue the given Amount\r\n  /// @notice Target users MUST have a zero (0) permitted issuance balance (try revoke_issuer)\r\n  /// @dev emits Issuer_Permitted event\r\n  /// @param issuer Target address to be allowed to issue given amount\r\n  /// @param amount Number of tokens issuer is permitted to issue\r\n  function permit_issuer(address issuer, uint256 amount) public only_controller {\r\n    /// @notice revoke is required first to stop a simple double allowance attack\r\n    require(amount > 0, \"amount must be > 0\");\r\n    require(permitted_issuance[issuer] == 0, \"issuer already permitted, revoke first\");\r\n    require(controller != issuer, \"controller cannot be permitted issuer\");\r\n    permitted_issuance[issuer] = amount;\r\n    emit Issuer_Permitted(issuer, amount);\r\n  }\r\n\r\n  /// @notice This function allows the controller to revoke issuance permission from given target\r\n  /// @notice permitted_issuance must be greater than zero (0)\r\n  /// @dev emits Issuer_Revoked event\r\n  /// @param issuer Target address of issuer to be revoked\r\n  function revoke_issuer(address issuer) public only_controller {\r\n    require(permitted_issuance[issuer] != 0, \"issuer already revoked\");\r\n    permitted_issuance[issuer] = 0;\r\n    emit Issuer_Revoked(issuer);\r\n  }\r\n\r\n  /// @notice This function allows the controller to assign a new controller\r\n  /// @dev Emits Controller_Set event\r\n  /// @param new_controller Address of the new controller\r\n  function set_controller(address new_controller) public only_controller {\r\n    controller = new_controller;\r\n    permitted_issuance[new_controller] = 0;\r\n    emit Controller_Set(new_controller);\r\n  }\r\n\r\n  modifier only_controller {\r\n         require( msg.sender == controller, \"not controller\" );\r\n         _;\r\n  }\r\n\r\n}\r\n\r\n/**\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMWEMMMMMMMMMMMMMMMMMMMMMMMMMM...............MMMMMMMMMMMMM\r\nMMMMMMLOVEMMMMMMMMMMMMMMMMMMMMMM...............MMMMMMMMMMMMM\r\nMMMMMMMMMMHIXELMMMMMMMMMMMM....................MMMMMNNMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMM....................MMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMM88=........................+MMMMMMMMMM\r\nMMMMMMMMMMMMMMMMM....................MMMMM...MMMMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMM....................MMMMM...MMMMMMMMMMMMMMM\r\nMMMMMMMMMMMM.........................MM+..MMM....+MMMMMMMMMM\r\nMMMMMMMMMNMM...................... ..MM?..MMM.. .+MMMMMMMMMM\r\nMMMMNDDMM+........................+MM........MM..+MMMMMMMMMM\r\nMMMMZ.............................+MM....................MMM\r\nMMMMZ.............................+MM....................MMM\r\nMMMMZ.............................+MM....................DDD\r\nMMMMZ.............................+MM..ZMMMMMMMMMMMMMMMMMMMM\r\nMMMMZ.............................+MM..ZMMMMMMMMMMMMMMMMMMMM\r\nMM..............................MMZ....ZMMMMMMMMMMMMMMMMMMMM\r\nMM............................MM.......ZMMMMMMMMMMMMMMMMMMMM\r\nMM............................MM.......ZMMMMMMMMMMMMMMMMMMMM\r\nMM......................ZMMMMM.......MMMMMMMMMMMMMMMMMMMMMMM\r\nMM............... ......ZMMMMM.... ..MMMMMMMMMMMMMMMMMMMMMMM\r\nMM...............MMMMM88~.........+MM..ZMMMMMMMMMMMMMMMMMMMM\r\nMM.......$DDDDDDD.......$DDDDD..DDNMM..ZMMMMMMMMMMMMMMMMMMMM\r\nMM.......$DDDDDDD.......$DDDDD..DDNMM..ZMMMMMMMMMMMMMMMMMMMM\r\nMM.......ZMMMMMMM.......ZMMMMM..MMMMM..ZMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMM+.......MMMMM88NMMMMM..MMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMM+.......MMMMM88NMMMMM..MMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vesting_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_controller\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"message_hash\",\"type\":\"bytes32\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"new_controller\",\"type\":\"address\"}],\"name\":\"Controller_Set\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"issuer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Issuer_Permitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"issuer\",\"type\":\"address\"}],\"name\":\"Issuer_Revoked\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes2[]\",\"name\":\"country_codes\",\"type\":\"bytes2[]\"}],\"name\":\"allow_countries\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes2\",\"name\":\"\",\"type\":\"bytes2\"}],\"name\":\"allowed_countries\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes2[]\",\"name\":\"country_codes\",\"type\":\"bytes2[]\"}],\"name\":\"block_countries\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"commit_untargeted_code\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"commits\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"claim_code\",\"type\":\"bytes\"}],\"name\":\"get_code_hash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"issuer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"permit_issuer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"permitted_issuance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"claim_code\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"denomination\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"tranche\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes2\",\"name\":\"country_code\",\"type\":\"bytes2\"}],\"name\":\"redeem_targeted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"claim_code\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"denomination\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"tranche\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes2\",\"name\":\"country_code\",\"type\":\"bytes2\"}],\"name\":\"redeem_untargeted_code\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"issuer\",\"type\":\"address\"}],\"name\":\"revoke_issuer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"new_controller\",\"type\":\"address\"}],\"name\":\"set_controller\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vesting_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Claim_Codes","CompilerVersion":"v0.8.1+commit.df193b15","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000023d1bfe8fa50a167816fbd79d7932577c06011f40000000000000000000000006ad570cb22d9c1a5ec5aba5b6ebea12ae6f08e97","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://b06f041ec50b5abd45d8df3ca09337af63bc12c16bab3da9c651b9a89f720164"}]}