{"status":"1","message":"OK","result":[{"SourceCode":"{\"BlobDefinition.sol\":{\"content\":\"pragma solidity 0.5.10;\\n\\nimport \\u0027./LibAddress.sol\\u0027;\\nimport \\u0027./LibInteger.sol\\u0027;\\n\\n/**\\n * @title BlobDefinition \\n * @dev HBD token contract adhering to ERC721 standard\\n */\\ncontract BlobDefinition\\n{\\n    using LibAddress for address;\\n    using LibInteger for uint;\\n\\n    event Transfer(address indexed from, address indexed to, uint indexed id);\\n    event Approval(address indexed owner, address indexed approved, uint indexed id);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev The admin of the contract\\n     */\\n    address payable private _admin;\\n\\n    /**\\n     * @dev The total minted tokens\\n     */\\n    uint private _supply;\\n\\n    /**\\n     * @dev The base url of token info page\\n     */\\n    string private _base_uri;\\n\\n    /**\\n     * @dev Permitted addresses to carry out special functions\\n     */\\n    mapping (address =\\u003e bool) private _permissions;\\n\\n    /**\\n     * @dev Number of tokens held by an address\\n     */\\n    mapping (address =\\u003e uint) private _token_balances;\\n\\n    /**\\n     * @dev Owners of each token\\n     */\\n    mapping (uint =\\u003e address) private _token_owners;\\n\\n    /**\\n     * @dev Approved third party addresses for each token\\n     */\\n    mapping (uint =\\u003e address) private _token_approvals;\\n\\n    /**\\n     * @dev Approved third party addresses to manage all tokens belonging to some address\\n     */\\n    mapping (address =\\u003e mapping (address =\\u003e bool)) private _token_operators;\\n\\n    /**\\n     * @dev Interfaces supported by this contract\\n     */\\n    mapping(bytes4 =\\u003e bool) private _supported_interfaces;\\n\\n    /**\\n     * @dev The name of token\\n     */\\n    string private constant _name = \\\"Hash Blob Definition\\\";\\n\\n    /**\\n     * @dev The symbol of token\\n     */\\n    string private constant _symbol = \\\"HBD\\\";\\n\\n    /**\\n     * Interface id for ERC165\\n     */\\n    bytes4 private constant _interface_165 = 0x01ffc9a7;\\n\\n    /**\\n     * Interface id for ERC721\\n     */\\n    bytes4 private constant _interface_721 = 0x80ac58cd;\\n\\n    /**\\n     * Maximum number of tokens to be minted\\n     */\\n    uint private constant _max_supply = 16384;\\n\\n    /**\\n     * @dev Initialise the contract\\n     */\\n    constructor () public\\n    {\\n        //The contract creator becomes the admin\\n        _admin = msg.sender;\\n\\n        //Register supported interfaces\\n        _supported_interfaces[_interface_165] = true;\\n        _supported_interfaces[_interface_721] = true;\\n    }\\n\\n    /**\\n     * @dev Allow access only for the admin of contract\\n     */\\n    modifier onlyAdmin()\\n    {\\n        require(msg.sender == _admin);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Allow access only for the permitted addresses\\n     */\\n    modifier onlyPermitted()\\n    {\\n        require(_permissions[msg.sender]);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Give or revoke permission of accounts\\n     * @param account The address to change permission\\n     * @param permission True if the permission should be granted, false if it should be revoked\\n     */\\n    function permit(address account, bool permission) public onlyAdmin\\n    {\\n        _permissions[account] = permission;\\n    }\\n\\n    /**\\n     * @dev Withdraw from the balance of this contract\\n     * @param amount The amount to be withdrawn, if zero is provided the whole balance will be withdrawn\\n     */\\n    function clean(uint amount) public onlyAdmin\\n    {\\n        if (amount == 0){\\n            _admin.transfer(address(this).balance);\\n        } else {\\n            _admin.transfer(amount);\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the base uri\\n     * @param uri The base uri\\n     */\\n    function base(string memory uri) public onlyAdmin\\n    {\\n        _base_uri = uri;\\n    }\\n\\n    /**\\n     * @dev Move token from one account to another\\n     * @param from The token sender address\\n     * @param to The recipient address\\n     * @param id The token id to transfer\\n     */\\n    function transferFrom(address from, address to, uint id) public\\n    {\\n        //The token must exist\\n        require(_isExist(id));\\n\\n        //Caller must be approved or the owner of token\\n        require(_isApprovedOrOwner(msg.sender, id));\\n\\n        //Do the transfer\\n        _send(from, to, id, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Safely move token from one account to another\\n     * @param from The token sender address\\n     * @param to The recipient address\\n     * @param id The token id to transfer\\n     */\\n    function safeTransferFrom(address from, address to, uint id) public\\n    {\\n        //The token must exist\\n        require(_isExist(id));\\n\\n        //Caller must be approved or the owner of token\\n        require(_isApprovedOrOwner(msg.sender, id));\\n\\n        //Do the transfer\\n        _send(from, to, id, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Safely move token from one account to another\\n     * @param from The token sender address\\n     * @param to The recipient address\\n     * @param id The token id to transfer\\n     * @param data Additional extra data\\n     */\\n    function safeTransferFrom(address from, address to, uint id, bytes memory data) public\\n    {\\n        //The token must exist\\n        require(_isExist(id));\\n\\n        //Caller must be approved or the owner of token\\n        require(_isApprovedOrOwner(msg.sender, id));\\n\\n        //Do the transfer\\n        _send(from, to, id, data);\\n    }\\n\\n    /**\\n     * @dev Allow a third party to transfer caller\\u0027s token\\n     * @param to The address to allow\\n     * @param id The token id to allow transfer\\n     */\\n    function approve(address to, uint id) public\\n    {\\n        //The token must exist\\n        require(_isExist(id));\\n\\n        //No need to approve the owner\\n        address owner = ownerOf(id);\\n        require(to != owner);\\n\\n        //Caller must be the owner of token or an approved operator\\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\\n        \\n        //Grant approval\\n        _token_approvals[id] = to;\\n\\n        //Emit events\\n        emit Approval(owner, to, id);\\n    }\\n\\n    /**\\n     * @dev Grant or revoke approval for a third party to transfer all of caller\\u0027s tokens\\n     * @param to The address to grant or revoke\\n     * @param approved Grant or revoke approval\\n     */\\n    function setApprovalForAll(address to, bool approved) public\\n    {\\n        //Cannot set own settings\\n        require(to != msg.sender);\\n\\n        //Grant or revoke approval\\n        _token_operators[msg.sender][to] = approved;\\n\\n        //Emit events\\n        emit ApprovalForAll(msg.sender, to, approved);\\n    }\\n\\n    /**\\n     * @dev Mint tokens\\n     * @param to The owner of token\\n     */\\n    function mint(address to) public onlyPermitted returns (uint)\\n    {\\n        //No point of minting to zero address\\n        require(!to.isOriginAddress());\\n\\n        //Must not exceed the maximum available tokens to be minted\\n        require(_supply \\u003c _max_supply);\\n\\n        //Mint the token\\n        uint id = _supply.add(1);\\n        _token_owners[id] = to;\\n        _token_balances[to] = _token_balances[to].add(1);\\n\\n        //Increment supply\\n        _supply = id;\\n\\n        //Emit events\\n        emit Transfer(address(0), to, id);\\n\\n        return id;\\n    }\\n\\n    /**\\n     * @dev Enable tokens\\n     * @param to The owner of token\\n     * @param id The token id to enable\\n     */\\n    function enable(address to, uint id) public onlyPermitted\\n    {\\n        //Must be a valid id\\n        require(id \\u003e 0);\\n\\n        //No point of minting to zero address\\n        require(!to.isOriginAddress());\\n\\n        //Token does not already exists\\n        require(!_isExist(id));\\n\\n        //Enable the token\\n        _token_owners[id] = to;\\n        _token_balances[to] = _token_balances[to].add(1);\\n\\n        //Emit events\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    /**\\n     * @dev Burn tokens\\n     * @param owner The owner of token\\n     * @param id The token id to burn\\n     */\\n    function disable(address owner, uint id) public onlyPermitted\\n    {\\n        //Token must exist\\n        require(_isExist(id));\\n\\n        //Token must be owned by sent in address\\n        require(ownerOf(id) == owner);\\n\\n        //Disable the token\\n        _token_approvals[id] = address(0);\\n        _token_balances[owner] = _token_balances[owner].sub(1);\\n        _token_owners[id] = address(0);\\n\\n        //Emit events\\n        emit Transfer(owner, address(0), id);\\n    }\\n\\n    /**\\n     * @dev Safely move token from one account to another\\n     * @param from The token sender address\\n     * @param to The recipient address\\n     * @param id The token id to transfer\\n     */\\n    function move(address from, address to, uint id) public onlyPermitted\\n    {\\n        //The token must exist\\n        require(_isExist(id));\\n\\n        //Do the transfer\\n        _send(from, to, id, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Get the approved address for a token\\n     * @param id The token id\\n     * @return address The approved address\\n     */\\n    function getApproved(uint id) public view returns (address)\\n    {\\n        return _token_approvals[id];\\n    }\\n\\n    /**\\n     * @dev Check whether the provided operator is approved to manage owner\\u0027s tokens\\n     * @param owner The token owner address\\n     * @param operator The operator address to check against\\n     * @return bool True if the operator is approved, otherwise false\\n     */\\n    function isApprovedForAll(address owner, address operator) public view returns (bool)\\n    {\\n        return _token_operators[owner][operator];\\n    }\\n\\n    /**\\n     * @dev Get number of tokens belonging to an account\\n     * @param account The address of account to check\\n     * @return uint The tokens balance\\n     */\\n    function balanceOf(address account) public view returns (uint)\\n    {\\n        return _token_balances[account];\\n    }\\n\\n    /**\\n     * @dev Get the owner of a token\\n     * @param id The id of token\\n     * @return address The owner of token\\n     */\\n    function ownerOf(uint id) public view returns (address)\\n    {\\n        return _token_owners[id];\\n    }\\n\\n    /**\\n     * @dev Get the url of token info page\\n     * @param id The id of token\\n     * @return string The url of token info page\\n     */\\n    function tokenURI(uint id) public view returns (string memory)\\n    {\\n        if(_isExist(id)) {\\n            return string(abi.encodePacked(_base_uri, id.toString()));\\n        } else {\\n            return \\\"\\\";\\n        }\\n    }\\n\\n    /**\\n     * @dev Get the url of contract info page\\n     * @return string The url of contract info page\\n     */\\n    function contractURI() public view returns (string memory)\\n    {\\n        return _base_uri;\\n    }\\n\\n    /**\\n     * @dev Check whether the given interface is supported by this contract\\n     * @param id The interface id to check\\n     * @return True if the interface is supported\\n     */\\n    function supportsInterface(bytes4 id) external view returns (bool) {\\n        return _supported_interfaces[id];\\n    }\\n\\n    /**\\n     * @dev Get the total number of tokens in existance\\n     * @return uint Number of tokens\\n     */\\n    function totalSupply() public view returns (uint)\\n    {\\n        return _supply;\\n    }\\n\\n    /**\\n     * @dev Get the maximum number of tokens minted\\n     * @return uint Maximum number of tokens\\n     */\\n    function maxSupply() public pure returns (uint)\\n    {\\n        return _max_supply;\\n    }\\n\\n    /**\\n     * @dev Get name of token\\n     * @return string The name\\n     */\\n    function name() public pure returns (string memory)\\n    {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Get symbol of token\\n     * @return string The symbol\\n     */\\n    function symbol() public pure returns (string memory)\\n    {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Check whether the provided address is permitted\\n     * @param account The address to check\\n     * @return bool True if the address is permitted, otherwise false\\n     */\\n    function isPermitted(address account) public view returns (bool)\\n    {\\n        return _permissions[account];\\n    }\\n\\n    /**\\n     * @dev Check whether the token exists\\n     * @param id The id of token\\n     * @return bool True if the token exists, otherwise false\\n     */\\n    function _isExist(uint id) private view returns (bool)\\n    {\\n        return ownerOf(id) != address(0);\\n    }\\n\\n    /**\\n     * @dev Check whether the provided address is the owner of token or a approved address\\n     * @param spender The address to check\\n     * @param id The id of token\\n     * @return bool True if the provided address is the owner of token or a approved address, otherwise false\\n     */\\n    function _isApprovedOrOwner(address spender, uint id) private view returns (bool)\\n    {\\n        address owner = ownerOf(id);\\n        return (spender == owner || getApproved(id) == spender || isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Transfer tokens from one account to another\\n     * @param from The token owner\\n     * @param to The token receiver\\n     * @param id The token id to transfer\\n     * @param data Additional data to add to the transaction\\n     */\\n    function _send(address from, address to, uint id, bytes memory data) private\\n    {\\n        //The token must be owned by the provided address\\n        require(ownerOf(id) == from);\\n\\n        //No point of transferring to zero address\\n        require(!to.isOriginAddress());\\n\\n        //Do nothing with the data\\n        delete data;\\n\\n        //Clear approvals\\n        _token_approvals[id] = address(0);\\n\\n        //Reduce the balance from owner\\n        _token_balances[from] = _token_balances[from].sub(1);\\n\\n        //Increase the balance of receiver\\n        _token_balances[to] = _token_balances[to].add(1);\\n\\n        //Set the new owner\\n        _token_owners[id] = to;\\n\\n        //Emit events\\n        emit Transfer(from, to, id);\\n    }\\n}\"},\"LibAddress.sol\":{\"content\":\"pragma solidity 0.5.10;\\n\\n/**\\n * @title LibAddress \\n * @dev Address related utility functions\\n */\\nlibrary LibAddress\\n{\\n    /**\\n     * @dev Check whether the given address is zero address\\n     * @param account The address to check against\\n     * @return bool True if the given address is zero address\\n     */\\n    function isOriginAddress(address account) internal pure returns (bool)\\n    {\\n        return (account == address(0));\\n    }\\n}\\n\"},\"LibInteger.sol\":{\"content\":\"pragma solidity 0.5.10;\\n\\n/**\\n * @title LibInteger \\n * @dev Integer related utility functions\\n */\\nlibrary LibInteger\\n{    \\n    /**\\n     * @dev Safely multiply, revert on overflow\\n     * @param a The first number\\n     * @param b The second number\\n     * @return uint The answer\\n    */\\n    function mul(uint a, uint b) internal pure returns (uint)\\n    {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint c = a * b;\\n        require(c / a == b);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Safely divide, revert if divisor is zero\\n     * @param a The first number\\n     * @param b The second number\\n     * @return uint The answer\\n    */\\n    function div(uint a, uint b) internal pure returns (uint)\\n    {\\n        require(b \\u003e 0, \\\"\\\");\\n        uint c = a / b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Safely substract, revert if answer is negative\\n     * @param a The first number\\n     * @param b The second number\\n     * @return uint The answer\\n    */\\n    function sub(uint a, uint b) internal pure returns (uint)\\n    {\\n        require(b \\u003c= a, \\\"\\\");\\n        uint c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Safely add, revert if overflow\\n     * @param a The first number\\n     * @param b The second number\\n     * @return uint The answer\\n    */\\n    function add(uint a, uint b) internal pure returns (uint)\\n    {\\n        uint c = a + b;\\n        require(c \\u003e= a, \\\"\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Convert number to string\\n     * @param value The number to convert\\n     * @return string The string representation\\n    */\\n    function toString(uint value) internal pure returns (string memory)\\n    {\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n\\n        uint temp = value;\\n        uint digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n\\n        bytes memory buffer = new bytes(digits);\\n        uint index = digits - 1;\\n        \\n        temp = value;\\n        while (temp != 0) {\\n            buffer[index--] = byte(uint8(48 + temp % 10));\\n            temp /= 10;\\n        }\\n        \\n        return string(buffer);\\n    }\\n}\\n\"}}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"base\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPermitted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"clean\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"move\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"permission\",\"type\":\"bool\"}],\"name\":\"permit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"enable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"disable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]","ContractName":"BlobDefinition","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://46bfacd158a3cc57e80d012440f28a7dbe70e97a8aef448caeb68a2f90740c38"}]}