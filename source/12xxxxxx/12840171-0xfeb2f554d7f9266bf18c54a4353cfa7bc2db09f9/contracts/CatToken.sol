

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

interface IERC20 {
	function totalSupply() external view returns (uint256);
	function balanceOf(address account) external view returns (uint256);
	function transfer(address recipient, uint256 amount) external returns (bool);
	function allowance(address owner, address spender) external view returns (uint256);
	function approve(address spender, uint256 amount) external returns (bool);

	function transferFrom(
		address sender,
		address recipient,
		uint256 amount
	) external returns (bool);

	event Transfer(address indexed from, address indexed to, uint256 value);

}

contract CatToken is ERC721, ERC721Enumerable, ERC721URIStorage, Pausable, Ownable {
    using Counters for Counters.Counter;
    using SafeMath for uint256;
    Counters.Counter private _tokenIdCounter;
    uint256 private _unitCost;
    uint256 private _maxPurchase;
    uint256 private _maxTokens;
    string _folderPath;
    bool _saleComplete;
    address _devAddress;
    
    event CloseSale(address indexed _from);
    event OpenSale(address indexed _from);

    
    constructor(uint256 maxPurchase, uint256 maxTokens) ERC721("TestingTesting", "PCC") {
        _unitCost = 80000000000000000; //initial price - 0.08 ether
        _maxPurchase = maxPurchase;
        _maxTokens = maxTokens;
        _saleComplete = false;
        _devAddress = msg.sender;
        _pause();
        _tokenIdCounter.increment(); //start token generation at 1 not 0
    }

    
    function devMint(address to, uint256 numberToMint) public onlyOwner onSale {
        require(_tokenIdCounter.current() <= _maxTokens, "Sold out!!");
        require(paused(), "Can only dev mint when contract is paused");

        _unpause();

        uint256 i = 0;
        do {
            _safeMint(to, _tokenIdCounter.current());
            _tokenIdCounter.increment();
            i++;
        } while (i < numberToMint && i < _maxPurchase);
        //can only mint a max of whatever the max public purchase is per transaction
        
        pause();
    }

    function pause() public onlyOwner onSale {
        //tokens can only be paused before they are sold out
        _pause();
    }
    
    function startSale(string memory folderPath) public onlyOwner onSale {
        require(paused(), "Sale is already open");
        _folderPath = folderPath;
        _unpause();
        emit OpenSale(msg.sender);
    }

    function setBaseURI(string memory folderPath) public onlyOwner onSale {
        //we can change the base URL only before the sale is closed
        bool pauseState = paused();
        if (pauseState){
            _unpause();
        }
        _folderPath = folderPath;
        
        if (pauseState){
            _pause();
        }
    }
    function _baseURI() internal view override returns (string memory) {
        
        return _folderPath;
    }

    function _beforeTokenTransfer(address from, address to, uint256 tokenId)
        internal
        whenNotPaused
        override(ERC721, ERC721Enumerable)
    {
        super._beforeTokenTransfer(from, to, tokenId);
    }

    function updateUnitPrice(uint256 unitPrice) public onlyOwner {
        _unitCost = unitPrice;
    }

    function mintCats(uint256 numberToMint) public payable {
        require(_tokenIdCounter.current() <= _maxTokens, "Sold out!!");
        require(msg.value == numberToMint.mul(_unitCost), "Incorrect ETH amount");
        require(numberToMint <= _maxPurchase, "Cannot purchase more than max amount");
        
        uint256 i = 0;
        do {
                i++;
               _safeMint(msg.sender, _tokenIdCounter.current());
               _tokenIdCounter.increment();
            } while (i < numberToMint && _tokenIdCounter.current() <= _maxTokens);

            uint256 remaining = numberToMint.sub(i);
            if (remaining > 0){
                //return any overspent funds for the last buyer
                payable(msg.sender).transfer(remaining.mul(_unitCost));
            }
    }
    
    function _burn(uint256 tokenId) internal override(ERC721, ERC721URIStorage) {
        super._burn(tokenId);
    }

    function tokenURI(uint256 tokenId)
        public
        view
        override(ERC721, ERC721URIStorage)
        returns (string memory)
    {
        return super.tokenURI(tokenId);
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(ERC721, ERC721Enumerable)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }
    
	
	function withdraw() public onlyOwner {
		uint256 balance = address(this).balance;
		uint256 dev_cut = balance.div(10);
		payable(msg.sender).transfer(balance.sub(dev_cut));
		payable(_devAddress).transfer(dev_cut);
	}


	function withdrawTokens(IERC20 token) public onlyOwner {
		require(address(token) != address(0));
		uint256 balance = token.balanceOf(address(this));
		token.transfer(msg.sender, balance);
	}
	
	function endSale() public onlyOwner onSale {
	    require(!paused(), "cannot close sale whilst paused");
	    require(_maxTokens == totalSupply(), "cannot close sale before it's sold out");
	    // once this action is completed the base URI cannot be changed 
	    // and contract cannot be paused.
	    _saleComplete = true;
	    emit CloseSale(msg.sender);
	}
	
	function unitCost() public view returns(uint256) {
	    return _unitCost;
	}
	
	modifier onSale() {
        require(!_saleComplete, "Sale closed. Action cannot be completed");
        _;
    }
}
