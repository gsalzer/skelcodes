{"status":"1","message":"OK","result":[{"SourceCode":"// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/CounterstakeLibrary.sol\r\n\r\npragma solidity ^0.8.3;\r\n\r\n\r\n// The purpose of the library is to separate some of the code out of the Export/Import contracts and keep their sizes under the 24KiB limit\r\n\r\n\r\nlibrary CounterstakeLibrary {\r\n\r\n\tenum Side {no, yes}\r\n\r\n\t// small values (bool, uint32, ...) are grouped together in order to be packed efficiently\r\n\tstruct Claim {\r\n\t\tuint amount;\r\n\t//\tint reward;\r\n\r\n\t\taddress payable recipient_address; // 20 bytes, 12 bytes left\r\n\t\tuint32 txts;\r\n\t\tuint32 ts;\r\n\t\t\r\n\t\taddress payable claimant_address;\r\n\t\tuint32 expiry_ts;\r\n\t\tuint16 period_number;\r\n\t\tSide current_outcome;\r\n\t\tbool is_large;\r\n\t\tbool withdrawn;\r\n\t\tbool finished;\r\n\t\t\r\n\t\tstring sender_address;\r\n\t//\tstring txid;\r\n\t\tstring data;\r\n\t\tuint yes_stake;\r\n\t\tuint no_stake;\r\n\t//\tuint challenging_target;\r\n\t}\r\n\r\n\tstruct Settings {\r\n\t\taddress tokenAddress;\r\n\t\tuint16 ratio100;// = 100;\r\n\t\tuint16 counterstake_coef100;// = 150;\r\n\t\tuint32 min_tx_age;\r\n\t\tuint min_stake;\r\n\t\tuint[] challenging_periods;// = [12 hours, 3 days, 1 weeks, 30 days];\r\n\t\tuint[] large_challenging_periods;// = [3 days, 1 weeks, 30 days];\r\n\t\tuint large_threshold;\r\n\t}\r\n\r\n\tevent NewClaim(uint indexed claim_num, address author_address, string sender_address, address recipient_address, string txid, uint32 txts, uint amount, int reward, uint stake, string data, uint32 expiry_ts);\r\n\tevent NewChallenge(uint indexed claim_num, address author_address, uint stake, Side outcome, Side current_outcome, uint yes_stake, uint no_stake, uint32 expiry_ts, uint challenging_target);\r\n\tevent FinishedClaim(uint indexed claim_num, Side outcome);\r\n\r\n\r\n\tstruct ClaimRequest {\r\n\t\tstring txid;\r\n\t\tuint32 txts;\r\n\t\tuint amount;\r\n\t\tint reward;\r\n\t\tuint stake;\r\n\t\tuint required_stake;\r\n\t\taddress payable recipient_address;\r\n\t\tstring sender_address;\r\n\t\tstring data;\r\n\t}\r\n\r\n\tfunction claim(\r\n\t\tSettings storage settings,\r\n\t\tmapping(string => uint) storage claim_nums,\r\n\t\tmapping(uint => Claim) storage claims,\r\n\t\tmapping(uint => mapping(Side => mapping(address => uint))) storage stakes,\r\n\t\tuint claim_num,\r\n\t\tClaimRequest memory req\r\n\t) external {\r\n\t\trequire(req.amount > 0, \"0 claim\");\r\n\t\trequire(req.stake >= req.required_stake, \"the stake is too small\");\r\n\t\trequire(block.timestamp >= req.txts + settings.min_tx_age, \"too early\");\r\n\t\tif (req.recipient_address == address(0))\r\n\t\t\treq.recipient_address = payable(msg.sender);\r\n\t\tif (req.reward < 0)\r\n\t\t\trequire(req.recipient_address == payable(msg.sender), \"the sender disallowed third-party claiming by setting a negative reward\");\r\n\t\tstring memory claim_id = getClaimId(req.sender_address, req.recipient_address, req.txid, req.txts, req.amount, req.reward, req.data);\r\n\t\trequire(claim_nums[claim_id] == 0, \"this transfer has already been claimed\");\r\n\t\tbool is_large = (settings.large_threshold > 0 && req.stake >= settings.large_threshold);\r\n\t\tuint32 expiry_ts = uint32(block.timestamp + getChallengingPeriod(settings, 0, is_large)); // might wrap\r\n\t\tclaim_nums[claim_id] = claim_num;\r\n\t//\tuint challenging_target = req.stake * settings.counterstake_coef100/100;\r\n\t\tclaims[claim_num] = Claim({\r\n\t\t\tamount: req.amount,\r\n\t\t//\treward: req.reward,\r\n\t\t\trecipient_address: req.recipient_address,\r\n\t\t\tclaimant_address: payable(msg.sender),\r\n\t\t\tsender_address: req.sender_address,\r\n\t\t//\ttxid: req.txid,\r\n\t\t\tdata: req.data,\r\n\t\t\tyes_stake: req.stake,\r\n\t\t\tno_stake: 0,\r\n\t\t\tcurrent_outcome: Side.yes,\r\n\t\t\tis_large: is_large,\r\n\t\t\tperiod_number: 0,\r\n\t\t\ttxts: req.txts,\r\n\t\t\tts: uint32(block.timestamp),\r\n\t\t\texpiry_ts: expiry_ts,\r\n\t\t//\tchallenging_target: req.stake * settings.counterstake_coef100/100,\r\n\t\t\twithdrawn: false,\r\n\t\t\tfinished: false\r\n\t\t});\r\n\t\tstakes[claim_num][Side.yes][msg.sender] = req.stake;\r\n\t\temit NewClaim(claim_num, msg.sender, req.sender_address, req.recipient_address, req.txid, req.txts, req.amount, req.reward, req.stake, req.data, expiry_ts);\r\n\t//\treturn claim_id;\r\n\t}\r\n\r\n\r\n\tfunction challenge(\r\n\t\tSettings storage settings, \r\n\t\tClaim storage c,\r\n\t\tmapping(uint => mapping(Side => mapping(address => uint))) storage stakes, \r\n\t\tuint claim_num, \r\n\t\tSide stake_on, \r\n\t\tuint stake\r\n\t) external {\r\n\t\trequire(block.timestamp < c.expiry_ts, \"the challenging period has expired\");\r\n\t\trequire(stake_on != c.current_outcome, \"this outcome is already current\");\r\n\t\tuint excess;\r\n\t\tuint challenging_target = (c.current_outcome == Side.yes ? c.yes_stake : c.no_stake) * settings.counterstake_coef100/100;\r\n\t\t{ // circumvent stack too deep\r\n\t\t\tuint stake_on_proposed_outcome = (stake_on == Side.yes ? c.yes_stake : c.no_stake) + stake;\r\n\t\t\tbool would_override_current_outcome = stake_on_proposed_outcome >= challenging_target;\r\n\t\t\texcess = would_override_current_outcome ? stake_on_proposed_outcome - challenging_target : 0;\r\n\t\t\tuint accepted_stake = stake - excess;\r\n\t\t\tif (stake_on == Side.yes)\r\n\t\t\t\tc.yes_stake += accepted_stake;\r\n\t\t\telse\r\n\t\t\t\tc.no_stake += accepted_stake;\r\n\t\t\tif (would_override_current_outcome){\r\n\t\t\t\tc.period_number++;\r\n\t\t\t\tc.current_outcome = stake_on;\r\n\t\t\t\tc.expiry_ts = uint32(block.timestamp + getChallengingPeriod(settings, c.period_number, c.is_large));\r\n\t\t\t\tchallenging_target = challenging_target * settings.counterstake_coef100/100;\r\n\t\t\t}\r\n\t\t\tstakes[claim_num][stake_on][msg.sender] += accepted_stake;\r\n\t\t}\r\n\t\temit NewChallenge(claim_num, msg.sender, stake, stake_on, c.current_outcome, c.yes_stake, c.no_stake, c.expiry_ts, challenging_target);\r\n\t\tif (excess > 0){\r\n\t\t\tif (settings.tokenAddress == address(0))\r\n\t\t\t\tpayable(msg.sender).transfer(excess);\r\n\t\t\telse\r\n\t\t\t\trequire(IERC20(settings.tokenAddress).transfer(msg.sender, excess), \"failed to transfer the token\");\r\n\t\t}\r\n\t}\r\n\r\n\r\n\r\n\tfunction finish(\r\n\t\tClaim storage c,\r\n\t\tmapping(uint => mapping(Side => mapping(address => uint))) storage stakes, \r\n\t\tuint claim_num, \r\n\t\taddress payable to_address\r\n\t) external \r\n\treturns (bool, bool, uint)\r\n\t{\r\n\t\trequire(block.timestamp > c.expiry_ts, \"challenging period is still ongoing\");\r\n\t\tif (to_address == address(0))\r\n\t\t\tto_address = payable(msg.sender);\r\n\t\t\r\n\t\tbool is_winning_claimant = (to_address == c.claimant_address && c.current_outcome == Side.yes);\r\n\t\trequire(!(is_winning_claimant && c.withdrawn), \"already withdrawn\");\r\n\t\tuint won_stake;\r\n\t\t{ // circumvent stack too deep\r\n\t\t\tuint my_stake = stakes[claim_num][c.current_outcome][to_address];\r\n\t\t\trequire(my_stake > 0 || is_winning_claimant, \"you are not the recipient and you didn't stake on the winning outcome or you have already withdrawn\");\r\n\t\t\tuint winning_stake = c.current_outcome == Side.yes ? c.yes_stake : c.no_stake;\r\n\t\t\tif (my_stake > 0)\r\n\t\t\t\twon_stake = (c.yes_stake + c.no_stake) * my_stake / winning_stake;\r\n\t\t}\r\n\t\tif (is_winning_claimant)\r\n\t\t\tc.withdrawn = true;\r\n\t\tbool finished;\r\n\t\tif (!c.finished){\r\n\t\t\tfinished = true;\r\n\t\t\tc.finished = true;\r\n\t\t//\tSide losing_outcome = outcome == Side.yes ? Side.no : Side.yes;\r\n\t\t//\tdelete stakes[claim_id][losing_outcome]; // can't purge the stakes that will never be claimed\r\n\t\t\temit FinishedClaim(claim_num, c.current_outcome);\r\n\t\t}\r\n\t\tdelete stakes[claim_num][c.current_outcome][to_address];\r\n\t\treturn (finished, is_winning_claimant, won_stake);\r\n\t}\r\n\r\n\r\n\r\n\tfunction getChallengingPeriod(Settings storage settings, uint16 period_number, bool bLarge) public view returns (uint) {\r\n\t\tuint[] storage periods = bLarge ? settings.large_challenging_periods : settings.challenging_periods;\r\n\t\tif (period_number > periods.length - 1)\r\n\t\t\tperiod_number = uint16(periods.length - 1);\r\n\t\treturn periods[period_number];\r\n\t}\r\n\r\n\tfunction validateChallengingPeriods(uint[] memory periods) pure external {\r\n\t\trequire(periods.length > 0, \"empty periods\");\r\n\t\tuint prev_period = 0;\r\n\t\tfor (uint i = 0; i < periods.length; i++) {\r\n\t\t\trequire(periods[i] < 3 * 365 days, \"some periods are longer than 3 years\");\r\n\t\t\trequire(periods[i] >= prev_period, \"subsequent periods cannot get shorter\");\r\n\t\t\tprev_period = periods[i];\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getClaimId(string memory sender_address, address recipient_address, string memory txid, uint32 txts, uint amount, int reward, string memory data) public pure returns (string memory){\r\n\t\treturn string(abi.encodePacked(sender_address, '_', toAsciiString(recipient_address), '_', txid, '_', uint2str(txts), '_', uint2str(amount), '_', int2str(reward), '_', data));\r\n\t}\r\n\r\n\r\n\tfunction uint2str(uint256 _i) private pure returns (string memory) {\r\n\t\tif (_i == 0)\r\n\t\t\treturn \"0\";\r\n\t\tuint256 j = _i;\r\n\t\tuint256 length;\r\n\t\twhile (j != 0) {\r\n\t\t\tlength++;\r\n\t\t\tj /= 10;\r\n\t\t}\r\n\t\tbytes memory bstr = new bytes(length);\r\n\t\tuint256 k = length;\r\n\t\tj = _i;\r\n\t\twhile (j != 0) {\r\n\t\t\tbstr[--k] = bytes1(uint8(48 + j % 10));\r\n\t\t\tj /= 10;\r\n\t\t}\r\n\t\treturn string(bstr);\r\n\t}\r\n\r\n\tfunction int2str(int256 _i) private pure returns (string memory) {\r\n\t\trequire(_i < type(int).max, \"int too large\");\r\n\t\treturn _i >= 0 ? uint2str(uint(_i)) : string(abi.encodePacked('-', uint2str(uint(-_i))));\r\n\t}\r\n\r\n\tfunction toAsciiString(address x) private pure returns (string memory) {\r\n\t\tbytes memory s = new bytes(40);\r\n\t\tfor (uint i = 0; i < 20; i++) {\r\n\t\t\tbytes1 b = bytes1(uint8(uint(uint160(x)) / (2**(8*(19 - i)))));\r\n\t\t\tbytes1 hi = bytes1(uint8(b) / 16);\r\n\t\t\tbytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\r\n\t\t\ts[2*i] = char(hi);\r\n\t\t\ts[2*i+1] = char(lo);            \r\n\t\t}\r\n\t\treturn string(s);\r\n\t}\r\n\r\n\tfunction char(bytes1 b) private pure returns (bytes1 c) {\r\n\t\tif (uint8(b) < 10) return bytes1(uint8(b) + 0x30);\r\n\t\telse return bytes1(uint8(b) + 0x57);\r\n\t}\r\n\r\n\tfunction isContract(address _addr) public view returns (bool){\r\n\t\tuint32 size;\r\n\t\tassembly {\r\n\t\t\tsize := extcodesize(_addr)\r\n\t\t}\r\n\t\treturn (size > 0);\r\n\t}\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"claim_num\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum CounterstakeLibrary.Side\",\"name\":\"outcome\",\"type\":\"uint8\"}],\"name\":\"FinishedClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"claim_num\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"author_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum CounterstakeLibrary.Side\",\"name\":\"outcome\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"enum CounterstakeLibrary.Side\",\"name\":\"current_outcome\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"yes_stake\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"no_stake\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"expiry_ts\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"challenging_target\",\"type\":\"uint256\"}],\"name\":\"NewChallenge\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"claim_num\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"author_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"sender_address\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"txid\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"txts\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"reward\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"data\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"expiry_ts\",\"type\":\"uint32\"}],\"name\":\"NewClaim\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"sender_address\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"recipient_address\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"txid\",\"type\":\"string\"},{\"internalType\":\"uint32\",\"name\":\"txts\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"reward\",\"type\":\"int256\"},{\"internalType\":\"string\",\"name\":\"data\",\"type\":\"string\"}],\"name\":\"getClaimId\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"periods\",\"type\":\"uint256[]\"}],\"name\":\"validateChallengingPeriods\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"CounterstakeLibrary","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://8eedcf125db0e727098f525441afffa55d8db17d0db6d08ea31750a4d017d825"}]}