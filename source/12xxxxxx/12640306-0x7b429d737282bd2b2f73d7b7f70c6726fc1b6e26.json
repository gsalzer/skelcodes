{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity =0.7.6;\r\npragma abicoder v2;\r\n\r\n\r\ncontract IndexedStakingLens {\r\n  struct StakingPool {\r\n    uint256 pid;\r\n    address stakingToken;\r\n    bool isPairToken;\r\n    address token0;\r\n    address token1;\r\n    uint256 amountStaked;\r\n    uint256 ndxPerDay;\r\n    string symbol;\r\n  }\r\n\r\n  // Assume 13.5 sec per block\r\n  uint256 internal constant BLOCKS_PER_DAY = 864000 / 135;\r\n  IMultiTokenStaking public constant stakingContract = IMultiTokenStaking(0xC46E0E7eCb3EfCC417f6F89b940FFAFf72556382);\r\n\r\n  function getPool(\r\n    uint256 i,\r\n    uint256 totalAllocPoint,\r\n    uint256 totalNdxPerDay\r\n  ) internal view returns (StakingPool memory pool) {\r\n    pool.pid = i;\r\n    pool.stakingToken = stakingContract.lpToken(i);\r\n    IUniswapV2Pair poolAsPair = IUniswapV2Pair(pool.stakingToken);\r\n    try poolAsPair.getReserves() returns (uint112, uint112, uint32) {\r\n      pool.isPairToken = true;\r\n      pool.token0 = poolAsPair.token0();\r\n      pool.token1 = poolAsPair.token1();\r\n      pool.symbol = string(abi.encodePacked(\r\n        SymbolHelper.getSymbol(pool.token0),\r\n        \"/\",\r\n        SymbolHelper.getSymbol(pool.token1)\r\n      ));\r\n    } catch {\r\n      pool.symbol = SymbolHelper.getSymbol(pool.stakingToken);\r\n    }\r\n    pool.amountStaked = IERC20(pool.stakingToken).balanceOf(address(stakingContract));\r\n    pool.ndxPerDay = (stakingContract.poolInfo(i).allocPoint * totalNdxPerDay) / totalAllocPoint;\r\n  }\r\n\r\n  function getPools() external view returns (StakingPool[] memory arr) {\r\n    uint256 len = stakingContract.poolLength();\r\n    arr = new StakingPool[](len);\r\n    uint256 totalAllocPoint = stakingContract.totalAllocPoint();\r\n    uint256 totalNdxPerDay = stakingContract.rewardsSchedule().getRewardsForBlockRange(block.number, block.number + BLOCKS_PER_DAY);\r\n    for (uint256 i; i < len; i++) {\r\n      arr[i] = getPool(i, totalAllocPoint, totalNdxPerDay);\r\n    }\r\n  }\r\n}\r\n\r\n\r\nlibrary SymbolHelper {\r\n\r\n  /**\r\n   * @dev Returns the index of the lowest bit set in `self`.\r\n   * Note: Requires that `self != 0`\r\n   */\r\n  function lowestBitSet(uint256 self) internal pure returns (uint256 _z) {\r\n    require (self > 0, \"Bits::lowestBitSet: Value 0 has no bits set\");\r\n    uint256 _magic = 0x00818283848586878898a8b8c8d8e8f929395969799a9b9d9e9faaeb6bedeeff;\r\n    uint256 val = (self & -self) * _magic >> 248;\r\n    uint256 _y = val >> 5;\r\n    _z = (\r\n      _y < 4\r\n        ? _y < 2\r\n          ? _y == 0\r\n            ? 0x753a6d1b65325d0c552a4d1345224105391a310b29122104190a110309020100\r\n            : 0xc976c13bb96e881cb166a933a55e490d9d56952b8d4e801485467d2362422606\r\n          : _y == 2\r\n            ? 0xe39ed557db96902cd38ed14fad815115c786af479b7e83247363534337271707\r\n            : 0xf7cae577eec2a03cf3bad76fb589591debb2dd67e0aa9834bea6925f6a4a2e0e\r\n        : _y < 6\r\n          ? _y == 4\r\n            ? 0xc8c0b887b0a8a4489c948c7f847c6125746c645c544c444038302820181008ff\r\n            : 0xf6e4ed9ff2d6b458eadcdf97bd91692de2d4da8fd2d0ac50c6ae9a8272523616\r\n          : _y == 6\r\n            ? 0xf5ecf1b3e9debc68e1d9cfabc5997135bfb7a7a3938b7b606b5b4b3f2f1f0ffe\r\n            : 0xf8f9cbfae6cc78fbefe7cdc3a1793dfcf4f0e8bbd8cec470b6a28a7a5a3e1efd\r\n    );\r\n    _z >>= (val & 0x1f) << 3;\r\n    return _z & 0xff;\r\n  }\r\n\r\n  function getSymbol(address token) internal view returns (string memory) {\r\n    (bool success, bytes memory data) = token.staticcall(abi.encodeWithSignature(\"symbol()\"));\r\n    if (!success) return \"UNKNOWN\";\r\n    if (data.length != 32) return abi.decode(data, (string));\r\n    uint256 symbol = abi.decode(data, (uint256));\r\n    if (symbol == 0) return \"UNKNOWN\";\r\n    uint256 emptyBits = 255 - lowestBitSet(symbol);\r\n    uint256 size = (emptyBits / 8) + (emptyBits % 8 > 0 ? 1 : 0);\r\n    assembly { mstore(data, size) }\r\n    return string(data);\r\n  }\r\n}\r\n\r\n\r\ninterface IMultiTokenStaking {\r\n  struct PoolInfo {\r\n    uint128 accRewardsPerShare;\r\n    uint64 lastRewardBlock;\r\n    uint64 allocPoint;\r\n  }\r\n\r\n  function poolLength() external view returns (uint256);\r\n\r\n  function lpToken(uint256) external view returns (address);\r\n\r\n  function poolInfo(uint256) external view returns (PoolInfo memory);\r\n\r\n  function totalAllocPoint() external view returns (uint256);\r\n\r\n  function rewardsSchedule() external view returns (IRewardsSchedule);\r\n}\r\n\r\ninterface IRewardsSchedule {\r\n  function getRewardsForBlockRange(uint256 from, uint256 to) external view returns (uint256);\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n  function token0() external view returns (address);\r\n\r\n  function token1() external view returns (address);\r\n\r\n  function getReserves()\r\n    external\r\n    view\r\n    returns (\r\n      uint112 reserve0,\r\n      uint112 reserve1,\r\n      uint32 blockTimestampLast\r\n    );\r\n}\r\n\r\ninterface IERC20 {\r\n  function balanceOf(address) external view returns (uint256);\r\n}","ABI":"[{\"inputs\":[],\"name\":\"getPools\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"stakingToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isPairToken\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ndxPerDay\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"internalType\":\"struct IndexedStakingLens.StakingPool[]\",\"name\":\"arr\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingContract\",\"outputs\":[{\"internalType\":\"contract IMultiTokenStaking\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"IndexedStakingLens","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://c354f2167b17d7b79a57afed4ca3ec05abab916442aee451831846d1c97b2c15"}]}