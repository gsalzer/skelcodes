{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.2.12\r\n\"\"\"\r\n@title Curve CryptoSwap Deposit Zap\r\n@author Curve.Fi\r\n@license Copyright (c) Curve.Fi, 2020 - all rights reserved\r\n@dev Wraps / unwraps Ether, and redirects deposits / withdrawals\r\n\"\"\"\r\n\r\nfrom vyper.interfaces import ERC20\r\n\r\ninterface CurveCryptoSwap:\r\n    def add_liquidity(amounts: uint256[N_COINS], min_mint_amount: uint256): nonpayable\r\n    def remove_liquidity(_amount: uint256, min_amounts: uint256[N_COINS]): nonpayable\r\n    def remove_liquidity_one_coin(token_amount: uint256, i: uint256, min_amount: uint256): nonpayable\r\n    def token() -> address: view\r\n    def coins(i: uint256) -> address: view\r\n\r\ninterface wETH:\r\n    def deposit(): payable\r\n    def withdraw(_amount: uint256): nonpayable\r\n\r\n\r\nN_COINS: constant(uint256) = 3\r\nWETH_IDX: constant(uint256) = N_COINS - 1\r\nWETH: constant(address) = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\r\n\r\npool: public(address)\r\ntoken: public(address)\r\ncoins: public(address[N_COINS])\r\n\r\n\r\n@payable\r\n@external\r\ndef __default__():\r\n    assert msg.sender == WETH\r\n\r\n\r\n@external\r\ndef __init__(_pool: address):\r\n    \"\"\"\r\n    @notice Contract constructor\r\n    @param _pool `CurveCryptoSwap` deployment to target\r\n    \"\"\"\r\n    self.pool = _pool\r\n    self.token = CurveCryptoSwap(_pool).token()\r\n\r\n    for i in range(N_COINS):\r\n        coin: address = CurveCryptoSwap(_pool).coins(i)\r\n        response: Bytes[32] = raw_call(\r\n            coin,\r\n            concat(\r\n                method_id(\"approve(address,uint256)\"),\r\n                convert(_pool, bytes32),\r\n                convert(MAX_UINT256, bytes32)\r\n            ),\r\n            max_outsize=32\r\n        )\r\n        if len(response) > 0:\r\n            assert convert(response, bool)  # dev: bad response\r\n        self.coins[i] = coin\r\n\r\n    assert self.coins[WETH_IDX] == WETH\r\n\r\n\r\n@payable\r\n@external\r\ndef add_liquidity(\r\n    _amounts: uint256[N_COINS],\r\n    _min_mint_amount: uint256,\r\n    _receiver: address = msg.sender\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Add liquidity and wrap Ether to wETH\r\n    @param _amounts Amount of each token to deposit. `msg.value` must be\r\n                    equal to the given amount of Ether.\r\n    @param _min_mint_amount Minimum amount of LP token to receive\r\n    @param _receiver Receiver of the LP tokens\r\n    @return Amount of LP tokens received\r\n    \"\"\"\r\n    assert msg.value == _amounts[WETH_IDX]\r\n    wETH(WETH).deposit(value=msg.value)\r\n\r\n    for i in range(N_COINS-1):\r\n        if _amounts[i] > 0:\r\n            response: Bytes[32] = raw_call(\r\n                self.coins[i],\r\n                concat(\r\n                    method_id(\"transferFrom(address,address,uint256)\"),\r\n                    convert(msg.sender, bytes32),\r\n                    convert(self, bytes32),\r\n                    convert(_amounts[i], bytes32)\r\n                ),\r\n                max_outsize=32\r\n            )\r\n            if len(response) > 0:\r\n                assert convert(response, bool)  # dev: bad response\r\n\r\n    CurveCryptoSwap(self.pool).add_liquidity(_amounts, _min_mint_amount)\r\n    token: address = self.token\r\n    amount: uint256 = ERC20(token).balanceOf(self)\r\n    response: Bytes[32] = raw_call(\r\n        token,\r\n        concat(\r\n            method_id(\"transfer(address,uint256)\"),\r\n            convert(_receiver, bytes32),\r\n            convert(amount, bytes32)\r\n        ),\r\n        max_outsize=32\r\n    )\r\n    if len(response) > 0:\r\n        assert convert(response, bool)  # dev: bad response\r\n\r\n    return amount\r\n\r\n\r\n@external\r\ndef remove_liquidity(\r\n    _amount: uint256,\r\n    _min_amounts: uint256[N_COINS],\r\n    _receiver: address = msg.sender\r\n) -> uint256[N_COINS]:\r\n    \"\"\"\r\n    @notice Withdraw coins from the pool, unwrapping wETH to Ether\r\n    @dev Withdrawal amounts are based on current deposit ratios\r\n    @param _amount Quantity of LP tokens to burn in the withdrawal\r\n    @param _min_amounts Minimum amounts of coins to receive\r\n    @param _receiver Receiver of the withdrawn tokens\r\n    @return Amounts of coins that were withdrawn\r\n    \"\"\"\r\n    ERC20(self.token).transferFrom(msg.sender, self, _amount)\r\n    CurveCryptoSwap(self.pool).remove_liquidity(_amount, _min_amounts)\r\n\r\n    amounts: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    for i in range(N_COINS-1):\r\n        coin: address = self.coins[i]\r\n        amounts[i] = ERC20(coin).balanceOf(self)\r\n        response: Bytes[32] = raw_call(\r\n            coin,\r\n            concat(\r\n                method_id(\"transfer(address,uint256)\"),\r\n                convert(_receiver, bytes32),\r\n                convert(amounts[i], bytes32)\r\n            ),\r\n            max_outsize=32\r\n        )\r\n        if len(response) > 0:\r\n            assert convert(response, bool)  # dev: bad response\r\n\r\n    amounts[WETH_IDX] = ERC20(WETH).balanceOf(self)\r\n    wETH(WETH).withdraw(amounts[WETH_IDX])\r\n    raw_call(_receiver, b\"\", value=self.balance)\r\n\r\n    return amounts\r\n\r\n\r\n@external\r\ndef remove_liquidity_one_coin(\r\n    _token_amount: uint256,\r\n    i: uint256,\r\n    _min_amount: uint256,\r\n    _receiver: address = msg.sender\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Withdraw a single coin from the pool, unwrapping wETH to Ether\r\n    @param _token_amount Amount of LP tokens to burn in the withdrawal\r\n    @param i Index value of the coin to withdraw\r\n    @param _min_amount Minimum amount of coin to receive\r\n    @param _receiver Receiver of the withdrawn token\r\n    @return Amount of underlying coin received\r\n    \"\"\"\r\n    ERC20(self.token).transferFrom(msg.sender, self, _token_amount)\r\n    CurveCryptoSwap(self.pool).remove_liquidity_one_coin(_token_amount, i, _min_amount)\r\n\r\n    coin: address = self.coins[i]\r\n    amount: uint256 = ERC20(coin).balanceOf(self)\r\n    if i == WETH_IDX:\r\n        wETH(WETH).withdraw(amount)\r\n        raw_call(_receiver, b\"\", value=self.balance)\r\n    else:\r\n        response: Bytes[32] = raw_call(\r\n            coin,\r\n            concat(\r\n                method_id(\"transfer(address,uint256)\"),\r\n                convert(_receiver, bytes32),\r\n                convert(amount, bytes32)\r\n            ),\r\n            max_outsize=32\r\n        )\r\n        if len(response) > 0:\r\n            assert convert(response, bool)  # dev: bad response\r\n    return amount","ABI":"[{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"add_liquidity\",\"inputs\":[{\"name\":\"_amounts\",\"type\":\"uint256[3]\"},{\"name\":\"_min_mint_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"add_liquidity\",\"inputs\":[{\"name\":\"_amounts\",\"type\":\"uint256[3]\"},{\"name\":\"_min_mint_amount\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity\",\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_min_amounts\",\"type\":\"uint256[3]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[3]\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity\",\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_min_amounts\",\"type\":\"uint256[3]\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[3]\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity_one_coin\",\"inputs\":[{\"name\":\"_token_amount\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"_min_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity_one_coin\",\"inputs\":[{\"name\":\"_token_amount\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"_min_amount\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"pool\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2568},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"token\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2598},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"coins\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2737}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.12","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"00000000000000000000000080466c64868e1ab14a1ddf27a676c3fcbe638fe5","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}