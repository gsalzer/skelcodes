{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n    ___            _       ___  _                          \r\n    | .\\ ___  _ _ <_> ___ | __><_>._ _  ___ ._ _  ___  ___ \r\n    |  _// ._>| '_>| ||___|| _> | || ' |<_> || ' |/ | '/ ._>\r\n    |_|  \\___.|_|  |_|     |_|  |_||_|_|<___||_|_|\\_|_.\\___.\r\n    \r\n* PeriFinance: PeriFinance.sol\r\n*\r\n* Latest source (may be newer): https://github.com/PeriFinance/periFinance/blob/master/contracts/PeriFinance.sol\r\n* Docs: Will be added in the future. /contracts/PeriFinance\r\n*\r\n* Contract Dependencies: \r\n*\t- BasePeriFinance\r\n*\t- ExternStateToken\r\n*\t- IAddressResolver\r\n*\t- IERC20\r\n*\t- IPeriFinance\r\n*\t- MixinResolver\r\n*\t- Owned\r\n*\t- Proxyable\r\n*\t- State\r\n* Libraries: \r\n*\t- SafeDecimalMath\r\n*\t- SafeMath\r\n*\t- VestingEntries\r\n*\r\n* MIT License\r\n* ===========\r\n*\r\n* Copyright (c) 2021 PeriFinance\r\n*\r\n* Permission is hereby granted, free of charge, to any person obtaining a copy\r\n* of this software and associated documentation files (the \"Software\"), to deal\r\n* in the Software without restriction, including without limitation the rights\r\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n* copies of the Software, and to permit persons to whom the Software is\r\n* furnished to do so, subject to the following conditions:\r\n*\r\n* The above copyright notice and this permission notice shall be included in all\r\n* copies or substantial portions of the Software.\r\n*\r\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n*/\r\n\r\n\r\n\r\npragma solidity >=0.4.24;\r\n\r\n// https://docs.peri.finance/contracts/source/interfaces/ierc20\r\ninterface IERC20 {\r\n    // ERC20 Optional Views\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    // Views\r\n    function totalSupply() external view returns (uint);\r\n\r\n    function balanceOf(address owner) external view returns (uint);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    // Mutative functions\r\n    function transfer(address to, uint value) external returns (bool);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint value\r\n    ) external returns (bool);\r\n\r\n    // Events\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n\r\n// https://docs.peri.finance/contracts/source/contracts/owned\r\ncontract Owned {\r\n    address public owner;\r\n    address public nominatedOwner;\r\n\r\n    constructor(address _owner) public {\r\n        require(_owner != address(0), \"Owner address cannot be 0\");\r\n        owner = _owner;\r\n        emit OwnerChanged(address(0), _owner);\r\n    }\r\n\r\n    function nominateNewOwner(address _owner) external onlyOwner {\r\n        nominatedOwner = _owner;\r\n        emit OwnerNominated(_owner);\r\n    }\r\n\r\n    function acceptOwnership() external {\r\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\r\n        emit OwnerChanged(owner, nominatedOwner);\r\n        owner = nominatedOwner;\r\n        nominatedOwner = address(0);\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        _onlyOwner();\r\n        _;\r\n    }\r\n\r\n    function _onlyOwner() private view {\r\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\r\n    }\r\n\r\n    event OwnerNominated(address newOwner);\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n}\r\n\r\n\r\n// Inheritance\r\n\r\n\r\n// Internal references\r\n\r\n\r\n// https://docs.peri.finance/contracts/source/contracts/proxy\r\ncontract Proxy is Owned {\r\n    Proxyable public target;\r\n\r\n    constructor(address _owner) public Owned(_owner) {}\r\n\r\n    function setTarget(Proxyable _target) external onlyOwner {\r\n        target = _target;\r\n        emit TargetUpdated(_target);\r\n    }\r\n\r\n    function _emit(\r\n        bytes calldata callData,\r\n        uint numTopics,\r\n        bytes32 topic1,\r\n        bytes32 topic2,\r\n        bytes32 topic3,\r\n        bytes32 topic4\r\n    ) external onlyTarget {\r\n        uint size = callData.length;\r\n        bytes memory _callData = callData;\r\n\r\n        assembly {\r\n            /* The first 32 bytes of callData contain its length (as specified by the abi).\r\n             * Length is assumed to be a uint256 and therefore maximum of 32 bytes\r\n             * in length. It is also leftpadded to be a multiple of 32 bytes.\r\n             * This means moving call_data across 32 bytes guarantees we correctly access\r\n             * the data itself. */\r\n            switch numTopics\r\n                case 0 {\r\n                    log0(add(_callData, 32), size)\r\n                }\r\n                case 1 {\r\n                    log1(add(_callData, 32), size, topic1)\r\n                }\r\n                case 2 {\r\n                    log2(add(_callData, 32), size, topic1, topic2)\r\n                }\r\n                case 3 {\r\n                    log3(add(_callData, 32), size, topic1, topic2, topic3)\r\n                }\r\n                case 4 {\r\n                    log4(add(_callData, 32), size, topic1, topic2, topic3, topic4)\r\n                }\r\n        }\r\n    }\r\n\r\n    // solhint-disable no-complex-fallback\r\n    function() external payable {\r\n        // Mutable call setting Proxyable.messageSender as this is using call not delegatecall\r\n        target.setMessageSender(msg.sender);\r\n\r\n        assembly {\r\n            let free_ptr := mload(0x40)\r\n            calldatacopy(free_ptr, 0, calldatasize)\r\n\r\n            /* We must explicitly forward ether to the underlying contract as well. */\r\n            let result := call(gas, sload(target_slot), callvalue, free_ptr, calldatasize, 0, 0)\r\n            returndatacopy(free_ptr, 0, returndatasize)\r\n\r\n            if iszero(result) {\r\n                revert(free_ptr, returndatasize)\r\n            }\r\n            return(free_ptr, returndatasize)\r\n        }\r\n    }\r\n\r\n    modifier onlyTarget {\r\n        require(Proxyable(msg.sender) == target, \"Must be proxy target\");\r\n        _;\r\n    }\r\n\r\n    event TargetUpdated(Proxyable newTarget);\r\n}\r\n\r\n\r\n// Inheritance\r\n\r\n\r\n// Internal references\r\n\r\n\r\n// https://docs.peri.finance/contracts/source/contracts/proxyable\r\ncontract Proxyable is Owned {\r\n    // This contract should be treated like an abstract contract\r\n\r\n    /* The proxy this contract exists behind. */\r\n    Proxy public proxy;\r\n    Proxy public integrationProxy;\r\n\r\n    /* The caller of the proxy, passed through to this contract.\r\n     * Note that every function using this member must apply the onlyProxy or\r\n     * optionalProxy modifiers, otherwise their invocations can use stale values. */\r\n    address public messageSender;\r\n\r\n    constructor(address payable _proxy) internal {\r\n        // This contract is abstract, and thus cannot be instantiated directly\r\n        require(owner != address(0), \"Owner must be set\");\r\n\r\n        proxy = Proxy(_proxy);\r\n        emit ProxyUpdated(_proxy);\r\n    }\r\n\r\n    function setProxy(address payable _proxy) external onlyOwner {\r\n        proxy = Proxy(_proxy);\r\n        emit ProxyUpdated(_proxy);\r\n    }\r\n\r\n    function setIntegrationProxy(address payable _integrationProxy) external onlyOwner {\r\n        integrationProxy = Proxy(_integrationProxy);\r\n    }\r\n\r\n    function setMessageSender(address sender) external onlyProxy {\r\n        messageSender = sender;\r\n    }\r\n\r\n    modifier onlyProxy {\r\n        _onlyProxy();\r\n        _;\r\n    }\r\n\r\n    function _onlyProxy() private view {\r\n        require(Proxy(msg.sender) == proxy || Proxy(msg.sender) == integrationProxy, \"Only the proxy can call\");\r\n    }\r\n\r\n    modifier optionalProxy {\r\n        _optionalProxy();\r\n        _;\r\n    }\r\n\r\n    function _optionalProxy() private {\r\n        if (Proxy(msg.sender) != proxy && Proxy(msg.sender) != integrationProxy && messageSender != msg.sender) {\r\n            messageSender = msg.sender;\r\n        }\r\n    }\r\n\r\n    modifier optionalProxy_onlyOwner {\r\n        _optionalProxy_onlyOwner();\r\n        _;\r\n    }\r\n\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function _optionalProxy_onlyOwner() private {\r\n        if (Proxy(msg.sender) != proxy && Proxy(msg.sender) != integrationProxy && messageSender != msg.sender) {\r\n            messageSender = msg.sender;\r\n        }\r\n        require(messageSender == owner, \"Owner only function\");\r\n    }\r\n\r\n    event ProxyUpdated(address proxyAddress);\r\n}\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n// Libraries\r\n\r\n\r\n// https://docs.peri.finance/contracts/source/libraries/safedecimalmath\r\nlibrary SafeDecimalMath {\r\n    using SafeMath for uint;\r\n\r\n    /* Number of decimal places in the representations. */\r\n    uint8 public constant decimals = 18;\r\n    uint8 public constant highPrecisionDecimals = 27;\r\n\r\n    /* The number representing 1.0. */\r\n    uint public constant UNIT = 10**uint(decimals);\r\n\r\n    /* The number representing 1.0 for higher fidelity numbers. */\r\n    uint public constant PRECISE_UNIT = 10**uint(highPrecisionDecimals);\r\n    uint private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10**uint(highPrecisionDecimals - decimals);\r\n\r\n    /**\r\n     * @return Provides an interface to UNIT.\r\n     */\r\n    function unit() external pure returns (uint) {\r\n        return UNIT;\r\n    }\r\n\r\n    /**\r\n     * @return Provides an interface to PRECISE_UNIT.\r\n     */\r\n    function preciseUnit() external pure returns (uint) {\r\n        return PRECISE_UNIT;\r\n    }\r\n\r\n    /**\r\n     * @return The result of multiplying x and y, interpreting the operands as fixed-point\r\n     * decimals.\r\n     *\r\n     * @dev A unit factor is divided out after the product of x and y is evaluated,\r\n     * so that product must be less than 2**256. As this is an integer division,\r\n     * the internal division always rounds down. This helps save on gas. Rounding\r\n     * is more expensive on gas.\r\n     */\r\n    function multiplyDecimal(uint x, uint y) internal pure returns (uint) {\r\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\r\n        return x.mul(y) / UNIT;\r\n    }\r\n\r\n    /**\r\n     * @return The result of safely multiplying x and y, interpreting the operands\r\n     * as fixed-point decimals of the specified precision unit.\r\n     *\r\n     * @dev The operands should be in the form of a the specified unit factor which will be\r\n     * divided out after the product of x and y is evaluated, so that product must be\r\n     * less than 2**256.\r\n     *\r\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\r\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\r\n     * (eg. small fractions or percentages).\r\n     */\r\n    function _multiplyDecimalRound(\r\n        uint x,\r\n        uint y,\r\n        uint precisionUnit\r\n    ) private pure returns (uint) {\r\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\r\n        uint quotientTimesTen = x.mul(y) / (precisionUnit / 10);\r\n\r\n        if (quotientTimesTen % 10 >= 5) {\r\n            quotientTimesTen += 10;\r\n        }\r\n\r\n        return quotientTimesTen / 10;\r\n    }\r\n\r\n    /**\r\n     * @return The result of safely multiplying x and y, interpreting the operands\r\n     * as fixed-point decimals of a precise unit.\r\n     *\r\n     * @dev The operands should be in the precise unit factor which will be\r\n     * divided out after the product of x and y is evaluated, so that product must be\r\n     * less than 2**256.\r\n     *\r\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\r\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\r\n     * (eg. small fractions or percentages).\r\n     */\r\n    function multiplyDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\r\n        return _multiplyDecimalRound(x, y, PRECISE_UNIT);\r\n    }\r\n\r\n    /**\r\n     * @return The result of safely multiplying x and y, interpreting the operands\r\n     * as fixed-point decimals of a standard unit.\r\n     *\r\n     * @dev The operands should be in the standard unit factor which will be\r\n     * divided out after the product of x and y is evaluated, so that product must be\r\n     * less than 2**256.\r\n     *\r\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\r\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\r\n     * (eg. small fractions or percentages).\r\n     */\r\n    function multiplyDecimalRound(uint x, uint y) internal pure returns (uint) {\r\n        return _multiplyDecimalRound(x, y, UNIT);\r\n    }\r\n\r\n    /**\r\n     * @return The result of safely dividing x and y. The return value is a high\r\n     * precision decimal.\r\n     *\r\n     * @dev y is divided after the product of x and the standard precision unit\r\n     * is evaluated, so the product of x and UNIT must be less than 2**256. As\r\n     * this is an integer division, the result is always rounded down.\r\n     * This helps save on gas. Rounding is more expensive on gas.\r\n     */\r\n    function divideDecimal(uint x, uint y) internal pure returns (uint) {\r\n        /* Reintroduce the UNIT factor that will be divided out by y. */\r\n        return x.mul(UNIT).div(y);\r\n    }\r\n\r\n    /**\r\n     * @return The result of safely dividing x and y. The return value is as a rounded\r\n     * decimal in the precision unit specified in the parameter.\r\n     *\r\n     * @dev y is divided after the product of x and the specified precision unit\r\n     * is evaluated, so the product of x and the specified precision unit must\r\n     * be less than 2**256. The result is rounded to the nearest increment.\r\n     */\r\n    function _divideDecimalRound(\r\n        uint x,\r\n        uint y,\r\n        uint precisionUnit\r\n    ) private pure returns (uint) {\r\n        uint resultTimesTen = x.mul(precisionUnit * 10).div(y);\r\n\r\n        if (resultTimesTen % 10 >= 5) {\r\n            resultTimesTen += 10;\r\n        }\r\n\r\n        return resultTimesTen / 10;\r\n    }\r\n\r\n    /**\r\n     * @return The result of safely dividing x and y. The return value is as a rounded\r\n     * standard precision decimal.\r\n     *\r\n     * @dev y is divided after the product of x and the standard precision unit\r\n     * is evaluated, so the product of x and the standard precision unit must\r\n     * be less than 2**256. The result is rounded to the nearest increment.\r\n     */\r\n    function divideDecimalRound(uint x, uint y) internal pure returns (uint) {\r\n        return _divideDecimalRound(x, y, UNIT);\r\n    }\r\n\r\n    /**\r\n     * @return The result of safely dividing x and y. The return value is as a rounded\r\n     * high precision decimal.\r\n     *\r\n     * @dev y is divided after the product of x and the high precision unit\r\n     * is evaluated, so the product of x and the high precision unit must\r\n     * be less than 2**256. The result is rounded to the nearest increment.\r\n     */\r\n    function divideDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\r\n        return _divideDecimalRound(x, y, PRECISE_UNIT);\r\n    }\r\n\r\n    /**\r\n     * @dev Convert a standard decimal representation to a high precision one.\r\n     */\r\n    function decimalToPreciseDecimal(uint i) internal pure returns (uint) {\r\n        return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\r\n    }\r\n\r\n    /**\r\n     * @dev Convert a high precision decimal to a standard decimal representation.\r\n     */\r\n    function preciseDecimalToDecimal(uint i) internal pure returns (uint) {\r\n        uint quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\r\n\r\n        if (quotientTimesTen % 10 >= 5) {\r\n            quotientTimesTen += 10;\r\n        }\r\n\r\n        return quotientTimesTen / 10;\r\n    }\r\n}\r\n\r\n\r\n// Inheritance\r\n\r\n\r\n// https://docs.peri.finance/contracts/source/contracts/state\r\ncontract State is Owned {\r\n    // the address of the contract that can modify variables\r\n    // this can only be changed by the owner of this contract\r\n    address public associatedContract;\r\n\r\n    constructor(address _associatedContract) internal {\r\n        // This contract is abstract, and thus cannot be instantiated directly\r\n        require(owner != address(0), \"Owner must be set\");\r\n\r\n        associatedContract = _associatedContract;\r\n        emit AssociatedContractUpdated(_associatedContract);\r\n    }\r\n\r\n    /* ========== SETTERS ========== */\r\n\r\n    // Change the associated contract to a new address\r\n    function setAssociatedContract(address _associatedContract) external onlyOwner {\r\n        associatedContract = _associatedContract;\r\n        emit AssociatedContractUpdated(_associatedContract);\r\n    }\r\n\r\n    /* ========== MODIFIERS ========== */\r\n\r\n    modifier onlyAssociatedContract {\r\n        require(msg.sender == associatedContract, \"Only the associated contract can perform this action\");\r\n        _;\r\n    }\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    event AssociatedContractUpdated(address associatedContract);\r\n}\r\n\r\n\r\n// Inheritance\r\n\r\n\r\n// https://docs.peri.finance/contracts/source/contracts/tokenstate\r\ncontract TokenState is Owned, State {\r\n    /* ERC20 fields. */\r\n    mapping(address => uint) public balanceOf;\r\n    mapping(address => mapping(address => uint)) public allowance;\r\n\r\n    constructor(address _owner, address _associatedContract) public Owned(_owner) State(_associatedContract) {}\r\n\r\n    /* ========== SETTERS ========== */\r\n\r\n    /**\r\n     * @notice Set ERC20 allowance.\r\n     * @dev Only the associated contract may call this.\r\n     * @param tokenOwner The authorising party.\r\n     * @param spender The authorised party.\r\n     * @param value The total value the authorised party may spend on the\r\n     * authorising party's behalf.\r\n     */\r\n    function setAllowance(\r\n        address tokenOwner,\r\n        address spender,\r\n        uint value\r\n    ) external onlyAssociatedContract {\r\n        allowance[tokenOwner][spender] = value;\r\n    }\r\n\r\n    /**\r\n     * @notice Set the balance in a given account\r\n     * @dev Only the associated contract may call this.\r\n     * @param account The account whose value to set.\r\n     * @param value The new balance of the given account.\r\n     */\r\n    function setBalanceOf(address account, uint value) external onlyAssociatedContract {\r\n        balanceOf[account] = value;\r\n    }\r\n}\r\n\r\n\r\n// Inheritance\r\n\r\n\r\n// Libraries\r\n\r\n\r\n// Internal references\r\n\r\n\r\n// https://docs.peri.finance/contracts/source/contracts/externstatetoken\r\ncontract ExternStateToken is Owned, Proxyable {\r\n    using SafeMath for uint;\r\n    using SafeDecimalMath for uint;\r\n\r\n    /* ========== STATE VARIABLES ========== */\r\n\r\n    /* Stores balances and allowances. */\r\n    TokenState public tokenState;\r\n\r\n    /* Other ERC20 fields. */\r\n    string public name;\r\n    string public symbol;\r\n    uint public totalSupply;\r\n    uint8 public decimals;\r\n\r\n    constructor(\r\n        address payable _proxy,\r\n        TokenState _tokenState,\r\n        string memory _name,\r\n        string memory _symbol,\r\n        uint _totalSupply,\r\n        uint8 _decimals,\r\n        address _owner\r\n    ) public Owned(_owner) Proxyable(_proxy) {\r\n        tokenState = _tokenState;\r\n\r\n        name = _name;\r\n        symbol = _symbol;\r\n        totalSupply = _totalSupply;\r\n        decimals = _decimals;\r\n    }\r\n\r\n    /* ========== VIEWS ========== */\r\n\r\n    /**\r\n     * @notice Returns the ERC20 allowance of one party to spend on behalf of another.\r\n     * @param owner The party authorising spending of their funds.\r\n     * @param spender The party spending tokenOwner's funds.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint) {\r\n        return tokenState.allowance(owner, spender);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the ERC20 token balance of a given account.\r\n     */\r\n    function balanceOf(address account) external view returns (uint) {\r\n        return tokenState.balanceOf(account);\r\n    }\r\n\r\n    /* ========== MUTATIVE FUNCTIONS ========== */\r\n\r\n    /**\r\n     * @notice Set the address of the TokenState contract.\r\n     * @dev This can be used to \"pause\" transfer functionality, by pointing the tokenState at 0x000..\r\n     * as balances would be unreachable.\r\n     */\r\n    function setTokenState(TokenState _tokenState) external optionalProxy_onlyOwner {\r\n        tokenState = _tokenState;\r\n        emitTokenStateUpdated(address(_tokenState));\r\n    }\r\n\r\n    function _internalTransfer(\r\n        address from,\r\n        address to,\r\n        uint value\r\n    ) internal returns (bool) {\r\n        /* Disallow transfers to irretrievable-addresses. */\r\n        require(to != address(0) && to != address(this) && to != address(proxy), \"Cannot transfer to this address\");\r\n\r\n        // Insufficient balance will be handled by the safe subtraction.\r\n        tokenState.setBalanceOf(from, tokenState.balanceOf(from).sub(value));\r\n        tokenState.setBalanceOf(to, tokenState.balanceOf(to).add(value));\r\n\r\n        // Emit a standard ERC20 transfer event\r\n        emitTransfer(from, to, value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Perform an ERC20 token transfer. Designed to be called by transfer functions possessing\r\n     * the onlyProxy or optionalProxy modifiers.\r\n     */\r\n    function _transferByProxy(\r\n        address from,\r\n        address to,\r\n        uint value\r\n    ) internal returns (bool) {\r\n        return _internalTransfer(from, to, value);\r\n    }\r\n\r\n    /*\r\n     * @dev Perform an ERC20 token transferFrom. Designed to be called by transferFrom functions\r\n     * possessing the optionalProxy or optionalProxy modifiers.\r\n     */\r\n    function _transferFromByProxy(\r\n        address sender,\r\n        address from,\r\n        address to,\r\n        uint value\r\n    ) internal returns (bool) {\r\n        /* Insufficient allowance will be handled by the safe subtraction. */\r\n        tokenState.setAllowance(from, sender, tokenState.allowance(from, sender).sub(value));\r\n        return _internalTransfer(from, to, value);\r\n    }\r\n\r\n    /**\r\n     * @notice Approves spender to transfer on the message sender's behalf.\r\n     */\r\n    function approve(address spender, uint value) public optionalProxy returns (bool) {\r\n        address sender = messageSender;\r\n\r\n        tokenState.setAllowance(sender, spender, value);\r\n        emitApproval(sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /* ========== EVENTS ========== */\r\n    function addressToBytes32(address input) internal pure returns (bytes32) {\r\n        return bytes32(uint256(uint160(input)));\r\n    }\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    bytes32 internal constant TRANSFER_SIG = keccak256(\"Transfer(address,address,uint256)\");\r\n\r\n    function emitTransfer(\r\n        address from,\r\n        address to,\r\n        uint value\r\n    ) internal {\r\n        proxy._emit(abi.encode(value), 3, TRANSFER_SIG, addressToBytes32(from), addressToBytes32(to), 0);\r\n    }\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    bytes32 internal constant APPROVAL_SIG = keccak256(\"Approval(address,address,uint256)\");\r\n\r\n    function emitApproval(\r\n        address owner,\r\n        address spender,\r\n        uint value\r\n    ) internal {\r\n        proxy._emit(abi.encode(value), 3, APPROVAL_SIG, addressToBytes32(owner), addressToBytes32(spender), 0);\r\n    }\r\n\r\n    event TokenStateUpdated(address newTokenState);\r\n    bytes32 internal constant TOKENSTATEUPDATED_SIG = keccak256(\"TokenStateUpdated(address)\");\r\n\r\n    function emitTokenStateUpdated(address newTokenState) internal {\r\n        proxy._emit(abi.encode(newTokenState), 1, TOKENSTATEUPDATED_SIG, 0, 0, 0);\r\n    }\r\n}\r\n\r\n\r\n// https://docs.peri.finance/contracts/source/interfaces/iaddressresolver\r\ninterface IAddressResolver {\r\n    function getAddress(bytes32 name) external view returns (address);\r\n\r\n    function getPynth(bytes32 key) external view returns (address);\r\n\r\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address);\r\n}\r\n\r\n\r\n// https://docs.peri.finance/contracts/source/interfaces/ipynth\r\ninterface IPynth {\r\n    // Views\r\n    function currencyKey() external view returns (bytes32);\r\n\r\n    function transferablePynths(address account) external view returns (uint);\r\n\r\n    // Mutative functions\r\n    function transferAndSettle(address to, uint value) external returns (bool);\r\n\r\n    function transferFromAndSettle(\r\n        address from,\r\n        address to,\r\n        uint value\r\n    ) external returns (bool);\r\n\r\n    // Restricted: used internally to PeriFinance\r\n    function burn(address account, uint amount) external;\r\n\r\n    function issue(address account, uint amount) external;\r\n}\r\n\r\n\r\n// https://docs.peri.finance/contracts/source/interfaces/iissuer\r\ninterface IIssuer {\r\n    // Views\r\n    function anyPynthOrPERIRateIsInvalid() external view returns (bool anyRateInvalid);\r\n\r\n    function availableCurrencyKeys() external view returns (bytes32[] memory);\r\n\r\n    function availablePynthCount() external view returns (uint);\r\n\r\n    function availablePynths(uint index) external view returns (IPynth);\r\n\r\n    function canBurnPynths(address account) external view returns (bool);\r\n\r\n    function collateral(address account) external view returns (uint);\r\n\r\n    function collateralisationRatio(address issuer) external view returns (uint);\r\n\r\n    function collateralisationRatioAndAnyRatesInvalid(address _issuer)\r\n        external\r\n        view\r\n        returns (uint cratio, bool anyRateIsInvalid);\r\n\r\n    function debtBalanceOf(address issuer, bytes32 currencyKey) external view returns (uint debtBalance);\r\n\r\n    function issuanceRatio() external view returns (uint);\r\n\r\n    function lastIssueEvent(address account) external view returns (uint);\r\n\r\n    function maxIssuablePynths(address issuer) external view returns (uint maxIssuable);\r\n\r\n    function minimumStakeTime() external view returns (uint);\r\n\r\n    function remainingIssuablePynths(address issuer)\r\n        external\r\n        view\r\n        returns (\r\n            uint maxIssuable,\r\n            uint alreadyIssued,\r\n            uint totalSystemDebt\r\n        );\r\n\r\n    function pynths(bytes32 currencyKey) external view returns (IPynth);\r\n\r\n    function getPynths(bytes32[] calldata currencyKeys) external view returns (IPynth[] memory);\r\n\r\n    function pynthsByAddress(address pynthAddress) external view returns (bytes32);\r\n\r\n    function totalIssuedPynths(bytes32 currencyKey, bool excludeEtherCollateral) external view returns (uint);\r\n\r\n    function transferablePeriFinanceAndAnyRateIsInvalid(address account, uint balance)\r\n        external\r\n        view\r\n        returns (uint transferable, bool anyRateIsInvalid);\r\n\r\n    // Restricted: used internally to PeriFinance\r\n    function issuePynths(address from, uint amount) external;\r\n\r\n    function issuePynthsOnBehalf(\r\n        address issueFor,\r\n        address from,\r\n        uint amount\r\n    ) external;\r\n\r\n    function issueMaxPynths(address from) external;\r\n\r\n    function issueMaxPynthsOnBehalf(address issueFor, address from) external;\r\n\r\n    function stakeUSDCAndIssuePynths(\r\n        address from,\r\n        uint usdcStakeAmount,\r\n        uint issueAmount\r\n    ) external;\r\n\r\n    function stakeUSDCAndIssueMaxPynths(address from, uint usdcStakeAmount) external;\r\n\r\n    function burnPynths(address from, uint amount) external;\r\n\r\n    function burnPynthsOnBehalf(\r\n        address burnForAddress,\r\n        address from,\r\n        uint amount\r\n    ) external;\r\n\r\n    function burnPynthsToTarget(address from) external;\r\n\r\n    function burnPynthsToTargetOnBehalf(address burnForAddress, address from) external;\r\n\r\n    function unstakeUSDCAndBurnPynths(\r\n        address from,\r\n        uint usdcUnstakeAmount,\r\n        uint burnAmount\r\n    ) external;\r\n\r\n    function unstakeUSDCToMaxAndBurnPynths(address from, uint burnAmount) external;\r\n\r\n    function liquidateDelinquentAccount(\r\n        address account,\r\n        uint pusdAmount,\r\n        address liquidator\r\n    ) external returns (uint totalRedeemed, uint amountToLiquidate);\r\n}\r\n\r\n\r\n// Inheritance\r\n\r\n\r\n// Internal references\r\n\r\n\r\n// https://docs.peri.finance/contracts/source/contracts/addressresolver\r\ncontract AddressResolver is Owned, IAddressResolver {\r\n    mapping(bytes32 => address) public repository;\r\n\r\n    constructor(address _owner) public Owned(_owner) {}\r\n\r\n    /* ========== RESTRICTED FUNCTIONS ========== */\r\n\r\n    function importAddresses(bytes32[] calldata names, address[] calldata destinations) external onlyOwner {\r\n        require(names.length == destinations.length, \"Input lengths must match\");\r\n\r\n        for (uint i = 0; i < names.length; i++) {\r\n            bytes32 name = names[i];\r\n            address destination = destinations[i];\r\n            repository[name] = destination;\r\n            emit AddressImported(name, destination);\r\n        }\r\n    }\r\n\r\n    /* ========= PUBLIC FUNCTIONS ========== */\r\n\r\n    function rebuildCaches(MixinResolver[] calldata destinations) external {\r\n        for (uint i = 0; i < destinations.length; i++) {\r\n            destinations[i].rebuildCache();\r\n        }\r\n    }\r\n\r\n    /* ========== VIEWS ========== */\r\n\r\n    function areAddressesImported(bytes32[] calldata names, address[] calldata destinations) external view returns (bool) {\r\n        for (uint i = 0; i < names.length; i++) {\r\n            if (repository[names[i]] != destinations[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function getAddress(bytes32 name) external view returns (address) {\r\n        return repository[name];\r\n    }\r\n\r\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address) {\r\n        address _foundAddress = repository[name];\r\n        require(_foundAddress != address(0), reason);\r\n        return _foundAddress;\r\n    }\r\n\r\n    function getPynth(bytes32 key) external view returns (address) {\r\n        IIssuer issuer = IIssuer(repository[\"Issuer\"]);\r\n        require(address(issuer) != address(0), \"Cannot find Issuer address\");\r\n        return address(issuer.pynths(key));\r\n    }\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    event AddressImported(bytes32 name, address destination);\r\n}\r\n\r\n\r\n// solhint-disable payable-fallback\r\n\r\n// https://docs.peri.finance/contracts/source/contracts/readproxy\r\ncontract ReadProxy is Owned {\r\n    address public target;\r\n\r\n    constructor(address _owner) public Owned(_owner) {}\r\n\r\n    function setTarget(address _target) external onlyOwner {\r\n        target = _target;\r\n        emit TargetUpdated(target);\r\n    }\r\n\r\n    function() external {\r\n        // The basics of a proxy read call\r\n        // Note that msg.sender in the underlying will always be the address of this contract.\r\n        assembly {\r\n            calldatacopy(0, 0, calldatasize)\r\n\r\n            // Use of staticcall - this will revert if the underlying function mutates state\r\n            let result := staticcall(gas, sload(target_slot), 0, calldatasize, 0, 0)\r\n            returndatacopy(0, 0, returndatasize)\r\n\r\n            if iszero(result) {\r\n                revert(0, returndatasize)\r\n            }\r\n            return(0, returndatasize)\r\n        }\r\n    }\r\n\r\n    event TargetUpdated(address newTarget);\r\n}\r\n\r\n\r\n// Inheritance\r\n\r\n\r\n// Internal references\r\n\r\n\r\n// https://docs.peri.finance/contracts/source/contracts/mixinresolver\r\ncontract MixinResolver {\r\n    AddressResolver public resolver;\r\n\r\n    mapping(bytes32 => address) private addressCache;\r\n\r\n    constructor(address _resolver) internal {\r\n        resolver = AddressResolver(_resolver);\r\n    }\r\n\r\n    /* ========== INTERNAL FUNCTIONS ========== */\r\n\r\n    function combineArrays(bytes32[] memory first, bytes32[] memory second)\r\n        internal\r\n        pure\r\n        returns (bytes32[] memory combination)\r\n    {\r\n        combination = new bytes32[](first.length + second.length);\r\n\r\n        for (uint i = 0; i < first.length; i++) {\r\n            combination[i] = first[i];\r\n        }\r\n\r\n        for (uint j = 0; j < second.length; j++) {\r\n            combination[first.length + j] = second[j];\r\n        }\r\n    }\r\n\r\n    /* ========== PUBLIC FUNCTIONS ========== */\r\n\r\n    // Note: this function is public not external in order for it to be overridden and invoked via super in subclasses\r\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {}\r\n\r\n    function rebuildCache() public {\r\n        bytes32[] memory requiredAddresses = resolverAddressesRequired();\r\n        // The resolver must call this function whenver it updates its state\r\n        for (uint i = 0; i < requiredAddresses.length; i++) {\r\n            bytes32 name = requiredAddresses[i];\r\n            // Note: can only be invoked once the resolver has all the targets needed added\r\n            address destination =\r\n                resolver.requireAndGetAddress(name, string(abi.encodePacked(\"Resolver missing target: \", name)));\r\n            addressCache[name] = destination;\r\n            emit CacheUpdated(name, destination);\r\n        }\r\n    }\r\n\r\n    /* ========== VIEWS ========== */\r\n\r\n    function isResolverCached() external view returns (bool) {\r\n        bytes32[] memory requiredAddresses = resolverAddressesRequired();\r\n        for (uint i = 0; i < requiredAddresses.length; i++) {\r\n            bytes32 name = requiredAddresses[i];\r\n            // false if our cache is invalid or if the resolver doesn't have the required address\r\n            if (resolver.getAddress(name) != addressCache[name] || addressCache[name] == address(0)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /* ========== INTERNAL FUNCTIONS ========== */\r\n\r\n    function requireAndGetAddress(bytes32 name) internal view returns (address) {\r\n        address _foundAddress = addressCache[name];\r\n        require(_foundAddress != address(0), string(abi.encodePacked(\"Missing address: \", name)));\r\n        return _foundAddress;\r\n    }\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    event CacheUpdated(bytes32 name, address destination);\r\n}\r\n\r\n\r\ninterface IVirtualPynth {\r\n    // Views\r\n    function balanceOfUnderlying(address account) external view returns (uint);\r\n\r\n    function rate() external view returns (uint);\r\n\r\n    function readyToSettle() external view returns (bool);\r\n\r\n    function secsLeftInWaitingPeriod() external view returns (uint);\r\n\r\n    function settled() external view returns (bool);\r\n\r\n    function pynth() external view returns (IPynth);\r\n\r\n    // Mutative functions\r\n    function settle(address account) external;\r\n}\r\n\r\n\r\n// https://docs.peri.finance/contracts/source/interfaces/iperiFinance\r\ninterface IPeriFinance {\r\n    // Views\r\n    function anyPynthOrPERIRateIsInvalid() external view returns (bool anyRateInvalid);\r\n\r\n    function availableCurrencyKeys() external view returns (bytes32[] memory);\r\n\r\n    function availablePynthCount() external view returns (uint);\r\n\r\n    function availablePynths(uint index) external view returns (IPynth);\r\n\r\n    function collateral(address account) external view returns (uint);\r\n\r\n    function collateralisationRatio(address issuer) external view returns (uint);\r\n\r\n    function debtBalanceOf(address issuer, bytes32 currencyKey) external view returns (uint);\r\n\r\n    function isWaitingPeriod(bytes32 currencyKey) external view returns (bool);\r\n\r\n    function maxIssuablePynths(address issuer) external view returns (uint maxIssuable);\r\n\r\n    function remainingIssuablePynths(address issuer)\r\n        external\r\n        view\r\n        returns (\r\n            uint maxIssuable,\r\n            uint alreadyIssued,\r\n            uint totalSystemDebt\r\n        );\r\n\r\n    function pynths(bytes32 currencyKey) external view returns (IPynth);\r\n\r\n    function pynthsByAddress(address pynthAddress) external view returns (bytes32);\r\n\r\n    function totalIssuedPynths(bytes32 currencyKey) external view returns (uint);\r\n\r\n    function totalIssuedPynthsExcludeEtherCollateral(bytes32 currencyKey) external view returns (uint);\r\n\r\n    function transferablePeriFinance(address account) external view returns (uint transferable);\r\n\r\n    // Mutative Functions\r\n    function burnPynths(uint amount) external;\r\n\r\n    function burnPynthsOnBehalf(address burnForAddress, uint amount) external;\r\n\r\n    function burnPynthsToTarget() external;\r\n\r\n    function burnPynthsToTargetOnBehalf(address burnForAddress) external;\r\n\r\n    function exchange(\r\n        bytes32 sourceCurrencyKey,\r\n        uint sourceAmount,\r\n        bytes32 destinationCurrencyKey\r\n    ) external returns (uint amountReceived);\r\n\r\n    function exchangeOnBehalf(\r\n        address exchangeForAddress,\r\n        bytes32 sourceCurrencyKey,\r\n        uint sourceAmount,\r\n        bytes32 destinationCurrencyKey\r\n    ) external returns (uint amountReceived);\r\n\r\n    function exchangeWithTracking(\r\n        bytes32 sourceCurrencyKey,\r\n        uint sourceAmount,\r\n        bytes32 destinationCurrencyKey,\r\n        address originator,\r\n        bytes32 trackingCode\r\n    ) external returns (uint amountReceived);\r\n\r\n    function exchangeOnBehalfWithTracking(\r\n        address exchangeForAddress,\r\n        bytes32 sourceCurrencyKey,\r\n        uint sourceAmount,\r\n        bytes32 destinationCurrencyKey,\r\n        address originator,\r\n        bytes32 trackingCode\r\n    ) external returns (uint amountReceived);\r\n\r\n    function exchangeWithVirtual(\r\n        bytes32 sourceCurrencyKey,\r\n        uint sourceAmount,\r\n        bytes32 destinationCurrencyKey,\r\n        bytes32 trackingCode\r\n    ) external returns (uint amountReceived, IVirtualPynth vPynth);\r\n\r\n    function issueMaxPynths() external;\r\n\r\n    function issuePynths(uint amount) external;\r\n\r\n    function issuePynthsOnBehalf(address issueForAddress, uint amount) external;\r\n\r\n    function issueMaxPynthsOnBehalf(address issueForAddress) external;\r\n\r\n    function stakeUSDCAndIssuePynths(uint usdcStakeAmount, uint issueAmount) external;\r\n\r\n    function stakeUSDCAndIssueMaxPynths(uint usdcStakingAmount) external;\r\n\r\n    function unstakeUSDCAndBurnPynths(uint usdcUnstakeAmount, uint burnAmount) external;\r\n\r\n    function unstakeUSDCToMaxAndBurnPynths(uint burnAmount) external;\r\n\r\n    function mint() external returns (bool);\r\n\r\n    function settle(bytes32 currencyKey)\r\n        external\r\n        returns (\r\n            uint reclaimed,\r\n            uint refunded,\r\n            uint numEntries\r\n        );\r\n\r\n    // Liquidations\r\n    function liquidateDelinquentAccount(address account, uint pusdAmount) external returns (bool);\r\n\r\n    // Restricted Functions\r\n\r\n    function mintSecondary(address account, uint amount) external;\r\n\r\n    function mintSecondaryRewards(uint amount) external;\r\n\r\n    function burnSecondary(address account, uint amount) external;\r\n}\r\n\r\n\r\n// https://docs.peri.finance/contracts/source/interfaces/iperiFinancestate\r\ninterface IPeriFinanceState {\r\n    // Views\r\n    function debtLedger(uint index) external view returns (uint);\r\n\r\n    function issuanceData(address account) external view returns (uint initialDebtOwnership, uint debtEntryIndex);\r\n\r\n    function debtLedgerLength() external view returns (uint);\r\n\r\n    function hasIssued(address account) external view returns (bool);\r\n\r\n    function lastDebtLedgerEntry() external view returns (uint);\r\n\r\n    // Mutative functions\r\n    function incrementTotalIssuerCount() external;\r\n\r\n    function decrementTotalIssuerCount() external;\r\n\r\n    function setCurrentIssuanceData(address account, uint initialDebtOwnership) external;\r\n\r\n    function appendDebtLedgerValue(uint value) external;\r\n\r\n    function clearIssuanceData(address account) external;\r\n\r\n    // Views\r\n    function periDebtLedger(uint index) external view returns (uint);\r\n\r\n    function periIssuanceData(address account) external view returns (uint initialDebtOwnership, uint debtEntryIndex);\r\n\r\n    function periDebtLedgerLength() external view returns (uint);\r\n\r\n    function hasPeriIssued(address account) external view returns (bool);\r\n\r\n    function lastPeriDebtLedgerEntry() external view returns (uint);\r\n\r\n    // Mutative functions\r\n    function incrementTotalPeriIssuerCount() external;\r\n\r\n    function decrementTotalPeriIssuerCount() external;\r\n\r\n    function setCurrentPeriIssuanceData(address account, uint initialDebtOwnership) external;\r\n\r\n    function appendPeriDebtLedgerValue(uint value) external;\r\n\r\n    function clearPeriIssuanceData(address account) external;\r\n}\r\n\r\n\r\n// https://docs.peri.finance/contracts/source/interfaces/isystemstatus\r\ninterface ISystemStatus {\r\n    struct Status {\r\n        bool canSuspend;\r\n        bool canResume;\r\n    }\r\n\r\n    struct Suspension {\r\n        bool suspended;\r\n        // reason is an integer code,\r\n        // 0 => no reason, 1 => upgrading, 2+ => defined by system usage\r\n        uint248 reason;\r\n    }\r\n\r\n    // Views\r\n    function accessControl(bytes32 section, address account) external view returns (bool canSuspend, bool canResume);\r\n\r\n    function requireSystemActive() external view;\r\n\r\n    function requireIssuanceActive() external view;\r\n\r\n    function requireExchangeActive() external view;\r\n\r\n    function requireExchangeBetweenPynthsAllowed(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view;\r\n\r\n    function requirePynthActive(bytes32 currencyKey) external view;\r\n\r\n    function requirePynthsActive(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view;\r\n\r\n    function systemSuspension() external view returns (bool suspended, uint248 reason);\r\n\r\n    function issuanceSuspension() external view returns (bool suspended, uint248 reason);\r\n\r\n    function exchangeSuspension() external view returns (bool suspended, uint248 reason);\r\n\r\n    function pynthExchangeSuspension(bytes32 currencyKey) external view returns (bool suspended, uint248 reason);\r\n\r\n    function pynthSuspension(bytes32 currencyKey) external view returns (bool suspended, uint248 reason);\r\n\r\n    function getPynthExchangeSuspensions(bytes32[] calldata pynths)\r\n        external\r\n        view\r\n        returns (bool[] memory exchangeSuspensions, uint256[] memory reasons);\r\n\r\n    function getPynthSuspensions(bytes32[] calldata pynths)\r\n        external\r\n        view\r\n        returns (bool[] memory suspensions, uint256[] memory reasons);\r\n\r\n    // Restricted functions\r\n    function suspendPynth(bytes32 currencyKey, uint256 reason) external;\r\n\r\n    function updateAccessControl(\r\n        bytes32 section,\r\n        address account,\r\n        bool canSuspend,\r\n        bool canResume\r\n    ) external;\r\n}\r\n\r\n\r\n// https://docs.peri.finance/contracts/source/interfaces/iexchanger\r\ninterface IExchanger {\r\n    // Views\r\n    function calculateAmountAfterSettlement(\r\n        address from,\r\n        bytes32 currencyKey,\r\n        uint amount,\r\n        uint refunded\r\n    ) external view returns (uint amountAfterSettlement);\r\n\r\n    function isPynthRateInvalid(bytes32 currencyKey) external view returns (bool);\r\n\r\n    function maxSecsLeftInWaitingPeriod(address account, bytes32 currencyKey) external view returns (uint);\r\n\r\n    function settlementOwing(address account, bytes32 currencyKey)\r\n        external\r\n        view\r\n        returns (\r\n            uint reclaimAmount,\r\n            uint rebateAmount,\r\n            uint numEntries\r\n        );\r\n\r\n    function hasWaitingPeriodOrSettlementOwing(address account, bytes32 currencyKey) external view returns (bool);\r\n\r\n    function feeRateForExchange(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey)\r\n        external\r\n        view\r\n        returns (uint exchangeFeeRate);\r\n\r\n    function getAmountsForExchange(\r\n        uint sourceAmount,\r\n        bytes32 sourceCurrencyKey,\r\n        bytes32 destinationCurrencyKey\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint amountReceived,\r\n            uint fee,\r\n            uint exchangeFeeRate\r\n        );\r\n\r\n    function priceDeviationThresholdFactor() external view returns (uint);\r\n\r\n    function waitingPeriodSecs() external view returns (uint);\r\n\r\n    // Mutative functions\r\n    function exchange(\r\n        address from,\r\n        bytes32 sourceCurrencyKey,\r\n        uint sourceAmount,\r\n        bytes32 destinationCurrencyKey,\r\n        address destinationAddress\r\n    ) external returns (uint amountReceived);\r\n\r\n    function exchangeOnBehalf(\r\n        address exchangeForAddress,\r\n        address from,\r\n        bytes32 sourceCurrencyKey,\r\n        uint sourceAmount,\r\n        bytes32 destinationCurrencyKey\r\n    ) external returns (uint amountReceived);\r\n\r\n    function exchangeWithTracking(\r\n        address from,\r\n        bytes32 sourceCurrencyKey,\r\n        uint sourceAmount,\r\n        bytes32 destinationCurrencyKey,\r\n        address destinationAddress,\r\n        address originator,\r\n        bytes32 trackingCode\r\n    ) external returns (uint amountReceived);\r\n\r\n    function exchangeOnBehalfWithTracking(\r\n        address exchangeForAddress,\r\n        address from,\r\n        bytes32 sourceCurrencyKey,\r\n        uint sourceAmount,\r\n        bytes32 destinationCurrencyKey,\r\n        address originator,\r\n        bytes32 trackingCode\r\n    ) external returns (uint amountReceived);\r\n\r\n    function exchangeWithVirtual(\r\n        address from,\r\n        bytes32 sourceCurrencyKey,\r\n        uint sourceAmount,\r\n        bytes32 destinationCurrencyKey,\r\n        address destinationAddress,\r\n        bytes32 trackingCode\r\n    ) external returns (uint amountReceived, IVirtualPynth vPynth);\r\n\r\n    function settle(address from, bytes32 currencyKey)\r\n        external\r\n        returns (\r\n            uint reclaimed,\r\n            uint refunded,\r\n            uint numEntries\r\n        );\r\n\r\n    function setLastExchangeRateForPynth(bytes32 currencyKey, uint rate) external;\r\n\r\n    function suspendPynthWithInvalidRate(bytes32 currencyKey) external;\r\n}\r\n\r\n\r\n// https://docs.peri.finance/contracts/source/interfaces/irewardsdistribution\r\ninterface IRewardsDistribution {\r\n    // Structs\r\n    struct DistributionData {\r\n        address destination;\r\n        uint amount;\r\n    }\r\n\r\n    // Views\r\n    function authority() external view returns (address);\r\n\r\n    function distributions(uint index) external view returns (address destination, uint amount); // DistributionData\r\n\r\n    function distributionsLength() external view returns (uint);\r\n\r\n    // Mutative Functions\r\n    function distributeRewards(uint amount) external returns (bool);\r\n}\r\n\r\n\r\n// Inheritance\r\n\r\n\r\n// Libraries\r\n\r\n\r\n// Internal references\r\n\r\n\r\ncontract BasePeriFinance is IERC20, ExternStateToken, MixinResolver, IPeriFinance {\r\n    using SafeMath for uint;\r\n    using SafeDecimalMath for uint;\r\n\r\n    // ========== STATE VARIABLES ==========\r\n\r\n    struct LockState {\r\n        address account;\r\n        uint startTime;\r\n        uint iterations;\r\n        uint totalAmount;\r\n        uint unitTime;\r\n        uint endTime;\r\n    }\r\n\r\n    // Available Pynths which can be used with the system\r\n    string public constant TOKEN_NAME = \"Peri Finance Token\";\r\n    string public constant TOKEN_SYMBOL = \"PERI\";\r\n    uint8 public constant DECIMALS = 18;\r\n    bytes32 public constant pUSD = \"pUSD\";\r\n\r\n    mapping(address => LockState) public lockStates;\r\n\r\n    event LockChanged(\r\n        address indexed account,\r\n        uint startTime,\r\n        uint iterations,\r\n        uint totalAmount,\r\n        uint unitTime,\r\n        uint endTime\r\n    );\r\n\r\n    // ========== ADDRESS RESOLVER CONFIGURATION ==========\r\n    bytes32 private constant CONTRACT_PERIFINANCESTATE = \"PeriFinanceState\";\r\n    bytes32 private constant CONTRACT_SYSTEMSTATUS = \"SystemStatus\";\r\n    bytes32 private constant CONTRACT_EXCHANGER = \"Exchanger\";\r\n    bytes32 private constant CONTRACT_ISSUER = \"Issuer\";\r\n    bytes32 private constant CONTRACT_REWARDSDISTRIBUTION = \"RewardsDistribution\";\r\n\r\n    // ========== CONSTRUCTOR ==========\r\n\r\n    constructor(\r\n        address payable _proxy,\r\n        TokenState _tokenState,\r\n        address _owner,\r\n        uint _totalSupply,\r\n        address _resolver\r\n    )\r\n        public\r\n        ExternStateToken(_proxy, _tokenState, TOKEN_NAME, TOKEN_SYMBOL, _totalSupply, DECIMALS, _owner)\r\n        MixinResolver(_resolver)\r\n    {}\r\n\r\n    // ========== VIEWS ==========\r\n\r\n    // Note: use public visibility so that it can be invoked in a subclass\r\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {\r\n        addresses = new bytes32[](5);\r\n        addresses[0] = CONTRACT_PERIFINANCESTATE;\r\n        addresses[1] = CONTRACT_SYSTEMSTATUS;\r\n        addresses[2] = CONTRACT_EXCHANGER;\r\n        addresses[3] = CONTRACT_ISSUER;\r\n        addresses[4] = CONTRACT_REWARDSDISTRIBUTION;\r\n    }\r\n\r\n    function periFinanceState() internal view returns (IPeriFinanceState) {\r\n        return IPeriFinanceState(requireAndGetAddress(CONTRACT_PERIFINANCESTATE));\r\n    }\r\n\r\n    function systemStatus() internal view returns (ISystemStatus) {\r\n        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));\r\n    }\r\n\r\n    function exchanger() internal view returns (IExchanger) {\r\n        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));\r\n    }\r\n\r\n    function issuer() internal view returns (IIssuer) {\r\n        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));\r\n    }\r\n\r\n    function rewardsDistribution() internal view returns (IRewardsDistribution) {\r\n        return IRewardsDistribution(requireAndGetAddress(CONTRACT_REWARDSDISTRIBUTION));\r\n    }\r\n\r\n    function debtBalanceOf(address account, bytes32 currencyKey) external view returns (uint) {\r\n        return issuer().debtBalanceOf(account, currencyKey);\r\n    }\r\n\r\n    function totalIssuedPynths(bytes32 currencyKey) external view returns (uint) {\r\n        return issuer().totalIssuedPynths(currencyKey, false);\r\n    }\r\n\r\n    function totalIssuedPynthsExcludeEtherCollateral(bytes32 currencyKey) external view returns (uint) {\r\n        return issuer().totalIssuedPynths(currencyKey, true);\r\n    }\r\n\r\n    function availableCurrencyKeys() external view returns (bytes32[] memory) {\r\n        return issuer().availableCurrencyKeys();\r\n    }\r\n\r\n    function availablePynthCount() external view returns (uint) {\r\n        return issuer().availablePynthCount();\r\n    }\r\n\r\n    function availablePynths(uint index) external view returns (IPynth) {\r\n        return issuer().availablePynths(index);\r\n    }\r\n\r\n    function pynths(bytes32 currencyKey) external view returns (IPynth) {\r\n        return issuer().pynths(currencyKey);\r\n    }\r\n\r\n    function pynthsByAddress(address pynthAddress) external view returns (bytes32) {\r\n        return issuer().pynthsByAddress(pynthAddress);\r\n    }\r\n\r\n    function isWaitingPeriod(bytes32 currencyKey) external view returns (bool) {\r\n        return exchanger().maxSecsLeftInWaitingPeriod(messageSender, currencyKey) > 0;\r\n    }\r\n\r\n    function anyPynthOrPERIRateIsInvalid() external view returns (bool anyRateInvalid) {\r\n        return issuer().anyPynthOrPERIRateIsInvalid();\r\n    }\r\n\r\n    function maxIssuablePynths(address account) external view returns (uint maxIssuable) {\r\n        return issuer().maxIssuablePynths(account);\r\n    }\r\n\r\n    function remainingIssuablePynths(address account)\r\n        external\r\n        view\r\n        returns (\r\n            uint maxIssuable,\r\n            uint alreadyIssued,\r\n            uint totalSystemDebt\r\n        )\r\n    {\r\n        return issuer().remainingIssuablePynths(account);\r\n    }\r\n\r\n    function collateralisationRatio(address _issuer) external view returns (uint) {\r\n        return issuer().collateralisationRatio(_issuer);\r\n    }\r\n\r\n    function collateral(address account) external view returns (uint) {\r\n        return issuer().collateral(account);\r\n    }\r\n\r\n    function transferablePeriFinance(address account) external view returns (uint transferable) {\r\n        (transferable, ) = issuer().transferablePeriFinanceAndAnyRateIsInvalid(account, tokenState.balanceOf(account));\r\n    }\r\n\r\n    function _canTransfer(address account, uint value) internal view returns (bool) {\r\n        require(!_isLocked(account, value), \"PERI : Locked balance\");\r\n\r\n        (uint initialDebtOwnership, ) = periFinanceState().issuanceData(account);\r\n\r\n        if (initialDebtOwnership > 0) {\r\n            (uint transferable, bool anyRateIsInvalid) =\r\n                issuer().transferablePeriFinanceAndAnyRateIsInvalid(account, tokenState.balanceOf(account));\r\n            require(value <= transferable, \"Cannot transfer staked or escrowed PERI\");\r\n            require(!anyRateIsInvalid, \"A pynth or PERI rate is invalid\");\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function setLock(\r\n        address account,\r\n        uint delay,\r\n        uint iterations,\r\n        uint totalLockAmount,\r\n        uint interval\r\n    ) external onlyOwner {\r\n        uint _startTime = delay.add(block.timestamp);\r\n        uint _endTime = _startTime.add(iterations.mul(interval));\r\n\r\n        lockStates[account] = LockState(account, _startTime, iterations, totalLockAmount, interval, _endTime);\r\n\r\n        emit LockChanged(account, _startTime, iterations, totalLockAmount, interval, _endTime);\r\n    }\r\n\r\n    function resetLock(address account) external onlyOwner {\r\n        delete lockStates[account];\r\n        emit LockChanged(account, 0, 0, 0, 0, 0);\r\n    }\r\n\r\n    function getLock(address account)\r\n        public\r\n        view\r\n        returns (\r\n            address,\r\n            uint,\r\n            uint,\r\n            uint,\r\n            uint,\r\n            uint\r\n        )\r\n    {\r\n        return (\r\n            lockStates[account].account,\r\n            lockStates[account].startTime,\r\n            lockStates[account].iterations,\r\n            lockStates[account].totalAmount,\r\n            lockStates[account].unitTime,\r\n            lockStates[account].endTime\r\n        );\r\n    }\r\n\r\n    function getLockCalculation(address account) public view returns (uint, uint) {\r\n        LockState memory userLockInfo = lockStates[account];\r\n\r\n        // Releasing is not started yet, or user is not locked\r\n        if (userLockInfo.startTime > block.timestamp || userLockInfo.startTime == 0) {\r\n            return (userLockInfo.iterations, userLockInfo.totalAmount);\r\n        }\r\n\r\n        uint iterRemains = (userLockInfo.endTime.sub(block.timestamp)).div(userLockInfo.unitTime);\r\n        uint lockAmount = userLockInfo.totalAmount.mul(iterRemains).div(userLockInfo.iterations);\r\n\r\n        return (iterRemains, lockAmount);\r\n    }\r\n\r\n    function _isLocked(address account, uint amount) internal view returns (bool) {\r\n        LockState memory userLockInfo = lockStates[account];\r\n\r\n        // Account is not locked\r\n        if (userLockInfo.startTime == 0 || userLockInfo.endTime < block.timestamp) {\r\n            return false;\r\n        }\r\n\r\n        // Releasing is not started yet\r\n        if (userLockInfo.startTime > block.timestamp) {\r\n            return true;\r\n        }\r\n\r\n        (, uint lockAmount) = getLockCalculation(account);\r\n        uint accountBalance = tokenState.balanceOf(account);\r\n\r\n        // Account's remained balance may less than lock amount\r\n        if (accountBalance.sub(amount) < lockAmount) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    // ========== MUTATIVE FUNCTIONS ==========\r\n\r\n    function exchange(\r\n        bytes32 sourceCurrencyKey,\r\n        uint sourceAmount,\r\n        bytes32 destinationCurrencyKey\r\n    ) external exchangeActive(sourceCurrencyKey, destinationCurrencyKey) optionalProxy returns (uint amountReceived) {\r\n        _notImplemented();\r\n        return exchanger().exchange(messageSender, sourceCurrencyKey, sourceAmount, destinationCurrencyKey, messageSender);\r\n    }\r\n\r\n    function exchangeOnBehalf(\r\n        address exchangeForAddress,\r\n        bytes32 sourceCurrencyKey,\r\n        uint sourceAmount,\r\n        bytes32 destinationCurrencyKey\r\n    ) external exchangeActive(sourceCurrencyKey, destinationCurrencyKey) optionalProxy returns (uint amountReceived) {\r\n        _notImplemented();\r\n        return\r\n            exchanger().exchangeOnBehalf(\r\n                exchangeForAddress,\r\n                messageSender,\r\n                sourceCurrencyKey,\r\n                sourceAmount,\r\n                destinationCurrencyKey\r\n            );\r\n    }\r\n\r\n    function settle(bytes32 currencyKey)\r\n        external\r\n        optionalProxy\r\n        returns (\r\n            uint reclaimed,\r\n            uint refunded,\r\n            uint numEntriesSettled\r\n        )\r\n    {\r\n        _notImplemented();\r\n        return exchanger().settle(messageSender, currencyKey);\r\n    }\r\n\r\n    function exchangeWithTracking(\r\n        bytes32 sourceCurrencyKey,\r\n        uint sourceAmount,\r\n        bytes32 destinationCurrencyKey,\r\n        address originator,\r\n        bytes32 trackingCode\r\n    ) external exchangeActive(sourceCurrencyKey, destinationCurrencyKey) optionalProxy returns (uint amountReceived) {\r\n        _notImplemented();\r\n        return\r\n            exchanger().exchangeWithTracking(\r\n                messageSender,\r\n                sourceCurrencyKey,\r\n                sourceAmount,\r\n                destinationCurrencyKey,\r\n                messageSender,\r\n                originator,\r\n                trackingCode\r\n            );\r\n    }\r\n\r\n    function exchangeOnBehalfWithTracking(\r\n        address exchangeForAddress,\r\n        bytes32 sourceCurrencyKey,\r\n        uint sourceAmount,\r\n        bytes32 destinationCurrencyKey,\r\n        address originator,\r\n        bytes32 trackingCode\r\n    ) external exchangeActive(sourceCurrencyKey, destinationCurrencyKey) optionalProxy returns (uint amountReceived) {\r\n        _notImplemented();\r\n        return\r\n            exchanger().exchangeOnBehalfWithTracking(\r\n                exchangeForAddress,\r\n                messageSender,\r\n                sourceCurrencyKey,\r\n                sourceAmount,\r\n                destinationCurrencyKey,\r\n                originator,\r\n                trackingCode\r\n            );\r\n    }\r\n\r\n    function transfer(address to, uint value) external optionalProxy systemActive returns (bool) {\r\n        // Ensure they're not trying to exceed their locked amount -- only if they have debt.\r\n        _canTransfer(messageSender, value);\r\n\r\n        // Perform the transfer: if there is a problem an exception will be thrown in this call.\r\n        _transferByProxy(messageSender, to, value);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint value\r\n    ) external optionalProxy systemActive returns (bool) {\r\n        // Ensure they're not trying to exceed their locked amount -- only if they have debt.\r\n        _canTransfer(from, value);\r\n\r\n        // Perform the transfer: if there is a problem,\r\n        // an exception will be thrown in this call.\r\n        return _transferFromByProxy(messageSender, from, to, value);\r\n    }\r\n\r\n    function issuePynths(uint amount) external issuanceActive optionalProxy {\r\n        return issuer().issuePynths(messageSender, amount);\r\n    }\r\n\r\n    function issuePynthsOnBehalf(address issueForAddress, uint amount) external issuanceActive optionalProxy {\r\n        return issuer().issuePynthsOnBehalf(issueForAddress, messageSender, amount);\r\n    }\r\n\r\n    function issueMaxPynths() external issuanceActive optionalProxy {\r\n        return issuer().issueMaxPynths(messageSender);\r\n    }\r\n\r\n    function issueMaxPynthsOnBehalf(address issueForAddress) external issuanceActive optionalProxy {\r\n        return issuer().issueMaxPynthsOnBehalf(issueForAddress, messageSender);\r\n    }\r\n\r\n    function stakeUSDCAndIssuePynths(uint usdcStakeAmount, uint issueAmount) external issuanceActive optionalProxy {\r\n        return issuer().stakeUSDCAndIssuePynths(messageSender, usdcStakeAmount, issueAmount);\r\n    }\r\n\r\n    function stakeUSDCAndIssueMaxPynths(uint usdcStakeAmount) external issuanceActive optionalProxy {\r\n        return issuer().stakeUSDCAndIssueMaxPynths(messageSender, usdcStakeAmount);\r\n    }\r\n\r\n    function burnPynths(uint amount) external issuanceActive optionalProxy {\r\n        return issuer().burnPynths(messageSender, amount);\r\n    }\r\n\r\n    function burnPynthsOnBehalf(address burnForAddress, uint amount) external issuanceActive optionalProxy {\r\n        return issuer().burnPynthsOnBehalf(burnForAddress, messageSender, amount);\r\n    }\r\n\r\n    function burnPynthsToTarget() external issuanceActive optionalProxy {\r\n        return issuer().burnPynthsToTarget(messageSender);\r\n    }\r\n\r\n    function burnPynthsToTargetOnBehalf(address burnForAddress) external issuanceActive optionalProxy {\r\n        return issuer().burnPynthsToTargetOnBehalf(burnForAddress, messageSender);\r\n    }\r\n\r\n    function unstakeUSDCAndBurnPynths(uint usdcUnstakeAmount, uint burnAmount) external issuanceActive optionalProxy {\r\n        return issuer().unstakeUSDCAndBurnPynths(messageSender, usdcUnstakeAmount, burnAmount);\r\n    }\r\n\r\n    function unstakeUSDCToMaxAndBurnPynths(uint burnAmount) external issuanceActive optionalProxy {\r\n        return issuer().unstakeUSDCToMaxAndBurnPynths(messageSender, burnAmount);\r\n    }\r\n\r\n    function exchangeWithVirtual(\r\n        bytes32,\r\n        uint,\r\n        bytes32,\r\n        bytes32\r\n    ) external returns (uint, IVirtualPynth) {\r\n        _notImplemented();\r\n    }\r\n\r\n    function mint() external returns (bool) {\r\n        _notImplemented();\r\n    }\r\n\r\n    function liquidateDelinquentAccount(address, uint) external returns (bool) {\r\n        _notImplemented();\r\n    }\r\n\r\n    function mintSecondary(address, uint) external {\r\n        _notImplemented();\r\n    }\r\n\r\n    function mintSecondaryRewards(uint) external {\r\n        _notImplemented();\r\n    }\r\n\r\n    function burnSecondary(address, uint) external {\r\n        _notImplemented();\r\n    }\r\n\r\n    function _notImplemented() internal pure {\r\n        revert(\"Cannot be run on this layer\");\r\n    }\r\n\r\n    // ========== MODIFIERS ==========\r\n\r\n    modifier systemActive() {\r\n        _systemActive();\r\n        _;\r\n    }\r\n\r\n    function _systemActive() private {\r\n        systemStatus().requireSystemActive();\r\n    }\r\n\r\n    modifier issuanceActive() {\r\n        _issuanceActive();\r\n        _;\r\n    }\r\n\r\n    function _issuanceActive() private {\r\n        systemStatus().requireIssuanceActive();\r\n    }\r\n\r\n    modifier exchangeActive(bytes32 src, bytes32 dest) {\r\n        _exchangeActive(src, dest);\r\n        _;\r\n    }\r\n\r\n    function _exchangeActive(bytes32 src, bytes32 dest) private {\r\n        systemStatus().requireExchangeBetweenPynthsAllowed(src, dest);\r\n    }\r\n\r\n    modifier onlyExchanger() {\r\n        _onlyExchanger();\r\n        _;\r\n    }\r\n\r\n    function _onlyExchanger() private {\r\n        require(msg.sender == address(exchanger()), \"Only Exchanger can invoke this\");\r\n    }\r\n\r\n    // ========== EVENTS ==========\r\n    event PynthExchange(\r\n        address indexed account,\r\n        bytes32 fromCurrencyKey,\r\n        uint256 fromAmount,\r\n        bytes32 toCurrencyKey,\r\n        uint256 toAmount,\r\n        address toAddress\r\n    );\r\n    bytes32 internal constant PYNTHEXCHANGE_SIG =\r\n        keccak256(\"PynthExchange(address,bytes32,uint256,bytes32,uint256,address)\");\r\n\r\n    function emitPynthExchange(\r\n        address account,\r\n        bytes32 fromCurrencyKey,\r\n        uint256 fromAmount,\r\n        bytes32 toCurrencyKey,\r\n        uint256 toAmount,\r\n        address toAddress\r\n    ) external onlyExchanger {\r\n        proxy._emit(\r\n            abi.encode(fromCurrencyKey, fromAmount, toCurrencyKey, toAmount, toAddress),\r\n            2,\r\n            PYNTHEXCHANGE_SIG,\r\n            addressToBytes32(account),\r\n            0,\r\n            0\r\n        );\r\n    }\r\n\r\n    event ExchangeTracking(bytes32 indexed trackingCode, bytes32 toCurrencyKey, uint256 toAmount);\r\n    bytes32 internal constant EXCHANGE_TRACKING_SIG = keccak256(\"ExchangeTracking(bytes32,bytes32,uint256)\");\r\n\r\n    function emitExchangeTracking(\r\n        bytes32 trackingCode,\r\n        bytes32 toCurrencyKey,\r\n        uint256 toAmount\r\n    ) external onlyExchanger {\r\n        proxy._emit(abi.encode(toCurrencyKey, toAmount), 2, EXCHANGE_TRACKING_SIG, trackingCode, 0, 0);\r\n    }\r\n\r\n    event ExchangeReclaim(address indexed account, bytes32 currencyKey, uint amount);\r\n    bytes32 internal constant EXCHANGERECLAIM_SIG = keccak256(\"ExchangeReclaim(address,bytes32,uint256)\");\r\n\r\n    function emitExchangeReclaim(\r\n        address account,\r\n        bytes32 currencyKey,\r\n        uint256 amount\r\n    ) external onlyExchanger {\r\n        proxy._emit(abi.encode(currencyKey, amount), 2, EXCHANGERECLAIM_SIG, addressToBytes32(account), 0, 0);\r\n    }\r\n\r\n    event ExchangeRebate(address indexed account, bytes32 currencyKey, uint amount);\r\n    bytes32 internal constant EXCHANGEREBATE_SIG = keccak256(\"ExchangeRebate(address,bytes32,uint256)\");\r\n\r\n    function emitExchangeRebate(\r\n        address account,\r\n        bytes32 currencyKey,\r\n        uint256 amount\r\n    ) external onlyExchanger {\r\n        proxy._emit(abi.encode(currencyKey, amount), 2, EXCHANGEREBATE_SIG, addressToBytes32(account), 0, 0);\r\n    }\r\n}\r\n\r\n\r\n// https://docs.peri.finance/contracts/source/interfaces/irewardescrow\r\ninterface IRewardEscrow {\r\n    // Views\r\n    function balanceOf(address account) external view returns (uint);\r\n\r\n    function numVestingEntries(address account) external view returns (uint);\r\n\r\n    function totalEscrowedAccountBalance(address account) external view returns (uint);\r\n\r\n    function totalVestedAccountBalance(address account) external view returns (uint);\r\n\r\n    function getVestingScheduleEntry(address account, uint index) external view returns (uint[2] memory);\r\n\r\n    function getNextVestingIndex(address account) external view returns (uint);\r\n\r\n    // Mutative functions\r\n    function appendVestingEntry(address account, uint quantity) external;\r\n\r\n    function vest() external;\r\n}\r\n\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\nlibrary VestingEntries {\r\n    struct VestingEntry {\r\n        uint64 endTime;\r\n        uint256 escrowAmount;\r\n    }\r\n    struct VestingEntryWithID {\r\n        uint64 endTime;\r\n        uint256 escrowAmount;\r\n        uint256 entryID;\r\n    }\r\n}\r\n\r\ninterface IRewardEscrowV2 {\r\n    // Views\r\n    function balanceOf(address account) external view returns (uint);\r\n\r\n    function numVestingEntries(address account) external view returns (uint);\r\n\r\n    function totalEscrowedAccountBalance(address account) external view returns (uint);\r\n\r\n    function totalVestedAccountBalance(address account) external view returns (uint);\r\n\r\n    function getVestingQuantity(address account, uint256[] calldata entryIDs) external view returns (uint);\r\n\r\n    function getVestingSchedules(\r\n        address account,\r\n        uint256 index,\r\n        uint256 pageSize\r\n    ) external view returns (VestingEntries.VestingEntryWithID[] memory);\r\n\r\n    function getAccountVestingEntryIDs(\r\n        address account,\r\n        uint256 index,\r\n        uint256 pageSize\r\n    ) external view returns (uint256[] memory);\r\n\r\n    function getVestingEntryClaimable(address account, uint256 entryID) external view returns (uint);\r\n\r\n    function getVestingEntry(address account, uint256 entryID) external view returns (uint64, uint256);\r\n\r\n    // Mutative functions\r\n    function vest(uint256[] calldata entryIDs) external;\r\n\r\n    function createEscrowEntry(\r\n        address beneficiary,\r\n        uint256 deposit,\r\n        uint256 duration\r\n    ) external;\r\n\r\n    function appendVestingEntry(\r\n        address account,\r\n        uint256 quantity,\r\n        uint256 duration\r\n    ) external;\r\n\r\n    function migrateVestingSchedule(address _addressToMigrate) external;\r\n\r\n    function migrateAccountEscrowBalances(\r\n        address[] calldata accounts,\r\n        uint256[] calldata escrowBalances,\r\n        uint256[] calldata vestedBalances\r\n    ) external;\r\n\r\n    // Account Merging\r\n    function startMergingWindow() external;\r\n\r\n    function mergeAccount(address accountToMerge, uint256[] calldata entryIDs) external;\r\n\r\n    function nominateAccountToMerge(address account) external;\r\n\r\n    function accountMergingIsOpen() external view returns (bool);\r\n\r\n    // L2 Migration\r\n    function importVestingEntries(\r\n        address account,\r\n        uint256 escrowedAmount,\r\n        VestingEntries.VestingEntry[] calldata vestingEntries\r\n    ) external;\r\n\r\n    // Return amount of PERI transfered to PynthetixBridgeToOptimism deposit contract\r\n    function burnForMigration(address account, uint256[] calldata entryIDs)\r\n        external\r\n        returns (uint256 escrowedAccountBalance, VestingEntries.VestingEntry[] memory vestingEntries);\r\n}\r\n\r\n\r\n// https://docs.peri.finance/contracts/source/interfaces/isupplyschedule\r\ninterface ISupplySchedule {\r\n    // Views\r\n    function mintableSupply() external view returns (uint);\r\n\r\n    function isMintable() external view returns (bool);\r\n\r\n    function minterReward() external view returns (uint);\r\n\r\n    // Mutative functions\r\n    function recordMintEvent(uint supplyMinted) external returns (bool);\r\n}\r\n\r\n\r\n// Inheritance\r\n\r\n\r\n// Internal references\r\n\r\n\r\n// https://docs.peri.finance/contracts/source/contracts/periFinance\r\ncontract PeriFinance is BasePeriFinance {\r\n    // ========== ADDRESS RESOLVER CONFIGURATION ==========\r\n    bytes32 private constant CONTRACT_REWARD_ESCROW = \"RewardEscrow\";\r\n    bytes32 private constant CONTRACT_REWARDESCROW_V2 = \"RewardEscrowV2\";\r\n    bytes32 private constant CONTRACT_SUPPLYSCHEDULE = \"SupplySchedule\";\r\n\r\n    // ========== CONSTRUCTOR ==========\r\n\r\n    constructor(\r\n        address payable _proxy,\r\n        TokenState _tokenState,\r\n        address _owner,\r\n        uint _totalSupply,\r\n        address _resolver\r\n    ) public BasePeriFinance(_proxy, _tokenState, _owner, _totalSupply, _resolver) {}\r\n\r\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {\r\n        bytes32[] memory existingAddresses = BasePeriFinance.resolverAddressesRequired();\r\n        bytes32[] memory newAddresses = new bytes32[](3);\r\n        newAddresses[0] = CONTRACT_REWARD_ESCROW;\r\n        newAddresses[1] = CONTRACT_REWARDESCROW_V2;\r\n        newAddresses[2] = CONTRACT_SUPPLYSCHEDULE;\r\n        return combineArrays(existingAddresses, newAddresses);\r\n    }\r\n\r\n    // ========== VIEWS ==========\r\n\r\n    function rewardEscrow() internal view returns (IRewardEscrow) {\r\n        return IRewardEscrow(requireAndGetAddress(CONTRACT_REWARD_ESCROW));\r\n    }\r\n\r\n    function rewardEscrowV2() internal view returns (IRewardEscrowV2) {\r\n        return IRewardEscrowV2(requireAndGetAddress(CONTRACT_REWARDESCROW_V2));\r\n    }\r\n\r\n    function supplySchedule() internal view returns (ISupplySchedule) {\r\n        return ISupplySchedule(requireAndGetAddress(CONTRACT_SUPPLYSCHEDULE));\r\n    }\r\n\r\n    // ========== OVERRIDDEN FUNCTIONS ==========\r\n\r\n    function exchangeWithVirtual(\r\n        bytes32 sourceCurrencyKey,\r\n        uint sourceAmount,\r\n        bytes32 destinationCurrencyKey,\r\n        bytes32 trackingCode\r\n    )\r\n        external\r\n        exchangeActive(sourceCurrencyKey, destinationCurrencyKey)\r\n        optionalProxy\r\n        returns (uint amountReceived, IVirtualPynth vPynth)\r\n    {\r\n        _notImplemented();\r\n        return\r\n            exchanger().exchangeWithVirtual(\r\n                messageSender,\r\n                sourceCurrencyKey,\r\n                sourceAmount,\r\n                destinationCurrencyKey,\r\n                messageSender,\r\n                trackingCode\r\n            );\r\n    }\r\n\r\n    function settle(bytes32 currencyKey)\r\n        external\r\n        optionalProxy\r\n        returns (\r\n            uint reclaimed,\r\n            uint refunded,\r\n            uint numEntriesSettled\r\n        )\r\n    {\r\n        _notImplemented();\r\n        return exchanger().settle(messageSender, currencyKey);\r\n    }\r\n\r\n    function mint() external issuanceActive returns (bool) {\r\n        require(address(rewardsDistribution()) != address(0), \"RewardsDistribution not set\");\r\n\r\n        ISupplySchedule _supplySchedule = supplySchedule();\r\n        IRewardsDistribution _rewardsDistribution = rewardsDistribution();\r\n\r\n        uint supplyToMint = _supplySchedule.mintableSupply();\r\n        require(supplyToMint > 0, \"No supply is mintable\");\r\n\r\n        // record minting event before mutation to token supply\r\n        _supplySchedule.recordMintEvent(supplyToMint);\r\n\r\n        // Set minted PERI balance to RewardEscrow's balance\r\n        // Minus the minterReward and set balance of minter to add reward\r\n        uint minterReward = _supplySchedule.minterReward();\r\n        // Get the remainder\r\n        uint amountToDistribute = supplyToMint.sub(minterReward);\r\n\r\n        // Set the token balance to the RewardsDistribution contract\r\n        tokenState.setBalanceOf(\r\n            address(_rewardsDistribution),\r\n            tokenState.balanceOf(address(_rewardsDistribution)).add(amountToDistribute)\r\n        );\r\n        emitTransfer(address(this), address(_rewardsDistribution), amountToDistribute);\r\n\r\n        // Kick off the distribution of rewards\r\n        _rewardsDistribution.distributeRewards(amountToDistribute);\r\n\r\n        // Assign the minters reward.\r\n        tokenState.setBalanceOf(msg.sender, tokenState.balanceOf(msg.sender).add(minterReward));\r\n        emitTransfer(address(this), msg.sender, minterReward);\r\n\r\n        totalSupply = totalSupply.add(supplyToMint);\r\n\r\n        return true;\r\n    }\r\n\r\n    function liquidateDelinquentAccount(address account, uint pusdAmount)\r\n        external\r\n        systemActive\r\n        optionalProxy\r\n        returns (bool)\r\n    {\r\n        _notImplemented();\r\n        (uint totalRedeemed, uint amountLiquidated) =\r\n            issuer().liquidateDelinquentAccount(account, pusdAmount, messageSender);\r\n\r\n        emitAccountLiquidated(account, totalRedeemed, amountLiquidated, messageSender);\r\n\r\n        // Transfer PERI redeemed to messageSender\r\n        // Reverts if amount to redeem is more than balanceOf account, ie due to escrowed balance\r\n        return _transferByProxy(account, messageSender, totalRedeemed);\r\n    }\r\n\r\n    /* Once off function for SIP-60 to migrate PERI balances in the RewardEscrow contract\r\n     * To the new RewardEscrowV2 contract\r\n     */\r\n    function migrateEscrowBalanceToRewardEscrowV2() external onlyOwner {\r\n        // Record balanceOf(RewardEscrow) contract\r\n        uint rewardEscrowBalance = tokenState.balanceOf(address(rewardEscrow()));\r\n\r\n        // transfer all of RewardEscrow's balance to RewardEscrowV2\r\n        // _internalTransfer emits the transfer event\r\n        _internalTransfer(address(rewardEscrow()), address(rewardEscrowV2()), rewardEscrowBalance);\r\n    }\r\n\r\n    // ========== EVENTS ==========\r\n    event AccountLiquidated(address indexed account, uint periRedeemed, uint amountLiquidated, address liquidator);\r\n    bytes32 internal constant ACCOUNTLIQUIDATED_SIG = keccak256(\"AccountLiquidated(address,uint256,uint256,address)\");\r\n\r\n    function emitAccountLiquidated(\r\n        address account,\r\n        uint256 periRedeemed,\r\n        uint256 amountLiquidated,\r\n        address liquidator\r\n    ) internal {\r\n        proxy._emit(\r\n            abi.encode(periRedeemed, amountLiquidated, liquidator),\r\n            2,\r\n            ACCOUNTLIQUIDATED_SIG,\r\n            addressToBytes32(account),\r\n            0,\r\n            0\r\n        );\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_proxy\",\"type\":\"address\"},{\"internalType\":\"contract TokenState\",\"name\":\"_tokenState\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_resolver\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"periRedeemed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountLiquidated\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"}],\"name\":\"AccountLiquidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"CacheUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ExchangeRebate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ExchangeReclaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"trackingCode\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"toCurrencyKey\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toAmount\",\"type\":\"uint256\"}],\"name\":\"ExchangeTracking\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"iterations\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unitTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"LockChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerNominated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proxyAddress\",\"type\":\"address\"}],\"name\":\"ProxyUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"fromCurrencyKey\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"toCurrencyKey\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"}],\"name\":\"PynthExchange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newTokenState\",\"type\":\"address\"}],\"name\":\"TokenStateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"DECIMALS\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_SYMBOL\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"anyPynthOrPERIRateIsInvalid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"anyRateInvalid\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"availableCurrencyKeys\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"availablePynthCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"availablePynths\",\"outputs\":[{\"internalType\":\"contract IPynth\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnPynths\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"burnForAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnPynthsOnBehalf\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"burnPynthsToTarget\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"burnForAddress\",\"type\":\"address\"}],\"name\":\"burnPynthsToTargetOnBehalf\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"burnSecondary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"collateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_issuer\",\"type\":\"address\"}],\"name\":\"collateralisationRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"}],\"name\":\"debtBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"emitExchangeRebate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"emitExchangeReclaim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"trackingCode\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"toCurrencyKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"toAmount\",\"type\":\"uint256\"}],\"name\":\"emitExchangeTracking\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"fromCurrencyKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"fromAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"toCurrencyKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"toAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"}],\"name\":\"emitPynthExchange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sourceCurrencyKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"sourceAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"destinationCurrencyKey\",\"type\":\"bytes32\"}],\"name\":\"exchange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountReceived\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"exchangeForAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"sourceCurrencyKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"sourceAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"destinationCurrencyKey\",\"type\":\"bytes32\"}],\"name\":\"exchangeOnBehalf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountReceived\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"exchangeForAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"sourceCurrencyKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"sourceAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"destinationCurrencyKey\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"originator\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"trackingCode\",\"type\":\"bytes32\"}],\"name\":\"exchangeOnBehalfWithTracking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountReceived\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sourceCurrencyKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"sourceAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"destinationCurrencyKey\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"originator\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"trackingCode\",\"type\":\"bytes32\"}],\"name\":\"exchangeWithTracking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountReceived\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sourceCurrencyKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"sourceAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"destinationCurrencyKey\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"trackingCode\",\"type\":\"bytes32\"}],\"name\":\"exchangeWithVirtual\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountReceived\",\"type\":\"uint256\"},{\"internalType\":\"contract IVirtualPynth\",\"name\":\"vPynth\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getLock\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getLockCalculation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"integrationProxy\",\"outputs\":[{\"internalType\":\"contract Proxy\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isResolverCached\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"}],\"name\":\"isWaitingPeriod\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"issueMaxPynths\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"issueForAddress\",\"type\":\"address\"}],\"name\":\"issueMaxPynthsOnBehalf\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"issuePynths\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"issueForAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"issuePynthsOnBehalf\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pusdAmount\",\"type\":\"uint256\"}],\"name\":\"liquidateDelinquentAccount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lockStates\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"iterations\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unitTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"maxIssuablePynths\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maxIssuable\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"messageSender\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"migrateEscrowBalanceToRewardEscrowV2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mintSecondary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mintSecondaryRewards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"nominateNewOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nominatedOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pUSD\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxy\",\"outputs\":[{\"internalType\":\"contract Proxy\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"}],\"name\":\"pynths\",\"outputs\":[{\"internalType\":\"contract IPynth\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"pynthAddress\",\"type\":\"address\"}],\"name\":\"pynthsByAddress\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"rebuildCache\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"remainingIssuablePynths\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maxIssuable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"alreadyIssued\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSystemDebt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"resetLock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"resolver\",\"outputs\":[{\"internalType\":\"contract AddressResolver\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"resolverAddressesRequired\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"addresses\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_integrationProxy\",\"type\":\"address\"}],\"name\":\"setIntegrationProxy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"delay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"iterations\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalLockAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interval\",\"type\":\"uint256\"}],\"name\":\"setLock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"setMessageSender\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_proxy\",\"type\":\"address\"}],\"name\":\"setProxy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"_tokenState\",\"type\":\"address\"}],\"name\":\"setTokenState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"}],\"name\":\"settle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reclaimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refunded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numEntriesSettled\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"usdcStakeAmount\",\"type\":\"uint256\"}],\"name\":\"stakeUSDCAndIssueMaxPynths\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"usdcStakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"issueAmount\",\"type\":\"uint256\"}],\"name\":\"stakeUSDCAndIssuePynths\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenState\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"}],\"name\":\"totalIssuedPynths\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"}],\"name\":\"totalIssuedPynthsExcludeEtherCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"transferablePeriFinance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"transferable\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"usdcUnstakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burnAmount\",\"type\":\"uint256\"}],\"name\":\"unstakeUSDCAndBurnPynths\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"burnAmount\",\"type\":\"uint256\"}],\"name\":\"unstakeUSDCToMaxAndBurnPynths\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"PeriFinance","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000005d30ad9c6374bf925d0a75454fa327aacf77849200000000000000000000000040ee175b073a1ac2a5dd02695c9a9612973c317a000000000000000000000000918153d6e806df9d4d33664d1cc580416171f720000000000000000000000000000000000000000000b20ed4c9688f57ffdae46d000000000000000000000000b8aa8820da9f999ba3b3dbb7f08f07cc1c8fa933","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://a366d60ad5da58d33b13bbd1ff543e55ea1ff3df98ad8824fe17b594c15949a4"}]}