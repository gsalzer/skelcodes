{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/CentaurSettlement.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity =0.6.12;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport './libraries/SafeMath.sol';\\r\\nimport './interfaces/ICentaurFactory.sol';\\r\\nimport './interfaces/ICentaurPool.sol';\\r\\nimport './interfaces/ICentaurSettlement.sol';\\r\\n\\r\\ncontract CentaurSettlement is ICentaurSettlement {\\r\\n\\r\\n\\tusing SafeMath for uint;\\r\\n\\r\\n\\tbytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\\r\\n\\r\\n\\taddress public override factory;\\r\\n\\tuint public override settlementDuration;\\r\\n\\r\\n\\t// User address -> Token address -> Settlement\\r\\n\\tmapping(address => mapping (address => Settlement)) pendingSettlement;\\r\\n\\r\\n\\tmodifier onlyFactory() {\\r\\n        require(msg.sender == factory, 'CentaurSwap: ONLY_FACTORY_ALLOWED');\\r\\n        _;\\r\\n    }\\r\\n\\r\\n\\tconstructor (address _factory, uint _settlementDuration) public {\\r\\n\\t\\tfactory = _factory;\\r\\n\\t\\tsettlementDuration = _settlementDuration;\\r\\n\\t}\\r\\n\\r\\n\\tfunction _safeTransfer(address token, address to, uint value) private {\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\\r\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'CentaurSwap: TRANSFER_FAILED');\\r\\n    }\\r\\n\\r\\n\\tfunction addSettlement(\\r\\n\\t\\taddress _sender,\\r\\n\\t\\tSettlement memory _pendingSettlement\\r\\n\\t) external override {\\r\\n\\t\\trequire(ICentaurFactory(factory).isValidPool(_pendingSettlement.fPool), 'CentaurSwap: POOL_NOT_FOUND');\\r\\n\\t\\trequire(ICentaurFactory(factory).isValidPool(_pendingSettlement.tPool), 'CentaurSwap: POOL_NOT_FOUND');\\r\\n\\r\\n\\t\\trequire(msg.sender == _pendingSettlement.tPool, 'CentaurSwap: INVALID_POOL');\\r\\n\\r\\n\\t\\trequire(pendingSettlement[_sender][_pendingSettlement.fPool].settlementTimestamp == 0, 'CentaurSwap: SETTLEMENT_EXISTS');\\r\\n\\t\\trequire(pendingSettlement[_sender][_pendingSettlement.tPool].settlementTimestamp == 0, 'CentaurSwap: SETTLEMENT_EXISTS');\\r\\n\\r\\n\\t\\tpendingSettlement[_sender][_pendingSettlement.fPool] = _pendingSettlement;\\r\\n\\t\\tpendingSettlement[_sender][_pendingSettlement.tPool] = _pendingSettlement;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction removeSettlement(\\r\\n\\t\\taddress _sender,\\r\\n\\t\\taddress _fPool,\\r\\n\\t\\taddress _tPool\\r\\n\\t) external override {\\r\\n\\t\\trequire(msg.sender == _tPool, 'CentaurSwap: INVALID_POOL');\\r\\n\\r\\n\\t\\trequire(pendingSettlement[_sender][_fPool].settlementTimestamp != 0, 'CentaurSwap: SETTLEMENT_DOES_NOT_EXISTS');\\r\\n\\t\\trequire(pendingSettlement[_sender][_tPool].settlementTimestamp != 0, 'CentaurSwap: SETTLEMENT_DOES_NOT_EXISTS');\\r\\n\\r\\n\\t\\trequire(block.timestamp >= pendingSettlement[_sender][_fPool].settlementTimestamp, 'CentaurSwap: SETTLEMENT_PENDING');\\r\\n\\r\\n\\t\\t_safeTransfer(ICentaurPool(_tPool).baseToken(), _tPool, pendingSettlement[_sender][_fPool].maxAmountOut);\\r\\n\\r\\n\\t\\tdelete pendingSettlement[_sender][_fPool];\\r\\n\\t\\tdelete pendingSettlement[_sender][_tPool];\\r\\n\\t}\\r\\n\\r\\n\\tfunction getPendingSettlement(address _sender, address _pool) external override view returns (Settlement memory) {\\r\\n\\t\\treturn pendingSettlement[_sender][_pool];\\r\\n\\t}\\r\\n\\t\\r\\n\\tfunction hasPendingSettlement(address _sender, address _pool) external override view returns (bool) {\\r\\n\\t\\treturn (pendingSettlement[_sender][_pool].settlementTimestamp != 0);\\r\\n\\t}\\r\\n\\r\\n\\t// Helper Functions\\r\\n\\tfunction setSettlementDuration(uint _settlementDuration) onlyFactory external override {\\r\\n\\t\\tsettlementDuration = _settlementDuration;\\r\\n\\t}\\r\\n}\"\r\n    },\r\n    \"contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.6.0 <0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it's recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b <= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n        // benefit is lost if 'b' is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b > 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ICentaurFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.5.0;\\r\\n\\r\\ninterface ICentaurFactory {\\r\\n    event PoolCreated(address indexed token, address pool, uint);\\r\\n\\r\\n    function poolFee() external view returns (uint);\\r\\n\\r\\n    function poolLogic() external view returns (address);\\r\\n    function cloneFactory() external view returns (address);\\r\\n    function settlement() external view returns (address);\\r\\n    function router() external view returns (address payable);\\r\\n\\r\\n    function getPool(address token) external view returns (address pool);\\r\\n    function allPools(uint) external view returns (address pool);\\r\\n    function allPoolsLength() external view returns (uint);\\r\\n    function isValidPool(address pool) external view returns (bool);\\r\\n\\r\\n    function createPool(address token, address oracle, uint poolUtilizationPercentage) external returns (address pool);\\r\\n    function addPool(address pool) external;\\r\\n    function removePool(address pool) external;\\r\\n\\r\\n    function setPoolLiquidityParameter(address, uint) external;\\r\\n    function setPoolTradeEnabled(address, bool) external;\\r\\n    function setPoolDepositEnabled(address, bool) external;\\r\\n    function setPoolWithdrawEnabled(address, bool) external;\\r\\n    function setAllPoolsTradeEnabled(bool) external;\\r\\n    function setAllPoolsDepositEnabled(bool) external;\\r\\n    function setAllPoolsWithdrawEnabled(bool) external;\\r\\n    function emergencyWithdrawFromPool(address, address, uint, address) external;\\r\\n\\r\\n    function setRouterOnlyEOAEnabled(bool) external;\\r\\n    function setRouterContractWhitelist(address, bool) external;\\r\\n\\r\\n    function setSettlementDuration(uint) external;\\r\\n\\r\\n    function setPoolFee(uint) external;\\r\\n    function setPoolLogic(address) external;\\r\\n    function setCloneFactory(address) external;\\r\\n    function setSettlement(address) external;\\r\\n    function setRouter(address payable) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ICentaurPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.5.0;\\r\\n\\r\\ninterface ICentaurPool {\\r\\n    event Approval(address indexed owner, address indexed spender, uint value);\\r\\n    event Transfer(address indexed from, address indexed to, uint value);\\r\\n\\r\\n    function name() external pure returns (string memory);\\r\\n    function symbol() external pure returns (string memory);\\r\\n    function decimals() external pure returns (uint8);\\r\\n    function totalSupply() external view returns (uint);\\r\\n    function balanceOf(address owner) external view returns (uint);\\r\\n    function allowance(address owner, address spender) external view returns (uint);\\r\\n\\r\\n    function approve(address spender, uint value) external returns (bool);\\r\\n    function transfer(address to, uint value) external returns (bool);\\r\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\r\\n\\r\\n    event Mint(address indexed sender, uint amount);\\r\\n    event Burn(address indexed sender, uint amount, address indexed to);\\r\\n    event AmountIn(address indexed sender, uint amount);\\r\\n    event AmountOut(address indexed sender, uint amount, address indexed to);\\r\\n    event EmergencyWithdraw(uint256 _timestamp, address indexed _token, uint256 _amount, address indexed _to);\\r\\n\\r\\n    function factory() external view returns (address);\\r\\n    function settlement() external view returns (address);\\r\\n    function baseToken() external view returns (address);\\r\\n    function baseTokenDecimals() external view returns (uint);\\r\\n    function oracle() external view returns (address);\\r\\n    function oracleDecimals() external view returns (uint);\\r\\n    function baseTokenTargetAmount() external view returns (uint);\\r\\n    function baseTokenBalance() external view returns (uint);\\r\\n    function liquidityParameter() external view returns (uint);\\r\\n\\r\\n    function init(address, address, address, uint) external;\\r\\n\\r\\n    function mint(address to) external returns (uint liquidity);\\r\\n    function burn(address to) external returns (uint amount);\\r\\n\\r\\n    function swapTo(address _sender, address _fromToken, uint _amountIn, uint _value, address _receiver) external returns (uint maxAmount);\\r\\n    function swapFrom(address _sender) external returns (uint amount, uint value);\\r\\n    function swapSettle(address _sender) external returns (uint);\\r\\n\\r\\n    function getOraclePrice() external view returns (uint price);\\r\\n    function getAmountOutFromValue(uint _value) external view returns (uint amount);\\r\\n    function getValueFromAmountIn(uint _amount) external view returns (uint value);\\r\\n    function getAmountInFromValue(uint _value) external view returns (uint amount);\\r\\n    function getValueFromAmountOut(uint _amount) external view returns (uint value);\\r\\n\\r\\n    function setFactory(address) external;\\r\\n    function setTradeEnabled(bool) external;\\r\\n    function setDepositEnabled(bool) external;\\r\\n    function setWithdrawEnabled(bool) external;\\r\\n    function setLiquidityParameter(uint) external;\\r\\n    function emergencyWithdraw(address, uint, address) external;\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/ICentaurSettlement.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.5.0;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\ninterface ICentaurSettlement {\\r\\n    // event SettlementAdded(address indexed sender, address indexed _fromToken, uint _amountIn, address indexed _toToken, uint _amountOut);\\r\\n    // event SettlementRemoved(address indexed sender, address indexed _fromToken, address indexed _toToken);\\r\\n    struct Settlement {\\r\\n        address fPool;\\r\\n        uint amountIn;\\r\\n        uint fPoolBaseTokenTargetAmount;\\r\\n        uint fPoolBaseTokenBalance;\\r\\n        uint fPoolLiquidityParameter;\\r\\n        address tPool;\\r\\n        uint maxAmountOut;\\r\\n        uint tPoolBaseTokenTargetAmount;\\r\\n        uint tPoolBaseTokenBalance;\\r\\n        uint tPoolLiquidityParameter;\\r\\n        address receiver;\\r\\n        uint settlementTimestamp;\\r\\n    }\\r\\n\\r\\n    function factory() external pure returns (address);\\r\\n    function settlementDuration() external pure returns (uint);\\r\\n\\r\\n    function addSettlement(\\r\\n        address _sender,\\r\\n        Settlement memory _pendingSettlement\\r\\n    ) external;\\r\\n    function removeSettlement(address _sender, address _fPool, address _tPool) external;\\r\\n    \\r\\n    function getPendingSettlement(address _sender, address _pool) external view returns (Settlement memory);\\r\\n    function hasPendingSettlement(address _sender, address _pool) external view returns (bool);\\r\\n\\r\\n    function setSettlementDuration(uint) external;\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_settlementDuration\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"fPool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fPoolBaseTokenTargetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fPoolBaseTokenBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fPoolLiquidityParameter\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tPool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tPoolBaseTokenTargetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tPoolBaseTokenBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tPoolLiquidityParameter\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"settlementTimestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct ICentaurSettlement.Settlement\",\"name\":\"_pendingSettlement\",\"type\":\"tuple\"}],\"name\":\"addSettlement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"}],\"name\":\"getPendingSettlement\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"fPool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fPoolBaseTokenTargetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fPoolBaseTokenBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fPoolLiquidityParameter\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tPool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tPoolBaseTokenTargetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tPoolBaseTokenBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tPoolLiquidityParameter\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"settlementTimestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct ICentaurSettlement.Settlement\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"}],\"name\":\"hasPendingSettlement\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_fPool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tPool\",\"type\":\"address\"}],\"name\":\"removeSettlement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_settlementDuration\",\"type\":\"uint256\"}],\"name\":\"setSettlementDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"settlementDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"CentaurSettlement","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000cf97fbeb86c61dfb30286c778c941d0daad2d68f00000000000000000000000000000000000000000000000000000000000000b4","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}