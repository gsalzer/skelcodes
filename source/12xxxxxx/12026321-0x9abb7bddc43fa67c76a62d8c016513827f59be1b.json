{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: This smart contract is guarded by an angry ghost\r\npragma solidity ^0.8.0;\r\n\r\n\r\ncontract POWNFTv3{\r\n\r\n    //v2 Variables\r\n    uint public UNMIGRATED = 0;\r\n    uint public V2_TOTAL = 0;\r\n    bytes32 public PREV_CHAIN_LAST_HASH;\r\n    POWNFTv2 CONTRACT_V2;\r\n\r\n    constructor(address contract_v2){\r\n        supportedInterfaces[0x80ac58cd] = true; //ERC721\r\n        supportedInterfaces[0x5b5e139f] = true; //ERC721Metadata\r\n        supportedInterfaces[0x780e9d63] = true; //ERC721Enumerable\r\n        supportedInterfaces[0x01ffc9a7] = true; //ERC165\r\n\r\n        CONTRACT_V2 = POWNFTv2(contract_v2);\r\n        V2_TOTAL =\r\n        UNMIGRATED = CONTRACT_V2.totalSupply();\r\n        PREV_CHAIN_LAST_HASH = CONTRACT_V2.hashOf(UNMIGRATED);\r\n\r\n    }\r\n\r\n\r\n    //////===721 Standard\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    //////===721 Implementation\r\n    mapping(address => uint256) internal BALANCES;\r\n    mapping (uint256 => address) internal ALLOWANCE;\r\n    mapping (address => mapping (address => bool)) internal AUTHORISED;\r\n\r\n    bytes32[] TOKENS;  //Array of all tokens [hash,hash,...]\r\n    mapping(uint256 => address) OWNERS;  //Mapping of owners\r\n\r\n\r\n    //    METADATA VARS\r\n    string private __name = \"POW NFT\";\r\n    string private __symbol = \"POW\";\r\n    bytes private __uriBase = bytes(\"https://www.pownftmetadata.com/t/\");\r\n\r\n\r\n    //    ENUMERABLE VARS\r\n    mapping(address => uint[]) internal OWNER_INDEX_TO_ID;\r\n    mapping(uint => uint) internal OWNER_ID_TO_INDEX;\r\n    mapping(uint => uint) internal ID_TO_INDEX;\r\n    mapping(uint => uint) internal INDEX_TO_ID;\r\n\r\n\r\n    //ETH VAR\r\n    mapping(uint256 => uint256) WITHDRAWALS;\r\n\r\n\r\n    //      MINING VARS\r\n    uint BASE_COST = 0.000045 ether;\r\n    uint BASE_DIFFICULTY = uint(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)/uint(300);\r\n    uint DIFFICULTY_RAMP = 3;\r\n\r\n\r\n    event Migrate(uint indexed _tokenId);\r\n\r\n    //      MINING EVENTS\r\n    event Mined(uint indexed _tokenId, bytes32 hash);\r\n    event Withdraw(uint indexed _tokenId, uint value);\r\n\r\n    //      MINING FUNCTIONS\r\n    function generationOf(uint _tokenId) private pure returns(uint generation){\r\n        for(generation = 0; _tokenId > 0; generation++){\r\n            _tokenId /= 2;\r\n        }\r\n        return generation - 1;\r\n    }\r\n    function hashOf(uint _tokenId) public view returns(bytes32){\r\n        require(isValidToken(_tokenId),\"invalid\");\r\n        return TOKENS[ID_TO_INDEX[_tokenId]];\r\n    }\r\n\r\n\r\n    function migrate(uint _tokenId,uint _withdrawEthUntil) public {\r\n            _migrate(_tokenId);\r\n            if(_withdrawEthUntil > 0){\r\n                withdraw(_tokenId, _withdrawEthUntil);\r\n            }\r\n    }\r\n    function _migrate(uint _tokenId) internal {\r\n        //require not migrated\r\n        require(!isValidToken(_tokenId),'is_migrated');\r\n\r\n        //Require before snapshot\r\n        require(_tokenId <= V2_TOTAL,'forgery');\r\n\r\n        //require owner on original contract\r\n        require(CONTRACT_V2.ownerOf(_tokenId) == msg.sender,'owner');\r\n        //mint the token with hash from prev contract\r\n        UNMIGRATED--;\r\n        mint(_tokenId,\r\n            CONTRACT_V2.hashOf(_tokenId)\r\n        );\r\n        emit Migrate(_tokenId);\r\n    }\r\n    function migrateMultiple(uint[] calldata _tokenIds, uint[] calldata _withdrawUntil) public {\r\n        for(uint i = 0; i < _tokenIds.length; i++){\r\n            _migrate(_tokenIds[i]);\r\n        }\r\n        withdrawMultiple(_tokenIds,_withdrawUntil);\r\n    }\r\n\r\n\r\n\r\n    function withdraw(uint _tokenId, uint _withdrawUntil) public {\r\n        payable(msg.sender).transfer(\r\n            _withdraw(_tokenId, _withdrawUntil)\r\n        );\r\n    }\r\n    function _withdraw(uint _tokenId, uint _withdrawUntil) internal returns(uint){\r\n        require(isValidToken(_withdrawUntil),'withdrawUntil_exist');\r\n\r\n        require(ownerOf(_tokenId) == msg.sender,\"owner\");\r\n        require(_withdrawUntil > WITHDRAWALS[_tokenId],'withdrawn');\r\n\r\n        uint generation = generationOf(_tokenId);\r\n        uint firstPayable = 2**(generation+1);\r\n\r\n        uint withdrawFrom = WITHDRAWALS[_tokenId];\r\n        if(withdrawFrom < _tokenId){\r\n            withdrawFrom = _tokenId;\r\n\r\n            //withdraw from if _tokenId < number brought over\r\n            if(withdrawFrom < V2_TOTAL){\r\n                withdrawFrom = V2_TOTAL;\r\n            }\r\n            if(withdrawFrom < firstPayable){\r\n                withdrawFrom = firstPayable - 1;\r\n            }\r\n        }\r\n\r\n        require(_withdrawUntil > withdrawFrom,'underflow');\r\n\r\n        uint payout = BASE_COST * (_withdrawUntil - withdrawFrom);\r\n\r\n        WITHDRAWALS[_tokenId] = _withdrawUntil;\r\n\r\n        emit Withdraw(_tokenId,payout);\r\n\r\n        return payout;\r\n    }\r\n\r\n    function withdrawMultiple(uint[] calldata _tokenIds, uint[] calldata _withdrawUntil) public{\r\n        uint payout = 0;\r\n        for(uint i = 0; i < _tokenIds.length; i++){\r\n            if(_withdrawUntil[i] > 0){\r\n                payout += _withdraw(_tokenIds[i],_withdrawUntil[i]);\r\n            }\r\n        }\r\n        payable(msg.sender).transfer(payout);\r\n    }\r\n\r\n    function mine(uint nonce) external payable{\r\n        uint tokenId = UNMIGRATED + TOKENS.length + 1;\r\n        uint generation = generationOf(tokenId);\r\n\r\n        uint difficulty = BASE_DIFFICULTY / (DIFFICULTY_RAMP**generation);\r\n        if(generation > 13){ //Token 16384\r\n            difficulty /= (tokenId - 2**14 + 1);\r\n        }\r\n\r\n        uint cost = (2**generation - 1)* BASE_COST;\r\n\r\n\r\n        bytes32 hash;\r\n        if(V2_TOTAL - UNMIGRATED != TOKENS.length){\r\n            hash = keccak256(abi.encodePacked(\r\n                    msg.sender,\r\n                    TOKENS[ID_TO_INDEX[tokenId-1]],\r\n                    nonce\r\n                ));\r\n        }else{\r\n//            First mine on new contract\r\n            hash = keccak256(abi.encodePacked(\r\n                        msg.sender,\r\n                        PREV_CHAIN_LAST_HASH,\r\n                    nonce\r\n                ));\r\n        }\r\n\r\n\r\n        require(uint(hash) < difficulty,\"difficulty\");\r\n        require(msg.value ==cost,\"cost\");\r\n\r\n        hash = keccak256(abi.encodePacked(hash,block.timestamp));\r\n\r\n        mint(tokenId, hash);\r\n\r\n        emit Mined(tokenId,hash);\r\n    }\r\n\r\n    function mint(uint tokenId, bytes32 hash) private{\r\n        OWNERS[tokenId] = msg.sender;\r\n        BALANCES[msg.sender]++;\r\n        OWNER_ID_TO_INDEX[tokenId] = OWNER_INDEX_TO_ID[msg.sender].length;\r\n        OWNER_INDEX_TO_ID[msg.sender].push(tokenId);\r\n\r\n        ID_TO_INDEX[tokenId] = TOKENS.length;\r\n        INDEX_TO_ID[TOKENS.length] = tokenId;\r\n        TOKENS.push(hash);\r\n\r\n        emit Transfer(address(0),msg.sender,tokenId);\r\n    }\r\n\r\n\r\n    function isValidToken(uint256 _tokenId) internal view returns(bool){\r\n        return OWNERS[_tokenId] != address(0);\r\n    }\r\n\r\n    function balanceOf(address _owner) external view returns (uint256){\r\n        return BALANCES[_owner];\r\n    }\r\n\r\n    function ownerOf(uint256 _tokenId) public view returns(address){\r\n        require(isValidToken(_tokenId),\"invalid\");\r\n        return OWNERS[_tokenId];\r\n    }\r\n\r\n\r\n    function approve(address _approved, uint256 _tokenId)  external{\r\n        address owner = ownerOf(_tokenId);\r\n        require( owner == msg.sender                    //Require Sender Owns Token\r\n            || AUTHORISED[owner][msg.sender]                //  or is approved for all.\r\n        ,\"permission\");\r\n        emit Approval(owner, _approved, _tokenId);\r\n        ALLOWANCE[_tokenId] = _approved;\r\n    }\r\n\r\n    function getApproved(uint256 _tokenId) external view returns (address) {\r\n        require(isValidToken(_tokenId),\"invalid\");\r\n        return ALLOWANCE[_tokenId];\r\n    }\r\n\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\r\n        return AUTHORISED[_owner][_operator];\r\n    }\r\n\r\n\r\n    function setApprovalForAll(address _operator, bool _approved) external {\r\n        emit ApprovalForAll(msg.sender,_operator, _approved);\r\n        AUTHORISED[msg.sender][_operator] = _approved;\r\n    }\r\n\r\n\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public {\r\n\r\n        //Check Transferable\r\n        //There is a token validity check in ownerOf\r\n        address owner = ownerOf(_tokenId);\r\n\r\n        require ( owner == msg.sender             //Require sender owns token\r\n        //Doing the two below manually instead of referring to the external methods saves gas\r\n        || ALLOWANCE[_tokenId] == msg.sender      //or is approved for this token\r\n            || AUTHORISED[owner][msg.sender]          //or is approved for all\r\n        ,\"permission\");\r\n        require(owner == _from,\"owner\");\r\n        require(_to != address(0),\"zero\");\r\n\r\n        emit Transfer(_from, _to, _tokenId);\r\n\r\n\r\n        OWNERS[_tokenId] =_to;\r\n\r\n        BALANCES[_from]--;\r\n        BALANCES[_to]++;\r\n\r\n        //Reset approved if there is one\r\n        if(ALLOWANCE[_tokenId] != address(0)){\r\n            delete ALLOWANCE[_tokenId];\r\n        }\r\n\r\n        //Enumerable Additions\r\n        uint oldIndex = OWNER_ID_TO_INDEX[_tokenId];\r\n        //If the token isn't the last one in the owner's index\r\n        if(oldIndex != OWNER_INDEX_TO_ID[_from].length - 1){\r\n            //Move the old one in the index list\r\n            OWNER_INDEX_TO_ID[_from][oldIndex] = OWNER_INDEX_TO_ID[_from][OWNER_INDEX_TO_ID[_from].length - 1];\r\n            //Update the token's reference to its place in the index list\r\n            OWNER_ID_TO_INDEX[OWNER_INDEX_TO_ID[_from][oldIndex]] = oldIndex;\r\n        }\r\n        OWNER_INDEX_TO_ID[_from].pop();\r\n\r\n        OWNER_ID_TO_INDEX[_tokenId] = OWNER_INDEX_TO_ID[_to].length;\r\n        OWNER_INDEX_TO_ID[_to].push(_tokenId);\r\n\r\n    }\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory data) public {\r\n        transferFrom(_from, _to, _tokenId);\r\n\r\n        //Get size of \"_to\" address, if 0 it's a wallet\r\n        uint32 size;\r\n        assembly {\r\n            size := extcodesize(_to)\r\n        }\r\n        if(size > 0){\r\n            ERC721TokenReceiver receiver = ERC721TokenReceiver(_to);\r\n            require(receiver.onERC721Received(msg.sender,_from,_tokenId,data) == bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\")),\"receiver\");\r\n        }\r\n\r\n    }\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external {\r\n        safeTransferFrom(_from,_to,_tokenId,\"\");\r\n    }\r\n\r\n\r\n    // METADATA FUNCTIONS\r\n    function tokenURI(uint256 _tokenId) public view returns (string memory){\r\n        //Note: changed visibility to public\r\n        require(isValidToken(_tokenId),'tokenId');\r\n\r\n        uint _i = _tokenId;\r\n        uint j = _i;\r\n        uint len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len;\r\n        while (_i != 0) {\r\n            k = k-1;\r\n            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\r\n            bytes1 b1 = bytes1(temp);\r\n            bstr[k] = b1;\r\n            _i /= 10;\r\n        }\r\n\r\n\r\n        return string(abi.encodePacked(__uriBase,bstr));\r\n\r\n    }\r\n\r\n\r\n\r\n    function name() external view returns (string memory _name){\r\n        return __name;\r\n    }\r\n\r\n    function symbol() external view returns (string memory _symbol){\r\n        return __symbol;\r\n    }\r\n\r\n\r\n    // ENUMERABLE FUNCTIONS\r\n    function totalSupply() external view returns (uint256){\r\n        return TOKENS.length;\r\n    }\r\n\r\n    function tokenByIndex(uint256 _index) external view returns(uint256){\r\n        require(_index < TOKENS.length,\"index\");\r\n        return INDEX_TO_ID[_index];\r\n    }\r\n\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256){\r\n        require(_index < BALANCES[_owner],\"index\");\r\n        return OWNER_INDEX_TO_ID[_owner][_index];\r\n    }\r\n\r\n    // End 721 Implementation\r\n\r\n    ///////===165 Implementation\r\n    mapping (bytes4 => bool) internal supportedInterfaces;\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool){\r\n        return supportedInterfaces[interfaceID];\r\n    }\r\n    ///==End 165\r\n}\r\n\r\n\r\n\r\n\r\ninterface ERC721TokenReceiver {\r\n    //note: the national treasure is buried under parliament house\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\r\n}\r\n\r\n\r\ninterface POWNFTv2 {\r\n    function hashOf(uint _tokenId) external view returns(bytes32);\r\n    function ownerOf(uint256 _tokenId) external view returns(address);\r\n    function totalSupply() external view returns (uint256);\r\n    //NWH YDY DDUG SEGEN DIN\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contract_v2\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Migrate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"Mined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"PREV_CHAIN_LAST_HASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNMIGRATED\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"V2_TOTAL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"hashOf\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_withdrawEthUntil\",\"type\":\"uint256\"}],\"name\":\"migrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_withdrawUntil\",\"type\":\"uint256[]\"}],\"name\":\"migrateMultiple\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"mine\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_withdrawUntil\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_withdrawUntil\",\"type\":\"uint256[]\"}],\"name\":\"withdrawMultiple\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"POWNFTv3","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000007d4e35a2090b3ba805ddb39b2c4b83612890df87","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://fad6a40f64a0d12643eace2cde0ce5076156d99af8a473f28b73b315818f5855"}]}