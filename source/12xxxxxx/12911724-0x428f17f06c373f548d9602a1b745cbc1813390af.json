{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../GSN/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value < 2**128, \\\"SafeCast: value doesn\\\\'t fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value < 2**64, \\\"SafeCast: value doesn\\\\'t fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value < 2**32, \\\"SafeCast: value doesn\\\\'t fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value < 2**16, \\\"SafeCast: value doesn\\\\'t fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value < 2**8, \\\"SafeCast: value doesn\\\\'t fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128) {\\n        require(value >= -2**127 && value < 2**127, \\\"SafeCast: value doesn\\\\'t fit in 128 bits\\\");\\n        return int128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64) {\\n        require(value >= -2**63 && value < 2**63, \\\"SafeCast: value doesn\\\\'t fit in 64 bits\\\");\\n        return int64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32) {\\n        require(value >= -2**31 && value < 2**31, \\\"SafeCast: value doesn\\\\'t fit in 32 bits\\\");\\n        return int32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16) {\\n        require(value >= -2**15 && value < 2**15, \\\"SafeCast: value doesn\\\\'t fit in 16 bits\\\");\\n        return int16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8) {\\n        require(value >= -2**7 && value < 2**7, \\\"SafeCast: value doesn\\\\'t fit in 8 bits\\\");\\n        return int8(value);\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        require(value < 2**255, \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/LinkTokenInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\npragma solidity =0.6.12;\\r\\n\\r\\ninterface LinkTokenInterface {\\r\\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\\r\\n  function approve(address spender, uint256 value) external returns (bool success);\\r\\n  function balanceOf(address owner) external view returns (uint256 balance);\\r\\n  function decimals() external view returns (uint8 decimalPlaces);\\r\\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\\r\\n  function increaseApproval(address spender, uint256 subtractedValue) external;\\r\\n  function name() external view returns (string memory tokenName);\\r\\n  function symbol() external view returns (string memory tokenSymbol);\\r\\n  function totalSupply() external view returns (uint256 totalTokensIssued);\\r\\n  function transfer(address to, uint256 value) external returns (bool success);\\r\\n  function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool success);\\r\\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\\r\\n}\"\r\n    },\r\n    \"contracts/RNGChainlink.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\npragma solidity =0.6.12;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/SafeCast.sol\\\";\\r\\n\\r\\nimport \\\"./VRFConsumerBase.sol\\\";\\r\\nimport \\\"./RNGInterface.sol\\\";\\r\\n\\r\\ncontract RNGChainlink is RNGInterface, VRFConsumerBase, Ownable {\\r\\n  using SafeCast for uint256;\\r\\n\\r\\n  event KeyHashSet(bytes32 keyHash);\\r\\n  event FeeSet(uint256 fee);\\r\\n  event VrfCoordinatorSet(address indexed vrfCoordinator);\\r\\n  event VRFRequested(uint256 indexed requestId, bytes32 indexed chainlinkRequestId);\\r\\n\\r\\n  bytes32 public keyHash;\\r\\n  uint256 public fee;\\r\\n  uint32 public requestCount;\\r\\n  mapping(uint32 => uint256) internal randomNumbers;\\r\\n  mapping(uint32 => uint32) internal requestLockBlock;\\r\\n  mapping(bytes32 => uint32) internal chainlinkRequestIds;\\r\\n\\r\\n  constructor(address _vrfCoordinator, address _link)\\r\\n    public\\r\\n    VRFConsumerBase(_vrfCoordinator, _link)\\r\\n  {\\r\\n    emit VrfCoordinatorSet(_vrfCoordinator);\\r\\n  }\\r\\n\\r\\n  function getLink() external view returns (address) {\\r\\n    return address(LINK);\\r\\n  }\\r\\n\\r\\n  function setKeyhash(bytes32 _keyhash) external onlyOwner {\\r\\n    keyHash = _keyhash;\\r\\n    emit KeyHashSet(keyHash);\\r\\n  }\\r\\n\\r\\n  function setFee(uint256 _fee) external onlyOwner {\\r\\n    fee = _fee;\\r\\n    emit FeeSet(fee);\\r\\n  }\\r\\n\\r\\n  function getLastRequestId() external override view returns (uint32 requestId) {\\r\\n    return requestCount;\\r\\n  }\\r\\n\\r\\n  function getRequestFee() external override view returns (address feeToken, uint256 requestFee) {\\r\\n    return (address(LINK), fee);\\r\\n  }\\r\\n\\r\\n  function requestRandomNumber() external override returns (uint32 requestId, uint32 lockBlock) {\\r\\n    uint256 seed = _getSeed();\\r\\n    lockBlock = uint32(block.number);\\r\\n\\r\\n    require(LINK.transferFrom(msg.sender, address(this), fee), \\\"RNGCHAINLINK: FEE_TRANSFER_FAILED\\\");\\r\\n    \\r\\n    requestId = _requestRandomness(seed);\\r\\n    requestLockBlock[requestId] = lockBlock;\\r\\n    emit RandomNumberRequested(requestId, msg.sender);\\r\\n  }\\r\\n\\r\\n  function isRequestComplete(uint32 requestId) external override view returns (bool isCompleted) {\\r\\n    return randomNumbers[requestId] != 0;\\r\\n  }\\r\\n\\r\\n  function randomNumber(uint32 requestId) external override returns (uint256 randomNum) {\\r\\n    return randomNumbers[requestId];\\r\\n  }\\r\\n\\r\\n  function _requestRandomness(uint256 seed) internal returns (uint32 requestId) {\\r\\n    requestId = _getNextRequestId();\\r\\n    bytes32 vrfRequestId = requestRandomness(keyHash, fee, seed);\\r\\n    chainlinkRequestIds[vrfRequestId] = requestId;\\r\\n\\r\\n    emit VRFRequested(requestId, vrfRequestId);\\r\\n  }\\r\\n\\r\\n  function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {\\r\\n    uint32 internalRequestId = chainlinkRequestIds[requestId];\\r\\n    randomNumbers[internalRequestId] = randomness;\\r\\n    emit RandomNumberCompleted(internalRequestId, randomness);\\r\\n  }\\r\\n\\r\\n  function _getNextRequestId() internal returns (uint32 requestId) {\\r\\n    requestCount = uint256(requestCount).add(1).toUint32();\\r\\n    requestId = requestCount;\\r\\n  }\\r\\n\\r\\n  function _getSeed() internal virtual view returns (uint256 seed) {\\r\\n    return uint256(blockhash(block.number - 1));\\r\\n  }\\r\\n}\"\r\n    },\r\n    \"contracts/RNGInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\npragma solidity =0.6.12;\\r\\n\\r\\ninterface RNGInterface {\\r\\n  event RandomNumberRequested(uint32 indexed requestId, address indexed sender);\\r\\n  event RandomNumberCompleted(uint32 indexed requestId, uint256 randomNumber);\\r\\n\\r\\n  function getLastRequestId() external view returns (uint32 requestId);\\r\\n  function getRequestFee() external view returns (address feeToken, uint256 requestFee);\\r\\n  function requestRandomNumber() external returns (uint32 requestId, uint32 lockBlock);\\r\\n  function isRequestComplete(uint32 requestId) external view returns (bool isCompleted);\\r\\n  function randomNumber(uint32 requestId) external returns (uint256 randomNum);\\r\\n}\"\r\n    },\r\n    \"contracts/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity =0.6.12;\\r\\n\\r\\nlibrary SafeMath {\\r\\n\\r\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    uint256 c = a + b;\\r\\n    require(c >= a, \\\"SafeMath: addition overflow\\\");\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\r\\n    uint256 c = a - b;\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    if (a == 0) {\\r\\n      return 0;\\r\\n    }\\r\\n    uint256 c = a * b;\\r\\n    require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    require(b > 0, \\\"SafeMath: division by zero\\\");\\r\\n    uint256 c = a / b;\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    require(b != 0, \\\"SafeMath: modulo by zero\\\");\\r\\n    return a % b;\\r\\n  }\\r\\n}\"\r\n    },\r\n    \"contracts/VRFConsumerBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\npragma solidity =0.6.12;\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./LinkTokenInterface.sol\\\";\\r\\nimport \\\"./VRFRequestIDBase.sol\\\";\\r\\n\\r\\nabstract contract VRFConsumerBase is VRFRequestIDBase {\\r\\n\\r\\n  using SafeMath for uint256;\\r\\n\\r\\n  function fulfillRandomness(bytes32 requestId, uint256 randomness)\\r\\n    internal virtual;\\r\\n\\r\\n  function requestRandomness(bytes32 _keyHash, uint256 _fee, uint256 _seed)\\r\\n    public returns (bytes32 requestId)\\r\\n  {\\r\\n    LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, _seed));\\r\\n    uint256 vRFSeed  = makeVRFInputSeed(_keyHash, _seed, address(this), nonces[_keyHash]);\\r\\n    nonces[_keyHash] = nonces[_keyHash].add(1);\\r\\n    return makeRequestId(_keyHash, vRFSeed);\\r\\n  }\\r\\n\\r\\n  LinkTokenInterface immutable internal LINK;\\r\\n  address immutable private vrfCoordinator;\\r\\n\\r\\n  mapping(bytes32 => uint256) public nonces;\\r\\n  constructor(address _vrfCoordinator, address _link) public {\\r\\n    vrfCoordinator = _vrfCoordinator;\\r\\n    LINK = LinkTokenInterface(_link);\\r\\n  }\\r\\n\\r\\n  function rawFulfillRandomness(bytes32 requestId, uint256 randomness) external {\\r\\n    require(msg.sender == vrfCoordinator, \\\"Only VRFCoordinator can fulfill\\\");\\r\\n    fulfillRandomness(requestId, randomness);\\r\\n  }\\r\\n}\"\r\n    },\r\n    \"contracts/VRFRequestIDBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\npragma solidity =0.6.12;\\r\\n\\r\\ncontract VRFRequestIDBase {\\r\\n\\r\\n  function makeVRFInputSeed(bytes32 _keyHash, uint256 _userSeed,\\r\\n    address _requester, uint256 _nonce)\\r\\n    internal pure returns (uint256)\\r\\n  {\\r\\n    return  uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));\\r\\n  }\\r\\n\\r\\n  function makeRequestId(\\r\\n    bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {\\r\\n    return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));\\r\\n  }\\r\\n}\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vrfCoordinator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_link\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"FeeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"keyHash\",\"type\":\"bytes32\"}],\"name\":\"KeyHashSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"requestId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"randomNumber\",\"type\":\"uint256\"}],\"name\":\"RandomNumberCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"requestId\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RandomNumberRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"chainlinkRequestId\",\"type\":\"bytes32\"}],\"name\":\"VRFRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vrfCoordinator\",\"type\":\"address\"}],\"name\":\"VrfCoordinatorSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastRequestId\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"requestId\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLink\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRequestFee\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"feeToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"requestFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"requestId\",\"type\":\"uint32\"}],\"name\":\"isRequestComplete\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isCompleted\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"keyHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"requestId\",\"type\":\"uint32\"}],\"name\":\"randomNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"randomNum\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"randomness\",\"type\":\"uint256\"}],\"name\":\"rawFulfillRandomness\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestCount\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestRandomNumber\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"requestId\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"lockBlock\",\"type\":\"uint32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_keyHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_seed\",\"type\":\"uint256\"}],\"name\":\"requestRandomness\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_keyhash\",\"type\":\"bytes32\"}],\"name\":\"setKeyhash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"RNGChainlink","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000f0d54349addcf704f77ae15b96510dea15cb7952000000000000000000000000514910771af9ca656af840dff83e8264ecf986ca","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":""}]}