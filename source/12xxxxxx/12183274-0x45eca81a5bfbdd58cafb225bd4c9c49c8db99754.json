{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/VestingAirdrop.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity >=0.6.0 <=0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./interfaces/IVesting.sol\\\";\\nimport \\\"./interfaces/IAirdrop.sol\\\";\\n\\ncontract VestingAirdrop is Ownable, IAirdrop {\\n    IERC20 public token;\\n    \\n    bytes32 public root;\\n    IVesting public vesting;\\n    uint256 public vestingAmount;\\n    uint256 public vestingDuration;\\n    uint256 public vestingCliff;\\n\\n    mapping (address => bool) public claimed;\\n\\n    event Claim(address _recipient, uint256 amount);\\n\\n    constructor(\\n        address _token,\\n        address _owner,\\n        bytes32 _root,\\n        address _vesting,\\n        uint256 _vestingAmount,\\n        uint256 _vestingCliff,\\n        uint256 _vestingDuration)\\n    public {\\n        token = IERC20(_token);\\n        root = _root;\\n        vesting = IVesting(_vesting);\\n        vestingAmount = _vestingAmount;\\n        vestingCliff = _vestingCliff;\\n        vestingDuration = _vestingDuration;\\n        transferOwnership(_owner);\\n    }\\n\\n    /**\\n     * @notice Modifies the underlying set for the Merkle tree. It is an error\\n     *          to call this function with an incorrect size or root hash.\\n     * @param _root The new Merkle root hash\\n     * @dev Only the owner of the contract can modify the Merkle set.\\n     *\\n     */\\n    function setMerkleSet(\\n        bytes32 _root\\n    ) external override onlyOwner() {\\n        root = _root;\\n    }\\n\\n    /**\\n     * @notice Deposits tokens into the airdrop contract\\n     * @param amount The quantity of ERC20 tokens to deposit\\n     *\\n     */\\n    function deposit(uint256 amount) external override {\\n        /* bounds check deposit amount */\\n        require(amount > 0, \\\"ADP: Zero deposit\\\");\\n\\n        /* transfer tokens to airdrop contract */\\n        bool transferResult = token.transferFrom(\\n            msg.sender,\\n            address(this),\\n            amount\\n        );\\n\\n        /* handle failure */\\n        require(transferResult, \\\"ADP: ERC20 transfer failed\\\");\\n    }\\n\\n    /**\\n     * @notice Withdraws the allocated quantity of tokens to the caller\\n     * @param proof The proof of membership of the Merkle tree\\n     * @param amount The number of tokens the caller is claiming\\n     * @dev Marks caller as claimed if proof checking succeeds and emits the\\n     *      `Claim` event.\\n     *\\n     */\\n    function withdraw(\\n        bytes32[] calldata proof,\\n        uint256 amount\\n    ) external override {\\n        /* check for multiple claims */\\n        require(!claimed[msg.sender], \\\"ADP: Already claimed\\\");\\n\\n        /* check the caller's Merkle proof */\\n        bool proofResult = checkProof(proof, hash(msg.sender, amount));\\n\\n        /* handle proof checking failure */\\n        require(proofResult, \\\"ADP: Invalid proof\\\");\\n\\n        /* mark caller as claimed */\\n        claimed[msg.sender] = true;\\n\\n        /* transfer tokens from airdrop contract to caller */\\n        bool transferResult = token.transfer(msg.sender, amount);\\n\\n        /* handle failure */\\n        require(transferResult, \\\"ADP: ERC20 transfer failed\\\");\\n\\n        /* Send tokens to vesting */\\n        token.transfer(address(vesting), vestingAmount);\\n\\n        /* Set vesting for the user */\\n        vesting.setVestingSchedule(\\n            msg.sender,\\n            vestingAmount,\\n            false,\\n            vestingCliff,\\n            vestingDuration\\n        );\\n\\n        /* emit appropriate event */\\n        emit Claim(msg.sender, amount);\\n    }\\n\\n    /**\\n     * @notice Withdraws all tokens currently held by the airdrop contract\\n     * @dev Only the owner of the airdrop contract can call this method\\n     *\\n     */\\n    function bail() external override onlyOwner() {\\n        /* retrieve current token balance of the airdrop contract */\\n        uint256 tokenBalance = token.balanceOf(address(this));\\n\\n        /* transfer all tokens in the airdrop contract to the owner */\\n        bool transferResult = token.transfer(msg.sender, tokenBalance);\\n\\n        require(transferResult, \\\"ADP: ERC20 transfer failed\\\");\\n    }\\n\\n    function cancelVestingSchedule(address account, uint256 scheduleId) external onlyOwner() {\\n        vesting.cancelVesting(account, scheduleId);\\n    }\\n\\n    function withdrawFromVesting(uint256 amount) external onlyOwner() {\\n        vesting.withdraw(amount);\\n    }\\n\\n    /**\\n    * @notice helper function for anyone to validate if a given proof is valid given a claimer and amount \\n    */\\n    function validClaim(bytes32[] calldata proof, address claimer, uint amount) public view returns(bool) {\\n        return checkProof(proof, hash(claimer, amount));\\n    }\\n\\n    /**\\n     * @notice Verifies a membership proof using another leaf node of the Merkle\\n     *          tree\\n     * @param proof The Merkle hash of the relevant data block\\n     * @param claimantHash The Merkle hash the caller is looking to prove is a\\n     *          member of the Merkle set\\n     *\\n     */\\n    function checkProof(\\n        bytes32[] calldata proof,\\n        bytes32 claimantHash\\n    ) internal view returns (bool) {\\n        bytes32 currElem = 0;\\n        bytes32 currHash = claimantHash;\\n\\n        for(uint256 i=0;i<proof.length;i++) {\\n            currElem = proof[i];\\n\\n            /* alternate what order we concatenate in */\\n            if (currElem < currHash) {\\n                currHash = keccak256(abi.encodePacked(currHash, currElem));\\n            } else {\\n                currHash = keccak256(abi.encodePacked(currElem, currHash));\\n            }\\n        }\\n        \\n        return currHash == root;\\n    }\\n\\n    function logBase2(uint256 n) internal pure returns (uint256) {\\n        uint256 res = 0;\\n\\n        if (n >= 2**128) { n >>= 128; res += 128; }\\n        if (n >= 2**64) { n >>= 64; res += 64; }\\n        if (n >= 2**32) { n >>= 32; res += 32; }\\n        if (n >= 2**16) { n >>= 16; res += 16; }\\n        if (n >= 2**8) { n >>= 8; res += 8; }\\n        if (n >= 2**4) { n >>= 4; res += 4; }\\n        if (n >= 2**2) { n >>= 2; res += 2; }\\n        if (n >= 2**1) { /* n >>= 1; */ res += 1; }\\n\\n        return res;\\n    }\\n\\n    /**\\n     * @notice Generates the Merkle hash given address and amount\\n     * @param recipient The address of the recipient\\n     * @param amount The quantity of tokens the recipient is entitled to\\n     * @return The Merkle hash of the leaf node needed to prove membership\\n     *\\n     */\\n    function hash(\\n        address recipient,\\n        uint256 amount\\n    ) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(recipient, amount));\\n    }\\n}\\n\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../GSN/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVesting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\n/**\\n* Tracer vesting interface. See https://github.com/tracer-protocol/tracer-dao\\n*/\\ninterface IVesting {\\n    /**\\n     * @notice Sets up a vesting schedule for a set user\\n     * @dev adds a new Schedule to the schedules mapping\\n     * @param account the account that a vesting schedule is being set up for. Will be able to claim tokens after\\n     *                the cliff period.\\n     * @param amount the amount of tokens being vested for the user.\\n     * @param isFixed a flag for if the vesting schedule is fixed or not. Fixed vesting schedules can't be cancelled.\\n     */\\n    function setVestingSchedule(\\n        address account,\\n        uint256 amount,\\n        bool isFixed,\\n        uint256 cliffWeeks,\\n        uint256 vestingWeeks\\n    ) external;\\n\\n    /**\\n     * @notice allows users to claim vested tokens if the cliff time has passed\\n     */\\n    function claim(uint256 vestingId) external;\\n\\n    /**\\n     * @notice Allows a vesting schedule to be cancelled.\\n     * @dev Any outstanding tokens are returned to the system.\\n     * @param account the account of the user whos vesting schedule is being cancelled.\\n     */\\n    function cancelVesting(address account, uint256 proposalId) external;\\n\\n    /**\\n     * @notice returns the total amount and total claimed amount of a users vesting schedule.\\n     * @param account the user to retrieve the vesting schedule for.\\n     */\\n    function getVesting(address account, uint256 proposalId)\\n        external\\n        view\\n        returns (uint256, uint256);\\n\\n    /**\\n     * @notice calculates the amount of tokens to distribute to an account at any instance in time, based off some\\n     *         total claimable amount.\\n     * @param amount the total outstanding amount to be claimed for this vesting schedule\\n     * @param currentTime the current timestamp\\n     * @param startTime the timestamp this vesting schedule started\\n     * @param endTime the timestamp this vesting schedule ends\\n     */\\n    function calcDistribution(\\n        uint256 amount,\\n        uint256 currentTime,\\n        uint256 startTime,\\n        uint256 endTime\\n    ) external pure returns (uint256);\\n\\n    /**\\n    * @notice Withdraws TCR tokens from the contract.\\n    * @dev blocks withdrawing locked tokens.\\n    */\\n    function withdraw(uint amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAirdrop.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity >=0.6.0 <=0.8.0;\\n\\ninterface IAirdrop {\\n    function setMerkleSet(bytes32 _root) external;\\n    function deposit(uint256 amount) external;\\n    function withdraw(bytes32[] calldata proof, uint256 amount) external;\\n    function bail() external;\\n}\\n\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_root\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_vesting\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_vestingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_vestingCliff\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_vestingDuration\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"bail\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"scheduleId\",\"type\":\"uint256\"}],\"name\":\"cancelVestingSchedule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"root\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_root\",\"type\":\"bytes32\"}],\"name\":\"setMerkleSet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"validClaim\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vesting\",\"outputs\":[{\"internalType\":\"contract IVesting\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vestingAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vestingCliff\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vestingDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFromVesting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"VestingAirdrop","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000009c4a4204b79dd291d6b6571c5be8bbcd0622f050000000000000000000000000a84918f3280d488eb3369cb713ec53ce386b6cba21273b5ec1e2c4680669adfcd22428071774c0248ce58910d28fd413532ef7d6000000000000000000000000399257702f0f05ebec30c17b8888be1b2a321e36000000000000000000000000000000000000000000000a96738339f1d3dc000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000068","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}