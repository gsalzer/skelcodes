{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/proxyLib/OwnableProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0 <0.9.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./OwnableProxied.sol\\\";\\nimport \\\"./OwnableUpgradeable.sol\\\";\\n\\ncontract OwnableProxy is OwnableProxied {\\n    /*\\n     * @notice Constructor sets the target and emmits an event with the first target\\n     * @param _target - The target Upgradeable contracts address\\n     */\\n    address public deployer;\\n\\n    constructor(address _target) {\\n        deployer = msg.sender;\\n        upgradeTo(_target);\\n    }\\n\\n    /*\\n     * @notice Fallback function that will execute code from the target contract to process a function call.\\n     * @dev Will use the delegatecall opcode to retain the current state of the Proxy contract and use the logic\\n     * from the target contract to process it.\\n     */\\n    fallback() external payable {\\n        bytes memory data = msg.data;\\n        address impl = target;\\n\\n        assembly {\\n            let result := delegatecall(\\n                gas(),\\n                impl,\\n                add(data, 0x20),\\n                mload(data),\\n                0,\\n                0\\n            )\\n            let size := returndatasize()\\n\\n            let ptr := mload(0x40)\\n            returndatacopy(ptr, 0, size)\\n\\n            switch result\\n            case 0 {\\n                revert(ptr, size)\\n            }\\n            default {\\n                return(ptr, size)\\n            }\\n        }\\n    }\\n\\n    receive() external payable {}\\n\\n    modifier onlyDeployer() {\\n        require(msg.sender == deployer, \\\"\\\");\\n        _;\\n    }\\n\\n    function setDeployer(address _deployer) public onlyOwner {\\n        deployer = _deployer;\\n    }\\n\\n    /*\\n     * @notice Upgrades the contract to a different target that has a changed logic. Can only be called by owner\\n     * @dev See https://github.com/jackandtheblockstalk/upgradeable-proxy for what can and cannot be done in Upgradeable\\n     * contracts\\n     * @param _target - The target Upgradeable contracts address\\n     */\\n    function upgradeTo(address _target) public override onlyDeployer {\\n        assert(target != _target);\\n\\n        address oldTarget = target;\\n        target = _target;\\n\\n        emit EventUpgrade(_target, oldTarget, msg.sender);\\n    }\\n\\n    /*\\n     * @notice Performs an upgrade and then executes a transaction. Intended use to upgrade and initialize atomically\\n     */\\n    //     function upgradeTo(address _target, bytes memory _data) public onlyOwner {\\n    //         upgradeTo(_target);\\n    //         assert(target.delegatecall(_data));\\n    //     }\\n}\\n\"\r\n    },\r\n    \"contracts/proxyLib/OwnableProxied.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0 <0.9.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n/*\\n * @title Proxied v0.5\\n * @author Jack Tanner\\n * @notice The Proxied contract acts as the parent contract to Proxy and Upgradeable with and creates space for\\n * state variables, functions and events that will be used in the upgraeable system.\\n *\\n * @dev Both the Proxy and Upgradeable need to hae the target and initialized state variables stored in the exact\\n * same storage location, which is why they must both inherit from Proxied. Defining them in the saparate contracts\\n * does not work.\\n *\\n * @param target - This stores the current address of the target Upgradeable contract, which can be modified by\\n * calling upgradeTo()\\n *\\n * @param initialized - This mapping records which targets have been initialized with the Upgradeable.initialize()\\n * function. Target Upgradeable contracts can only be intitialed once.\\n */\\nabstract contract OwnableProxied is Ownable {\\n    address public target;\\n    mapping(address => bool) public initialized;\\n\\n    event EventUpgrade(\\n        address indexed newTarget,\\n        address indexed oldTarget,\\n        address indexed admin\\n    );\\n    event EventInitialized(address indexed target);\\n\\n    function upgradeTo(address _target) public virtual;\\n}\\n\"\r\n    },\r\n    \"contracts/proxyLib/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0 <0.9.0;\\npragma experimental ABIEncoderV2;\\n\\nimport './OwnableProxied.sol';\\n\\ncontract OwnableUpgradeable is OwnableProxied {\\n    /*\\n     * @notice Modifier to make body of function only execute if the contract has not already been initialized.\\n     */\\n    address payable public proxy;\\n    modifier initializeOnceOnly() {\\n         if(!initialized[target]) {\\n             initialized[target] = true;\\n             emit EventInitialized(target);\\n             _;\\n         } else revert();\\n     }\\n\\n    modifier onlyProxy() {\\n        require(msg.sender == proxy);\\n        _;\\n    }\\n\\n    /**\\n     * @notice Will always fail if called. This is used as a placeholder for the contract ABI.\\n     * @dev This is code is never executed by the Proxy using delegate call\\n     */\\n    function upgradeTo(address) public pure override {\\n        assert(false);\\n    }\\n\\n    /**\\n     * @notice Initialize any state variables that would normally be set in the contructor.\\n     * @dev Initialization functionality MUST be implemented in inherited upgradeable contract if the child contract requires\\n     * variable initialization on creation. This is because the contructor of the child contract will not execute\\n     * and set any state when the Proxy contract targets it.\\n     * This function MUST be called stright after the Upgradeable contract is set as the target of the Proxy. This method\\n     * can be overwridden so that it may have arguments. Make sure that the initializeOnceOnly() modifier is used to protect\\n     * from being initialized more than once.\\n     * If a contract is upgraded twice, pay special attention that the state variables are not initialized again\\n     */\\n    /*function initialize() public initializeOnceOnly {\\n        // initialize contract state variables here\\n    }*/\\n\\n    function setProxy(address payable theAddress) public onlyOwner {\\n        proxy = theAddress;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/proxyLib/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function changeOwner(address newOwner) public onlyOwner returns (bool) {\\n        _owner = newOwner;\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(\\n            newOwner != address(0),\\n            \\\"Ownable: new owner is the zero address\\\"\\n        );\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"EventInitialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newTarget\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldTarget\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"EventUpgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deployer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_deployer\",\"type\":\"address\"}],\"name\":\"setDeployer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"target\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"OwnableProxy","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000e7cf6feec4a6800d8ae0e80ce715c0d000aa8885","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}