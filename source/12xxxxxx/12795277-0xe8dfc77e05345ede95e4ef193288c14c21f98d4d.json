{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/Mail/ENS_Registry.sol\": {\r\n      \"content\": \"// ███████╗░█████╗░██████╗░██████╗░███████╗██████╗░░░░███████╗██╗\\n// ╚════██║██╔══██╗██╔══██╗██╔══██╗██╔════╝██╔══██╗░░░██╔════╝██║\\n// ░░███╔═╝███████║██████╔╝██████╔╝█████╗░░██████╔╝░░░█████╗░░██║\\n// ██╔══╝░░██╔══██║██╔═══╝░██╔═══╝░██╔══╝░░██╔══██╗░░░██╔══╝░░██║\\n// ███████╗██║░░██║██║░░░░░██║░░░░░███████╗██║░░██║██╗██║░░░░░██║\\n// ╚══════╝╚═╝░░╚═╝╚═╝░░░░░╚═╝░░░░░╚══════╝╚═╝░░╚═╝╚═╝╚═╝░░░░░╚═╝\\n// Copyright (C) 2020 zapper\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 2 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n\\n///@author Zapper\\n///@notice Zapper Mail implementation, based heavily on Melon Mail from Melonport\\n// SPDX-License-Identifier: GPL-2.0\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title EnsRegistry\\n * @dev Extract of the interface for ENS Registry\\n */\\ninterface EnsRegistry {\\n    function setOwner(bytes32 _node, address _owner) external;\\n\\n    function setSubnodeOwner(\\n        bytes32 _node,\\n        bytes32 _label,\\n        address _owner\\n    ) external;\\n\\n    function setResolver(bytes32 _node, address _resolver) external;\\n\\n    function owner(bytes32 _node) external view returns (address);\\n\\n    function resolver(bytes32 _node) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/Mail/ENS_Resolver.sol\": {\r\n      \"content\": \"// ███████╗░█████╗░██████╗░██████╗░███████╗██████╗░░░░███████╗██╗\\n// ╚════██║██╔══██╗██╔══██╗██╔══██╗██╔════╝██╔══██╗░░░██╔════╝██║\\n// ░░███╔═╝███████║██████╔╝██████╔╝█████╗░░██████╔╝░░░█████╗░░██║\\n// ██╔══╝░░██╔══██║██╔═══╝░██╔═══╝░██╔══╝░░██╔══██╗░░░██╔══╝░░██║\\n// ███████╗██║░░██║██║░░░░░██║░░░░░███████╗██║░░██║██╗██║░░░░░██║\\n// ╚══════╝╚═╝░░╚═╝╚═╝░░░░░╚═╝░░░░░╚══════╝╚═╝░░╚═╝╚═╝╚═╝░░░░░╚═╝\\n// Copyright (C) 2020 zapper\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 2 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n\\n///@author Zapper\\n///@notice Zapper Mail implementation, based heavily on Melon Mail from Melonport\\n// SPDX-License-Identifier: GPL-2.0\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title EnsResolver\\n * @dev Extract of the interface for ENS Resolver\\n */\\ninterface EnsResolver {\\n    function setAddr(bytes32 _node, address _addr) external;\\n\\n    function addr(bytes32 _node) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/Mail/Signature_Verifier.sol\": {\r\n      \"content\": \"// ███████╗░█████╗░██████╗░██████╗░███████╗██████╗░░░░███████╗██╗\\n// ╚════██║██╔══██╗██╔══██╗██╔══██╗██╔════╝██╔══██╗░░░██╔════╝██║\\n// ░░███╔═╝███████║██████╔╝██████╔╝█████╗░░██████╔╝░░░█████╗░░██║\\n// ██╔══╝░░██╔══██║██╔═══╝░██╔═══╝░██╔══╝░░██╔══██╗░░░██╔══╝░░██║\\n// ███████╗██║░░██║██║░░░░░██║░░░░░███████╗██║░░██║██╗██║░░░░░██║\\n// ╚══════╝╚═╝░░╚═╝╚═╝░░░░░╚═╝░░░░░╚══════╝╚═╝░░╚═╝╚═╝╚═╝░░░░░╚═╝\\n// Copyright (C) 2021 zapper\\n// Copyright (c) 2018 Tasuku Nakamura\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 2 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n\\n///@author Zapper\\n///@notice This contract checks if a message has been signed by a verified signer via personal_sign.\\n// SPDX-License-Identifier: GPLv2\\n\\npragma solidity ^0.8.0;\\n\\ncontract SignatureVerifier {\\n    address public _signer;\\n\\n    constructor(address signer) {\\n        _signer = signer;\\n    }\\n\\n    function verify(\\n        address account,\\n        string calldata publicKey,\\n        bytes memory signature\\n    ) internal view returns (bool) {\\n        bytes32 messageHash = getMessageHash(account, publicKey);\\n        bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);\\n\\n        return recoverSigner(ethSignedMessageHash, signature) == _signer;\\n    }\\n\\n    function getMessageHash(address account, string calldata publicKey)\\n        public\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(abi.encodePacked(account, publicKey));\\n    }\\n\\n    function getEthSignedMessageHash(bytes32 messageHash)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\n                    messageHash\\n                )\\n            );\\n    }\\n\\n    function recoverSigner(\\n        bytes32 _ethSignedMessageHash,\\n        bytes memory _signature\\n    ) internal pure returns (address) {\\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\\n\\n        return ecrecover(_ethSignedMessageHash, v, r, s);\\n    }\\n\\n    function splitSignature(bytes memory signature)\\n        internal\\n        pure\\n        returns (\\n            bytes32 r,\\n            bytes32 s,\\n            uint8 v\\n        )\\n    {\\n        require(signature.length == 65, \\\"invalid signature length\\\");\\n\\n        assembly {\\n            r := mload(add(signature, 32))\\n            s := mload(add(signature, 64))\\n            v := byte(0, mload(add(signature, 96)))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Mail/Zapper_Mail_V1.sol\": {\r\n      \"content\": \"// ███████╗░█████╗░██████╗░██████╗░███████╗██████╗░░░░███████╗██╗\\n// ╚════██║██╔══██╗██╔══██╗██╔══██╗██╔════╝██╔══██╗░░░██╔════╝██║\\n// ░░███╔═╝███████║██████╔╝██████╔╝█████╗░░██████╔╝░░░█████╗░░██║\\n// ██╔══╝░░██╔══██║██╔═══╝░██╔═══╝░██╔══╝░░██╔══██╗░░░██╔══╝░░██║\\n// ███████╗██║░░██║██║░░░░░██║░░░░░███████╗██║░░██║██╗██║░░░░░██║\\n// ╚══════╝╚═╝░░╚═╝╚═╝░░░░░╚═╝░░░░░╚══════╝╚═╝░░╚═╝╚═╝╚═╝░░░░░╚═╝\\n// Copyright (C) 2021 zapper\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 2 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n\\n///@author Zapper\\n///@notice Zapper Mail implementation with inspiration from Melon Mail.\\n// SPDX-License-Identifier: GPL-2.0\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../oz/0.8.0/access/Ownable.sol\\\";\\nimport \\\"./Signature_Verifier.sol\\\";\\nimport \\\"./ENS_Registry.sol\\\";\\nimport \\\"./ENS_Resolver.sol\\\";\\n\\ncontract Zapper_Mail_V1 is SignatureVerifier, Ownable {\\n    EnsRegistry public registry;\\n    EnsResolver public resolver;\\n    bytes32 public baseNode;\\n    bool public paused = false;\\n\\n    event UserRegistered(\\n        bytes32 indexed usernameHash,\\n        address indexed addr,\\n        string username,\\n        string publicKey\\n    );\\n    event EmailSent(address indexed from, address indexed to, string mailHash);\\n\\n    constructor(\\n        address _signer,\\n        EnsRegistry _registry,\\n        EnsResolver _resolver,\\n        bytes32 _baseNode\\n    ) SignatureVerifier(_signer) {\\n        registry = _registry;\\n        resolver = _resolver;\\n        baseNode = _baseNode;\\n    }\\n\\n    modifier pausable {\\n        if (paused) {\\n            revert(\\\"Paused\\\");\\n        } else {\\n            _;\\n        }\\n    }\\n\\n    /**\\n     * @dev Pause or unpause the mail functionality\\n     */\\n    function pause() external onlyOwner {\\n        paused = !paused;\\n    }\\n\\n    /**\\n     * @dev Transfer ownership of the top ENS domain\\n     * @param _node - namehash of the top ENS domain\\n     * @param _owner - new owner for the ENS domain\\n     */\\n    function transferDomainOwnership(bytes32 _node, address _owner)\\n        external\\n        onlyOwner\\n    {\\n        registry.setOwner(_node, _owner);\\n    }\\n\\n    /**\\n     * @dev Transfer resolved address of the ENS subdomain\\n     * @param _node - namehash of the ENS subdomain\\n     * @param _account - new resolved address of the ENS subdomain\\n     */\\n    function transferSubdomainAddress(bytes32 _node, address _account)\\n        external\\n    {\\n        require(\\n            registry.owner(_node) == address(this),\\n            \\\"Err: Subdomain not owned by contract\\\"\\n        );\\n        require(\\n            resolver.addr(_node) == tx.origin,\\n            \\\"Err: Subdomain not owned by sender\\\"\\n        );\\n        resolver.setAddr(_node, _account);\\n    }\\n\\n    /**\\n     * @dev Returns the node for the subdomain specified by the username\\n     */\\n    function node(string calldata _username) public view returns (bytes32) {\\n        return\\n            keccak256(abi.encodePacked(baseNode, keccak256(bytes(_username))));\\n    }\\n\\n    /**\\n     * @dev Updates to new ENS registry.\\n     * @param _registry The address of new ENS registry to use.\\n     */\\n    function updateRegistry(EnsRegistry _registry) external onlyOwner {\\n        require(registry != _registry, \\\"Err: New registry should be different\\\");\\n        registry = _registry;\\n    }\\n\\n    /**\\n     * @dev Allows to update to new ENS resolver.\\n     * @param _resolver The address of new ENS resolver to use.\\n     */\\n    function updateResolver(EnsResolver _resolver) external onlyOwner {\\n        require(resolver != _resolver, \\\"Err: New resolver should be different\\\");\\n        resolver = _resolver;\\n    }\\n\\n    /**\\n     * @dev Allows to update to new ENS base node.\\n     * @param _baseNode The new ENS base node to use.\\n     */\\n    function updateBaseNode(bytes32 _baseNode) external onlyOwner {\\n        require(baseNode != _baseNode, \\\"Err: New node should be different\\\");\\n        baseNode = _baseNode;\\n    }\\n\\n    /**\\n     * @dev Registers a username to an address, such that the address will own a subdomain of zappermail.eth\\n     * i.e.: If a user registers \\\"joe\\\", they will own \\\"joe.zappermail.eth\\\"\\n     * @param _account - Address of the new owner of the username\\n     * @param _node - Subdomain node to be registered\\n     * @param _username - Username being requested\\n     * @param _publicKey - The Zapper mail encryption public key for this username\\n     * @param _signature - Verified signature granting account the subdomain\\n     */\\n    function registerUser(\\n        address _account,\\n        bytes32 _node,\\n        string calldata _username,\\n        string calldata _publicKey,\\n        bytes calldata _signature\\n    ) external pausable {\\n        // Confirm that the signature matches that of the sender\\n        require(\\n            verify(_account, _publicKey, _signature),\\n            \\\"Err: Invalid Signature\\\"\\n        );\\n\\n        // Validate that the node is valid for the given username\\n        require(\\n            node(_username) == _node,\\n            \\\"Err: Node does not match ENS subdomain\\\"\\n        );\\n\\n        // Require that the subdomain is not already owned or owned by this registry\\n        require(\\n            registry.owner(_node) == address(0) ||\\n                registry.owner(_node) == address(this),\\n            \\\"Err: Subdomain already owned\\\"\\n        );\\n\\n        // Take ownership of the subdomain and configure it\\n        bytes32 usernameHash = keccak256(bytes(_username));\\n        registry.setSubnodeOwner(baseNode, usernameHash, address(this));\\n        registry.setResolver(_node, address(resolver));\\n        resolver.setAddr(_node, _account);\\n        registry.setOwner(_node, address(this));\\n\\n        // Emit event to index users on the backend\\n        emit UserRegistered(usernameHash, _account, _username, _publicKey);\\n    }\\n\\n    /**\\n     * @dev Sends a message to a user\\n     * @param _recipient - Address of the recipient of the message\\n     * @param _hash - IPFS hash of the message\\n     */\\n    function sendMessage(address _recipient, string calldata _hash)\\n        external\\n        pausable\\n    {\\n        emit EmailSent(tx.origin, _recipient, _hash);\\n    }\\n\\n    /**\\n     * @dev Batch sends a message to users\\n     * @param _recipients - Addresses of the recipients of the message\\n     * @param _hashes - IPFS hashes of the message\\n     */\\n    function batchSendMessage(\\n        address[] calldata _recipients,\\n        string[] calldata _hashes\\n    ) external pausable {\\n        require(\\n            _recipients.length == _hashes.length,\\n            \\\"Err: Expected same number of recipients as hashes\\\"\\n        );\\n        for (uint256 i = 0; i < _recipients.length; i++) {\\n            emit EmailSent(tx.origin, _recipients[i], _hashes[i]);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/oz/0.8.0/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(\\n            newOwner != address(0),\\n            \\\"Ownable: new owner is the zero address\\\"\\n        );\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/oz/0.8.0/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"},{\"internalType\":\"contract EnsRegistry\",\"name\":\"_registry\",\"type\":\"address\"},{\"internalType\":\"contract EnsResolver\",\"name\":\"_resolver\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_baseNode\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"mailHash\",\"type\":\"string\"}],\"name\":\"EmailSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"usernameHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"username\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"publicKey\",\"type\":\"string\"}],\"name\":\"UserRegistered\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_signer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseNode\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_recipients\",\"type\":\"address[]\"},{\"internalType\":\"string[]\",\"name\":\"_hashes\",\"type\":\"string[]\"}],\"name\":\"batchSendMessage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"publicKey\",\"type\":\"string\"}],\"name\":\"getMessageHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_username\",\"type\":\"string\"}],\"name\":\"node\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_node\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"_username\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_publicKey\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"registerUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"contract EnsRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resolver\",\"outputs\":[{\"internalType\":\"contract EnsResolver\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_hash\",\"type\":\"string\"}],\"name\":\"sendMessage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_node\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"transferDomainOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_node\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"transferSubdomainAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_baseNode\",\"type\":\"bytes32\"}],\"name\":\"updateBaseNode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract EnsRegistry\",\"name\":\"_registry\",\"type\":\"address\"}],\"name\":\"updateRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract EnsResolver\",\"name\":\"_resolver\",\"type\":\"address\"}],\"name\":\"updateResolver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Zapper_Mail_V1","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000002dddd8efc6b053f3b5dc327fb812d180f18878f600000000000000000000000000000000000c2e074ec69a0dfb2997ba6c7d2e1e0000000000000000000000004976fb03c32e5b8cfe2b6ccb31c09ba78ebaba418e148fbcd175fe47dffbb187744fb1b048f92e377f0f6a08eb32a2ea409d7b49","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv2","Proxy":"0","Implementation":"","SwarmSource":""}]}