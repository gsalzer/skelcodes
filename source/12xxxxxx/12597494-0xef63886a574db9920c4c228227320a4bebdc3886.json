{"status":"1","message":"OK","result":[{"SourceCode":"pragma abicoder v2;\r\npragma solidity ^0.7.0;\r\n\r\ncontract BulkTokenMetadata {\r\n    struct Token {\r\n        address token_address;\r\n        uint totalSupply;\r\n        uint decimals;\r\n        string symbol;\r\n        string name;\r\n    }\r\n\r\n  function getTokens(address[] calldata tokenAddresses) external view returns (Token[] memory tokens) {\r\n    tokens = new Token[](tokenAddresses.length);\r\n    \r\n    for(uint i = 0; i < tokenAddresses.length; i++) {\r\n      if(isAContract(tokenAddresses[i])) {\r\n        try this.getTokenInfo(tokenAddresses[i]) returns (Token memory token) {\r\n          tokens[i] = token;\r\n        } catch {\r\n          tokens[i] = Token(address(0), 0, 0, \"\", \"\");  \r\n        }\r\n      } else {\r\n        tokens[i] = Token(address(0), 0, 0, \"\", \"\");   \r\n      }\r\n    }\r\n    return tokens;\r\n  }\r\n  \r\n  function getTokenInfo(address tokenAddress) public view returns (Token memory token) {\r\n    token = Token(tokenAddress, ERC20(tokenAddress).totalSupply(), ERC20(tokenAddress).decimals(), ERC20(tokenAddress).symbol(), ERC20(tokenAddress).name());\r\n  }\r\n    \r\n  // check if contract (token, exchange) is actually a smart contract and not a 'regular' address\r\n  function isAContract(address contractAddr) internal view returns (bool) {\r\n    uint256 codeSize;\r\n    assembly { codeSize := extcodesize(contractAddr) } // contract code size\r\n    return codeSize > 0; \r\n    // Might not be 100% foolproof, but reliable enough for an early return in 'view' functions \r\n  }\r\n}\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint supply);\r\n    function balanceOf(address _owner) external view returns (uint balance);\r\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\r\n    function decimals() external view returns(uint digits);\r\n    function symbol() external view returns (string memory);\r\n    function name() external view returns (string memory);\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"getTokenInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"internalType\":\"struct BulkTokenMetadata.Token\",\"name\":\"token\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokenAddresses\",\"type\":\"address[]\"}],\"name\":\"getTokens\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"internalType\":\"struct BulkTokenMetadata.Token[]\",\"name\":\"tokens\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"BulkTokenMetadata","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://f48f1f47364ea0f27be0e12fcd2378fdb5ba8e952fd194124e57d74fcee384ae"}]}