{"status":"1","message":"OK","result":[{"SourceCode":"\"\"\"\r\n@title Greenwood AaveV2Escrow\r\n@notice Aave V2 integrations for the Greenwood Protocol\r\n@author Greenwood Labs\r\n\"\"\"\r\n\r\n# define the interfaces used by the contract\r\ninterface AAVE_V2_CALCULATOR:\r\n    def calculateBorrow(_borrow_context: AssetContext, _collateral_context: AssetContext, _amount: uint256, _collateralization_ratio: uint256, _version: String[11]) -> AaveV2BorrowCalculation: nonpayable\r\n    def calculateWithdraw(_borrow_context: AssetContext, _collateral_context: AssetContext, _escrow: address, _loan: Loan, _version: String[11]) -> AaveV2WithdrawCalculation: nonpayable\r\n    def calculateRepay(_borrow_context: AssetContext, _collateral_context: AssetContext, _amount: uint256, _escrow: address, _loan: Loan, _version: String[11])-> AaveV2RepayCalculation: nonpayable\r\n\r\ninterface REGISTRY:\r\n    def getAddress(_contract: String[20], _version: String[11]) -> address: nonpayable\r\n    def governance() -> address: nonpayable\r\n\r\ninterface STORE:\r\n    def getAssetContext(_ticker: String[10]) -> AssetContext: view\r\n    def recordLoan(_borrower: address, _borrow_asset: address, _collateral_asset: address, _collateralization_ratio: uint256, _collateral_locked: uint256, _index: uint256, _principal: uint256, _protocol: String[10], _version: String[11]): nonpayable\r\n    def updateLoan(_collateral_locked: uint256, _index: uint256, _loan_key: bytes32, _outstanding: uint256, _version: String[11]): nonpayable\r\n    def getLoan(_loan_key: bytes32) -> Loan: view\r\n    def getLoanProtocol(_loan_key: bytes32) -> String[10]: view\r\n\r\n# define the constants used by the contract\r\nLOOP_LIMIT: constant(uint256) = 100\r\n\r\n# define the events emitted by the contract\r\nevent AddCollateral:\r\n    loanKey: bytes32\r\n    depositor: address\r\n    amount: uint256\r\n    collateralAsset: address\r\n    blockNumber: uint256\r\n\r\nevent Borrow:\r\n    borrower: address\r\n    amount: uint256\r\n    borrowAsset: address\r\n    collateralAsset: address\r\n    blockNumber: uint256\r\n\r\nevent Liquidate:\r\n    loanKey: bytes32\r\n    outstanding: uint256\r\n    borrowAsset: address\r\n    collateralAsset: address\r\n    blockNumber: uint256\r\n\r\nevent Liquidation:\r\n    borrowAsset: address\r\n    collateralAsset: address\r\n    liquidator: address\r\n    loanKeys: bytes32[100]\r\n    redemptionAmount: uint256\r\n    repayAmount: uint256\r\n    blockNumber: uint256\r\n\r\nevent Repay:\r\n    borrower: address\r\n    repaymentAmount: uint256\r\n    repaymentAsset: address\r\n    redemptionAmount: uint256\r\n    redemptionAsset: address\r\n    blockNumber: uint256\r\n\r\nevent SetRegistry:\r\n    previousRegistry: address\r\n    newRegistry: address\r\n    governance: address\r\n    blockNumber: uint256\r\n\r\nevent WithdrawCollateral:\r\n    loanKey: bytes32\r\n    amount: uint256\r\n    collateralAsset: address\r\n    collateralLocked: uint256\r\n    blockNumber: uint256\r\n\r\n# define the structs used by the contract\r\nstruct AaveV2BorrowCalculation:\r\n    requiredCollateral: uint256\r\n    borrowIndex: uint256\r\n    borrowAmount: uint256\r\n    originationFee: uint256\r\n\r\nstruct AaveV2RepayCalculation:\r\n    repayAmount: uint256\r\n    redemptionAmount: int128\r\n    requiredCollateral: uint256\r\n    outstanding: int128\r\n    borrowIndex: uint256\r\n\r\nstruct AaveV2WithdrawCalculation:\r\n    requiredCollateral: uint256\r\n    outstanding: uint256\r\n\r\nstruct AssetContext:\r\n    aToken: address\r\n    aaveV2PriceFeed: address\r\n    aaveV2LendingPool: address\r\n    cToken: address\r\n    compoundPriceFeed: address\r\n    comptroller: address\r\n    decimals: uint256\r\n    underlying: address\r\n\r\nstruct Loan:\r\n    collateralAsset: address\r\n    borrowAsset: address\r\n    outstanding: uint256\r\n    collateralizationRatio: uint256\r\n    collateralLocked: uint256\r\n    borrower: address\r\n    lastBorrowIndex: uint256\r\n    repaymentTime: uint256\r\n\r\n# define the storage variables used by the contract\r\nregistry: public(address)\r\n\r\n@external\r\ndef __init__(_registry: address):\r\n    \"\"\"\r\n    @notice Contract constructor\r\n    @param _registry The address of the Greenwood Registry\r\n    \"\"\"\r\n\r\n    # set the address of the Escrow\r\n    self.registry = _registry\r\n\r\n@internal\r\ndef isAuthorized(_caller: address, _role: String[20], _version: String[11]) -> bool:\r\n    \"\"\"\r\n    @notice Method for role-based security\r\n    @param _caller The address that called the permissioned method\r\n    @param _role The requested authorization level\r\n    @param _version The version of Greenwood to use\r\n    @return True if the caller is authorized, False otherwise\r\n    \"\"\"\r\n\r\n    # check if the requested role is \"controller\"\r\n    if keccak256(_role) == keccak256(\"controller\"):\r\n\r\n        # get the address of the Controller from the Registry\r\n        escrow: address = REGISTRY(self.registry).getAddress(\"controller\", _version)\r\n\r\n        # return the equality comparison boolean\r\n        return escrow == _caller\r\n    \r\n    # check if the requested role is \"governance\"\r\n    elif keccak256(_role) == keccak256(\"governance\"):\r\n\r\n        # get the address of the Governance from the Registry\r\n        governance: address = REGISTRY(self.registry).governance()\r\n\r\n        # return the equality comparison boolean\r\n        return governance == _caller\r\n\r\n    # check if the requested role is \"liquidator\"\r\n    elif keccak256(_role) == keccak256(\"liquidator\"):\r\n\r\n        # get the address of the Liquidator from the Registry\r\n        liquidator: address = REGISTRY(self.registry).getAddress(\"liquidator\", _version)\r\n\r\n        # return the equality comparison boolean\r\n        return liquidator == _caller\r\n\r\n    # catch extraneous role arguments\r\n    else:\r\n\r\n        # revert\r\n        raise \"Unhandled role argument\"\r\n\r\n@external\r\ndef borrow(_borrow_ticker: String[10], _collateral_ticker: String[10], _borrow_context: AssetContext, _collateral_context: AssetContext, _amount: uint256, _borrower: address, _calculator: address, _collateralization_ratio: uint256, _store: address, _version: String[11]):\r\n    \"\"\"\r\n    @notice Borrow assets from Aave V2\r\n    @param _borrow_ticker The ticker string of the asset being borrowed\r\n    @param _collateral_ticker The ticker string of the asset being used as collateral\r\n    @param _borrow_context The AssetContext struct of the asset being borrowed\r\n    @param _collateral_context The AssetContext struct of the asset being used as collateral\r\n    @param _amount The amount of asset being borrowed scaled by the asset's decimals\r\n    @param _borrower The address of the borrower\r\n    @param _calculator The address of the Grenwood Calculator to use\r\n    @param _collateralization_ratio The collateralization ratio for the loan as a percentage\r\n    @param _store The address of the Greenwood Store to use\r\n    @param _version The version of Greenwood to use\r\n    @dev Only the Controller or the Governance can call this method\r\n    \"\"\"\r\n\r\n    # require that the method is being called by the Controller or the Governance\r\n    assert self.isAuthorized(msg.sender, \"controller\", _version) == True or self.isAuthorized(msg.sender, \"governance\", _version) == True, \"Only Controller or Governance can call this method\"\r\n\r\n    # require that the borrow amount is greater than 0 after scaling it down\r\n    assert convert(_amount, decimal) / convert(10 ** _borrow_context.decimals, decimal) > 0.0, \"Borrow amount must be greater than 0\"\r\n\r\n    # get requiredCollateral, borrowIndex, borrowAmount, and protocolFee from the Calculator\r\n    borrowCalculations: AaveV2BorrowCalculation = AAVE_V2_CALCULATOR(_calculator).calculateBorrow(_borrow_context, _collateral_context, _amount, _collateralization_ratio, _version)\r\n\r\n    # check if the origination fee is greater than 0\r\n    if borrowCalculations.originationFee > 0:\r\n\r\n        # get the address of the Treasury from the Registry\r\n        treasury: address = REGISTRY(self.registry).getAddress(\"treasury\", _version)\r\n\r\n        # require that a Treasury address was returned from the Store\r\n        assert treasury != ZERO_ADDRESS, \"No Treasury address returned from the Store\"\r\n\r\n        # transfer the origination fee to the Treasury\r\n        transferResponse: Bytes[32] = raw_call(\r\n            _collateral_context.underlying,\r\n            concat(\r\n                method_id(\"transferFrom(address,address,uint256)\"),\r\n                convert(_borrower, bytes32),\r\n                convert(treasury, bytes32),\r\n                convert(borrowCalculations.originationFee, bytes32),\r\n            ),\r\n            max_outsize=32,\r\n        )\r\n        if len(transferResponse) > 0:\r\n            assert convert(transferResponse, bool), \"Failed safeTransfer\"\r\n\r\n    # move collateral from the borrower to the Escrow using safeTransferFrom \r\n    transferFromResponse: Bytes[32] = raw_call(\r\n        _collateral_context.underlying,\r\n        concat(\r\n            method_id(\"transferFrom(address,address,uint256)\"),\r\n            convert(_borrower, bytes32),\r\n            convert(self, bytes32),\r\n            convert(borrowCalculations.requiredCollateral, bytes32),\r\n        ),\r\n        max_outsize=32,\r\n    )\r\n    if len(transferFromResponse) > 0:\r\n        assert convert(transferFromResponse, bool), \"Failed safeTransferFrom\"\r\n\r\n    # approve the collateral transfer from Escrow to the Aave V2 LendingPool\r\n    approveResponse: Bytes[32] = raw_call(\r\n        _collateral_context.underlying,\r\n        concat(\r\n            method_id(\"approve(address,uint256)\"),\r\n            convert(_collateral_context.aaveV2LendingPool, bytes32),\r\n            convert(borrowCalculations.requiredCollateral, bytes32),\r\n        ),\r\n        max_outsize=32,\r\n    )\r\n    if len(approveResponse) > 0:\r\n        assert convert(approveResponse, bool), \"Failed approve\"\r\n\r\n    # supply the collateral to Aave V2\r\n    raw_call(\r\n        _collateral_context.aaveV2LendingPool,\r\n        concat(\r\n            method_id(\"deposit(address,uint256,address,uint16)\"),\r\n            convert(_collateral_context.underlying, bytes32),\r\n            convert(borrowCalculations.requiredCollateral, bytes32),\r\n            convert(self, bytes32),\r\n            convert(0, bytes32) \r\n        )\r\n    )\r\n\r\n    # execute the borrow on Aave V2\r\n    raw_call(\r\n        _borrow_context.aaveV2LendingPool,\r\n        concat(\r\n            method_id(\"borrow(address,uint256,uint256,uint16,address)\"),\r\n            convert(_borrow_context.underlying, bytes32),\r\n            convert(_amount, bytes32),\r\n            convert(2, bytes32),\r\n            convert(0, bytes32),\r\n            convert(self, bytes32),\r\n        )\r\n    )\r\n\r\n    # transfer the borrowed asset to the borrower using safeTransfer\r\n    transferResponse: Bytes[32] = raw_call(\r\n        _borrow_context.underlying,\r\n        concat(\r\n            method_id(\"transfer(address,uint256)\"),\r\n            convert(_borrower, bytes32),\r\n            convert(_amount, bytes32),\r\n        ),\r\n        max_outsize=32,\r\n    )\r\n    if len(transferResponse) > 0:\r\n        assert convert(transferResponse, bool), \"Failed safeTransfer\"\r\n\r\n    # call recordLoan() on the Store to store the loan data\r\n    STORE(_store).recordLoan(_borrower, _borrow_context.underlying, _collateral_context.underlying, _collateralization_ratio, borrowCalculations.requiredCollateral, borrowCalculations.borrowIndex, _amount, \"aavev2\", _version)\r\n\r\n    # emit a Borrow event\r\n    log Borrow(_borrower, _amount, _borrow_context.underlying, _collateral_context.underlying, block.number)\r\n    \r\n@external\r\ndef repay(_borrow_ticker: String[10], _collateral_ticker: String[10], _amount: uint256, _calculator: address, _loan_key: bytes32, _store: address, _version: String[11]):\r\n    \"\"\"\r\n    @notice Repay an Aave V2 loan\r\n    @param _borrow_ticker The ticker string of the asset that was borrowed\r\n    @param _collateral_ticker The ticker string of the asset that is being used as collateral\r\n    @param _amount The amount of the repayment scaled by the asset's decimals\r\n    @param _calculator The address of the Greenwood Calculator to use\r\n    @param _loan_key The uinque identifier for the loan\r\n    @param _store The address of the Greenwood Store to use\r\n    @param _version The version of Greenwood to use\r\n    @dev Only the Controller or the Governance can call this method\r\n    \"\"\"\r\n\r\n    # require that the method is being called by the Controller or the Governance\r\n    assert self.isAuthorized(msg.sender, \"controller\", _version) == True or self.isAuthorized(msg.sender, \"governance\", _version) == True, \"Only Controller or Governance can call this method\"\r\n\r\n    # get the loan protocol from the Store\r\n    loanProtocol: String[10] = STORE(_store).getLoanProtocol(_loan_key)\r\n\r\n    # get the rest of the loan data from the Store\r\n    loan: Loan = STORE(_store).getLoan(_loan_key)\r\n\r\n    # require that the outstanding balance of the loan is greater than 0\r\n    assert loan.outstanding > 0, \"Outstanding balance must be greater than 0\"\r\n\r\n    # get the asset contexts for the borrow asset and the collateral asset from the Store\r\n    borrowContext: AssetContext = STORE(_store).getAssetContext(_borrow_ticker)\r\n    collateralContext: AssetContext = STORE(_store).getAssetContext(_collateral_ticker)\r\n    \r\n    # require the the loan assets match the underlying assets of the contexts\r\n    assert borrowContext.underlying == loan.borrowAsset, \"Borrow context mismatch\"\r\n    assert collateralContext.underlying == loan.collateralAsset, \"Collateral context mismatch\"\r\n\r\n    # check if this is a full repayment\r\n    if _amount != MAX_UINT256:\r\n\r\n        # require that the repay amount is greater than 0 after scaling it down\r\n        assert convert(_amount, decimal) / convert(10 ** borrowContext.decimals, decimal) > 0.0, \"Repayment amount must be greater than 0\"\r\n    \r\n    # check that this loan was originated with Aave V2\r\n    if keccak256(loanProtocol) == keccak256(\"aavev2\"):\r\n\r\n        # get the redemption amount from the Calculator\r\n        repayCalculations: AaveV2RepayCalculation = AAVE_V2_CALCULATOR(_calculator).calculateRepay(borrowContext, collateralContext, _amount, self, loan, _version)\r\n\r\n        # move the repayment asset (borrow asset) from the borrower to the Escrow\r\n        transferFromResponse: Bytes[32] = raw_call(\r\n            borrowContext.underlying,\r\n            concat(\r\n                method_id(\"transferFrom(address,address,uint256)\"),\r\n                convert(loan.borrower, bytes32),\r\n                convert(self, bytes32),\r\n                convert(repayCalculations.repayAmount, bytes32),\r\n            ),\r\n            max_outsize=32,\r\n        ) \r\n        if len(transferFromResponse) > 0:\r\n            assert convert(transferFromResponse, bool), \"Failed safeTransferFrom\"\r\n        \r\n        # approve the Aave V2 LendingPool to access the token balance of the Escrow\r\n        approveResponse: Bytes[32] = raw_call(\r\n            borrowContext.underlying,\r\n            concat(\r\n                method_id(\"approve(address,uint256)\"),\r\n                convert(borrowContext.aaveV2LendingPool, bytes32),\r\n                convert(repayCalculations.repayAmount, bytes32),\r\n            ),\r\n            max_outsize=32,\r\n        )\r\n        if len(approveResponse) > 0:\r\n            assert convert(approveResponse, bool), \"Failed approve\"    \r\n\r\n        # call repay() on the Aave V2 LendingPool\r\n        raw_call(\r\n            borrowContext.aaveV2LendingPool,\r\n            concat(\r\n                method_id(\"repay(address,uint256,uint256,address)\"),\r\n                convert(borrowContext.underlying, bytes32),\r\n                convert(repayCalculations.repayAmount, bytes32),\r\n                convert(2, bytes32),\r\n                convert(self, bytes32)\r\n            ),\r\n        )\r\n\r\n        # check if the redemption amount is less than 0\r\n        if repayCalculations.redemptionAmount < 0:\r\n\r\n            # emit a Liquidate event because the loan is undercollateralized\r\n            log Liquidate(_loan_key, loan.outstanding, borrowContext.underlying, collateralContext.underlying, block.number)\r\n\r\n        # check if the redemption amount is greater than 0\r\n        elif repayCalculations.redemptionAmount > 0:\r\n\r\n            # allow the Aave V2 LendingPool to burn the aTokens\r\n            approveBurnResponse: Bytes[32] = raw_call(\r\n                collateralContext.aToken,\r\n                concat(\r\n                    method_id(\"approve(address,uint256)\"),\r\n                    convert(collateralContext.aaveV2LendingPool, bytes32),\r\n                    convert(convert(repayCalculations.redemptionAmount, uint256), bytes32),\r\n                ),\r\n                max_outsize=32,\r\n            )\r\n            if len(approveBurnResponse) > 0:\r\n                assert convert(approveBurnResponse, bool), \"Failed approve\"\r\n\r\n            # call withdraw() on the Aave V2 LendingPool\r\n            raw_call(\r\n                collateralContext.aaveV2LendingPool,\r\n                concat(\r\n                    method_id(\"withdraw(address,uint256,address)\"),\r\n                    convert(collateralContext.underlying, bytes32),\r\n                    convert(convert(repayCalculations.redemptionAmount, uint256), bytes32),\r\n                    convert(self, bytes32)\r\n                ),\r\n            )\r\n            \r\n            # transfer the redeemed collateral asset back to the borrower\r\n            transferResponse: Bytes[32] = raw_call(\r\n                collateralContext.underlying,\r\n                concat(\r\n                    method_id(\"transfer(address,uint256)\"),\r\n                    convert(loan.borrower, bytes32),\r\n                    convert(convert(repayCalculations.redemptionAmount, uint256), bytes32),\r\n                ),\r\n                max_outsize=32,\r\n            )\r\n            if len(transferResponse) > 0:\r\n                assert convert(transferResponse, bool), \"Failed safeTransfer\"\r\n\r\n            # update the loan with collateral needed, checkpoint borrow index, and outstanding balance\r\n            STORE(_store).updateLoan(repayCalculations.requiredCollateral, repayCalculations.borrowIndex, _loan_key, convert(repayCalculations.outstanding, uint256), _version)\r\n\r\n            # emit a Repay event\r\n            log Repay(loan.borrower, repayCalculations.repayAmount, borrowContext.underlying, convert(repayCalculations.redemptionAmount, uint256), collateralContext.underlying, block.number)\r\n                \r\n        # check if the redemption amount is equal to 0\r\n        elif repayCalculations.redemptionAmount == 0:\r\n\r\n            # emit a Repay event\r\n            log Repay(loan.borrower, repayCalculations.repayAmount, borrowContext.underlying, convert(repayCalculations.redemptionAmount, uint256), collateralContext.underlying, block.number)\r\n    \r\n    # catch extraneous lending protocols\r\n    else:\r\n        raise \"Unhandled protocol\"\r\n\r\n\r\n@external\r\ndef addCollateral(_collateral_ticker: String[10], _amount: uint256, _depositor: address, _loan_key: bytes32, _store: address, _version: String[11]):\r\n    \"\"\"\r\n    @notice Add collateral to Aave V2\r\n    @param _collateral_ticker The ticker string of the asset that is being used as collateral\r\n    @param _amount The amount of the deposit scaled by the asset's decimals\r\n    @param _depositor The address of the depositor\r\n    @param _loan_key The uinque identifier for the loan\r\n    @param _store The address of the Greenwood Store contract to use\r\n    @param _version The version of Greenwood to use\r\n    @dev Only the Controller or the Governance can call this method\r\n    \"\"\"\r\n\r\n    # require that the method is being called by the Controller or the Governance\r\n    assert self.isAuthorized(msg.sender, \"controller\", _version) == True or self.isAuthorized(msg.sender, \"governance\", _version) == True, \"Only Controller or Governance can call this method\"\r\n\r\n    # get the loan's protocol from the Store\r\n    protocol: String[10] = STORE(_store).getLoanProtocol(_loan_key)\r\n\r\n    # require that a protocol was returned from the Store\r\n    assert keccak256(protocol) != keccak256(\"\"), \"No loan protocol returned from the Store\"\r\n\r\n    # get the loan data from the Store\r\n    loan: Loan = STORE(_store).getLoan(_loan_key)\r\n\r\n    # get the context of the collateral asset from the Store\r\n    collateralContext: AssetContext = STORE(_store).getAssetContext(_collateral_ticker)\r\n\r\n    # require that the loan's collateral asset and underlying asset of the collateral context match\r\n    assert loan.collateralAsset == collateralContext.underlying, \"Collateral context mismatch\"\r\n\r\n    # require that the deposit amount is greater than 0 after scaling it down\r\n    assert convert(_amount, decimal) / convert(10 ** collateralContext.decimals, decimal) > 0.0, \"Deposit amount must be greater than 0\"\r\n\r\n    # check if this loan was originated with Aave V2\r\n    if keccak256(protocol) == keccak256(\"aavev2\"):\r\n\r\n        # move collateral from user to Escrow \r\n        transferFromResponse: Bytes[32] = raw_call(\r\n            collateralContext.underlying,\r\n            concat(\r\n                method_id(\"transferFrom(address,address,uint256)\"),\r\n                convert(_depositor, bytes32),\r\n                convert(self, bytes32),\r\n                convert(_amount, bytes32),\r\n            ),\r\n            max_outsize=32,\r\n        ) \r\n        if len(transferFromResponse) > 0:\r\n            assert convert(transferFromResponse, bool), \"Failed safeTransferFrom\"\r\n\r\n        # approve the collateral transfer from Escrow to Aave V2\r\n        approveResponse: Bytes[32] = raw_call(\r\n            collateralContext.underlying,\r\n            concat(\r\n                method_id(\"approve(address,uint256)\"),\r\n                convert(collateralContext.aaveV2LendingPool, bytes32),\r\n                convert(_amount, bytes32),\r\n            ),\r\n            max_outsize=32,\r\n        )\r\n        if len(approveResponse) > 0:\r\n            assert convert(approveResponse, bool), \"Failed approve\"\r\n\r\n        # supply the collateral to Aave V2\r\n        raw_call(\r\n            collateralContext.aaveV2LendingPool,\r\n            concat(\r\n                method_id(\"deposit(address,uint256,address,uint16)\"),\r\n                convert(collateralContext.underlying, bytes32),\r\n                convert(_amount, bytes32),\r\n                convert(self, bytes32),\r\n                convert(0, bytes32) \r\n            )\r\n        )\r\n        \r\n        # add the amount of collateral to the existing amount of collateralLocked\r\n        collateralLocked: uint256 = loan.collateralLocked + _amount\r\n\r\n        # pass borrowIndex of 0 so this member of the  Loan truct is not updated\r\n        borrowIndex: uint256 = 0\r\n\r\n        # update the loan with the new value of collateral locked\r\n        STORE(_store).updateLoan(collateralLocked, borrowIndex, _loan_key, loan.outstanding, _version)\r\n\r\n        # emit an AddCollateral event\r\n        log AddCollateral(_loan_key, _depositor, _amount, collateralContext.underlying, block.number)\r\n        \r\n    else:\r\n        raise \"malformed protocol string\"\r\n\r\n@external\r\ndef withdrawCollateral(_borrow_ticker: String[10], _collateral_ticker: String[10], _amount: uint256, _calculator: address, _loan_key: bytes32,  _store: address, _version: String[11]):\r\n    \"\"\"\r\n    @notice Withdraw collateral from Aave V2\r\n    @param _borrow_ticker The ticker string of the asset that was borrowed\r\n    @param _collateral_ticker The ticker string of the asset that is being used as collateral\r\n    @param _amount The amount to withdraw scaled by the asset's decimals\r\n    @param _calculator The address of the Greenwood Calculator to use\r\n    @param _loan_key The uinque identifier for the loan\r\n    @param _store The address of the Greenwood Store to use\r\n    @param _version The version of Greenwood to use\r\n    @dev Only the Controller or the Governance can call this method\r\n    \"\"\"\r\n\r\n    # require that the method is being called by the Controller or the Governance\r\n    assert self.isAuthorized(msg.sender, \"controller\", _version) == True or self.isAuthorized(msg.sender, \"governance\", _version) == True, \"Only Controller or Governance can call this method\"\r\n\r\n    # get the loan's protocol from the Store \r\n    protocol: String[10] = STORE(_store).getLoanProtocol(_loan_key)\r\n\r\n    # require that a protocol was returned from the Store\r\n    assert keccak256(protocol) != keccak256(\"\"), \"No loan protocol returned from the Store\"\r\n\r\n    # get the loan data from the Store \r\n    loan: Loan = STORE(_store).getLoan(_loan_key)\r\n\r\n    # get the asset contexts for the borrow asset and the collateral asset from the Store\r\n    collateralContext: AssetContext = STORE(_store).getAssetContext(_collateral_ticker)\r\n    borrowContext: AssetContext = STORE(_store).getAssetContext(_borrow_ticker)\r\n\r\n    # require the the loan assets match the underlying assets of the contexts\r\n    assert loan.borrowAsset == borrowContext.underlying, \"Borrow context mismatch\"\r\n    assert loan.collateralAsset == collateralContext.underlying, \"Collateral context mismatch\"\r\n\r\n    # require that the withdraw amount is greater than 0 after scaling it down\r\n    assert convert(_amount, decimal) / convert(10 ** collateralContext.decimals, decimal) > 0.0, \"Withdraw amount must be greater than 0\"\r\n\r\n    # check if this loan was originated with Aave V2\r\n    if keccak256(protocol) == keccak256(\"aavev2\"):\r\n\r\n        # get the withdraw calculations from the Calculator\r\n        withdrawCalculations: AaveV2WithdrawCalculation = AAVE_V2_CALCULATOR(_calculator).calculateWithdraw(borrowContext, collateralContext, self, loan, _version)\r\n\r\n        # require that this withdraw does not violate collateral requirements\r\n        assert loan.collateralLocked - _amount >= withdrawCalculations.requiredCollateral, \"Withdraw amount violates collateral requirements\"\r\n\r\n        # allow the Aave V2 LendingPool to burn the aTokens\r\n        approveBurnResponse: Bytes[32] = raw_call(\r\n            collateralContext.aToken,\r\n            concat(\r\n                method_id(\"approve(address,uint256)\"),\r\n                convert(collateralContext.aaveV2LendingPool, bytes32),\r\n                convert(_amount, bytes32),\r\n            ),\r\n            max_outsize=32,\r\n        )\r\n        if len(approveBurnResponse) > 0:\r\n            assert convert(approveBurnResponse, bool), \"Failed approve\"\r\n\r\n        # call withdraw() on the Aave V2 LendingPool\r\n        raw_call(\r\n            collateralContext.aaveV2LendingPool,\r\n            concat(\r\n                method_id(\"withdraw(address,uint256,address)\"),\r\n                convert(collateralContext.underlying, bytes32),\r\n                convert(_amount, bytes32),\r\n                convert(self, bytes32)\r\n            ),\r\n        )\r\n\r\n        # recalculate collateral locked by subtracting the withdraw amount from collateralLocked\r\n        collateralLocked: uint256 = loan.collateralLocked - _amount\r\n\r\n        # transfer the redeemed collateral asset back to the borrower\r\n        transferResponse: Bytes[32] = raw_call(\r\n            collateralContext.underlying,\r\n            concat(\r\n                method_id(\"transfer(address,uint256)\"),\r\n                convert(loan.borrower, bytes32),\r\n                convert(_amount, bytes32),\r\n            ),\r\n            max_outsize=32,\r\n        )\r\n        if len(transferResponse) > 0:\r\n            assert convert(transferResponse, bool), \"Failed safeTransfer\"\r\n\r\n        # pass borrowIndex of 0 so this member of the struct is not updated\r\n        borrowIndex: uint256 = 0\r\n\r\n        # update the loan with outstanding balance and collateral needed\r\n        STORE(_store).updateLoan(collateralLocked, borrowIndex, _loan_key, withdrawCalculations.outstanding, _version)\r\n        \r\n        # emit a WithdrawCollateral event\r\n        log WithdrawCollateral(_loan_key, _amount, collateralContext.underlying, collateralLocked, block.number)\r\n\r\n    # revert, unhandled loan.protocol\r\n    else:\r\n        raise \"malformed protocol string\"\r\n\r\n@external\r\ndef liquidate(_borrow_ticker: String[10], _collateral_ticker: String[10], _borrow_index: uint256, _key_count: uint256, _loan_keys: bytes32[100], _liquidator: address, _redeem_amount: uint256, _repay_amount: uint256, _store: address, _version: String[11]):\r\n    \"\"\"\r\n    @notice Liquidate undercollateralized loans\r\n    @param _borrow_ticker The ticker string of the asset that was borrowed\r\n    @param _collateral_ticker The ticker string of the asset that is being used as collateral\r\n    @param _borrow_index The latest borrow index from the underlying lending protocol\r\n    @param _key_count The number of keys in the _loan_keys array\r\n    @param _liquidator The address of the liquidator\r\n    @param _redeem_amount The amount of collateral asset to redeem\r\n    @param _repay_amount The amount of borrowed asset to repay\r\n    @param _store The address of the Greenwood Store to use\r\n    @param _version The version of Greenwood to use\r\n    @dev Only the Controller or the Governance can call this method\r\n    \"\"\"\r\n\r\n    # require that the method is being called by the Liquidator or the Governance\r\n    assert self.isAuthorized(msg.sender, \"liquidator\", _version) == True or self.isAuthorized(msg.sender, \"governance\", _version) == True, \"Only Liquidator or Governance can call this method\"\r\n\r\n    # get the asset contexts for the borrow asset and the collateral asset from the Store\r\n    borrowContext: AssetContext = STORE(_store).getAssetContext(_borrow_ticker)\r\n    collateralContext: AssetContext = STORE(_store).getAssetContext(_collateral_ticker)\r\n\r\n    # require that the liquidation redemption amount is greater than 0\r\n    assert _redeem_amount > 0, \"Liquidation redeem amount must be greater than 0\"\r\n\r\n    # require that the liquidation repayment amount is greater than 0\r\n    assert _repay_amount > 0, \"Liquidation repay amount must be greater than 0\"\r\n\r\n    # move repayment asset (borrow asset) from Liquidator to Escrow\r\n    transferFromResponse: Bytes[32] = raw_call(\r\n        borrowContext.underlying,\r\n        concat(\r\n            method_id(\"transferFrom(address,address,uint256)\"),\r\n            convert(_liquidator, bytes32),\r\n            convert(self, bytes32),\r\n            convert(_repay_amount, bytes32),\r\n        ),\r\n        max_outsize=32,\r\n    ) \r\n    if len(transferFromResponse) > 0:\r\n        assert convert(transferFromResponse, bool), \"Failed safeTransferFrom\"\r\n\r\n    # approve the Aave V2 LendingPool to access the token balance of Escrow\r\n    approveResponse: Bytes[32] = raw_call(\r\n        borrowContext.underlying,\r\n        concat(\r\n            method_id(\"approve(address,uint256)\"),\r\n            convert(borrowContext.aaveV2LendingPool, bytes32),\r\n            convert(_repay_amount, bytes32),\r\n        ),\r\n        max_outsize=32,\r\n    )\r\n    if len(approveResponse) > 0:\r\n        assert convert(approveResponse, bool), \"Failed approve\"\r\n\r\n    # call repay() on the Aave V2 LendingPool\r\n    raw_call(\r\n        borrowContext.aaveV2LendingPool,\r\n        concat(\r\n            method_id(\"repay(address,uint256,uint256,address)\"),\r\n            convert(borrowContext.underlying, bytes32),\r\n            convert(_repay_amount, bytes32),\r\n            convert(2, bytes32),\r\n            convert(self, bytes32)\r\n        ),\r\n    )\r\n\r\n    # allow the Aave V2 LendingPool to burn the aTokens\r\n    approveBurnResponse: Bytes[32] = raw_call(\r\n        collateralContext.aToken,\r\n        concat(\r\n            method_id(\"approve(address,uint256)\"),\r\n            convert(collateralContext.aaveV2LendingPool, bytes32),\r\n            convert(_redeem_amount, bytes32),\r\n        ),\r\n        max_outsize=32,\r\n    )\r\n    if len(approveBurnResponse) > 0:\r\n        assert convert(approveBurnResponse, bool), \"Failed approve\"\r\n\r\n    # call withdraw() on the Aave V2 LendingPool\r\n    raw_call(\r\n        collateralContext.aaveV2LendingPool,\r\n        concat(\r\n            method_id(\"withdraw(address,uint256,address)\"),\r\n            convert(collateralContext.underlying, bytes32),\r\n            convert(_redeem_amount, bytes32),\r\n            convert(self, bytes32)\r\n        ),\r\n    )\r\n\r\n    # transfer the redeemed collateral asset to the liquidator\r\n    transferResponse: Bytes[32] = raw_call(\r\n        collateralContext.underlying,\r\n        concat(\r\n            method_id(\"transfer(address,uint256)\"),\r\n            convert(_liquidator, bytes32),\r\n            convert(_redeem_amount, bytes32),\r\n        ),\r\n        max_outsize=32,\r\n    )\r\n    if len(transferResponse) > 0:\r\n        assert convert(transferResponse, bool), \"Failed safeTransfer\"\r\n\r\n    # declare memory variable to store the number of loan keys that have been processed\r\n    loanKeyCounter: uint256 = 0\r\n\r\n    # update the outstanding balance and collateral needed for the loans\r\n    for i in range(LOOP_LIMIT):\r\n        if loanKeyCounter < _key_count:\r\n            STORE(_store).updateLoan(0, _borrow_index, _loan_keys[i], 0, _version)\r\n\r\n            # increment the loan key counter\r\n            loanKeyCounter += 1\r\n        \r\n        # all loan keys have been processed\r\n        elif loanKeyCounter == _key_count:\r\n\r\n            # halt loop execution\r\n            break\r\n\r\n        else:\r\n\r\n            # halt loop execution as a fallback case\r\n            break\r\n\r\n    # emit a Liquidation event\r\n    log Liquidation(borrowContext.underlying, collateralContext.underlying, _liquidator, _loan_keys, _redeem_amount, _repay_amount, block.number)\r\n\r\n@external\r\ndef setRegistry(_new_registry: address):\r\n    \"\"\"\r\n    @notice Updates the address of the Registry\r\n    @param _new_registry The address of the new Greenwood Registry\r\n    @dev Only the Governance can call this method\r\n    @dev Only call this method with a valid Greenwood Registry or subsequent calls will fail!\r\n    \"\"\"\r\n\r\n    # require that the method caller is the Governance\r\n    assert self.isAuthorized(msg.sender, \"governance\", \"\") == True, \"Only Governance can call this method\"\r\n\r\n    # get the previous Registry\r\n    previousRegistry: address = self.registry\r\n\r\n    # update the address of the Registry\r\n    self.registry = _new_registry\r\n\r\n    # emit a SetRegistry event\r\n    log SetRegistry(previousRegistry, _new_registry, msg.sender, block.number)","ABI":"[{\"name\":\"AddCollateral\",\"inputs\":[{\"type\":\"bytes32\",\"name\":\"loanKey\",\"indexed\":false},{\"type\":\"address\",\"name\":\"depositor\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"amount\",\"indexed\":false},{\"type\":\"address\",\"name\":\"collateralAsset\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"blockNumber\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Borrow\",\"inputs\":[{\"type\":\"address\",\"name\":\"borrower\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"amount\",\"indexed\":false},{\"type\":\"address\",\"name\":\"borrowAsset\",\"indexed\":false},{\"type\":\"address\",\"name\":\"collateralAsset\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"blockNumber\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Liquidate\",\"inputs\":[{\"type\":\"bytes32\",\"name\":\"loanKey\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"outstanding\",\"indexed\":false},{\"type\":\"address\",\"name\":\"borrowAsset\",\"indexed\":false},{\"type\":\"address\",\"name\":\"collateralAsset\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"blockNumber\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Liquidation\",\"inputs\":[{\"type\":\"address\",\"name\":\"borrowAsset\",\"indexed\":false},{\"type\":\"address\",\"name\":\"collateralAsset\",\"indexed\":false},{\"type\":\"address\",\"name\":\"liquidator\",\"indexed\":false},{\"type\":\"bytes32[100]\",\"name\":\"loanKeys\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"redemptionAmount\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"repayAmount\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"blockNumber\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Repay\",\"inputs\":[{\"type\":\"address\",\"name\":\"borrower\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"repaymentAmount\",\"indexed\":false},{\"type\":\"address\",\"name\":\"repaymentAsset\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"redemptionAmount\",\"indexed\":false},{\"type\":\"address\",\"name\":\"redemptionAsset\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"blockNumber\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetRegistry\",\"inputs\":[{\"type\":\"address\",\"name\":\"previousRegistry\",\"indexed\":false},{\"type\":\"address\",\"name\":\"newRegistry\",\"indexed\":false},{\"type\":\"address\",\"name\":\"governance\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"blockNumber\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"WithdrawCollateral\",\"inputs\":[{\"type\":\"bytes32\",\"name\":\"loanKey\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"amount\",\"indexed\":false},{\"type\":\"address\",\"name\":\"collateralAsset\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"collateralLocked\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"blockNumber\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_registry\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"name\":\"borrow\",\"outputs\":[],\"inputs\":[{\"type\":\"string\",\"name\":\"_borrow_ticker\"},{\"type\":\"string\",\"name\":\"_collateral_ticker\"},{\"type\":\"tuple\",\"name\":\"_borrow_context\",\"components\":[{\"type\":\"address\",\"name\":\"aToken\"},{\"type\":\"address\",\"name\":\"aaveV2PriceFeed\"},{\"type\":\"address\",\"name\":\"aaveV2LendingPool\"},{\"type\":\"address\",\"name\":\"cToken\"},{\"type\":\"address\",\"name\":\"compoundPriceFeed\"},{\"type\":\"address\",\"name\":\"comptroller\"},{\"type\":\"uint256\",\"name\":\"decimals\"},{\"type\":\"address\",\"name\":\"underlying\"}]},{\"type\":\"tuple\",\"name\":\"_collateral_context\",\"components\":[{\"type\":\"address\",\"name\":\"aToken\"},{\"type\":\"address\",\"name\":\"aaveV2PriceFeed\"},{\"type\":\"address\",\"name\":\"aaveV2LendingPool\"},{\"type\":\"address\",\"name\":\"cToken\"},{\"type\":\"address\",\"name\":\"compoundPriceFeed\"},{\"type\":\"address\",\"name\":\"comptroller\"},{\"type\":\"uint256\",\"name\":\"decimals\"},{\"type\":\"address\",\"name\":\"underlying\"}]},{\"type\":\"uint256\",\"name\":\"_amount\"},{\"type\":\"address\",\"name\":\"_borrower\"},{\"type\":\"address\",\"name\":\"_calculator\"},{\"type\":\"uint256\",\"name\":\"_collateralization_ratio\"},{\"type\":\"address\",\"name\":\"_store\"},{\"type\":\"string\",\"name\":\"_version\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":53885},{\"name\":\"repay\",\"outputs\":[],\"inputs\":[{\"type\":\"string\",\"name\":\"_borrow_ticker\"},{\"type\":\"string\",\"name\":\"_collateral_ticker\"},{\"type\":\"uint256\",\"name\":\"_amount\"},{\"type\":\"address\",\"name\":\"_calculator\"},{\"type\":\"bytes32\",\"name\":\"_loan_key\"},{\"type\":\"address\",\"name\":\"_store\"},{\"type\":\"string\",\"name\":\"_version\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":55486},{\"name\":\"addCollateral\",\"outputs\":[],\"inputs\":[{\"type\":\"string\",\"name\":\"_collateral_ticker\"},{\"type\":\"uint256\",\"name\":\"_amount\"},{\"type\":\"address\",\"name\":\"_depositor\"},{\"type\":\"bytes32\",\"name\":\"_loan_key\"},{\"type\":\"address\",\"name\":\"_store\"},{\"type\":\"string\",\"name\":\"_version\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":38820},{\"name\":\"withdrawCollateral\",\"outputs\":[],\"inputs\":[{\"type\":\"string\",\"name\":\"_borrow_ticker\"},{\"type\":\"string\",\"name\":\"_collateral_ticker\"},{\"type\":\"uint256\",\"name\":\"_amount\"},{\"type\":\"address\",\"name\":\"_calculator\"},{\"type\":\"bytes32\",\"name\":\"_loan_key\"},{\"type\":\"address\",\"name\":\"_store\"},{\"type\":\"string\",\"name\":\"_version\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":43976},{\"name\":\"liquidate\",\"outputs\":[],\"inputs\":[{\"type\":\"string\",\"name\":\"_borrow_ticker\"},{\"type\":\"string\",\"name\":\"_collateral_ticker\"},{\"type\":\"uint256\",\"name\":\"_borrow_index\"},{\"type\":\"uint256\",\"name\":\"_key_count\"},{\"type\":\"bytes32[100]\",\"name\":\"_loan_keys\"},{\"type\":\"address\",\"name\":\"_liquidator\"},{\"type\":\"uint256\",\"name\":\"_redeem_amount\"},{\"type\":\"uint256\",\"name\":\"_repay_amount\"},{\"type\":\"address\",\"name\":\"_store\"},{\"type\":\"string\",\"name\":\"_version\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":411348},{\"name\":\"setRegistry\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_new_registry\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":47208},{\"name\":\"registry\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1361}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.3","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"0000000000000000000000001ddbb7a21905c6a8dbd76b20b7c6b3a55d1af24f","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":""}]}