{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/models/Ecosystem.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPLv3\\npragma solidity 0.7.2;\\npragma experimental ABIEncoderV2;\\n\\nimport '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\\n\\nimport './EternalModel.sol';\\n\\n/**\\n * @title ElasticDAO ecosystem\\n * @author ElasticDAO - https://ElasticDAO.org\\n * @notice This contract is used for storing core dao data\\n * @dev ElasticDAO network contracts can read/write from this contract\\n * @dev Serialize - Translation of data from the concerned struct to key-value pairs\\n * @dev Deserialize - Translation of data from the key-value pairs to a struct\\n */\\ncontract Ecosystem is EternalModel, ReentrancyGuard {\\n  struct Instance {\\n    address daoAddress;\\n    // Models\\n    address daoModelAddress;\\n    address ecosystemModelAddress;\\n    address tokenHolderModelAddress;\\n    address tokenModelAddress;\\n    // Tokens\\n    address governanceTokenAddress;\\n  }\\n\\n  event Serialized(address indexed _daoAddress);\\n\\n  /**\\n   * @dev deserializes Instance struct\\n   * @param _daoAddress - address of the unique user ID\\n   * @return record Instance\\n   */\\n  function deserialize(address _daoAddress) external view returns (Instance memory record) {\\n    if (_exists(_daoAddress)) {\\n      record.daoAddress = _daoAddress;\\n      record.daoModelAddress = getAddress(\\n        keccak256(abi.encode(record.daoAddress, 'daoModelAddress'))\\n      );\\n      record.ecosystemModelAddress = address(this);\\n      record.governanceTokenAddress = getAddress(\\n        keccak256(abi.encode(record.daoAddress, 'governanceTokenAddress'))\\n      );\\n      record.tokenHolderModelAddress = getAddress(\\n        keccak256(abi.encode(record.daoAddress, 'tokenHolderModelAddress'))\\n      );\\n      record.tokenModelAddress = getAddress(\\n        keccak256(abi.encode(record.daoAddress, 'tokenModelAddress'))\\n      );\\n    }\\n\\n    return record;\\n  }\\n\\n  /**\\n   * @dev checks if @param _daoAddress\\n   * @param _daoAddress - address of the unique user ID\\n   * @return recordExists bool\\n   */\\n  function exists(address _daoAddress) external view returns (bool recordExists) {\\n    return _exists(_daoAddress);\\n  }\\n\\n  /**\\n   * @dev serializes Instance struct\\n   * @param _record Instance\\n   */\\n  function serialize(Instance memory _record) external nonReentrant {\\n    bool recordExists = _exists(_record.daoAddress);\\n\\n    require(\\n      msg.sender == _record.daoAddress || (_record.daoAddress == address(0) && !recordExists),\\n      'ElasticDAO: Unauthorized'\\n    );\\n\\n    setAddress(\\n      keccak256(abi.encode(_record.daoAddress, 'daoModelAddress')),\\n      _record.daoModelAddress\\n    );\\n    setAddress(\\n      keccak256(abi.encode(_record.daoAddress, 'governanceTokenAddress')),\\n      _record.governanceTokenAddress\\n    );\\n    setAddress(\\n      keccak256(abi.encode(_record.daoAddress, 'tokenHolderModelAddress')),\\n      _record.tokenHolderModelAddress\\n    );\\n    setAddress(\\n      keccak256(abi.encode(_record.daoAddress, 'tokenModelAddress')),\\n      _record.tokenModelAddress\\n    );\\n\\n    setBool(keccak256(abi.encode(_record.daoAddress, 'exists')), true);\\n\\n    emit Serialized(_record.daoAddress);\\n  }\\n\\n  function _exists(address _daoAddress) internal view returns (bool recordExists) {\\n    return getBool(keccak256(abi.encode(_daoAddress, 'exists')));\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () internal {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/models/EternalModel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPLv3\\npragma solidity 0.7.2;\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @title Implementation of Eternal Storage for ElasticDAO -\\n * - (https://fravoll.github.io/solidity-patterns/eternal_storage.html)\\n * @author ElasticDAO - https://ElasticDAO.org\\n * @notice This contract is used for storing contract network data\\n * @dev ElasticDAO network contracts can read/write from this contract\\n */\\ncontract EternalModel {\\n  struct Storage {\\n    mapping(bytes32 => address) addressStorage;\\n    mapping(bytes32 => bool) boolStorage;\\n    mapping(bytes32 => bytes) bytesStorage;\\n    mapping(bytes32 => int256) intStorage;\\n    mapping(bytes32 => string) stringStorage;\\n    mapping(bytes32 => uint256) uIntStorage;\\n  }\\n\\n  Storage internal s;\\n\\n  /**\\n   * @notice Getter Functions\\n   */\\n\\n  /**\\n   * @notice Gets stored contract data in unit256 format\\n   * @param _key bytes32 location should be keccak256 and abi.encodePacked\\n   * @return uint256 _value from storage _key location\\n   */\\n  function getUint(bytes32 _key) internal view returns (uint256) {\\n    return s.uIntStorage[_key];\\n  }\\n\\n  /**\\n   * @notice Get stored contract data in string format\\n   * @param _key bytes32 location should be keccak256 and abi.encodePacked\\n   * @return string _value from storage _key location\\n   */\\n  function getString(bytes32 _key) internal view returns (string memory) {\\n    return s.stringStorage[_key];\\n  }\\n\\n  /**\\n   * @notice Get stored contract data in address format\\n   * @param _key bytes32 location should be keccak256 and abi.encodePacked\\n   * @return address _value from storage _key location\\n   */\\n  function getAddress(bytes32 _key) internal view returns (address) {\\n    return s.addressStorage[_key];\\n  }\\n\\n  /**\\n   * @notice Get stored contract data in bool format\\n   * @param _key bytes32 location should be keccak256 and abi.encodePacked\\n   * @return bool _value from storage _key location\\n   */\\n  function getBool(bytes32 _key) internal view returns (bool) {\\n    return s.boolStorage[_key];\\n  }\\n\\n  /**\\n   * @notice Setters Functions\\n   */\\n\\n  /**\\n   * @notice Store contract data in uint256 format\\n   * @dev restricted to latest ElasticDAO Networks contracts\\n   * @param _key bytes32 location should be keccak256 and abi.encodePacked\\n   * @param _value uint256 value\\n   */\\n  function setUint(bytes32 _key, uint256 _value) internal {\\n    s.uIntStorage[_key] = _value;\\n  }\\n\\n  /**\\n   * @notice Store contract data in string format\\n   * @dev restricted to latest ElasticDAO Networks contracts\\n   * @param _key bytes32 location should be keccak256 and abi.encodePacked\\n   * @param _value string value\\n   */\\n  function setString(bytes32 _key, string memory _value) internal {\\n    s.stringStorage[_key] = _value;\\n  }\\n\\n  /**\\n   * @notice Store contract data in address format\\n   * @dev restricted to latest ElasticDAO Networks contracts\\n   * @param _key bytes32 location should be keccak256 and abi.encodePacked\\n   * @param _value address value\\n   */\\n  function setAddress(bytes32 _key, address _value) internal {\\n    s.addressStorage[_key] = _value;\\n  }\\n\\n  /**\\n   * @notice Store contract data in bool format\\n   * @dev restricted to latest ElasticDAO Networks contracts\\n   * @param _key bytes32 location should be keccak256 and abi.encodePacked\\n   * @param _value bool value\\n   */\\n  function setBool(bytes32 _key, bool _value) internal {\\n    s.boolStorage[_key] = _value;\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_daoAddress\",\"type\":\"address\"}],\"name\":\"Serialized\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_daoAddress\",\"type\":\"address\"}],\"name\":\"deserialize\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"daoAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"daoModelAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ecosystemModelAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenHolderModelAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenModelAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"governanceTokenAddress\",\"type\":\"address\"}],\"internalType\":\"struct Ecosystem.Instance\",\"name\":\"record\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_daoAddress\",\"type\":\"address\"}],\"name\":\"exists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"recordExists\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"daoAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"daoModelAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ecosystemModelAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenHolderModelAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenModelAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"governanceTokenAddress\",\"type\":\"address\"}],\"internalType\":\"struct Ecosystem.Instance\",\"name\":\"_record\",\"type\":\"tuple\"}],\"name\":\"serialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Ecosystem","CompilerVersion":"v0.7.2+commit.51b20bc0","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}