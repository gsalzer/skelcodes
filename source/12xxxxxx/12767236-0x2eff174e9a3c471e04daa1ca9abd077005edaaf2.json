{"status":"1","message":"OK","result":[{"SourceCode":"// Verified using https://dapp.tools\n\n// hevm: flattened sources of src/fabs/mgr.sol\n\npragma solidity =0.5.12;\n\n////// src/mgr.sol\n/// tinlake_manager.sol -- Tinlake dss adapter\n\n// 2020 Lucas Vogelsang <lucas@centrifuge.io>,\n// 2020 Martin Lundfall <martin.lundfall@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n/* pragma solidity =0.5.12; */\n\ninterface GemLike_3 {\n    function decimals() external view returns (uint256);\n    function transfer(address,uint256) external returns (bool);\n    function transferFrom(address,address,uint256) external returns (bool);\n    function approve(address,uint256) external returns (bool);\n    function totalSupply() external returns (uint256);\n    function balanceOf(address) external returns (uint256);\n}\n\ninterface JoinLike {\n    function join(address,uint256) external;\n    function exit(address,uint256) external;\n}\n\ninterface EndLike {\n    function debt() external returns (uint256);\n}\n\ninterface RedeemLike {\n    function redeemOrder(uint256) external;\n    function disburse(uint256) external returns (uint256,uint256,uint256,uint256);\n}\n\ninterface VatLike_5 {\n    function urns(bytes32,address) external returns (uint256,uint256);\n    function ilks(bytes32) external returns (uint256,uint256,uint256,uint256,uint256);\n    function live() external returns(uint);\n}\n\ninterface GemJoinLike {\n    function gem() external returns (address);\n    function ilk() external returns (bytes32);\n}\n\ninterface MIP21UrnLike {\n    function lock(uint256 wad) external;\n    function free(uint256 wad) external;\n    // n.b. DAI can only go to the output conduit\n    function draw(uint256 wad) external;\n    // n.b. anyone can wipe\n    function wipe(uint256 wad) external;\n    function quit() external;\n    function gemJoin() external returns (address);\n}\n\ninterface MIP21LiquidationLike {\n    function ilks(bytes32 ilk) external returns (string memory, address, uint48, uint48);\n}\n\ncontract TinlakeManager {\n    // --- Auth ---\n    mapping (address => uint256) public wards;\n\n    function rely(address usr) external auth {\n        wards[usr] = 1;\n        emit Rely(usr);\n    }\n    function deny(address usr) external auth {\n        wards[usr] = 0;\n        emit Deny(usr);\n    }\n    modifier auth {\n        require(wards[msg.sender] == 1, \"TinlakeMgr/not-authorized\");\n        _;\n    }\n\n    // Events\n    event Rely(address indexed usr);\n    event Deny(address indexed usr);\n    event Draw(uint256 wad);\n    event Wipe(uint256 wad);\n    event Join(uint256 wad);\n    event Exit(uint256 wad);\n    event Tell(uint256 wad);\n    event Unwind(uint256 payBack);\n    event Cull(uint256 tab);\n    event Recover(uint256 recovered, uint256 payBack);\n    event Cage();\n    event File(bytes32 indexed what, address indexed data);\n    event Migrate(address indexed dst);\n\n    bool public safe; // Soft liquidation not triggered\n    bool public glad; // Write-off not triggered\n    bool public live; // Global settlement not triggered\n\n    uint256 public tab;  // Dai owed\n\n    // --- Contracts ---\n    // dss components\n    VatLike_5 public vat;\n    GemLike_3 public dai;\n    EndLike public end;\n    address public vow;\n    JoinLike public daiJoin;\n\n    // Tinlake components\n    GemLike_3      public gem;\n    RedeemLike   public pool;\n\n    // MIP21 RWAUrn\n    MIP21UrnLike public urn;\n    MIP21LiquidationLike public liq;\n\n    address public tranche;\n    address public owner;\n\n    constructor(address dai_,   address daiJoin_,\n                address drop_,  address pool_,\n                address tranche_, address end_,\n                address vat_, address vow_\n                ) public {\n        dai = GemLike_3(dai_);\n        daiJoin = JoinLike(daiJoin_);\n        vat = VatLike_5(vat_);\n        vow = vow_;\n        end = EndLike(end_);\n        gem = GemLike_3(drop_);\n\n        pool = RedeemLike(pool_);\n\n        wards[msg.sender] = 1;\n        emit Rely(msg.sender);\n\n        safe = true;\n        glad = true;\n        live = true;\n\n        tranche = tranche_;\n    }\n\n    // --- Math ---\n    uint256 constant RAY = 10 ** 27;\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x);\n    }\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x);\n    }\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n    function divup(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(x, sub(y, 1)) / y;\n    }\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x > y ? y : x;\n    }\n\n\n    // --- Gem Operation ---\n    // moves the rwaToken into the vault\n    // requires that mgr contract holds the rwaToken\n    function lock(uint256 wad) public auth {\n        GemLike_3(GemJoinLike(urn.gemJoin()).gem()).approve(address(urn), uint256(wad));\n        urn.lock(wad);\n    }\n    // removes the rwaToken from the vault\n    function free(uint256 wad) public auth {\n        urn.free(wad);\n    }\n\n    // --- DROP Operation ---\n    // join & exit move the gem directly into/from the urn\n    function join(uint256 wad) public auth {\n        require(safe && live, \"TinlakeManager/bad-state\");\n        require(int256(wad) >= 0, \"TinlakeManager/overflow\");\n        gem.transferFrom(msg.sender, address(this), wad);\n        emit Join(wad);\n    }\n\n    function exit(uint256 wad) public auth {\n        require(safe && live, \"TinlakeManager/bad-state\");\n        require(wad <= 2 ** 255, \"TinlakeManager/overflow\");\n        gem.transfer(msg.sender, wad);\n        emit Exit(wad);\n    }\n\n    // --- DAI Operation ---\n    // draw & wipe call daiJoin.exit/join immediately\n    function draw(uint256 wad) public auth {\n        require(safe && live, \"TinlakeManager/bad-state\");\n        urn.draw(wad);\n        dai.transfer(msg.sender, wad);\n        emit Draw(wad);\n    }\n\n    function wipe(uint256 wad) public {\n        require(safe && live, \"TinlakeManager/bad-state\");\n        dai.transferFrom(msg.sender, address(urn), wad);\n        urn.wipe(wad);\n        emit Wipe(wad);\n    }\n\n    // Take DAI from the urn in case there is any in the Urn\n    // can be dealt with through migrate() after ES\n    function quit() public auth {\n        urn.quit();\n    }\n\n    // --- Administration ---\n    function migrate(address dst) public auth {\n        dai.approve(dst, uint256(-1));\n        gem.approve(dst, uint256(-1));\n        live = false;\n        emit Migrate(dst);\n    }\n\n    function file(bytes32 what, address data) public auth {\n        emit File(what, data);\n        if (what == \"urn\") {\n            urn = MIP21UrnLike(data);\n            dai.approve(data, uint256(-1));\n        }\n        else if (what == \"liq\") {\n            liq = MIP21LiquidationLike(data);\n        }\n        else if (what == \"owner\") {\n            owner = data;\n        }\n        else if (what == \"vow\") {\n            vow = data;\n        }\n        else if (what == \"end\") {\n            end = EndLike(data);\n        }\n        else if (what == \"pool\") {\n            pool = RedeemLike(data);\n        }\n        else if (what == \"tranche\") {\n            tranche = data;\n        }\n        else revert(\"TinlakeMgr/file-unknown-param\");\n    }\n\n    // --- Liquidation ---\n    // triggers a soft liquidation of the DROP collateral\n    // a redeemOrder is submitted to receive DAI back\n    function tell() public {\n        require(safe, \"TinlakeMgr/not-safe\");\n        bytes32 ilk = GemJoinLike(urn.gemJoin()).ilk();\n\n        (,,, uint48 toc) = liq.ilks(ilk);\n        require(toc != 0, \"TinlakeMgr/not-liquidated\");\n\n        (, uint256 art) = vat.urns(ilk, address(urn));\n        (, uint256 rate, , ,) = vat.ilks(ilk);\n        tab = mul(art, rate);\n\n        uint256 ink = gem.balanceOf(address(this));\n        safe = false;\n        gem.approve(tranche, ink);\n        pool.redeemOrder(ink);\n        emit Tell(ink);\n    }\n\n    // triggers the payout of a DROP redemption\n    // method can be called multiple times until all DROP is redeemed\n    function unwind(uint256 endEpoch) public {\n        require(!safe && glad && live, \"TinlakeMgr/not-soft-liquidation\");\n\n        (uint256 redeemed, , ,) = pool.disburse(endEpoch);\n        bytes32 ilk = GemJoinLike(urn.gemJoin()).ilk();\n\n        (, uint256 art) = vat.urns(ilk, address(urn));\n        (, uint256 rate, , ,) = vat.ilks(ilk);\n        uint256 tab_ = mul(art, rate);\n\n        uint256 payBack = min(redeemed, divup(tab_, RAY));\n        dai.transferFrom(address(this), address(urn), payBack);\n        urn.wipe(payBack);\n\n        // Return possible remainder to the owner\n        dai.transfer(owner, dai.balanceOf(address(this)));\n        tab = sub(tab_, mul(payBack, RAY));\n        emit Unwind(payBack);\n    }\n\n    // --- Write-off ---\n    // can be called after RwaLiquidationOracle.cull()\n    function cull() public {\n        require(!safe && glad && live, \"TinlakeMgr/bad-state\");\n        bytes32 ilk = GemJoinLike(urn.gemJoin()).ilk();\n\n        (uint256 ink, uint256 art) = vat.urns(ilk, address(urn));\n        require(ink == 0 && art == 0, \"TinlakeMgr/not-written-off\");\n\n        (,, uint48 tau, uint48 toc) = liq.ilks(ilk);\n        require(toc != 0, \"TinlakeMgr/not-liquidated\");\n        require(block.timestamp >= add(toc, tau), \"TinlakeMgr/early-cull\");\n\n        glad = false;\n        emit Cull(tab);\n    }\n\n    // recovers DAI from the Tinlake pool by triggering a payout\n    // method can be called multiple times until all DROP is redeemed\n    function recover(uint256 endEpoch) public {\n        require(!glad, \"TinlakeMgr/not-written-off\");\n\n        (uint256 recovered, , ,) = pool.disburse(endEpoch);\n        uint256 payBack;\n        if (end.debt() == 0) {\n            payBack = min(recovered, tab / RAY);\n            dai.approve(address(daiJoin), payBack);\n            daiJoin.join(vow, payBack);\n            tab = sub(tab, mul(payBack, RAY));\n        }\n        dai.transfer(owner, dai.balanceOf(address(this)));\n        emit Recover(recovered, payBack);\n    }\n\n    function cage() external {\n        require(!glad, \"TinlakeMgr/bad-state\");\n        require(wards[msg.sender] == 1 || vat.live() == 0, \"TinlakeMgr/not-authorized\");\n        live = false;\n        emit Cage();\n    }\n}\n\n////// src/fabs/mgr.sol\n/* pragma solidity =0.5.12; */\n\n/* import { TinlakeManager } from \"./../mgr.sol\"; */\n\ninterface TinlakeManagerFabLike {\n    function newTinlakeManager(address, address, address,  address, address, address, address, address) external returns (address);\n}\n\ncontract TinlakeManagerFab {\n    function newTinlakeManager(address dai_, address daiJoin_, address drop_,  address pool_, address tranche_, address end_, address vat_, address vow_) public returns (address) {\n        TinlakeManager mgr = new TinlakeManager(dai_, daiJoin_, drop_,  pool_, tranche_, end_, vat_, vow_);\n        mgr.rely(msg.sender);\n        mgr.deny(address(this));\n        return address(mgr);\n    }\n}\n","ABI":"[{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"dai_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"daiJoin_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"drop_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pool_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tranche_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"end_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vat_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vow_\",\"type\":\"address\"}],\"name\":\"newTinlakeManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"TinlakeManagerFab","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}