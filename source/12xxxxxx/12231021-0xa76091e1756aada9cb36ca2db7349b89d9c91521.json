{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/Elena/Source/argent-contracts/contracts/infrastructure/dapp/IFilter.sol\": {\r\n      \"content\": \"// Copyright (C) 2021  Argent Labs Ltd. <https://argent.xyz>\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.3;\\n\\ninterface IFilter {\\n    function isValid(address _wallet, address _spender, address _to, bytes calldata _data) external view returns (bool valid);\\n}\"\r\n    },\r\n    \"/Users/Elena/Source/argent-contracts/contracts/infrastructure/helper/IDappRegistry.sol\": {\r\n      \"content\": \"// Copyright (C) 2021  Argent Labs Ltd. <https://argent.xyz>\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.3;\\npragma experimental ABIEncoderV2;\\n\\ninterface IDappRegistry {\\n    function enabledRegistryIds(address _wallet) external view returns (bytes32);\\n    function authorisations(uint8 _registryId, address _dapp) external view returns (bytes32);\\n}\"\r\n    },\r\n    \"/Users/Elena/Source/argent-contracts/contracts/infrastructure/helper/MultiCallHelper.sol\": {\r\n      \"content\": \"// Copyright (C) 2021  Argent Labs Ltd. <https://argent.xyz>\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.3;\\n\\nimport \\\"../dapp/IFilter.sol\\\";\\nimport \\\"./IDappRegistry.sol\\\";\\nimport \\\"../storage/ITransferStorage.sol\\\";\\nimport \\\"../../modules/common/Utils.sol\\\";\\n\\n/**\\n * @title MultiCallHelper\\n * @notice Helper contract that can be used to check in 1 call if and why a sequence of transactions is authorised to be executed by a wallet.\\n * @author Julien Niset - <julien@argent.xyz>\\n */\\ncontract MultiCallHelper {\\n\\n    uint256 private constant MAX_UINT = type(uint256).max;\\n\\n    struct Call {\\n        address to;\\n        uint256 value;\\n        bytes data;\\n    }\\n\\n    // The trusted contacts storage\\n    ITransferStorage internal immutable userWhitelist;\\n    // The dapp registry contract\\n    IDappRegistry internal immutable dappRegistry;\\n\\n    constructor(ITransferStorage _userWhitelist, IDappRegistry _dappRegistry) {\\n        userWhitelist = _userWhitelist;\\n        dappRegistry = _dappRegistry;\\n    }\\n\\n    /**\\n     * @notice Checks if a sequence of transactions is authorised to be executed by a wallet.\\n     * The method returns false if any of the inner transaction is not to a trusted contact or an authorised dapp.\\n     * @param _wallet The target wallet.\\n     * @param _transactions The sequence of transactions.\\n     */\\n    function isMultiCallAuthorised(address _wallet, Call[] calldata _transactions) external view returns (bool) {\\n        for(uint i = 0; i < _transactions.length; i++) {\\n            address spender = Utils.recoverSpender(_transactions[i].to, _transactions[i].data);\\n            if (\\n                (spender != _transactions[i].to && _transactions[i].value != 0) ||\\n                (!isWhitelisted(_wallet, spender) && isAuthorised(_wallet, spender, _transactions[i].to, _transactions[i].data) == MAX_UINT)\\n            ) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Checks if each of the transaction of a sequence of transactions is authorised to be executed by a wallet.\\n     * For each transaction of the sequence it returns an Id where:\\n     *     - Id is in [0,255]: the transaction is to an address authorised in registry Id of the DappRegistry\\n     *     - Id = 256: the transaction is to an address authorised in the trusted contacts of the wallet\\n     *     - Id = MAX_UINT: the transaction is not authorised\\n     * @param _wallet The target wallet.\\n     * @param _transactions The sequence of transactions.\\n     */\\n    function multiCallAuthorisation(address _wallet, Call[] calldata _transactions) external view returns (uint256[] memory registryIds) {\\n        registryIds = new uint256[](_transactions.length);\\n        for(uint i = 0; i < _transactions.length; i++) {\\n            address spender = Utils.recoverSpender(_transactions[i].to, _transactions[i].data);\\n            if (spender != _transactions[i].to && _transactions[i].value != 0) {\\n                registryIds[i] = MAX_UINT;\\n            } else if (isWhitelisted(_wallet, spender)) {\\n                registryIds[i] = 256;\\n            } else {\\n                registryIds[i] = isAuthorised(_wallet, spender, _transactions[i].to, _transactions[i].data);\\n            }\\n        }\\n    }\\n\\n    function isAuthorised(address _wallet, address _spender, address _to, bytes calldata _data) internal view returns (uint256) {\\n        uint registries = uint(dappRegistry.enabledRegistryIds(_wallet));\\n        // Check Argent Default Registry first. It is enabled by default, implying that a zero \\n        // at position 0 of the `registries` bit vector means that the Argent Registry is enabled)\\n        for(uint registryId = 0; registryId == 0 || (registries >> registryId) > 0; registryId++) {\\n            bool isEnabled = (((registries >> registryId) & 1) > 0) /* \\\"is bit set for regId?\\\" */ == (registryId > 0) /* \\\"not Argent registry?\\\" */;\\n            if(isEnabled) { // if registryId is enabled\\n                uint auth = uint(dappRegistry.authorisations(uint8(registryId), _spender)); \\n                uint validAfter = auth & 0xffffffffffffffff;\\n                if (0 < validAfter && validAfter <= block.timestamp) { // if the current time is greater than the validity time\\n                    address filter = address(uint160(auth >> 64));\\n                    if(filter == address(0) || IFilter(filter).isValid(_wallet, _spender, _to, _data)) {\\n                        return registryId;\\n                    }\\n                }\\n            }\\n        }\\n        return MAX_UINT;\\n    }\\n\\n    function isAuthorisedInRegistry(address _wallet, Call[] calldata _transactions, uint8 _registryId) external view returns (bool) {\\n        for(uint i = 0; i < _transactions.length; i++) {\\n            address spender = Utils.recoverSpender(_transactions[i].to, _transactions[i].data);\\n\\n            uint auth = uint(dappRegistry.authorisations(_registryId, spender)); \\n            uint validAfter = auth & 0xffffffffffffffff;\\n            if (0 < validAfter && validAfter <= block.timestamp) { // if the current time is greater than the validity time\\n                address filter = address(uint160(auth >> 64));\\n                if(filter != address(0) && !IFilter(filter).isValid(_wallet, spender, _transactions[i].to, _transactions[i].data)) {\\n                    return false;\\n                }\\n            } else {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    function isWhitelisted(address _wallet, address _target) internal view returns (bool _isWhitelisted) {\\n        uint whitelistAfter = userWhitelist.getWhitelist(_wallet, _target);\\n        return whitelistAfter > 0 && whitelistAfter < block.timestamp;\\n    }\\n}\"\r\n    },\r\n    \"/Users/Elena/Source/argent-contracts/contracts/infrastructure/storage/ITransferStorage.sol\": {\r\n      \"content\": \"// Copyright (C) 2020  Argent Labs Ltd. <https://argent.xyz>\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity >=0.5.4 <0.9.0;\\n\\n/**\\n * @title ITransferStorage\\n * @notice TransferStorage interface\\n */\\ninterface ITransferStorage {\\n    function setWhitelist(address _wallet, address _target, uint256 _value) external;\\n\\n    function getWhitelist(address _wallet, address _target) external view returns (uint256);\\n}\"\r\n    },\r\n    \"/Users/Elena/Source/argent-contracts/contracts/modules/common/Utils.sol\": {\r\n      \"content\": \"// Copyright (C) 2020  Argent Labs Ltd. <https://argent.xyz>\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.3;\\n\\n/**\\n * @title Utils\\n * @notice Common utility methods used by modules.\\n */\\nlibrary Utils {\\n\\n    // ERC20, ERC721 & ERC1155 transfers & approvals\\n    bytes4 private constant ERC20_TRANSFER = bytes4(keccak256(\\\"transfer(address,uint256)\\\"));\\n    bytes4 private constant ERC20_APPROVE = bytes4(keccak256(\\\"approve(address,uint256)\\\"));\\n    bytes4 private constant ERC721_SET_APPROVAL_FOR_ALL = bytes4(keccak256(\\\"setApprovalForAll(address,bool)\\\"));\\n    bytes4 private constant ERC721_TRANSFER_FROM = bytes4(keccak256(\\\"transferFrom(address,address,uint256)\\\"));\\n    bytes4 private constant ERC721_SAFE_TRANSFER_FROM = bytes4(keccak256(\\\"safeTransferFrom(address,address,uint256)\\\"));\\n    bytes4 private constant ERC721_SAFE_TRANSFER_FROM_BYTES = bytes4(keccak256(\\\"safeTransferFrom(address,address,uint256,bytes)\\\"));\\n    bytes4 private constant ERC1155_SAFE_TRANSFER_FROM = bytes4(keccak256(\\\"safeTransferFrom(address,address,uint256,uint256,bytes)\\\"));\\n\\n    bytes4 private constant OWNER_SIG = 0x8da5cb5b;\\n    /**\\n    * @notice Helper method to recover the signer at a given position from a list of concatenated signatures.\\n    * @param _signedHash The signed hash\\n    * @param _signatures The concatenated signatures.\\n    * @param _index The index of the signature to recover.\\n    */\\n    function recoverSigner(bytes32 _signedHash, bytes memory _signatures, uint _index) internal pure returns (address) {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n        // we jump 32 (0x20) as the first slot of bytes contains the length\\n        // we jump 65 (0x41) per signature\\n        // for v we load 32 bytes ending with v (the first 31 come from s) then apply a mask\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            r := mload(add(_signatures, add(0x20,mul(0x41,_index))))\\n            s := mload(add(_signatures, add(0x40,mul(0x41,_index))))\\n            v := and(mload(add(_signatures, add(0x41,mul(0x41,_index)))), 0xff)\\n        }\\n        require(v == 27 || v == 28, \\\"Utils: bad v value in signature\\\");\\n\\n        address recoveredAddress = ecrecover(_signedHash, v, r, s);\\n        require(recoveredAddress != address(0), \\\"Utils: ecrecover returned 0\\\");\\n        return recoveredAddress;\\n    }\\n\\n    /**\\n    * @notice Helper method to recover the spender from a contract call. \\n    * The method returns the contract unless the call is to a standard method of a ERC20/ERC721/ERC1155 token\\n    * in which case the spender is recovered from the data.\\n    * @param _to The target contract.\\n    * @param _data The data payload.\\n    */\\n    function recoverSpender(address _to, bytes memory _data) internal pure returns (address spender) {\\n        if(_data.length >= 68) {\\n            bytes4 methodId;\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                methodId := mload(add(_data, 0x20))\\n            }\\n            if(\\n                methodId == ERC20_TRANSFER ||\\n                methodId == ERC20_APPROVE ||\\n                methodId == ERC721_SET_APPROVAL_FOR_ALL) \\n            {\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    spender := mload(add(_data, 0x24))\\n                }\\n                return spender;\\n            }\\n            if(\\n                methodId == ERC721_TRANSFER_FROM ||\\n                methodId == ERC721_SAFE_TRANSFER_FROM ||\\n                methodId == ERC721_SAFE_TRANSFER_FROM_BYTES ||\\n                methodId == ERC1155_SAFE_TRANSFER_FROM)\\n            {\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    spender := mload(add(_data, 0x44))\\n                }\\n                return spender;\\n            }\\n        }\\n\\n        spender = _to;\\n    }\\n\\n    /**\\n    * @notice Helper method to parse data and extract the method signature.\\n    */\\n    function functionPrefix(bytes memory _data) internal pure returns (bytes4 prefix) {\\n        require(_data.length >= 4, \\\"Utils: Invalid functionPrefix\\\");\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            prefix := mload(add(_data, 0x20))\\n        }\\n    }\\n\\n    /**\\n    * @notice Checks if an address is a contract.\\n    * @param _addr The address.\\n    */\\n    function isContract(address _addr) internal view returns (bool) {\\n        uint32 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            size := extcodesize(_addr)\\n        }\\n        return (size > 0);\\n    }\\n\\n    /**\\n    * @notice Checks if an address is a guardian or an account authorised to sign on behalf of a smart-contract guardian\\n    * given a list of guardians.\\n    * @param _guardians the list of guardians\\n    * @param _guardian the address to test\\n    * @return true and the list of guardians minus the found guardian upon success, false and the original list of guardians if not found.\\n    */\\n    function isGuardianOrGuardianSigner(address[] memory _guardians, address _guardian) internal view returns (bool, address[] memory) {\\n        if (_guardians.length == 0 || _guardian == address(0)) {\\n            return (false, _guardians);\\n        }\\n        bool isFound = false;\\n        address[] memory updatedGuardians = new address[](_guardians.length - 1);\\n        uint256 index = 0;\\n        for (uint256 i = 0; i < _guardians.length; i++) {\\n            if (!isFound) {\\n                // check if _guardian is an account guardian\\n                if (_guardian == _guardians[i]) {\\n                    isFound = true;\\n                    continue;\\n                }\\n                // check if _guardian is the owner of a smart contract guardian\\n                if (isContract(_guardians[i]) && isGuardianOwner(_guardians[i], _guardian)) {\\n                    isFound = true;\\n                    continue;\\n                }\\n            }\\n            if (index < updatedGuardians.length) {\\n                updatedGuardians[index] = _guardians[i];\\n                index++;\\n            }\\n        }\\n        return isFound ? (true, updatedGuardians) : (false, _guardians);\\n    }\\n\\n    /**\\n    * @notice Checks if an address is the owner of a guardian contract.\\n    * The method does not revert if the call to the owner() method consumes more then 25000 gas.\\n    * @param _guardian The guardian contract\\n    * @param _owner The owner to verify.\\n    */\\n    function isGuardianOwner(address _guardian, address _owner) internal view returns (bool) {\\n        address owner = address(0);\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr,OWNER_SIG)\\n            let result := staticcall(25000, _guardian, ptr, 0x20, ptr, 0x20)\\n            if eq(result, 1) {\\n                owner := mload(ptr)\\n            }\\n        }\\n        return owner == _owner;\\n    }\\n\\n    /**\\n    * @notice Returns ceil(a / b).\\n    */\\n    function ceil(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a / b;\\n        if (a % b == 0) {\\n            return c;\\n        } else {\\n            return c + 1;\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {\r\n      \"\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract ITransferStorage\",\"name\":\"_userWhitelist\",\"type\":\"address\"},{\"internalType\":\"contract IDappRegistry\",\"name\":\"_dappRegistry\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct MultiCallHelper.Call[]\",\"name\":\"_transactions\",\"type\":\"tuple[]\"},{\"internalType\":\"uint8\",\"name\":\"_registryId\",\"type\":\"uint8\"}],\"name\":\"isAuthorisedInRegistry\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct MultiCallHelper.Call[]\",\"name\":\"_transactions\",\"type\":\"tuple[]\"}],\"name\":\"isMultiCallAuthorised\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct MultiCallHelper.Call[]\",\"name\":\"_transactions\",\"type\":\"tuple[]\"}],\"name\":\"multiCallAuthorisation\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"registryIds\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"MultiCallHelper","CompilerVersion":"v0.8.3+commit.8d00100c","OptimizationUsed":"1","Runs":"999","ConstructorArguments":"000000000000000000000000577e0b01a8538e4cb36e5f202528157f65cdf08a000000000000000000000000b5ecc8ab46e2e20573c2e57c865f7c97f58c2798","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}