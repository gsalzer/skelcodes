{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ScheduleCalc.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.3;\\n\\nstruct ReleaseSchedule {\\n    uint releaseCount;\\n    uint delayUntilFirstReleaseInSeconds;\\n    uint initialReleasePortionInBips;\\n    uint periodBetweenReleasesInSeconds;\\n}\\n\\nstruct Timelock {\\n    uint scheduleId;\\n    uint commencementTimestamp;\\n    uint tokensTransferred;\\n    uint totalAmount;\\n}\\n\\nlibrary ScheduleCalc {\\n    uint constant BIPS_PRECISION = 10000;\\n\\n    function calculateUnlocked(uint commencedTimestamp, uint currentTimestamp, uint amount, ReleaseSchedule memory releaseSchedule) external pure returns (uint unlocked) {\\n        if(commencedTimestamp > currentTimestamp) {\\n            return 0;\\n        }\\n        uint secondsElapsed = currentTimestamp - commencedTimestamp;\\n\\n        // return the full amount if the total lockup period has expired\\n        // unlocked amounts in each period are truncated and round down remainders smaller than the smallest unit\\n        // unlocking the full amount unlocks any remainder amounts in the final unlock period\\n        // this is done first to reduce computation\\n        if (secondsElapsed >= releaseSchedule.delayUntilFirstReleaseInSeconds +\\n        (releaseSchedule.periodBetweenReleasesInSeconds * (releaseSchedule.releaseCount - 1))) {\\n            return amount;\\n        }\\n\\n        // unlock the initial release if the delay has elapsed\\n        if (secondsElapsed >= releaseSchedule.delayUntilFirstReleaseInSeconds) {\\n            unlocked = (amount * releaseSchedule.initialReleasePortionInBips) / BIPS_PRECISION;\\n\\n            // if at least one period after the delay has passed\\n            if (secondsElapsed - releaseSchedule.delayUntilFirstReleaseInSeconds\\n                >= releaseSchedule.periodBetweenReleasesInSeconds) {\\n\\n                // calculate the number of additional periods that have passed (not including the initial release)\\n                // this discards any remainders (ie it truncates / rounds down)\\n                uint additionalUnlockedPeriods =\\n                (secondsElapsed - releaseSchedule.delayUntilFirstReleaseInSeconds) /\\n                releaseSchedule.periodBetweenReleasesInSeconds;\\n\\n                // calculate the amount of unlocked tokens for the additionalUnlockedPeriods\\n                // multiplication is applied before division to delay truncating to the smallest unit\\n                // this distributes unlocked tokens more evenly across unlock periods\\n                // than truncated division followed by multiplication\\n                unlocked += ((amount - unlocked) * additionalUnlockedPeriods) / (releaseSchedule.releaseCount - 1);\\n            }\\n        }\\n\\n        return unlocked;\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"commencedTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"releaseCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delayUntilFirstReleaseInSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialReleasePortionInBips\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"periodBetweenReleasesInSeconds\",\"type\":\"uint256\"}],\"internalType\":\"struct ReleaseSchedule\",\"name\":\"releaseSchedule\",\"type\":\"tuple\"}],\"name\":\"calculateUnlocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"unlocked\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"ScheduleCalc","CompilerVersion":"v0.8.3+commit.8d00100c","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}