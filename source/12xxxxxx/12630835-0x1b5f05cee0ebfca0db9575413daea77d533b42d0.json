{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.4.22 <0.6.0;\r\n// GroupWalletMaster contract, based on MultiSigContracts inspired by parity MultiSignature contract, consensys and gnosis MultiSig contracts\r\n\r\ncontract AbstractGroupWalletFactory {\r\n  AbstractResolver                public  resolverContract;\r\n  AbstractETHRegistrarController  public  controllerContract;\r\n  AbstractBaseRegistrar           public  base;\r\n  AbstractENS                     public  ens;\r\n\r\n  function getOwner(bytes32 _domainHash) external view returns (address);\r\n}\r\n\r\ninterface ENS {\r\n  event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\r\n  event Transfer(bytes32 indexed node, address owner);\r\n  event NewResolver(bytes32 indexed node, address resolver);\r\n  event NewTTL(bytes32 indexed node, uint64 ttl);\r\n  event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n  function setRecord(bytes32 node, address owner, address resolver, uint64 ttl) external;\r\n  function setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external;\r\n  function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external returns(bytes32);\r\n  function setResolver(bytes32 node, address resolver) external;\r\n  function setOwner(bytes32 node, address owner) external;\r\n  function setTTL(bytes32 node, uint64 ttl) external;\r\n  function setApprovalForAll(address operator, bool approved) external;\r\n  function owner(bytes32 node) external view returns (address);\r\n  function resolver(bytes32 node) external view returns (address);\r\n  function ttl(bytes32 node) external view returns (uint64);\r\n  function recordExists(bytes32 node) external view returns (bool);\r\n  function isApprovedForAll(address ensowner, address operator) external view returns (bool);\r\n}\r\n\r\ncontract AbstractBaseRegistrar {\r\n  event NameMigrated(uint256 indexed id, address indexed owner, uint expires);\r\n  event NameRegistered(uint256 indexed id, address indexed owner, uint expires);\r\n  event NameRenewed(uint256 indexed id, uint expires);\r\n\r\n  bytes32 public baseNode;   // The namehash of the TLD this registrar owns (eg, .eth)\r\n  ENS public ens;\r\n}\r\n\r\ncontract AbstractResolver {\r\n  mapping(bytes32=>bytes) hashes;\r\n\r\n  event AddrChanged(bytes32 indexed node, address a);\r\n  event AddressChanged(bytes32 indexed node, uint coinType, bytes newAddress);\r\n  event NameChanged(bytes32 indexed node, string name);\r\n  event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\r\n  event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\r\n  event TextChanged(bytes32 indexed node, string indexed indexedKey, string key);\r\n  event ContenthashChanged(bytes32 indexed node, bytes hash);\r\n\r\n  function setABI(bytes32 node, uint256 contentType, bytes calldata data) external;\r\n  function setAddr(bytes32 node, address r_addr) external;\r\n  function setAddr(bytes32 node, uint coinType, bytes calldata a) external;\r\n  function setName(bytes32 node, string calldata _name) external;\r\n  function setText(bytes32 node, string calldata key, string calldata value) external;\r\n  function setAuthorisation(bytes32 node, address target, bool isAuthorised) external;\r\n}\r\n\r\ncontract AbstractENS {\r\n  event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\r\n  event Transfer(bytes32 indexed node, address owner);\r\n  event NewResolver(bytes32 indexed node, address resolver);\r\n  event NewTTL(bytes32 indexed node, uint64 ttl);\r\n  event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n  function setRecord(bytes32 node, address owner, address resolver, uint64 ttl) external;\r\n  function setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external;\r\n  function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external returns(bytes32);\r\n  function setResolver(bytes32 node, address resolver) external;\r\n  function setOwner(bytes32 node, address owner) external;\r\n  function setApprovalForAll(address operator, bool approved) external;\r\n  function owner(bytes32 node) public view returns (address);\r\n  function recordExists(bytes32 node) external view returns (bool);\r\n  function isApprovedForAll(address ensowner, address operator) external view returns (bool);\r\n}\r\n\r\ncontract AbstractETHRegistrarController {\r\n  mapping(bytes32=>uint) public commitments;\r\n\r\n  uint public minCommitmentAge;\r\n  uint public maxCommitmentAge;\r\n\r\n  event NameRegistered(string name, bytes32 indexed label, address indexed owner, uint cost, uint expires);\r\n  event NameRenewed(string name, bytes32 indexed label, uint cost, uint expires);\r\n  event NewPriceOracle(address indexed oracle);\r\n\r\n  function rentPrice(string memory name, uint duration) view public returns(uint);\r\n  function makeCommitmentWithConfig(string memory name, address owner, bytes32 secret, address resolver, address addr) pure public returns(bytes32);\r\n  function commit(bytes32 commitment) public;\r\n  function register(string calldata name, address owner, uint duration, bytes32 secret) external payable;\r\n  function registerWithConfig(string memory name, address owner, uint duration, bytes32 secret, address resolver, address addr) public payable;\r\n  function available(string memory name) public view returns(bool);\r\n}\r\n\r\ncontract GroupWalletMaster {\r\n    address internal masterCopy;                                                // ******* DO NOT CHANGE ORDER ******\r\n\r\n    mapping(uint256 => uint256) private  tArr;                                  // transaction records\r\n    address[]                   private  owners;                                // contract owners = members of the group\r\n\r\n    address internal GWF;                                                       // GWF - GroupWalletFactory master contract\r\n    mapping(uint256 => bytes)   private  structures;                            // saving encoded group structure for addUser()\r\n    \r\n                                                                                // ******* DO NOT CHANGE ORDER ******\r\n\r\n    event TestReturnData(address sender, bytes returnData);\r\n    event TestReturnLength(address sender, uint256 value);\r\n    event GroupWalletDeployed(address sender, uint256 members, uint256 timeStamp);\r\n    event GroupWalletMessage(bytes32 msg);\r\n    event Deposit(address from, uint256 value);\r\n    event ColorTableSaved(bytes32 domainHash);\r\n    event EtherScriptSaved(bytes32 domainHash,string key);\r\n\r\n    function getMasterCopy() external view returns (address) {\r\n      return masterCopy;\r\n    }\r\n\r\n    function getGWF() external view returns (address) {\r\n      return GWF;\r\n    }\r\n    \r\n    function getENS() internal view returns (AbstractENS) {\r\n      return AbstractENS( AbstractGroupWalletFactory(GWF).ens() );\r\n    }\r\n\r\n    function getRsv() internal view returns (AbstractResolver) {\r\n      return AbstractGroupWalletFactory(GWF).resolverContract();\r\n    }\r\n\r\n    function getTarget(uint tNb) private view returns (address) {\r\n      return address( uint160( uint256( tArr[tNb] ) & k_addressMask ) );\r\n    }\r\n\r\n    function getTValue(uint tNb) private view returns (uint64) {\r\n      return uint64( (uint256( uint256( tArr[tNb] ) & k_valueMask )>>160) & k_value2Mask);\r\n    }\r\n\r\n    function getAsset(uint tNb) private view returns (uint8) {\r\n      return uint8(  (uint256( uint256( tArr[tNb] ) & k_assetMask )>>208) & k_asset2Mask);\r\n    }\r\n\r\n    function getFlags(uint tNb) private view returns (uint64) {\r\n      return uint64( (uint256( uint256( tArr[tNb] ) & k_flagsMask )>>216) & k_flags2Mask);\r\n    }\r\n\r\n    function getType(uint tNb) private view returns (uint8) {\r\n      return uint8(  (uint256( uint256( tArr[tNb] ) & k_typeMask )>>252) & k_type2Mask);\r\n    }\r\n    \r\n    function saveFlags(uint _tId, uint64 flags) private {\r\n      tArr[_tId] = uint256( (uint256( flags )<<216) & k_flagsMask ) + uint256( tArr[_tId] & k_flags3Mask );\r\n    }\r\n    \r\n    function saveAsset(uint _tId, uint8 asset) private {\r\n      tArr[_tId] = uint256( (uint256( asset )<<208) & k_assetMask ) + uint256( tArr[_tId] & k_asset3Mask );\r\n    }\r\n    \r\n    function char(byte b) private pure returns (byte c) {\r\n        if (uint8(b) < uint8(10)) return byte(uint8(b) + 0x30);\r\n        else return byte(uint8(b) + 0x57);\r\n    }\r\n\r\n    function b_String(bytes32 _bytes32, uint len, bool isHex) private pure returns (string memory) {\r\n        uint8 off = 0;\r\n        if (isHex) off = 2;\r\n        bytes memory s = new bytes((len*2)+off);\r\n\r\n        if (isHex) {\r\n          s[0] = 0x30;\r\n          s[1] = 0x78;\r\n        }\r\n      \r\n        for (uint i = 0; i < len; i++) {\r\n            byte b = byte(uint8(uint(_bytes32) / (2 ** (8 * ((len-1) - i)))));\r\n            byte hi = byte(uint8(b) / 16);\r\n            byte lo = byte(uint8(b) - 16 * uint8(hi));\r\n            s[off+(2 * i)] = char(hi);\r\n            s[off+(2 * i) + 1] = char(lo);\r\n        }\r\n        return string(s);\r\n    }\r\n\r\n    function confirmTransaction_Q6d(uint _tId) external payable\r\n    {\r\n        require(isAddressOwner(msg.sender),\"ownerExists!!!\");\r\n        if (msg.value==0) return;\r\n        \r\n        uint256 t = tArr[_tId];\r\n\r\n        uint64 f = uint64( (uint256( uint256( t ) & k_flagsMask )>>216) & k_flags2Mask );\r\n        uint64 o = getOwnerMask(msg.sender);\r\n        require(uint64(f&o)==0,\"notConfirmed!!!\");\r\n        \r\n        require(uint8( (uint256( uint256( t ) & k_assetMask )>>208) & k_asset2Mask )<128, \"G1a notExecuted!!!\");\r\n        \r\n        f = uint64(f|o);                                                        // confirm f|o\r\n\r\n        if ( ( getFlags((msg.value-1)) & uint64(MAX_OWNER_COUNT) ) <= nbOfConfirmations( uint64(f/32) ) ) callExecution(_tId,t,f);\r\n        else tArr[_tId] = uint256( ((uint256(f)<<216) & k_flagsMask) + uint256( t & k_flags3Mask ) );\r\n    }\r\n    \r\n    function confirmAndExecute_68(uint _tId) external payable\r\n    {\r\n        require(isAddressOwner(msg.sender),\"ownerExists!!!\");\r\n        if (msg.value==0) return;\r\n        \r\n        uint256 t = tArr[_tId];\r\n\r\n        uint64 f = uint64( (uint256( uint256( t ) & k_flagsMask )>>216) & k_flags2Mask );\r\n        uint64 o = getOwnerMask(msg.sender);\r\n        require(uint64(f&o)==0,\"notConfirmed!!!\");\r\n\r\n        require(uint8( (uint256( uint256( t ) & k_assetMask )>>208) & k_asset2Mask )<128, \"68 notExecuted!!!\");\r\n\r\n        f  = uint64(f|o);                                                       // confirm f|o\r\n        \r\n        if ( ( getFlags((msg.value-1)) & uint64(MAX_OWNER_COUNT) ) <= nbOfConfirmations( uint64(f/32) ) ) callExecution(_tId,t,f);\r\n    }\r\n\r\n    function submitFirstTransaction_gm(uint firstTRecord, uint256 dhash) external payable\r\n    { \r\n      require(isAddressOwner(msg.sender),\"ownerExists!!!\");\r\n      require(tArr[0] == 0,\"tArr in use error!!!\");\r\n      \r\n      tArr[0]            = uint256( (uint256( uint64( uint64(owners.length>>1)+1 ) | getOwnerMask(msg.sender) )<<216) & k_flagsMask ) + uint256( uint256(firstTRecord) & k_flags3Mask );\r\n      \r\n      tArr[uint256(GWF)] = dhash;                                               // project domain hash\r\n      \r\n      emit GroupWalletDeployed(msg.sender,owners.length,uint256(now));\r\n    }\r\n\r\n    function submitTransaction_Hom(uint aTRecord) external payable\r\n    {\r\n      require(isAddressOwner(msg.sender),\"ownerExists!!!\");                     // submit and execute, if required == 1 *********************** missing *********\r\n      if (msg.value==0) return;\r\n      require(tArr[msg.value] == 0,\"tArr overwrite error!!!\");\r\n      \r\n      tArr[msg.value] = uint256( (uint256( uint64( getTRequired(msg.value-1) ) | getOwnerMask(msg.sender) )<<216) & k_flagsMask ) + uint256( uint256(aTRecord) & k_flags3Mask );\r\n    }\r\n    \r\n    function mb32(bytes memory _data) private pure returns(bytes32 a) {\r\n      assembly {\r\n          a := mload(add(_data, 32))\r\n      }\r\n    }\r\n    \r\n    function memcpy(uint dest, uint src, uint len) private pure {\r\n        // Copy word-length chunks while possible\r\n        for (; len >= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n        \r\n        if (len==0) return;\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n\r\n    function substring(bytes memory self, uint offset, uint len) internal pure returns(bytes memory) {\r\n        require(offset + len <= self.length,\"substring!!!\");\r\n\r\n        bytes memory ret = new bytes(len);\r\n        uint dest;\r\n        uint src;\r\n\r\n        assembly {\r\n            dest := add(ret, 32)\r\n            src  := add(add(self, 32), offset)\r\n        }\r\n        memcpy(dest, src, len);\r\n\r\n        return ret;\r\n    }\r\n\r\n    function getMemberWelcome(address target) external view returns (bytes memory) { // ****** perhaps, check if msg.sender is target address **********\r\n      return abi.encode( tArr[uint256(target)+2], tArr[uint256(target)+3] );\r\n    }\r\n    \r\n    function saveAsset(bytes32 dhash, uint256 asset, string calldata key, string calldata data) external payable\r\n    {\r\n      uint256 pHash = tArr[uint256(GWF)];\r\n      \r\n      require(dhash != 0x0,                                        \" - Domain hash missing!\");\r\n      require(getENS().recordExists(dhash),                        \" - Domain does NOT exist!\");\r\n      require(getENS().owner(dhash)==address(this),                \" - Only domain owner can save colors!\");\r\n      \r\n      if (pHash>0) {\r\n        require(getENS().owner( bytes32(pHash) ) == address(this), \" - GWP contract is NOT domain owner!\");\r\n        require(bytes32(pHash)==dhash,                             \" - Domain hash unexpected!\");\r\n      }\r\n\r\n      getRsv().setText(dhash,key,data);\r\n      \r\n      if (asset==1) emit ColorTableSaved (dhash);\r\n      if (asset==2) emit EtherScriptSaved(dhash,key);\r\n    }\r\n    \r\n\r\n    function submitTransaction_addUser(uint256 aTRecord, uint256 dhash, uint256 labelHash, uint256 memK1, uint256 memK2, bytes calldata data) external payable\r\n    {\r\n      require(isAddressOwner(msg.sender),\"ownerExists!!!\");                     // submit and execute, if required == 1 *********************** missing *********\r\n      require(msg.value>0 || (msg.value==0 && dhash>0x0),\"bad msg.value!!!\");\r\n      require(tArr[msg.value] == 0,\"tArr overwrite error!!!\");\r\n      require((aTRecord & k_typeMask)>>252 == 2,\"action == addUser!!!\");\r\n  \r\n      uint256 targetId = uint256(aTRecord&k_addressMask);\r\n      \r\n      tArr[targetId+1] = labelHash;\r\n      \r\n      tArr[targetId+2] = memK1;\r\n      tArr[targetId+3] = memK2;\r\n      \r\n      structures[targetId] = data;                                              // save structure with new member\r\n      \r\n      if (dhash>0x0) {                                                          // is first transaction = 0\r\n        tArr[0]            = uint256( (uint256( uint64( uint64(owners.length>>1)+1 ) | getOwnerMask(msg.sender) )<<216) & k_flagsMask ) + uint256( uint256(aTRecord) & k_flags3Mask );\r\n        tArr[uint256(GWF)] = dhash;                                             // project domain hash\r\n        emit GroupWalletDeployed(msg.sender,owners.length,uint256(now));\r\n      } else\r\n      {\r\n        tArr[msg.value]    = uint256( (uint256( uint64( getTRequired(msg.value-1) ) | getOwnerMask(msg.sender) )<<216) & k_flagsMask ) + uint256( uint256(aTRecord) & k_flags3Mask );\r\n      }\r\n      \r\n      require(getENS().owner( bytes32(tArr[uint256(GWF)]) ) == address(this), \" - GWP contract is NOT domain owner!\");\r\n    }\r\n  \r\n    function executeTransaction_G1A(uint _tId) external payable\r\n    {\r\n      require(isAddressOwner(msg.sender),\"ownerExists!!!\");\r\n      if (msg.value==0) return;\r\n      \r\n      uint256 t = tArr[_tId];\r\n\r\n      uint64 f = uint64( (uint256( uint256( t ) & k_flagsMask )>>216) & k_flags2Mask );\r\n      uint64 o = getOwnerMask(msg.sender);\r\n      require(uint64(f&o)>0,\"confirmed!!!\");\r\n      \r\n      require(uint8( (uint256( uint256( t ) & k_assetMask )>>208) & k_asset2Mask )<128, \"G1a notExecuted!!!\");\r\n\r\n      f = uint64( uint64( (uint256( uint256( t ) & k_flagsMask )>>216) & k_flags2Mask) );\r\n\r\n      if ( ( getFlags((msg.value-1)) & uint64(MAX_OWNER_COUNT) ) <= nbOfConfirmations( uint64(f/32) ) ) callExecution(_tId,t,f);\r\n    }\r\n    \r\n    function callExecution(uint _tId,uint256 t,uint64 f) internal {\r\n    \r\n      uint8 typ =  uint8( (uint256( uint256( t ) & k_typeMask )>>252) & k_type2Mask );\r\n\r\n\r\n      if (typ == 5) {                                                           // changeRequirement\r\n        uint8 majority = uint8( (uint256( uint256( t ) & k_assetMask )>>208) & k_asset2Mask );\r\n        require((majority>=2) && (majority<=MAX_OWNER_COUNT),\"required 2-31!!!\");\r\n\r\n        f = (uint64(f|uint64(MAX_OWNER_COUNT)) ^ uint64(MAX_OWNER_COUNT))+uint64(majority);\r\n        tArr[_tId] = uint256( ((uint256(f)<<216) & k_flagsMask) + uint256( t & k_flags3Mask ) ) | k_executeFlag;\r\n        return;\r\n      }\r\n\r\n\r\n      address target = address(uint160( uint256( t ) & k_addressMask ));\r\n\r\n      if (typ == 1) {\r\n        (bool succ,bytes memory returnData) = target.call.value( uint64( (uint256( uint256( t ) & k_valueMask )>>160) & k_value2Mask)<<20 )(\"\"); // mul 1.048.576\r\n        \r\n        if (succ) {\r\n          tArr[_tId] = uint256( ((uint256(f)<<216) & k_flagsMask) + uint256( t & k_flags3Mask ) ) | k_executeFlag;\r\n        }\r\n        else\r\n        {\r\n          emit TestReturnLength (msg.sender, returnData.length);\r\n          emit TestReturnData   (msg.sender, returnData);\r\n          require(succ==true, string(abi.encode( returnData, returnData.length )));\r\n        }\r\n        return;\r\n      }\r\n      else\r\n      {\r\n        if (typ == 2)                                                           // addOwner\r\n        {\r\n          require(!isAddressOwner(target),\"ownerDoesNotExist!!!\");\r\n          \r\n          uint64 r = uint64(f & uint64(MAX_OWNER_COUNT));\r\n\r\n          require((owners.length+1) <= MAX_OWNER_COUNT && r <= (owners.length + 1) && r != 0 && r >= 2,\"validRequirement!!!\");\r\n\r\n          owners.push(target);\r\n        \r\n          AbstractENS l_ens       = getENS();\r\n          AbstractResolver l_rslv = getRsv();\r\n          bytes32 l_dHash         = bytes32( tArr[uint256(GWF)] );\r\n          bytes32 l_dlabelHash    = keccak256( abi.encodePacked( l_dHash, bytes32( tArr[uint256(target)+1] ) ) );\r\n\r\n          l_ens.setSubnodeRecord(l_dHash, bytes32( tArr[uint256(target)+1] ), address(this), address(l_rslv), uint64(now*1000) & uint64(0xffffffffffff0000)); // joe.ethereum.eth\r\n          l_rslv.setAddr(l_dlabelHash,target);\r\n          l_rslv.setABI (l_dHash,32,abi.encodePacked(structures[uint256(target)]));  // update group structure\r\n          l_ens.setOwner(l_dlabelHash,target);\r\n          \r\n          if (address(this).balance>welcomeBudget) {\r\n            require(address(uint160(target)).send(welcomeBudget),\"Funding new member failed.\");\r\n            emit Deposit(target, welcomeBudget);          \r\n          }\r\n          \r\n          tArr[_tId] = uint256( ((uint256(f)<<216) & k_flagsMask) + uint256( t & k_flags3Mask ) ) | k_executeFlag;\r\n          return;\r\n        }\r\n        else\r\n        {\r\n          if (typ == 3)\r\n          {\r\n            ownerChange(target, address(0x0));                                  // removeOwner\r\n            \r\n            if (uint64( f & uint64(MAX_OWNER_COUNT) ) > owners.length) {\r\n              saveFlags(_tId,(uint64(f|uint64(MAX_OWNER_COUNT)) ^ uint64(MAX_OWNER_COUNT))+uint64(owners.length));\r\n            }\r\n            \r\n            if (address(this).balance>lowBudget) {\r\n              uint val = ((address(this).balance-lowBudget) / 2) / owners.length;\r\n              require(address(uint160(target)).send(val),\"Refunding removed member failed.\");\r\n              emit Deposit(target, val);          \r\n            }\r\n            \r\n            tArr[_tId] = uint256( ((uint256(f)<<216) & k_flagsMask) + uint256( t & k_flags3Mask ) ) | k_executeFlag;\r\n            return;\r\n          }\r\n          else\r\n          {\r\n            if (typ == 4) {\r\n              require(!isAddressOwner(target),\"ownerDoesNotExist!!!\");\r\n              \r\n              ownerChange( owners[ uint8( (uint256( uint256( t ) & k_assetMask )>>208) & k_asset2Mask ) ], target);       // replaceOwner\r\n\r\n              tArr[_tId] = uint256( ((uint256(f)<<216) & k_flagsMask) + uint256( t & k_flags3Mask ) ) | k_executeFlag;\r\n              return;\r\n            }\r\n            else\r\n            {\r\n              if (typ == 6) {                                                   // transferShares / transferToken\r\n                uint value = uint64( (uint256( uint256( t ) & k_valueMask )>>160) & k_value2Mask); // nb of token/shares to be transferred\r\n                require(value>0,\"nb ether/shares = 0!!!\");\r\n                \r\n                // NOT YET ***********\r\n\r\n                tArr[_tId] = uint256( ((uint256(f)<<216) & k_flagsMask) + uint256( t & k_flags3Mask ) ) | k_executeFlag;\r\n                return;\r\n              }\r\n              else\r\n              {\r\n                require(1==2,\"unknown type!!!\");\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    function revokeConfirmation_NlP(uint _tId) external \r\n    {\r\n      require(isAddressOwner(msg.sender),\"ownerExists!!!\");\r\n\r\n      uint256 t = tArr[_tId];\r\n      uint64 f  = uint64( (uint256( uint256( t ) & k_flagsMask )>>216) & k_flags2Mask);\r\n      uint64 o  = getOwnerMask(msg.sender);\r\n\r\n      require((uint64(f&o)>0) ,\"confirmed!!!\");\r\n      require(uint8((uint256( uint256( t ) & k_assetMask )>>208) & k_asset2Mask)<128, \"revoke notExecuted!!!\");\r\n\r\n      tArr[_tId] = uint256( (uint256( uint64(f|o) ^ uint64(o) )<<216) & k_flagsMask ) + uint256( t & k_flags3Mask );\r\n    }\r\n\r\n    function getTNumberPublic() public view returns (uint count)\r\n    {\r\n      uint i = 0;\r\n      count = 0;\r\n      \r\n      if (tArr[0]==0) return count;\r\n      \r\n      do {\r\n        if (tArr[i] > 0) count += 1;\r\n        i++;\r\n      } while(tArr[i] > 0);\r\n    }\r\n\r\n    function isConfirmed(uint _tNb) public view returns (bool) {\r\n      uint64 f = getFlags(_tNb);\r\n      uint64 r = uint64(getTRequired(_tNb-1));\r\n      if (r==0) r = uint64(owners.length>>1)+1;\r\n      uint64 c = nbOfConfirmations( uint64(f/32) );\r\n      return (r <= c);\r\n    }\r\n\r\n    function getTconfirmations(uint _tNb) public view returns (uint) {\r\n      uint64 f = getFlags(_tNb);      \r\n      return nbOfConfirmations(uint64(f>>5));\r\n    }\r\n    \r\n    function getRequiredPublic(uint _tNb) external view returns (uint count)\r\n    { \r\n      return getTRequired(_tNb-1);\r\n    }\r\n    \r\n    function getIsOwner(address _owner) external view returns (bool)\r\n    {\r\n      return isAddressOwner(_owner);\r\n    }\r\n    \r\n    function getTransactionsCount() external view returns (uint)\r\n    {\r\n      return getTNumberPublic();\r\n    }\r\n    \r\n    function getTransactions(uint _tNb) external view returns (address destination, uint value, uint8 asset, bool executed, uint64 flags, uint8 typ, bool conf)\r\n    {\r\n      if (getTNumberPublic()>0)\r\n        return (getTarget(_tNb),getTValue(_tNb),getAsset(_tNb),isTExecuted(_tNb),getFlags(_tNb),getType(_tNb),isConfirmed(_tNb));\r\n    }\r\n    \r\n    function getTransactionRecord(uint _tNb) external view returns (uint256)\r\n    {\r\n      if (getTNumberPublic()>0) return tArr[_tNb];\r\n      return 0;\r\n    }\r\n\r\n    function getConfirmationCount(uint _tNb) external view returns (uint)\r\n    {\r\n      return getTconfirmations(_tNb);\r\n    }\r\n    \r\n    function getTransactionCount(bool pending, bool executed) external view returns (uint count)\r\n    {\r\n      uint i = 0;\r\n      uint t = getTNumberPublic();\r\n      \r\n      if (t==0) return 0;\r\n      \r\n      do {\r\n        if (pending && !isTExecuted(i) || executed && isTExecuted(i)) count += 1;\r\n        i++;\r\n      } while(i<t);\r\n    }\r\n\r\n    function addressConfirmations(uint _tNb,address _owner) external view returns (bool)\r\n    {\r\n      return ownerConfirmed(_tNb,_owner);\r\n    }\r\n\r\n    function getOwners() external view returns (address[] memory)\r\n    {\r\n      return owners;\r\n    }\r\n\r\n    function getConfirmations(uint _tId) external view returns (address[] memory _confirmations)\r\n    {   \r\n      uint m = owners.length;\r\n      address[] memory confirmationsTemp = new address[](m);\r\n      uint count = 0;\r\n      uint i=0;\r\n      \r\n      do\r\n      {\r\n        if (ownerConfirmed(_tId,owners[i])) confirmationsTemp[count++] = owners[i];\r\n        i++;\r\n      } while (i<m);\r\n      \r\n      _confirmations = new address[](count);\r\n      \r\n      i=0;\r\n      do\r\n      {\r\n        _confirmations[i] = confirmationsTemp[i];\r\n        i++;\r\n      } while (i<count);      \r\n    }\r\n        \r\n    function nbOfConfirmations(uint64 confirmFlags) internal view returns (uint8 nb) {\r\n      uint64 m = 1;\r\n      uint o   = owners.length;\r\n      \r\n      do\r\n      {\r\n        if (confirmFlags & m > 0) nb++;\r\n        m = m*2;\r\n      } while (o-->0);\r\n      \r\n      return nb;\r\n    }\r\n    \r\n    function isAddressOwner(address _owner) private view returns (bool) {      \r\n      uint m = owners.length;\r\n      \r\n      if (m==0) return false;\r\n      if (owners[0]  == _owner) return true;\r\n      \r\n      if (m==1) return false;\r\n      if (owners[1]  == _owner) return true;\r\n\r\n      if (m==2) return false;\r\n      if (owners[2]  == _owner) return true;\r\n\r\n      if (m==3) return false;\r\n      if (owners[3]  == _owner) return true;\r\n      \r\n      if (m==4) return false;\r\n      if (owners[4]  == _owner) return true;\r\n\r\n      if (m==5) return false;\r\n      if (owners[5]  == _owner) return true;\r\n\r\n      if (m==6) return false;\r\n      if (owners[6]  == _owner) return true;\r\n\r\n      if (m==7) return false;\r\n      if (owners[7]  == _owner) return true;\r\n\r\n      if (m==8) return false;\r\n      if (owners[8]  == _owner) return true;\r\n\r\n      if (m==9) return false;\r\n      if (owners[9]  == _owner) return true;\r\n\r\n      if (m==10) return false;\r\n      if (owners[10] == _owner) return true;\r\n\r\n      if (m==11) return false;\r\n      if (owners[11] == _owner) return true;\r\n\r\n      if (m==12) return false;\r\n      if (owners[12] == _owner) return true;\r\n\r\n      if (m==13) return false;\r\n      if (owners[13] == _owner) return true;\r\n\r\n      if (m==14) return false;\r\n      if (owners[14] == _owner) return true;\r\n\r\n      if (m==15) return false;\r\n      if (owners[15] == _owner) return true;\r\n\r\n      if (m==16) return false;\r\n      if (owners[16] == _owner) return true;\r\n\r\n      if (m==17) return false;\r\n      if (owners[17] == _owner) return true;\r\n\r\n      if (m==18) return false;\r\n      if (owners[18] == _owner) return true;\r\n\r\n      if (m==19) return false;\r\n      if (owners[19] == _owner) return true;\r\n\r\n      if (m==20) return false;\r\n      if (owners[20] == _owner) return true;\r\n\r\n      if (m==21) return false;\r\n      if (owners[21] == _owner) return true;\r\n\r\n      if (m==22) return false;\r\n      if (owners[22] == _owner) return true;\r\n\r\n      if (m==23) return false;\r\n      if (owners[23] == _owner) return true;\r\n\r\n      if (m==24) return false;\r\n      if (owners[24] == _owner) return true;\r\n\r\n      if (m==25) return false;\r\n      if (owners[25] == _owner) return true;\r\n\r\n      if (m==26) return false;\r\n      if (owners[26] == _owner) return true;\r\n\r\n      if (m==27) return false;\r\n      if (owners[27] == _owner) return true;\r\n\r\n      if (m==28) return false;\r\n      if (owners[28] == _owner) return true;\r\n\r\n      if (m==29) return false;\r\n      if (owners[29] == _owner) return true;\r\n\r\n      if (m==30) return false;\r\n      if (owners[30] == _owner) return true;\r\n      \r\n      return false;\r\n    }\r\n    \r\n    function getOwnerMask(address _owner) private view returns (uint64 mask) {      \r\n      if (owners[0]  == _owner) return   32; \r\n      if (owners[1]  == _owner) return   64; \r\n      if (owners[2]  == _owner) return  128; \r\n      if (owners[3]  == _owner) return  256; \r\n      if (owners[4]  == _owner) return  512; \r\n      if (owners[5]  == _owner) return 1024; \r\n      if (owners[6]  == _owner) return 2048; \r\n      if (owners[7]  == _owner) return 4096; \r\n      if (owners[8]  == _owner) return 8192; \r\n      if (owners[9]  == _owner) return 16384; \r\n      \r\n      if (owners[10] == _owner) return    32768; \r\n      if (owners[11] == _owner) return    65536; \r\n      if (owners[12] == _owner) return   131072; \r\n      if (owners[13] == _owner) return   262144; \r\n      if (owners[14] == _owner) return   524288; \r\n      if (owners[15] == _owner) return  1048576; \r\n      if (owners[16] == _owner) return  2097152; \r\n      if (owners[17] == _owner) return  4194304; \r\n      if (owners[18] == _owner) return  8388608; \r\n      if (owners[19] == _owner) return 16777216; \r\n    \r\n      if (owners[20] == _owner) return    33554432; \r\n      if (owners[21] == _owner) return    67108864; \r\n      if (owners[22] == _owner) return   134217728; \r\n      if (owners[23] == _owner) return   268435456; \r\n      if (owners[24] == _owner) return   536870912; \r\n      if (owners[25] == _owner) return  1073741824; \r\n      if (owners[26] == _owner) return  2147483648; \r\n      if (owners[27] == _owner) return  4294967296; \r\n      if (owners[28] == _owner) return  8589934592; \r\n      if (owners[29] == _owner) return 17179869184; \r\n\r\n      if (owners[30] == _owner) return 34359738368; \r\n\r\n      require(1==2,\"Owner NOT found!\");\r\n    }\r\n    \r\n    function isTExecuted(uint _tNb) private view returns (bool) {\r\n      return (getAsset(_tNb)>127);\r\n    }\r\n\r\n    function ownerConfirmed(uint _tNb, address _owner) private view returns (bool) {\r\n      uint64 f = getFlags(_tNb);\r\n      uint64 o = getOwnerMask(_owner);\r\n      return (uint64(f&o)>0);\r\n    }\r\n    \r\n    function getTRequired(uint _tId) private view returns (uint64)\r\n    {\r\n      if ((_tId+1)==0) return uint64(owners.length>>1)+1;\r\n      return uint64(getFlags(_tId) & uint64(MAX_OWNER_COUNT));\r\n    }\r\n    \r\n    function ownerChange( address _owner, address _newOwner) private {\r\n      if (owners[0]  == _owner) {owners[0] = _newOwner; return;}\r\n      if (owners[1]  == _owner) {owners[1] = _newOwner; return;}\r\n      if (owners[2]  == _owner) {owners[2] = _newOwner; return;}\r\n      if (owners[3]  == _owner) {owners[3] = _newOwner; return;}\r\n      if (owners[4]  == _owner) {owners[4] = _newOwner; return;}\r\n      if (owners[5]  == _owner) {owners[5] = _newOwner; return;}\r\n      if (owners[6]  == _owner) {owners[6] = _newOwner; return;}\r\n      if (owners[7]  == _owner) {owners[7] = _newOwner; return;}\r\n      if (owners[8]  == _owner) {owners[8] = _newOwner; return;}\r\n      if (owners[9]  == _owner) {owners[9] = _newOwner; return;}\r\n\r\n      if (owners[10] == _owner) {owners[10] = _newOwner; return;}\r\n      if (owners[11] == _owner) {owners[11] = _newOwner; return;}\r\n      if (owners[12] == _owner) {owners[12] = _newOwner; return;}\r\n      if (owners[13] == _owner) {owners[13] = _newOwner; return;}\r\n      if (owners[14] == _owner) {owners[14] = _newOwner; return;}\r\n      if (owners[15] == _owner) {owners[15] = _newOwner; return;}\r\n      if (owners[16] == _owner) {owners[16] = _newOwner; return;}\r\n      if (owners[17] == _owner) {owners[17] = _newOwner; return;}\r\n      if (owners[18] == _owner) {owners[18] = _newOwner; return;}\r\n      if (owners[19] == _owner) {owners[19] = _newOwner; return;}\r\n\r\n      if (owners[20] == _owner) {owners[20] = _newOwner; return;}\r\n      if (owners[21] == _owner) {owners[21] = _newOwner; return;}\r\n      if (owners[22] == _owner) {owners[22] = _newOwner; return;}\r\n      if (owners[23] == _owner) {owners[23] = _newOwner; return;}\r\n      if (owners[24] == _owner) {owners[24] = _newOwner; return;}\r\n      if (owners[25] == _owner) {owners[25] = _newOwner; return;}\r\n      if (owners[26] == _owner) {owners[26] = _newOwner; return;}\r\n      if (owners[27] == _owner) {owners[27] = _newOwner; return;}\r\n      if (owners[28] == _owner) {owners[28] = _newOwner; return;}\r\n      if (owners[29] == _owner) {owners[29] = _newOwner; return;}\r\n      \r\n      if (owners[30] == _owner) {owners[30] = _newOwner; return;}\r\n      \r\n      require(false,\"ownerChange illegal owner!!!\");\r\n    }\r\n\r\n    function sendMessage(bytes32 msgData) external {\r\n      require(isAddressOwner(msg.sender),\"ownerExists!!!\");\r\n\r\n      if (msg.sender!=owners[ uint(uint256(msgData) & k_asset2Mask) ]) require(1==2,\"sendMessage, invalid owner!!!\");\r\n      emit GroupWalletMessage(msgData);\r\n    }\r\n    \r\n    function newProxyGroupWallet_j5O(address[] calldata _owners) external payable {\r\n      uint i;\r\n      uint l = _owners.length;\r\n      \r\n      do {\r\n        require(_owners[i] != address(0x0), \"Bad owner list!\");\r\n        owners.push(_owners[i]);\r\n        i++;\r\n      } while(i<l);\r\n      \r\n      GWF = msg.sender;\r\n    }\r\n\r\n    function() external payable\r\n    {\r\n      require(false,\"GroupWalletMaster fallback!\");\r\n    }\r\n    \r\n    constructor(address[] memory _owners) public payable\r\n    {\r\n      uint i;\r\n      do {\r\n        require(_owners[i] != address(0x0), \"Bad owner list!\");                 // only for unit tests of the master contract, owners NOT needed \r\n        owners.push(_owners[i]);\r\n        i++;\r\n      } while(i<_owners.length);\r\n      \r\n      masterCopy       = address(msg.sender);                                   // save owner of GroupWalletMaster\r\n    }\r\n    \r\n    uint constant     private MAX_OWNER_COUNT = 31;\r\n    uint constant     private welcomeBudget   = 0.006 ether;                    // new member gets ether\r\n    uint constant     private lowBudget       = 0.200 ether;                    // GWP - GroupWalletProxy contract keeps ether\r\n\r\n    uint256 constant k_addressMask  = 0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff;\r\n        \r\n    uint256 constant k_valueMask    = 0x000000000000ffffffffffff0000000000000000000000000000000000000000;\r\n    uint256 constant k_value2Mask   = 0x0000000000000000000000000000000000000000000000000000ffffffffffff;\r\n    \r\n    uint256 constant k_flagsMask    = 0x0fffffffff000000000000000000000000000000000000000000000000000000;\r\n    uint256 constant k_flags2Mask   = 0x0000000000000000000000000000000000000000000000000000000fffffffff;\r\n    uint256 constant k_flags3Mask   = 0xf000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n    \r\n    uint256 constant k_assetMask    = 0x0000000000ff0000000000000000000000000000000000000000000000000000;\r\n    uint256 constant k_asset2Mask   = 0x00000000000000000000000000000000000000000000000000000000000000ff;\r\n    uint256 constant k_asset3Mask   = 0xffffffffff00ffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n    uint256 constant k_executeFlag  = 0x0000000000800000000000000000000000000000000000000000000000000000;\r\n    \r\n    uint256 constant k_typeMask     = 0xf000000000000000000000000000000000000000000000000000000000000000;\r\n    uint256 constant k_type2Mask    = 0x000000000000000000000000000000000000000000000000000000000000000f;\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_owners\",\"type\":\"address[]\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"domainHash\",\"type\":\"bytes32\"}],\"name\":\"ColorTableSaved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"domainHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"}],\"name\":\"EtherScriptSaved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"members\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"GroupWalletDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"msg\",\"type\":\"bytes32\"}],\"name\":\"GroupWalletMessage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"name\":\"TestReturnData\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TestReturnLength\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tNb\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addressConfirmations\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tId\",\"type\":\"uint256\"}],\"name\":\"confirmAndExecute_68\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tId\",\"type\":\"uint256\"}],\"name\":\"confirmTransaction_Q6d\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tId\",\"type\":\"uint256\"}],\"name\":\"executeTransaction_G1A\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tNb\",\"type\":\"uint256\"}],\"name\":\"getConfirmationCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tId\",\"type\":\"uint256\"}],\"name\":\"getConfirmations\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"_confirmations\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGWF\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getIsOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMasterCopy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"getMemberWelcome\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tNb\",\"type\":\"uint256\"}],\"name\":\"getRequiredPublic\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTNumberPublic\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tNb\",\"type\":\"uint256\"}],\"name\":\"getTconfirmations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"pending\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"}],\"name\":\"getTransactionCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tNb\",\"type\":\"uint256\"}],\"name\":\"getTransactionRecord\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tNb\",\"type\":\"uint256\"}],\"name\":\"getTransactions\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"asset\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"},{\"internalType\":\"uint64\",\"name\":\"flags\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"typ\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"conf\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTransactionsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tNb\",\"type\":\"uint256\"}],\"name\":\"isConfirmed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_owners\",\"type\":\"address[]\"}],\"name\":\"newProxyGroupWallet_j5O\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tId\",\"type\":\"uint256\"}],\"name\":\"revokeConfirmation_NlP\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dhash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"asset\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"data\",\"type\":\"string\"}],\"name\":\"saveAsset\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"msgData\",\"type\":\"bytes32\"}],\"name\":\"sendMessage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"firstTRecord\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dhash\",\"type\":\"uint256\"}],\"name\":\"submitFirstTransaction_gm\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"aTRecord\",\"type\":\"uint256\"}],\"name\":\"submitTransaction_Hom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"aTRecord\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dhash\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"labelHash\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"memK1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"memK2\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"submitTransaction_addUser\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"GroupWalletMaster","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"800000","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000030000000000000000000000003db0ec8535aa335488a74388c2c41faca3bc1e680000000000000000000000005c31b86d2581c7c9424cd2cf477cbd537f5b90d8000000000000000000000000560c29de80e89cd45d2a6906a7c76654657a1c39","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://b5e328f2e044cddadfc707c30f14fd2c14de2d82d8028d036b16bf5611435b51"}]}