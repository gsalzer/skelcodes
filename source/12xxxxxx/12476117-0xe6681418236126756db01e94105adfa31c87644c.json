{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/alexisgauba/Desktop/Opyn/ConvexityProtocol/contracts/OptionsContract.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.10;\\n\\nimport \\\"./interfaces/OracleInterface.sol\\\";\\nimport \\\"./interfaces/UniswapFactoryInterface.sol\\\";\\nimport \\\"./interfaces/UniswapExchangeInterface.sol\\\";\\nimport \\\"./packages/ERC20.sol\\\";\\nimport \\\"./packages/IERC20.sol\\\";\\nimport \\\"./packages/ERC20Detailed.sol\\\";\\nimport \\\"./packages/Ownable.sol\\\";\\nimport \\\"./packages/SafeMath.sol\\\";\\n\\n\\n/**\\n * @title Opyn's Options Contract\\n * @author Opyn\\n */\\ncontract OptionsContract is Ownable, ERC20 {\\n    using SafeMath for uint256;\\n\\n    /* represents floting point numbers, where number = value * 10 ** exponent\\n    i.e 0.1 = 10 * 10 ** -3 */\\n    struct Number {\\n        uint256 value;\\n        int32 exponent;\\n    }\\n\\n    // Keeps track of the weighted collateral and weighted debt for each vault.\\n    struct Vault {\\n        uint256 collateral;\\n        uint256 oTokensIssued;\\n        uint256 underlying;\\n        bool owned;\\n    }\\n\\n    mapping(address => Vault) internal vaults;\\n\\n    address payable[] public vaultOwners;\\n\\n    // 10 is 0.01 i.e. 1% incentive.\\n    Number public liquidationIncentive = Number(10, -3);\\n\\n    /* 500 is 0.5. Max amount that a Vault can be liquidated by i.e.\\n    max collateral that can be taken in one function call */\\n    Number public liquidationFactor = Number(500, -3);\\n\\n    /* 16 means 1.6. The minimum ratio of a Vault's collateral to insurance promised.\\n    The ratio is calculated as below:\\n    vault.collateral / (Vault.oTokensIssued * strikePrice) */\\n    Number public minCollateralizationRatio = Number(10, -1);\\n\\n    // The amount of insurance promised per oToken\\n    Number public strikePrice;\\n\\n    // The amount of underlying that 1 oToken protects.\\n    Number public oTokenExchangeRate;\\n\\n    /* UNIX time.\\n    Exercise period starts at `(expiry - windowSize)` and ends at `expiry` */\\n    uint256 internal windowSize;\\n\\n    /* The total fees accumulated in the contract any time liquidate or exercise is called */\\n    uint256 internal totalFee;\\n\\n    // The time of expiry of the options contract\\n    uint256 public expiry;\\n\\n    // The precision of the collateral\\n    int32 public collateralExp = -18;\\n\\n    // The precision of the underlying\\n    int32 public underlyingExp = -18;\\n\\n    // The collateral asset\\n    IERC20 public collateral;\\n\\n    // The asset being protected by the insurance\\n    IERC20 public underlying;\\n\\n    // The asset in which insurance is denominated in.\\n    IERC20 public strike;\\n\\n    // The Oracle used for the contract\\n    OracleInterface public oracle;\\n\\n    // The name of  the contract\\n    string public name;\\n\\n    // The symbol of  the contract\\n    string public symbol;\\n\\n    // The number of decimals of the contract\\n    uint8 public decimals;\\n\\n    // the state of the option contract, if true then all option functionalities are paused other than removing collateral\\n    bool internal isPaused;\\n\\n    /**\\n     * @param _collateral The collateral asset\\n     * @param _underlying The asset that is being protected\\n     * @param _oTokenExchangeExp The precision of the `amount of underlying` that 1 oToken protects\\n     * @param _strikePrice The amount of strike asset that will be paid out per oToken\\n     * @param _strikeExp The precision of the strike price.\\n     * @param _strike The asset in which the insurance is calculated\\n     * @param _expiry The time at which the insurance expires\\n     * @param _windowSize UNIX time. Exercise window is from `expiry - _windowSize` to `expiry`.\\n     * @param _oracleAddress The address of the oracle\\n     */\\n    constructor(\\n        address _collateral,\\n        address _underlying,\\n        address _strike,\\n        int32 _oTokenExchangeExp,\\n        uint256 _strikePrice,\\n        int32 _strikeExp,\\n        uint256 _expiry,\\n        uint256 _windowSize,\\n        address _oracleAddress\\n    ) public {\\n        require(block.timestamp < _expiry, \\\"Can't deploy an expired contract\\\");\\n        require(\\n            _windowSize <= _expiry,\\n            \\\"Exercise window can't be longer than the contract's lifespan\\\"\\n        );\\n\\n        require(\\n            isWithinExponentRange(_strikeExp),\\n            \\\"strike price exponent not within expected range\\\"\\n        );\\n        require(\\n            isWithinExponentRange(_oTokenExchangeExp),\\n            \\\"oToken exchange rate exponent not within expected range\\\"\\n        );\\n\\n        require(\\n            address(_underlying) != address(0),\\n            \\\"OptionsContract: Can't use ETH as underlying.\\\"\\n        );\\n\\n        collateral = IERC20(_collateral);\\n        underlying = IERC20(_underlying);\\n        strike = IERC20(_strike);\\n\\n        collateralExp = getAssetExp(_collateral);\\n        underlyingExp = getAssetExp(_underlying);\\n        require(\\n            isWithinExponentRange(collateralExp),\\n            \\\"collateral exponent not within expected range\\\"\\n        );\\n        require(\\n            isWithinExponentRange(underlyingExp),\\n            \\\"underlying exponent not within expected range\\\"\\n        );\\n        require(\\n            _oTokenExchangeExp >= underlyingExp,\\n            \\\"Options Contract: The exchange rate has greater precision than the underlying\\\"\\n        );\\n\\n        oTokenExchangeRate = Number(1, _oTokenExchangeExp);\\n\\n        strikePrice = Number(_strikePrice, _strikeExp);\\n\\n        expiry = _expiry;\\n        oracle = OracleInterface(_oracleAddress);\\n        windowSize = _windowSize;\\n    }\\n\\n    /*** Events ***/\\n    event VaultOpened(address payable vaultOwner);\\n    event ETHCollateralAdded(\\n        address payable vaultOwner,\\n        uint256 amount,\\n        address payer\\n    );\\n    event ERC20CollateralAdded(\\n        address payable vaultOwner,\\n        uint256 amount,\\n        address payer\\n    );\\n    event IssuedOTokens(\\n        address issuedTo,\\n        uint256 oTokensIssued,\\n        address payable vaultOwner\\n    );\\n    event Liquidate(\\n        uint256 amtCollateralToPay,\\n        address payable vaultOwner,\\n        address payable liquidator\\n    );\\n    event Exercise(\\n        uint256 amtUnderlyingToPay,\\n        uint256 amtCollateralToPay,\\n        address payable exerciser,\\n        address payable vaultExercisedFrom\\n    );\\n    event RedeemVaultBalance(\\n        uint256 amtCollateralRedeemed,\\n        uint256 amtUnderlyingRedeemed,\\n        address payable vaultOwner\\n    );\\n    event BurnOTokens(address payable vaultOwner, uint256 oTokensBurned);\\n    event RemoveCollateral(uint256 amtRemoved, address payable vaultOwner);\\n    event UpdateParameters(\\n        uint256 liquidationIncentive,\\n        uint256 liquidationFactor,\\n        uint256 minCollateralizationRatio,\\n        address owner\\n    );\\n    event TransferFee(address payable to, uint256 fees);\\n    event RemoveUnderlying(\\n        uint256 amountUnderlying,\\n        address payable vaultOwner\\n    );\\n    event OptionStateUpdated(\\n        bool oldState,\\n        bool newState,\\n        uint256 updateTimestamp\\n    );\\n\\n    /**\\n     * @dev Throws if called Options contract is expired.\\n     */\\n    modifier notExpired() {\\n        require(!hasExpired(), \\\"Options contract expired\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice This function gets the length of vaultOwners array\\n     */\\n    function getVaultOwnersLength() external view returns (uint256) {\\n        return vaultOwners.length;\\n    }\\n\\n    /**\\n     * @notice Can only be called by owner. Used to update the fees, minCollateralizationRatio, etc\\n     * @param _liquidationIncentive The incentive paid to liquidator. 10 is 0.01 i.e. 1% incentive.\\n     * @param _liquidationFactor Max amount that a Vault can be liquidated by. 500 is 0.5.\\n     * @param _minCollateralizationRatio The minimum ratio of a Vault's collateral to insurance promised. 16 means 1.6.\\n     */\\n    function updateParameters(\\n        uint256 _liquidationIncentive,\\n        uint256 _liquidationFactor,\\n        uint256 _minCollateralizationRatio\\n    ) external onlyOwner {\\n        require(\\n            _liquidationIncentive <= 200,\\n            \\\"Can't have >20% liquidation incentive\\\"\\n        );\\n        require(\\n            _liquidationFactor <= 1000,\\n            \\\"Can't liquidate more than 100% of the vault\\\"\\n        );\\n        require(\\n            _minCollateralizationRatio >= 10,\\n            \\\"Can't have minCollateralizationRatio < 1\\\"\\n        );\\n\\n        liquidationIncentive.value = _liquidationIncentive;\\n        liquidationFactor.value = _liquidationFactor;\\n        minCollateralizationRatio.value = _minCollateralizationRatio;\\n\\n        emit UpdateParameters(\\n            _liquidationIncentive,\\n            _liquidationFactor,\\n            _minCollateralizationRatio,\\n            owner()\\n        );\\n    }\\n\\n    function harvest(address _token, uint256 _amount) external onlyOwner {\\n        require(\\n            (_token != address(underlying)) &&\\n                (_token != address(collateral)) &&\\n                (_token != address(strike)),\\n            \\\"Owner can't harvest this token\\\"\\n        );\\n\\n        ERC20(_token).transfer(msg.sender, _amount);\\n    }\\n\\n    /**\\n     * @notice Can only be called by owner. Used to set the name, symbol and decimals of the contract\\n     * @param _name The name of the contract\\n     * @param _symbol The symbol of the contract\\n     */\\n    function setDetails(string calldata _name, string calldata _symbol)\\n        external\\n        onlyOwner\\n    {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = uint8(-1 * oTokenExchangeRate.exponent);\\n    }\\n\\n    /**\\n     * @notice Can only be called by owner. Used to take out the protocol fees from the contract.\\n     * @param _address The address to send the fee to.\\n     */\\n    function transferFee(address payable _address) external onlyOwner {\\n        uint256 fees = totalFee;\\n        totalFee = 0;\\n        transferCollateral(_address, fees);\\n\\n        emit TransferFee(_address, fees);\\n    }\\n\\n    /**\\n     * @notice Can only be called by owner. Used to pause and restart the option contract.\\n     * @dev can not restart an already running option, and can not pause an already paused option\\n     * @param _isPaused The option contract state, if true then pause the contract, if false then restart contract\\n     */\\n    function setIsPaused(bool _isPaused) external onlyOwner {\\n        require(_isPaused != isPaused, \\\"Option contract already in that state\\\");\\n\\n        emit OptionStateUpdated(isPaused, _isPaused, now);\\n\\n        isPaused = _isPaused;\\n    }\\n\\n    /**\\n     * @notice Get option contract state. If option is paused should return true, else false.\\n     * @return option contract state\\n     */\\n    function isSystemPaused() public view returns (bool) {\\n        return isPaused;\\n    }\\n\\n    /**\\n     * @notice Checks if a `owner` has already created a Vault\\n     * @param _owner The address of the supposed owner\\n     * @return true or false\\n     */\\n    function hasVault(address payable _owner) public view returns (bool) {\\n        return vaults[_owner].owned;\\n    }\\n\\n    /**\\n     * @notice Creates a new empty Vault and sets the owner of the vault to be the msg.sender.\\n     */\\n    function openVault() public notExpired returns (bool) {\\n        require(!isSystemPaused(), \\\"Option contract is paused\\\");\\n        require(!hasVault(msg.sender), \\\"Vault already created\\\");\\n\\n        vaults[msg.sender] = Vault(0, 0, 0, true);\\n        vaultOwners.push(msg.sender);\\n\\n        emit VaultOpened(msg.sender);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice If the collateral type is ETH, anyone can call this function any time before\\n     * expiry to increase the amount of collateral in a Vault. Will fail if ETH is not the\\n     * collateral asset.\\n     * Remember that adding ETH collateral even if no oTokens have been created can put the owner at a\\n     * risk of losing the collateral if an exercise event happens.\\n     * Ensure that you issue and immediately sell oTokens to allow the owner to earn premiums.\\n     * (Either call the createAndSell function in the oToken contract or batch the\\n     * addERC20Collateral, issueOTokens and sell transactions and ensure they happen atomically to protect\\n     * the end user).\\n     * @param vaultOwner the index of the Vault to which collateral will be added.\\n     */\\n    function addETHCollateral(address payable vaultOwner)\\n        public\\n        payable\\n        notExpired\\n        returns (uint256)\\n    {\\n        require(!isSystemPaused(), \\\"Option contract is paused\\\");\\n        require(isETH(collateral), \\\"ETH is not the specified collateral type\\\");\\n        require(hasVault(vaultOwner), \\\"Vault does not exist\\\");\\n\\n        emit ETHCollateralAdded(vaultOwner, msg.value, msg.sender);\\n        return _addCollateral(vaultOwner, msg.value);\\n    }\\n\\n    /**\\n     * @notice If the collateral type is any ERC20, anyone can call this function any time before\\n     * expiry to increase the amount of collateral in a Vault. Can only transfer in the collateral asset.\\n     * Will fail if ETH is the collateral asset.\\n     * The user has to allow the contract to handle their ERC20 tokens on his behalf before these\\n     * functions are called.\\n     * Remember that adding ERC20 collateral even if no oTokens have been created can put the owner at a\\n     * risk of losing the collateral. Ensure that you issue and immediately sell the oTokens!\\n     * (Either call the createAndSell function in the oToken contract or batch the\\n     * addERC20Collateral, issueOTokens and sell transactions and ensure they happen atomically to protect\\n     * the end user).\\n     * @param vaultOwner the index of the Vault to which collateral will be added.\\n     * @param amt the amount of collateral to be transferred in.\\n     */\\n    function addERC20Collateral(address payable vaultOwner, uint256 amt)\\n        public\\n        notExpired\\n        returns (uint256)\\n    {\\n        require(!isSystemPaused(), \\\"Option contract is paused\\\");\\n        require(\\n            collateral.transferFrom(msg.sender, address(this), amt),\\n            \\\"OptionsContract: transfer collateral failed.\\\"\\n        );\\n        require(hasVault(vaultOwner), \\\"Vault does not exist\\\");\\n\\n        emit ERC20CollateralAdded(vaultOwner, amt, msg.sender);\\n        return _addCollateral(vaultOwner, amt);\\n    }\\n\\n    /**\\n     * @notice Returns the amount of underlying to be transferred during an exercise call\\n     */\\n    function underlyingRequiredToExercise(uint256 oTokensToExercise)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 underlyingPerOTokenExp = uint256(\\n            oTokenExchangeRate.exponent - underlyingExp\\n        );\\n\\n        // underlyingPerOTokenExp <= 60, no danger of overflowing uint256\\n        return oTokensToExercise.mul(10**underlyingPerOTokenExp);\\n    }\\n\\n    /**\\n     * @notice Returns true if exercise can be called\\n     */\\n    function isExerciseWindow() public view returns (bool) {\\n        return ((block.timestamp >= expiry.sub(windowSize)) &&\\n            (block.timestamp < expiry));\\n    }\\n\\n    /**\\n     * @notice Returns true if the oToken contract has expired\\n     */\\n    function hasExpired() public view returns (bool) {\\n        return (block.timestamp >= expiry);\\n    }\\n\\n    /**\\n     * @notice Called by anyone holding the oTokens and underlying during the\\n     * exercise window i.e. from `expiry - windowSize` time to `expiry` time. The caller\\n     * transfers in their oTokens and corresponding amount of underlying and gets\\n     * `strikePrice * oTokens` amount of collateral out. The collateral paid out is taken from\\n     * the each vault owner starting with the first and iterating until the oTokens to exercise\\n     * are found.\\n     * NOTE: This uses a for loop and hence could run out of gas if the array passed in is too big!\\n     * @param oTokensToExercise the number of oTokens being exercised.\\n     * @param vaultsToExerciseFrom the array of vaults to exercise from.\\n     */\\n    function exercise(\\n        uint256 oTokensToExercise,\\n        address payable[] memory vaultsToExerciseFrom\\n    ) public payable {\\n        require(!isSystemPaused(), \\\"Option contract is paused\\\");\\n        require(oTokensToExercise > 0, \\\"Can't exercise 0 oTokens\\\");\\n\\n        for (uint256 i = 0; i < vaultsToExerciseFrom.length; i++) {\\n            address payable vaultOwner = vaultsToExerciseFrom[i];\\n            require(\\n                hasVault(vaultOwner),\\n                \\\"Cannot exercise from a vault that doesn't exist\\\"\\n            );\\n            Vault storage vault = vaults[vaultOwner];\\n            if (oTokensToExercise == 0) {\\n                return;\\n            } else if (vault.oTokensIssued >= oTokensToExercise) {\\n                _exercise(oTokensToExercise, vaultOwner);\\n                return;\\n            } else {\\n                oTokensToExercise = oTokensToExercise.sub(vault.oTokensIssued);\\n                _exercise(vault.oTokensIssued, vaultOwner);\\n            }\\n        }\\n        require(\\n            oTokensToExercise == 0,\\n            \\\"Specified vaults have insufficient collateral\\\"\\n        );\\n    }\\n\\n    /**\\n     * @notice This function allows the vault owner to remove their share of underlying after an exercise\\n     */\\n    function removeUnderlying() external {\\n        require(hasVault(msg.sender), \\\"Vault does not exist\\\");\\n        Vault storage vault = vaults[msg.sender];\\n\\n        require(vault.underlying > 0, \\\"No underlying balance\\\");\\n\\n        uint256 underlyingToTransfer = vault.underlying;\\n        vault.underlying = 0;\\n\\n        transferUnderlying(msg.sender, underlyingToTransfer);\\n        emit RemoveUnderlying(underlyingToTransfer, msg.sender);\\n    }\\n\\n    /**\\n     * @notice This function is called to issue the option tokens. Remember that issuing oTokens even if they\\n     * haven't been sold can put the owner at a risk of not making premiums on the oTokens. Ensure that you\\n     * issue and immidiately sell the oTokens! (Either call the createAndSell function in the oToken contract\\n     * of batch the issueOTokens transaction with a sell transaction and ensure it happens atomically).\\n     * @dev The owner of a Vault should only be able to have a max of\\n     * repo.collateral * collateralToStrike / (minCollateralizationRatio * strikePrice) tokens issued.\\n     * @param oTokensToIssue The number of o tokens to issue\\n     * @param receiver The address to send the oTokens to\\n     */\\n    function issueOTokens(uint256 oTokensToIssue, address receiver)\\n        public\\n        notExpired\\n    {\\n        require(!isSystemPaused(), \\\"Option contract is paused\\\");\\n        //check that we're properly collateralized to mint this number, then call _mint(address account, uint256 amount)\\n        require(hasVault(msg.sender), \\\"Vault does not exist\\\");\\n\\n        Vault storage vault = vaults[msg.sender];\\n\\n        // checks that the vault is sufficiently collateralized\\n        uint256 newOTokensBalance = vault.oTokensIssued.add(oTokensToIssue);\\n        require(isSafe(vault.collateral, newOTokensBalance), \\\"unsafe to mint\\\");\\n\\n        // issue the oTokens\\n        vault.oTokensIssued = newOTokensBalance;\\n        _mint(receiver, oTokensToIssue);\\n\\n        emit IssuedOTokens(receiver, oTokensToIssue, msg.sender);\\n        return;\\n    }\\n\\n    /**\\n     * @notice Returns the vault for a given address\\n     * @param vaultOwner the owner of the Vault to return\\n     */\\n    function getVault(address payable vaultOwner)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            bool\\n        )\\n    {\\n        Vault storage vault = vaults[vaultOwner];\\n        return (\\n            vault.collateral,\\n            vault.oTokensIssued,\\n            vault.underlying,\\n            vault.owned\\n        );\\n    }\\n\\n    /**\\n     * @notice Returns true if the given ERC20 is ETH.\\n     * @param _ierc20 the ERC20 asset.\\n     */\\n    function isETH(IERC20 _ierc20) public pure returns (bool) {\\n        return _ierc20 == IERC20(0);\\n    }\\n\\n    /**\\n     * @notice allows the owner to burn their oTokens to increase the collateralization ratio of\\n     * their vault.\\n     * @param amtToBurn number of oTokens to burn\\n     * @dev only want to call this function before expiry. After expiry, no benefit to calling it.\\n     */\\n    function burnOTokens(uint256 amtToBurn) external notExpired {\\n        require(!isSystemPaused(), \\\"Option contract is paused\\\");\\n        require(hasVault(msg.sender), \\\"Vault does not exist\\\");\\n\\n        Vault storage vault = vaults[msg.sender];\\n\\n        vault.oTokensIssued = vault.oTokensIssued.sub(amtToBurn);\\n        _burn(msg.sender, amtToBurn);\\n\\n        emit BurnOTokens(msg.sender, amtToBurn);\\n    }\\n\\n    /**\\n     * @notice allows the owner to remove excess collateral from the vault before expiry. Removing collateral lowers\\n     * the collateralization ratio of the vault.\\n     * @param amtToRemove Amount of collateral to remove in 10^-18.\\n     */\\n    function removeCollateral(uint256 amtToRemove) external notExpired {\\n        require(amtToRemove > 0, \\\"Cannot remove 0 collateral\\\");\\n        require(hasVault(msg.sender), \\\"Vault does not exist\\\");\\n\\n        Vault storage vault = vaults[msg.sender];\\n        require(\\n            amtToRemove <= getCollateral(msg.sender),\\n            \\\"Can't remove more collateral than owned\\\"\\n        );\\n\\n        // check that vault will remain safe after removing collateral\\n        uint256 newCollateralBalance = vault.collateral.sub(amtToRemove);\\n\\n        require(\\n            isSafe(newCollateralBalance, vault.oTokensIssued),\\n            \\\"Vault is unsafe\\\"\\n        );\\n\\n        // remove the collateral\\n        vault.collateral = newCollateralBalance;\\n        transferCollateral(msg.sender, amtToRemove);\\n\\n        emit RemoveCollateral(amtToRemove, msg.sender);\\n    }\\n\\n    /**\\n     * @notice after expiry, each vault holder can get back their proportional share of collateral\\n     * from vaults that they own.\\n     * @dev The owner gets all of their collateral back if no exercise event took their collateral.\\n     */\\n    function redeemVaultBalance() external {\\n        require(hasExpired(), \\\"Can't collect collateral until expiry\\\");\\n        require(hasVault(msg.sender), \\\"Vault does not exist\\\");\\n\\n        // pay out owner their share\\n        Vault storage vault = vaults[msg.sender];\\n\\n        // To deal with lower precision\\n        uint256 collateralToTransfer = vault.collateral;\\n        uint256 underlyingToTransfer = vault.underlying;\\n\\n        vault.collateral = 0;\\n        vault.oTokensIssued = 0;\\n        vault.underlying = 0;\\n\\n        transferCollateral(msg.sender, collateralToTransfer);\\n        transferUnderlying(msg.sender, underlyingToTransfer);\\n\\n        emit RedeemVaultBalance(\\n            collateralToTransfer,\\n            underlyingToTransfer,\\n            msg.sender\\n        );\\n    }\\n\\n    /**\\n     * This function returns the maximum amount of collateral liquidatable if the given vault is unsafe\\n     * @param vaultOwner The index of the vault to be liquidated\\n     */\\n    function maxOTokensLiquidatable(address payable vaultOwner)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        if (isUnsafe(vaultOwner)) {\\n            Vault storage vault = vaults[vaultOwner];\\n            uint256 maxCollateralLiquidatable = vault\\n                .collateral\\n                .mul(liquidationFactor.value)\\n                .div(10**uint256(-liquidationFactor.exponent));\\n\\n            uint256 one = 10**uint256(-liquidationIncentive.exponent);\\n            Number memory liqIncentive = Number(\\n                liquidationIncentive.value.add(one),\\n                liquidationIncentive.exponent\\n            );\\n            return calculateOTokens(maxCollateralLiquidatable, liqIncentive);\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    /**\\n     * @notice This function can be called by anyone who notices a vault is undercollateralized.\\n     * The caller gets a reward for reducing the amount of oTokens in circulation.\\n     * @dev Liquidator comes with _oTokens. They get _oTokens * strikePrice * (incentive + fee)\\n     * amount of collateral out. They can liquidate a max of liquidationFactor * vault.collateral out\\n     * in one function call i.e. partial liquidations.\\n     * @param vaultOwner The index of the vault to be liquidated\\n     * @param oTokensToLiquidate The number of oTokens being taken out of circulation\\n     */\\n    function liquidate(address payable vaultOwner, uint256 oTokensToLiquidate)\\n        external\\n        notExpired\\n    {\\n        require(!isSystemPaused(), \\\"Option contract is paused\\\");\\n        require(hasVault(vaultOwner), \\\"Vault does not exist\\\");\\n\\n        Vault storage vault = vaults[vaultOwner];\\n\\n        // cannot liquidate a safe vault.\\n        require(isUnsafe(vaultOwner), \\\"Vault is safe\\\");\\n\\n        // Owner can't liquidate themselves\\n        require(msg.sender != vaultOwner, \\\"Owner can't liquidate themselves\\\");\\n\\n        uint256 amtCollateral = calculateCollateralToPay(\\n            oTokensToLiquidate,\\n            Number(1, 0)\\n        );\\n        uint256 amtIncentive = calculateCollateralToPay(\\n            oTokensToLiquidate,\\n            liquidationIncentive\\n        );\\n        uint256 amtCollateralToPay = amtCollateral.add(amtIncentive);\\n\\n        // calculate the maximum amount of collateral that can be liquidated\\n        uint256 maxCollateralLiquidatable = vault.collateral.mul(\\n            liquidationFactor.value\\n        );\\n\\n        if (liquidationFactor.exponent > 0) {\\n            maxCollateralLiquidatable = maxCollateralLiquidatable.mul(\\n                10**uint256(liquidationFactor.exponent)\\n            );\\n        } else {\\n            maxCollateralLiquidatable = maxCollateralLiquidatable.div(\\n                10**uint256(-1 * liquidationFactor.exponent)\\n            );\\n        }\\n\\n        require(\\n            amtCollateralToPay <= maxCollateralLiquidatable,\\n            \\\"Can only liquidate liquidation factor at any given time\\\"\\n        );\\n\\n        // deduct the collateral and oTokensIssued\\n        vault.collateral = vault.collateral.sub(amtCollateralToPay);\\n        vault.oTokensIssued = vault.oTokensIssued.sub(oTokensToLiquidate);\\n\\n        // transfer the collateral and burn the _oTokens\\n        _burn(msg.sender, oTokensToLiquidate);\\n        transferCollateral(msg.sender, amtCollateralToPay);\\n\\n        emit Liquidate(amtCollateralToPay, vaultOwner, msg.sender);\\n    }\\n\\n    /**\\n     * @notice checks if a vault is unsafe. If so, it can be liquidated\\n     * @param vaultOwner The number of the vault to check\\n     * @return true or false\\n     */\\n    function isUnsafe(address payable vaultOwner) public view returns (bool) {\\n        bool stillUnsafe = !isSafe(\\n            getCollateral(vaultOwner),\\n            getOTokensIssued(vaultOwner)\\n        );\\n        return stillUnsafe;\\n    }\\n\\n    /**\\n     * @notice This function returns if an -30 <= exponent <= 30\\n     */\\n    function isWithinExponentRange(int32 val) internal pure returns (bool) {\\n        return ((val <= 30) && (val >= -30));\\n    }\\n\\n    /**\\n     * @notice This function calculates and returns the amount of collateral in the vault\\n     */\\n    function getCollateral(address payable vaultOwner)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        Vault storage vault = vaults[vaultOwner];\\n        return vault.collateral;\\n    }\\n\\n    /**\\n     * @notice This function calculates and returns the amount of puts issued by the Vault\\n     */\\n    function getOTokensIssued(address payable vaultOwner)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        Vault storage vault = vaults[vaultOwner];\\n        return vault.oTokensIssued;\\n    }\\n\\n    /**\\n     * @notice Called by anyone holding the oTokens and underlying during the\\n     * exercise window i.e. from `expiry - windowSize` time to `expiry` time. The caller\\n     * transfers in their oTokens and corresponding amount of underlying and gets\\n     * `strikePrice * oTokens` amount of collateral out. The collateral paid out is taken from\\n     * the specified vault holder. At the end of the expiry window, the vault holder can redeem their balance\\n     * of collateral. The vault owner can withdraw their underlying at any time.\\n     * The user has to allow the contract to handle their oTokens and underlying on his behalf before these functions are called.\\n     * @param oTokensToExercise the number of oTokens being exercised.\\n     * @param vaultToExerciseFrom the address of the vaultOwner to take collateral from.\\n     * @dev oTokenExchangeRate is the number of underlying tokens that 1 oToken protects.\\n     */\\n    function _exercise(\\n        uint256 oTokensToExercise,\\n        address payable vaultToExerciseFrom\\n    ) internal {\\n        // 1. before exercise window: revert\\n        require(\\n            isExerciseWindow(),\\n            \\\"Can't exercise outside of the exercise window\\\"\\n        );\\n\\n        require(hasVault(vaultToExerciseFrom), \\\"Vault does not exist\\\");\\n\\n        Vault storage vault = vaults[vaultToExerciseFrom];\\n        require(oTokensToExercise > 0, \\\"Can't exercise 0 oTokens\\\");\\n        // Check correct amount of oTokens passed in)\\n        require(\\n            oTokensToExercise <= vault.oTokensIssued,\\n            \\\"Can't exercise more oTokens than the owner has\\\"\\n        );\\n\\n        // 1. Check sufficient underlying\\n        // 1.1 update underlying balances\\n        uint256 amtUnderlyingToPay = underlyingRequiredToExercise(\\n            oTokensToExercise\\n        );\\n        vault.underlying = vault.underlying.add(amtUnderlyingToPay);\\n\\n        // 2. Calculate Collateral to pay\\n        // 2.1 Payout enough collateral to get (strikePrice * oTokens) amount of collateral\\n        uint256 amtCollateralToPay = calculateCollateralToPay(\\n            oTokensToExercise,\\n            Number(1, 0)\\n        );\\n\\n        require(\\n            amtCollateralToPay <= vault.collateral,\\n            \\\"Vault underwater, can't exercise\\\"\\n        );\\n\\n        // 3. Update collateral + oToken balances\\n        vault.collateral = vault.collateral.sub(amtCollateralToPay);\\n        vault.oTokensIssued = vault.oTokensIssued.sub(oTokensToExercise);\\n\\n        // 4. Transfer in underlying, burn oTokens + pay out collateral\\n        // 4.1 Transfer in underlying\\n        require(\\n            underlying.transferFrom(\\n                msg.sender,\\n                address(this),\\n                amtUnderlyingToPay\\n            ),\\n            \\\"OptionsContract: Could not transfer in tokens\\\"\\n        );\\n\\n        // 4.2 burn oTokens\\n        _burn(msg.sender, oTokensToExercise);\\n\\n        // 4.3 Pay out collateral\\n        transferCollateral(msg.sender, amtCollateralToPay);\\n\\n        emit Exercise(\\n            amtUnderlyingToPay,\\n            amtCollateralToPay,\\n            msg.sender,\\n            vaultToExerciseFrom\\n        );\\n    }\\n\\n    /**\\n     * @notice adds `_amt` collateral to `vaultOwner` and returns the new balance of the vault\\n     * @param vaultOwner the index of the vault\\n     * @param amt the amount of collateral to add\\n     */\\n    function _addCollateral(address payable vaultOwner, uint256 amt)\\n        internal\\n        notExpired\\n        returns (uint256)\\n    {\\n        Vault storage vault = vaults[vaultOwner];\\n        vault.collateral = vault.collateral.add(amt);\\n\\n        return vault.collateral;\\n    }\\n\\n    /**\\n     * @notice checks if a hypothetical vault is safe with the given collateralAmt and oTokensIssued\\n     * @param collateralAmt The amount of collateral the hypothetical vault has\\n     * @param oTokensIssued The amount of oTokens generated by the hypothetical vault\\n     * @return true or false\\n     */\\n    function isSafe(uint256 collateralAmt, uint256 oTokensIssued)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        // get price from Oracle\\n        uint256 collateralToEthPrice = 1;\\n        uint256 strikeToEthPrice = 1;\\n\\n        if (collateral != strike) {\\n            collateralToEthPrice = getPrice(address(collateral));\\n            strikeToEthPrice = getPrice(address(strike));\\n        }\\n\\n        // check `oTokensIssued * minCollateralizationRatio * strikePrice <= collAmt * collateralToStrikePrice`\\n        uint256 leftSideVal = oTokensIssued\\n            .mul(minCollateralizationRatio.value)\\n            .mul(strikePrice.value);\\n        int32 leftSideExp = minCollateralizationRatio.exponent +\\n            strikePrice.exponent;\\n\\n        uint256 rightSideVal = (collateralAmt.mul(collateralToEthPrice)).div(\\n            strikeToEthPrice\\n        );\\n        int32 rightSideExp = collateralExp;\\n\\n        uint256 exp = 0;\\n        bool stillSafe = false;\\n\\n        if (rightSideExp < leftSideExp) {\\n            exp = uint256(leftSideExp - rightSideExp);\\n            stillSafe = leftSideVal.mul(10**exp) <= rightSideVal;\\n        } else {\\n            exp = uint256(rightSideExp - leftSideExp);\\n            stillSafe = leftSideVal <= rightSideVal.mul(10**exp);\\n        }\\n\\n        return stillSafe;\\n    }\\n\\n    /**\\n     * This function returns the maximum amount of oTokens that can safely be issued against the specified amount of collateral.\\n     * @param collateralAmt The amount of collateral against which oTokens will be issued.\\n     */\\n    function maxOTokensIssuable(uint256 collateralAmt)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return calculateOTokens(collateralAmt, minCollateralizationRatio);\\n    }\\n\\n    /**\\n     * @notice This function is used to calculate the amount of tokens that can be issued.\\n     * @dev The amount of oTokens is determined by:\\n     * oTokensIssued  <= collateralAmt * collateralToStrikePrice / (proportion * strikePrice)\\n     * @param collateralAmt The amount of collateral\\n     * @param proportion The proportion of the collateral to pay out. If 100% of collateral\\n     * should be paid out, pass in Number(1, 0). The proportion might be less than 100% if\\n     * you are calculating fees.\\n     */\\n    function calculateOTokens(uint256 collateralAmt, Number memory proportion)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        // get price from Oracle\\n        uint256 collateralToEthPrice = 1;\\n        uint256 strikeToEthPrice = 1;\\n\\n        if (collateral != strike) {\\n            collateralToEthPrice = getPrice(address(collateral));\\n            strikeToEthPrice = getPrice(address(strike));\\n        }\\n\\n        // oTokensIssued  <= collAmt * collateralToStrikePrice / (proportion * strikePrice)\\n        uint256 denomVal = proportion.value.mul(strikePrice.value);\\n        int32 denomExp = proportion.exponent + strikePrice.exponent;\\n\\n        uint256 numeratorVal = (collateralAmt.mul(collateralToEthPrice)).div(\\n            strikeToEthPrice\\n        );\\n        int32 numeratorExp = collateralExp;\\n\\n        uint256 exp = 0;\\n        uint256 numOptions = 0;\\n\\n        if (numeratorExp < denomExp) {\\n            exp = uint256(denomExp - numeratorExp);\\n            numOptions = numeratorVal.div(denomVal.mul(10**exp));\\n        } else {\\n            exp = uint256(numeratorExp - denomExp);\\n            numOptions = numeratorVal.mul(10**exp).div(denomVal);\\n        }\\n\\n        return numOptions;\\n    }\\n\\n    /**\\n     * @notice This function calculates the amount of collateral to be paid out.\\n     * @dev The amount of collateral to paid out is determined by:\\n     * (proportion * strikePrice * strikeToCollateralPrice * oTokens) amount of collateral.\\n     * @param _oTokens The number of oTokens.\\n     * @param proportion The proportion of the collateral to pay out. If 100% of collateral\\n     * should be paid out, pass in Number(1, 0). The proportion might be less than 100% if\\n     * you are calculating fees.\\n     */\\n    function calculateCollateralToPay(\\n        uint256 _oTokens,\\n        Number memory proportion\\n    ) internal view returns (uint256) {\\n        // Get price from oracle\\n        uint256 collateralToEthPrice = 1;\\n        uint256 strikeToEthPrice = 1;\\n\\n        if (collateral != strike) {\\n            collateralToEthPrice = getPrice(address(collateral));\\n            strikeToEthPrice = getPrice(address(strike));\\n        }\\n\\n        // calculate how much should be paid out\\n        uint256 amtCollateralToPayInEthNum = _oTokens\\n            .mul(strikePrice.value)\\n            .mul(proportion.value)\\n            .mul(strikeToEthPrice);\\n        int32 amtCollateralToPayExp = strikePrice.exponent +\\n            proportion.exponent -\\n            collateralExp;\\n        uint256 amtCollateralToPay = 0;\\n        uint256 exp;\\n        if (amtCollateralToPayExp > 0) {\\n            exp = uint256(amtCollateralToPayExp);\\n            amtCollateralToPay = amtCollateralToPayInEthNum.mul(10**exp).div(\\n                collateralToEthPrice\\n            );\\n        } else {\\n            exp = uint256(-1 * amtCollateralToPayExp);\\n            amtCollateralToPay = amtCollateralToPayInEthNum.div(10**exp).div(\\n                collateralToEthPrice\\n            );\\n        }\\n        require(exp <= 77, \\\"Options Contract: Exponentiation overflowed\\\");\\n\\n        return amtCollateralToPay;\\n    }\\n\\n    /**\\n     * @notice This function transfers `amt` collateral to `_addr`\\n     * @param _addr The address to send the collateral to\\n     * @param _amt The amount of the collateral to pay out.\\n     */\\n    function transferCollateral(address payable _addr, uint256 _amt) internal {\\n        if (isETH(collateral)) {\\n            _addr.transfer(_amt);\\n        } else {\\n            require(\\n                collateral.transfer(_addr, _amt),\\n                \\\"OptionsContract: transfer collateral failed.\\\"\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @notice This function transfers `amt` underlying to `_addr`\\n     * @param _addr The address to send the underlying to\\n     * @param _amt The amount of the underlying to pay out.\\n     */\\n    function transferUnderlying(address payable _addr, uint256 _amt) internal {\\n        require(\\n            underlying.transfer(_addr, _amt),\\n            \\\"OptionsContract: transfer underlying failed\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev internal function to parse token decimals for constructor\\n     * @param _asset the asset address\\n     */\\n    function getAssetExp(address _asset) internal view returns (int32) {\\n        if (_asset == address(0)) return -18;\\n        return -1 * int32(ERC20Detailed(_asset).decimals());\\n    }\\n\\n    /**\\n     * @notice This function gets the price ETH (wei) to asset price.\\n     * @param asset The address of the asset to get the price of\\n     */\\n    function getPrice(address asset) internal view returns (uint256) {\\n        return oracle.getPrice(asset);\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/alexisgauba/Desktop/Opyn/ConvexityProtocol/contracts/OptionsExchange.sol\": {\r\n      \"content\": \"pragma solidity 0.5.10;\\n\\nimport \\\"./interfaces/CompoundOracleInterface.sol\\\";\\nimport \\\"./interfaces/UniswapFactoryInterface.sol\\\";\\nimport \\\"./interfaces/UniswapExchangeInterface.sol\\\";\\nimport \\\"./packages/IERC20.sol\\\";\\n\\n\\ncontract OptionsExchange {\\n    using SafeMath for uint256;\\n\\n    uint256 internal constant LARGE_BLOCK_SIZE = 1651753129000;\\n    uint256 internal constant LARGE_APPROVAL_NUMBER = 10**30;\\n\\n    UniswapFactoryInterface public uniswapFactory;\\n\\n    constructor(address _uniswapFactory) public {\\n        uniswapFactory = UniswapFactoryInterface(_uniswapFactory);\\n    }\\n\\n    /*** Events ***/\\n    event SellOTokens(\\n        address seller,\\n        address payable receiver,\\n        address oTokenAddress,\\n        address payoutTokenAddress,\\n        uint256 oTokensToSell,\\n        uint256 payoutTokensReceived\\n    );\\n    event BuyOTokens(\\n        address buyer,\\n        address payable receiver,\\n        address oTokenAddress,\\n        address paymentTokenAddress,\\n        uint256 oTokensToBuy,\\n        uint256 premiumPaid\\n    );\\n\\n    /**\\n     * @notice This function sells oTokens on Uniswap and sends back payoutTokens to the receiver\\n     * @param receiver The address to send the payout tokens back to\\n     * @param oTokenAddress The address of the oToken to sell\\n     * @param payoutTokenAddress The address of the token to receive the premiums in\\n     * @param oTokensToSell The number of oTokens to sell\\n     */\\n    function sellOTokens(\\n        address payable receiver,\\n        address oTokenAddress,\\n        address payoutTokenAddress,\\n        uint256 oTokensToSell\\n    ) external {\\n        // @note: first need to bootstrap the uniswap exchange to get the address.\\n        IERC20 oToken = IERC20(oTokenAddress);\\n        IERC20 payoutToken = IERC20(payoutTokenAddress);\\n        require(\\n            oToken.transferFrom(msg.sender, address(this), oTokensToSell),\\n            \\\"OptionsExchange: pull otoken from user failed.\\\"\\n        );\\n        uint256 payoutTokensReceived = uniswapSellOToken(\\n            oToken,\\n            payoutToken,\\n            oTokensToSell,\\n            receiver\\n        );\\n\\n        emit SellOTokens(\\n            msg.sender,\\n            receiver,\\n            oTokenAddress,\\n            payoutTokenAddress,\\n            oTokensToSell,\\n            payoutTokensReceived\\n        );\\n    }\\n\\n    /**\\n     * @notice This function buys oTokens on Uniswap and using paymentTokens from the receiver\\n     * @param receiver The address to send the oTokens back to\\n     * @param oTokenAddress The address of the oToken to buy\\n     * @param paymentTokenAddress The address of the token to pay the premiums in\\n     * @param oTokensToBuy The number of oTokens to buy\\n     */\\n    function buyOTokens(\\n        address payable receiver,\\n        address oTokenAddress,\\n        address paymentTokenAddress,\\n        uint256 oTokensToBuy\\n    ) external payable {\\n        IERC20 oToken = IERC20(oTokenAddress);\\n        IERC20 paymentToken = IERC20(paymentTokenAddress);\\n        uniswapBuyOToken(paymentToken, oToken, oTokensToBuy, receiver);\\n    }\\n\\n    /**\\n     * @notice This function calculates the amount of premiums that the seller\\n     * will receive if they sold oTokens on Uniswap\\n     * @param oTokenAddress The address of the oToken to sell\\n     * @param payoutTokenAddress The address of the token to receive the premiums in\\n     * @param oTokensToSell The number of oTokens to sell\\n     */\\n    function premiumReceived(\\n        address oTokenAddress,\\n        address payoutTokenAddress,\\n        uint256 oTokensToSell\\n    ) external view returns (uint256) {\\n        // get the amount of ETH that will be paid out if oTokensToSell is sold.\\n        UniswapExchangeInterface oTokenExchange = getExchange(oTokenAddress);\\n        uint256 ethReceived = oTokenExchange.getTokenToEthInputPrice(\\n            oTokensToSell\\n        );\\n\\n        if (!isETH(IERC20(payoutTokenAddress))) {\\n            // get the amount of payout tokens that will be received if the ethRecieved is sold.\\n            UniswapExchangeInterface payoutExchange = getExchange(\\n                payoutTokenAddress\\n            );\\n            return payoutExchange.getEthToTokenInputPrice(ethReceived);\\n        }\\n        return ethReceived;\\n    }\\n\\n    /**\\n     * @notice This function calculates the premiums to be paid if a buyer wants to\\n     * buy oTokens on Uniswap\\n     * @param oTokenAddress The address of the oToken to buy\\n     * @param paymentTokenAddress The address of the token to pay the premiums in\\n     * @param oTokensToBuy The number of oTokens to buy\\n     */\\n    function premiumToPay(\\n        address oTokenAddress,\\n        address paymentTokenAddress,\\n        uint256 oTokensToBuy\\n    ) public view returns (uint256) {\\n        // get the amount of ETH that needs to be paid for oTokensToBuy.\\n        UniswapExchangeInterface oTokenExchange = getExchange(oTokenAddress);\\n        uint256 ethToPay = oTokenExchange.getEthToTokenOutputPrice(\\n            oTokensToBuy\\n        );\\n\\n        if (!isETH(IERC20(paymentTokenAddress))) {\\n            // get the amount of paymentTokens that needs to be paid to get the desired ethToPay.\\n            UniswapExchangeInterface paymentTokenExchange = getExchange(\\n                paymentTokenAddress\\n            );\\n            return paymentTokenExchange.getTokenToEthOutputPrice(ethToPay);\\n        }\\n\\n        return ethToPay;\\n    }\\n\\n    function uniswapSellOToken(\\n        IERC20 oToken,\\n        IERC20 payoutToken,\\n        uint256 _amt,\\n        address payable _transferTo\\n    ) internal returns (uint256) {\\n        require(!isETH(oToken), \\\"Can only sell oTokens\\\");\\n        UniswapExchangeInterface exchange = getExchange(address(oToken));\\n\\n        require(\\n            oToken.approve(address(exchange), _amt),\\n            \\\"OptionsExchange: approve failed\\\"\\n        );\\n\\n        if (isETH(payoutToken)) {\\n            //Token to ETH\\n            return\\n                exchange.tokenToEthTransferInput(\\n                    _amt,\\n                    1,\\n                    LARGE_BLOCK_SIZE,\\n                    _transferTo\\n                );\\n        } else {\\n            //Token to Token\\n            return\\n                exchange.tokenToTokenTransferInput(\\n                    _amt,\\n                    1,\\n                    1,\\n                    LARGE_BLOCK_SIZE,\\n                    _transferTo,\\n                    address(payoutToken)\\n                );\\n        }\\n    }\\n\\n    function uniswapBuyOToken(\\n        IERC20 paymentToken,\\n        IERC20 oToken,\\n        uint256 _amt,\\n        address payable _transferTo\\n    ) internal returns (uint256) {\\n        require(!isETH(oToken), \\\"Can only buy oTokens\\\");\\n\\n        if (!isETH(paymentToken)) {\\n            UniswapExchangeInterface exchange = getExchange(\\n                address(paymentToken)\\n            );\\n\\n            uint256 paymentTokensToTransfer = premiumToPay(\\n                address(oToken),\\n                address(paymentToken),\\n                _amt\\n            );\\n\\n            require(\\n                paymentToken.transferFrom(\\n                    msg.sender,\\n                    address(this),\\n                    paymentTokensToTransfer\\n                ),\\n                \\\"OptionsExchange: Pull token from sender failed\\\"\\n            );\\n\\n            // Token to Token\\n            require(\\n                paymentToken.approve(address(exchange), LARGE_APPROVAL_NUMBER),\\n                \\\"OptionsExchange: Approve failed\\\"\\n            );\\n\\n            emit BuyOTokens(\\n                msg.sender,\\n                _transferTo,\\n                address(oToken),\\n                address(paymentToken),\\n                _amt,\\n                paymentTokensToTransfer\\n            );\\n\\n            return\\n                exchange.tokenToTokenTransferInput(\\n                    paymentTokensToTransfer,\\n                    1,\\n                    1,\\n                    LARGE_BLOCK_SIZE,\\n                    _transferTo,\\n                    address(oToken)\\n                );\\n        } else {\\n            // ETH to Token\\n            UniswapExchangeInterface exchange = UniswapExchangeInterface(\\n                uniswapFactory.getExchange(address(oToken))\\n            );\\n\\n            uint256 ethToTransfer;\\n            uint256 amount = _amt;\\n            if (_amt > 0) {\\n                ethToTransfer = exchange.getEthToTokenOutputPrice(_amt);\\n                require(\\n                    msg.value >= ethToTransfer,\\n                    \\\"Options Exchange: Insufficient ETH\\\"\\n                );\\n                // send excess value back to user\\n                msg.sender.transfer(msg.value.sub(ethToTransfer));\\n            } else if (msg.value > 0) {\\n                ethToTransfer = msg.value;\\n                amount = exchange.getTokenToEthOutputPrice(ethToTransfer);\\n            }\\n\\n            emit BuyOTokens(\\n                msg.sender,\\n                _transferTo,\\n                address(oToken),\\n                address(paymentToken),\\n                amount,\\n                ethToTransfer\\n            );\\n\\n            return\\n                exchange.ethToTokenTransferOutput.value(ethToTransfer)(\\n                    amount,\\n                    LARGE_BLOCK_SIZE,\\n                    _transferTo\\n                );\\n        }\\n    }\\n\\n    function getExchange(address _token)\\n        internal\\n        view\\n        returns (UniswapExchangeInterface)\\n    {\\n        UniswapExchangeInterface exchange = UniswapExchangeInterface(\\n            uniswapFactory.getExchange(_token)\\n        );\\n\\n        if (address(exchange) == address(0)) {\\n            revert(\\\"No payout exchange\\\");\\n        }\\n\\n        return exchange;\\n    }\\n\\n    function isETH(IERC20 _ierc20) internal pure returns (bool) {\\n        return _ierc20 == IERC20(0);\\n    }\\n\\n    function() external payable {\\n        // to get ether from uniswap exchanges\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/alexisgauba/Desktop/Opyn/ConvexityProtocol/contracts/OptionsFactory.sol\": {\r\n      \"content\": \"pragma solidity 0.5.10;\\n\\nimport \\\"./oToken.sol\\\";\\nimport \\\"./lib/StringComparator.sol\\\";\\nimport \\\"./packages/Ownable.sol\\\";\\nimport \\\"./packages/IERC20.sol\\\";\\n\\n\\ncontract OptionsFactory is Ownable {\\n    using StringComparator for string;\\n\\n    mapping(address => bool) public whitelisted;\\n    address[] public optionsContracts;\\n\\n    // The contract which interfaces with the exchange\\n    OptionsExchange public optionsExchange;\\n    address public oracleAddress;\\n\\n    event OptionsContractCreated(address addr);\\n    event AssetWhitelisted(address indexed asset);\\n\\n    /**\\n     * @param _optionsExchangeAddr: The contract which interfaces with the exchange\\n     * @param _oracleAddress Address of the oracle\\n     */\\n    constructor(OptionsExchange _optionsExchangeAddr, address _oracleAddress)\\n        public\\n    {\\n        optionsExchange = OptionsExchange(_optionsExchangeAddr);\\n        oracleAddress = _oracleAddress;\\n    }\\n\\n    /**\\n     * @notice creates a new Option Contract\\n     * @param _collateral The collateral asset. Eg. \\\"ETH\\\"\\n     * @param _underlying The underlying asset. Eg. \\\"DAI\\\"\\n     * @param _oTokenExchangeExp Units of underlying that 1 oToken protects\\n     * @param _strikePrice The amount of strike asset that will be paid out\\n     * @param _strikeExp The precision of the strike Price\\n     * @param _strike The asset in which the insurance is calculated\\n     * @param _expiry The time at which the insurance expires\\n     * @param _windowSize UNIX time. Exercise window is from `expiry - _windowSize` to `expiry`.\\n     * @dev this condition must hold for the oToken to be safe: abs(oTokenExchangeExp - underlyingExp) < 19\\n     * @dev this condition must hold for the oToken to be safe: max(abs(strikeExp + liqIncentiveExp - collateralExp), abs(strikeExp - collateralExp)) <= 9\\n     */\\n    function createOptionsContract(\\n        address _collateral,\\n        address _underlying,\\n        address _strike,\\n        int32 _oTokenExchangeExp,\\n        uint256 _strikePrice,\\n        int32 _strikeExp,\\n        uint256 _expiry,\\n        uint256 _windowSize,\\n        string calldata _name,\\n        string calldata _symbol\\n    ) external returns (address) {\\n        require(whitelisted[_collateral], \\\"Collateral not whitelisted.\\\");\\n        require(whitelisted[_underlying], \\\"Underlying not whitelisted.\\\");\\n        require(whitelisted[_strike], \\\"Strike not whitelisted.\\\");\\n\\n        require(_expiry > block.timestamp, \\\"Cannot create an expired option\\\");\\n        require(_windowSize <= _expiry, \\\"Invalid _windowSize\\\");\\n\\n        oToken otoken = new oToken(\\n            _collateral,\\n            _underlying,\\n            _strike,\\n            _oTokenExchangeExp,\\n            _strikePrice,\\n            _strikeExp,\\n            _expiry,\\n            _windowSize,\\n            optionsExchange,\\n            oracleAddress\\n        );\\n\\n        otoken.setDetails(_name, _symbol);\\n\\n        optionsContracts.push(address(otoken));\\n        emit OptionsContractCreated(address(otoken));\\n\\n        // Set the owner for the options contract to the person who created the options contract\\n        otoken.transferOwnership(msg.sender);\\n        return address(otoken);\\n    }\\n\\n    /**\\n     * @notice The number of Option Contracts that the Factory contract has stored\\n     */\\n    function getNumberOfOptionsContracts() external view returns (uint256) {\\n        return optionsContracts.length;\\n    }\\n\\n    /**\\n     * @notice The owner of the Factory Contract can update an asset's address, by adding it, changing the address or removing the asset\\n     * @param _asset The address for the asset\\n     */\\n    function whitelistAsset(address _asset) external onlyOwner {\\n        whitelisted[_asset] = true;\\n        emit AssetWhitelisted(_asset);\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/alexisgauba/Desktop/Opyn/ConvexityProtocol/contracts/interfaces/CompoundOracleInterface.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.10;\\n// AT MAINNET ADDRESS: 0x9B8Eb8b3d6e2e0Db36F41455185FEF7049a35CaE\\nimport \\\"../packages/ERC20.sol\\\";\\n\\n\\ninterface CompoundOracleInterface {\\n    function getUnderlyingPrice(address cToken) external view returns (uint256);\\n\\n    function price(string calldata symbol) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"/Users/alexisgauba/Desktop/Opyn/ConvexityProtocol/contracts/interfaces/OracleInterface.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.10;\\n\\n\\ninterface OracleInterface {\\n    function getPrice(address asset) external view returns (uint256);\\n\\n    function getBTCPrice() external view returns (uint256);\\n\\n    function getETHPrice() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"/Users/alexisgauba/Desktop/Opyn/ConvexityProtocol/contracts/interfaces/UniswapExchangeInterface.sol\": {\r\n      \"content\": \"pragma solidity 0.5.10;\\n\\n\\n/* solhint-disable */\\n\\n// Solidity Interface\\ncontract UniswapExchangeInterface {\\n    // Address of ERC20 token sold on this exchange\\n    function tokenAddress() external view returns (address token);\\n\\n    // Address of Uniswap Factory\\n    function factoryAddress() external view returns (address factory);\\n\\n    // Provide Liquidity\\n    function addLiquidity(\\n        uint256 min_liquidity,\\n        uint256 max_tokens,\\n        uint256 deadline\\n    ) external payable returns (uint256);\\n\\n    function removeLiquidity(\\n        uint256 amount,\\n        uint256 min_eth,\\n        uint256 min_tokens,\\n        uint256 deadline\\n    ) external returns (uint256, uint256);\\n\\n    // Get Prices\\n    function getEthToTokenInputPrice(uint256 eth_sold)\\n        external\\n        view\\n        returns (uint256 tokens_bought);\\n\\n    function getEthToTokenOutputPrice(uint256 tokens_bought)\\n        external\\n        view\\n        returns (uint256 eth_sold);\\n\\n    function getTokenToEthInputPrice(uint256 tokens_sold)\\n        external\\n        view\\n        returns (uint256 eth_bought);\\n\\n    function getTokenToEthOutputPrice(uint256 eth_bought)\\n        external\\n        view\\n        returns (uint256 tokens_sold);\\n\\n    // Trade ETH to ERC20\\n    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline)\\n        external\\n        payable\\n        returns (uint256 tokens_bought);\\n\\n    function ethToTokenTransferInput(\\n        uint256 min_tokens,\\n        uint256 deadline,\\n        address recipient\\n    ) external payable returns (uint256 tokens_bought);\\n\\n    function ethToTokenSwapOutput(uint256 tokens_bought, uint256 deadline)\\n        external\\n        payable\\n        returns (uint256 eth_sold);\\n\\n    function ethToTokenTransferOutput(\\n        uint256 tokens_bought,\\n        uint256 deadline,\\n        address recipient\\n    ) external payable returns (uint256 eth_sold);\\n\\n    // Trade ERC20 to ETH\\n    function tokenToEthSwapInput(\\n        uint256 tokens_sold,\\n        uint256 min_eth,\\n        uint256 deadline\\n    ) external returns (uint256 eth_bought);\\n\\n    function tokenToEthTransferInput(\\n        uint256 tokens_sold,\\n        uint256 min_eth,\\n        uint256 deadline,\\n        address recipient\\n    ) external returns (uint256 eth_bought);\\n\\n    function tokenToEthSwapOutput(\\n        uint256 eth_bought,\\n        uint256 max_tokens,\\n        uint256 deadline\\n    ) external returns (uint256 tokens_sold);\\n\\n    function tokenToEthTransferOutput(\\n        uint256 eth_bought,\\n        uint256 max_tokens,\\n        uint256 deadline,\\n        address recipient\\n    ) external returns (uint256 tokens_sold);\\n\\n    // Trade ERC20 to ERC20\\n    function tokenToTokenSwapInput(\\n        uint256 tokens_sold,\\n        uint256 min_tokens_bought,\\n        uint256 min_eth_bought,\\n        uint256 deadline,\\n        address token_addr\\n    ) external returns (uint256 tokens_bought);\\n\\n    function tokenToTokenTransferInput(\\n        uint256 tokens_sold,\\n        uint256 min_tokens_bought,\\n        uint256 min_eth_bought,\\n        uint256 deadline,\\n        address recipient,\\n        address token_addr\\n    ) external returns (uint256 tokens_bought);\\n\\n    function tokenToTokenSwapOutput(\\n        uint256 tokens_bought,\\n        uint256 max_tokens_sold,\\n        uint256 max_eth_sold,\\n        uint256 deadline,\\n        address token_addr\\n    ) external returns (uint256 tokens_sold);\\n\\n    function tokenToTokenTransferOutput(\\n        uint256 tokens_bought,\\n        uint256 max_tokens_sold,\\n        uint256 max_eth_sold,\\n        uint256 deadline,\\n        address recipient,\\n        address token_addr\\n    ) external returns (uint256 tokens_sold);\\n\\n    // Trade ERC20 to Custom Pool\\n    function tokenToExchangeSwapInput(\\n        uint256 tokens_sold,\\n        uint256 min_tokens_bought,\\n        uint256 min_eth_bought,\\n        uint256 deadline,\\n        address exchange_addr\\n    ) external returns (uint256 tokens_bought);\\n\\n    function tokenToExchangeTransferInput(\\n        uint256 tokens_sold,\\n        uint256 min_tokens_bought,\\n        uint256 min_eth_bought,\\n        uint256 deadline,\\n        address recipient,\\n        address exchange_addr\\n    ) external returns (uint256 tokens_bought);\\n\\n    function tokenToExchangeSwapOutput(\\n        uint256 tokens_bought,\\n        uint256 max_tokens_sold,\\n        uint256 max_eth_sold,\\n        uint256 deadline,\\n        address exchange_addr\\n    ) external returns (uint256 tokens_sold);\\n\\n    function tokenToExchangeTransferOutput(\\n        uint256 tokens_bought,\\n        uint256 max_tokens_sold,\\n        uint256 max_eth_sold,\\n        uint256 deadline,\\n        address recipient,\\n        address exchange_addr\\n    ) external returns (uint256 tokens_sold);\\n\\n    // ERC20 comaptibility for liquidity tokens\\n    bytes32 public name;\\n    bytes32 public symbol;\\n    uint256 public decimals;\\n\\n    function transfer(address _to, uint256 _value) external returns (bool);\\n\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function approve(address _spender, uint256 _value) external returns (bool);\\n\\n    function allowance(address _owner, address _spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function balanceOf(address _owner) external view returns (uint256);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    // Never use\\n    function setup(address token_addr) external;\\n}\\n\"\r\n    },\r\n    \"/Users/alexisgauba/Desktop/Opyn/ConvexityProtocol/contracts/interfaces/UniswapFactoryInterface.sol\": {\r\n      \"content\": \"pragma solidity 0.5.10;\\n\\n\\n// Solidity Interface\\ncontract UniswapFactoryInterface {\\n    // Public Variables\\n    address public exchangeTemplate;\\n    uint256 public tokenCount;\\n\\n    // // Create Exchange\\n    function createExchange(address token) external returns (address exchange);\\n\\n    // Get Exchange and Token Info\\n    function getExchange(address token)\\n        external\\n        view\\n        returns (address exchange);\\n\\n    function getToken(address exchange) external view returns (address token);\\n\\n    function getTokenWithId(uint256 tokenId)\\n        external\\n        view\\n        returns (address token);\\n\\n    // Never use\\n    function initializeFactory(address template) external;\\n    // function createExchange(address token) external returns (address exchange) {\\n    //     return 0x06D014475F84Bb45b9cdeD1Cf3A1b8FE3FbAf128;\\n    // }\\n    // // Get Exchange and Token Info\\n    // function getExchange(address token) external view returns (address exchange){\\n    //     return 0x06D014475F84Bb45b9cdeD1Cf3A1b8FE3FbAf128;\\n    // }\\n    // function getToken(address exchange) external view returns (address token) {\\n    //     return 0x06D014475F84Bb45b9cdeD1Cf3A1b8FE3FbAf128;\\n    // }\\n    // function getTokenWithId(uint256 tokenId) external view returns (address token) {\\n    //     return 0x06D014475F84Bb45b9cdeD1Cf3A1b8FE3FbAf128;\\n    // }\\n}\\n\"\r\n    },\r\n    \"/Users/alexisgauba/Desktop/Opyn/ConvexityProtocol/contracts/lib/StringComparator.sol\": {\r\n      \"content\": \"pragma solidity 0.5.10;\\n\\nlibrary StringComparator {\\n    function compareStrings (string memory a, string memory b) public pure\\n       returns (bool) {\\n        return keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b)));\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/alexisgauba/Desktop/Opyn/ConvexityProtocol/contracts/oToken.sol\": {\r\n      \"content\": \"pragma solidity 0.5.10;\\n\\nimport \\\"./OptionsContract.sol\\\";\\nimport \\\"./OptionsExchange.sol\\\";\\n\\n\\n/**\\n * @title Opyn's Options Contract\\n * @author Opyn\\n */\\n\\ncontract oToken is OptionsContract {\\n    OptionsExchange public optionsExchange;\\n\\n    /**\\n     * @param _collateral The collateral asset\\n     * @param _underlying The asset that is being protected\\n     * @param _oTokenExchangeExp The precision of the `amount of underlying` that 1 oToken protects\\n     * @param _strikePrice The amount of strike asset that will be paid out\\n     * @param _strikeExp The precision of the strike asset (-18 if ETH)\\n     * @param _strike The asset in which the insurance is calculated\\n     * @param _expiry The time at which the insurance expires\\n     * @param _optionsExchange The contract which interfaces with the exchange + oracle\\n     * @param _oracleAddress The address of the oracle\\n     * @param _windowSize UNIX time. Exercise window is from `expiry - _windowSize` to `expiry`.\\n     */\\n    constructor(\\n        address _collateral,\\n        address _underlying,\\n        address _strike,\\n        int32 _oTokenExchangeExp,\\n        uint256 _strikePrice,\\n        int32 _strikeExp,\\n        uint256 _expiry,\\n        uint256 _windowSize,\\n        OptionsExchange _optionsExchange,\\n        address _oracleAddress\\n    )\\n        public\\n        OptionsContract(\\n            _collateral,\\n            _underlying,\\n            _strike,\\n            _oTokenExchangeExp,\\n            _strikePrice,\\n            _strikeExp,\\n            _expiry,\\n            _windowSize,\\n            _oracleAddress\\n        )\\n    {\\n        optionsExchange = _optionsExchange;\\n    }\\n\\n    /**\\n     * @notice opens a Vault, adds ETH collateral, and mints new oTokens in one step\\n     * Remember that creating oTokens can put the owner at a risk of losing the collateral\\n     * if an exercise event happens.\\n     * The sell function provides the owner a chance to earn premiums.\\n     * Ensure that you create and immediately sell oTokens atmoically.\\n     * @param amtToCreate number of oTokens to create\\n     * @param receiver address to send the Options to\\n     */\\n    function createETHCollateralOption(uint256 amtToCreate, address receiver)\\n        external\\n        payable\\n    {\\n        openVault();\\n        addETHCollateralOption(amtToCreate, receiver);\\n    }\\n\\n    /**\\n     * @notice adds ETH collateral, and mints new oTokens in one step to an existing Vault\\n     * Remember that creating oTokens can put the owner at a risk of losing the collateral\\n     * if an exercise event happens.\\n     * The sell function provides the owner a chance to earn premiums.\\n     * Ensure that you create and immediately sell oTokens atmoically.\\n     * @param amtToCreate number of oTokens to create\\n     * @param receiver address to send the Options to\\n     */\\n    function addETHCollateralOption(uint256 amtToCreate, address receiver)\\n        public\\n        payable\\n    {\\n        addETHCollateral(msg.sender);\\n        issueOTokens(amtToCreate, receiver);\\n    }\\n\\n    /**\\n     * @notice opens a Vault, adds ETH collateral, mints new oTokens and sell in one step\\n     * @param amtToCreate number of oTokens to create\\n     * @param receiver address to receive the premiums\\n     */\\n    function createAndSellETHCollateralOption(\\n        uint256 amtToCreate,\\n        address payable receiver\\n    ) external payable {\\n        openVault();\\n        addETHCollateralOption(amtToCreate, address(this));\\n        this.approve(address(optionsExchange), amtToCreate);\\n        optionsExchange.sellOTokens(\\n            receiver,\\n            address(this),\\n            address(0),\\n            amtToCreate\\n        );\\n    }\\n\\n    /**\\n     * @notice adds ETH collateral to an existing Vault, and mints new oTokens and sells the oTokens in one step\\n     * @param amtToCreate number of oTokens to create\\n     * @param receiver address to send the Options to\\n     */\\n    function addAndSellETHCollateralOption(\\n        uint256 amtToCreate,\\n        address payable receiver\\n    ) external payable {\\n        addETHCollateral(msg.sender);\\n        issueOTokens(amtToCreate, address(this));\\n        this.approve(address(optionsExchange), amtToCreate);\\n        optionsExchange.sellOTokens(\\n            receiver,\\n            address(this),\\n            address(0),\\n            amtToCreate\\n        );\\n    }\\n\\n    /**\\n     * @notice opens a Vault, adds ERC20 collateral, and mints new oTokens in one step\\n     * Remember that creating oTokens can put the owner at a risk of losing the collateral\\n     * if an exercise event happens.\\n     * The sell function provides the owner a chance to earn premiums.\\n     * Ensure that you create and immediately sell oTokens atmoically.\\n     * @param amtToCreate number of oTokens to create\\n     * @param amtCollateral amount of collateral added\\n     * @param receiver address to send the Options to\\n     */\\n    function createERC20CollateralOption(\\n        uint256 amtToCreate,\\n        uint256 amtCollateral,\\n        address receiver\\n    ) external {\\n        openVault();\\n        addERC20CollateralOption(amtToCreate, amtCollateral, receiver);\\n    }\\n\\n    /**\\n     * @notice adds ERC20 collateral, and mints new oTokens in one step\\n     * Remember that creating oTokens can put the owner at a risk of losing the collateral\\n     * if an exercise event happens.\\n     * The sell function provides the owner a chance to earn premiums.\\n     * Ensure that you create and immediately sell oTokens atmoically.\\n     * @param amtToCreate number of oTokens to create\\n     * @param amtCollateral amount of collateral added\\n     * @param receiver address to send the Options to\\n     */\\n    function addERC20CollateralOption(\\n        uint256 amtToCreate,\\n        uint256 amtCollateral,\\n        address receiver\\n    ) public {\\n        addERC20Collateral(msg.sender, amtCollateral);\\n        issueOTokens(amtToCreate, receiver);\\n    }\\n\\n    /**\\n     * @notice opens a Vault, adds ERC20 collateral, mints new oTokens and sells the oTokens in one step\\n     * @param amtToCreate number of oTokens to create\\n     * @param amtCollateral amount of collateral added\\n     * @param receiver address to send the Options to\\n     */\\n    function createAndSellERC20CollateralOption(\\n        uint256 amtToCreate,\\n        uint256 amtCollateral,\\n        address payable receiver\\n    ) external {\\n        openVault();\\n        addERC20CollateralOption(amtToCreate, amtCollateral, address(this));\\n        this.approve(address(optionsExchange), amtToCreate);\\n        optionsExchange.sellOTokens(\\n            receiver,\\n            address(this),\\n            address(0),\\n            amtToCreate\\n        );\\n    }\\n\\n    /**\\n     * @notice adds ERC20 collateral, mints new oTokens and sells the oTokens in one step\\n     * @param amtToCreate number of oTokens to create\\n     * @param amtCollateral amount of collateral added\\n     * @param receiver address to send the Options to\\n     */\\n    function addAndSellERC20CollateralOption(\\n        uint256 amtToCreate,\\n        uint256 amtCollateral,\\n        address payable receiver\\n    ) external {\\n        addERC20Collateral(msg.sender, amtCollateral);\\n        issueOTokens(amtToCreate, address(this));\\n        this.approve(address(optionsExchange), amtToCreate);\\n        optionsExchange.sellOTokens(\\n            receiver,\\n            address(this),\\n            address(0),\\n            amtToCreate\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/alexisgauba/Desktop/Opyn/ConvexityProtocol/contracts/packages/Context.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\ncontract Context {\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\n    // an instance of this contract, which should be used via inheritance.\\n    constructor() internal {}\\n\\n    // solhint-disable-previous-line no-empty-blocks\\n\\n    function _msgSender() internal view returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/alexisgauba/Desktop/Opyn/ConvexityProtocol/contracts/packages/ERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20Mintable}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20};\\n     *\\n     * Requirements:\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for `sender`'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(\\n            sender,\\n            _msgSender(),\\n            _allowances[sender][_msgSender()].sub(\\n                amount,\\n                \\\"ERC20: transfer amount exceeds allowance\\\"\\n            )\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue)\\n        public\\n        returns (bool)\\n    {\\n        _approve(\\n            _msgSender(),\\n            spender,\\n            _allowances[_msgSender()][spender].add(addedValue)\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue)\\n        public\\n        returns (bool)\\n    {\\n        _approve(\\n            _msgSender(),\\n            spender,\\n            _allowances[_msgSender()][spender].sub(\\n                subtractedValue,\\n                \\\"ERC20: decreased allowance below zero\\\"\\n            )\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _balances[sender] = _balances[sender].sub(\\n            amount,\\n            \\\"ERC20: transfer amount exceeds balance\\\"\\n        );\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _balances[account] = _balances[account].sub(\\n            amount,\\n            \\\"ERC20: burn amount exceeds balance\\\"\\n        );\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\n     *\\n     * This is internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\\n     * from the caller's allowance.\\n     *\\n     * See {_burn} and {_approve}.\\n     */\\n    function _burnFrom(address account, uint256 amount) internal {\\n        _burn(account, amount);\\n        _approve(\\n            account,\\n            _msgSender(),\\n            _allowances[account][_msgSender()].sub(\\n                amount,\\n                \\\"ERC20: burn amount exceeds allowance\\\"\\n            )\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/alexisgauba/Desktop/Opyn/ConvexityProtocol/contracts/packages/ERC20Detailed.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n\\n/**\\n * @dev Optional functions from the ERC20 standard.\\n */\\ncontract ERC20Detailed is IERC20 {\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\\n     * these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(\\n        string memory name,\\n        string memory symbol,\\n        uint8 decimals\\n    ) public {\\n        _name = name;\\n        _symbol = symbol;\\n        _decimals = decimals;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/alexisgauba/Desktop/Opyn/ConvexityProtocol/contracts/packages/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see {ERC20Detailed}.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\"\r\n    },\r\n    \"/Users/alexisgauba/Desktop/Opyn/ConvexityProtocol/contracts/packages/Ownable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./Context.sol\\\";\\n\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() internal {\\n        _owner = _msgSender();\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the current owner.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return _msgSender() == _owner;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(\\n            newOwner != address(0),\\n            \\\"Ownable: new owner is the zero address\\\"\\n        );\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/alexisgauba/Desktop/Opyn/ConvexityProtocol/contracts/packages/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"petersburg\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"whitelistAsset\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"optionsExchange\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumberOfOptionsContracts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oracleAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_collateral\",\"type\":\"address\"},{\"name\":\"_underlying\",\"type\":\"address\"},{\"name\":\"_strike\",\"type\":\"address\"},{\"name\":\"_oTokenExchangeExp\",\"type\":\"int32\"},{\"name\":\"_strikePrice\",\"type\":\"uint256\"},{\"name\":\"_strikeExp\",\"type\":\"int32\"},{\"name\":\"_expiry\",\"type\":\"uint256\"},{\"name\":\"_windowSize\",\"type\":\"uint256\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"createOptionsContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"optionsContracts\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_optionsExchangeAddr\",\"type\":\"address\"},{\"name\":\"_oracleAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"OptionsContractCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"AssetWhitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"OptionsFactory","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000039246c4f3f6592c974ebc44f80ba6dc69b817c710000000000000000000000007054e08461e3ecb7718b63540addb3c3a1746415","EVMVersion":"petersburg","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}