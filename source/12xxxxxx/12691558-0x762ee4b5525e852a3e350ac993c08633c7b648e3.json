{"status":"1","message":"OK","result":[{"SourceCode":"# Copyright (C) 2021 VolumeFi Software, Inc.\r\n\r\n#  This program is free software: you can redistribute it and/or modify\r\n#  it under the terms of the Apache 2.0 License. \r\n#  This program is distributed WITHOUT ANY WARRANTY without even the implied warranty of\r\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\r\n#  @author VolumeFi, Software inc.\r\n#  @notice This Vyper contract is for Dancing Bananas.\r\n#  SPDX-License-Identifier: Apache-2.0\r\n\r\n# @version ^0.2.12\r\n\r\nstruct MintParams:\r\n    token0: address\r\n    token1: address\r\n    fee: uint256\r\n    tickLower: int128\r\n    tickUpper: int128\r\n    amount0Desired: uint256\r\n    amount1Desired: uint256\r\n    amount0Min: uint256\r\n    amount1Min: uint256\r\n    recipient: address\r\n    deadline: uint256\r\n\r\nstruct SingleMintParams:\r\n    token0: address\r\n    token1: address\r\n    fee: uint256\r\n    tickLower: int128\r\n    tickUpper: int128\r\n    sqrtPriceAX96: uint256\r\n    sqrtPriceBX96: uint256\r\n    liquidityMin: uint256\r\n    recipient: address\r\n    deadline: uint256\r\n\r\nstruct RemoveParams:\r\n    liquidity: uint256\r\n    recipient: address\r\n    deadline: uint256\r\n\r\ninterface WrappedEth:\r\n    def deposit(): payable\r\n    def withdraw(amount: uint256): nonpayable\r\n\r\ninterface NonfungiblePositionManager:\r\n    def burn(tokenId: uint256): payable\r\n\r\ninterface ERC20:\r\n    def approve(account: address, amount: uint256): nonpayable\r\n    def transfer(account: address, amount: uint256): nonpayable\r\n    def transferFrom(_from: address, _to: address, amount: uint256): nonpayable\r\n\r\ninterface UniswapV2Factory:\r\n    def getPair(tokenA: address, tokenB: address) -> address: view\r\n\r\ninterface UniswapV2Pair:\r\n    def token0() -> address: view\r\n    def getReserves() -> (uint256, uint256, uint256): view\r\n\r\nevent AddedLiquidity:\r\n    tokenId: indexed(uint256)\r\n    token0: indexed(address)\r\n    token1: indexed(address)\r\n    liquidity: uint256\r\n    amount0: uint256\r\n    amount1: uint256\r\n\r\nevent RemovedLiquidity:\r\n    tokenId: indexed(uint256)\r\n    token0: indexed(address)\r\n    token1: indexed(address)\r\n    liquidity: uint256\r\n    amount0: uint256\r\n    amount1: uint256\r\n\r\nevent Paused:\r\n    paused: bool\r\n\r\nevent FeeChanged:\r\n    newFee: uint256\r\n\r\nNONFUNGIBLEPOSITIONMANAGER: constant(address) = 0xC36442b4a4522E871399CD717aBDD847Ab11FE88\r\nUNISWAPV3FACTORY: constant(address) = 0x1F98431c8aD98523631AE4a59f267346ea31F984\r\nUNISWAPV2FACTORY: constant(address) = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f\r\nUNISWAPV2ROUTER02: constant(address) = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\r\nVETH: constant(address) = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\r\nWETH: constant(address) = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\r\n\r\nCAIPIN_MID: constant(Bytes[4]) = method_id(\"createAndInitializePoolIfNecessary(address,address,uint24,uint160)\")\r\nGETPOOL_MID: constant(Bytes[4]) = method_id(\"getPool(address,address,uint24)\")\r\nSLOT0_MID: constant(Bytes[4]) = method_id(\"slot0()\")\r\nMINT_MID: constant(Bytes[4]) = method_id(\"mint((address,address,uint24,int24,int24,uint256,uint256,uint256,uint256,address,uint256))\")\r\nINCREASELIQUIDITY_MID: constant(Bytes[4]) = method_id(\"increaseLiquidity((uint256,uint256,uint256,uint256,uint256,uint256))\")\r\nDECREASELIQUIDITY_MID: constant(Bytes[4]) = method_id(\"decreaseLiquidity((uint256,uint128,uint256,uint256,uint256))\")\r\nPOSITIONS_MID: constant(Bytes[4]) = method_id(\"positions(uint256)\")\r\nCOLLECT_MID: constant(Bytes[4]) = method_id(\"collect((uint256,address,uint128,uint128))\")\r\nSWAPETFT_MID: constant(Bytes[4]) = method_id(\"swapExactTokensForTokens(uint256,uint256,address[],address,uint256)\")\r\n\r\nADDLIQETH_MID: constant(Bytes[4]) = method_id(\"addLiquidityEthForUniV3(uint256,(address,address,uint256,int128,int128,uint256,uint256,uint256,uint256,address,uint256))\")\r\n_ADDLIQETH_MID: constant(Bytes[4]) = method_id(\"_addLiquidityEthForUniV3(uint256,(address,address,uint256,int128,int128,uint256,uint256,uint256,uint256,address,uint256),address,uint256)\")\r\nADDLIQ_MID: constant(Bytes[4]) = method_id(\"addLiquidityForUniV3(uint256,(address,address,uint256,int128,int128,uint256,uint256,uint256,uint256,address,uint256))\")\r\n_ADDLIQ_MID: constant(Bytes[4]) = method_id(\"_addLiquidityForUniV3(uint256,(address,address,uint256,int128,int128,uint256,uint256,uint256,uint256,address,uint256),address)\")\r\nINVEST_MID: constant(Bytes[4]) = method_id(\"investTokenForUniPair(uint256,address,uint256,(address,address,uint256,int128,int128,uint256,uint256,uint256,address,uint256))\")\r\n_INVEST_MID: constant(Bytes[4]) = method_id(\"_investTokenForUniPair(uint256,address,uint256,(address,address,uint256,int128,int128,uint256,uint256,uint256,address,uint256),address,uint256)\")\r\nREMOVELIQ_MID: constant(Bytes[4]) = method_id(\"removeLiquidityFromUniV3NFLP(uint256,(uint256,address,uint256))\")\r\n_REMOVELIQ_MID: constant(Bytes[4]) = method_id(\"_removeLiquidityFromUniV3NFLP(uint256,(uint256,address,uint256))\")\r\nREMOVELIQETH_MID: constant(Bytes[4]) = method_id(\"removeLiquidityEthFromUniV3NFLP(uint256,(uint256,address,uint256))\")\r\n_REMOVELIQETH_MID: constant(Bytes[4]) = method_id(\"_removeLiquidityEthFromUniV3NFLP(uint256,(uint256,address,uint256))\")\r\nDIVEST_MID: constant(Bytes[4]) = method_id(\"divestUniV3NFLPToToken(uint256,address,(uint256,address,uint256),uint256)\")\r\n_DIVEST_MID: constant(Bytes[4]) = method_id(\"_divestUniV3NFLPToToken(uint256,address,(uint256,address,uint256),uint256)\")\r\n\r\npaused: public(bool)\r\nadmin: public(address)\r\nfeeAddress: public(address)\r\nfeeAmount: public(uint256)\r\n\r\n@external\r\ndef __init__():\r\n    self.paused = False\r\n    self.admin = msg.sender\r\n    self.feeAddress = 0xf29399fB3311082d9F8e62b988cBA44a5a98ebeD\r\n    self.feeAmount = 5 * 10 ** 15\r\n\r\n@internal\r\n@pure\r\ndef getCurrentSqrtPriceX96(token0: address, token1: address, feeLevel: uint256) -> uint256:\r\n    _response32: Bytes[32] = raw_call(\r\n        UNISWAPV3FACTORY,\r\n        concat(\r\n            GETPOOL_MID,\r\n            convert(token0, bytes32),\r\n            convert(token1, bytes32),\r\n            convert(feeLevel, bytes32)\r\n        ),\r\n        max_outsize=32,\r\n        is_static_call=True\r\n    )\r\n    pool: address = convert(convert(_response32, bytes32), address)\r\n    assert pool != ZERO_ADDRESS\r\n    _response224: Bytes[224] = raw_call(\r\n        pool,\r\n        SLOT0_MID,\r\n        max_outsize=224,\r\n        is_static_call=True\r\n    )\r\n    sqrtPriceX96: uint256 = convert(slice(_response224, 0, 32), uint256)\r\n    assert sqrtPriceX96 != 0\r\n    return sqrtPriceX96\r\n\r\n@internal\r\ndef addLiquidity(_tokenId: uint256, sender: address, uniV3Params: MintParams, _sqrtPriceX96: uint256 = 0) -> (uint256, uint256, uint256):\r\n    ERC20(uniV3Params.token0).approve(NONFUNGIBLEPOSITIONMANAGER, uniV3Params.amount0Desired)\r\n    ERC20(uniV3Params.token1).approve(NONFUNGIBLEPOSITIONMANAGER, uniV3Params.amount1Desired)\r\n    if _tokenId == 0:\r\n        sqrtPriceX96: uint256 = _sqrtPriceX96\r\n        if sqrtPriceX96 == 0:\r\n            sqrtPriceX96 = self.getCurrentSqrtPriceX96(uniV3Params.token0, uniV3Params.token1, uniV3Params.fee)\r\n        _response32: Bytes[32] = raw_call(\r\n            NONFUNGIBLEPOSITIONMANAGER,\r\n            concat(\r\n                CAIPIN_MID,\r\n                convert(uniV3Params.token0, bytes32),\r\n                convert(uniV3Params.token1, bytes32),\r\n                convert(uniV3Params.fee, bytes32),\r\n                convert(sqrtPriceX96, bytes32)\r\n            ),\r\n            max_outsize=32\r\n        )\r\n        assert convert(convert(_response32, bytes32), address) != ZERO_ADDRESS\r\n        _response128: Bytes[128] = raw_call(\r\n            NONFUNGIBLEPOSITIONMANAGER,\r\n            concat(\r\n                MINT_MID,\r\n                convert(uniV3Params.token0, bytes32),\r\n                convert(uniV3Params.token1, bytes32),\r\n                convert(uniV3Params.fee, bytes32),\r\n                convert(uniV3Params.tickLower, bytes32),\r\n                convert(uniV3Params.tickUpper, bytes32),\r\n                convert(uniV3Params.amount0Desired, bytes32),\r\n                convert(uniV3Params.amount1Desired, bytes32),\r\n                convert(uniV3Params.amount0Min, bytes32),\r\n                convert(uniV3Params.amount1Min, bytes32),\r\n                convert(uniV3Params.recipient, bytes32),\r\n                convert(uniV3Params.deadline, bytes32)\r\n            ),\r\n            max_outsize=128\r\n        )\r\n        tokenId: uint256 = convert(slice(_response128, 0, 32), uint256)\r\n        liquidity: uint256 = convert(slice(_response128, 32, 32), uint256)\r\n        amount0: uint256 = convert(slice(_response128, 64, 32), uint256)\r\n        amount1: uint256 = convert(slice(_response128, 96, 32), uint256)\r\n        log AddedLiquidity(tokenId, uniV3Params.token0, uniV3Params.token1, liquidity, amount0, amount1)\r\n        return (amount0, amount1, liquidity)\r\n    else:\r\n        liquidity: uint256 = 0\r\n        amount0: uint256 = 0\r\n        amount1: uint256 = 0\r\n        _response96: Bytes[96] = raw_call(\r\n            NONFUNGIBLEPOSITIONMANAGER,\r\n            concat(\r\n                INCREASELIQUIDITY_MID,\r\n                convert(_tokenId, bytes32),\r\n                convert(uniV3Params.amount0Desired, bytes32),\r\n                convert(uniV3Params.amount1Desired, bytes32),\r\n                convert(uniV3Params.amount0Min, bytes32),\r\n                convert(uniV3Params.amount1Min, bytes32),\r\n                convert(uniV3Params.deadline, bytes32)\r\n            ),\r\n            max_outsize=96\r\n        )\r\n        liquidity = convert(slice(_response96, 0, 32), uint256)\r\n        amount0 = convert(slice(_response96, 32, 32), uint256)\r\n        amount1 = convert(slice(_response96, 64, 32), uint256)\r\n        log AddedLiquidity(_tokenId, uniV3Params.token0, uniV3Params.token1, liquidity, amount0, amount1)\r\n        return (amount0, amount1, liquidity)\r\n\r\n@internal\r\ndef removeLiquidity(_tokenId: uint256, _removeParams: RemoveParams, _recipient: address=ZERO_ADDRESS) -> (address, address, uint256, uint256):\r\n    _response384: Bytes[384] = raw_call(\r\n        NONFUNGIBLEPOSITIONMANAGER,\r\n        concat(\r\n            POSITIONS_MID,\r\n            convert(_tokenId, bytes32)\r\n        ),\r\n        max_outsize=384,\r\n        is_static_call=True\r\n    )\r\n    token0: address = convert(convert(slice(_response384, 64, 32), uint256), address)\r\n    token1: address = convert(convert(slice(_response384, 96, 32), uint256), address)\r\n    liquidity: uint256 = convert(slice(_response384, 224, 32), uint256)\r\n    isBurn: bool = False\r\n    if liquidity <= _removeParams.liquidity:\r\n        isBurn = True\r\n    else:\r\n        liquidity = _removeParams.liquidity\r\n    _response64: Bytes[64] = raw_call(\r\n        NONFUNGIBLEPOSITIONMANAGER,\r\n        concat(\r\n            DECREASELIQUIDITY_MID,\r\n            convert(_tokenId, bytes32),\r\n            convert(liquidity, bytes32),\r\n            convert(0, bytes32),\r\n            convert(0, bytes32),\r\n            convert(_removeParams.deadline, bytes32)\r\n        ),\r\n        max_outsize=64\r\n    )\r\n    recipient: address = _recipient\r\n    if _recipient == ZERO_ADDRESS:\r\n        recipient = _removeParams.recipient\r\n\r\n    _response64 = raw_call(\r\n        NONFUNGIBLEPOSITIONMANAGER,\r\n        concat(\r\n            COLLECT_MID,\r\n            convert(_tokenId, bytes32),\r\n            convert(recipient, bytes32),\r\n            convert(2 ** 128 - 1, bytes32),\r\n            convert(2 ** 128 - 1, bytes32)\r\n        ),\r\n        max_outsize=64\r\n    )\r\n    amount0: uint256 = convert(slice(_response64, 0, 32), uint256)\r\n    amount1: uint256 = convert(slice(_response64, 32, 32), uint256)\r\n    if isBurn:\r\n        NonfungiblePositionManager(NONFUNGIBLEPOSITIONMANAGER).burn(_tokenId)\r\n\r\n    log RemovedLiquidity(_tokenId, token0, token1, liquidity, amount0, amount1)\r\n\r\n    return (token0, token1, amount0, amount1)\r\n\r\n@external\r\ndef _addLiquidityEthForUniV3(_tokenId: uint256, uniV3Params: MintParams, msg_sender: address, msg_value: uint256):\r\n    assert msg.sender == self\r\n    assert not self.paused\r\n    assert convert(uniV3Params.token0, uint256) < convert(uniV3Params.token1, uint256)\r\n    if uniV3Params.token0 == WETH:\r\n        if msg_value > uniV3Params.amount0Desired:\r\n            send(msg_sender, msg_value - uniV3Params.amount0Desired)\r\n        else:\r\n            assert msg_value == uniV3Params.amount0Desired\r\n        WrappedEth(WETH).deposit(value=uniV3Params.amount0Desired)\r\n        ERC20(uniV3Params.token1).transferFrom(msg_sender, self, uniV3Params.amount1Desired)\r\n        amount0: uint256 = 0\r\n        amount1: uint256 = 0\r\n        liquidity: uint256 = 0\r\n        (amount0, amount1, liquidity) = self.addLiquidity(_tokenId, msg_sender, uniV3Params)\r\n        amount0 = uniV3Params.amount0Desired - amount0\r\n        amount1 = uniV3Params.amount1Desired - amount1\r\n        if amount0 > 0:\r\n            WrappedEth(WETH).withdraw(amount0)\r\n            send(msg_sender, amount0)\r\n            ERC20(uniV3Params.token0).approve(NONFUNGIBLEPOSITIONMANAGER, 0)\r\n        if amount1 > 0:\r\n            ERC20(uniV3Params.token1).transfer(msg_sender, amount1)\r\n            ERC20(uniV3Params.token1).approve(NONFUNGIBLEPOSITIONMANAGER, 0)\r\n    else:\r\n        assert uniV3Params.token1 == WETH\r\n        if msg_value > uniV3Params.amount1Desired:\r\n            send(msg_sender, msg_value - uniV3Params.amount1Desired)\r\n        else:\r\n            assert msg_value == uniV3Params.amount1Desired\r\n        WrappedEth(WETH).deposit(value=uniV3Params.amount1Desired)\r\n        ERC20(uniV3Params.token0).transferFrom(msg_sender, self, uniV3Params.amount0Desired)\r\n        amount0: uint256 = 0\r\n        amount1: uint256 = 0\r\n        liquidity: uint256 = 0\r\n        (amount0, amount1, liquidity) = self.addLiquidity(_tokenId, msg_sender, uniV3Params)\r\n        amount0 = uniV3Params.amount0Desired - amount0\r\n        amount1 = uniV3Params.amount1Desired - amount1\r\n        if amount0 > 0:\r\n            ERC20(uniV3Params.token0).transfer(msg_sender, amount0)\r\n            ERC20(uniV3Params.token0).approve(NONFUNGIBLEPOSITIONMANAGER, 0)\r\n        if amount1 > 0:\r\n            WrappedEth(WETH).withdraw(amount1)\r\n            send(msg_sender, amount1)\r\n            ERC20(uniV3Params.token1).approve(NONFUNGIBLEPOSITIONMANAGER, 0)\r\n\r\n@external\r\ndef _addLiquidityForUniV3(_tokenId: uint256, uniV3Params: MintParams, msg_sender: address):\r\n    assert msg.sender == self\r\n    assert not self.paused\r\n    assert convert(uniV3Params.token0, uint256) < convert(uniV3Params.token1, uint256)\r\n    ERC20(uniV3Params.token0).transferFrom(msg_sender, self, uniV3Params.amount0Desired)\r\n    ERC20(uniV3Params.token1).transferFrom(msg_sender, self, uniV3Params.amount1Desired)\r\n    amount0: uint256 = 0\r\n    amount1: uint256 = 0\r\n    liquidity: uint256 = 0\r\n    (amount0, amount1, liquidity) = self.addLiquidity(_tokenId, msg_sender, uniV3Params)\r\n    amount0 = uniV3Params.amount0Desired - amount0\r\n    amount1 = uniV3Params.amount1Desired - amount1\r\n    if amount0 > 0:\r\n        ERC20(uniV3Params.token0).transfer(msg_sender, amount0)\r\n        ERC20(uniV3Params.token0).approve(NONFUNGIBLEPOSITIONMANAGER, 0)\r\n    if amount1 > 0:\r\n        ERC20(uniV3Params.token1).transfer(msg_sender, amount1)\r\n        ERC20(uniV3Params.token1).approve(NONFUNGIBLEPOSITIONMANAGER, 0)\r\n\r\n@external\r\ndef _removeLiquidityFromUniV3NFLP(_tokenId: uint256, _removeParams: RemoveParams):\r\n    assert msg.sender == self\r\n    assert _tokenId != 0\r\n    self.removeLiquidity(_tokenId, _removeParams)\r\n\r\n@external\r\ndef _removeLiquidityEthFromUniV3NFLP(_tokenId: uint256, _removeParams: RemoveParams):\r\n    assert msg.sender == self\r\n    assert _tokenId != 0\r\n    token0: address = ZERO_ADDRESS\r\n    token1: address = ZERO_ADDRESS\r\n    amount0: uint256 = 0\r\n    amount1: uint256 = 0\r\n    (token0, token1, amount0, amount1) = self.removeLiquidity(_tokenId, _removeParams, self)\r\n    if token0 == WETH and token1 != WETH:\r\n        WrappedEth(token0).withdraw(amount0)\r\n        send(_removeParams.recipient, amount0)\r\n        ERC20(token1).transfer(_removeParams.recipient, amount1)\r\n    elif token1 == WETH and token0 != WETH:\r\n        WrappedEth(token1).withdraw(amount1)\r\n        send(_removeParams.recipient, amount1)\r\n        ERC20(token0).transfer(_removeParams.recipient, amount0)\r\n    else:\r\n        raise \"Not Eth Pair\"\r\n\r\n@internal\r\ndef token2Token(fromToken: address, toToken: address, tokens2Trade: uint256, deadline: uint256) -> uint256:\r\n    if fromToken == toToken:\r\n        return tokens2Trade\r\n    ERC20(fromToken).approve(UNISWAPV2ROUTER02, tokens2Trade)\r\n    _response: Bytes[128] = raw_call(\r\n        UNISWAPV2ROUTER02,\r\n        concat(\r\n            SWAPETFT_MID,\r\n            convert(tokens2Trade, bytes32),\r\n            convert(0, bytes32),\r\n            convert(160, bytes32),\r\n            convert(self, bytes32),\r\n            convert(deadline, bytes32),\r\n            convert(2, bytes32),\r\n            convert(fromToken, bytes32),\r\n            convert(toToken, bytes32)\r\n        ),\r\n        max_outsize=128\r\n    )\r\n    tokenBought: uint256 = convert(slice(_response, 96, 32), uint256)\r\n    ERC20(fromToken).approve(UNISWAPV2ROUTER02, 0)\r\n    assert tokenBought > 0\r\n    return tokenBought\r\n\r\n@internal\r\n@view\r\ndef getVirtualPriceX96(sqrtPriceAX96: uint256, sqrtPriceX96: uint256, sqrtPriceBX96: uint256) -> uint256:\r\n    ret: uint256 = (sqrtPriceBX96 - sqrtPriceX96) * 2 ** 96 / sqrtPriceBX96 * 2 ** 96 / sqrtPriceX96 * 2 ** 96 / (sqrtPriceX96 - sqrtPriceAX96)\r\n    if ret > 2 ** 160:\r\n        return 2 ** 160\r\n    else:\r\n        return ret\r\n\r\n@internal\r\n@pure\r\ndef uintSqrt(x: uint256) -> uint256:\r\n    if x > 3:\r\n        z: uint256 = (x + 1) / 2\r\n        y: uint256 = x\r\n        for i in range(256):\r\n            if y == z:\r\n                return y\r\n            y = z\r\n            z = (x / z + z) / 2\r\n        raise \"Did not coverage\"\r\n    elif x == 0:\r\n        return 0\r\n    else:\r\n        return 1\r\n\r\n@internal\r\n@view\r\ndef getUserInForSqrtPriceX96(reserveIn: uint256, reserveOut: uint256, priceX96: uint256, toInvest: uint256) -> uint256:\r\n    b: uint256 = reserveIn + (reserveOut * 997 / 1000 * 2 ** 96 / priceX96) - toInvest * 997 / 1000\r\n    return (self.uintSqrt(b * b + 4 * reserveIn * toInvest * 997 / 1000) - b) * 1000 / 1994\r\n\r\n@internal\r\n@pure\r\ndef _getLiquidityInPool(midToken: address, pair: address) -> uint256:\r\n    res0: uint256 = 0\r\n    res1: uint256 = 0\r\n    blockTimestampLast: uint256 = 0\r\n    (res0, res1, blockTimestampLast) = UniswapV2Pair(pair).getReserves()\r\n    token0: address = UniswapV2Pair(pair).token0()\r\n    if token0 == midToken:\r\n        return res0\r\n    else:\r\n        return res1\r\n\r\n@internal\r\n@view\r\ndef getMidToken(midToken: address, token0: address, token1: address) -> address:\r\n    if midToken == token0 or midToken == token1:\r\n        return midToken\r\n    pair0: address = UniswapV2Factory(UNISWAPV2FACTORY).getPair(midToken, token0)\r\n    pair1: address = UniswapV2Factory(UNISWAPV2FACTORY).getPair(midToken, token1)\r\n    eth0: uint256 = self._getLiquidityInPool(midToken, pair0)\r\n    eth1: uint256 = self._getLiquidityInPool(midToken, pair1)\r\n    if eth0 > eth1:\r\n        return token0\r\n    else:\r\n        return token1\r\n\r\n@external\r\ndef _investTokenForUniPair(_tokenId: uint256, _token: address, amount: uint256, _uniV3Params: SingleMintParams, msg_sender: address, msg_value: uint256):\r\n    assert msg.sender == self\r\n    assert not self.paused\r\n    assert amount > 0\r\n    uniV3Params: MintParams = MintParams({\r\n        token0: _uniV3Params.token0,\r\n        token1: _uniV3Params.token1,\r\n        fee: _uniV3Params.fee,\r\n        tickLower: _uniV3Params.tickLower,\r\n        tickUpper: _uniV3Params.tickUpper,\r\n        amount0Desired: 0,\r\n        amount1Desired: 0,\r\n        amount0Min: 0,\r\n        amount1Min: 0,\r\n        recipient: _uniV3Params.recipient,\r\n        deadline: _uniV3Params.deadline\r\n    })\r\n    assert convert(uniV3Params.token0, uint256) < convert(uniV3Params.token1, uint256)\r\n    token: address = _token\r\n    toInvest: uint256 = 0\r\n    midToken: address = WETH\r\n    if token == VETH or token == ZERO_ADDRESS:\r\n        if msg_value > amount:\r\n            send(msg_sender, msg_value - amount)\r\n        else:\r\n            assert msg_value == amount\r\n        WrappedEth(WETH).deposit(value=amount)\r\n        token = WETH\r\n        toInvest = amount\r\n    else:\r\n        ERC20(token).transferFrom(msg_sender, self, amount)\r\n        if msg_value > 0:\r\n            send(msg_sender, msg_value)\r\n        if token == WETH:\r\n            toInvest = amount\r\n        elif token != uniV3Params.token0 and token != uniV3Params.token1:\r\n            toInvest = self.token2Token(token, WETH, amount, uniV3Params.deadline)\r\n        else:\r\n            midToken = token\r\n            toInvest = amount\r\n\r\n    if uniV3Params.token0 != WETH and uniV3Params.token1 != WETH and token != uniV3Params.token0 and token != uniV3Params.token1:\r\n        midToken = self.getMidToken(WETH, uniV3Params.token0, uniV3Params.token1)\r\n        toInvest = self.token2Token(WETH, midToken, toInvest, uniV3Params.deadline)\r\n\r\n    res0: uint256 = 0\r\n    res1: uint256 = 0\r\n    blockTimestampLast: uint256 = 0\r\n    pair: address = UniswapV2Factory(UNISWAPV2FACTORY).getPair(uniV3Params.token0, uniV3Params.token1)\r\n    endToken: address = ZERO_ADDRESS\r\n    if midToken == uniV3Params.token0:\r\n        (res0, res1, blockTimestampLast) = UniswapV2Pair(pair).getReserves()\r\n        endToken = uniV3Params.token1\r\n    else:\r\n        (res1, res0, blockTimestampLast) = UniswapV2Pair(pair).getReserves()\r\n        endToken = uniV3Params.token0\r\n\r\n    sqrtPriceX96: uint256 = 0\r\n\r\n    sqrtPriceX96 = self.getCurrentSqrtPriceX96(uniV3Params.token0, uniV3Params.token1, uniV3Params.fee)\r\n\r\n    retAmount: uint256 = 0\r\n    swapAmount: uint256 = 0\r\n    if sqrtPriceX96 <= _uniV3Params.sqrtPriceAX96:\r\n        if convert(midToken, uint256) > convert(endToken, uint256):\r\n            swapAmount = toInvest\r\n    elif sqrtPriceX96 >= _uniV3Params.sqrtPriceBX96:\r\n        if convert(midToken, uint256) < convert(endToken, uint256):\r\n            swapAmount = toInvest\r\n    else:\r\n        virtualPriceX96: uint256 = self.getVirtualPriceX96(_uniV3Params.sqrtPriceAX96, sqrtPriceX96, _uniV3Params.sqrtPriceBX96)\r\n        if convert(midToken, uint256) > convert(endToken, uint256):\r\n            swapAmount = self.getUserInForSqrtPriceX96(res0, res1, virtualPriceX96, toInvest)\r\n        else:\r\n            swapAmount = self.getUserInForSqrtPriceX96(res0, res1, 2 ** 192 / virtualPriceX96, toInvest)\r\n\r\n    if swapAmount > toInvest:\r\n        swapAmount = toInvest\r\n\r\n    if swapAmount > 0:\r\n        retAmount = self.token2Token(midToken, endToken, swapAmount, uniV3Params.deadline)\r\n\r\n    if uniV3Params.token0 == midToken:\r\n        uniV3Params.amount0Desired = toInvest - swapAmount\r\n        uniV3Params.amount1Desired = retAmount\r\n    else:\r\n        uniV3Params.amount1Desired = toInvest - swapAmount\r\n        uniV3Params.amount0Desired = retAmount\r\n\r\n    amount0: uint256 = 0\r\n    amount1: uint256 = 0\r\n    liquidity: uint256 = 0\r\n    (amount0, amount1, liquidity) = self.addLiquidity(_tokenId, msg_sender, uniV3Params, sqrtPriceX96)\r\n    assert liquidity >= _uniV3Params.liquidityMin\r\n    amount0 = uniV3Params.amount0Desired - amount0\r\n    amount1 = uniV3Params.amount1Desired - amount1\r\n    if amount0 > 0:\r\n        ERC20(uniV3Params.token0).approve(NONFUNGIBLEPOSITIONMANAGER, 0)\r\n    if amount1 > 0:\r\n        ERC20(uniV3Params.token1).approve(NONFUNGIBLEPOSITIONMANAGER, 0)\r\n\r\n@external\r\ndef _divestUniV3NFLPToToken(_tokenId: uint256, _token: address, _removeParams: RemoveParams, minTokenAmount: uint256):\r\n    assert msg.sender == self\r\n    deadline: uint256 = MAX_UINT256\r\n    assert not self.paused\r\n\r\n    token: address = _token\r\n    if token == VETH or token == ZERO_ADDRESS:\r\n        token = WETH\r\n\r\n    token0: address = ZERO_ADDRESS\r\n    token1: address = ZERO_ADDRESS\r\n    amount0: uint256 = 0\r\n    amount1: uint256 = 0\r\n    (token0, token1, amount0, amount1) = self.removeLiquidity(_tokenId, _removeParams, self)\r\n\r\n    amount: uint256 = 0\r\n    if token0 == token:\r\n        amount = self.token2Token(token1, token0, amount1, MAX_UINT256) + amount0\r\n    elif token1 == token:\r\n        amount = self.token2Token(token0, token1, amount0, MAX_UINT256) + amount1\r\n    else:\r\n        midToken: address = self.getMidToken(WETH, token0, token1)\r\n        if midToken == token0:\r\n            amount = self.token2Token(token1, token0, amount1, MAX_UINT256)\r\n            amount = self.token2Token(token0, WETH, amount + amount0, MAX_UINT256)\r\n            amount = self.token2Token(WETH, token, amount, MAX_UINT256)\r\n        else:\r\n            amount = self.token2Token(token0, token1, amount0, MAX_UINT256)\r\n            amount = self.token2Token(token1, WETH, amount + amount1, MAX_UINT256)\r\n            amount = self.token2Token(WETH, token, amount, MAX_UINT256)\r\n\r\n    assert amount >= minTokenAmount\r\n\r\n    if token != _token:\r\n        WrappedEth(WETH).withdraw(amount)\r\n        send(_removeParams.recipient, amount)\r\n    else:\r\n        ERC20(token).transfer(_removeParams.recipient, amount)\r\n\r\n@external\r\n@payable\r\n@nonreentrant('lock')\r\ndef batchRun(data: Bytes[3616]):\r\n    fee: uint256 = self.feeAmount\r\n    assert msg.value >= fee\r\n    send(self.feeAddress, fee)\r\n    cursor: uint256 = 0\r\n    usedValue: uint256 = fee\r\n    for i in range(8):\r\n        if len(data) < cursor + 4:\r\n            break\r\n        mid: Bytes[4] = slice(data, cursor, 4)\r\n        cursor += 4\r\n        if mid == ADDLIQ_MID:\r\n            raw_call(self,\r\n                concat(\r\n                    _ADDLIQ_MID,\r\n                    slice(data, cursor, 384),\r\n                    convert(msg.sender, bytes32)\r\n                )\r\n            )\r\n            cursor += 384\r\n        elif mid == ADDLIQETH_MID:\r\n            if convert(convert(slice(data, cursor + 32, 32), uint256), address) == WETH:\r\n                raw_call(self,\r\n                    concat(\r\n                        _ADDLIQETH_MID,\r\n                        slice(data, cursor, 384),\r\n                        convert(msg.sender, bytes32),\r\n                        slice(data, cursor + 192, 32)\r\n                    )\r\n                )\r\n                usedValue += convert(slice(data, cursor + 192, 32), uint256)\r\n            else:\r\n                assert convert(convert(slice(data, cursor + 64, 32), uint256), address) == WETH\r\n                raw_call(self,\r\n                    concat(\r\n                        _ADDLIQETH_MID,\r\n                        slice(data, cursor, 384),\r\n                        convert(msg.sender, bytes32),\r\n                        slice(data, cursor + 224, 32)\r\n                    )\r\n                )\r\n                usedValue += convert(slice(data, cursor + 224, 32), uint256)\r\n            cursor += 384\r\n        elif mid == REMOVELIQ_MID:\r\n            raw_call(self,\r\n                concat(\r\n                    _REMOVELIQ_MID,\r\n                    slice(data, cursor, 128)\r\n                )\r\n            )\r\n            cursor += 128\r\n        elif mid == REMOVELIQETH_MID:\r\n            raw_call(self,\r\n                concat(\r\n                    _REMOVELIQETH_MID,\r\n                    slice(data, cursor, 128)\r\n                )\r\n            )\r\n            cursor += 128\r\n        elif mid == INVEST_MID:\r\n            token: address = convert(convert(slice(data, cursor + 32, 32), uint256), address)\r\n            if token == VETH or token == ZERO_ADDRESS:\r\n                raw_call(self,\r\n                    concat(\r\n                        _INVEST_MID,\r\n                        slice(data, cursor, 416),\r\n                        convert(msg.sender, bytes32),\r\n                        slice(data, cursor + 64, 32)\r\n                    )\r\n                )\r\n                usedValue += convert(slice(data, cursor + 64, 32), uint256)\r\n            else:\r\n                raw_call(self,\r\n                    concat(\r\n                        _INVEST_MID,\r\n                        slice(data, cursor, 416),\r\n                        convert(msg.sender, bytes32),\r\n                        convert(0, bytes32)\r\n                    )\r\n                )\r\n            cursor += 416\r\n        elif mid == DIVEST_MID:\r\n            raw_call(self,\r\n                concat(\r\n                    _DIVEST_MID,\r\n                    slice(data, cursor, 192)\r\n                )\r\n            )\r\n            cursor += 192\r\n        else:\r\n            assert convert(mid, uint256) == 0\r\n            break\r\n\r\n    if msg.value - usedValue > 0:\r\n        send(msg.sender, msg.value - usedValue)\r\n\r\n# Admin functions\r\n@external\r\ndef pause(_paused: bool):\r\n    assert msg.sender == self.admin\r\n    self.paused = _paused\r\n    log Paused(_paused)\r\n\r\n@external\r\ndef newAdmin(_admin: address):\r\n    assert msg.sender == self.admin\r\n    self.admin = _admin\r\n\r\n@external\r\ndef newFeeAmount(_feeAmount: uint256):\r\n    assert msg.sender == self.admin\r\n    self.feeAmount = _feeAmount\r\n    log FeeChanged(_feeAmount)\r\n\r\n@external\r\ndef newFeeAddress(_feeAddress: address):\r\n    assert msg.sender == self.admin\r\n    self.feeAddress = _feeAddress\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef batchWithdraw(token: address[8], amount: uint256[8], to: address[8]):\r\n    assert msg.sender == self.admin\r\n    for i in range(8):\r\n        if token[i] == VETH:\r\n            send(to[i], amount[i])\r\n        elif token[i] != ZERO_ADDRESS:\r\n            ERC20(token[i]).transfer(to[i], amount[i])\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef withdraw(token: address, amount: uint256, to: address):\r\n    assert msg.sender == self.admin\r\n    if token == VETH:\r\n        send(to, amount)\r\n    elif token != ZERO_ADDRESS:\r\n        ERC20(token).transfer(to, amount)\r\n\r\n@external\r\n@payable\r\ndef __default__():\r\n    assert msg.sender == WETH","ABI":"[{\"name\":\"AddedLiquidity\",\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"token0\",\"type\":\"address\",\"indexed\":true},{\"name\":\"token1\",\"type\":\"address\",\"indexed\":true},{\"name\":\"liquidity\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"amount0\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"amount1\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RemovedLiquidity\",\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"token0\",\"type\":\"address\",\"indexed\":true},{\"name\":\"token1\",\"type\":\"address\",\"indexed\":true},{\"name\":\"liquidity\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"amount0\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"amount1\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Paused\",\"inputs\":[{\"name\":\"paused\",\"type\":\"bool\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"FeeChanged\",\"inputs\":[{\"name\":\"newFee\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"_addLiquidityEthForUniV3\",\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"uniV3Params\",\"type\":\"tuple\",\"components\":[{\"name\":\"token0\",\"type\":\"address\"},{\"name\":\"token1\",\"type\":\"address\"},{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"tickLower\",\"type\":\"int128\"},{\"name\":\"tickUpper\",\"type\":\"int128\"},{\"name\":\"amount0Desired\",\"type\":\"uint256\"},{\"name\":\"amount1Desired\",\"type\":\"uint256\"},{\"name\":\"amount0Min\",\"type\":\"uint256\"},{\"name\":\"amount1Min\",\"type\":\"uint256\"},{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"deadline\",\"type\":\"uint256\"}]},{\"name\":\"msg_sender\",\"type\":\"address\"},{\"name\":\"msg_value\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":226074},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"_addLiquidityForUniV3\",\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"uniV3Params\",\"type\":\"tuple\",\"components\":[{\"name\":\"token0\",\"type\":\"address\"},{\"name\":\"token1\",\"type\":\"address\"},{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"tickLower\",\"type\":\"int128\"},{\"name\":\"tickUpper\",\"type\":\"int128\"},{\"name\":\"amount0Desired\",\"type\":\"uint256\"},{\"name\":\"amount1Desired\",\"type\":\"uint256\"},{\"name\":\"amount0Min\",\"type\":\"uint256\"},{\"name\":\"amount1Min\",\"type\":\"uint256\"},{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"deadline\",\"type\":\"uint256\"}]},{\"name\":\"msg_sender\",\"type\":\"address\"}],\"outputs\":[],\"gas\":119369},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"_removeLiquidityFromUniV3NFLP\",\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_removeParams\",\"type\":\"tuple\",\"components\":[{\"name\":\"liquidity\",\"type\":\"uint256\"},{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"deadline\",\"type\":\"uint256\"}]}],\"outputs\":[],\"gas\":53243},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"_removeLiquidityEthFromUniV3NFLP\",\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_removeParams\",\"type\":\"tuple\",\"components\":[{\"name\":\"liquidity\",\"type\":\"uint256\"},{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"deadline\",\"type\":\"uint256\"}]}],\"outputs\":[],\"gas\":99739},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"_investTokenForUniPair\",\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"_uniV3Params\",\"type\":\"tuple\",\"components\":[{\"name\":\"token0\",\"type\":\"address\"},{\"name\":\"token1\",\"type\":\"address\"},{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"tickLower\",\"type\":\"int128\"},{\"name\":\"tickUpper\",\"type\":\"int128\"},{\"name\":\"sqrtPriceAX96\",\"type\":\"uint256\"},{\"name\":\"sqrtPriceBX96\",\"type\":\"uint256\"},{\"name\":\"liquidityMin\",\"type\":\"uint256\"},{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"deadline\",\"type\":\"uint256\"}]},{\"name\":\"msg_sender\",\"type\":\"address\"},{\"name\":\"msg_value\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":609798},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"_divestUniV3NFLPToToken\",\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_removeParams\",\"type\":\"tuple\",\"components\":[{\"name\":\"liquidity\",\"type\":\"uint256\"},{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"deadline\",\"type\":\"uint256\"}]},{\"name\":\"minTokenAmount\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":197576},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"batchRun\",\"inputs\":[{\"name\":\"data\",\"type\":\"bytes\"}],\"outputs\":[],\"gas\":382890},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"pause\",\"inputs\":[{\"name\":\"_paused\",\"type\":\"bool\"}],\"outputs\":[],\"gas\":39195},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"newAdmin\",\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"}],\"outputs\":[],\"gas\":37875},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"newFeeAmount\",\"inputs\":[{\"name\":\"_feeAmount\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":39155},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"newFeeAddress\",\"inputs\":[{\"name\":\"_feeAddress\",\"type\":\"address\"}],\"outputs\":[],\"gas\":37935},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"batchWithdraw\",\"inputs\":[{\"name\":\"token\",\"type\":\"address[8]\"},{\"name\":\"amount\",\"type\":\"uint256[8]\"},{\"name\":\"to\",\"type\":\"address[8]\"}],\"outputs\":[],\"gas\":352263},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"withdraw\",\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"to\",\"type\":\"address\"}],\"outputs\":[],\"gas\":96563},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"paused\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":2868},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2898},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"feeAddress\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2928},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"feeAmount\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":2958}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.12","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":""}]}