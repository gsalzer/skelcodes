{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier:  AGPL-3.0-or-later // hevm: flattened sources of contracts/Pool.sol\r\npragma solidity =0.6.11 >=0.6.0 <0.8.0 >=0.6.2 <0.8.0;\r\n\r\n////// contracts/interfaces/IBPool.sol\r\n/* pragma solidity 0.6.11; */\r\n\r\ninterface IBPool {\r\n\r\n    function transfer(address, uint256) external returns (bool);\r\n\r\n    function INIT_POOL_SUPPLY() external view returns (uint256);\r\n\r\n    function MAX_OUT_RATIO() external view returns (uint256);\r\n\r\n    function bind(address, uint256, uint256) external;\r\n\r\n    function balanceOf(address) external view returns (uint256);\r\n\r\n    function finalize() external;\r\n\r\n    function gulp(address) external;\r\n\r\n    function isFinalized() external view returns (bool);\r\n\r\n    function isBound(address) external view returns (bool);\r\n\r\n    function getNumTokens() external view returns (uint256);\r\n\r\n    function getBalance(address) external view returns (uint256);\r\n\r\n    function getNormalizedWeight(address) external view returns (uint256);\r\n\r\n    function getDenormalizedWeight(address) external view returns (uint256);\r\n\r\n    function getTotalDenormalizedWeight() external view returns (uint256);\r\n\r\n    function getSwapFee() external view returns (uint256);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function getFinalTokens() external view returns (address[] memory);\r\n\r\n    function joinPool(uint poolAmountOut, uint[] calldata maxAmountsIn) external;\r\n\r\n    function calcSingleOutGivenPoolIn(\r\n        uint256 tokenBalanceOut,\r\n        uint256 tokenWeightOut,\r\n        uint256 poolSupply,\r\n        uint256 totalWeight,\r\n        uint256 poolAmountIn,\r\n        uint256 swapFee\r\n    ) external pure returns (uint256);\r\n\r\n    function calcPoolInGivenSingleOut(\r\n        uint256 tokenBalanceOut,\r\n        uint256 tokenWeightOut,\r\n        uint256 poolSupply,\r\n        uint256 totalWeight,\r\n        uint256 tokenAmountOut,\r\n        uint256 swapFee\r\n    ) external pure returns (uint256);\r\n\r\n    function exitswapExternAmountOut(\r\n        address tokenOut,\r\n        uint256 tokenAmountOut,\r\n        uint256 maxPoolAmountIn\r\n    ) external returns (uint256 poolAmountIn);\r\n\r\n}\r\n\r\n////// contracts/interfaces/IDebtLocker.sol\r\n/* pragma solidity 0.6.11; */\r\n\r\ninterface IDebtLocker {\r\n\r\n    function loan() external view returns (address);\r\n\r\n    function liquidityAsset() external view returns (address);\r\n\r\n    function pool() external view returns (address);\r\n\r\n    function lastPrincipalPaid() external view returns (uint256);\r\n\r\n    function lastInterestPaid() external view returns (uint256);\r\n\r\n    function lastFeePaid() external view returns (uint256);\r\n\r\n    function lastExcessReturned() external view returns (uint256);\r\n\r\n    function lastDefaultSuffered() external view returns (uint256);\r\n\r\n    function lastAmountRecovered() external view returns (uint256);\r\n\r\n    function claim() external returns (uint256[7] memory);\r\n    \r\n    function triggerDefault() external;\r\n\r\n}\r\n\r\n////// contracts/interfaces/ILiquidityLocker.sol\r\n/* pragma solidity 0.6.11; */\r\n\r\ninterface ILiquidityLocker {\r\n\r\n    function pool() external view returns (address);\r\n\r\n    function liquidityAsset() external view returns (address);\r\n\r\n    function transfer(address, uint256) external;\r\n\r\n    function fundLoan(address, address, uint256) external;\r\n\r\n}\r\n\r\n////// contracts/interfaces/ILiquidityLockerFactory.sol\r\n/* pragma solidity 0.6.11; */\r\n\r\ninterface ILiquidityLockerFactory {\r\n\r\n    function owner(address) external view returns (address);\r\n    \r\n    function isLocker(address) external view returns (bool);\r\n\r\n    function factoryType() external view returns (uint8);\r\n\r\n    function newLocker(address) external returns (address);\r\n\r\n}\r\n\r\n////// contracts/token/interfaces/IBaseFDT.sol\r\n/* pragma solidity 0.6.11; */\r\n\r\ninterface IBaseFDT {\r\n\r\n    /**\r\n        @dev    Returns the total amount of funds a given address is able to withdraw currently.\r\n        @param  owner Address of FDT holder.\r\n        @return A uint256 representing the available funds for a given account.\r\n    */\r\n    function withdrawableFundsOf(address owner) external view returns (uint256);\r\n\r\n    /**\r\n        @dev Withdraws all available funds for a FDT holder.\r\n    */\r\n    function withdrawFunds() external;\r\n\r\n    /**\r\n        @dev   This event emits when new funds are distributed.\r\n        @param by               The address of the sender that distributed funds.\r\n        @param fundsDistributed The amount of funds received for distribution.\r\n    */\r\n    event FundsDistributed(address indexed by, uint256 fundsDistributed);\r\n\r\n    /**\r\n        @dev   This event emits when distributed funds are withdrawn by a token holder.\r\n        @param by             The address of the receiver of funds.\r\n        @param fundsWithdrawn The amount of funds that were withdrawn.\r\n        @param totalWithdrawn The total amount of funds that were withdrawn.\r\n    */\r\n    event FundsWithdrawn(address indexed by, uint256 fundsWithdrawn, uint256 totalWithdrawn);\r\n\r\n}\r\n\r\n////// lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\r\n/* pragma solidity >=0.6.0 <0.8.0; */\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n////// contracts/token/interfaces/IBasicFDT.sol\r\n/* pragma solidity 0.6.11; */\r\n\r\n/* import \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\"; */\r\n\r\n/* import \"./IBaseFDT.sol\"; */\r\n\r\ninterface IBasicFDT is IBaseFDT, IERC20 {\r\n\r\n    event PointsPerShareUpdated(uint256);\r\n\r\n    event PointsCorrectionUpdated(address indexed, int256);\r\n\r\n    function withdrawnFundsOf(address) external view returns (uint256);\r\n\r\n    function accumulativeFundsOf(address) external view returns (uint256);\r\n\r\n    function updateFundsReceived() external;\r\n\r\n}\r\n\r\n////// contracts/token/interfaces/ILoanFDT.sol\r\n/* pragma solidity 0.6.11; */\r\n\r\n/* import \"./IBasicFDT.sol\"; */\r\n\r\ninterface ILoanFDT is IBasicFDT {\r\n\r\n    function fundsToken() external view returns (address);\r\n\r\n    function fundsTokenBalance() external view returns (uint256);\r\n\r\n}\r\n\r\n////// contracts/interfaces/ILoan.sol\r\n/* pragma solidity 0.6.11; */\r\n\r\n/* import \"../token/interfaces/ILoanFDT.sol\"; */\r\n\r\ninterface ILoan is ILoanFDT {\r\n    \r\n    // State Variables\r\n    function liquidityAsset() external view returns (address);\r\n    \r\n    function collateralAsset() external view returns (address);\r\n    \r\n    function fundingLocker() external view returns (address);\r\n    \r\n    function flFactory() external view returns (address);\r\n    \r\n    function collateralLocker() external view returns (address);\r\n    \r\n    function clFactory() external view returns (address);\r\n    \r\n    function borrower() external view returns (address);\r\n    \r\n    function repaymentCalc() external view returns (address);\r\n    \r\n    function lateFeeCalc() external view returns (address);\r\n    \r\n    function premiumCalc() external view returns (address);\r\n    \r\n    function loanState() external view returns (uint256);\r\n    \r\n    function collateralRequiredForDrawdown(uint256) external view returns (uint256);\r\n    \r\n\r\n    // Loan Specifications\r\n    function apr() external view returns (uint256);\r\n    \r\n    function paymentsRemaining() external view returns (uint256);\r\n    \r\n    function paymentIntervalSeconds() external view returns (uint256);\r\n    \r\n    function requestAmount() external view returns (uint256);\r\n    \r\n    function collateralRatio() external view returns (uint256);\r\n    \r\n    function fundingPeriod() external view returns (uint256);\r\n\r\n    function defaultGracePeriod() external view returns (uint256);\r\n    \r\n    function createdAt() external view returns (uint256);\r\n    \r\n    function principalOwed() external view returns (uint256);\r\n    \r\n    function principalPaid() external view returns (uint256);\r\n    \r\n    function interestPaid() external view returns (uint256);\r\n    \r\n    function feePaid() external view returns (uint256);\r\n    \r\n    function excessReturned() external view returns (uint256);\r\n    \r\n    function getNextPayment() external view returns (uint256, uint256, uint256, uint256);\r\n    \r\n    function superFactory() external view returns (address);\r\n    \r\n    function termDays() external view returns (uint256);\r\n    \r\n    function nextPaymentDue() external view returns (uint256);\r\n\r\n    function getFullPayment() external view returns (uint256, uint256, uint256);\r\n    \r\n\r\n    // Liquidations\r\n    function amountLiquidated() external view returns (uint256);\r\n\r\n    function defaultSuffered() external view returns (uint256);\r\n    \r\n    function amountRecovered() external view returns (uint256);\r\n    \r\n    function getExpectedAmountRecovered() external view returns (uint256);\r\n\r\n    function liquidationExcess() external view returns (uint256);\r\n    \r\n\r\n    // Functions\r\n    function fundLoan(address, uint256) external;\r\n    \r\n    function makePayment() external;\r\n    \r\n    function drawdown(uint256) external;\r\n    \r\n    function makeFullPayment() external;\r\n    \r\n    function triggerDefault() external;\r\n    \r\n    function unwind() external;\r\n    \r\n\r\n    // Security \r\n    function pause() external;\r\n\r\n    function unpause() external;\r\n\r\n    function loanAdmins(address) external view returns (address);\r\n\r\n    function setLoanAdmin(address, bool) external;\r\n\r\n\r\n    // Misc\r\n    function reclaimERC20(address) external;\r\n\r\n}\r\n\r\n////// contracts/interfaces/ILoanFactory.sol\r\n/* pragma solidity 0.6.11; */\r\n\r\ninterface ILoanFactory {\r\n\r\n    function CL_FACTORY() external view returns (uint8);\r\n\r\n    function FL_FACTORY() external view returns (uint8);\r\n\r\n    function INTEREST_CALC_TYPE() external view returns (uint8);\r\n\r\n    function LATEFEE_CALC_TYPE() external view returns (uint8);\r\n\r\n    function PREMIUM_CALC_TYPE() external view returns (uint8);\r\n\r\n    function globals() external view returns (address);\r\n\r\n    function loansCreated() external view returns (uint256);\r\n\r\n    function loans(uint256) external view returns (address);\r\n\r\n    function isLoan(address) external view returns (bool);\r\n\r\n    function loanFactoryAdmins(address) external view returns (bool);\r\n\r\n    function setGlobals(address) external;\r\n    \r\n    function createLoan(address, address, address, address, uint256[5] memory, address[3] memory) external returns (address);\r\n\r\n    function setLoanFactoryAdmin(address, bool) external;\r\n\r\n    function pause() external;\r\n\r\n    function unpause() external;\r\n\r\n}\r\n\r\n////// contracts/interfaces/IMapleGlobals.sol\r\n/* pragma solidity 0.6.11; */\r\n\r\ninterface IMapleGlobals {\r\n\r\n    function pendingGovernor() external view returns (address);\r\n\r\n    function governor() external view returns (address);\r\n\r\n    function globalAdmin() external view returns (address);\r\n\r\n    function mpl() external view returns (address);\r\n\r\n    function mapleTreasury() external view returns (address);\r\n\r\n    function isValidBalancerPool(address) external view returns (bool);\r\n\r\n    function treasuryFee() external view returns (uint256);\r\n\r\n    function investorFee() external view returns (uint256);\r\n\r\n    function defaultGracePeriod() external view returns (uint256);\r\n\r\n    function fundingPeriod() external view returns (uint256);\r\n\r\n    function swapOutRequired() external view returns (uint256);\r\n\r\n    function isValidLiquidityAsset(address) external view returns (bool);\r\n\r\n    function isValidCollateralAsset(address) external view returns (bool);\r\n\r\n    function isValidPoolDelegate(address) external view returns (bool);\r\n\r\n    function validCalcs(address) external view returns (bool);\r\n\r\n    function isValidCalc(address, uint8) external view returns (bool);\r\n\r\n    function getLpCooldownParams() external view returns (uint256, uint256);\r\n\r\n    function isValidLoanFactory(address) external view returns (bool);\r\n\r\n    function isValidSubFactory(address, address, uint8) external view returns (bool);\r\n\r\n    function isValidPoolFactory(address) external view returns (bool);\r\n    \r\n    function getLatestPrice(address) external view returns (uint256);\r\n    \r\n    function defaultUniswapPath(address, address) external view returns (address);\r\n\r\n    function minLoanEquity() external view returns (uint256);\r\n    \r\n    function maxSwapSlippage() external view returns (uint256);\r\n\r\n    function protocolPaused() external view returns (bool);\r\n\r\n    function stakerCooldownPeriod() external view returns (uint256);\r\n\r\n    function lpCooldownPeriod() external view returns (uint256);\r\n\r\n    function stakerUnstakeWindow() external view returns (uint256);\r\n\r\n    function lpWithdrawWindow() external view returns (uint256);\r\n\r\n    function oracleFor(address) external view returns (address);\r\n\r\n    function validSubFactories(address, address) external view returns (bool);\r\n\r\n    function setStakerCooldownPeriod(uint256) external;\r\n\r\n    function setLpCooldownPeriod(uint256) external;\r\n\r\n    function setStakerUnstakeWindow(uint256) external;\r\n\r\n    function setLpWithdrawWindow(uint256) external;\r\n\r\n    function setMaxSwapSlippage(uint256) external;\r\n\r\n    function setGlobalAdmin(address) external;\r\n\r\n    function setValidBalancerPool(address, bool) external;\r\n\r\n    function setProtocolPause(bool) external;\r\n\r\n    function setValidPoolFactory(address, bool) external;\r\n\r\n    function setValidLoanFactory(address, bool) external;\r\n\r\n    function setValidSubFactory(address, address, bool) external;\r\n\r\n    function setDefaultUniswapPath(address, address, address) external;\r\n\r\n    function setPoolDelegateAllowlist(address, bool) external;\r\n\r\n    function setCollateralAsset(address, bool) external;\r\n\r\n    function setLiquidityAsset(address, bool) external;\r\n\r\n    function setCalc(address, bool) external;\r\n\r\n    function setInvestorFee(uint256) external;\r\n\r\n    function setTreasuryFee(uint256) external;\r\n\r\n    function setMapleTreasury(address) external;\r\n\r\n    function setDefaultGracePeriod(uint256) external;\r\n\r\n    function setMinLoanEquity(uint256) external;\r\n\r\n    function setFundingPeriod(uint256) external;\r\n\r\n    function setSwapOutRequired(uint256) external;\r\n\r\n    function setPriceOracle(address, address) external;\r\n\r\n    function setPendingGovernor(address) external;\r\n\r\n    function acceptGovernor() external;\r\n\r\n}\r\n\r\n////// contracts/interfaces/IPoolFactory.sol\r\n/* pragma solidity 0.6.11; */\r\n\r\ninterface IPoolFactory {\r\n\r\n    function LL_FACTORY() external view returns (uint8);\r\n\r\n    function SL_FACTORY() external view returns (uint8);\r\n\r\n    function poolsCreated() external view returns (uint256);\r\n\r\n    function globals() external view returns (address);\r\n\r\n    function pools(uint256) external view returns (address);\r\n\r\n    function isPool(address) external view returns (bool);\r\n\r\n    function poolFactoryAdmins(address) external view returns (bool);\r\n\r\n    function setGlobals(address) external;\r\n\r\n    function createPool(address, address, address, address, uint256, uint256, uint256) external returns (address);\r\n\r\n    function setPoolFactoryAdmin(address, bool) external;\r\n\r\n    function pause() external;\r\n\r\n    function unpause() external;\r\n\r\n}\r\n\r\n////// contracts/token/interfaces/IExtendedFDT.sol\r\n/* pragma solidity 0.6.11; */\r\n\r\n/* import \"./IBasicFDT.sol\"; */\r\n\r\ninterface IExtendedFDT is IBasicFDT {\r\n\r\n    event LossesPerShareUpdated(uint256);\r\n\r\n    event LossesCorrectionUpdated(address indexed, int256);\r\n\r\n    event LossesDistributed(address indexed, uint256);\r\n\r\n    event LossesRecognized(address indexed, uint256, uint256);\r\n\r\n    function lossesPerShare() external view returns (uint256);\r\n\r\n    function recognizableLossesOf(address) external view returns (uint256);\r\n\r\n    function recognizedLossesOf(address) external view returns (uint256);\r\n\r\n    function accumulativeLossesOf(address) external view returns (uint256);\r\n\r\n    function updateLossesReceived() external;\r\n\r\n}\r\n\r\n////// contracts/token/interfaces/IStakeLockerFDT.sol\r\n/* pragma solidity 0.6.11; */\r\n\r\n/* import \"./IExtendedFDT.sol\"; */\r\n\r\ninterface IStakeLockerFDT is IExtendedFDT {\r\n\r\n    function fundsToken() external view returns (address);\r\n\r\n    function fundsTokenBalance() external view returns (uint256);\r\n\r\n    function bptLosses() external view returns (uint256);\r\n\r\n    function lossesBalance() external view returns (uint256);\r\n\r\n}\r\n\r\n////// contracts/interfaces/IStakeLocker.sol\r\n/* pragma solidity 0.6.11; */\r\n\r\n/* import \"../token/interfaces/IStakeLockerFDT.sol\"; */\r\n\r\ninterface IStakeLocker is IStakeLockerFDT {\r\n\r\n    function stakeDate(address) external returns (uint256);\r\n\r\n    function stake(uint256) external;\r\n\r\n    function unstake(uint256) external;\r\n\r\n    function pull(address, uint256) external;\r\n\r\n    function setAllowlist(address, bool) external;\r\n\r\n    function openStakeLockerToPublic() external;\r\n\r\n    function openToPublic() external view returns (bool);\r\n\r\n    function allowed(address) external view returns (bool);\r\n\r\n    function updateLosses(uint256) external;\r\n\r\n    function intendToUnstake() external;\r\n\r\n    function unstakeCooldown(address) external view returns (uint256);\r\n\r\n    function lockupPeriod() external view returns (uint256);\r\n\r\n    function stakeAsset() external view returns (address);\r\n\r\n    function liquidityAsset() external view returns (address);\r\n\r\n    function pool() external view returns (address);\r\n\r\n    function setLockupPeriod(uint256) external;\r\n\r\n    function cancelUnstake() external;\r\n\r\n    function increaseCustodyAllowance(address, uint256) external;\r\n\r\n    function transferByCustodian(address, address, uint256) external;\r\n\r\n    function pause() external;\r\n\r\n    function unpause() external;\r\n\r\n    function isUnstakeAllowed(address) external view returns (bool);\r\n\r\n    function isReceiveAllowed(uint256) external view returns (bool);\r\n\r\n}\r\n\r\n////// contracts/interfaces/IStakeLockerFactory.sol\r\n/* pragma solidity 0.6.11; */\r\n\r\ninterface IStakeLockerFactory {\r\n\r\n    function owner(address) external returns (address);\r\n\r\n    function isLocker(address) external returns (bool);\r\n\r\n    function factoryType() external returns (uint8);\r\n\r\n    function newLocker(address, address) external returns (address);\r\n\r\n}\r\n\r\n////// contracts/interfaces/IDebtLockerFactory.sol\r\n/* pragma solidity 0.6.11; */\r\n\r\ninterface IDebtLockerFactory {\r\n\r\n    function owner(address) external view returns (address);\r\n\r\n    function isLocker(address) external view returns (bool);\r\n\r\n    function factoryType() external view returns (uint8);\r\n\r\n    function newLocker(address) external returns (address);\r\n\r\n}\r\n\r\n////// contracts/interfaces/IERC20Details.sol\r\n/* pragma solidity 0.6.11; */\r\n\r\n/* import \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\"; */\r\n\r\ninterface IERC20Details is IERC20 {\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint256);\r\n\r\n}\r\n\r\n////// lib/openzeppelin-contracts/contracts/math/SafeMath.sol\r\n/* pragma solidity >=0.6.0 <0.8.0; */\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n////// lib/openzeppelin-contracts/contracts/utils/Address.sol\r\n/* pragma solidity >=0.6.2 <0.8.0; */\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n////// lib/openzeppelin-contracts/contracts/token/ERC20/SafeERC20.sol\r\n/* pragma solidity >=0.6.0 <0.8.0; */\r\n\r\n/* import \"./IERC20.sol\"; */\r\n/* import \"../../math/SafeMath.sol\"; */\r\n/* import \"../../utils/Address.sol\"; */\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n////// contracts/library/PoolLib.sol\r\n/* pragma solidity 0.6.11; */\r\n\r\n/* import \"lib/openzeppelin-contracts/contracts/math/SafeMath.sol\"; */\r\n/* import \"lib/openzeppelin-contracts/contracts/token/ERC20/SafeERC20.sol\"; */\r\n/* import \"../interfaces/ILoan.sol\"; */\r\n/* import \"../interfaces/IBPool.sol\"; */\r\n/* import \"../interfaces/IMapleGlobals.sol\"; */\r\n/* import \"../interfaces/ILiquidityLocker.sol\"; */\r\n/* import \"../interfaces/IERC20Details.sol\"; */\r\n/* import \"../interfaces/ILoanFactory.sol\"; */\r\n/* import \"../interfaces/IStakeLocker.sol\"; */\r\n/* import \"../interfaces/IDebtLockerFactory.sol\"; */\r\n\r\n/// @title PoolLib is a library of utility functions used by Pool.\r\nlibrary PoolLib {\r\n\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    uint256 public constant MAX_UINT256 = uint256(-1);\r\n    uint256 public constant WAD         = 10 ** 18;\r\n    uint8   public constant DL_FACTORY  = 1;         // Factory type of DebtLockerFactory\r\n\r\n    event         LoanFunded(address indexed loan, address debtLocker, uint256 amountFunded);\r\n    event DepositDateUpdated(address indexed liquidityProvider, uint256 depositDate);\r\n\r\n    /***************************************/\r\n    /*** Pool Delegate Utility Functions ***/\r\n    /***************************************/\r\n\r\n    /** \r\n        @dev   Conducts sanity checks for Pools in the constructor.\r\n        @param globals        Instance of a MapleGlobals.\r\n        @param liquidityAsset Asset used by Pool for liquidity to fund loans.\r\n        @param stakeAsset     Asset escrowed in StakeLocker.\r\n        @param stakingFee     Fee that the Stakers earn on interest, in basis points.\r\n        @param delegateFee    Fee that the Pool Delegate earns on interest, in basis points.\r\n    */\r\n    function poolSanityChecks(\r\n        IMapleGlobals globals, \r\n        address liquidityAsset, \r\n        address stakeAsset, \r\n        uint256 stakingFee, \r\n        uint256 delegateFee\r\n    ) external view {\r\n        IBPool bPool = IBPool(stakeAsset);\r\n\r\n        require(globals.isValidLiquidityAsset(liquidityAsset), \"P:INVALID_LIQ_ASSET\");\r\n        require(stakingFee.add(delegateFee) <= 10_000,         \"P:INVALID_FEES\");\r\n        require(\r\n            globals.isValidBalancerPool(address(stakeAsset)) &&\r\n            bPool.isBound(globals.mpl())                     && \r\n            bPool.isBound(liquidityAsset)                    &&\r\n            bPool.isFinalized(), \r\n            \"P:INVALID_BALANCER_POOL\"\r\n        );\r\n    }\r\n\r\n    /**\r\n        @dev   Funds a Loan for an amount, utilizing the supplied DebtLockerFactory for DebtLockers.\r\n        @dev   It emits a `LoanFunded` event.\r\n        @param debtLockers     Mapping contains the DebtLocker contract address corresponding to the DebtLockerFactory and Loan.\r\n        @param superFactory    Address of the PoolFactory.\r\n        @param liquidityLocker Address of the LiquidityLocker contract attached with this Pool.\r\n        @param loan            Address of the Loan to fund.\r\n        @param dlFactory       The DebtLockerFactory to utilize.\r\n        @param amt             Amount to fund the Loan.\r\n    */\r\n    function fundLoan(\r\n        mapping(address => mapping(address => address)) storage debtLockers,\r\n        address superFactory,\r\n        address liquidityLocker,\r\n        address loan,\r\n        address dlFactory,\r\n        uint256 amt\r\n    ) external {\r\n        IMapleGlobals globals = IMapleGlobals(ILoanFactory(superFactory).globals());\r\n        address loanFactory   = ILoan(loan).superFactory();\r\n\r\n        // Auth checks.\r\n        require(globals.isValidLoanFactory(loanFactory),                        \"P:INVALID_LF\");\r\n        require(ILoanFactory(loanFactory).isLoan(loan),                         \"P:INVALID_L\");\r\n        require(globals.isValidSubFactory(superFactory, dlFactory, DL_FACTORY), \"P:INVALID_DLF\");\r\n\r\n        address debtLocker = debtLockers[loan][dlFactory];\r\n\r\n        // Instantiate DebtLocker if it doesn't exist withing this factory\r\n        if (debtLocker == address(0)) {\r\n            debtLocker = IDebtLockerFactory(dlFactory).newLocker(loan);\r\n            debtLockers[loan][dlFactory] = debtLocker;\r\n        }\r\n    \r\n        // Fund the Loan.\r\n        ILiquidityLocker(liquidityLocker).fundLoan(loan, debtLocker, amt);\r\n        \r\n        emit LoanFunded(loan, debtLocker, amt);\r\n    }\r\n\r\n    /**\r\n        @dev    Helper function used by Pool `claim` function, for when if a default has occurred.\r\n        @param  liquidityAsset                  IERC20 of Liquidity Asset.\r\n        @param  stakeLocker                     Address of StakeLocker.\r\n        @param  stakeAsset                      Address of BPTs.\r\n        @param  defaultSuffered                 Amount of shortfall in defaulted Loan after liquidation.\r\n        @return bptsBurned                      Amount of BPTs burned to cover shortfall.\r\n        @return postBurnBptBal                  Amount of BPTs returned to StakeLocker after burn.\r\n        @return liquidityAssetRecoveredFromBurn Amount of Liquidity Asset recovered from burn.\r\n    */\r\n    function handleDefault(\r\n        IERC20  liquidityAsset,\r\n        address stakeLocker,\r\n        address stakeAsset,\r\n        uint256 defaultSuffered\r\n    ) \r\n        external\r\n        returns (\r\n            uint256 bptsBurned,\r\n            uint256 postBurnBptBal,\r\n            uint256 liquidityAssetRecoveredFromBurn\r\n        ) \r\n    {\r\n\r\n        IBPool bPool = IBPool(stakeAsset);  // stakeAsset = Balancer Pool Tokens\r\n\r\n        // Check amount of Liquidity Asset coverage that exists in the StakeLocker.\r\n        uint256 availableSwapOut = getSwapOutValueLocker(stakeAsset, address(liquidityAsset), stakeLocker);\r\n\r\n        // Pull BPTs from StakeLocker.\r\n        IStakeLocker(stakeLocker).pull(address(this), bPool.balanceOf(stakeLocker));\r\n\r\n        // To maintain accounting, account for direct transfers into Pool.\r\n        uint256 preBurnLiquidityAssetBal = liquidityAsset.balanceOf(address(this));\r\n        uint256 preBurnBptBal            = bPool.balanceOf(address(this));\r\n\r\n        // Burn enough BPTs for Liquidity Asset to cover default suffered.\r\n        bPool.exitswapExternAmountOut(\r\n            address(liquidityAsset), \r\n            availableSwapOut >= defaultSuffered ? defaultSuffered : availableSwapOut,  // Burn BPTs up to defaultSuffered amount\r\n            preBurnBptBal\r\n        );\r\n\r\n        // Return remaining BPTs to StakeLocker.\r\n        postBurnBptBal = bPool.balanceOf(address(this));\r\n        bptsBurned     = preBurnBptBal.sub(postBurnBptBal);\r\n        bPool.transfer(stakeLocker, postBurnBptBal);\r\n        liquidityAssetRecoveredFromBurn = liquidityAsset.balanceOf(address(this)).sub(preBurnLiquidityAssetBal);\r\n        IStakeLocker(stakeLocker).updateLosses(bptsBurned);  // Update StakeLockerFDT loss accounting for BPTs\r\n    }\r\n\r\n    /**\r\n        @dev    Calculates portions of claim from DebtLocker to be used by Pool `claim` function.\r\n        @param  claimInfo           [0] = Total Claimed\r\n                                    [1] = Interest Claimed\r\n                                    [2] = Principal Claimed\r\n                                    [3] = Fee Claimed\r\n                                    [4] = Excess Returned Claimed\r\n                                    [5] = Amount Recovered (from Liquidation)\r\n                                    [6] = Default Suffered\r\n        @param  delegateFee         Portion of interest (basis points) that goes to the Pool Delegate.\r\n        @param  stakingFee          Portion of interest (basis points) that goes to the StakeLocker.\r\n        @return poolDelegatePortion Total funds to send to the Pool Delegate.\r\n        @return stakeLockerPortion  Total funds to send to the StakeLocker.\r\n        @return principalClaim      Total principal claim.\r\n        @return interestClaim       Total interest claim.\r\n    */\r\n    function calculateClaimAndPortions(\r\n        uint256[7] calldata claimInfo,\r\n        uint256 delegateFee,\r\n        uint256 stakingFee\r\n    ) \r\n        external\r\n        pure\r\n        returns (\r\n            uint256 poolDelegatePortion,\r\n            uint256 stakeLockerPortion,\r\n            uint256 principalClaim,\r\n            uint256 interestClaim\r\n        ) \r\n    { \r\n        poolDelegatePortion = claimInfo[1].mul(delegateFee).div(10_000).add(claimInfo[3]);  // Pool Delegate portion of interest plus fee.\r\n        stakeLockerPortion  = claimInfo[1].mul(stakingFee).div(10_000);                     // StakeLocker portion of interest.\r\n\r\n        principalClaim = claimInfo[2].add(claimInfo[4]).add(claimInfo[5]);                                     // principal + excess + amountRecovered\r\n        interestClaim  = claimInfo[1].sub(claimInfo[1].mul(delegateFee).div(10_000)).sub(stakeLockerPortion);  // leftover interest\r\n    }\r\n\r\n    /**\r\n        @dev   Checks that the deactivation is allowed.\r\n        @param globals        Instance of a MapleGlobals.\r\n        @param principalOut   Amount of funds that are already funded to Loans.\r\n        @param liquidityAsset Liquidity Asset of the Pool.\r\n    */\r\n    function validateDeactivation(IMapleGlobals globals, uint256 principalOut, address liquidityAsset) external view {\r\n        require(principalOut <= _convertFromUsd(globals, liquidityAsset, 100), \"P:PRINCIPAL_OUTSTANDING\");\r\n    }\r\n\r\n    /********************************************/\r\n    /*** Liquidity Provider Utility Functions ***/\r\n    /********************************************/\r\n\r\n    /**\r\n        @dev   Updates the effective deposit date based on how much new capital has been added.\r\n               If more capital is added, the deposit date moves closer to the current timestamp.\r\n        @dev   It emits a `DepositDateUpdated` event.\r\n        @param amt     Total deposit amount.\r\n        @param account Address of account depositing.\r\n    */\r\n    function updateDepositDate(mapping(address => uint256) storage depositDate, uint256 balance, uint256 amt, address account) internal {\r\n        uint256 prevDate = depositDate[account];\r\n\r\n        // prevDate + (now - prevDate) * (amt / (balance + amt))\r\n        // NOTE: prevDate = 0 implies balance = 0, and equation reduces to now\r\n        uint256 newDate = (balance + amt) > 0\r\n            ? prevDate.add(block.timestamp.sub(prevDate).mul(amt).div(balance + amt))\r\n            : prevDate;\r\n\r\n        depositDate[account] = newDate;\r\n        emit DepositDateUpdated(account, newDate);\r\n    }\r\n\r\n    /**\r\n        @dev Performs all necessary checks for a `transferByCustodian` call.\r\n        @dev From and to must always be equal.\r\n    */\r\n    function transferByCustodianChecks(address from, address to, uint256 amount) external pure {\r\n        require(to == from,                 \"P:INVALID_RECEIVER\");\r\n        require(amount != uint256(0),       \"P:INVALID_AMT\");\r\n    }\r\n\r\n    /**\r\n        @dev Performs all necessary checks for an `increaseCustodyAllowance` call.\r\n    */\r\n    function increaseCustodyAllowanceChecks(address custodian, uint256 amount, uint256 newTotalAllowance, uint256 fdtBal) external pure {\r\n        require(custodian != address(0),     \"P:INVALID_CUSTODIAN\");\r\n        require(amount    != uint256(0),     \"P:INVALID_AMT\");\r\n        require(newTotalAllowance <= fdtBal, \"P:INSUF_BALANCE\");\r\n    }\r\n\r\n    /**********************************/\r\n    /*** Governor Utility Functions ***/\r\n    /**********************************/\r\n\r\n    /**\r\n        @dev   Transfers any locked funds to the Governor. Only the Governor can call this function.\r\n        @param token          Address of the token to be reclaimed.\r\n        @param liquidityAsset Address of Liquidity Asset that is supported by the Pool.\r\n        @param globals        Instance of a MapleGlobals.\r\n    */\r\n    function reclaimERC20(address token, address liquidityAsset, IMapleGlobals globals) external {\r\n        require(msg.sender == globals.governor(), \"P:NOT_GOV\");\r\n        require(token != liquidityAsset && token != address(0), \"P:INVALID_TOKEN\");\r\n        IERC20(token).safeTransfer(msg.sender, IERC20(token).balanceOf(address(this)));\r\n    }\r\n\r\n    /************************/\r\n    /*** Getter Functions ***/\r\n    /************************/\r\n\r\n    /**\r\n        @dev Official Balancer pool bdiv() function. Does synthetic float with 10^-18 precision.\r\n    */\r\n    function _bdiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"P:DIV_ZERO\");\r\n        uint256 c0 = a * WAD;\r\n        require(a == 0 || c0 / a == WAD, \"P:DIV_INTERNAL\");  // bmul overflow\r\n        uint256 c1 = c0 + (b / 2);\r\n        require(c1 >= c0, \"P:DIV_INTERNAL\");  //  badd require\r\n        return c1 / b;\r\n    }\r\n\r\n    /**\r\n        @dev    Calculates the value of BPT in units of Liquidity Asset.\r\n        @dev    Vulnerable to flash-loan attacks where the attacker can artificially inflate the BPT price by swapping a large amount\r\n                of Liquidity Asset into the Pool and swapping back after this function is called.\r\n        @param  _bPool         Address of Balancer pool.\r\n        @param  liquidityAsset Asset used by Pool for liquidity to fund Loans.\r\n        @param  staker         Address that deposited BPTs to StakeLocker.\r\n        @param  stakeLocker    Escrows BPTs deposited by Staker.\r\n        @return USDC value of Staker BPTs.\r\n    */\r\n    function BPTVal(\r\n        address _bPool,\r\n        address liquidityAsset,\r\n        address staker,\r\n        address stakeLocker\r\n    ) external view returns (uint256) {\r\n        IBPool bPool = IBPool(_bPool);\r\n\r\n        // StakeLockerFDTs are minted 1:1 (in wei) in the StakeLocker when staking BPTs, thus representing stake amount.\r\n        // These are burned when withdrawing staked BPTs, thus representing the current stake amount.\r\n        uint256 amountStakedBPT       = IERC20(stakeLocker).balanceOf(staker);\r\n        uint256 totalSupplyBPT        = IERC20(_bPool).totalSupply();\r\n        uint256 liquidityAssetBalance = bPool.getBalance(liquidityAsset);\r\n        uint256 liquidityAssetWeight  = bPool.getNormalizedWeight(liquidityAsset);\r\n\r\n        // liquidityAsset value = (amountStaked/totalSupply) * (liquidityAssetBalance/liquidityAssetWeight)\r\n        return _bdiv(amountStakedBPT, totalSupplyBPT).mul(_bdiv(liquidityAssetBalance, liquidityAssetWeight)).div(WAD);\r\n    }\r\n\r\n    /** \r\n        @dev    Calculates Liquidity Asset swap out value of staker BPT balance escrowed in StakeLocker.\r\n        @param  _bPool         Balancer pool that issues the BPTs.\r\n        @param  liquidityAsset Swap out asset (e.g. USDC) to receive when burning BPTs.\r\n        @param  staker         Address that deposited BPTs to StakeLocker.\r\n        @param  stakeLocker    Escrows BPTs deposited by Staker.\r\n        @return liquidityAsset Swap out value of staker BPTs.\r\n    */\r\n    function getSwapOutValue(\r\n        address _bPool,\r\n        address liquidityAsset,\r\n        address staker,\r\n        address stakeLocker\r\n    ) public view returns (uint256) {\r\n        return _getSwapOutValue(_bPool, liquidityAsset, IERC20(stakeLocker).balanceOf(staker));\r\n    }\r\n\r\n    /** \r\n        @dev    Calculates Liquidity Asset swap out value of entire BPT balance escrowed in StakeLocker.\r\n        @param  _bPool         Balancer pool that issues the BPTs.\r\n        @param  liquidityAsset Swap out asset (e.g. USDC) to receive when burning BPTs.\r\n        @param  stakeLocker    Escrows BPTs deposited by Staker.\r\n        @return liquidityAsset Swap out value of StakeLocker BPTs.\r\n    */\r\n    function getSwapOutValueLocker(\r\n        address _bPool,\r\n        address liquidityAsset,\r\n        address stakeLocker\r\n    ) public view returns (uint256) {\r\n        return _getSwapOutValue(_bPool, liquidityAsset, IBPool(_bPool).balanceOf(stakeLocker));\r\n    }\r\n\r\n    function _getSwapOutValue(\r\n        address _bPool,\r\n        address liquidityAsset,\r\n        uint256 poolAmountIn\r\n    ) internal view returns (uint256) {\r\n        // Fetch Balancer pool token information\r\n        IBPool bPool            = IBPool(_bPool);\r\n        uint256 tokenBalanceOut = bPool.getBalance(liquidityAsset);\r\n        uint256 tokenWeightOut  = bPool.getDenormalizedWeight(liquidityAsset);\r\n        uint256 poolSupply      = bPool.totalSupply();\r\n        uint256 totalWeight     = bPool.getTotalDenormalizedWeight();\r\n        uint256 swapFee         = bPool.getSwapFee();\r\n\r\n        // Returns the amount of liquidityAsset that can be recovered from BPT burning\r\n        uint256 tokenAmountOut = bPool.calcSingleOutGivenPoolIn(\r\n            tokenBalanceOut,\r\n            tokenWeightOut,\r\n            poolSupply,\r\n            totalWeight,\r\n            poolAmountIn,\r\n            swapFee\r\n        );\r\n\r\n        // Max amount that can be swapped based on amount of liquidityAsset in the Balancer Pool\r\n        uint256 maxSwapOut = tokenBalanceOut.mul(bPool.MAX_OUT_RATIO()).div(WAD);  \r\n\r\n        return tokenAmountOut <= maxSwapOut ? tokenAmountOut : maxSwapOut;\r\n    }\r\n\r\n    /**\r\n        @dev    Calculates BPTs required if burning BPTs for liquidityAsset, given supplied tokenAmountOutRequired.\r\n        @dev    Vulnerable to flash-loan attacks where the attacker can artificially inflate the BPT price by swapping a large amount\r\n                of liquidityAsset into the pool and swapping back after this function is called.\r\n        @param  _bPool                       Balancer pool that issues the BPTs.\r\n        @param  liquidityAsset               Swap out asset (e.g. USDC) to receive when burning BPTs.\r\n        @param  staker                       Address that deposited BPTs to stakeLocker.\r\n        @param  stakeLocker                  Escrows BPTs deposited by staker.\r\n        @param  liquidityAssetAmountRequired Amount of liquidityAsset required to recover.\r\n        @return poolAmountInRequired         poolAmountIn required.\r\n        @return stakerBalance                poolAmountIn currently staked.\r\n    */\r\n    function getPoolSharesRequired(\r\n        address _bPool,\r\n        address liquidityAsset,\r\n        address staker,\r\n        address stakeLocker,\r\n        uint256 liquidityAssetAmountRequired\r\n    ) public view returns (uint256 poolAmountInRequired, uint256 stakerBalance) {\r\n        // Fetch Balancer pool token information.\r\n        IBPool bPool = IBPool(_bPool);\r\n\r\n        uint256 tokenBalanceOut = bPool.getBalance(liquidityAsset);\r\n        uint256 tokenWeightOut  = bPool.getDenormalizedWeight(liquidityAsset);\r\n        uint256 poolSupply      = bPool.totalSupply();\r\n        uint256 totalWeight     = bPool.getTotalDenormalizedWeight();\r\n        uint256 swapFee         = bPool.getSwapFee();\r\n\r\n        // Fetch amount of BPTs required to burn to receive Liquidity Asset amount required.\r\n        poolAmountInRequired = bPool.calcPoolInGivenSingleOut(\r\n            tokenBalanceOut,\r\n            tokenWeightOut,\r\n            poolSupply,\r\n            totalWeight,\r\n            liquidityAssetAmountRequired,\r\n            swapFee\r\n        );\r\n\r\n        // Fetch amount staked in StakeLocker by Staker.\r\n        stakerBalance = IERC20(stakeLocker).balanceOf(staker);\r\n    }\r\n\r\n    /**\r\n        @dev    Returns information on the stake requirements.\r\n        @param  globals                    Instance of a MapleGlobals.\r\n        @param  balancerPool               Address of Balancer pool.\r\n        @param  liquidityAsset             Address of Liquidity Asset, to be returned from swap out.\r\n        @param  poolDelegate               Address of Pool Delegate.\r\n        @param  stakeLocker                Address of StakeLocker.\r\n        @return swapOutAmountRequired      Min amount of Liquidity Asset coverage from staking required (in Liquidity Asset units).\r\n        @return currentPoolDelegateCover   Present amount of Liquidity Asset coverage from Pool Delegate stake (in Liquidity Asset units).\r\n        @return enoughStakeForFinalization If enough stake is present from Pool Delegate for Pool finalization.\r\n        @return poolAmountInRequired       BPTs required for minimum Liquidity Asset coverage.\r\n        @return poolAmountPresent          Current staked BPTs.\r\n    */\r\n    function getInitialStakeRequirements(IMapleGlobals globals, address balancerPool, address liquidityAsset, address poolDelegate, address stakeLocker) external view returns (\r\n        uint256 swapOutAmountRequired,\r\n        uint256 currentPoolDelegateCover,\r\n        bool    enoughStakeForFinalization,\r\n        uint256 poolAmountInRequired,\r\n        uint256 poolAmountPresent\r\n    ) {\r\n        swapOutAmountRequired = _convertFromUsd(globals, liquidityAsset, globals.swapOutRequired());\r\n        (\r\n            poolAmountInRequired,\r\n            poolAmountPresent\r\n        ) = getPoolSharesRequired(balancerPool, liquidityAsset, poolDelegate, stakeLocker, swapOutAmountRequired);\r\n\r\n        currentPoolDelegateCover   = getSwapOutValue(balancerPool, liquidityAsset, poolDelegate, stakeLocker);\r\n        enoughStakeForFinalization = poolAmountPresent >= poolAmountInRequired;\r\n    }\r\n\r\n    /************************/\r\n    /*** Helper Functions ***/\r\n    /************************/\r\n\r\n    /**\r\n        @dev   Converts from WAD precision to Liquidity Asset precision.\r\n        @param amt                    Amount to convert.\r\n        @param liquidityAssetDecimals Liquidity Asset decimal.\r\n    */\r\n    function fromWad(uint256 amt, uint256 liquidityAssetDecimals) external pure returns (uint256) {\r\n        return amt.mul(10 ** liquidityAssetDecimals).div(WAD);\r\n    }\r\n\r\n    /** \r\n        @dev    Returns Liquidity Asset in Liquidity Asset units when given integer USD (E.g., $100 = 100).\r\n        @param  globals        Instance of a MapleGlobals.\r\n        @param  liquidityAsset Liquidity Asset of the pool.\r\n        @param  usdAmount      USD amount to convert, in integer units (e.g., $100 = 100).\r\n        @return usdAmount worth of Liquidity Asset, in Liquidity Asset units.\r\n    */\r\n    function _convertFromUsd(IMapleGlobals globals, address liquidityAsset, uint256 usdAmount) internal view returns (uint256) {\r\n        return usdAmount\r\n            .mul(10 ** 8)                                         // Cancel out 10 ** 8 decimals from oracle.\r\n            .mul(10 ** IERC20Details(liquidityAsset).decimals())  // Convert to Liquidity Asset precision.\r\n            .div(globals.getLatestPrice(liquidityAsset));         // Convert to Liquidity Asset value.\r\n    }\r\n}\r\n\r\n////// contracts/math/SafeMathInt.sol\r\n/* pragma solidity 0.6.11; */\r\n\r\nlibrary SafeMathInt {\r\n    function toUint256Safe(int256 a) internal pure returns (uint256) {\r\n        require(a >= 0, \"SMI:NEG\");\r\n        return uint256(a);\r\n    }\r\n}\r\n\r\n////// contracts/math/SafeMathUint.sol\r\n/* pragma solidity 0.6.11; */\r\n\r\nlibrary SafeMathUint {\r\n    function toInt256Safe(uint256 a) internal pure returns (int256 b) {\r\n        b = int256(a);\r\n        require(b >= 0, \"SMU:OOB\");\r\n    }\r\n}\r\n\r\n////// lib/openzeppelin-contracts/contracts/math/SignedSafeMath.sol\r\n/* pragma solidity >=0.6.0 <0.8.0; */\r\n\r\n/**\r\n * @title SignedSafeMath\r\n * @dev Signed math operations with safety checks that revert on error.\r\n */\r\nlibrary SignedSafeMath {\r\n    int256 constant private _INT256_MIN = -2**255;\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two signed integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        require(!(a == -1 && b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\");\r\n\r\n        int256 c = a * b;\r\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two signed integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != 0, \"SignedSafeMath: division by zero\");\r\n        require(!(b == -1 && a == _INT256_MIN), \"SignedSafeMath: division overflow\");\r\n\r\n        int256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two signed integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two signed integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n////// lib/openzeppelin-contracts/contracts/GSN/Context.sol\r\n/* pragma solidity >=0.6.0 <0.8.0; */\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n////// lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\r\n/* pragma solidity >=0.6.0 <0.8.0; */\r\n\r\n/* import \"../../GSN/Context.sol\"; */\r\n/* import \"./IERC20.sol\"; */\r\n/* import \"../../math/SafeMath.sol\"; */\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\r\n     * a default value of 18.\r\n     *\r\n     * To select a different value for {decimals}, use {_setupDecimals}.\r\n     *\r\n     * All three of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor (string memory name_, string memory symbol_) public {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _decimals = 18;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\r\n     * called.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``sender``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets {decimals} to a value other than the default one of 18.\r\n     *\r\n     * WARNING: This function should only be called from the constructor. Most\r\n     * applications that interact with token contracts will not expect\r\n     * {decimals} to ever change, and may work incorrectly if it does.\r\n     */\r\n    function _setupDecimals(uint8 decimals_) internal {\r\n        _decimals = decimals_;\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be to transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r\n}\r\n\r\n////// contracts/token/BasicFDT.sol\r\n/* pragma solidity 0.6.11; */\r\n\r\n/* import \"lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\"; */\r\n/* import \"lib/openzeppelin-contracts/contracts/math/SafeMath.sol\"; */\r\n/* import \"lib/openzeppelin-contracts/contracts/math/SignedSafeMath.sol\"; */\r\n/* import \"./interfaces/IBaseFDT.sol\"; */\r\n/* import \"../math/SafeMathUint.sol\"; */\r\n/* import \"../math/SafeMathInt.sol\"; */\r\n\r\n/// @title BasicFDT implements base level FDT functionality for accounting for revenues.\r\nabstract contract BasicFDT is IBaseFDT, ERC20 {\r\n    using SafeMath       for uint256;\r\n    using SafeMathUint   for uint256;\r\n    using SignedSafeMath for  int256;\r\n    using SafeMathInt    for  int256;\r\n\r\n    uint256 internal constant pointsMultiplier = 2 ** 128;\r\n    uint256 internal pointsPerShare;\r\n\r\n    mapping(address => int256)  internal pointsCorrection;\r\n    mapping(address => uint256) internal withdrawnFunds;\r\n\r\n    event   PointsPerShareUpdated(uint256 pointsPerShare);\r\n    event PointsCorrectionUpdated(address indexed account, int256 pointsCorrection);\r\n\r\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) public { }\r\n\r\n    /**\r\n        @dev Distributes funds to token holders.\r\n        @dev It reverts if the total supply of tokens is 0.\r\n        @dev It emits a `FundsDistributed` event if the amount of received funds is greater than 0.\r\n        @dev It emits a `PointsPerShareUpdated` event if the amount of received funds is greater than 0.\r\n             About undistributed funds:\r\n                In each distribution, there is a small amount of funds which do not get distributed,\r\n                   which is `(value  pointsMultiplier) % totalSupply()`.\r\n                With a well-chosen `pointsMultiplier`, the amount funds that are not getting distributed\r\n                   in a distribution can be less than 1 (base unit).\r\n                We can actually keep track of the undistributed funds in a distribution\r\n                   and try to distribute it in the next distribution.\r\n    */\r\n    function _distributeFunds(uint256 value) internal {\r\n        require(totalSupply() > 0, \"FDT:ZERO_SUPPLY\");\r\n\r\n        if (value == 0) return;\r\n\r\n        pointsPerShare = pointsPerShare.add(value.mul(pointsMultiplier) / totalSupply());\r\n        emit FundsDistributed(msg.sender, value);\r\n        emit PointsPerShareUpdated(pointsPerShare);\r\n    }\r\n\r\n    /**\r\n        @dev    Prepares the withdrawal of funds.\r\n        @dev    It emits a `FundsWithdrawn` event if the amount of withdrawn funds is greater than 0.\r\n        @return withdrawableDividend The amount of dividend funds that can be withdrawn.\r\n    */\r\n    function _prepareWithdraw() internal returns (uint256 withdrawableDividend) {\r\n        withdrawableDividend       = withdrawableFundsOf(msg.sender);\r\n        uint256 _withdrawnFunds    = withdrawnFunds[msg.sender].add(withdrawableDividend);\r\n        withdrawnFunds[msg.sender] = _withdrawnFunds;\r\n\r\n        emit FundsWithdrawn(msg.sender, withdrawableDividend, _withdrawnFunds);\r\n    }\r\n\r\n    /**\r\n        @dev    Returns the amount of funds that an account can withdraw.\r\n        @param  _owner The address of a token holder.\r\n        @return The amount funds that `_owner` can withdraw.\r\n    */\r\n    function withdrawableFundsOf(address _owner) public view override returns (uint256) {\r\n        return accumulativeFundsOf(_owner).sub(withdrawnFunds[_owner]);\r\n    }\r\n\r\n    /**\r\n        @dev    Returns the amount of funds that an account has withdrawn.\r\n        @param  _owner The address of a token holder.\r\n        @return The amount of funds that `_owner` has withdrawn.\r\n    */\r\n    function withdrawnFundsOf(address _owner) external view returns (uint256) {\r\n        return withdrawnFunds[_owner];\r\n    }\r\n\r\n    /**\r\n        @dev    Returns the amount of funds that an account has earned in total.\r\n        @dev    accumulativeFundsOf(_owner) = withdrawableFundsOf(_owner) + withdrawnFundsOf(_owner)\r\n                                         = (pointsPerShare * balanceOf(_owner) + pointsCorrection[_owner]) / pointsMultiplier\r\n        @param  _owner The address of a token holder.\r\n        @return The amount of funds that `_owner` has earned in total.\r\n    */\r\n    function accumulativeFundsOf(address _owner) public view returns (uint256) {\r\n        return\r\n            pointsPerShare\r\n                .mul(balanceOf(_owner))\r\n                .toInt256Safe()\r\n                .add(pointsCorrection[_owner])\r\n                .toUint256Safe() / pointsMultiplier;\r\n    }\r\n\r\n    /**\r\n        @dev   Transfers tokens from one account to another. Updates pointsCorrection to keep funds unchanged.\r\n        @dev   It emits two `PointsCorrectionUpdated` events, one for the sender and one for the receiver.\r\n        @param from  The address to transfer from.\r\n        @param to    The address to transfer to.\r\n        @param value The amount to be transferred.\r\n    */\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal virtual override {\r\n        super._transfer(from, to, value);\r\n\r\n        int256 _magCorrection       = pointsPerShare.mul(value).toInt256Safe();\r\n        int256 pointsCorrectionFrom = pointsCorrection[from].add(_magCorrection);\r\n        pointsCorrection[from]      = pointsCorrectionFrom;\r\n        int256 pointsCorrectionTo   = pointsCorrection[to].sub(_magCorrection);\r\n        pointsCorrection[to]        = pointsCorrectionTo;\r\n\r\n        emit PointsCorrectionUpdated(from, pointsCorrectionFrom);\r\n        emit PointsCorrectionUpdated(to,   pointsCorrectionTo);\r\n    }\r\n\r\n    /**\r\n        @dev   Mints tokens to an account. Updates pointsCorrection to keep funds unchanged.\r\n        @param account The account that will receive the created tokens.\r\n        @param value   The amount that will be created.\r\n    */\r\n    function _mint(address account, uint256 value) internal virtual override {\r\n        super._mint(account, value);\r\n\r\n        int256 _pointsCorrection = pointsCorrection[account].sub(\r\n            (pointsPerShare.mul(value)).toInt256Safe()\r\n        );\r\n\r\n        pointsCorrection[account] = _pointsCorrection;\r\n\r\n        emit PointsCorrectionUpdated(account, _pointsCorrection);\r\n    }\r\n\r\n    /**\r\n        @dev   Burns an amount of the token of a given account. Updates pointsCorrection to keep funds unchanged.\r\n        @dev   It emits a `PointsCorrectionUpdated` event.\r\n        @param account The account whose tokens will be burnt.\r\n        @param value   The amount that will be burnt.\r\n    */\r\n    function _burn(address account, uint256 value) internal virtual override {\r\n        super._burn(account, value);\r\n\r\n        int256 _pointsCorrection = pointsCorrection[account].add(\r\n            (pointsPerShare.mul(value)).toInt256Safe()\r\n        );\r\n\r\n        pointsCorrection[account] = _pointsCorrection;\r\n\r\n        emit PointsCorrectionUpdated(account, _pointsCorrection);\r\n    }\r\n\r\n    /**\r\n        @dev Withdraws all available funds for a token holder.\r\n    */\r\n    function withdrawFunds() public virtual override {}\r\n\r\n    /**\r\n        @dev    Updates the current `fundsToken` balance and returns the difference of the new and previous `fundsToken` balance.\r\n        @return A int256 representing the difference of the new and previous `fundsToken` balance.\r\n    */\r\n    function _updateFundsTokenBalance() internal virtual returns (int256) {}\r\n\r\n    /**\r\n        @dev Registers a payment of funds in tokens. May be called directly after a deposit is made.\r\n        @dev Calls _updateFundsTokenBalance(), whereby the contract computes the delta of the new and previous\r\n             `fundsToken` balance and increments the total received funds (cumulative), by delta, by calling _distributeFunds().\r\n    */\r\n    function updateFundsReceived() public virtual {\r\n        int256 newFunds = _updateFundsTokenBalance();\r\n\r\n        if (newFunds <= 0) return;\r\n\r\n        _distributeFunds(newFunds.toUint256Safe());\r\n    }\r\n}\r\n\r\n////// contracts/token/ExtendedFDT.sol\r\n/* pragma solidity 0.6.11; */\r\n\r\n/* import \"./BasicFDT.sol\"; */\r\n\r\n/// @title ExtendedFDT implements FDT functionality for accounting for losses.\r\nabstract contract ExtendedFDT is BasicFDT {\r\n    using SafeMath       for uint256;\r\n    using SafeMathUint   for uint256;\r\n    using SignedSafeMath for  int256;\r\n    using SafeMathInt    for  int256;\r\n\r\n    uint256 internal lossesPerShare;\r\n\r\n    mapping(address => int256)  internal lossesCorrection;\r\n    mapping(address => uint256) internal recognizedLosses;\r\n\r\n    event   LossesPerShareUpdated(uint256 lossesPerShare);\r\n    event LossesCorrectionUpdated(address indexed account, int256 lossesCorrection);\r\n\r\n    /**\r\n        @dev   This event emits when new losses are distributed.\r\n        @param by                The address of the account that has distributed losses.\r\n        @param lossesDistributed The amount of losses received for distribution.\r\n    */\r\n    event LossesDistributed(address indexed by, uint256 lossesDistributed);\r\n\r\n    /**\r\n        @dev   This event emits when distributed losses are recognized by a token holder.\r\n        @param by                    The address of the receiver of losses.\r\n        @param lossesRecognized      The amount of losses that were recognized.\r\n        @param totalLossesRecognized The total amount of losses that are recognized.\r\n    */\r\n    event LossesRecognized(address indexed by, uint256 lossesRecognized, uint256 totalLossesRecognized);\r\n\r\n    constructor(string memory name, string memory symbol) BasicFDT(name, symbol) public { }\r\n\r\n    /**\r\n        @dev Distributes losses to token holders.\r\n        @dev It reverts if the total supply of tokens is 0.\r\n        @dev It emits a `LossesDistributed` event if the amount of received losses is greater than 0.\r\n        @dev It emits a `LossesPerShareUpdated` event if the amount of received losses is greater than 0.\r\n             About undistributed losses:\r\n                In each distribution, there is a small amount of losses which do not get distributed,\r\n                which is `(value * pointsMultiplier) % totalSupply()`.\r\n             With a well-chosen `pointsMultiplier`, the amount losses that are not getting distributed\r\n                in a distribution can be less than 1 (base unit).\r\n             We can actually keep track of the undistributed losses in a distribution\r\n                and try to distribute it in the next distribution.\r\n    */\r\n    function _distributeLosses(uint256 value) internal {\r\n        require(totalSupply() > 0, \"FDT:ZERO_SUPPLY\");\r\n\r\n        if (value == 0) return;\r\n\r\n        uint256 _lossesPerShare = lossesPerShare.add(value.mul(pointsMultiplier) / totalSupply());\r\n        lossesPerShare          = _lossesPerShare;\r\n\r\n        emit LossesDistributed(msg.sender, value);\r\n        emit LossesPerShareUpdated(_lossesPerShare);\r\n    }\r\n\r\n    /**\r\n        @dev    Prepares losses for a withdrawal.\r\n        @dev    It emits a `LossesWithdrawn` event if the amount of withdrawn losses is greater than 0.\r\n        @return recognizableDividend The amount of dividend losses that can be recognized.\r\n    */\r\n    function _prepareLossesWithdraw() internal returns (uint256 recognizableDividend) {\r\n        recognizableDividend = recognizableLossesOf(msg.sender);\r\n\r\n        uint256 _recognizedLosses    = recognizedLosses[msg.sender].add(recognizableDividend);\r\n        recognizedLosses[msg.sender] = _recognizedLosses;\r\n\r\n        emit LossesRecognized(msg.sender, recognizableDividend, _recognizedLosses);\r\n    }\r\n\r\n    /**\r\n        @dev    Returns the amount of losses that an address can withdraw.\r\n        @param  _owner The address of a token holder.\r\n        @return The amount of losses that `_owner` can withdraw.\r\n    */\r\n    function recognizableLossesOf(address _owner) public view returns (uint256) {\r\n        return accumulativeLossesOf(_owner).sub(recognizedLosses[_owner]);\r\n    }\r\n\r\n    /**\r\n        @dev    Returns the amount of losses that an address has recognized.\r\n        @param  _owner The address of a token holder\r\n        @return The amount of losses that `_owner` has recognized\r\n    */\r\n    function recognizedLossesOf(address _owner) external view returns (uint256) {\r\n        return recognizedLosses[_owner];\r\n    }\r\n\r\n    /**\r\n        @dev    Returns the amount of losses that an address has earned in total.\r\n        @dev    accumulativeLossesOf(_owner) = recognizableLossesOf(_owner) + recognizedLossesOf(_owner)\r\n                = (lossesPerShare * balanceOf(_owner) + lossesCorrection[_owner]) / pointsMultiplier\r\n        @param  _owner The address of a token holder\r\n        @return The amount of losses that `_owner` has earned in total\r\n    */\r\n    function accumulativeLossesOf(address _owner) public view returns (uint256) {\r\n        return\r\n            lossesPerShare\r\n                .mul(balanceOf(_owner))\r\n                .toInt256Safe()\r\n                .add(lossesCorrection[_owner])\r\n                .toUint256Safe() / pointsMultiplier;\r\n    }\r\n\r\n    /**\r\n        @dev   Transfers tokens from one account to another. Updates pointsCorrection to keep funds unchanged.\r\n        @dev         It emits two `LossesCorrectionUpdated` events, one for the sender and one for the receiver.\r\n        @param from  The address to transfer from.\r\n        @param to    The address to transfer to.\r\n        @param value The amount to be transferred.\r\n    */\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal virtual override {\r\n        super._transfer(from, to, value);\r\n\r\n        int256 _lossesCorrection    = lossesPerShare.mul(value).toInt256Safe();\r\n        int256 lossesCorrectionFrom = lossesCorrection[from].add(_lossesCorrection);\r\n        lossesCorrection[from]      = lossesCorrectionFrom;\r\n        int256 lossesCorrectionTo   = lossesCorrection[to].sub(_lossesCorrection);\r\n        lossesCorrection[to]        = lossesCorrectionTo;\r\n\r\n        emit LossesCorrectionUpdated(from, lossesCorrectionFrom);\r\n        emit LossesCorrectionUpdated(to,   lossesCorrectionTo);\r\n    }\r\n\r\n    /**\r\n        @dev   Mints tokens to an account. Updates lossesCorrection to keep losses unchanged.\r\n        @dev   It emits a `LossesCorrectionUpdated` event.\r\n        @param account The account that will receive the created tokens.\r\n        @param value   The amount that will be created.\r\n    */\r\n    function _mint(address account, uint256 value) internal virtual override {\r\n        super._mint(account, value);\r\n\r\n        int256 _lossesCorrection = lossesCorrection[account].sub(\r\n            (lossesPerShare.mul(value)).toInt256Safe()\r\n        );\r\n\r\n        lossesCorrection[account] = _lossesCorrection;\r\n\r\n        emit LossesCorrectionUpdated(account, _lossesCorrection);\r\n    }\r\n\r\n    /**\r\n        @dev   Burns an amount of the token of a given account. Updates lossesCorrection to keep losses unchanged.\r\n        @dev   It emits a `LossesCorrectionUpdated` event.\r\n        @param account The account from which tokens will be burnt.\r\n        @param value   The amount that will be burnt.\r\n    */\r\n    function _burn(address account, uint256 value) internal virtual override {\r\n        super._burn(account, value);\r\n\r\n        int256 _lossesCorrection = lossesCorrection[account].add(\r\n            (lossesPerShare.mul(value)).toInt256Safe()\r\n        );\r\n\r\n        lossesCorrection[account] = _lossesCorrection;\r\n\r\n        emit LossesCorrectionUpdated(account, _lossesCorrection);\r\n    }\r\n\r\n    /**\r\n        @dev Registers a loss. May be called directly after a shortfall after BPT burning occurs.\r\n        @dev Calls _updateLossesTokenBalance(), whereby the contract computes the delta of the new and previous\r\n             losses balance and increments the total losses (cumulative), by delta, by calling _distributeLosses().\r\n    */\r\n    function updateLossesReceived() public virtual {\r\n        int256 newLosses = _updateLossesBalance();\r\n\r\n        if (newLosses <= 0) return;\r\n\r\n        _distributeLosses(newLosses.toUint256Safe());\r\n    }\r\n\r\n    /**\r\n        @dev Recognizes all recognizable losses for an account using loss accounting.\r\n    */\r\n    function _recognizeLosses() internal virtual returns (uint256 losses) { }\r\n\r\n    /**\r\n        @dev    Updates the current losses balance and returns the difference of the new and previous losses balance.\r\n        @return A int256 representing the difference of the new and previous losses balance.\r\n    */\r\n    function _updateLossesBalance() internal virtual returns (int256) { }\r\n}\r\n\r\n////// contracts/token/PoolFDT.sol\r\n/* pragma solidity 0.6.11; */\r\n\r\n/* import \"./ExtendedFDT.sol\"; */\r\n\r\n/// @title PoolFDT inherits ExtendedFDT and accounts for gains/losses for Liquidity Providers.\r\nabstract contract PoolFDT is ExtendedFDT {\r\n    using SafeMath       for uint256;\r\n    using SafeMathUint   for uint256;\r\n    using SignedSafeMath for  int256;\r\n    using SafeMathInt    for  int256;\r\n\r\n    uint256 public interestSum;  // Sum of all withdrawable interest.\r\n    uint256 public poolLosses;   // Sum of all unrecognized losses.\r\n\r\n    uint256 public interestBalance;  // The amount of earned interest present and accounted for in this contract.\r\n    uint256 public lossesBalance;    // The amount of losses present and accounted for in this contract.\r\n\r\n    constructor(string memory name, string memory symbol) ExtendedFDT(name, symbol) public { }\r\n\r\n    /**\r\n        @dev Realizes losses incurred to LPs.\r\n    */\r\n    function _recognizeLosses() internal override returns (uint256 losses) {\r\n        losses = _prepareLossesWithdraw();\r\n\r\n        poolLosses = poolLosses.sub(losses);\r\n\r\n        _updateLossesBalance();\r\n    }\r\n\r\n    /**\r\n        @dev    Updates the current losses balance and returns the difference of the new and previous losses balance.\r\n        @return A int256 representing the difference of the new and previous losses balance.\r\n    */\r\n    function _updateLossesBalance() internal override returns (int256) {\r\n        uint256 _prevLossesTokenBalance = lossesBalance;\r\n\r\n        lossesBalance = poolLosses;\r\n\r\n        return int256(lossesBalance).sub(int256(_prevLossesTokenBalance));\r\n    }\r\n\r\n    /**\r\n        @dev    Updates the current interest balance and returns the difference of the new and previous interest balance.\r\n        @return A int256 representing the difference of the new and previous interest balance.\r\n    */\r\n    function _updateFundsTokenBalance() internal override returns (int256) {\r\n        uint256 _prevFundsTokenBalance = interestBalance;\r\n\r\n        interestBalance = interestSum;\r\n\r\n        return int256(interestBalance).sub(int256(_prevFundsTokenBalance));\r\n    }\r\n}\r\n\r\n////// contracts/Pool.sol\r\n/* pragma solidity 0.6.11; */\r\n\r\n/* import \"lib/openzeppelin-contracts/contracts/token/ERC20/SafeERC20.sol\"; */\r\n\r\n/* import \"./interfaces/IBPool.sol\"; */\r\n/* import \"./interfaces/IDebtLocker.sol\"; */\r\n/* import \"./interfaces/IMapleGlobals.sol\"; */\r\n/* import \"./interfaces/ILiquidityLocker.sol\"; */\r\n/* import \"./interfaces/ILiquidityLockerFactory.sol\"; */\r\n/* import \"./interfaces/ILoan.sol\"; */\r\n/* import \"./interfaces/ILoanFactory.sol\"; */\r\n/* import \"./interfaces/IPoolFactory.sol\"; */\r\n/* import \"./interfaces/IStakeLocker.sol\"; */\r\n/* import \"./interfaces/IStakeLockerFactory.sol\"; */\r\n\r\n/* import \"./library/PoolLib.sol\"; */\r\n\r\n/* import \"./token/PoolFDT.sol\"; */\r\n\r\n/// @title Pool maintains all accounting and functionality related to Pools.\r\ncontract Pool is PoolFDT {\r\n\r\n    using SafeMath  for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    uint256 constant WAD = 10 ** 18;\r\n\r\n    uint8 public constant DL_FACTORY = 1;  // Factory type of `DebtLockerFactory`.\r\n\r\n    IERC20  public immutable liquidityAsset;  // The asset deposited by Lenders into the LiquidityLocker, for funding Loans.\r\n\r\n    address public immutable poolDelegate;     // The Pool Delegate address, maintains full authority over the Pool.\r\n    address public immutable liquidityLocker;  // The LiquidityLocker owned by this contract\r\n    address public immutable stakeAsset;       // The address of the asset deposited by Stakers into the StakeLocker (BPTs), for liquidation during default events.\r\n    address public immutable stakeLocker;      // The address of the StakeLocker, escrowing `stakeAsset`.\r\n    address public immutable superFactory;     // The factory that deployed this Loan.\r\n\r\n    uint256 private immutable liquidityAssetDecimals;  // The precision for the Liquidity Asset (i.e. `decimals()`).\r\n\r\n    uint256 public           stakingFee;   // The fee Stakers earn            (in basis points).\r\n    uint256 public immutable delegateFee;  // The fee the Pool Delegate earns (in basis points).\r\n\r\n    uint256 public principalOut;  // The sum of all outstanding principal on Loans.\r\n    uint256 public liquidityCap;  // The amount of liquidity tokens accepted by the Pool.\r\n    uint256 public lockupPeriod;  // The period of time from an account's deposit date during which they cannot withdraw any funds.\r\n\r\n    bool public openToPublic;  // Boolean opening Pool to public for LP deposits\r\n\r\n    enum State { Initialized, Finalized, Deactivated }\r\n    State public poolState;\r\n\r\n    mapping(address => uint256)                     public depositDate;                // Used for withdraw penalty calculation.\r\n    mapping(address => mapping(address => address)) public debtLockers;                // Address of the DebtLocker corresponding to `[Loan][DebtLockerFactory]`.\r\n    mapping(address => bool)                        public poolAdmins;                 // The Pool Admin addresses that have permission to do certain operations in case of disaster management.\r\n    mapping(address => bool)                        public allowedLiquidityProviders;  // Mapping that contains the list of addresses that have early access to the pool.\r\n    mapping(address => uint256)                     public withdrawCooldown;           // The timestamp of when individual LPs have notified of their intent to withdraw.\r\n    mapping(address => mapping(address => uint256)) public custodyAllowance;           // The amount of PoolFDTs that are \"locked\" at a certain address.\r\n    mapping(address => uint256)                     public totalCustodyAllowance;      // The total amount of PoolFDTs that are \"locked\" for a given account. Cannot be greater than an account's balance.\r\n\r\n    event                   LoanFunded(address indexed loan, address debtLocker, uint256 amountFunded);\r\n    event                        Claim(address indexed loan, uint256 interest, uint256 principal, uint256 fee, uint256 stakeLockerPortion, uint256 poolDelegatePortion);\r\n    event               BalanceUpdated(address indexed liquidityProvider, address indexed token, uint256 balance);\r\n    event              CustodyTransfer(address indexed custodian, address indexed from, address indexed to, uint256 amount);\r\n    event      CustodyAllowanceChanged(address indexed liquidityProvider, address indexed custodian, uint256 oldAllowance, uint256 newAllowance);\r\n    event              LPStatusChanged(address indexed liquidityProvider, bool status);\r\n    event              LiquidityCapSet(uint256 newLiquidityCap);\r\n    event              LockupPeriodSet(uint256 newLockupPeriod);\r\n    event                StakingFeeSet(uint256 newStakingFee);\r\n    event             PoolStateChanged(State state);\r\n    event                     Cooldown(address indexed liquidityProvider, uint256 cooldown);\r\n    event           PoolOpenedToPublic(bool isOpen);\r\n    event                 PoolAdminSet(address indexed poolAdmin, bool allowed);\r\n    event           DepositDateUpdated(address indexed liquidityProvider, uint256 depositDate);\r\n    event TotalCustodyAllowanceUpdated(address indexed liquidityProvider, uint256 newTotalAllowance);\r\n    \r\n    event DefaultSuffered(\r\n        address indexed loan,\r\n        uint256 defaultSuffered,\r\n        uint256 bptsBurned,\r\n        uint256 bptsReturned,\r\n        uint256 liquidityAssetRecoveredFromBurn\r\n    );\r\n\r\n    /**\r\n        Universal accounting law:\r\n                                       fdtTotalSupply = liquidityLockerBal + principalOut - interestSum + poolLosses\r\n            fdtTotalSupply + interestSum - poolLosses = liquidityLockerBal + principalOut\r\n    */\r\n\r\n    /**\r\n        @dev   Constructor for a Pool.\r\n        @dev   It emits a `PoolStateChanged` event.\r\n        @param _poolDelegate   Address that has manager privileges of the Pool.\r\n        @param _liquidityAsset Asset used to fund the Pool, It gets escrowed in LiquidityLocker.\r\n        @param _stakeAsset     Asset escrowed in StakeLocker.\r\n        @param _slFactory      Factory used to instantiate the StakeLocker.\r\n        @param _llFactory      Factory used to instantiate the LiquidityLocker.\r\n        @param _stakingFee     Fee that Stakers earn on interest, in basis points.\r\n        @param _delegateFee    Fee that the Pool Delegate earns on interest, in basis points.\r\n        @param _liquidityCap   Max amount of Liquidity Asset accepted by the Pool.\r\n        @param name            Name of Pool token.\r\n        @param symbol          Symbol of Pool token.\r\n    */\r\n    constructor(\r\n        address _poolDelegate,\r\n        address _liquidityAsset,\r\n        address _stakeAsset,\r\n        address _slFactory,\r\n        address _llFactory,\r\n        uint256 _stakingFee,\r\n        uint256 _delegateFee,\r\n        uint256 _liquidityCap,\r\n        string memory name,\r\n        string memory symbol\r\n    ) PoolFDT(name, symbol) public {\r\n\r\n        // Conduct sanity checks on Pool parameters.\r\n        PoolLib.poolSanityChecks(_globals(msg.sender), _liquidityAsset, _stakeAsset, _stakingFee, _delegateFee);\r\n\r\n        // Assign variables relating to the Liquidity Asset.\r\n        liquidityAsset         = IERC20(_liquidityAsset);\r\n        liquidityAssetDecimals = ERC20(_liquidityAsset).decimals();\r\n\r\n        // Assign state variables.\r\n        stakeAsset   = _stakeAsset;\r\n        poolDelegate = _poolDelegate;\r\n        stakingFee   = _stakingFee;\r\n        delegateFee  = _delegateFee;\r\n        superFactory = msg.sender;\r\n        liquidityCap = _liquidityCap;\r\n\r\n        // Instantiate the LiquidityLocker and the StakeLocker.\r\n        stakeLocker     = address(IStakeLockerFactory(_slFactory).newLocker(_stakeAsset, _liquidityAsset));\r\n        liquidityLocker = address(ILiquidityLockerFactory(_llFactory).newLocker(_liquidityAsset));\r\n\r\n        lockupPeriod = 180 days;\r\n\r\n        emit PoolStateChanged(State.Initialized);\r\n    }\r\n\r\n    /*******************************/\r\n    /*** Pool Delegate Functions ***/\r\n    /*******************************/\r\n\r\n    /**\r\n        @dev Finalizes the Pool, enabling deposits. Checks the amount the Pool Delegate deposited to the StakeLocker.\r\n             Only the Pool Delegate can call this function.\r\n        @dev It emits a `PoolStateChanged` event.\r\n    */\r\n    function finalize() external {\r\n        _isValidDelegateAndProtocolNotPaused();\r\n        _isValidState(State.Initialized);\r\n        (,, bool stakeSufficient,,) = getInitialStakeRequirements();\r\n        require(stakeSufficient, \"P:INSUF_STAKE\");\r\n        poolState = State.Finalized;\r\n        emit PoolStateChanged(poolState);\r\n    }\r\n\r\n    /**\r\n        @dev   Funds a Loan for an amount, utilizing the supplied DebtLockerFactory for DebtLockers.\r\n               Only the Pool Delegate can call this function.\r\n        @dev   It emits a `LoanFunded` event.\r\n        @dev   It emits a `BalanceUpdated` event.\r\n        @param loan      Address of the Loan to fund.\r\n        @param dlFactory Address of the DebtLockerFactory to utilize.\r\n        @param amt       Amount to fund the Loan.\r\n    */\r\n    function fundLoan(address loan, address dlFactory, uint256 amt) external {\r\n        _isValidDelegateAndProtocolNotPaused();\r\n        _isValidState(State.Finalized);\r\n        principalOut = principalOut.add(amt);\r\n        PoolLib.fundLoan(debtLockers, superFactory, liquidityLocker, loan, dlFactory, amt);\r\n        _emitBalanceUpdatedEvent();\r\n    }\r\n\r\n    /**\r\n        @dev   Liquidates a Loan. The Pool Delegate could liquidate the Loan only when the Loan completes its grace period.\r\n               The Pool Delegate can claim its proportion of recovered funds from the liquidation using the `claim()` function.\r\n               Only the Pool Delegate can call this function.\r\n        @param loan      Address of the Loan to liquidate.\r\n        @param dlFactory Address of the DebtLockerFactory that is used to pull corresponding DebtLocker.\r\n    */\r\n    function triggerDefault(address loan, address dlFactory) external {\r\n        _isValidDelegateAndProtocolNotPaused();\r\n        IDebtLocker(debtLockers[loan][dlFactory]).triggerDefault();\r\n    }\r\n\r\n    /**\r\n        @dev    Claims available funds for the Loan through a specified DebtLockerFactory. Only the Pool Delegate or a Pool Admin can call this function.\r\n        @dev    It emits two `BalanceUpdated` events.\r\n        @dev    It emits a `Claim` event.\r\n        @param  loan      Address of the loan to claim from.\r\n        @param  dlFactory Address of the DebtLockerFactory.\r\n        @return claimInfo The claim details.\r\n                    claimInfo [0] = Total amount claimed\r\n                    claimInfo [1] = Interest  portion claimed\r\n                    claimInfo [2] = Principal portion claimed\r\n                    claimInfo [3] = Fee       portion claimed\r\n                    claimInfo [4] = Excess    portion claimed\r\n                    claimInfo [5] = Recovered portion claimed (from liquidations)\r\n                    claimInfo [6] = Default suffered\r\n    */\r\n    function claim(address loan, address dlFactory) external returns (uint256[7] memory claimInfo) {\r\n        _whenProtocolNotPaused();\r\n        _isValidDelegateOrPoolAdmin();\r\n        claimInfo = IDebtLocker(debtLockers[loan][dlFactory]).claim();\r\n\r\n        (uint256 poolDelegatePortion, uint256 stakeLockerPortion, uint256 principalClaim, uint256 interestClaim) = PoolLib.calculateClaimAndPortions(claimInfo, delegateFee, stakingFee);\r\n\r\n        // Subtract outstanding principal by the principal claimed plus excess returned.\r\n        // Considers possible `principalClaim` overflow if Liquidity Asset is transferred directly into the Loan.\r\n        if (principalClaim <= principalOut) {\r\n            principalOut = principalOut - principalClaim;\r\n        } else {\r\n            interestClaim  = interestClaim.add(principalClaim - principalOut);  // Distribute `principalClaim` overflow as interest to LPs.\r\n            principalClaim = principalOut;                                      // Set `principalClaim` to `principalOut` so correct amount gets transferred.\r\n            principalOut   = 0;                                                 // Set `principalOut` to zero to avoid subtraction overflow.\r\n        }\r\n\r\n        // Accounts for rounding error in StakeLocker / Pool Delegate / LiquidityLocker interest split.\r\n        interestSum = interestSum.add(interestClaim);\r\n\r\n        _transferLiquidityAsset(poolDelegate, poolDelegatePortion);  // Transfer the fee and portion of interest to the Pool Delegate.\r\n        _transferLiquidityAsset(stakeLocker,  stakeLockerPortion);   // Transfer the portion of interest to the StakeLocker.\r\n\r\n        // Transfer remaining claim (remaining interest + principal + excess + recovered) to the LiquidityLocker.\r\n        // Dust will accrue in the Pool, but this ensures that state variables are in sync with the LiquidityLocker balance updates.\r\n        // Not using `balanceOf` in case of external address transferring the Liquidity Asset directly into Pool.\r\n        // Ensures that internal accounting is exactly reflective of balance change.\r\n        _transferLiquidityAsset(liquidityLocker, principalClaim.add(interestClaim));\r\n\r\n        // Handle default if defaultSuffered > 0.\r\n        if (claimInfo[6] > 0) _handleDefault(loan, claimInfo[6]);\r\n\r\n        // Update funds received for StakeLockerFDTs.\r\n        IStakeLocker(stakeLocker).updateFundsReceived();\r\n\r\n        // Update funds received for PoolFDTs.\r\n        updateFundsReceived();\r\n\r\n        _emitBalanceUpdatedEvent();\r\n        emit BalanceUpdated(stakeLocker, address(liquidityAsset), liquidityAsset.balanceOf(stakeLocker));\r\n\r\n        emit Claim(loan, interestClaim, principalClaim, claimInfo[3], stakeLockerPortion, poolDelegatePortion);\r\n    }\r\n\r\n    /**\r\n        @dev   Handles if a claim has been made and there is a non-zero defaultSuffered amount.\r\n        @dev   It emits a `DefaultSuffered` event.\r\n        @param loan            Address of a Loan that has defaulted.\r\n        @param defaultSuffered Losses suffered from default after liquidation.\r\n    */\r\n    function _handleDefault(address loan, uint256 defaultSuffered) internal {\r\n\r\n        (uint256 bptsBurned, uint256 postBurnBptBal, uint256 liquidityAssetRecoveredFromBurn) = PoolLib.handleDefault(liquidityAsset, stakeLocker, stakeAsset, defaultSuffered);\r\n\r\n        // If BPT burn is not enough to cover full default amount, pass on losses to LPs with PoolFDT loss accounting.\r\n        if (defaultSuffered > liquidityAssetRecoveredFromBurn) {\r\n            poolLosses = poolLosses.add(defaultSuffered - liquidityAssetRecoveredFromBurn);\r\n            updateLossesReceived();\r\n        }\r\n\r\n        // Transfer Liquidity Asset from burn to LiquidityLocker.\r\n        liquidityAsset.safeTransfer(liquidityLocker, liquidityAssetRecoveredFromBurn);\r\n\r\n        principalOut = principalOut.sub(defaultSuffered);  // Subtract rest of the Loan's principal from `principalOut`.\r\n\r\n        emit DefaultSuffered(\r\n            loan,                            // The Loan that suffered the default.\r\n            defaultSuffered,                 // Total default suffered from the Loan by the Pool after liquidation.\r\n            bptsBurned,                      // Amount of BPTs burned from StakeLocker.\r\n            postBurnBptBal,                  // Remaining BPTs in StakeLocker post-burn.\r\n            liquidityAssetRecoveredFromBurn  // Amount of Liquidity Asset recovered from burning BPTs.\r\n        );\r\n    }\r\n\r\n    /**\r\n        @dev Triggers deactivation, permanently shutting down the Pool. Must have less than 100 USD worth of Liquidity Asset `principalOut`.\r\n             Only the Pool Delegate can call this function.\r\n        @dev It emits a `PoolStateChanged` event.\r\n    */\r\n    function deactivate() external {\r\n        _isValidDelegateAndProtocolNotPaused();\r\n        _isValidState(State.Finalized);\r\n        PoolLib.validateDeactivation(_globals(superFactory), principalOut, address(liquidityAsset));\r\n        poolState = State.Deactivated;\r\n        emit PoolStateChanged(poolState);\r\n    }\r\n\r\n    /**************************************/\r\n    /*** Pool Delegate Setter Functions ***/\r\n    /**************************************/\r\n\r\n    /**\r\n        @dev   Sets the liquidity cap. Only the Pool Delegate or a Pool Admin can call this function.\r\n        @dev   It emits a `LiquidityCapSet` event.\r\n        @param newLiquidityCap New liquidity cap value.\r\n    */\r\n    function setLiquidityCap(uint256 newLiquidityCap) external {\r\n        _whenProtocolNotPaused();\r\n        _isValidDelegateOrPoolAdmin();\r\n        liquidityCap = newLiquidityCap;\r\n        emit LiquidityCapSet(newLiquidityCap);\r\n    }\r\n\r\n    /**\r\n        @dev   Sets the lockup period. Only the Pool Delegate can call this function.\r\n        @dev   It emits a `LockupPeriodSet` event.\r\n        @param newLockupPeriod New lockup period used to restrict the withdrawals.\r\n    */\r\n    function setLockupPeriod(uint256 newLockupPeriod) external {\r\n        _isValidDelegateAndProtocolNotPaused();\r\n        require(newLockupPeriod <= lockupPeriod, \"P:BAD_VALUE\");\r\n        lockupPeriod = newLockupPeriod;\r\n        emit LockupPeriodSet(newLockupPeriod);\r\n    }\r\n\r\n    /**\r\n        @dev   Sets the staking fee. Only the Pool Delegate can call this function.\r\n        @dev   It emits a `StakingFeeSet` event.\r\n        @param newStakingFee New staking fee.\r\n    */\r\n    function setStakingFee(uint256 newStakingFee) external {\r\n        _isValidDelegateAndProtocolNotPaused();\r\n        require(newStakingFee.add(delegateFee) <= 10_000, \"P:BAD_FEE\");\r\n        stakingFee = newStakingFee;\r\n        emit StakingFeeSet(newStakingFee);\r\n    }\r\n\r\n    /**\r\n        @dev   Sets the account status in the Pool's allowlist. Only the Pool Delegate can call this function.\r\n        @dev   It emits an `LPStatusChanged` event.\r\n        @param account The address to set status for.\r\n        @param status  The status of an account in the allowlist.\r\n    */\r\n    function setAllowList(address account, bool status) external {\r\n        _isValidDelegateAndProtocolNotPaused();\r\n        allowedLiquidityProviders[account] = status;\r\n        emit LPStatusChanged(account, status);\r\n    }\r\n\r\n    /**\r\n        @dev   Sets a Pool Admin. Only the Pool Delegate can call this function.\r\n        @dev   It emits a `PoolAdminSet` event.\r\n        @param poolAdmin An address being allowed or disallowed as a Pool Admin.\r\n        @param allowed Status of a Pool Admin.\r\n    */\r\n    function setPoolAdmin(address poolAdmin, bool allowed) external {\r\n        _isValidDelegateAndProtocolNotPaused();\r\n        poolAdmins[poolAdmin] = allowed;\r\n        emit PoolAdminSet(poolAdmin, allowed);\r\n    }\r\n\r\n    /**\r\n        @dev   Sets whether the Pool is open to the public. Only the Pool Delegate can call this function.\r\n        @dev   It emits a `PoolOpenedToPublic` event.\r\n        @param open Public pool access status.\r\n    */\r\n    function setOpenToPublic(bool open) external {\r\n        _isValidDelegateAndProtocolNotPaused();\r\n        openToPublic = open;\r\n        emit PoolOpenedToPublic(open);\r\n    }\r\n\r\n    /************************************/\r\n    /*** Liquidity Provider Functions ***/\r\n    /************************************/\r\n\r\n    /**\r\n        @dev   Handles Liquidity Providers depositing of Liquidity Asset into the LiquidityLocker, minting PoolFDTs.\r\n        @dev   It emits a `DepositDateUpdated` event.\r\n        @dev   It emits a `BalanceUpdated` event.\r\n        @dev   It emits a `Cooldown` event.\r\n        @param amt Amount of Liquidity Asset to deposit.\r\n    */\r\n    function deposit(uint256 amt) external {\r\n        _whenProtocolNotPaused();\r\n        _isValidState(State.Finalized);\r\n        require(isDepositAllowed(amt), \"P:DEP_NOT_ALLOWED\");\r\n\r\n        withdrawCooldown[msg.sender] = uint256(0);  // Reset the LP's withdraw cooldown if they had previously intended to withdraw.\r\n\r\n        uint256 wad = _toWad(amt);\r\n        PoolLib.updateDepositDate(depositDate, balanceOf(msg.sender), wad, msg.sender);\r\n\r\n        liquidityAsset.safeTransferFrom(msg.sender, liquidityLocker, amt);\r\n        _mint(msg.sender, wad);\r\n\r\n        _emitBalanceUpdatedEvent();\r\n        emit Cooldown(msg.sender, uint256(0));\r\n    }\r\n\r\n    /**\r\n        @dev Activates the cooldown period to withdraw. It can't be called if the account is not providing liquidity.\r\n        @dev It emits a `Cooldown` event.\r\n    **/\r\n    function intendToWithdraw() external {\r\n        require(balanceOf(msg.sender) != uint256(0), \"P:ZERO_BAL\");\r\n        withdrawCooldown[msg.sender] = block.timestamp;\r\n        emit Cooldown(msg.sender, block.timestamp);\r\n    }\r\n\r\n    /**\r\n        @dev Cancels an initiated withdrawal by resetting the account's withdraw cooldown.\r\n        @dev It emits a `Cooldown` event.\r\n    **/\r\n    function cancelWithdraw() external {\r\n        require(withdrawCooldown[msg.sender] != uint256(0), \"P:NOT_WITHDRAWING\");\r\n        withdrawCooldown[msg.sender] = uint256(0);\r\n        emit Cooldown(msg.sender, uint256(0));\r\n    }\r\n\r\n    /**\r\n        @dev   Checks that the account can withdraw an amount.\r\n        @param account The address of the account.\r\n        @param wad     The amount to withdraw.\r\n    */\r\n    function _canWithdraw(address account, uint256 wad) internal view {\r\n        require(depositDate[account].add(lockupPeriod) <= block.timestamp,     \"P:FUNDS_LOCKED\");     // Restrict withdrawal during lockup period\r\n        require(balanceOf(account).sub(wad) >= totalCustodyAllowance[account], \"P:INSUF_TRANS_BAL\");  // Account can only withdraw tokens that aren't custodied\r\n    }\r\n\r\n    /**\r\n        @dev   Handles Liquidity Providers withdrawing of Liquidity Asset from the LiquidityLocker, burning PoolFDTs.\r\n        @dev   It emits two `BalanceUpdated` event.\r\n        @param amt Amount of Liquidity Asset to withdraw.\r\n    */\r\n    function withdraw(uint256 amt) external {\r\n        _whenProtocolNotPaused();\r\n        uint256 wad = _toWad(amt);\r\n        (uint256 lpCooldownPeriod, uint256 lpWithdrawWindow) = _globals(superFactory).getLpCooldownParams();\r\n\r\n        _canWithdraw(msg.sender, wad);\r\n        require((block.timestamp - (withdrawCooldown[msg.sender] + lpCooldownPeriod)) <= lpWithdrawWindow, \"P:WITHDRAW_NOT_ALLOWED\");\r\n\r\n        _burn(msg.sender, wad);  // Burn the corresponding PoolFDTs balance.\r\n        withdrawFunds();         // Transfer full entitled interest, decrement `interestSum`.\r\n\r\n        // Transfer amount that is due after realized losses are accounted for.\r\n        // Recognized losses are absorbed by the LP.\r\n        _transferLiquidityLockerFunds(msg.sender, amt.sub(_recognizeLosses()));\r\n\r\n        _emitBalanceUpdatedEvent();\r\n    }\r\n\r\n    /**\r\n        @dev   Transfers PoolFDTs.\r\n        @param from Address sending   PoolFDTs.\r\n        @param to   Address receiving PoolFDTs.\r\n        @param wad  Amount of PoolFDTs to transfer.\r\n    */\r\n    function _transfer(address from, address to, uint256 wad) internal override {\r\n        _whenProtocolNotPaused();\r\n\r\n        (uint256 lpCooldownPeriod, uint256 lpWithdrawWindow) = _globals(superFactory).getLpCooldownParams();\r\n\r\n        _canWithdraw(from, wad);\r\n        require(block.timestamp > (withdrawCooldown[to] + lpCooldownPeriod + lpWithdrawWindow), \"P:TO_NOT_ALLOWED\");  // Recipient must not be currently withdrawing.\r\n        require(recognizableLossesOf(from) == uint256(0),                                       \"P:RECOG_LOSSES\");    // If an LP has unrecognized losses, they must recognize losses using `withdraw`.\r\n\r\n        PoolLib.updateDepositDate(depositDate, balanceOf(to), wad, to);\r\n        super._transfer(from, to, wad);\r\n    }\r\n\r\n    /**\r\n        @dev Withdraws all claimable interest from the LiquidityLocker for an account using `interestSum` accounting.\r\n        @dev It emits a `BalanceUpdated` event.\r\n    */\r\n    function withdrawFunds() public override {\r\n        _whenProtocolNotPaused();\r\n        uint256 withdrawableFunds = _prepareWithdraw();\r\n\r\n        if (withdrawableFunds == uint256(0)) return;\r\n\r\n        _transferLiquidityLockerFunds(msg.sender, withdrawableFunds);\r\n        _emitBalanceUpdatedEvent();\r\n\r\n        interestSum = interestSum.sub(withdrawableFunds);\r\n\r\n        _updateFundsTokenBalance();\r\n    }\r\n\r\n    /**\r\n        @dev   Increases the custody allowance for a given Custodian corresponding to the calling account (`msg.sender`).\r\n        @dev   It emits a `CustodyAllowanceChanged` event.\r\n        @dev   It emits a `TotalCustodyAllowanceUpdated` event.\r\n        @param custodian Address which will act as Custodian of a given amount for an account.\r\n        @param amount    Number of additional FDTs to be custodied by the Custodian.\r\n    */\r\n    function increaseCustodyAllowance(address custodian, uint256 amount) external {\r\n        uint256 oldAllowance      = custodyAllowance[msg.sender][custodian];\r\n        uint256 newAllowance      = oldAllowance.add(amount);\r\n        uint256 newTotalAllowance = totalCustodyAllowance[msg.sender].add(amount);\r\n\r\n        PoolLib.increaseCustodyAllowanceChecks(custodian, amount, newTotalAllowance, balanceOf(msg.sender));\r\n\r\n        custodyAllowance[msg.sender][custodian] = newAllowance;\r\n        totalCustodyAllowance[msg.sender]       = newTotalAllowance;\r\n        emit CustodyAllowanceChanged(msg.sender, custodian, oldAllowance, newAllowance);\r\n        emit TotalCustodyAllowanceUpdated(msg.sender, newTotalAllowance);\r\n    }\r\n\r\n    /**\r\n        @dev   Transfers custodied PoolFDTs back to the account.\r\n        @dev   `from` and `to` should always be equal in this implementation.\r\n        @dev   This means that the Custodian can only decrease their own allowance and unlock funds for the original owner.\r\n        @dev   It emits a `CustodyTransfer` event.\r\n        @dev   It emits a `CustodyAllowanceChanged` event.\r\n        @dev   It emits a `TotalCustodyAllowanceUpdated` event.\r\n        @param from   Address which holds the PoolFDTs.\r\n        @param to     Address which will be the new owner of the amount of PoolFDTs.\r\n        @param amount Amount of PoolFDTs transferred.\r\n    */\r\n    function transferByCustodian(address from, address to, uint256 amount) external {\r\n        uint256 oldAllowance = custodyAllowance[from][msg.sender];\r\n        uint256 newAllowance = oldAllowance.sub(amount);\r\n\r\n        PoolLib.transferByCustodianChecks(from, to, amount);\r\n\r\n        custodyAllowance[from][msg.sender] = newAllowance;\r\n        uint256 newTotalAllowance          = totalCustodyAllowance[from].sub(amount);\r\n        totalCustodyAllowance[from]        = newTotalAllowance;\r\n        emit CustodyTransfer(msg.sender, from, to, amount);\r\n        emit CustodyAllowanceChanged(from, msg.sender, oldAllowance, newAllowance);\r\n        emit TotalCustodyAllowanceUpdated(msg.sender, newTotalAllowance);\r\n    }\r\n\r\n    /**************************/\r\n    /*** Governor Functions ***/\r\n    /**************************/\r\n\r\n    /**\r\n        @dev   Transfers any locked funds to the Governor. Only the Governor can call this function.\r\n        @param token Address of the token to be reclaimed.\r\n    */\r\n    function reclaimERC20(address token) external {\r\n        PoolLib.reclaimERC20(token, address(liquidityAsset), _globals(superFactory));\r\n    }\r\n\r\n    /*************************/\r\n    /*** Getter Functions ***/\r\n    /*************************/\r\n\r\n    /**\r\n        @dev    Calculates the value of BPT in units of Liquidity Asset.\r\n        @param  _bPool          Address of Balancer pool.\r\n        @param  _liquidityAsset Asset used by Pool for liquidity to fund Loans.\r\n        @param  _staker         Address that deposited BPTs to StakeLocker.\r\n        @param  _stakeLocker    Escrows BPTs deposited by Staker.\r\n        @return USDC value of staker BPTs.\r\n    */\r\n    function BPTVal(\r\n        address _bPool,\r\n        address _liquidityAsset,\r\n        address _staker,\r\n        address _stakeLocker\r\n    ) external view returns (uint256) {\r\n        return PoolLib.BPTVal(_bPool, _liquidityAsset, _staker, _stakeLocker);\r\n    }\r\n\r\n    /**\r\n        @dev   Checks that the given deposit amount is acceptable based on current liquidityCap.\r\n        @param depositAmt Amount of tokens (i.e liquidityAsset type) the account is trying to deposit.\r\n    */\r\n    function isDepositAllowed(uint256 depositAmt) public view returns (bool) {\r\n        return (openToPublic || allowedLiquidityProviders[msg.sender]) &&\r\n               _balanceOfLiquidityLocker().add(principalOut).add(depositAmt) <= liquidityCap;\r\n    }\r\n\r\n    /**\r\n        @dev    Returns information on the stake requirements.\r\n        @return [0] = Min amount of Liquidity Asset coverage from staking required.\r\n                [1] = Present amount of Liquidity Asset coverage from the Pool Delegate stake.\r\n                [2] = If enough stake is present from the Pool Delegate for finalization.\r\n                [3] = Staked BPTs required for minimum Liquidity Asset coverage.\r\n                [4] = Current staked BPTs.\r\n    */\r\n    function getInitialStakeRequirements() public view returns (uint256, uint256, bool, uint256, uint256) {\r\n        return PoolLib.getInitialStakeRequirements(_globals(superFactory), stakeAsset, address(liquidityAsset), poolDelegate, stakeLocker);\r\n    }\r\n\r\n    /**\r\n        @dev    Calculates BPTs required if burning BPTs for the Liquidity Asset, given supplied `tokenAmountOutRequired`.\r\n        @param  _bPool                        The Balancer pool that issues the BPTs.\r\n        @param  _liquidityAsset               Swap out asset (e.g. USDC) to receive when burning BPTs.\r\n        @param  _staker                       Address that deposited BPTs to StakeLocker.\r\n        @param  _stakeLocker                  Escrows BPTs deposited by Staker.\r\n        @param  _liquidityAssetAmountRequired Amount of Liquidity Asset required to recover.\r\n        @return [0] = poolAmountIn required.\r\n                [1] = poolAmountIn currently staked.\r\n    */\r\n    function getPoolSharesRequired(\r\n        address _bPool,\r\n        address _liquidityAsset,\r\n        address _staker,\r\n        address _stakeLocker,\r\n        uint256 _liquidityAssetAmountRequired\r\n    ) external view returns (uint256, uint256) {\r\n        return PoolLib.getPoolSharesRequired(_bPool, _liquidityAsset, _staker, _stakeLocker, _liquidityAssetAmountRequired);\r\n    }\r\n\r\n    /**\r\n      @dev    Checks that the Pool state is `Finalized`.\r\n      @return bool Boolean value indicating if Pool is in a Finalized state.\r\n    */\r\n    function isPoolFinalized() external view returns (bool) {\r\n        return poolState == State.Finalized;\r\n    }\r\n\r\n    /************************/\r\n    /*** Helper Functions ***/\r\n    /************************/\r\n\r\n    /**\r\n        @dev   Converts to WAD precision.\r\n        @param amt Amount to convert.\r\n    */\r\n    function _toWad(uint256 amt) internal view returns (uint256) {\r\n        return amt.mul(WAD).div(10 ** liquidityAssetDecimals);\r\n    }\r\n\r\n    /**\r\n        @dev    Returns the balance of this Pool's LiquidityLocker.\r\n        @return Balance of LiquidityLocker.\r\n    */\r\n    function _balanceOfLiquidityLocker() internal view returns (uint256) {\r\n        return liquidityAsset.balanceOf(liquidityLocker);\r\n    }\r\n\r\n    /**\r\n        @dev   Checks that the current state of Pool matches the provided state.\r\n        @param _state Enum of desired Pool state.\r\n    */\r\n    function _isValidState(State _state) internal view {\r\n        require(poolState == _state, \"P:BAD_STATE\");\r\n    }\r\n\r\n    /**\r\n        @dev Checks that `msg.sender` is the Pool Delegate.\r\n    */\r\n    function _isValidDelegate() internal view {\r\n        require(msg.sender == poolDelegate, \"P:NOT_DEL\");\r\n    }\r\n\r\n    /**\r\n        @dev Returns the MapleGlobals instance.\r\n    */\r\n    function _globals(address poolFactory) internal view returns (IMapleGlobals) {\r\n        return IMapleGlobals(IPoolFactory(poolFactory).globals());\r\n    }\r\n\r\n    /**\r\n        @dev Emits a `BalanceUpdated` event for LiquidityLocker.\r\n        @dev It emits a `BalanceUpdated` event.\r\n    */\r\n    function _emitBalanceUpdatedEvent() internal {\r\n        emit BalanceUpdated(liquidityLocker, address(liquidityAsset), _balanceOfLiquidityLocker());\r\n    }\r\n\r\n    /**\r\n        @dev   Transfers Liquidity Asset to given `to` address, from self (i.e. `address(this)`).\r\n        @param to    Address to transfer liquidityAsset.\r\n        @param value Amount of liquidity asset that gets transferred.\r\n    */\r\n    function _transferLiquidityAsset(address to, uint256 value) internal {\r\n        liquidityAsset.safeTransfer(to, value);\r\n    }\r\n\r\n    /**\r\n        @dev Checks that `msg.sender` is the Pool Delegate or a Pool Admin.\r\n    */\r\n    function _isValidDelegateOrPoolAdmin() internal view {\r\n        require(msg.sender == poolDelegate || poolAdmins[msg.sender], \"P:NOT_DEL_OR_ADMIN\");\r\n    }\r\n\r\n    /**\r\n        @dev Checks that the protocol is not in a paused state.\r\n    */\r\n    function _whenProtocolNotPaused() internal view {\r\n        require(!_globals(superFactory).protocolPaused(), \"P:PROTO_PAUSED\");\r\n    }\r\n\r\n    /**\r\n        @dev Checks that `msg.sender` is the Pool Delegate and that the protocol is not in a paused state.\r\n    */\r\n    function _isValidDelegateAndProtocolNotPaused() internal view {\r\n        _isValidDelegate();\r\n        _whenProtocolNotPaused();\r\n    }\r\n\r\n    function _transferLiquidityLockerFunds(address to, uint256 value) internal {\r\n        ILiquidityLocker(liquidityLocker).transfer(to, value);\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolDelegate\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_liquidityAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stakeAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_slFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_llFactory\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_stakingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_delegateFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidityCap\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidityProvider\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"BalanceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"loan\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"interest\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeLockerPortion\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolDelegatePortion\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidityProvider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cooldown\",\"type\":\"uint256\"}],\"name\":\"Cooldown\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidityProvider\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"custodian\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldAllowance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAllowance\",\"type\":\"uint256\"}],\"name\":\"CustodyAllowanceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"custodian\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CustodyTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"loan\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"defaultSuffered\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bptsBurned\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bptsReturned\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidityAssetRecoveredFromBurn\",\"type\":\"uint256\"}],\"name\":\"DefaultSuffered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidityProvider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositDate\",\"type\":\"uint256\"}],\"name\":\"DepositDateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"by\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fundsDistributed\",\"type\":\"uint256\"}],\"name\":\"FundsDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"by\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fundsWithdrawn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"}],\"name\":\"FundsWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidityProvider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"LPStatusChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLiquidityCap\",\"type\":\"uint256\"}],\"name\":\"LiquidityCapSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"loan\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"debtLocker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountFunded\",\"type\":\"uint256\"}],\"name\":\"LoanFunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLockupPeriod\",\"type\":\"uint256\"}],\"name\":\"LockupPeriodSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"lossesCorrection\",\"type\":\"int256\"}],\"name\":\"LossesCorrectionUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"by\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lossesDistributed\",\"type\":\"uint256\"}],\"name\":\"LossesDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lossesPerShare\",\"type\":\"uint256\"}],\"name\":\"LossesPerShareUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"by\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lossesRecognized\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalLossesRecognized\",\"type\":\"uint256\"}],\"name\":\"LossesRecognized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"pointsCorrection\",\"type\":\"int256\"}],\"name\":\"PointsCorrectionUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pointsPerShare\",\"type\":\"uint256\"}],\"name\":\"PointsPerShareUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"poolAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"PoolAdminSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isOpen\",\"type\":\"bool\"}],\"name\":\"PoolOpenedToPublic\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum Pool.State\",\"name\":\"state\",\"type\":\"uint8\"}],\"name\":\"PoolStateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newStakingFee\",\"type\":\"uint256\"}],\"name\":\"StakingFeeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidityProvider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTotalAllowance\",\"type\":\"uint256\"}],\"name\":\"TotalCustodyAllowanceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bPool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_liquidityAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stakeLocker\",\"type\":\"address\"}],\"name\":\"BPTVal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DL_FACTORY\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"accumulativeFundsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"accumulativeLossesOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowedLiquidityProviders\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"loan\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dlFactory\",\"type\":\"address\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"uint256[7]\",\"name\":\"claimInfo\",\"type\":\"uint256[7]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"custodyAllowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deactivate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"debtLockers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delegateFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"depositDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"loan\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dlFactory\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"fundLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getInitialStakeRequirements\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bPool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_liquidityAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stakeLocker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_liquidityAssetAmountRequired\",\"type\":\"uint256\"}],\"name\":\"getPoolSharesRequired\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"custodian\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"increaseCustodyAllowance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"intendToWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interestBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interestSum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"depositAmt\",\"type\":\"uint256\"}],\"name\":\"isDepositAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPoolFinalized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityAsset\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityLocker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockupPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lossesBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openToPublic\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"poolAdmins\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolDelegate\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolLosses\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolState\",\"outputs\":[{\"internalType\":\"enum Pool.State\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"principalOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"reclaimERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"recognizableLossesOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"recognizedLossesOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setAllowList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newLiquidityCap\",\"type\":\"uint256\"}],\"name\":\"setLiquidityCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newLockupPeriod\",\"type\":\"uint256\"}],\"name\":\"setLockupPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"open\",\"type\":\"bool\"}],\"name\":\"setOpenToPublic\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAdmin\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"setPoolAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newStakingFee\",\"type\":\"uint256\"}],\"name\":\"setStakingFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeAsset\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeLocker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"superFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalCustodyAllowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferByCustodian\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"loan\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dlFactory\",\"type\":\"address\"}],\"name\":\"triggerDefault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateFundsReceived\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateLossesReceived\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"withdrawCooldown\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"withdrawableFundsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"withdrawnFundsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Pool","CompilerVersion":"v0.6.11+commit.5ef660b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000a6ccb9483e3e7a737e3a4f5b72a1ce51838ba122000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000c1b10e536cd611acff7a7c32a9e29ce6a02ef6ef00000000000000000000000053a597a4730eb02095dd798b203dcc306348b8d6000000000000000000000000966528bb1c44f96b3aa8fbf411ee896116b068c900000000000000000000000000000000000000000000000000000000000003e800000000000000000000000000000000000000000000000000000000000003e800000000000000000000000000000000000000000000000000000bd2cc61d0000000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000000000000000018000000000000000000000000000000000000000000000000000000000000000104d61706c6520506f6f6c20546f6b656e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000064d504c2d4c500000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"PoolLib:2c1c30fb8cc313ef3cfd2e2bbf2da88add902c30","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"ipfs://338ed6b58b0c477d8e804960099fbfd7403722cacff069fd1119edb300baf016"}]}