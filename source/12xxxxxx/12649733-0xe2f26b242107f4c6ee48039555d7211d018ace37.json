{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/SafeMath.sol\r\npragma solidity ^0.6.12;\r\n\r\n// from: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol\r\n// Subject to the MIT license.\r\n\r\n/**\r\n * @title BiFi's safe-math Contract\r\n * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\r\n */\r\nlibrary SafeMath {\r\n  uint256 internal constant unifiedPoint = 10 ** 18;\r\n\t/******************** Safe Math********************/\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\tuint256 c = a + b;\r\n\t\trequire(c >= a, \"a\");\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\treturn _sub(a, b, \"s\");\r\n\t}\r\n\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\treturn _mul(a, b);\r\n\t}\r\n\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\treturn _div(a, b, \"d\");\r\n\t}\r\n\r\n\tfunction _sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256)\r\n\t{\r\n\t\trequire(b <= a, errorMessage);\r\n\t\treturn a - b;\r\n\t}\r\n\r\n\tfunction _mul(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\tif (a == 0)\r\n\t\t{\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tuint256 c = a* b;\r\n\t\trequire((c / a) == b, \"m\");\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction _div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256)\r\n\t{\r\n\t\trequire(b > 0, errorMessage);\r\n\t\treturn a / b;\r\n\t}\r\n\r\n\tfunction unifiedDiv(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\treturn _div(_mul(a, unifiedPoint), b, \"d\");\r\n\t}\r\n\r\n\tfunction unifiedMul(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\treturn _div(_mul(a, b), unifiedPoint, \"m\");\r\n\t}\r\n}\r\n\r\n// File: contracts/interfaces/IManagerDataStorage.sol\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @title BiFi's manager data storage interface\r\n * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\r\n */\r\ninterface IManagerDataStorage  {\r\n\tfunction getGlobalRewardPerBlock() external view returns (uint256);\r\n\tfunction setGlobalRewardPerBlock(uint256 _globalRewardPerBlock) external returns (bool);\r\n\r\n\tfunction getGlobalRewardDecrement() external view returns (uint256);\r\n\tfunction setGlobalRewardDecrement(uint256 _globalRewardDecrement) external returns (bool);\r\n\r\n\tfunction getGlobalRewardTotalAmount() external view returns (uint256);\r\n\tfunction setGlobalRewardTotalAmount(uint256 _globalRewardTotalAmount) external returns (bool);\r\n\r\n\tfunction getAlphaRate() external view returns (uint256);\r\n\tfunction setAlphaRate(uint256 _alphaRate) external returns (bool);\r\n\r\n\tfunction getAlphaLastUpdated() external view returns (uint256);\r\n\tfunction setAlphaLastUpdated(uint256 _alphaLastUpdated) external returns (bool);\r\n\r\n\tfunction getRewardParamUpdateRewardPerBlock() external view returns (uint256);\r\n\tfunction setRewardParamUpdateRewardPerBlock(uint256 _rewardParamUpdateRewardPerBlock) external returns (bool);\r\n\r\n\tfunction getRewardParamUpdated() external view returns (uint256);\r\n\tfunction setRewardParamUpdated(uint256 _rewardParamUpdated) external returns (bool);\r\n\r\n\tfunction getInterestUpdateRewardPerblock() external view returns (uint256);\r\n\tfunction setInterestUpdateRewardPerblock(uint256 _interestUpdateRewardPerblock) external returns (bool);\r\n\r\n\tfunction getInterestRewardUpdated() external view returns (uint256);\r\n\tfunction setInterestRewardUpdated(uint256 _interestRewardLastUpdated) external returns (bool);\r\n\r\n\tfunction setTokenHandler(uint256 handlerID, address handlerAddr) external returns (bool);\r\n\r\n\tfunction getTokenHandlerInfo(uint256 handlerID) external view returns (bool, address);\r\n\r\n\tfunction getTokenHandlerID(uint256 index) external view returns (uint256);\r\n\r\n\tfunction getTokenHandlerAddr(uint256 handlerID) external view returns (address);\r\n\tfunction setTokenHandlerAddr(uint256 handlerID, address handlerAddr) external returns (bool);\r\n\r\n\tfunction getTokenHandlerExist(uint256 handlerID) external view returns (bool);\r\n\tfunction setTokenHandlerExist(uint256 handlerID, bool exist) external returns (bool);\r\n\r\n\tfunction getTokenHandlerSupport(uint256 handlerID) external view returns (bool);\r\n\tfunction setTokenHandlerSupport(uint256 handlerID, bool support) external returns (bool);\r\n\r\n\tfunction setLiquidationManagerAddr(address _liquidationManagerAddr) external returns (bool);\r\n\tfunction getLiquidationManagerAddr() external view returns (address);\r\n\r\n\tfunction setManagerAddr(address _managerAddr) external returns (bool);\r\n}\r\n\r\n// File: contracts/interfaces/IOracleProxy.sol\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @title BiFi's oracle proxy interface\r\n * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\r\n */\r\ninterface IOracleProxy  {\r\n\tfunction getTokenPrice(uint256 tokenID) external view returns (uint256);\r\n\r\n\tfunction getOracleFeed(uint256 tokenID) external view returns (address, uint256);\r\n\tfunction setOracleFeed(uint256 tokenID, address feedAddr, uint256 decimals, bool needPriceConvert, uint256 priceConvertID) external returns (bool);\r\n}\r\n\r\n// File: contracts/interfaces/IERC20.sol\r\n// from: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\r\npragma solidity 0.6.12;\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external ;\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external ;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/interfaces/IObserver.sol\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @title BiFi's Observer interface\r\n * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\r\n */\r\ninterface IObserver {\r\n    function getAlphaBaseAsset() external view returns (uint256[] memory);\r\n    function setChainGlobalRewardPerblock(uint256 _idx, uint256 globalRewardPerBlocks) external returns (bool);\r\n    function updateChainMarketInfo(uint256 _idx, uint256 chainDeposit, uint256 chainBorrow) external returns (bool);\r\n}\r\n\r\n// File: contracts/interfaces/IProxy.sol\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @title BiFi's proxy interface\r\n * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\r\n */\r\ninterface IProxy  {\r\n\tfunction handlerProxy(bytes memory data) external returns (bool, bytes memory);\r\n\tfunction handlerViewProxy(bytes memory data) external view returns (bool, bytes memory);\r\n\tfunction siProxy(bytes memory data) external returns (bool, bytes memory);\r\n\tfunction siViewProxy(bytes memory data) external view returns (bool, bytes memory);\r\n}\r\n\r\n// File: contracts/interfaces/IMarketHandler.sol\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @title BiFi's market handler interface\r\n * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\r\n */\r\ninterface IMarketHandler  {\r\n\tfunction setCircuitBreaker(bool _emergency) external returns (bool);\r\n\tfunction setCircuitBreakWithOwner(bool _emergency) external returns (bool);\r\n\r\n\tfunction getTokenName() external view returns (string memory);\r\n\r\n\tfunction ownershipTransfer(address payable newOwner) external returns (bool);\r\n\r\n\tfunction deposit(uint256 unifiedTokenAmount, bool allFlag) external payable returns (bool);\r\n\tfunction withdraw(uint256 unifiedTokenAmount, bool allFlag) external returns (bool);\r\n\tfunction borrow(uint256 unifiedTokenAmount, bool allFlag) external returns (bool);\r\n\tfunction repay(uint256 unifiedTokenAmount, bool allFlag) external payable returns (bool);\r\n\r\n\tfunction executeFlashloan(\r\n\t\taddress receiverAddress,\r\n\t\tuint256 amount\r\n  ) external returns (bool);\r\n\r\n\tfunction depositFlashloanFee(\r\n\t\tuint256 amount\r\n\t) external returns (bool);\r\n\r\n  function convertUnifiedToUnderlying(uint256 unifiedTokenAmount) external view returns (uint256);\r\n\tfunction partialLiquidationUser(address payable delinquentBorrower, uint256 liquidateAmount, address payable liquidator, uint256 rewardHandlerID) external returns (uint256, uint256, uint256);\r\n\tfunction partialLiquidationUserReward(address payable delinquentBorrower, uint256 liquidationAmountWithReward, address payable liquidator) external returns (uint256);\r\n\r\n\tfunction getTokenHandlerLimit() external view returns (uint256, uint256);\r\n  function getTokenHandlerBorrowLimit() external view returns (uint256);\r\n\tfunction getTokenHandlerMarginCallLimit() external view returns (uint256);\r\n\tfunction setTokenHandlerBorrowLimit(uint256 borrowLimit) external returns (bool);\r\n\tfunction setTokenHandlerMarginCallLimit(uint256 marginCallLimit) external returns (bool);\r\n\r\n  function getTokenLiquidityAmountWithInterest(address payable userAddr) external view returns (uint256);\r\n\r\n\tfunction getUserAmountWithInterest(address payable userAddr) external view returns (uint256, uint256);\r\n\tfunction getUserAmount(address payable userAddr) external view returns (uint256, uint256);\r\n\r\n\tfunction getUserMaxBorrowAmount(address payable userAddr) external view returns (uint256);\r\n\tfunction getUserMaxWithdrawAmount(address payable userAddr) external view returns (uint256);\r\n\tfunction getUserMaxRepayAmount(address payable userAddr) external view returns (uint256);\r\n\r\n\tfunction checkFirstAction() external returns (bool);\r\n\tfunction applyInterest(address payable userAddr) external returns (uint256, uint256);\r\n\r\n\tfunction reserveDeposit(uint256 unifiedTokenAmount) external payable returns (bool);\r\n\tfunction reserveWithdraw(uint256 unifiedTokenAmount) external returns (bool);\r\n\r\n\tfunction withdrawFlashloanFee(uint256 unifiedTokenAmount) external returns (bool);\r\n\r\n\tfunction getDepositTotalAmount() external view returns (uint256);\r\n\tfunction getBorrowTotalAmount() external view returns (uint256);\r\n\r\n\tfunction getSIRandBIR() external view returns (uint256, uint256);\r\n\r\n  function getERC20Addr() external view returns (address);\r\n}\r\n\r\n// File: contracts/interfaces/IServiceIncentive.sol\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @title BiFi's si interface\r\n * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\r\n */\r\ninterface IServiceIncentive  {\r\n\tfunction setCircuitBreakWithOwner(bool emergency) external returns (bool);\r\n\tfunction setCircuitBreaker(bool emergency) external returns (bool);\r\n\r\n\tfunction updateRewardPerBlockLogic(uint256 _rewardPerBlock) external returns (bool);\r\n\tfunction updateRewardLane(address payable userAddr) external returns (bool);\r\n\r\n\tfunction getBetaRateBaseTotalAmount() external view returns (uint256);\r\n\tfunction getBetaRateBaseUserAmount(address payable userAddr) external view returns (uint256);\r\n\r\n\tfunction getMarketRewardInfo() external view returns (uint256, uint256, uint256);\r\n\r\n\tfunction getUserRewardInfo(address payable userAddr) external view returns (uint256, uint256, uint256);\r\n\r\n\tfunction claimRewardAmountUser(address payable userAddr) external returns (uint256);\r\n}\r\n\r\n// File: contracts/Errors.sol\r\npragma solidity 0.6.12;\r\n\r\ncontract Modifier {\r\n    string internal constant ONLY_OWNER = \"O\";\r\n    string internal constant ONLY_MANAGER = \"M\";\r\n    string internal constant CIRCUIT_BREAKER = \"emergency\";\r\n}\r\n\r\ncontract ManagerModifier is Modifier {\r\n    string internal constant ONLY_HANDLER = \"H\";\r\n    string internal constant ONLY_LIQUIDATION_MANAGER = \"LM\";\r\n    string internal constant ONLY_BREAKER = \"B\";\r\n}\r\n\r\ncontract HandlerDataStorageModifier is Modifier {\r\n    string internal constant ONLY_BIFI_CONTRACT = \"BF\";\r\n}\r\n\r\ncontract SIDataStorageModifier is Modifier {\r\n    string internal constant ONLY_SI_HANDLER = \"SI\";\r\n}\r\n\r\ncontract HandlerErrors is Modifier {\r\n    string internal constant USE_VAULE = \"use value\";\r\n    string internal constant USE_ARG = \"use arg\";\r\n    string internal constant EXCEED_LIMIT = \"exceed limit\";\r\n    string internal constant NO_LIQUIDATION = \"no liquidation\";\r\n    string internal constant NO_LIQUIDATION_REWARD = \"no enough reward\";\r\n    string internal constant NO_EFFECTIVE_BALANCE = \"not enough balance\";\r\n    string internal constant TRANSFER = \"err transfer\";\r\n}\r\n\r\ncontract SIErrors is Modifier { }\r\n\r\ncontract InterestErrors is Modifier { }\r\n\r\ncontract LiquidationManagerErrors is Modifier {\r\n    string internal constant NO_DELINQUENT = \"not delinquent\";\r\n}\r\n\r\ncontract ManagerErrors is ManagerModifier {\r\n    string internal constant REWARD_TRANSFER = \"RT\";\r\n    string internal constant UNSUPPORTED_TOKEN = \"UT\";\r\n}\r\n\r\ncontract OracleProxyErrors is Modifier {\r\n    string internal constant ZERO_PRICE = \"price zero\";\r\n}\r\n\r\ncontract RequestProxyErrors is Modifier { }\r\n\r\ncontract ManagerDataStorageErrors is ManagerModifier {\r\n    string internal constant NULL_ADDRESS = \"err addr null\";\r\n}\r\n\r\n// File: contracts/marketManager/ManagerSlot.sol\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @title BiFi's Slot contract\r\n * @notice Manager Slot Definitions & Allocations\r\n * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\r\n */\r\ncontract ManagerSlot is ManagerErrors {\r\n\tusing SafeMath for uint256;\r\n\r\n\taddress public owner;\r\n\tmapping(address => bool) operators;\r\n\tmapping(address => Breaker) internal breakerTable;\r\n\r\n\tbool public emergency = false;\r\n\r\n\tIManagerDataStorage internal dataStorageInstance;\r\n\tIOracleProxy internal oracleProxy;\r\n\r\n\t/* feat: manager reward token instance*/\r\n\tIERC20 internal rewardErc20Instance;\r\n\r\n\tIObserver public Observer;\r\n\r\n\taddress public slotSetterAddr;\r\n\taddress public handlerManagerAddr;\r\n\taddress public flashloanAddr;\r\n\r\n  // BiFi-X\r\n  address public positionStorageAddr;\r\n  address public nftAddr;\r\n\r\n\tuint256 public tokenHandlerLength;\r\n\r\n  struct FeeRateParams {\r\n    uint256 unifiedPoint;\r\n    uint256 minimum;\r\n    uint256 slope;\r\n    uint256 discountRate;\r\n  }\r\n\r\n  struct HandlerFlashloan {\r\n      uint256 flashFeeRate;\r\n      uint256 discountBase;\r\n      uint256 feeTotal;\r\n  }\r\n\r\n  mapping(uint256 => HandlerFlashloan) public handlerFlashloan;\r\n\r\n\tstruct UserAssetsInfo {\r\n\t\tuint256 depositAssetSum;\r\n\t\tuint256 borrowAssetSum;\r\n\t\tuint256 marginCallLimitSum;\r\n\t\tuint256 depositAssetBorrowLimitSum;\r\n\t\tuint256 depositAsset;\r\n\t\tuint256 borrowAsset;\r\n\t\tuint256 price;\r\n\t\tuint256 callerPrice;\r\n\t\tuint256 depositAmount;\r\n\t\tuint256 borrowAmount;\r\n\t\tuint256 borrowLimit;\r\n\t\tuint256 marginCallLimit;\r\n\t\tuint256 callerBorrowLimit;\r\n\t\tuint256 userBorrowableAsset;\r\n\t\tuint256 withdrawableAsset;\r\n\t}\r\n\r\n\tstruct Breaker {\r\n\t\tbool auth;\r\n\t\tbool tried;\r\n\t}\r\n\r\n\tstruct ContractInfo {\r\n\t\tbool support;\r\n\t\taddress addr;\r\n    address tokenAddr;\r\n\r\n    uint256 expectedBalance;\r\n    uint256 afterBalance;\r\n\r\n\t\tIProxy tokenHandler;\r\n\t\tbytes data;\r\n\r\n\t\tIMarketHandler handlerFunction;\r\n\t\tIServiceIncentive siFunction;\r\n\r\n\t\tIOracleProxy oracleProxy;\r\n\t\tIManagerDataStorage managerDataStorage;\r\n\t}\r\n\r\n\tmodifier onlyOwner {\r\n\t\trequire(msg.sender == owner, ONLY_OWNER);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier onlyHandler(uint256 handlerID) {\r\n\t\t_isHandler(handlerID);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier onlyOperators {\r\n\t\taddress payable sender = msg.sender;\r\n\t\trequire(operators[sender] || sender == owner);\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction _isHandler(uint256 handlerID) internal view {\r\n\t\taddress msgSender = msg.sender;\r\n\t\trequire((msgSender == dataStorageInstance.getTokenHandlerAddr(handlerID)) || (msgSender == owner), ONLY_HANDLER);\r\n\t}\r\n\r\n\tmodifier onlyLiquidationManager {\r\n\t\t_isLiquidationManager();\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction _isLiquidationManager() internal view {\r\n\t\taddress msgSender = msg.sender;\r\n\t\trequire((msgSender == dataStorageInstance.getLiquidationManagerAddr()) || (msgSender == owner), ONLY_LIQUIDATION_MANAGER);\r\n\t}\r\n\r\n\tmodifier circuitBreaker {\r\n\t\t_isCircuitBreak();\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction _isCircuitBreak() internal view {\r\n\t\trequire((!emergency) || (msg.sender == owner), CIRCUIT_BREAKER);\r\n\t}\r\n\r\n\tmodifier onlyBreaker {\r\n\t\t_isBreaker();\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction _isBreaker() internal view {\r\n\t\trequire(breakerTable[msg.sender].auth, ONLY_BREAKER);\r\n\t}\r\n}\r\n\r\n// File: contracts/interfaces/IFlashloanReceiver.sol\r\npragma solidity 0.6.12;\r\n\r\ninterface IFlashloanReceiver {\r\n    function executeOperation(\r\n      address reserve,\r\n      uint256 amount,\r\n      uint256 fee,\r\n      bytes calldata params\r\n    ) external returns (bool);\r\n}\r\n\r\n// File: contracts/interfaces/utils/Bifi-X/IPositionStorage.sol\r\npragma solidity 0.6.12;\r\ninterface IPositionStorage {\r\n  function createStrategy(address strategyLogic) external returns (bool);\r\n  function setStrategy(uint256 strategyID, address strategyLogic) external returns (bool);\r\n  function getStrategy(uint256 strategyID) external view returns (address);\r\n  function newUserProduct(address user, address product) external returns (bool);\r\n  function getUserProducts(address user) external view returns (address[] memory);\r\n  function setFactory(address _factory) external returns (bool);\r\n  function getNFTID(address product) external view returns (uint256);\r\n}\r\n\r\n// File: contracts/interfaces/utils/IERC721.sol\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @dev Optional enumeration extension for ERC-721 non-fungible token standard.\r\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\r\n */\r\ninterface IERC721\r\n{\r\n\r\n  /**\r\n   * @dev Returns a count of valid NFTs tracked by this contract, where each one of them has an\r\n   * assigned and queryable owner not equal to the zero address.\r\n   * @return Total supply of NFTs.\r\n   */\r\n  function totalSupply()\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the token identifier for the `_index`th NFT. Sort order is not specified.\r\n   * @param _index A counter less than `totalSupply()`.\r\n   * @return Token id.\r\n   */\r\n  function tokenByIndex(\r\n    uint256 _index\r\n  )\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\r\n   * considered invalid, and this function throws for queries about the zero address.\r\n   * @param _owner Address for whom to query the balance.\r\n   * @return Balance of _owner.\r\n   */\r\n  function balanceOf(\r\n    address _owner\r\n  )\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the address of the owner of the NFT. NFTs assigned to the zero address are\r\n   * considered invalid, and queries about them do throw.\r\n   * @param _tokenId The identifier for an NFT.\r\n   * @return Address of _tokenId owner.\r\n   */\r\n  function ownerOf(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    view\r\n    returns (address);\r\n\r\n  function mint(\r\n    address _to,\r\n    uint256 _tokenId\r\n  ) external ;\r\n\r\n  /**\r\n   * @dev Returns the token identifier for the `_index`th NFT assigned to `_owner`. Sort order is\r\n   * not specified. It throws if `_index` >= `balanceOf(_owner)` or if `_owner` is the zero address,\r\n   * representing invalid NFTs.\r\n   * @param _owner An address where we are interested in NFTs owned by them.\r\n   * @param _index A counter less than `balanceOf(_owner)`.\r\n   * @return Token id.\r\n   */\r\n  function tokenOfOwnerByIndex(\r\n    address _owner,\r\n    uint256 _index\r\n  )\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n}\r\n\r\n// File: contracts/marketManager/ManagerFlashloan.sol\r\n// SPDX-License-Identifier: BSD-3-Clause\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\n/**\r\n* @title BiFi-X ManagerFlashloan contract\r\n* @author BiFi-X(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\r\n*/\r\ncontract ManagerFlashLoan is ManagerSlot {\r\n  \tevent FlashLoan(address receiver, address asset, uint256 amount, uint256 fee);\r\n\r\n    /**\r\n    * @dev Withdraw accumulated flashloan fee\r\n    * @param handlerID The ID of handler with accumulated flashloan fee\r\n    * @return Whether or not succeed\r\n    */\r\n    function withdrawFlashloanFee(uint256 handlerID) onlyOwner external returns (bool) {\r\n      ContractInfo memory handlerInfo;\r\n      (handlerInfo.support, handlerInfo.addr) = dataStorageInstance.getTokenHandlerInfo(handlerID);\r\n\r\n      if(handlerInfo.support) {\r\n        handlerInfo.tokenHandler = IProxy(handlerInfo.addr);\r\n\r\n        (bool success, ) = handlerInfo.tokenHandler.handlerProxy(\r\n              abi.encodeWithSelector(\r\n                handlerInfo.handlerFunction\r\n                .withdrawFlashloanFee.selector,\r\n                handlerFlashloan[handlerID].feeTotal\r\n              )\r\n            );\r\n        require(success);\r\n\r\n        handlerFlashloan[handlerID].feeTotal = 0;\r\n      }\r\n\r\n      return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Execute flashloan\r\n    * @param handlerID The ID of the token handler to borrow.\r\n    * @param receiverAddress The address of receive callback contract\r\n    * @param amount The amount of borrow through flashloan\r\n    * @param params The encode metadata of user\r\n    * @return Whether or not succeed\r\n    */\r\n    function flashloan(\r\n      uint256 handlerID,\r\n      address receiverAddress,\r\n      uint256 amount,\r\n      bytes calldata params\r\n    ) external returns (bool) {\r\n      return _flashloan(handlerID, receiverAddress, amount, params);\r\n    }\r\n\r\n    /**\r\n    * @dev Execute flashloan\r\n    * @param handlerID The ID of the token handler to borrow.\r\n    * @param receiverAddress The address of receive callback contract\r\n    * @param amount The amount of borrow through flashloan\r\n    * @param params The encode metadata of user\r\n    * @return Whether or not succeed\r\n    */\r\n    function _flashloan(\r\n      uint256 handlerID,\r\n      address receiverAddress,\r\n      uint256 amount,\r\n      bytes calldata params\r\n    ) internal returns (bool) {\r\n        ContractInfo memory handlerInfo;\r\n        (handlerInfo.support, handlerInfo.addr) = dataStorageInstance.getTokenHandlerInfo(handlerID);\r\n\r\n        require(handlerInfo.support);\r\n        handlerInfo.tokenHandler = IProxy(handlerInfo.addr);\r\n\r\n        // receiver to be called after the eth or token send is executed\r\n        IFlashloanReceiver receiver = IFlashloanReceiver(receiverAddress);\r\n\r\n        bool success;\r\n\r\n        // get flashloan fee\r\n        uint256 fee = _getFee(handlerID, amount);\r\n\r\n        // memory before contract balance\r\n        // for successfuly repay flashloan amount and fee\r\n        (handlerInfo.tokenAddr, handlerInfo.expectedBalance) = _getThisBalance(handlerInfo, handlerID);\r\n        handlerInfo.expectedBalance = handlerInfo.expectedBalance.add(_convertUnifiedToUnderlying(handlerInfo, amount)).add(_convertUnifiedToUnderlying(handlerInfo, fee));\r\n\r\n        // send eth or token through handler\r\n        (success, handlerInfo.data) = handlerInfo.tokenHandler.handlerProxy(\r\n          abi.encodeWithSelector(\r\n            handlerInfo.handlerFunction\r\n            .executeFlashloan.selector,\r\n            receiverAddress,\r\n            amount\r\n          )\r\n        );\r\n        // catch error in handler\r\n        require(success);\r\n\r\n        // call FlashloanReceiver executeOperation function\r\n        success = receiver.executeOperation(handlerInfo.tokenAddr, _convertUnifiedToUnderlying(handlerInfo, amount), _convertUnifiedToUnderlying(handlerInfo, fee), params);\r\n        require(success);\r\n\r\n        // get contract balance after executeOperation function\r\n        (, handlerInfo.afterBalance) = _getThisBalance(handlerInfo, handlerID);\r\n\r\n        // handlerInfo.afterBalance gte than handlerInfo.expectedBalance\r\n        // If the user has not made a successful repayment, occur revert\r\n        require(handlerInfo.expectedBalance <= handlerInfo.afterBalance);\r\n\r\n        if(handlerID == 0) { // coin case\r\n          // payback: over repay amount\r\n          if(handlerInfo.expectedBalance < handlerInfo.afterBalance){\r\n            msg.sender.transfer(handlerInfo.afterBalance.sub(handlerInfo.expectedBalance));\r\n          }\r\n          // recovery liquidity\r\n          payable(handlerInfo.addr).transfer(handlerInfo.expectedBalance);\r\n\r\n\r\n        } else { // token case\r\n          IERC20 token = IERC20(handlerInfo.tokenAddr);\r\n          // payback: over repay amount\r\n          if(handlerInfo.afterBalance > handlerInfo.expectedBalance){\r\n            token.transfer(msg.sender, handlerInfo.afterBalance.sub(handlerInfo.expectedBalance));\r\n          }\r\n          // recovery liquidity\r\n          token.transfer(handlerInfo.addr, handlerInfo.expectedBalance);\r\n        }\r\n\r\n        // fee store in manager slot\r\n        handlerFlashloan[handlerID].feeTotal = handlerFlashloan[handlerID].feeTotal.add(fee);\r\n\r\n        // fee to handler reserve\r\n        (success, handlerInfo.data) = handlerInfo.tokenHandler.handlerProxy(\r\n          abi.encodeWithSelector(\r\n            handlerInfo.handlerFunction\r\n            .depositFlashloanFee.selector,\r\n            fee\r\n          )\r\n        );\r\n\r\n        // if error in handler\r\n        require(success);\r\n\r\n        emit FlashLoan(receiverAddress, handlerInfo.addr, amount, fee);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @param handlerID The ID of handler with accumulated flashloan fee\r\n    * @return The amount of fee accumlated to handler\r\n    */\r\n    function getFeeTotal(uint256 handlerID) external view returns (uint256) {\r\n      return handlerFlashloan[handlerID].feeTotal;\r\n    }\r\n\r\n    /**\r\n    * @dev Get flashloan fee for flashloan amount\r\n    * @param handlerID The ID of handler with accumulated flashloan fee\r\n    * @return The amount of fee for flashloan amount\r\n    */\r\n    function getFee(uint256 handlerID, uint256 amount) external view returns (uint256) {\r\n      return _getFee(handlerID, amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Get flashloan fee for flashloan amount\r\n    * @param handlerID The ID of handler with accumulated flashloan fee\r\n    * @param amount The amount of flashloan amount\r\n    * @return The amount of fee for flashloan amount\r\n    */\r\n    function _getFee(uint256 handlerID, uint256 amount) internal view returns (uint256) {\r\n      FeeRateParams memory feeRateParams;\r\n\r\n      uint256 flashloanFeeRate = handlerFlashloan[handlerID].flashFeeRate;\r\n\r\n       if(positionStorageAddr == address(0)) {\r\n        return amount.unifiedMul(flashloanFeeRate);\r\n      }\r\n\r\n      // discount for BiFi-X User\r\n      IPositionStorage positionStorage = IPositionStorage(positionStorageAddr);\r\n      uint256 nftID = positionStorage.getNFTID(msg.sender);\r\n\r\n      // msg.sender is BiFi-X Product\r\n      if(nftID > 0) {\r\n        IERC721 nft = IERC721(nftAddr);\r\n\r\n        address originOwner = nft.ownerOf(nftID);\r\n        uint256 bifiBalance = rewardErc20Instance.balanceOf(originOwner);\r\n        if(bifiBalance >= handlerFlashloan[handlerID].discountBase) {\r\n          // feeRate * (0.1 + 0.9 * min(1, discountBase / bifiAmount))\r\n          feeRateParams.unifiedPoint = 10 ** 18;\r\n          feeRateParams.minimum = 10 ** 17;\r\n          feeRateParams.slope = feeRateParams.unifiedPoint - feeRateParams.minimum;\r\n\r\n          feeRateParams.discountRate = _min(feeRateParams.unifiedPoint, handlerFlashloan[handlerID].discountBase.unifiedDiv(bifiBalance));\r\n\r\n          flashloanFeeRate = flashloanFeeRate.unifiedMul(\r\n            feeRateParams.minimum.add(feeRateParams.slope.unifiedMul(feeRateParams.discountRate))\r\n          );\r\n        }\r\n      }\r\n\r\n      return amount.unifiedMul(flashloanFeeRate);\r\n    }\r\n\r\n    /**\r\n    * @dev Get flashloan fee for flashloan amount before make product(BiFi-X)\r\n    * @param handlerID The ID of handler with accumulated flashloan fee\r\n    * @param amount The amount of flashloan amount\r\n    * @param bifiBalance The amount of Bifi amount\r\n    * @return The amount of fee for flashloan amount\r\n    */\r\n    function getFeeFromArguments(uint256 handlerID, uint256 amount, uint256 bifiBalance) external view returns (uint256) {\r\n      FeeRateParams memory feeRateParams;\r\n\r\n      uint256 flashloanFeeRate = handlerFlashloan[handlerID].flashFeeRate;\r\n\r\n      if(bifiBalance >= handlerFlashloan[handlerID].discountBase) {\r\n        // feeRate * (0.1 + 0.9 * min(1, discountBase / bifiAmount))\r\n        feeRateParams.unifiedPoint = 10 ** 18;\r\n        feeRateParams.minimum = 10 ** 17;\r\n        feeRateParams.slope = feeRateParams.unifiedPoint - feeRateParams.minimum;\r\n\r\n        feeRateParams.discountRate = _min(feeRateParams.unifiedPoint, handlerFlashloan[handlerID].discountBase.unifiedDiv(bifiBalance));\r\n\r\n        flashloanFeeRate = flashloanFeeRate.unifiedMul(\r\n          feeRateParams.minimum.add(feeRateParams.slope.unifiedMul(feeRateParams.discountRate))\r\n        );\r\n      }\r\n\r\n      return amount.unifiedMul(flashloanFeeRate);\r\n    }\r\n\r\n    function _min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n      if (a >= b) { return b; }\r\n      return a;\r\n    }\r\n\r\n    /**\r\n    * @dev Convert amount of handler's unified decimals to amount of token's underlying decimals\r\n    * @param unifiedTokenAmount The amount of unified decimals\r\n    * @return (underlyingTokenAmount)\r\n    */\r\n    function _convertUnifiedToUnderlying(ContractInfo memory handlerInfo, uint256 unifiedTokenAmount) internal view returns (uint256) {\r\n      (, handlerInfo.data) = handlerInfo.tokenHandler.handlerViewProxy(\r\n        abi.encodeWithSelector(\r\n          handlerInfo.handlerFunction\r\n          .convertUnifiedToUnderlying.selector,\r\n          unifiedTokenAmount\r\n        )\r\n      );\r\n\r\n      uint256 underlyingTokenDecimal = abi.decode(handlerInfo.data, (uint256));\r\n      return underlyingTokenDecimal;\r\n    }\r\n\r\n    /**\r\n    * @dev Get handler contract balance\r\n    * @param handlerInfo Handler's information about getting the balance\r\n    * @param handlerID The ID of handler get the balance\r\n    * @return tokenAddr is actual tokenAddress and contract token balance.\r\n    */\r\n    function _getThisBalance(ContractInfo memory handlerInfo, uint256 handlerID) internal view returns (address tokenAddr, uint256 balance) {\r\n      if(handlerID == 0) { // ether\r\n        balance = address(this).balance;\r\n        return (address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE), balance);\r\n      } else { // token\r\n        (, handlerInfo.data) = handlerInfo.tokenHandler.handlerViewProxy(\r\n          abi.encodeWithSelector(\r\n            handlerInfo.handlerFunction\r\n            .getERC20Addr.selector\r\n          )\r\n        );\r\n\r\n        tokenAddr = abi.decode(handlerInfo.data, (address));\r\n        balance = IERC20(tokenAddr).balanceOf(address(this));\r\n        return (tokenAddr, balance);\r\n      }\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"FlashLoan\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"Observer\",\"outputs\":[{\"internalType\":\"contract IObserver\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergency\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"handlerID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiverAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"name\":\"flashloan\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flashloanAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"handlerID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"handlerID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bifiBalance\",\"type\":\"uint256\"}],\"name\":\"getFeeFromArguments\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"handlerID\",\"type\":\"uint256\"}],\"name\":\"getFeeTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"handlerFlashloan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"flashFeeRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"discountBase\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeTotal\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"handlerManagerAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"positionStorageAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"slotSetterAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenHandlerLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"handlerID\",\"type\":\"uint256\"}],\"name\":\"withdrawFlashloanFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ManagerFlashLoan","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"BSD-3-Clause","Proxy":"0","Implementation":"","SwarmSource":"ipfs://a78fc9e7d659a4424fdc4ff0887b0b8b2b9253eaf5ec3c7585e748b4698b2398"}]}