{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.2.12\r\n# (c) Curve.Fi, 2021\r\n\r\n# This contract contains view-only external methods which can be gas-inefficient\r\n# when called from smart contracts but ok to use from frontend\r\n# Called only from Curve contract as it uses msg.sender as the contract address\r\nfrom vyper.interfaces import ERC20\r\n\r\ninterface Curve:\r\n    def A_precise() -> uint256: view\r\n    def gamma() -> uint256: view\r\n    def price_scale(i: uint256) -> uint256: view\r\n    def balances(i: uint256) -> uint256: view\r\n    def D() -> uint256: view\r\n    def fee_calc(xp: uint256[N_COINS]) -> uint256: view\r\n    def calc_token_fee(amounts: uint256[N_COINS], xp: uint256[N_COINS]) -> uint256: view\r\n    def token() -> address: view\r\n\r\ninterface Math:\r\n    def newton_D(ANN: uint256, gamma: uint256, x_unsorted: uint256[N_COINS]) -> uint256: view\r\n    def newton_y(ANN: uint256, gamma: uint256, x: uint256[N_COINS], D: uint256, i: uint256) -> uint256: view\r\n\r\nN_COINS: constant(int128) = 3  # <- change\r\nPRECISION: constant(uint256) = 10 ** 18  # The precision to convert to\r\nPRECISIONS: constant(uint256[N_COINS]) = [\r\n    10**12, # USDT\r\n    10**10, # WBTC\r\n    1, # WETH\r\n]\r\n\r\nmath: address\r\n\r\n\r\n@external\r\ndef __init__(math: address):\r\n    self.math = math\r\n\r\n\r\n@external\r\n@view\r\ndef get_dy(i: uint256, j: uint256, dx: uint256) -> uint256:\r\n    assert i != j and i < N_COINS and j < N_COINS, \"coin index out of range\"\r\n    assert dx > 0, \"do not exchange 0 coins\"\r\n\r\n    precisions: uint256[N_COINS] = PRECISIONS\r\n\r\n    price_scale: uint256[N_COINS-1] = empty(uint256[N_COINS-1])\r\n    for k in range(N_COINS-1):\r\n        price_scale[k] = Curve(msg.sender).price_scale(k)\r\n    xp: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    for k in range(N_COINS):\r\n        xp[k] = Curve(msg.sender).balances(k)\r\n    y0: uint256 = xp[j]\r\n    xp[i] += dx\r\n    xp[0] *= precisions[0]\r\n    for k in range(N_COINS-1):\r\n        xp[k+1] = xp[k+1] * price_scale[k] * precisions[k+1] / PRECISION\r\n\r\n    A: uint256 = Curve(msg.sender).A_precise()\r\n    gamma: uint256 = Curve(msg.sender).gamma()\r\n\r\n    y: uint256 = Math(self.math).newton_y(A, gamma, xp, Curve(msg.sender).D(), j)\r\n    dy: uint256 = xp[j] - y - 1\r\n    xp[j] = y\r\n    if j > 0:\r\n        dy = dy * PRECISION / price_scale[j-1]\r\n    dy /= precisions[j]\r\n    dy -= Curve(msg.sender).fee_calc(xp) * dy / 10**10\r\n\r\n    return dy\r\n\r\n\r\n@view\r\n@external\r\ndef calc_token_amount(amounts: uint256[N_COINS], deposit: bool) -> uint256:\r\n    precisions: uint256[N_COINS] = PRECISIONS\r\n    token_supply: uint256 = ERC20(Curve(msg.sender).token()).totalSupply()\r\n    xp: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    for k in range(N_COINS):\r\n        xp[k] = Curve(msg.sender).balances(k)\r\n    amountsp: uint256[N_COINS] = amounts\r\n    if deposit:\r\n        for k in range(N_COINS):\r\n            xp[k] += amounts[k]\r\n    else:\r\n        for k in range(N_COINS):\r\n            xp[k] -= amounts[k]\r\n    xp[0] *= precisions[0]\r\n    amountsp[0] *= precisions[0]\r\n    for k in range(N_COINS-1):\r\n        p: uint256 = Curve(msg.sender).price_scale(k) * precisions[k+1]\r\n        xp[k+1] = xp[k+1] * p / PRECISION\r\n        amountsp[k+1] = amountsp[k+1] * p / PRECISION\r\n    A: uint256 = Curve(msg.sender).A_precise()\r\n    gamma: uint256 = Curve(msg.sender).gamma()\r\n    D: uint256 = Math(self.math).newton_D(A, gamma, xp)\r\n    d_token: uint256 = token_supply * D / Curve(msg.sender).D()\r\n    if deposit:\r\n        d_token -= token_supply\r\n    else:\r\n        d_token = token_supply - d_token\r\n    d_token -= Curve(msg.sender).calc_token_fee(amountsp, xp) * d_token / 10**10 + 1\r\n    return d_token","ABI":"[{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"math\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_dy\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"j\",\"type\":\"uint256\"},{\"name\":\"dx\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":32392},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calc_token_amount\",\"inputs\":[{\"name\":\"amounts\",\"type\":\"uint256[3]\"},{\"name\":\"deposit\",\"type\":\"bool\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":38843}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.12","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"000000000000000000000000656dd75d33a6241a0c4c2368eb00441ad3113ec0","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":""}]}