{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\n\n\n// Part: IERC20\n\ninterface IERC20 {\n    function decimals() external view returns (uint);\n}\n\n// Part: IKeep3rV1Oracle\n\n// Modified from https://github.com/keep3r-network/keep3r.network/blob/master/contracts/Keep3rV1Volatility.sol\n// Subject to the MIT license\n\ninterface IKeep3rV1Oracle {\n  function sample(address tokenIn, uint amountIn, address tokenOut, uint points, uint window) external view returns (uint[] memory);\n}\n\n// File: Keep3rV1OracleMetrics.sol\n\ncontract Keep3rV1OracleMetrics {\n\n  uint private constant FIXED_1 = 0x080000000000000000000000000000000;\n  uint private constant FIXED_2 = 0x100000000000000000000000000000000;\n  uint private constant SQRT_1 = 13043817825332782212;\n  uint private constant LNX = 3988425491;\n  uint private constant LOG_10_2 = 3010299957;\n  uint private constant LOG_E_2 = 6931471806;\n  uint private constant BASE = 1e10;\n\n  uint public constant periodSize = 1800;\n\n  IKeep3rV1Oracle public constant KV1O = IKeep3rV1Oracle(0xf67Ab1c914deE06Ba0F264031885Ea7B276a7cDa); // SushiswapV1Oracle\n\n  function floorLog2(uint256 _n) public pure returns (uint8) {\n      uint8 res = 0;\n\n      if (_n < 256) {\n          // At most 8 iterations\n          while (_n > 1) {\n              _n >>= 1;\n              res += 1;\n          }\n      } else {\n          // Exactly 8 iterations\n          for (uint8 s = 128; s > 0; s >>= 1) {\n              if (_n >= (uint(1) << s)) {\n                  _n >>= s;\n                  res |= s;\n              }\n          }\n      }\n\n      return res;\n  }\n\n  function ln(uint256 x) public pure returns (uint) {\n      uint res = 0;\n\n      // If x >= 2, then we compute the integer part of log2(x), which is larger than 0.\n      if (x >= FIXED_2) {\n          uint8 count = floorLog2(x / FIXED_1);\n          x >>= count; // now x < 2\n          res = count * FIXED_1;\n      }\n\n      // If x > 1, then we compute the fraction part of log2(x), which is larger than 0.\n      if (x > FIXED_1) {\n          for (uint8 i = 127; i > 0; --i) {\n              x = (x * x) / FIXED_1; // now 1 < x < 4\n              if (x >= FIXED_2) {\n                  x >>= 1; // now 1 < x < 2\n                  res += uint(1) << (i - 1);\n              }\n          }\n      }\n\n      return res * LOG_E_2 / BASE;\n  }\n\n  /**\n   * @dev computes e ^ (x / FIXED_1) * FIXED_1\n   * input range: 0 <= x <= OPT_EXP_MAX_VAL - 1\n   * auto-generated via 'PrintFunctionOptimalExp.py'\n   * Detailed description:\n   * - Rewrite the input as a sum of binary exponents and a single residual r, as small as possible\n   * - The exponentiation of each binary exponent is given (pre-calculated)\n   * - The exponentiation of r is calculated via Taylor series for e^x, where x = r\n   * - The exponentiation of the input is calculated by multiplying the intermediate results above\n   * - For example: e^5.521692859 = e^(4 + 1 + 0.5 + 0.021692859) = e^4 * e^1 * e^0.5 * e^0.021692859\n   */\n  function optimalExp(uint256 x) public pure returns (uint256) {\n      uint256 res = 0;\n\n      uint256 y;\n      uint256 z;\n\n      z = y = x % 0x10000000000000000000000000000000; // get the input modulo 2^(-3)\n      z = (z * y) / FIXED_1;\n      res += z * 0x10e1b3be415a0000; // add y^02 * (20! / 02!)\n      z = (z * y) / FIXED_1;\n      res += z * 0x05a0913f6b1e0000; // add y^03 * (20! / 03!)\n      z = (z * y) / FIXED_1;\n      res += z * 0x0168244fdac78000; // add y^04 * (20! / 04!)\n      z = (z * y) / FIXED_1;\n      res += z * 0x004807432bc18000; // add y^05 * (20! / 05!)\n      z = (z * y) / FIXED_1;\n      res += z * 0x000c0135dca04000; // add y^06 * (20! / 06!)\n      z = (z * y) / FIXED_1;\n      res += z * 0x0001b707b1cdc000; // add y^07 * (20! / 07!)\n      z = (z * y) / FIXED_1;\n      res += z * 0x000036e0f639b800; // add y^08 * (20! / 08!)\n      z = (z * y) / FIXED_1;\n      res += z * 0x00000618fee9f800; // add y^09 * (20! / 09!)\n      z = (z * y) / FIXED_1;\n      res += z * 0x0000009c197dcc00; // add y^10 * (20! / 10!)\n      z = (z * y) / FIXED_1;\n      res += z * 0x0000000e30dce400; // add y^11 * (20! / 11!)\n      z = (z * y) / FIXED_1;\n      res += z * 0x000000012ebd1300; // add y^12 * (20! / 12!)\n      z = (z * y) / FIXED_1;\n      res += z * 0x0000000017499f00; // add y^13 * (20! / 13!)\n      z = (z * y) / FIXED_1;\n      res += z * 0x0000000001a9d480; // add y^14 * (20! / 14!)\n      z = (z * y) / FIXED_1;\n      res += z * 0x00000000001c6380; // add y^15 * (20! / 15!)\n      z = (z * y) / FIXED_1;\n      res += z * 0x000000000001c638; // add y^16 * (20! / 16!)\n      z = (z * y) / FIXED_1;\n      res += z * 0x0000000000001ab8; // add y^17 * (20! / 17!)\n      z = (z * y) / FIXED_1;\n      res += z * 0x000000000000017c; // add y^18 * (20! / 18!)\n      z = (z * y) / FIXED_1;\n      res += z * 0x0000000000000014; // add y^19 * (20! / 19!)\n      z = (z * y) / FIXED_1;\n      res += z * 0x0000000000000001; // add y^20 * (20! / 20!)\n      res = res / 0x21c3677c82b40000 + y + FIXED_1; // divide by 20! and then add y^1 / 1! + y^0 / 0!\n\n      if ((x & 0x010000000000000000000000000000000) != 0)\n          res = (res * 0x1c3d6a24ed82218787d624d3e5eba95f9) / 0x18ebef9eac820ae8682b9793ac6d1e776; // multiply by e^2^(-3)\n      if ((x & 0x020000000000000000000000000000000) != 0)\n          res = (res * 0x18ebef9eac820ae8682b9793ac6d1e778) / 0x1368b2fc6f9609fe7aceb46aa619baed4; // multiply by e^2^(-2)\n      if ((x & 0x040000000000000000000000000000000) != 0)\n          res = (res * 0x1368b2fc6f9609fe7aceb46aa619baed5) / 0x0bc5ab1b16779be3575bd8f0520a9f21f; // multiply by e^2^(-1)\n      if ((x & 0x080000000000000000000000000000000) != 0)\n          res = (res * 0x0bc5ab1b16779be3575bd8f0520a9f21e) / 0x0454aaa8efe072e7f6ddbab84b40a55c9; // multiply by e^2^(+0)\n      if ((x & 0x100000000000000000000000000000000) != 0)\n          res = (res * 0x0454aaa8efe072e7f6ddbab84b40a55c5) / 0x00960aadc109e7a3bf4578099615711ea; // multiply by e^2^(+1)\n      if ((x & 0x200000000000000000000000000000000) != 0)\n          res = (res * 0x00960aadc109e7a3bf4578099615711d7) / 0x0002bf84208204f5977f9a8cf01fdce3d; // multiply by e^2^(+2)\n      if ((x & 0x400000000000000000000000000000000) != 0)\n          res = (res * 0x0002bf84208204f5977f9a8cf01fdc307) / 0x0000003c6ab775dd0b95b4cbee7e65d11; // multiply by e^2^(+3)\n\n      return res;\n  }\n\n  function sqrt(uint x) public pure returns (uint y) {\n      uint z = (x + 1) / 2;\n      y = x;\n      while (z < y) {\n          y = z;\n          z = (x / z + z) / 2;\n      }\n  }\n\n  /**\n   * @notice computes mle for mu in assumed GBM price path\n   * @dev Non-standard form of P_t = P_0 * e^{mu * t + sigma * W_t}\n   */\n  function mu(address tokenIn, address tokenOut, uint points, uint window) public view returns (uint m) {\n    // TODO: Fix for signed int output\n    uint[] memory p = KV1O.sample(tokenIn, uint(10)**IERC20(tokenIn).decimals(), tokenOut, points, window);\n    for (uint8 i = 1; i <= (p.length - 1); i++) {\n      m += (ln(p[i] * FIXED_1) - ln(p[i-1] * FIXED_1));\n    }\n    return m / (periodSize * (p.length - 1));\n  }\n\n  /**\n   * @notice computes mle for sigma**2 in assumed GBM price path\n   * @dev Non-standard form of P_t = P_0 * e^{mu * t + sigma * W_t}\n   */\n  function sigSqrd(address tokenIn, address tokenOut, uint points, uint window) public view returns (uint ss) {\n    // TODO: Fix for signed int output\n    uint[] memory p = KV1O.sample(tokenIn, uint(10)**IERC20(tokenIn).decimals(), tokenOut, points, window);\n\n    uint m = mu(tokenIn, tokenOut, points, window);\n    m = m * periodSize;\n    for (uint8 i = 1; i <= (p.length - 1); i++) {\n      ss += ((ln(p[i] * FIXED_1) - ln(p[i-1] * FIXED_1)) - m)**2; // FIXED_1 needed?\n    }\n    return ss / (periodSize * (p.length - 1));\n  }\n\n  /**\n   * @notice computes mle for sigma in assumed GBM price path\n   * @dev Non-standard form of P_t = P_0 * e^{mu * t + sigma * W_t}\n   */\n  function sig(address tokenIn, address tokenOut, uint points, uint window) external view returns (uint) {\n    return sqrt(sigSqrd(tokenIn, tokenOut, points, window));\n  }\n\n  /**\n   * @notice rolling mu for last r windows\n   */\n  function rMu(address tokenIn, address tokenOut, uint points, uint window, uint8 r) public view returns (uint[] memory) {\n    uint[] memory _mus = new uint[](r);\n\n    // need to hit sample() for points = r * points with window = window to get extra number of points\n    // then for i = 1, ..., r; assemble the _mus\n    uint allPoints = points * uint(r);\n    uint[] memory p = KV1O.sample(tokenIn, uint(10)**IERC20(tokenIn).decimals(), tokenOut, allPoints, window);\n\n    uint m = 0;\n    uint index = 0;\n    for (uint8 i = 1; i <= (p.length - 1); i++) {\n      m += (ln(p[i] * FIXED_1) - ln(p[i-1] * FIXED_1));\n      if (i % (points * window) == 0) {\n        _mus[index] = (m / (periodSize * (p.length - 1)));\n        m = 0;\n        index += 1;\n      }\n    }\n    return _mus;\n  }\n\n  /**\n   * @notice rolling sig for last r windows\n   */\n  function rSigSqrd(address tokenIn, address tokenOut, uint points, uint window, uint8 r) external view returns (uint[] memory) {\n    uint[] memory _mus = rMu(tokenIn, tokenOut, points, window, r);\n    uint[] memory _sigs = new uint[](r);\n\n    // need to hit sample() for points = r * points with window = window to get extra number of points\n    // then for i = 1, ..., r; assemble the _sigs\n    uint allPoints = points * uint(r);\n    uint[] memory p = KV1O.sample(tokenIn, uint(10)**IERC20(tokenIn).decimals(), tokenOut, allPoints, window);\n\n    uint ss = 0;\n    uint index = 0;\n    for (uint8 i = 1; i <= (p.length - 1); i++) {\n      ss += ((ln(p[i] * FIXED_1) - ln(p[i-1] * FIXED_1)) - _mus[index]*periodSize)**2;\n      if (i % (points * window) == 0) {\n        _sigs[index] = (ss / (periodSize * (p.length - 1)));\n        ss = 0;\n        index += 1;\n      }\n    }\n\n    return _sigs;\n  }\n}\n","ABI":"[{\"inputs\":[],\"name\":\"KV1O\",\"outputs\":[{\"internalType\":\"contract IKeep3rV1Oracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_n\",\"type\":\"uint256\"}],\"name\":\"floorLog2\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"}],\"name\":\"ln\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"points\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"window\",\"type\":\"uint256\"}],\"name\":\"mu\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"}],\"name\":\"optimalExp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"periodSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"points\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"window\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"r\",\"type\":\"uint8\"}],\"name\":\"rMu\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"points\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"window\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"r\",\"type\":\"uint8\"}],\"name\":\"rSigSqrd\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"points\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"window\",\"type\":\"uint256\"}],\"name\":\"sig\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"points\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"window\",\"type\":\"uint256\"}],\"name\":\"sigSqrd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ss\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"}],\"name\":\"sqrt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"Keep3rV1OracleMetrics","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}