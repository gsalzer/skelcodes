{"status":"1","message":"OK","result":[{"SourceCode":"{\"Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * This test is non-exhaustive, and there may be false-negatives: during the\\n     * execution of a contract\\u0027s constructor, its address will be reported as\\n     * not containing a contract.\\n     *\\n     * IMPORTANT: It is unsafe to assume that an address for which this\\n     * function returns false is an externally-owned account (EOA) and not a\\n     * contract.\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies in extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != 0x0 \\u0026\\u0026 codehash != accountHash);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` into `address payable`. Note that this is\\n     * simply a type cast: the actual underlying value is not changed.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function toPayable(address account) internal pure returns (address payable) {\\n        return address(uint160(account));\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-call-value\\n        (bool success, ) = recipient.call{value:amount}(new bytes(0));\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n}\"},\"IERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\n\\ninterface IERC1155 {\\n  // Events\\n\\n  /**\\n   * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\\n   *   Operator MUST be msg.sender\\n   *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\\n   *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\\n   *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the \\\"circulating supply\\\" for a given token ID\\n   *   To broadcast the existence of a token ID with no initial balance, the contract SHOULD emit the TransferSingle event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\\n   */\\n  event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _amount);\\n\\n  /**\\n   * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\\n   *   Operator MUST be msg.sender\\n   *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\\n   *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\\n   *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the \\\"circulating supply\\\" for a given token ID\\n   *   To broadcast the existence of multiple token IDs with no initial balance, this SHOULD emit the TransferBatch event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\\n   */\\n  event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _amounts);\\n\\n  /**\\n   * @dev MUST emit when an approval is updated\\n   */\\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\\n\\n  /**\\n   * @dev MUST emit when the URI is updated for a token ID\\n   *   URIs are defined in RFC 3986\\n   *   The URI MUST point a JSON file that conforms to the \\\"ERC-1155 Metadata JSON Schema\\\"\\n   */\\n  event URI(string _amount, uint256 indexed _id);\\n\\n  /**\\n   * @notice Transfers amount of an _id from the _from address to the _to address specified\\n   * @dev MUST emit TransferSingle event on success\\n   * Caller must be approved to manage the _from account\\u0027s tokens (see isApprovedForAll)\\n   * MUST throw if `_to` is the zero address\\n   * MUST throw if balance of sender for token `_id` is lower than the `_amount` sent\\n   * MUST throw on any other error\\n   * When transfer is complete, this function MUST check if `_to` is a smart contract (code size \\u003e 0). If so, it MUST call `onERC1155Received` on `_to` and revert if the return amount is not `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n   * @param _from    Source address\\n   * @param _to      Target address\\n   * @param _id      ID of the token type\\n   * @param _amount  Transfered amount\\n   * @param _data    Additional data with no specified format, sent in call to `_to`\\n   */\\n  function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes calldata _data) external;\\n\\n  /**\\n   * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\\n   * @dev MUST emit TransferBatch event on success\\n   * Caller must be approved to manage the _from account\\u0027s tokens (see isApprovedForAll)\\n   * MUST throw if `_to` is the zero address\\n   * MUST throw if length of `_ids` is not the same as length of `_amounts`\\n   * MUST throw if any of the balance of sender for token `_ids` is lower than the respective `_amounts` sent\\n   * MUST throw on any other error\\n   * When transfer is complete, this function MUST check if `_to` is a smart contract (code size \\u003e 0). If so, it MUST call `onERC1155BatchReceived` on `_to` and revert if the return amount is not `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n   * Transfers and events MUST occur in the array order they were submitted (_ids[0] before _ids[1], etc)\\n   * @param _from     Source addresses\\n   * @param _to       Target addresses\\n   * @param _ids      IDs of each token type\\n   * @param _amounts  Transfer amounts per token type\\n   * @param _data     Additional data with no specified format, sent in call to `_to`\\n  */\\n  function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external;\\n  \\n  /**\\n   * @notice Get the balance of an account\\u0027s Tokens\\n   * @param _owner  The address of the token holder\\n   * @param _id     ID of the Token\\n   * @return        The _owner\\u0027s balance of the Token type requested\\n   */\\n  function balanceOf(address _owner, uint256 _id) external view returns (uint256);\\n\\n  /**\\n   * @notice Get the balance of multiple account/token pairs\\n   * @param _owners The addresses of the token holders\\n   * @param _ids    ID of the Tokens\\n   * @return        The _owner\\u0027s balance of the Token types requested (i.e. balance for each (owner, id) pair)\\n   */\\n  function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory);\\n\\n  /**\\n   * @notice Enable or disable approval for a third party (\\\"operator\\\") to manage all of caller\\u0027s tokens\\n   * @dev MUST emit the ApprovalForAll event on success\\n   * @param _operator  Address to add to the set of authorized operators\\n   * @param _approved  True if the operator is approved, false to revoke approval\\n   */\\n  function setApprovalForAll(address _operator, bool _approved) external;\\n\\n\\n  function isApprovedForAll(address _owner, address _operator) external view returns (bool isOperator);\\n\\n}\\n\"},\"IERC1155TokenReceiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\n/**\\n * @dev ERC-1155 interface for accepting safe transfers.\\n */\\ninterface IERC1155TokenReceiver {\\n\\n  /**\\n   * @notice Handle the receipt of a single ERC1155 token type\\n   * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated\\n   * This function MAY throw to revert and reject the transfer\\n   * Return of other amount than the magic value MUST result in the transaction being reverted\\n   * Note: The token contract address is always the message sender\\n   * @param _operator  The address which called the `safeTransferFrom` function\\n   * @param _from      The address which previously owned the token\\n   * @param _id        The id of the token being transferred\\n   * @param _amount    The amount of tokens being transferred\\n   * @param _data      Additional data with no specified format\\n   * @return           `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n   */\\n  function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _amount, bytes calldata _data) external returns(bytes4);\\n\\n  /**\\n   * @notice Handle the receipt of multiple ERC1155 token types\\n   * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated\\n   * This function MAY throw to revert and reject the transfer\\n   * Return of other amount than the magic value WILL result in the transaction being reverted\\n   * Note: The token contract address is always the message sender\\n   * @param _operator  The address which called the `safeBatchTransferFrom` function\\n   * @param _from      The address which previously owned the token\\n   * @param _ids       An array containing ids of each token being transferred\\n   * @param _amounts   An array containing amounts of each token being transferred\\n   * @param _data      Additional data with no specified format\\n   * @return           `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n   */\\n  function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external returns(bytes4);\\n\\n  /**\\n   * @notice Indicates whether a contract implements the `ERC1155TokenReceiver` functions and so can accept ERC1155 token types.\\n   * @param  interfaceID The ERC-165 interface ID that is queried for support.s\\n   * @dev This function MUST return true if it implements the ERC1155TokenReceiver interface and ERC-165 interface.\\n   *      This function MUST NOT consume more than 5,000 gas.\\n   * @return Wheter ERC-165 or ERC1155TokenReceiver interfaces are supported.\\n   */\\n  function supportsInterface(bytes4 interfaceID) external view returns (bool);\\n\\n}\"},\"MiningCore.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./IERC1155.sol\\\";\\nimport \\\"./IERC1155TokenReceiver.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./Address.sol\\\";\\n\\n// sns: [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17]\\n// ids:[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18]\\n// fertilities:[1,2,5,10,30,100,1,2,5,10,30,100,10,20,50,100,300,1000]\\n// carries:[0,0,0,0,0,0,10,20,50,100,300,1000,1,2,5,10,30,100]\\n\\ninterface MiningPool{\\n    \\n    function users(address userAddress) external view returns(uint256 id,uint256 investment,uint256 freezeTime);\\n    \\n    function balanceOf(address userAddress) external view returns (address[2] memory,uint256[2] memory balances);\\n    \\n    function totalSupply() external view returns (uint256);\\n    \\n    function stakeAmount() external view returns (uint256);\\n    \\n    function duration() external view returns (uint256);\\n    \\n    function token() external view returns (address);\\n    \\n    function deposit(uint256[2] calldata amounts) external returns(bool);\\n    \\n    function allot(address userAddress,uint256[2] calldata amounts) external returns(bool);\\n    \\n    function lock(address holder, address locker, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s) external;\\n    \\n    function lockStatus(address userAddress) external view returns(bool);\\n}\\n\\ninterface IUniswapPair {\\n    \\n    function setFeeOwner(address _feeOwner) external;\\n}\\n\\ninterface IUniswapFactory {\\n    \\n    function getPair(address token0,address token1) external returns(address);\\n}\\n\\nabstract contract ERC1155TokenReceiver is IERC1155TokenReceiver{\\n    \\n    bytes4 constant internal ERC1155_RECEIVED_VALUE = 0xf23a6e61;\\n    bytes4 constant internal ERC1155_BATCH_RECEIVED_VALUE = 0xbc197c81;\\n    \\n    //-------------------------------------ERC1155---------------------------------------------------------------------\\n    \\n    function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _value, bytes calldata _data) external override returns(bytes4) {\\n        uint256[] memory _values = new uint256[](1);\\n        uint256[] memory _ids = new uint256[](1);\\n        _ids[0] = _id;\\n        _values[0] = _value;\\n        \\n        operateToken1155(msg.sender,_operator,_from,_ids,_values,_data);\\n        return ERC1155_RECEIVED_VALUE;\\n    }\\n\\n    function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external override returns(bytes4) {\\n        operateToken1155(msg.sender,_operator,_from,_ids,_values,_data);\\n        return ERC1155_BATCH_RECEIVED_VALUE;\\n    }\\n\\n    // ERC165 interface support\\n    function supportsInterface(bytes4 interfaceID) external override pure returns (bool) {\\n        return  interfaceID == 0x01ffc9a7 ||    // ERC165\\n                interfaceID == 0x4e2312e0;      // ERC1155_ACCEPTED ^ ERC1155_BATCH_ACCEPTED;\\n    }\\n    \\n    function operateToken1155(address msgSender, address _operator, address _from, uint256[] memory _ids, uint256[] memory _values, bytes calldata _data) internal virtual;\\n}\\n\\ncontract Config{\\n    \\n    uint256 public constant ONE_DAY = 1 days;\\n    \\n    uint256[10] public  RANKING_AWARD_PERCENT = [10,5,3,1,1,1,1,1,1,1];\\n    \\n    uint256 public constant LAST_STRAW_PERCNET = 5;\\n    \\n    uint256[2] public  OUT_RATE = [1,1];\\n\\n}\\n\\n\\ncontract MiningCore is Config, Ownable, ERC1155TokenReceiver {\\n    \\n    using SafeMath for uint256;\\n    \\n    constructor(MiningPool _pool,IERC1155 _token1155,address payable _developer) {\\n        pool = _pool;\\n        token1155 = _token1155;\\n        developer = _developer;\\n    }\\n    \\n    MiningPool public pool;\\n    \\n    IERC1155 public token1155;\\n    \\n    \\n    uint256 public ORE_AMOUNT = 500000000;\\n    \\n    struct Record{\\n        //提现状态\\n        bool drawStatus;\\n        //挖矿总量\\n        uint256 digGross;\\n        //最后一击\\n        bool lastStraw;\\n       \\n        mapping(uint256=\\u003euint256) disCars;\\n    }\\n    \\n    struct Pair {\\n        uint256[2] amounts;\\n        //挖矿总量\\n        uint256 complete;\\n        //实际挖矿量\\n        uint256 actual;\\n        \\n        address lastStraw;\\n    }\\n    \\n    struct Car{\\n        uint256 sn;\\n        uint256 fertility;\\n        uint256 carry;\\n    }\\n    \\n    //address[] callHelper;\\n    \\n    address payable developer;\\n    \\n    uint256 public version;\\n    \\n    //User acquisition record\\n    //mapping(uint256=\\u003emapping(address=\\u003ebool)) public obtainLogs;\\n    \\n    mapping(uint256=\\u003emapping(address=\\u003eRecord)) public records;\\n    \\n    //Record of each mining period\\n    mapping(uint256=\\u003ePair) public history;\\n    \\n    //Daily output\\n    mapping(uint256=\\u003euint256) public dailyOutput;\\n    \\n    //The number corresponds to the carIndex\\n    uint256[] public carIndex;\\n    \\n    //Each ID corresponds to a car attribute\\n    mapping(uint256=\\u003eCar) public cars;\\n    \\n    mapping(uint256=\\u003e address[10]) public rank;\\n    \\n    event ObtainCar(address indexed userAddress,uint256 indexed _version,uint256 amount );\\n    \\n    event Mining(address indexed userAddress,uint256 indexed _version,uint256[] ,uint256[],uint256 amount);\\n    \\n    event WithdrawAward(address indexed userAddress,uint256 indexed _version,uint256[2] amounts);\\n    \\n    event UpdateRank(address indexed operator);\\n    \\n    event DeveloperFee(uint256 fee1,uint256 fee2);\\n    \\n    event SetCarIndex(uint256 sn,uint256 id,uint256 fertility,uint256 carry);\\n    \\n    event LastStraw(address indexed userAddress,uint256 _version,uint256,uint256,uint256);\\n    \\n    function init() public onlyOwner {\\n        uint256[18] memory _ids = [uint256(1),2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18];\\n        uint256[18] memory _fertilities = [uint256(1),2,5,10,30,100,1,2,5,10,30,100,10,20,50,100,300,1000];\\n        uint256[18] memory _carries = [uint256(0),0,0,0,0,0,10,20,50,100,300,1000,1,2,5,10,30,100];\\n        setCarIndexs(_ids,_fertilities,_carries);\\n    }\\n\\n     //Set vehicle properties\\n    function setCarIndex(uint256 sn,uint256 id,uint256 fertility,uint256 carry) public onlyOwner{\\n        if(sn+1\\u003ecarIndex.length){\\n            carIndex.push(id);\\n            //callHelper.push(address(this));\\n        }else{\\n            carIndex[sn] = id;\\n        }\\n        \\n        cars[id] = Car(sn,fertility,carry);\\n        emit SetCarIndex( sn, id, fertility, carry);\\n    }\\n    \\n    //Batch set vehicle properties\\n    function setCarIndexs(uint256[18] memory ids,uint256[18] memory fertilities,uint256[18] memory carries) private {\\n        for(uint256 i=0;i\\u003cids.length;i++){\\n            setCarIndex(i,ids[i],fertilities[i],carries[i]);\\n        }\\n    }\\n    \\n    function setFeeOwner(address _feeOwner,address factory) external  onlyOwner {\\n        (address[2] memory tokens,) = pool.balanceOf(address(0));\\n        address pair = IUniswapFactory(factory).getPair(tokens[0],tokens[1]);\\n        IUniswapPair(pair).setFeeOwner(_feeOwner);\\n    }\\n    \\n    \\n    function setOracle(uint256 _ORE_AMOUNT) public onlyOwner {\\n        ORE_AMOUNT = _ORE_AMOUNT;\\n    }\\n    \\n    \\n    function operateToken1155(address msgSender,address _operator, address _from, uint256[] memory _ids, uint256[] memory _values, bytes calldata) internal override virtual{\\n        \\n        require(address(token1155)==msgSender,\\\"not allowed\\\");\\n        require(!Address.isContract(_operator),\\\"Contract invocation is not allowed\\\");\\n       \\n        if(_from!=address(0x0)){\\n            mining(_from,_ids,_values);\\n        }\\n    }\\n    \\n\\n    function obtainCar(uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s) public {\\n        require(!pool.lockStatus(msg.sender),\\\"Have been received\\\");\\n\\t\\t\\n\\t\\t     (,uint256[] memory counts,uint256 len,uint256 token1155Amount,uint256 quantity) = cat(msg.sender);\\n            \\n             if(dailyOutput[pool.duration()]==0){\\n                 dailyOutput[pool.duration()] = token1155Amount;\\n             }\\n        \\n        // uint256[] memory carUsable = new uint256[](kinds());\\n        // {\\n        //     (,uint256[] memory counts,uint256 len,uint256 token1155Amount,uint256 quantity) = cat(msg.sender);\\n            \\n        //     if(dailyOutput[pool.duration()]==0){\\n        //         dailyOutput[pool.duration()] = token1155Amount;\\n        //     }\\n        \\n        //     require(quantity\\u003e0\\u0026\\u0026len\\u003e0,\\\"to small\\\");\\n\\n        //     uint256 ratio = uint256(keccak256(abi.encodePacked(block.number, block.timestamp)));\\n            \\n        //     uint256 BASIC = len*10;\\n        //     uint256 bn;\\n        //     if(quantity\\u003eBASIC){\\n        //         bn = (quantity-BASIC)/len+1;\\n        //         quantity -= (quantity-9*len);\\n        //     }\\n            \\n        //     for(uint256 i = 0;i\\u003cquantity;i++){\\n        //          uint256 sn = (ratio\\u003e\\u003ei)%len;\\n        //          carUsable[sn]++;\\n        //     }\\n            \\n        //     for(uint256 j;j\\u003clen;j++){\\n        //         carUsable[j]+= bn;\\n        //         if(carUsable[j]\\u003ecounts[j]){\\n        //             carUsable[j] = counts[j];\\n        //         }\\n        //     }\\n\\n        //     emit ObtainCar(msg.sender,version,quantity);\\n        // }\\n        \\n        pool.lock(msg.sender,address(this),nonce,expiry,allowed,v,r,s);\\n        //token1155.safeBatchTransferFrom(address(this),msg.sender,carIndex,carUsable,\\\"success\\\");\\n \\n    }\\n    \\n    function withdrawAward(uint256 _version) public {\\n        \\n       require(!records[_version][msg.sender].drawStatus,\\\"have withdrawal\\\");\\n\\t   require(_version\\u003cversion,\\\"Event not over\\\");\\n        \\n       (uint256[2] memory amounts) =  getVersionAward(_version,msg.sender);\\n\\n       records[_version][msg.sender].drawStatus = true;\\n       \\n       pool.allot(msg.sender,amounts);\\n       \\n       emit WithdrawAward(msg.sender,_version,amounts);\\n       \\n    }\\n    \\n    \\n    function getVersionAward(uint256 _version,address userAddress) public view returns(uint256[2] memory amounts){\\n        Pair memory pair = history[_version];\\n        return getPredictAward(_version,userAddress,pair);\\n    }\\n    \\n    function getPredictAward(uint256 _version,address userAddress,Pair memory pair) internal view returns(uint256[2] memory amounts){\\n        Record storage record = records[_version][userAddress];\\n        \\n        uint256 ranking = getRanking(userAddress,_version);\\n\\n        for(uint8 i = 0;i\\u003c2;i++){\\n            uint256 baseAmount = pair.amounts[i].mul(70).div(100);\\n            uint256 awardAmount = pair.amounts[i].mul(30).div(100);\\n            \\n            amounts[i] = amounts[i].add(baseAmount.mul(record.digGross).div(ORE_AMOUNT));\\n            \\n            if(ranking\\u003c10){\\n                amounts[i] = amounts[i].add(awardAmount.mul(RANKING_AWARD_PERCENT[ranking]).div(30));\\n            }\\n            \\n            if(record.lastStraw){\\n                amounts[i] = amounts[i].add(awardAmount.mul(LAST_STRAW_PERCNET).div(30));\\n            }\\n        }\\n    }\\n\\n    function getGlobalStats(uint256 _version) external view returns (uint256[5] memory stats,address lastStrawUser) {\\n        \\n        Pair memory pair = history[_version];\\n        if(_version==version){\\n            (,uint256[2] memory balances) = pool.balanceOf(address(this));\\n            pair.amounts = balances;\\n        }\\n        \\n        stats[0] = pair.amounts[0];\\n        stats[1] = pair.amounts[1];\\n        stats[2] = pair.complete;\\n        stats[3] = pair.actual;\\n        stats[4] = (pool.duration()+1)*ONE_DAY;\\n        lastStrawUser = pair.lastStraw;\\n  \\n    }\\n    \\n    \\n    function crown(uint256 _version) external view returns (address[10] memory ranking,uint256[10] memory digGross){\\n        ranking = sortRank(_version);\\n        for(uint8 i =0;i\\u003cranking.length;i++){\\n            digGross[i] = getDigGross(ranking[i],_version);\\n        }\\n    }\\n    \\n    \\n    function getPersonalStats(uint256 _version,address userAddress) external view returns (uint256[8] memory stats,bool[3] memory stats2,uint256[] memory departs){\\n        Record storage record = records[_version][userAddress];\\n         \\n        (uint256 id,uint256 investment,uint256 freezeTime) = pool.users(userAddress);\\n        stats[0] = investment;\\n        stats[1] = record.digGross;\\n         \\n        Pair memory pair = history[_version];\\n         \\n        if(_version==version){\\n            (,uint256[2] memory balances) = pool.balanceOf(address(this));\\n            pair.amounts = balances;\\n        }\\n         \\n        uint256[2] memory amounts = getPredictAward(_version,userAddress,pair);\\n         \\n        stats[2] = amounts[1];\\n        stats[3] = amounts[0];\\n        stats[4] = id;\\n        stats[5] = freezeTime;\\n        stats[6] = getRanking(userAddress,_version)+1;\\n         \\n        stats2[0] = record.drawStatus;\\n        stats2[1] = record.lastStraw;\\n        stats2[2] = pool.lockStatus(userAddress);\\n         \\n        departs = new uint256[](kinds());\\n        uint256 total;\\n        for(uint256 i =0;i\\u003ckinds();i++){\\n            uint256 depart = getDepartCars(_version,userAddress,carIndex[i]);\\n            departs[i] = depart;\\n            total = total.add(depart);\\n        }\\n        stats[7] = total;\\n        \\n     }\\n     \\n\\n    function getDepartCars(uint256 _version,address userAddress,uint256 _carId) public view returns(uint256){\\n        return records[_version][userAddress].disCars[_carId];\\n    }\\n    \\n    \\n    \\n    function mining(address userAddress,uint256[] memory ids,uint256[] memory amounts) internal returns(uint256){\\n        Pair storage pair = history[version];\\n        require(ids.length\\u003e0\\u0026\\u0026ids.length == amounts.length,\\\"error\\\");\\n        \\n        uint256 carFertility;\\n        uint256 carCarry;\\n        Record storage record = records[version][userAddress];\\n        uint256 output;\\n        for(uint256 i = 0;i\\u003cids.length;i++){\\n            Car memory car = cars[ids[i]];\\n            carFertility = carFertility.add(car.fertility.mul(amounts[i]));\\n            carCarry = carCarry.add(car.carry.mul(amounts[i]));\\n            record.disCars[ids[i]] = record.disCars[ids[i]].add(amounts[i]);\\n        }\\n        \\n        if(carFertility\\u003ecarCarry){\\n            output = carCarry;\\n        }else{\\n            output = carFertility;\\n        }\\n        \\n        uint256 miningQuantity = pair.complete.add(carFertility);\\n        if(miningQuantity\\u003e=ORE_AMOUNT){ \\n            if(output\\u003eORE_AMOUNT.sub(pair.complete))  output = ORE_AMOUNT.sub(pair.complete);\\n            \\n            emit LastStraw(userAddress,version,carFertility,carCarry,output);\\n            lastStraw(userAddress,pair);\\n        }\\n        \\n        record.digGross = record.digGross.add(output);\\n        pair.complete = pair.complete.add(carFertility);\\n        pair.actual = pair.actual.add(output);\\n        updateRank(userAddress);\\n        \\n        token1155.safeBatchTransferFrom(address(this),owner(),ids,amounts,\\\"success\\\");\\n        \\n        emit Mining(userAddress,version,ids,amounts,output);\\n        return output;\\n    }\\n    \\n    function getRanking(address userAddress,uint256 _version) public view returns(uint256){\\n        address[10] memory rankingList = sortRank(_version);\\n        uint256 ranking = 10;\\n        for(uint8 i =0;i\\u003crankingList.length;i++){\\n            if(userAddress == rankingList[i]){\\n                ranking = i;\\n                break;\\n            }\\n        }\\n        return ranking;\\n    }\\n    \\n    function pickUp(address[10] memory rankingList,address userAddress) internal view returns (uint256 sn,uint256 minDig){\\n        \\n        minDig = getDigGross(rankingList[0]);\\n        for(uint8 i =0;i\\u003crankingList.length;i++){\\n            if(rankingList[i]==userAddress){\\n                return (rankingList.length,0);\\n            }\\n            if(getDigGross(rankingList[i])\\u003cminDig){\\n                minDig = getDigGross(rankingList[i]);\\n                sn = i;\\n            }\\n        }\\n        \\n        return (sn,minDig);\\n    }\\n    \\n    function updateRank(address userAddress) internal {\\n        address[10] memory rankingList = rank[version];\\n        \\n        (uint256 sn,uint256 minDig) = pickUp(rankingList,userAddress);\\n        if(sn!=rankingList.length){\\n            if(minDig\\u003c getDigGross(userAddress)){\\n                rankingList[sn] = userAddress;\\n            }\\n            rank[version] = rankingList;\\n            emit UpdateRank(userAddress);\\n        }\\n    }\\n    \\n    function sortRank(uint256 _version) public view returns(address[10] memory ranking){\\n        ranking = rank[_version];\\n        \\n        address tmp;\\n        for(uint8 i = 1;i\\u003c5;i++){\\n            for(uint8 j = 0;j\\u003c5-i;j++){\\n                if(getDigGross(ranking[j],_version)\\u003cgetDigGross(ranking[j+1],_version)){\\n                    tmp = ranking[j];\\n                    ranking[j] = ranking[j+1];\\n                    ranking[j+1] = tmp;\\n                }\\n            }\\n        }\\n        return ranking;\\n    }\\n    \\n    function getDigGross(address userAddress) internal view returns(uint256){\\n        return getDigGross(userAddress,version);\\n    }\\n    \\n    function getDigGross(address userAddress,uint256 _version) internal view returns(uint256){\\n        return records[_version][userAddress].digGross;\\n    }\\n    \\n    function lastStraw(address userAddress,Pair storage pair) internal{\\n        \\n        (address[2] memory tokens,uint256[2] memory amounts) = pool.balanceOf(address(this));\\n        \\n        for(uint8 i;i\\u003camounts.length;i++){\\n            TransferHelper.safeApprove(tokens[i],address(pool),amounts[i]);\\n        }\\n        pool.deposit(amounts);\\n        pair.amounts = amounts;\\n\\n        pair.lastStraw = userAddress;\\n        records[version][userAddress].lastStraw = true;    \\n        \\n        developerFee(pair);\\n        version++;  \\n        \\n    }\\n    \\n     //项目方收款\\n    function developerFee(Pair storage pair) internal{\\n     \\n        uint256[2] memory amounts;\\n        for(uint256 i = 0;i\\u003camounts.length;i++){\\n            amounts[i] = pair.amounts[i].mul(70).mul(ORE_AMOUNT.sub(pair.actual)).div(ORE_AMOUNT).div(100);\\n        }\\n        pool.allot(developer,amounts);\\n        \\n        emit DeveloperFee(amounts[0],amounts[1]);\\n    }\\n    \\n    \\n    \\n    function cat(address userAddress) public view returns(uint256[] memory,uint256[] memory counts,uint256 len,uint256 token1155Amount,uint256 quantity){\\n        \\n        ( ,uint256 investment, ) = pool.users(userAddress);\\n        \\n        (counts,token1155Amount) = determinate(); \\n\\n        uint256 dailyTokenAmount = dailyOutput[pool.duration()];\\n        if(dailyTokenAmount==0){\\n            dailyTokenAmount = token1155Amount;\\n        }\\n        uint256 totalSupply = pool.totalSupply();\\n        quantity = investment.mul(dailyTokenAmount).div(totalSupply);\\n        \\n        return (carIndex,counts,kinds(),token1155Amount,quantity);\\n\\n    }\\n    \\n    function determinate() public view returns(uint256[] memory counts,uint256 token1155Amount){\\n        address _owner = owner();\\n        counts = new uint256[](kinds());\\n        for(uint8 i = 0;i\\u003ckinds();i++){\\n            uint256 count = token1155.balanceOf(_owner,carIndex[i]);\\n            counts[i] = count;\\n            token1155Amount+=count;\\n        }\\n\\t\\t\\n        for(uint8 i = 0;i\\u003ckinds();i++){\\n            token1155Amount+=counts[i];\\n        }\\n        \\n    }\\n    \\n    function kinds() internal view returns (uint256) {\\n        return carIndex.length;\\n    }\\n}\\n\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes(\\u0027approve(address,uint256)\\u0027)));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))), \\u0027TransferHelper: APPROVE_FAILED\\u0027);\\n    }\\n\\n    function safeTransfer(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes(\\u0027transfer(address,uint256)\\u0027)));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))), \\u0027TransferHelper: TRANSFER_FAILED\\u0027);\\n    }\\n\\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\\n        // bytes4(keccak256(bytes(\\u0027transferFrom(address,address,uint256)\\u0027)));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))), \\u0027TransferHelper: TRANSFER_FROM_FAILED\\u0027);\\n    }\\n\\n    function safeTransferETH(address to, uint value) internal {\\n        (bool success,) = to.call{value:value}(new bytes(0));\\n        require(success, \\u0027TransferHelper: ETH_TRANSFER_FAILED\\u0027);\\n    }\\n}\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\n\\nimport \\\"./SafeMath.sol\\\";\\n\\ncontract Context {\\n    \\n    \\n    constructor () { }\\n    \\n\\n    function _msgSender() internal view returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view returns (bytes memory) {\\n        this; \\n        return msg.data;\\n    }\\n}\\n\\ncontract Ownable is Context {\\n    \\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    \\n    constructor () {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    \\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    \\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    \\n    function isOwner() public view returns (bool) {\\n        return _msgSender() == _owner;\\n    }\\n\\n    \\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    \\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    \\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\n\\nlibrary SafeMath {\\n    \\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    \\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    \\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    \\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        \\n        \\n        \\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    \\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    \\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        \\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        \\n\\n        return c;\\n    }\\n\\n    \\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    \\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract MiningPool\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"contract IERC1155\",\"name\":\"_token1155\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_developer\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee2\",\"type\":\"uint256\"}],\"name\":\"DeveloperFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_version\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"LastStraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_version\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Mining\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_version\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ObtainCar\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fertility\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"carry\",\"type\":\"uint256\"}],\"name\":\"SetCarIndex\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"UpdateRank\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_version\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[2]\",\"name\":\"amounts\",\"type\":\"uint256[2]\"}],\"name\":\"WithdrawAward\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"LAST_STRAW_PERCNET\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ONE_DAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ORE_AMOUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"OUT_RATE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"RANKING_AWARD_PERCENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"carIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"cars\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"sn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fertility\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"carry\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"cat\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"counts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1155Amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_version\",\"type\":\"uint256\"}],\"name\":\"crown\",\"outputs\":[{\"internalType\":\"address[10]\",\"name\":\"ranking\",\"type\":\"address[10]\"},{\"internalType\":\"uint256[10]\",\"name\":\"digGross\",\"type\":\"uint256[10]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dailyOutput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"determinate\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"counts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"token1155Amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_version\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_carId\",\"type\":\"uint256\"}],\"name\":\"getDepartCars\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_version\",\"type\":\"uint256\"}],\"name\":\"getGlobalStats\",\"outputs\":[{\"internalType\":\"uint256[5]\",\"name\":\"stats\",\"type\":\"uint256[5]\"},{\"internalType\":\"address\",\"name\":\"lastStrawUser\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_version\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getPersonalStats\",\"outputs\":[{\"internalType\":\"uint256[8]\",\"name\":\"stats\",\"type\":\"uint256[8]\"},{\"internalType\":\"bool[3]\",\"name\":\"stats2\",\"type\":\"bool[3]\"},{\"internalType\":\"uint256[]\",\"name\":\"departs\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_version\",\"type\":\"uint256\"}],\"name\":\"getRanking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_version\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getVersionAward\",\"outputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"amounts\",\"type\":\"uint256[2]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"history\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"complete\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lastStraw\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"obtainCar\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"contract MiningPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rank\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"records\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"drawStatus\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"digGross\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"lastStraw\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fertility\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"carry\",\"type\":\"uint256\"}],\"name\":\"setCarIndex\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"}],\"name\":\"setFeeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ORE_AMOUNT\",\"type\":\"uint256\"}],\"name\":\"setOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_version\",\"type\":\"uint256\"}],\"name\":\"sortRank\",\"outputs\":[{\"internalType\":\"address[10]\",\"name\":\"ranking\",\"type\":\"address[10]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token1155\",\"outputs\":[{\"internalType\":\"contract IERC1155\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_version\",\"type\":\"uint256\"}],\"name\":\"withdrawAward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MiningCore","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000c26104ac636297a7f0adae2bf35a13362b8655e40000000000000000000000007149eceefa2562e81fd4c20264f81af14de2dc55000000000000000000000000e689cb9657b0f1b4907cc83abc8d1fc619b7cdda","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://60232318f1a9ca2292d8cde8aae987b7bc49093a4f5f376655154c62ba938ab2"}]}