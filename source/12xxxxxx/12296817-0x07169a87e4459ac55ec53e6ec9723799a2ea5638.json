{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.6.6;\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface IToken {\r\n\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function balanceOf(address account) external view returns (uint256);\r\n\r\n  function name() external view returns (string memory);\r\n\r\n  function symbol() external view returns (string memory);\r\n\r\n  function decimals() external view returns (uint8);\r\n\r\n  function intervalLength() external returns (uint256);\r\n  \r\n  function owner() external view returns (address);\r\n  \r\n  function burn(uint256 _amount) external;\r\n  \r\n  function renounceMinter() external;\r\n  \r\n  function mint(address account, uint256 amount) external returns (bool);\r\n\r\n  function lock(\r\n    address recipient,\r\n    uint256 amount,\r\n    uint256 blocks,\r\n    bool deposit\r\n  ) external returns (bool);\r\n\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n  \r\n  function transfer(address to, uint256 amount) external returns (bool success);\r\n\r\n}\r\n\r\ninterface IDutchAuction {\r\n  function auctionEnded() external view returns (bool);\r\n\r\n  function finaliseAuction() external;\r\n}\r\n\r\n\r\ninterface IDutchSwapFactory {\r\n  function deployDutchAuction(\r\n    address _token,\r\n    uint256 _tokenSupply,\r\n    uint256 _startDate,\r\n    uint256 _endDate,\r\n    address _paymentCurrency,\r\n    uint256 _startPrice,\r\n    uint256 _minimumPrice,\r\n    address _wallet\r\n  ) external returns (address dutchAuction);\r\n}\r\n\r\ninterface IPriceOracle {\r\n\r\n  function consult(uint256 amountIn) external view returns (uint256 amountOut);\r\n\r\n  function update() external;\r\n}\r\n\r\ncontract AuctionManager {\r\n  using SafeMath for uint256;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  // used as factor when dealing with %\r\n  uint256 constant ACCURACY = 1e4;\r\n  // when 95% at market price, start selling\r\n  uint256 public sellThreshold;\r\n  // cap auctions at certain amount of $TRDL minted\r\n  uint256 public dilutionBound;\r\n  // stop selling when volume small\r\n  // uint256 public dustThreshold; set at dilutionBound / 52\r\n  // % start_price above estimate, and % min_price below estimate\r\n  uint256 public priceSpan;\r\n  // auction duration\r\n  uint256 public auctionDuration;\r\n\r\n  IToken private strudel;\r\n  IToken private vBtc;\r\n  IToken private gStrudel;\r\n  IPriceOracle private btcPriceOracle;\r\n  IPriceOracle private vBtcPriceOracle;\r\n  IPriceOracle private strudelPriceOracle;\r\n  IDutchSwapFactory private auctionFactory;\r\n\r\n  IDutchAuction public currentAuction;\r\n  mapping(address => uint256) public lockTimeForAuction;\r\n\r\n  constructor(\r\n    address _strudelAddr,\r\n    address _gStrudel,\r\n    address _vBtcAddr,\r\n    address _btcPriceOracle,\r\n    address _vBtcPriceOracle,\r\n    address _strudelPriceOracle,\r\n    address _auctionFactory\r\n  ) public {\r\n    strudel = IToken(_strudelAddr);\r\n    gStrudel = IToken(_gStrudel);\r\n    vBtc = IToken(_vBtcAddr);\r\n    btcPriceOracle = IPriceOracle(_btcPriceOracle);\r\n    vBtcPriceOracle = IPriceOracle(_vBtcPriceOracle);\r\n    strudelPriceOracle = IPriceOracle(_strudelPriceOracle);\r\n    auctionFactory = IDutchSwapFactory(_auctionFactory);\r\n    sellThreshold = 9500; // vBTC @ 95% of BTC price or above\r\n    dilutionBound = 70; // 0.7% of $TRDL total supply\r\n    priceSpan = 2500; // 25%\r\n    auctionDuration = 84600; // ~23,5h\r\n  }\r\n\r\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function _getDiff(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a > b) {\r\n      return a - b;\r\n    }\r\n    return b - a;\r\n  }\r\n\r\n  function decimals() public view returns (uint8) {\r\n      return gStrudel.decimals();\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC20-totalSupply}.\r\n   */\r\n  function totalSupply() public view returns (uint256) {\r\n      return gStrudel.totalSupply();\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC20-balanceOf}.\r\n   */\r\n  function balanceOf(address account) public view returns (uint256) {\r\n      return gStrudel.balanceOf(account);\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(strudel.owner() == msg.sender, \"Ownable: caller is not the owner\");\r\n    _;\r\n  }\r\n\r\n  function updateOracles() public {\r\n    try btcPriceOracle.update() {\r\n      // do nothing\r\n    } catch Error(string memory) {\r\n      // do nothing\r\n    } catch (bytes memory) {\r\n      // do nothing\r\n    }\r\n    try vBtcPriceOracle.update() {\r\n      // do nothing\r\n    } catch Error(string memory) {\r\n      // do nothing\r\n    } catch (bytes memory) {\r\n      // do nothing\r\n    }\r\n    try strudelPriceOracle.update() {\r\n      // do nothing\r\n    } catch Error(string memory) {\r\n      // do nothing\r\n    } catch (bytes memory) {\r\n      // do nothing\r\n    }\r\n  }\r\n\r\n  function rotateAuctions() external {\r\n    if (address(currentAuction) != address(0)) {\r\n      require(currentAuction.auctionEnded(), \"previous auction hasn't ended\");\r\n      try currentAuction.finaliseAuction() {\r\n        // do nothing\r\n      } catch Error(string memory) {\r\n        // do nothing\r\n      } catch (bytes memory) {\r\n        // do nothing\r\n      }\r\n      uint256 studelReserves = strudel.balanceOf(address(this));\r\n      if (studelReserves > 0) {\r\n        strudel.burn(studelReserves);\r\n      }\r\n    }\r\n\r\n    updateOracles();\r\n\r\n    // get prices\r\n    uint256 btcPriceInEth = btcPriceOracle.consult(1e18);\r\n    uint256 vBtcPriceInEth = vBtcPriceOracle.consult(1e18);\r\n    uint256 strudelPriceInEth = strudelPriceOracle.consult(1e18);\r\n\r\n    // measure outstanding supply\r\n    uint256 vBtcOutstandingSupply = vBtc.totalSupply();\r\n    uint256 strudelSupply = strudel.totalSupply();\r\n    uint256 vBtcAmount = vBtc.balanceOf(address(this));\r\n    vBtcOutstandingSupply -= vBtcAmount;\r\n\r\n    // calculate vBTC supply imbalance in ETH\r\n    uint256 imbalance = _getDiff(btcPriceInEth, vBtcPriceInEth).mul(vBtcOutstandingSupply);\r\n\r\n    uint256 cap = strudelSupply.mul(dilutionBound).mul(strudelPriceInEth).div(ACCURACY);\r\n    // cap by dillution bound\r\n    imbalance = min(\r\n      cap,\r\n      imbalance\r\n    );\r\n\r\n    // pause if imbalance below dust threshold\r\n    if (imbalance.div(strudelPriceInEth) < strudelSupply.mul(dilutionBound).div(52).div(ACCURACY)) {\r\n      // pause auctions\r\n      currentAuction = IDutchAuction(address(0));\r\n      return;\r\n    }\r\n\r\n    // determine what kind of auction we want\r\n    uint256 priceRelation = btcPriceInEth.mul(ACCURACY).div(vBtcPriceInEth);\r\n    if (priceRelation < ACCURACY.mul(ACCURACY).div(sellThreshold)) {\r\n      // cap vBtcAmount by imbalance in vBTC\r\n      vBtcAmount = min(vBtcAmount, imbalance.div(vBtcPriceInEth));\r\n      // calculate vBTC price\r\n      imbalance = vBtcPriceInEth.mul(1e18).div(strudelPriceInEth);\r\n      // auction off some vBTC\r\n      vBtc.approve(address(auctionFactory), vBtcAmount);\r\n      currentAuction = IDutchAuction(\r\n        auctionFactory.deployDutchAuction(\r\n          address(vBtc),\r\n          vBtcAmount,\r\n          now,\r\n          now + auctionDuration,\r\n          address(strudel),\r\n          imbalance.mul(ACCURACY.add(priceSpan)).div(ACCURACY), // startPrice\r\n          imbalance.mul(ACCURACY.sub(priceSpan)).div(ACCURACY), // minPrice\r\n          address(this)\r\n        )\r\n      );\r\n    } else {\r\n\r\n      // calculate price in vBTC\r\n      vBtcAmount = strudelPriceInEth.mul(1e18).div(vBtcPriceInEth);\r\n      // auction off some $TRDL\r\n      currentAuction = IDutchAuction(\r\n        auctionFactory.deployDutchAuction(\r\n          address(this),\r\n          imbalance.div(strudelPriceInEth), // calculate imbalance in $TRDL\r\n          now,\r\n          now + auctionDuration,\r\n          address(vBtc),\r\n          vBtcAmount.mul(ACCURACY.add(priceSpan)).div(ACCURACY), // startPrice\r\n          vBtcAmount.mul(ACCURACY.sub(priceSpan)).div(ACCURACY), // minPrice\r\n          address(this)\r\n        )\r\n      );\r\n\r\n      // if imbalance >= dillution bound, use max lock (52 weeks)\r\n      // if imbalance < dillution bound, lock shorter\r\n      lockTimeForAuction[address(currentAuction)] = gStrudel.intervalLength().mul(52).mul(imbalance).div(cap);\r\n    }\r\n  }\r\n\r\n  function setSellThreshold(uint256 _threshold) external onlyOwner {\r\n    require(_threshold >= 6000, \"threshold below 60% minimum\");\r\n    require(_threshold <= 12000, \"threshold above 120% maximum\");\r\n    sellThreshold = _threshold;\r\n  }\r\n\r\n  function setDulutionBound(uint256 _dilutionBound) external onlyOwner {\r\n    require(_dilutionBound <= 1000, \"dilution bound above 10% max value\");\r\n    dilutionBound = _dilutionBound;\r\n  }\r\n\r\n  function setPriceSpan(uint256 _priceSpan) external onlyOwner {\r\n    require(_priceSpan > 1000, \"price span should have at least 10%\");\r\n    require(_priceSpan < ACCURACY, \"price span larger accuracy\");\r\n    priceSpan = _priceSpan;\r\n  }\r\n\r\n  function setAuctionDuration(uint256 _auctionDuration) external onlyOwner {\r\n    require(_auctionDuration >= 3600, \"auctions should run at laest for 1 hour\");\r\n    require(_auctionDuration <= 604800, \"auction duration should be less than week\");\r\n    auctionDuration = _auctionDuration;\r\n  }\r\n\r\n  function renounceMinter() external onlyOwner {\r\n    strudel.renounceMinter();\r\n  }\r\n\r\n  function swipe(address tokenAddr) external onlyOwner {\r\n    IToken token = IToken(tokenAddr);\r\n    token.transfer(strudel.owner(), token.balanceOf(address(this)));\r\n  }\r\n\r\n  // In deployDutchAuction, approve and transferFrom are called\r\n  // In initDutchAuction, transferFrom is called again\r\n  // In DutchAuction, transfer is called to either payout, or return money to AuctionManager\r\n\r\n  function transferFrom(address, address, uint256) public pure returns (bool) {\r\n    return true;\r\n  }\r\n\r\n  function approve(address, uint256) public pure returns (bool) {\r\n    return true;\r\n  }\r\n\r\n  function transfer(address to, uint256 amount) public returns (bool success) {\r\n    // require sender is our Auction\r\n    address auction = msg.sender;\r\n    require(lockTimeForAuction[auction] > 0, \"Caller is not our auction\");\r\n\r\n    // if recipient is AuctionManager, it means we are doing a refund -> do nothing\r\n    if (to == address(this)) return true;\r\n\r\n    uint256 blocks = lockTimeForAuction[auction];\r\n    strudel.mint(address(this), amount);\r\n    strudel.approve(address(gStrudel), amount);\r\n    gStrudel.lock(to, amount, blocks, false);\r\n    return true;\r\n  }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strudelAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_gStrudel\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vBtcAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_btcPriceOracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vBtcPriceOracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_strudelPriceOracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_auctionFactory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auctionDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentAuction\",\"outputs\":[{\"internalType\":\"contract IDutchAuction\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dilutionBound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lockTimeForAuction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceSpan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rotateAuctions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_auctionDuration\",\"type\":\"uint256\"}],\"name\":\"setAuctionDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_dilutionBound\",\"type\":\"uint256\"}],\"name\":\"setDulutionBound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_priceSpan\",\"type\":\"uint256\"}],\"name\":\"setPriceSpan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_threshold\",\"type\":\"uint256\"}],\"name\":\"setSellThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"}],\"name\":\"swipe\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateOracles\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"AuctionManager","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000297d33e17e61c2ddd812389c2105193f8348188a00000000000000000000000064d506ba9ba0cc9f0326cc72f134e754df0e2aff000000000000000000000000e1406825186d63980fd6e2ec61888f7b91c4bae4000000000000000000000000f7d08f4f4523895d080eac4cca74a7c6e18cbe8600000000000000000000000091ae9424b706616a531831fb4a8988726b398837000000000000000000000000ef5c7f2058db2ccb103484e664b7df8e1f1b889c0000000000000000000000003cb6fb749a1fd088e1c524cba27f25b5fdd105c8","EVMVersion":"Default","Library":"","LicenseType":"MPL-2.0","Proxy":"0","Implementation":"","SwarmSource":"ipfs://5c827d2ad6902396b0be0f7f6942efe3b2d6aa14a859580c51c9b09e90f40e45"}]}