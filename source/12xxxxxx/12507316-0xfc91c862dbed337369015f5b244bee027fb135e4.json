{"status":"1","message":"OK","result":[{"SourceCode":"//SPDX-License-Identifier: MIT\r\npragma solidity ^0.7.3;\r\npragma experimental SMTChecker;\r\n\r\n\r\ninterface ERC20If {\r\n  function balanceOf(address _who) external view returns (uint256);\r\n  function transfer(address _to, uint256 _value) external returns (bool);\r\n}\r\n\r\ncontract MultiSig{\r\n    receive() external payable {}\r\n\r\n    uint256 public nonce = 0;\r\n\r\n    int private withdrawFlag1 = 0;\r\n    int private withdrawFlag2 = 0;\r\n    int private withdrawFlag3 = 0;\r\n\r\n    int private closeFlag1 = 0;\r\n    int private closeFlag2 = 0;\r\n    int private closeFlag3 = 0;\r\n\r\n    address[] private owners=new address[](3);\r\n\r\n    constructor(address _owner1,address _owner2,address _owner3)\r\n    {\r\n        require(_owner1!=_owner2);\r\n        require(_owner1!=_owner3);\r\n        require(_owner2!=_owner3);\r\n\r\n        owners[0] = _owner1;\r\n        owners[1] = _owner2;\r\n        owners[2] = _owner3;\r\n    }\r\n\r\n    fallback() external payable {}\r\n\r\n    function getMessageToSignature(address payable[] memory dests, uint256[] memory values) private view returns (bytes memory) {\r\n        return abi.encode(nonce, dests, values, this);\r\n    }\r\n\r\n//测试使用\r\n//    function testABIEncode(address[] memory dests, uint256[] memory values,\r\n  //                  uint8 v1, bytes32 r1, bytes32 s1,\r\n    //                uint8 v2, bytes32 r2, bytes32 s2) public view returns (bytes memory) {\r\n      //  return abi.encode(dests, values,v1,r1, s1, v2, r2, s2);\r\n    //}\r\n\r\n    function recoverAddress(bytes32 message, uint8 v, bytes32 r, bytes32 s) private pure returns (address) {\r\n        return ecrecover(message, v, r, s);\r\n    }\r\n\r\n    function hash(bytes memory data) private pure returns (bytes32) {\r\n        return sha256(data);\r\n    }\r\n\r\n    function _validAddress(address addr) private view returns (bool) {\r\n        return owners[0] == addr || owners[1] == addr || owners[2] == addr;\r\n    }\r\n\r\n    function spend(address payable[] memory dests, uint256[] memory values,\r\n                    uint8 v1, bytes32 r1, bytes32 s1,\r\n                    uint8 v2, bytes32 r2, bytes32 s2) public payable {\r\n        require(dests.length > 0 && dests.length == values.length);\r\n        uint256  value;\r\n        for (uint i = 0; i < values.length; ++i){\r\n            value += values[i];\r\n            assert(value >= values[i]);\r\n        }\r\n        require(address(this).balance >= value, \"insufficient funds\");\r\n\r\n        bytes32 h=hash((getMessageToSignature(dests, values)));\r\n        address addr1=recoverAddress(h, v1, r1, s1);\r\n        address addr2=recoverAddress(h, v2, r2, s2);\r\n        require(addr1 != addr2, \"failed to recover address\");\r\n        require(_validAddress(addr1), \"invalid address\");\r\n        require(_validAddress(addr2), \"invalid address\");\r\n        nonce = nonce + 1;\r\n\r\n        for (uint i = 0; i < dests.length; ++i) {\r\n            // dests[i].transfer(values[i]);\r\n            (bool success, ) =dests[i].call{value:values[i]}(\"\");\r\n            require(success, \"transfer failed.\");\r\n        }\r\n    }\r\n\r\n    function withdrawAll() public payable {\r\n        require(_validAddress(msg.sender), \"invalid address\");\r\n        if (msg.sender == owners[0]) {\r\n            withdrawFlag1 = 1;\r\n        }\r\n        else if (msg.sender == owners[1]) {\r\n            withdrawFlag2 = 1;\r\n        }\r\n        else if (msg.sender == owners[2]) {\r\n            withdrawFlag3 = 1;\r\n        }\r\n        else {\r\n                assert(false);\r\n        }\r\n\r\n        if ((withdrawFlag1+withdrawFlag2+withdrawFlag3)>=2) {\r\n            withdrawFlag1 = 0;\r\n            withdrawFlag2 = 0;\r\n            withdrawFlag3 = 0;\r\n            (bool success, ) = msg.sender.call{value:address(this).balance}(\"\");\r\n            if (!success) {\r\n               revert(\"withdraw all failed\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function close() public payable {\r\n        require(_validAddress(msg.sender), \"invalid address\");\r\n        if (msg.sender == owners[0]) {\r\n            closeFlag1 = 1;\r\n        }\r\n        else if (msg.sender == owners[1]) {\r\n            closeFlag2 = 1;\r\n        }\r\n        else if (msg.sender == owners[2]) {\r\n            closeFlag3 = 1;\r\n        }\r\n        else {\r\n                assert(false);\r\n            }\r\n\r\n        if ((closeFlag1+closeFlag2+closeFlag3)>=2){\r\n            selfdestruct(msg.sender);\r\n        }\r\n    }\r\n\r\n    function transferERC20(address payable[] memory dests, uint256[] memory values,\r\n                    uint8 v1, bytes32 r1, bytes32 s1,\r\n                    uint8 v2, bytes32 r2, bytes32 s2, address erc20Token) public  {\r\n        require(dests.length > 0 && dests.length == values.length);\r\n        uint256  value;\r\n        for (uint i = 0; i < values.length; ++i){\r\n            value += values[i];\r\n            assert(value >= values[i]);\r\n        }\r\n        ERC20If _erc20=(ERC20If)(erc20Token);\r\n        require(_erc20.balanceOf(address(this)) >= value, \"insufficient ERC20 funds\");\r\n\r\n        require(\r\n            verifySignature4ERC20Token(dests,values,v1,r1,s1,v2,r2,s2,erc20Token),\r\n            \"invalid signature.\");\r\n\r\n        nonce = nonce + 1;\r\n\r\n        for (uint i = 0; i < dests.length; ++i) {\r\n            require(\r\n                (_erc20).transfer(dests[i],values[i]),\r\n                 \"transfer erc20Token failed\");\r\n        }\r\n    }\r\n\r\n    function verifySignature4ERC20Token(address payable[] memory dests, uint256[] memory values,\r\n                    uint8 v1, bytes32 r1, bytes32 s1,\r\n                    uint8 v2, bytes32 r2, bytes32 s2, address erc20) private view returns (bool) {\r\n        bytes32 h=hash(getMessageToSignature4ERC20Token(dests, values,erc20));\r\n        address addr1=recoverAddress(h, v1, r1, s1);\r\n        address addr2=recoverAddress(h, v2, r2, s2);\r\n        require(addr1 != addr2, \"failed to recover address\");\r\n        require(_validAddress(addr1), \"invalid address\");\r\n        require(_validAddress(addr2), \"invalid address\");\r\n        return true;\r\n    }\r\n\r\n    function getMessageToSignature4ERC20Token(address payable[] memory dests,\r\n    uint256[] memory values, address erc20) public view returns (bytes memory) {\r\n        return abi.encode(nonce, dests, values, erc20);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner3\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"close\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable[]\",\"name\":\"dests\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"erc20\",\"type\":\"address\"}],\"name\":\"getMessageToSignature4ERC20Token\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable[]\",\"name\":\"dests\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"uint8\",\"name\":\"v1\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r1\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s1\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v2\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r2\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s2\",\"type\":\"bytes32\"}],\"name\":\"spend\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable[]\",\"name\":\"dests\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"uint8\",\"name\":\"v1\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r1\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s1\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v2\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r2\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s2\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"erc20Token\",\"type\":\"address\"}],\"name\":\"transferERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"MultiSig","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000006190a856ac79a44874ffc0cb0f2b20e8fee7ce29000000000000000000000000bb8baaee0f8a686d7007f4acc187e6981eb0eda7000000000000000000000000e6b45be55fea86983f123ee99f38376cbae2f6bf","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://45fc22cba57fb12c98c55c2d785087bb029648fa923ff3ade0c7d76a2b2670c2"}]}