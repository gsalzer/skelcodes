{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.3;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n *\r\n * In order to transfer ownership, a recipient must be specified, at which point\r\n * the specified recipient can call `acceptOwnership` and take ownership.\r\n */\r\n\r\ncontract TwoStepOwnable {\r\n  address private _owner;\r\n\r\n  address private _newPotentialOwner;\r\n\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev Initialize contract by setting transaction submitter as initial owner.\r\n   */\r\n  constructor() public {\r\n    _setOwner(tx.origin);\r\n  }\r\n\r\n  /**\r\n   * @dev Sets account as owner\r\n   */\r\n  function _setOwner(address account) internal {\r\n    _owner = account;\r\n    emit OwnershipTransferred(address(0), account);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the current owner.\r\n   */\r\n  function owner() public view returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(isOwner(), \"TwoStepOwnable: caller is not the owner.\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if the caller is the current owner.\r\n   */\r\n  function isOwner() public view returns (bool) {\r\n    return msg.sender == _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows a new account (`newOwner`) to accept ownership.\r\n   * Can only be called by the current owner.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(\r\n      newOwner != address(0),\r\n      \"TwoStepOwnable: new potential owner is the zero address.\"\r\n    );\r\n\r\n    _newPotentialOwner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Cancel a transfer of ownership to a new account.\r\n   * Can only be called by the current owner.\r\n   */\r\n  function cancelOwnershipTransfer() public onlyOwner {\r\n    delete _newPotentialOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers ownership of the contract to the caller.\r\n   * Can only be called by a new potential owner set by the current owner.\r\n   */\r\n  function acceptOwnership() public {\r\n    require(\r\n      msg.sender == _newPotentialOwner,\r\n      \"TwoStepOwnable: current owner must set caller as new potential owner.\"\r\n    );\r\n\r\n    delete _newPotentialOwner;\r\n\r\n    emit OwnershipTransferred(_owner, msg.sender);\r\n\r\n    _owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers ownership of the contract to the null account, thereby\r\n   * preventing it from being used to perform upgrades in the future. This\r\n   * function may only be called by the owner of this contract.\r\n   */\r\n  function renounceOwnership() external onlyOwner {\r\n    emit OwnershipTransferred(_owner, address(0));\r\n    _owner = address(0);\r\n  }\r\n}\r\n\r\n\r\n\r\ninterface IDharmaUpgradeBeaconController {\r\n  // Fire an event any time a new implementation is set on an upgrade beacon.\r\n  event Upgraded(\r\n    address indexed upgradeBeacon,\r\n    address oldImplementation,\r\n    bytes32 oldImplementationCodeHash,\r\n    address newImplementation,\r\n    bytes32 newImplementationCodeHash\r\n  );\r\n  function upgrade(address beacon, address implementation) external;\r\n  function getImplementation(\r\n    address beacon\r\n  ) external view returns (address implementation);\r\n  function getCodeHashAtLastUpgrade(\r\n    address beacon\r\n  ) external view returns (bytes32 codeHashAtLastUpgrade);\r\n}\r\n\r\ninterface IDharmaUpgradeBeaconEnvoy {\r\n  function getImplementation(address beacon) external view returns (address);\r\n}\r\n\r\n/**\r\n * @title DharmaUpgradeBeaconController\r\n * @author cf\r\n * @notice This contract has exclusive control over modifications to the stored\r\n * implementation address on controlled \"upgrade beacon\" contracts. It is an\r\n * owned contract, where ownership can be transferred to another contract - that\r\n * way, the upgrade mechanism itself can be \"upgraded\". Apart from the ownable\r\n * methods, this contract is deliberately simple and only has one non-view\r\n * method - `upgrade`. Timelocks or other upgrade conditions will be managed by\r\n * the owner of this contract.\r\n * The contract has been forked and modified slightly from 0age's original implementation.\r\n */\r\ncontract DharmaUpgradeBeaconController is IDharmaUpgradeBeaconController, TwoStepOwnable {\r\n  // Store a mapping of the implementation code hash at the time of the last\r\n  // upgrade for each beacon. This can be used by calling contracts to verify\r\n  // that the implementation has not been altered since it was initially set.\r\n  mapping(address => bytes32) private _codeHashAtLastUpgrade;\r\n\r\n  // The Upgrade Beacon Envoy checks a beacon's implementation, used for events.\r\n  IDharmaUpgradeBeaconEnvoy private constant _UPGRADE_BEACON_ENVOY = (\r\n    IDharmaUpgradeBeaconEnvoy(0x000000000067503c398F4c9652530DBC4eA95C02)\r\n  );\r\n\r\n  /**\r\n   * @notice In the constructor, set the transaction submitter as the initial\r\n   * owner of this contract and verify the runtime code of the referenced\r\n   * upgrade beacon envoy via `EXTCODEHASH`.\r\n   */\r\n  constructor() {\r\n    // Ensure the upgrade beacon envoy has the expected runtime code hash.\r\n    address envoy = address(_UPGRADE_BEACON_ENVOY);\r\n    bytes32 envoyCodeHash;\r\n    assembly { envoyCodeHash := extcodehash(envoy)}\r\n    require(\r\n      envoyCodeHash == bytes32(\r\n        0x7332d06692fd32b21bdd8b8b7a0a3f0de5cf549668cbc4498fc6cfaa453f1176\r\n      ),\r\n      \"Upgrade Beacon Envoy runtime code is incorrect.\"\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Set a new implementation address on an upgrade beacon contract.\r\n   * This function may only be called by the owner of this contract.\r\n   * @param beacon Address of upgrade beacon to set the new implementation on.\r\n   * @param implementation The address of the new implementation.\r\n   */\r\n  function upgrade(address beacon, address implementation) external override onlyOwner {\r\n    // Ensure that the implementaton contract is not the null address.\r\n    require(implementation != address(0), \"Must specify an implementation.\");\r\n\r\n    // Ensure that the implementation contract has code via extcodesize.\r\n    uint256 implementationSize;\r\n    assembly { implementationSize := extcodesize(implementation) }\r\n    require(implementationSize > 0, \"Implementation must have contract code.\");\r\n\r\n    // Ensure that the beacon contract is not the null address.\r\n    require(beacon != address(0), \"Must specify an upgrade beacon.\");\r\n\r\n    // Ensure that the upgrade beacon contract has code via extcodesize.\r\n    uint256 beaconSize;\r\n    assembly { beaconSize := extcodesize(beacon) }\r\n    require(beaconSize > 0, \"Upgrade beacon must have contract code.\");\r\n\r\n    // Update the upgrade beacon with the new implementation address.\r\n    _update(beacon, implementation);\r\n  }\r\n\r\n  /**\r\n   * @notice View function to check the existing implementation on a given\r\n   * beacon. This is accomplished via a staticcall to the upgrade beacon envoy,\r\n   * which in turn performs a staticcall into the given beacon and passes along\r\n   * the returned implementation address.\r\n   * @param beacon Address of the upgrade beacon to check for an implementation.\r\n   * @return implementation Address of the implementation.\r\n   */\r\n  function getImplementation(\r\n    address beacon\r\n  ) external override view returns (address implementation) {\r\n    // Perform a staticcall into envoy, supplying the beacon as the argument.\r\n    implementation = _UPGRADE_BEACON_ENVOY.getImplementation(beacon);\r\n  }\r\n\r\n  /**\r\n   * @notice View function to check the runtime code hash of a beacon's\r\n   * implementation contract at the time it was last updated. This can be used\r\n   * by other callers to verify that the implementation has not been altered\r\n   * since it was last updated by comparing this value to the current runtime\r\n   * code hash of the beacon's implementation contract. Note that this function\r\n   * will return `bytes32(0)` in the event the supplied beacon has not yet been\r\n   * updated.\r\n   * @param beacon Address of the upgrade beacon to check for a code hash.\r\n   * @return codeHashAtLastUpgrade Runtime code hash of the implementation\r\n   * contract when the beacon was last updated.\r\n   */\r\n  function getCodeHashAtLastUpgrade(\r\n    address beacon\r\n  ) external override view returns (bytes32 codeHashAtLastUpgrade) {\r\n    // Return the code hash that was set when the given beacon was last updated.\r\n    codeHashAtLastUpgrade = _codeHashAtLastUpgrade[beacon];\r\n  }\r\n\r\n  /**\r\n   * @notice Private function to perform an update to a given upgrade beacon and\r\n   * determine the runtime code hash of both the old and the new implementation.\r\n   * The latest code hash for the new implementation of the given beacon will be\r\n   * updated, and an event containing the beacon, the old and new implementation\r\n   * addresses, and the old and new implementation runtime code hashes will be\r\n   * emitted.\r\n   * @param beacon Address of upgrade beacon to set the new implementation on.\r\n   * @param implementation The address of the new implementation.\r\n   */\r\n  function _update(address beacon, address implementation) private {\r\n    // Get the address of the current implementation set on the upgrade beacon.\r\n    address oldImplementation = _UPGRADE_BEACON_ENVOY.getImplementation(beacon);\r\n\r\n    // Get the runtime code hash for the current implementation.\r\n    bytes32 oldImplementationCodeHash;\r\n    assembly { oldImplementationCodeHash := extcodehash(oldImplementation) }\r\n\r\n    // Call into beacon and supply address of new implementation to update it.\r\n    (bool success,) = beacon.call(abi.encode(implementation));\r\n\r\n    // Revert with message on failure (i.e. if the beacon is somehow incorrect).\r\n    if (!success) {\r\n      assembly {\r\n        returndatacopy(0, 0, returndatasize())\r\n        revert(0, returndatasize())\r\n      }\r\n    }\r\n\r\n    // Get address of the new implementation that was set on the upgrade beacon.\r\n    address newImplementation = _UPGRADE_BEACON_ENVOY.getImplementation(beacon);\r\n\r\n    // Get the runtime code hash for the new implementation.\r\n    bytes32 newImplementationCodeHash;\r\n    assembly { newImplementationCodeHash := extcodehash(newImplementation) }\r\n\r\n    // Set runtime code hash of the new implementation for the given beacon.\r\n    _codeHashAtLastUpgrade[beacon] = newImplementationCodeHash;\r\n\r\n    // Emit an event to signal that the upgrade beacon was updated.\r\n    emit Upgraded(\r\n      beacon,\r\n      oldImplementation,\r\n      oldImplementationCodeHash,\r\n      newImplementation,\r\n      newImplementationCodeHash\r\n    );\r\n  }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"upgradeBeacon\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldImplementation\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"oldImplementationCodeHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"newImplementationCodeHash\",\"type\":\"bytes32\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelOwnershipTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"}],\"name\":\"getCodeHashAtLastUpgrade\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"codeHashAtLastUpgrade\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"}],\"name\":\"getImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"upgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"DharmaUpgradeBeaconController","CompilerVersion":"v0.8.3+commit.8d00100c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://8f09ca742e9151e639b2aab367b2b534a072ac85e651adcea483a3cc815662c5"}]}