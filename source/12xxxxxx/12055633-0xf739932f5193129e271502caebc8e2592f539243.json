{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface ERC20 {\r\n    function transferFrom(address _from, address _to, uint _value) external returns (bool);\r\n    function transfer(address _to, uint _value) external returns (bool);\r\n    function decimals() external view returns (uint);\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n}\r\n\r\nstruct MyTokenImbalanceData {\r\n    int  totalBuyUnitsImbalance;\r\n    uint lastRateUpdateBlock;\r\n}\r\n\r\n  // bps - basic rate steps. one step is 1 / 10000 of the rate.\r\nstruct StepFunction {\r\n    int[] x; // quantity for each step. Quantity of each step includes previous steps.\r\n    int[] y; // rate change per quantity step  in bps.\r\n}\r\n\r\nstruct RatesTokenData {\r\n    bool listed;  // was added to reserve\r\n    bool enabled; // whether trade is enabled\r\n\r\n    uint index;  // index in tokenList\r\n    // position in the compact data\r\n    uint arrayIndex;\r\n    uint fieldIndex;\r\n    uint baseRate;\r\n    StepFunction buyRateQtyStepFunction; // in bps. higher quantity - bigger the rate.\r\n    StepFunction sellRateQtyStepFunction;// in bps. higher the qua\r\n    \r\n    uint slippageBpsUnit;\r\n}\r\n\r\nabstract contract  IConversionRate {\r\n    \r\n    mapping(address => RatesTokenData) public tokenData;\r\n    mapping(address => MyTokenImbalanceData) public tokenImbalanceData;\r\n    mapping(address => uint) public tokenMaxTotalImbalance;\r\n    function recordImbalance(address token,int buyAmount,uint256 rateUpdateBlock,uint256 currentBlock) virtual external;\r\n    function getRate(address token, uint256 currentBlockNumber, bool buy, uint256 qty) virtual external view returns(uint256);\r\n    function getListedTokens() virtual external view returns(address[] memory);\r\n    function getQuota(address token, bool isBuy) virtual external view returns (int quota);\r\n    function maxGasPrice() virtual external view returns (uint);\r\n    function getFeedRate(address token, bool buy) virtual public view returns (uint);\r\n    function getRateUpdateBlock(address token) virtual public view returns(uint);\r\n   \r\n}\r\n\r\n\r\ncontract KyberHelper {\r\n    \r\n    struct TokenData {\r\n        address token;\r\n        \r\n        uint256 rateUpdateBlock;\r\n\r\n        uint256 baseBuyRate;\r\n        uint256 baseSellRate;\r\n        \r\n        StepFunction buyRateQtyStepFunction;       // in bps. higher quantity - bigger the rate.\r\n        StepFunction sellRateQtyStepFunction;      // in bps. higher the qua\r\n        StepFunction buyRateImbalanceStepFunction; // in BPS. higher reserve imbalance - bigger the rate.\r\n        StepFunction sellRateImbalanceStepFunction;\r\n    }\r\n    \r\n    struct RatesCompactData {\r\n        address token;\r\n        byte buy;\r\n        byte sell;\r\n    }\r\n    \r\n    struct TokenControlInfo {\r\n        address token;\r\n        uint minimalRecordResolution;\r\n        uint maxPerBlockImbalance;\r\n        uint maxTotalImbalance;\r\n    }\r\n\r\n    struct KyberTokenImbalanceData {\r\n        int  lastBlockBuyUnitsImbalance;\r\n        uint lastBlock;\r\n        int  totalBuyUnitsImbalance;\r\n        uint lastRateUpdateBlock;\r\n    }\r\n    \r\n    //  coded by 1inch\r\n    struct TokenImbalanceData {\r\n        address token;\r\n        uint256[5] data;\r\n    }\r\n    \r\n    // coded by OneBit\r\n    struct MyImbalanceData {\r\n        address token;\r\n        int totalImbalance;\r\n    }\r\n    \r\n    struct QuotaData {\r\n        address token;\r\n        uint256 buyQuota;\r\n        uint256 sellQuota;\r\n    }\r\n    \r\n    string constant public VERSION = \"MyKyberRate v0.1\";\r\n    \r\n    function getMyImbalanceData(address conversionRateContract) external view returns (MyImbalanceData[] memory data) {\r\n        address[] memory tokens = IConversionRate(conversionRateContract).getListedTokens();\r\n        data = new MyImbalanceData[](tokens.length);\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            data[i].token = tokens[i];\r\n            uint rateUpdateBlock = IConversionRate(conversionRateContract).getRateUpdateBlock(tokens[i]);\r\n            (int totalBuyUnitsImbalance, uint lastRateUpdateBlock) = IConversionRate(conversionRateContract).tokenImbalanceData(tokens[i]);\r\n            if(lastRateUpdateBlock == rateUpdateBlock) {\r\n                data[i].totalImbalance = totalBuyUnitsImbalance;\r\n            }\r\n            else {\r\n                 data[i].totalImbalance = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function getQuotaData(address conversionRateContract) external view returns (QuotaData[] memory data) {\r\n        address[] memory tokens = IConversionRate(conversionRateContract).getListedTokens();\r\n        data = new QuotaData[](tokens.length);\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            data[i].token = tokens[i];\r\n            int buyQuota = IConversionRate(conversionRateContract).getQuota(tokens[i],true);\r\n            int sellQuota = IConversionRate(conversionRateContract).getQuota(tokens[i],false);\r\n            if(buyQuota >=0 ){\r\n                data[i].buyQuota = uint(buyQuota);\r\n            }\r\n            else {\r\n                data[i].buyQuota = 0;\r\n            }\r\n            if(sellQuota >=0 ){\r\n                data[i].sellQuota = uint(sellQuota);\r\n            }\r\n            else {\r\n                data[i].sellQuota = 0;\r\n            }\r\n            \r\n        }\r\n    }\r\n    \r\n    function getTokenControlInfo(address conversionRateContract) external view returns (TokenControlInfo[] memory data) {\r\n        address[] memory tokens = IConversionRate(conversionRateContract).getListedTokens();\r\n        data = new TokenControlInfo[](tokens.length);\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            uint maxTotalImbalance = IConversionRate(conversionRateContract).tokenMaxTotalImbalance(tokens[i]);\r\n            \r\n            data[i].token = tokens[i];\r\n            uint tokenResolution = getTokenResolution(tokens[i]);\r\n            data[i].minimalRecordResolution = tokenResolution; \r\n            data[i].maxPerBlockImbalance = maxTotalImbalance/tokenResolution;\r\n            data[i].maxTotalImbalance = maxTotalImbalance/tokenResolution;\r\n        }\r\n    }\r\n    \r\n    function getRatesCompactData(address conversionRateContract) external view returns (RatesCompactData[] memory data) {\r\n          address[] memory tokens = IConversionRate(conversionRateContract).getListedTokens();\r\n          data = new RatesCompactData[](tokens.length);\r\n          for (uint i = 0; i < tokens.length; i++) {              \r\n              data[i].token = tokens[i];\r\n              data[i].buy = 0;\r\n              data[i].sell = 0;\r\n          }\r\n    }\r\n    \r\n    function getStepFunctionData(address conversionRateContract) external view returns (TokenData[] memory data) {\r\n        address[] memory tokens = IConversionRate(conversionRateContract).getListedTokens();\r\n        \r\n        data = new TokenData[](tokens.length);\r\n        \r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            address token = tokens[i];\r\n            data[i].token = tokens[i];\r\n            \r\n            data[i].rateUpdateBlock = IConversionRate(conversionRateContract).getRateUpdateBlock(tokens[i]);\r\n            \r\n            data[i].baseBuyRate = IConversionRate(conversionRateContract).getFeedRate(tokens[i], true);\r\n            data[i].baseSellRate = IConversionRate(conversionRateContract).getFeedRate(tokens[i], false);\r\n\r\n            (,,,,,, StepFunction memory buyRateQtyStepFunction, StepFunction memory sellRateQtyStepFunction,)\r\n            = IConversionRate(conversionRateContract).tokenData(token);\r\n            data[i].buyRateQtyStepFunction = buyRateQtyStepFunction;\r\n            data[i].sellRateQtyStepFunction = sellRateQtyStepFunction;\r\n        }\r\n    }\r\n    \r\n    function getTokenImbalanceData(address conversionRateContract) external view returns (TokenImbalanceData[] memory data) {\r\n        address[] memory tokens = IConversionRate(conversionRateContract).getListedTokens();\r\n        data = new TokenImbalanceData[](tokens.length);\r\n        uint currentBlockNumber = block.number;\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            data[i].token = tokens[i];\r\n            uint tokenResolution = getTokenResolution(tokens[i]);\r\n            (int totalBuyUnitsImbalance, uint lastRateUpdateBlock) = IConversionRate(conversionRateContract).tokenImbalanceData(tokens[i]);\r\n            //uint rateUpdateBlock = IConversionRate(conversionRateContract).getRateUpdateBlock(tokens[i]);\r\n            for (uint j = 0; j < 5; j++) {\r\n                //if(currentBlockNumber%5 == j && lastRateUpdateBlock == rateUpdateBlock) {\r\n                if(currentBlockNumber%5 == j) {\r\n                    totalBuyUnitsImbalance = totalBuyUnitsImbalance/int(tokenResolution);\r\n                    KyberTokenImbalanceData memory kyberTokenImbalanceData = KyberTokenImbalanceData(0,currentBlockNumber,totalBuyUnitsImbalance,lastRateUpdateBlock);\r\n                    data[i].data[j] = encodeTokenImbalanceData(kyberTokenImbalanceData);\r\n                }\r\n                else {\r\n                    data[i].data[j] = 0x1;\r\n                }\r\n                \r\n            }\r\n            \r\n        }\r\n    }\r\n    \r\n    function getTokenResolution(address token) internal view returns (uint) {\r\n        uint tokenDecimal = ERC20(token).decimals();\r\n        if (tokenDecimal > 10) {\r\n            return 10 ** (tokenDecimal-10);\r\n        }\r\n        else {\r\n            return 1;\r\n        }\r\n    }\r\n\r\n    uint constant internal POW_2_64 = 2 ** 64;\r\n    function encodeTokenImbalanceData(KyberTokenImbalanceData memory data) public pure returns(uint) {\r\n        // check for overflows\r\n        require(data.lastBlockBuyUnitsImbalance < int(POW_2_64 / 2));\r\n        require(data.lastBlockBuyUnitsImbalance > int(-1 * int(POW_2_64) / 2));\r\n        require(data.lastBlock < POW_2_64);\r\n        require(data.totalBuyUnitsImbalance < int(POW_2_64 / 2));\r\n        require(data.totalBuyUnitsImbalance > int(-1 * int(POW_2_64) / 2));\r\n        require(data.lastRateUpdateBlock < POW_2_64);\r\n\r\n        // do encoding\r\n        uint result = uint(data.lastBlockBuyUnitsImbalance) & (POW_2_64 - 1);\r\n        result |= data.lastBlock * POW_2_64;\r\n        result |= (uint(data.totalBuyUnitsImbalance) & (POW_2_64 - 1)) * POW_2_64 * POW_2_64;\r\n        result |= data.lastRateUpdateBlock * POW_2_64 * POW_2_64 * POW_2_64;\r\n\r\n        return result;\r\n    }\r\n    \r\n    function decodeTokenImbalanceData(uint input) public pure returns(KyberTokenImbalanceData memory) {\r\n        KyberTokenImbalanceData memory data;\r\n\r\n        data.lastBlockBuyUnitsImbalance = int(int64(input & (POW_2_64 - 1)));\r\n        data.lastBlock = uint(uint64((input / POW_2_64) & (POW_2_64 - 1)));\r\n        data.totalBuyUnitsImbalance = int(int64((input / (POW_2_64 * POW_2_64)) & (POW_2_64 - 1)));\r\n        data.lastRateUpdateBlock = uint(uint64((input / (POW_2_64 * POW_2_64 * POW_2_64))));\r\n\r\n        return data;\r\n    }\r\n    \r\n}","ABI":"[{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"input\",\"type\":\"uint256\"}],\"name\":\"decodeTokenImbalanceData\",\"outputs\":[{\"components\":[{\"internalType\":\"int256\",\"name\":\"lastBlockBuyUnitsImbalance\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"lastBlock\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"totalBuyUnitsImbalance\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"lastRateUpdateBlock\",\"type\":\"uint256\"}],\"internalType\":\"struct KyberHelper.KyberTokenImbalanceData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"int256\",\"name\":\"lastBlockBuyUnitsImbalance\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"lastBlock\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"totalBuyUnitsImbalance\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"lastRateUpdateBlock\",\"type\":\"uint256\"}],\"internalType\":\"struct KyberHelper.KyberTokenImbalanceData\",\"name\":\"data\",\"type\":\"tuple\"}],\"name\":\"encodeTokenImbalanceData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"conversionRateContract\",\"type\":\"address\"}],\"name\":\"getMyImbalanceData\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"totalImbalance\",\"type\":\"int256\"}],\"internalType\":\"struct KyberHelper.MyImbalanceData[]\",\"name\":\"data\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"conversionRateContract\",\"type\":\"address\"}],\"name\":\"getQuotaData\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"buyQuota\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellQuota\",\"type\":\"uint256\"}],\"internalType\":\"struct KyberHelper.QuotaData[]\",\"name\":\"data\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"conversionRateContract\",\"type\":\"address\"}],\"name\":\"getRatesCompactData\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bytes1\",\"name\":\"buy\",\"type\":\"bytes1\"},{\"internalType\":\"bytes1\",\"name\":\"sell\",\"type\":\"bytes1\"}],\"internalType\":\"struct KyberHelper.RatesCompactData[]\",\"name\":\"data\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"conversionRateContract\",\"type\":\"address\"}],\"name\":\"getStepFunctionData\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rateUpdateBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseBuyRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseSellRate\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"int256[]\",\"name\":\"x\",\"type\":\"int256[]\"},{\"internalType\":\"int256[]\",\"name\":\"y\",\"type\":\"int256[]\"}],\"internalType\":\"struct StepFunction\",\"name\":\"buyRateQtyStepFunction\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"int256[]\",\"name\":\"x\",\"type\":\"int256[]\"},{\"internalType\":\"int256[]\",\"name\":\"y\",\"type\":\"int256[]\"}],\"internalType\":\"struct StepFunction\",\"name\":\"sellRateQtyStepFunction\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"int256[]\",\"name\":\"x\",\"type\":\"int256[]\"},{\"internalType\":\"int256[]\",\"name\":\"y\",\"type\":\"int256[]\"}],\"internalType\":\"struct StepFunction\",\"name\":\"buyRateImbalanceStepFunction\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"int256[]\",\"name\":\"x\",\"type\":\"int256[]\"},{\"internalType\":\"int256[]\",\"name\":\"y\",\"type\":\"int256[]\"}],\"internalType\":\"struct StepFunction\",\"name\":\"sellRateImbalanceStepFunction\",\"type\":\"tuple\"}],\"internalType\":\"struct KyberHelper.TokenData[]\",\"name\":\"data\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"conversionRateContract\",\"type\":\"address\"}],\"name\":\"getTokenControlInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minimalRecordResolution\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPerBlockImbalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTotalImbalance\",\"type\":\"uint256\"}],\"internalType\":\"struct KyberHelper.TokenControlInfo[]\",\"name\":\"data\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"conversionRateContract\",\"type\":\"address\"}],\"name\":\"getTokenImbalanceData\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256[5]\",\"name\":\"data\",\"type\":\"uint256[5]\"}],\"internalType\":\"struct KyberHelper.TokenImbalanceData[]\",\"name\":\"data\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"KyberHelper","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://bff1ee233163d965e022dee9b3049e0220a6565dbc798d11a6dffc491e8b18a1"}]}