{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name_, string memory symbol_) public {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@uniswap/lib/contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.0;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\\n    }\\n\\n    function safeTransfer(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\\n    }\\n\\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\\n    }\\n\\n    function safeTransferETH(address to, uint value) internal {\\n        (bool success,) = to.call{value:value}(new bytes(0));\\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\nimport './IUniswapV2Router01.sol';\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/UniswapTrader.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.6.8;\\n\\nimport \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\\\";\\nimport \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\\\";\\nimport \\\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\\\";\\nimport \\\"@uniswap/lib/contracts/libraries/TransferHelper.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\n/**\\n    @title The Uniswap-enabled base contract for Vanilla.\\n*/\\ncontract UniswapTrader {\\n    using SafeMath for uint256;\\n\\n    string private constant _ERROR_SLIPPAGE_LIMIT_EXCEEDED = \\\"a1\\\";\\n    string private constant _INVALID_UNISWAP_PAIR = \\\"a2\\\";\\n\\n    address internal immutable _uniswapFactoryAddr;\\n    address internal immutable _wethAddr;\\n\\n    // internally tracked reserves for price manipulation protection for each token (Uniswap uses uint112 so uint128 is plenty)\\n    mapping(address => uint128) public wethReserves;\\n\\n    /**\\n        @notice Deploys the contract and initializes Uniswap contract references and internal WETH-reserve for safe tokens.\\n        @dev using UniswapRouter to ensure that Vanilla uses the same WETH contract\\n        @param routerAddress The address of UniswapRouter contract\\n        @param limit The initial reserve value for tokens in the safelist\\n        @param safeList The list of \\\"safe\\\" tokens to trade\\n     */\\n    constructor(\\n        address routerAddress,\\n        uint128 limit,\\n        address[] memory safeList\\n    ) public {\\n        // fetch addresses via router to guarantee correctness\\n        IUniswapV2Router02 router = IUniswapV2Router02(routerAddress);\\n        address wethAddr = router.WETH();\\n        IUniswapV2Factory factory = IUniswapV2Factory(router.factory());\\n        for (uint256 i = 0; i < safeList.length; i++) {\\n            address token = safeList[i];\\n            // verify that WETH-token pair exists in Uniswap\\n            // (order isn't significant, UniswapV2Factory.createPair populates the mapping in reverse direction too)\\n            address pair = factory.getPair(token, wethAddr);\\n            require(pair != address(0), _INVALID_UNISWAP_PAIR);\\n\\n            // we initialize the fixed list of rewardedTokens with the reserveLimit-value that they'll match the invariant\\n            // \\\"every rewardedToken will have wethReserves[rewardedToken] > 0\\\"\\n            // (this way we don't need to store separate lists for both wethReserve-tracking and tokens eligible for the rewards)\\n            wethReserves[token] = limit;\\n        }\\n        _wethAddr = wethAddr;\\n        _uniswapFactoryAddr = address(factory);\\n    }\\n\\n    /**\\n        @notice Checks if the given ERC-20 token will be eligible for rewards (i.e. a safelisted token)\\n        @param token The ERC-20 token address\\n     */\\n    function isTokenRewarded(address token) public view returns (bool) {\\n        return wethReserves[token] > 0;\\n    }\\n\\n    function _pairInfo(\\n        address factory,\\n        address token,\\n        address weth\\n    ) internal pure returns (address pair, bool tokenFirst) {\\n        // as order of tokens is important in Uniswap pairs, we record this information here and pass it on to caller\\n        // for gas optimization\\n        tokenFirst = token < weth;\\n\\n        // adapted from UniswapV2Library.sol, calculates the CREATE2 address for a pair without making any external calls to factory contract\\n        pair = address(\\n            uint256(\\n                keccak256(\\n                    abi.encodePacked(\\n                        hex\\\"ff\\\",\\n                        factory,\\n                        keccak256(\\n                            tokenFirst\\n                                ? abi.encodePacked(token, weth)\\n                                : abi.encodePacked(weth, token)\\n                        ),\\n                        hex\\\"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\\\"\\n                    )\\n                )\\n            )\\n        );\\n    }\\n\\n    function _amountToSwap(\\n        uint256 tokensIn,\\n        uint256 reservesIn,\\n        uint256 reservesOut\\n    ) internal pure returns (uint256 tokensOut) {\\n        uint256 inMinusFee = tokensIn.mul(997); // in * (100% - 0.3%)\\n        tokensOut = reservesOut.mul(inMinusFee).div(\\n            reservesIn.mul(1000).add(inMinusFee)\\n        );\\n    }\\n\\n    function _updateReservesOnBuy(address token, uint112 wethReserve)\\n        private\\n        returns (uint128 reserve)\\n    {\\n        // when buying, update internal reserve only if Uniswap reserve is greater\\n        reserve = wethReserves[token];\\n        if (reserve == 0) {\\n            // trading a non-safelisted token, so do not update internal reserves\\n            return reserve;\\n        }\\n        if (wethReserve > reserve) {\\n            wethReserves[token] = wethReserve;\\n            reserve = wethReserve;\\n        }\\n    }\\n\\n    function _buyInUniswap(\\n        address token_,\\n        uint256 eth,\\n        uint256 amount_,\\n        address tokenOwner_\\n    ) internal returns (uint256 numToken, uint128 reserve) {\\n        (address pairAddress, bool tokenFirst) =\\n            _pairInfo(_uniswapFactoryAddr, token_, _wethAddr);\\n        IUniswapV2Pair pair = IUniswapV2Pair(pairAddress);\\n\\n        address tokenCustody = address(this);\\n        uint256 balance = IERC20(token_).balanceOf(tokenCustody);\\n        IERC20(_wethAddr).transferFrom(tokenOwner_, pairAddress, eth);\\n        if (tokenFirst) {\\n            (uint112 tokenReserve, uint112 wethReserve, ) = pair.getReserves();\\n            pair.swap(\\n                _amountToSwap(eth, wethReserve, tokenReserve),\\n                uint256(0),\\n                tokenCustody,\\n                new bytes(0)\\n            );\\n            reserve = _updateReservesOnBuy(token_, wethReserve);\\n        } else {\\n            (uint112 wethReserve, uint112 tokenReserve, ) = pair.getReserves();\\n            pair.swap(\\n                uint256(0),\\n                _amountToSwap(eth, wethReserve, tokenReserve),\\n                tokenCustody,\\n                new bytes(0)\\n            );\\n            reserve = _updateReservesOnBuy(token_, wethReserve);\\n        }\\n        // finally check how the custody balance has changed after swap\\n        numToken = IERC20(token_).balanceOf(tokenCustody) - balance;\\n        // revert if the price diff between trade-time and execution-time was too large\\n        require(numToken >= amount_, _ERROR_SLIPPAGE_LIMIT_EXCEEDED);\\n    }\\n\\n    function _updateReservesOnSell(address token, uint112 wethReserve)\\n        private\\n        returns (uint128 reserve)\\n    {\\n        // when selling, update internal reserve only if the Uniswap reserve is smaller\\n        reserve = wethReserves[token];\\n        if (reserve == 0) {\\n            // trading a non-safelisted token, so do not update internal reserves\\n            return reserve;\\n        }\\n        if (wethReserve < reserve) {\\n            wethReserves[token] = wethReserve;\\n            reserve = wethReserve;\\n        }\\n    }\\n\\n    function _sellInUniswap(\\n        address token_,\\n        uint256 amount_,\\n        uint256 eth_,\\n        address tokenReceiver_\\n    ) internal returns (uint256 numEth, uint128 reserve) {\\n        (address pairAddress, bool tokenFirst) =\\n            _pairInfo(_uniswapFactoryAddr, token_, _wethAddr);\\n        IUniswapV2Pair pair = IUniswapV2Pair(pairAddress);\\n        uint256 balance = IERC20(_wethAddr).balanceOf(tokenReceiver_);\\n\\n        // Use TransferHelper because we have no idea here how token.transfer() has been implemented\\n        TransferHelper.safeTransfer(token_, pairAddress, amount_);\\n        if (tokenFirst) {\\n            (uint112 tokenReserve, uint112 wethReserve, ) = pair.getReserves();\\n            pair.swap(\\n                uint256(0),\\n                _amountToSwap(amount_, tokenReserve, wethReserve),\\n                tokenReceiver_,\\n                new bytes(0)\\n            );\\n            reserve = _updateReservesOnSell(token_, wethReserve);\\n        } else {\\n            (uint112 wethReserve, uint112 tokenReserve, ) = pair.getReserves();\\n            pair.swap(\\n                _amountToSwap(amount_, tokenReserve, wethReserve),\\n                uint256(0),\\n                tokenReceiver_,\\n                new bytes(0)\\n            );\\n            reserve = _updateReservesOnSell(token_, wethReserve);\\n        }\\n        // finally check how the receivers balance has changed after swap\\n        numEth = IERC20(_wethAddr).balanceOf(tokenReceiver_) - balance;\\n        // revert if the price diff between trade-time and execution-time was too large\\n        require(numEth >= eth_, _ERROR_SLIPPAGE_LIMIT_EXCEEDED);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/VanillaGovernanceToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.6.8;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n\\n/**\\n @title Governance Token for Vanilla Finance.\\n */\\ncontract VanillaGovernanceToken is ERC20(\\\"Vanilla\\\", \\\"VNL\\\") {\\n    string private constant _ERROR_ACCESS_DENIED = \\\"c1\\\";\\n    address private immutable _owner;\\n\\n    /**\\n        @notice Deploys the token and sets the caller as an owner.\\n     */\\n    constructor() public {\\n        _owner = msg.sender;\\n        // set the decimals explicitly to 12, for (theoretical maximum of) VNL reward of a 1ETH of profit\\n        // should be displayed as 1000000VNL (18-6 = 12 decimals).\\n        _setupDecimals(12);\\n    }\\n\\n    modifier onlyOwner() {\\n        require(_owner == msg.sender, _ERROR_ACCESS_DENIED);\\n        _;\\n    }\\n\\n    /**\\n        @notice Mints the tokens. Used only by the VanillaRouter-contract.\\n\\n        @param to The recipient address of the minted tokens\\n        @param tradeReward The amount of tokens to be minted\\n     */\\n    function mint(address to, uint256 tradeReward) external onlyOwner {\\n        _mint(to, tradeReward);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/VanillaRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.6.8;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"./VanillaGovernanceToken.sol\\\";\\nimport \\\"./UniswapTrader.sol\\\";\\n\\n/// @dev Needed functions from the WETH contract originally deployed in https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code\\ninterface IWETH {\\n    function deposit() external payable;\\n\\n    function withdraw(uint256 amount) external;\\n}\\n\\n/**\\n    @title The main entrypoint for Vanilla\\n*/\\ncontract VanillaRouter is UniswapTrader {\\n    string private constant _ERROR_TRADE_EXPIRED = \\\"b1\\\";\\n    string private constant _ERROR_TRANSFER_FAILED = \\\"b2\\\";\\n    string private constant _ERROR_TOO_MANY_TRADES_PER_BLOCK = \\\"b3\\\";\\n    string private constant _ERROR_NO_TOKEN_OWNERSHIP = \\\"b4\\\";\\n    string private constant _ERROR_RESERVELIMIT_TOO_LOW = \\\"b5\\\";\\n    string private constant _ERROR_NO_SAFE_TOKENS = \\\"b6\\\";\\n\\n    uint256 public immutable epoch;\\n    VanillaGovernanceToken public immutable vnlContract;\\n    uint128 public immutable reserveLimit;\\n\\n    using SafeMath for uint256;\\n\\n    // data for calculating volume-weighted average prices, average purchasing block, and limiting trades per block\\n    struct PriceData {\\n        uint256 ethSum;\\n        uint256 tokenSum;\\n        uint256 weightedBlockSum;\\n        uint256 latestBlock;\\n    }\\n\\n    // Price data, indexed as [owner][token]\\n    mapping(address => mapping(address => PriceData)) public tokenPriceData;\\n\\n    /**\\n       @dev Emitted when tokens are sold.\\n       @param seller The owner of tokens.\\n       @param token The address of the sold token.\\n       @param amount Number of sold tokens.\\n       @param eth The received ether from the trade.\\n       @param profit The calculated profit from the trade.\\n       @param reward The amount of VanillaGovernanceToken reward tokens transferred to seller.\\n       @param reserve The internally tracker Uniswap WETH reserve before trade.\\n     */\\n    event TokensSold(\\n        address indexed seller,\\n        address indexed token,\\n        uint256 amount,\\n        uint256 eth,\\n        uint256 profit,\\n        uint256 reward,\\n        uint256 reserve\\n    );\\n\\n    /**\\n       @dev Emitted when tokens are bought.\\n       @param buyer The new owner of tokens.\\n       @param token The address of the purchased token.\\n       @param eth The amount of ether spent in the trade.\\n       @param amount Number of purchased tokens.\\n       @param reserve The internally tracker Uniswap WETH reserve before trade.\\n     */\\n    event TokensPurchased(\\n        address indexed buyer,\\n        address indexed token,\\n        uint256 eth,\\n        uint256 amount,\\n        uint256 reserve\\n    );\\n\\n    /**\\n        @notice Deploys the contract and the VanillaGovernanceToken contract.\\n        @dev initializes the token contract for safe reference and sets the epoch for reward calculations\\n        @param uniswapRouter The address of UniswapRouter contract\\n        @param limit The minimum WETH reserve for a token to be eligible in profit mining\\n        @param safeList The list of ERC-20 addresses that are considered \\\"safe\\\", and will be eligible for rewards\\n    */\\n    constructor(\\n        address uniswapRouter,\\n        uint128 limit,\\n        address[] memory safeList\\n    ) public UniswapTrader(uniswapRouter, limit, safeList) {\\n        vnlContract = new VanillaGovernanceToken();\\n        epoch = block.number;\\n        require(limit > 0, _ERROR_RESERVELIMIT_TOO_LOW);\\n        require(safeList.length > 0, _ERROR_NO_SAFE_TOKENS);\\n        reserveLimit = limit;\\n    }\\n\\n    modifier beforeDeadline(uint256 deadline) {\\n        require(deadline >= block.timestamp, _ERROR_TRADE_EXPIRED);\\n        _;\\n    }\\n\\n    /**\\n        @notice Buys the tokens with Ether. Use the external pricefeed for pricing.\\n        @dev Buys the `numToken` tokens for all the msg.value Ether, before `blockTimeDeadline`\\n\\n        @param token The address of ERC20 token to be bought\\n        @param numToken The amount of ERC20 tokens to be bought\\n        @param blockTimeDeadline The block timestamp when this buy-transaction expires\\n     */\\n    function depositAndBuy(\\n        address token,\\n        uint256 numToken,\\n        uint256 blockTimeDeadline\\n    ) external payable beforeDeadline(blockTimeDeadline) {\\n        IWETH weth = IWETH(_wethAddr);\\n        uint256 numEth = msg.value;\\n        weth.deposit{value: numEth}();\\n\\n        // execute swap using WETH-balance of this contract\\n        _executeBuy(msg.sender, address(this), token, numEth, numToken);\\n    }\\n\\n    /**\\n        @notice Buys the tokens with WETH. Use the external pricefeed for pricing.\\n        @dev Buys the `numToken` tokens for all the msg.value Ether, before `blockTimeDeadline`\\n\\n        @param token The address of ERC20 token to be bought\\n        @param numEth The amount of WETH to spend. Needs to be pre-approved for the VanillaRouter.\\n        @param numToken The amount of ERC20 tokens to be bought\\n        @param blockTimeDeadline The block timestamp when this buy-transaction expires\\n     */\\n    function buy(\\n        address token,\\n        uint256 numEth,\\n        uint256 numToken,\\n        uint256 blockTimeDeadline\\n    ) external beforeDeadline(blockTimeDeadline) {\\n        // execute swap using WETH-balance of the caller\\n        _executeBuy(msg.sender, msg.sender, token, numEth, numToken);\\n    }\\n\\n    function _executeBuy(\\n        address owner,\\n        address currentWETHHolder,\\n        address token,\\n        uint256 numEthSold,\\n        uint256 numToken\\n    ) internal {\\n        // verify the one-trade-per-block-per-token rule and protect against reentrancy\\n        PriceData storage prices = tokenPriceData[owner][token];\\n        require(\\n            block.number > prices.latestBlock,\\n            _ERROR_TOO_MANY_TRADES_PER_BLOCK\\n        );\\n        prices.latestBlock = block.number;\\n\\n        // do the swap and update price data\\n        (uint256 tokens, uint256 newReserve) =\\n            _buyInUniswap(token, numEthSold, numToken, currentWETHHolder);\\n        prices.ethSum = prices.ethSum.add(numEthSold);\\n        prices.tokenSum = prices.tokenSum.add(tokens);\\n        prices.weightedBlockSum = prices.weightedBlockSum.add(\\n            block.number.mul(tokens)\\n        );\\n        emit TokensPurchased(msg.sender, token, numEthSold, tokens, newReserve);\\n    }\\n\\n    /**\\n        @dev Receives the ether only from WETH contract during withdraw()\\n     */\\n    receive() external payable {\\n        // make sure that router accepts ETH only from WETH contract\\n        assert(msg.sender == _wethAddr);\\n    }\\n\\n    /**\\n        @notice Sells the tokens the caller owns. Use the external pricefeed for pricing.\\n        @dev Sells the `numToken` tokens msg.sender owns, for `numEth` ether, before `blockTimeDeadline`\\n\\n        @param token The address of ERC20 token to be sold\\n        @param numToken The amount of ERC20 tokens to be sold\\n        @param numEthLimit The minimum amount of ether to be received for exchange (the limit order)\\n        @param blockTimeDeadline The block timestamp when this sell-transaction expires\\n     */\\n    function sell(\\n        address token,\\n        uint256 numToken,\\n        uint256 numEthLimit,\\n        uint256 blockTimeDeadline\\n    ) external beforeDeadline(blockTimeDeadline) {\\n        // execute the swap by transferring WETH directly to caller\\n        _executeSell(msg.sender, msg.sender, token, numToken, numEthLimit);\\n    }\\n\\n    /**\\n        @notice Sells the tokens the caller owns. Use the external pricefeed for pricing.\\n        @dev Sells the `numToken` tokens msg.sender owns, for `numEth` ether, before `blockTimeDeadline`\\n\\n        @param token The address of ERC20 token to be sold\\n        @param numToken The amount of ERC20 tokens to be sold\\n        @param numEthLimit The minimum amount of ether to be received for exchange (the limit order)\\n        @param blockTimeDeadline The block timestamp when this sell-transaction expires\\n     */\\n    function sellAndWithdraw(\\n        address token,\\n        uint256 numToken,\\n        uint256 numEthLimit,\\n        uint256 blockTimeDeadline\\n    ) external beforeDeadline(blockTimeDeadline) {\\n        // execute the swap by transferring WETH to this contract first\\n        uint256 numEth =\\n            _executeSell(\\n                msg.sender,\\n                address(this),\\n                token,\\n                numToken,\\n                numEthLimit\\n            );\\n\\n        IWETH iweth = IWETH(_wethAddr);\\n        iweth.withdraw(numEth);\\n\\n        (bool etherTransferSuccessful, ) =\\n            msg.sender.call{value: numEth}(new bytes(0));\\n        require(etherTransferSuccessful, _ERROR_TRANSFER_FAILED);\\n    }\\n\\n    function _executeSell(\\n        address owner,\\n        address recipient,\\n        address token,\\n        uint256 numTokensSold,\\n        uint256 numEthLimit\\n    ) internal returns (uint256) {\\n        // verify the one-trade-per-block-per-token rule and protect against reentrancy\\n        PriceData storage prices = tokenPriceData[owner][token];\\n        require(\\n            block.number > prices.latestBlock,\\n            _ERROR_TOO_MANY_TRADES_PER_BLOCK\\n        );\\n        prices.latestBlock = block.number;\\n\\n        // do the swap, calculate the profit and update price data\\n        (uint256 numEth, uint128 reserve) =\\n            _sellInUniswap(token, numTokensSold, numEthLimit, recipient);\\n\\n        uint256 profitablePrice =\\n            numTokensSold.mul(prices.ethSum).div(prices.tokenSum);\\n        uint256 avgBlock = prices.weightedBlockSum.div(prices.tokenSum);\\n        uint256 newTokenSum = prices.tokenSum.sub(numTokensSold);\\n        uint256 profit =\\n            numEth > profitablePrice ? numEth.sub(profitablePrice) : 0;\\n\\n        prices.ethSum = _proportionOf(\\n            prices.ethSum,\\n            newTokenSum,\\n            prices.tokenSum\\n        );\\n        prices.weightedBlockSum = _proportionOf(\\n            prices.weightedBlockSum,\\n            newTokenSum,\\n            prices.tokenSum\\n        );\\n        prices.tokenSum = newTokenSum;\\n\\n        uint256 reward = 0;\\n        if (isTokenRewarded(token)) {\\n            // calculate the reward, and mint tokens\\n            reward = _calculateReward(\\n                epoch,\\n                avgBlock,\\n                block.number,\\n                profit,\\n                reserve,\\n                reserveLimit\\n            );\\n            if (reward > 0) {\\n                vnlContract.mint(msg.sender, reward);\\n            }\\n        }\\n\\n        emit TokensSold(\\n            msg.sender,\\n            token,\\n            numTokensSold,\\n            numEth,\\n            profit,\\n            reward,\\n            reserve\\n        );\\n        return numEth;\\n    }\\n\\n    /**\\n        @notice Estimates the reward.\\n        @dev Estimates the reward for given `owner` when selling `numTokensSold``token`s for `numEth` Ether. Also returns the individual components of the reward formula.\\n        @return profitablePrice The expected amount of Ether for this trade. Profit of this trade can be calculated with `numEth`-`profitablePrice`.\\n        @return avgBlock The volume-weighted average block for the `owner` and `token`\\n        @return htrs The Holding/Trading Ratio, Squared- estimate for this trade, percentage value range in fixed point range 0-100.0000.\\n        @return vpc The Value-Protection Coefficient- estimate for this trade, percentage value range in fixed point range 0-100.0000.\\n        @return reward The token reward estimate for this trade.\\n     */\\n    function estimateReward(\\n        address owner,\\n        address token,\\n        uint256 numEth,\\n        uint256 numTokensSold\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 profitablePrice,\\n            uint256 avgBlock,\\n            uint256 htrs,\\n            uint256 vpc,\\n            uint256 reward\\n        )\\n    {\\n        PriceData storage prices = tokenPriceData[owner][token];\\n        require(prices.tokenSum > 0, _ERROR_NO_TOKEN_OWNERSHIP);\\n        profitablePrice = numTokensSold.mul(prices.ethSum).div(prices.tokenSum);\\n        avgBlock = prices.weightedBlockSum.div(prices.tokenSum);\\n        if (numEth > profitablePrice) {\\n            uint256 profit = numEth.sub(profitablePrice);\\n            uint128 wethReserve = wethReserves[token];\\n            htrs = _estimateHTRS(avgBlock);\\n            vpc = _estimateVPC(profit, wethReserve);\\n            reward = _calculateReward(\\n                epoch,\\n                avgBlock,\\n                block.number,\\n                profit,\\n                wethReserve,\\n                reserveLimit\\n            );\\n        } else {\\n            htrs = 0;\\n            vpc = 0;\\n            reward = 0;\\n        }\\n    }\\n\\n    function _estimateHTRS(uint256 avgBlock) internal view returns (uint256) {\\n        // H     = \\\"Holding/Trading Ratio, Squared\\\" (HTRS)\\n        //       = ((Bmax-Bavg)/(Bmax-Bmin))²\\n        //       = (((Bmax-Bmin)-(Bavg-Bmin))/(Bmax-Bmin))²\\n        //       = (Bhold/Btrade)² (= 0 if Bmax = Bavg, NaN if Bmax = Bmin)\\n        if (avgBlock == block.number || block.number == epoch) return 0;\\n\\n        uint256 bhold = block.number - avgBlock;\\n        uint256 btrade = block.number - epoch;\\n\\n        return bhold.mul(bhold).mul(1_000_000).div(btrade.mul(btrade));\\n    }\\n\\n    function _estimateVPC(uint256 profit, uint256 reserve)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        // VPC = 1-max((P + L)/W, 1) (= 0 if P+L > W)\\n        //     = (W - P - L ) / W\\n        if (profit + reserveLimit > reserve) return 0;\\n\\n        return (reserve - profit - reserveLimit).mul(1_000_000).div(reserve);\\n    }\\n\\n    function _calculateReward(\\n        uint256 epoch_,\\n        uint256 avgBlock,\\n        uint256 currentBlock,\\n        uint256 profit,\\n        uint128 wethReserve,\\n        uint128 reserveLimit_\\n    ) internal pure returns (uint256) {\\n        /*\\n        Reward formula:\\n            P     = absolute profit in Ether = `profit`\\n            Bmax  = block.number when trade is happening = `block.number`\\n            Bavg  = volume-weighted average block.number of purchase = `avgBlock`\\n            Bmin  = \\\"epoch\\\", the block.number when contract was deployed = `epoch_`\\n            Bhold = Bmax-Bavg = number of blocks the trade has been held (instead of traded)\\n            Btrade= Bmax-Bmin = max possible trading time in blocks\\n            H     = \\\"Holding/Trading Ratio, Squared\\\" (HTRS)\\n                  = ((Bmax-Bavg)/(Bmax-Bmin))²\\n                  = (((Bmax-Bmin)-(Bavg-Bmin))/(Bmax-Bmin))²\\n                  = (Bhold/Btrade)² (= 0 if Bmax = Bavg, NaN if Bmax = Bmin)\\n            L     = WETH reserve limit for any traded token = `_reserveLimit`\\n            W     = internally tracked WETH reserve size for when selling a token = `wethReserve`\\n            V     = value protection coefficient\\n                  = 1-min((P + L)/W, 1) (= 0 if P+L > W)\\n            R     = minted rewards\\n                  = P*V*H\\n                  = if   (P = 0 || P + L > W || Bmax = Bavg || BMax = Bmin)\\n                         0\\n                    else P * (1-(P + L)/W) * (Bhold/Btrade)²\\n                       = (P * (W - P - L) * Bhold²) / W / Btrade²\\n        */\\n\\n        if (profit == 0) return 0;\\n        if (profit + reserveLimit_ > wethReserve) return 0;\\n        if (currentBlock == avgBlock) return 0;\\n        if (currentBlock == epoch_) return 0;\\n\\n        // these cannot underflow thanks to previous checks\\n        uint256 rpl = wethReserve - profit - reserveLimit_;\\n        uint256 bhold = currentBlock - avgBlock;\\n        uint256 btrade = currentBlock - epoch_;\\n\\n        uint256 nominator = profit.mul(rpl).mul(bhold.mul(bhold));\\n        // no division by zero possible, both wethReserve and btrade² are always > 0\\n        return nominator / wethReserve / (btrade.mul(btrade));\\n    }\\n\\n    function _proportionOf(\\n        uint256 total,\\n        uint256 numerator,\\n        uint256 denominator\\n    ) internal pure returns (uint256) {\\n        // percentage = (numerator/denominator)\\n        // proportion = total * percentage\\n        return total.mul(numerator).div(denominator);\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"uniswapRouter\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"limit\",\"type\":\"uint128\"},{\"internalType\":\"address[]\",\"name\":\"safeList\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eth\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reserve\",\"type\":\"uint256\"}],\"name\":\"TokensPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eth\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"profit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reserve\",\"type\":\"uint256\"}],\"name\":\"TokensSold\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"numEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockTimeDeadline\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"numToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockTimeDeadline\",\"type\":\"uint256\"}],\"name\":\"depositAndBuy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"numEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numTokensSold\",\"type\":\"uint256\"}],\"name\":\"estimateReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"profitablePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"avgBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"htrs\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vpc\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"isTokenRewarded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserveLimit\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"numToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numEthLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockTimeDeadline\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"numToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numEthLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockTimeDeadline\",\"type\":\"uint256\"}],\"name\":\"sellAndWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenPriceData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ethSum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenSum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"weightedBlockSum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"latestBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vnlContract\",\"outputs\":[{\"internalType\":\"contract VanillaGovernanceToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"wethReserves\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"VanillaRouter","CompilerVersion":"v0.6.8+commit.0bbfe453","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d00000000000000000000000000000000000000000000001b1ae4d6e2ef5000000000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000001e0000000000000000000000007fc66500c84a76ad7e9c93437bfc5ac33e2ddae9000000000000000000000000ff20817765cb7f73d4bde2e66e067e58d11095c2000000000000000000000000d46ba6d942050d489dbd938a2c909a5d5039a161000000000000000000000000a117000000f279d81a1d3cc75430faa017fa5a2e0000000000000000000000001337def18c680af1f9f45cbcab6309562975b1dd0000000000000000000000000d8775f648430679a709e98d2b0cb6250d2887ef000000000000000000000000c00e94cb662c3520282e6f5717214004a7f26888000000000000000000000000d533a949740bb3306d119cc777fa900ba034cd520000000000000000000000006b175474e89094c44da98b954eedeac495271d0f0000000000000000000000001494ca1f11d487c2bbe4543e90080aeba4ba3c2b0000000000000000000000006810e776880c02933d47db1b9fc05908e5386b96000000000000000000000000514910771af9ca656af840dff83e8264ecf986ca0000000000000000000000009f8f72aa9304c8b593d555f12ef6589cc3a579a2000000000000000000000000d26114cd6ee289accf82350c8d8487fedb8a0c07000000000000000000000000408e41876cccdc0f92210600ef50372656052a38000000000000000000000000d291e7a03283640fdc51b121ac401383a46cc62300000000000000000000000073968b9a57c6e53d41345fd57a6e6ae27d6cdb2f000000000000000000000000b753428af26e81097e7fd17f40c88aaa3e04902c000000000000000000000000c011a73ee8576fb46f5e1c5751ca3b9fe0af2a6f000000000000000000000000e53ec727dbdeb9e2d5456c3be40cff031ab40a550000000000000000000000006b3595068778dd592e39a122f4f5a5cf09c90fe20000000000000000000000004c19596f5aaff459fa38b0f7ed92f11ae65437840000000000000000000000000000000000085d4780b73119b644ae5ecd22b37600000000000000000000000004fa0d235c4abf4bcf4787af4cf447de572ef8280000000000000000000000001f9840a85d5af5bf1d1762f925bdaddc4201f984000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec70000000000000000000000001b40183efb4dd766f11bda7a7c3ad8982e9984210000000000000000000000002260fac5e5542a773aa44fbcfedf7c193bc2c5990000000000000000000000000bc529c00c6401aef6d220be8c6ea1667f6ad93e","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":""}]}