{"status":"1","message":"OK","result":[{"SourceCode":"# Copyright (C) 2021 VolumeFi Software, Inc.\r\n\r\n#  This program is free software: you can redistribute it and/or modify\r\n#  it under the terms of the Apache 2.0 License. \r\n#  This program is distributed WITHOUT ANY WARRANTY without even the implied warranty of\r\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\r\n#  @author VolumeFi, Software inc.\r\n#  @notice This Vyper contract Adds liquidity to any Balancer pool from ETH or any ERC20 Token.\r\n#  SPDX-License-Identifier: Apache-2.0\r\n\r\n# @version ^0.2.0\r\n\r\ninterface ERC20:\r\n    def allowance(owner: address, spender: address) -> uint256: view\r\n\r\ninterface BFactory:\r\n    def isBPool(b: address) -> bool: view\r\n\r\ninterface BPool:\r\n    def joinswapExternAmountIn(tokenIn: address, tokenAmountIn: uint256, minPoolAmountOut: uint256) -> uint256: payable\r\n    def isBound(t: address) -> bool: view\r\n    def getNumTokens() -> uint256: view\r\n\r\ninterface UniswapV2Factory:\r\n    def getPair(tokenA: address, tokenB: address) -> address: view\r\n\r\ninterface WrappedEth:\r\n    def deposit(): payable\r\n\r\nevent LPTokenMint:\r\n    lptoken: address\r\n    recipient: address\r\n    liquidity: uint256\r\n\r\nevent Paused:\r\n    paused: bool\r\n\r\nevent FeeChanged:\r\n    newFee: uint256\r\n\r\nUNISWAPV2ROUTER02: constant(address) = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\r\nUNISWAPV2FACTORY: constant(address) = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f\r\nBALANCERFACTORY: constant(address) = 0x9424B1412450D0f8Fc2255FAf6046b98213B76Bd\r\nVETH: constant(address) = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\r\nWETH: constant(address) = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\r\nDEADLINE: constant(uint256) = MAX_UINT256 # change\r\n\r\nTRANSFERFROM_MID: constant(Bytes[4]) = method_id(\"transferFrom(address,address,uint256)\")\r\nTRANSFER_MID: constant(Bytes[4]) = method_id(\"transfer(address,uint256)\")\r\nAPPROVE_MID: constant(Bytes[4]) = method_id(\"approve(address,uint256)\")\r\nSWAPETFT_MID: constant(Bytes[4]) = method_id(\"swapExactTokensForTokens(uint256,uint256,address[],address,uint256)\")\r\nGETCURRENTTOKENS_MID: constant(Bytes[4]) = method_id(\"getCurrentTokens()\")\r\n\r\npaused: public(bool)\r\nadmin: public(address)\r\nfeeAmount: public(uint256)\r\nfeeAddress: public(address)\r\n\r\n@external\r\ndef __init__():\r\n    self.paused = False\r\n    self.admin = msg.sender\r\n    self.feeAddress = 0xf29399fB3311082d9F8e62b988cBA44a5a98ebeD\r\n    self.feeAmount = 5 * 10 ** 15\r\n\r\n@internal\r\ndef _enter2Balancer(_toBalancerPoolAddress: address, _fromTokenContractAddress: address, tokens2Trade: uint256) -> uint256:\r\n    assert BPool(_toBalancerPoolAddress).isBound(_fromTokenContractAddress), \"Token not bound\"\r\n    _response32: Bytes[32] = empty(Bytes[32])\r\n    if ERC20(_fromTokenContractAddress).allowance(self, _toBalancerPoolAddress) > 0:\r\n        _response32 = raw_call(\r\n            _fromTokenContractAddress,\r\n            concat(\r\n                APPROVE_MID,\r\n                convert(_toBalancerPoolAddress, bytes32),\r\n                convert(0, bytes32)\r\n            ),\r\n            max_outsize=32\r\n        )  # dev: failed approve\r\n        if len(_response32) > 0:\r\n            assert convert(_response32, bool), \"Approve failed\"  # dev: failed approve\r\n    _response32 = raw_call(\r\n        _fromTokenContractAddress,\r\n        concat(\r\n            APPROVE_MID,\r\n            convert(_toBalancerPoolAddress, bytes32),\r\n            convert(tokens2Trade, bytes32)\r\n        ),\r\n        max_outsize=32\r\n    )  # dev: failed approve\r\n    if len(_response32) > 0:\r\n        assert convert(_response32, bool), \"Approve failed\"  # dev: failed approve\r\n    poolTokensOut: uint256 = BPool(_toBalancerPoolAddress).joinswapExternAmountIn(_fromTokenContractAddress, tokens2Trade, 1)\r\n    assert poolTokensOut > 0, \"Error in entering balancer pool\"\r\n    return poolTokensOut\r\n\r\ninterface UniswapV2Pair:\r\n    def token0() -> address: view\r\n    def token1() -> address: view\r\n    def getReserves() -> (uint256, uint256, uint256): view\r\n\r\n@internal\r\n@pure\r\ndef _getPairTokens(pair: address) -> (address, address):\r\n    token0: address = UniswapV2Pair(pair).token0()\r\n    token1: address = UniswapV2Pair(pair).token1()\r\n    return (token0, token1)\r\n\r\n@internal\r\n@view\r\ndef _getLiquidityInPool(midToken: address, pair: address) -> uint256:\r\n    res0: uint256 = 0\r\n    res1: uint256 = 0\r\n    token0: address = ZERO_ADDRESS\r\n    token1: address = ZERO_ADDRESS\r\n    blockTimestampLast: uint256 = 0\r\n    (res0, res1, blockTimestampLast) = UniswapV2Pair(pair).getReserves()\r\n    (token0, token1) = self._getPairTokens(pair)\r\n    if token0 == midToken:\r\n        return res0\r\n    else:\r\n        return res1\r\n\r\n@internal\r\n@view\r\ndef _getMidTokenNumber(midToken: address, tokens: address[8]) -> uint256:\r\n    maxeth: uint256 = 0\r\n    maxi: uint256 = 0\r\n    for i in range(8):\r\n        if tokens[i] == ZERO_ADDRESS:\r\n            break\r\n        if midToken == tokens[i]:\r\n            return i\r\n        pair: address = UniswapV2Factory(UNISWAPV2FACTORY).getPair(midToken, tokens[i])\r\n        eth: uint256 = 0\r\n        if pair != ZERO_ADDRESS:\r\n            eth = self._getLiquidityInPool(midToken, pair)\r\n        if eth > maxeth:\r\n            maxeth = eth\r\n            maxi = i\r\n    return maxi\r\n\r\n@internal\r\ndef _token2Token(fromToken: address, toToken: address, tokens2Trade: uint256, deadline: uint256) -> uint256:\r\n    if fromToken == toToken:\r\n        return tokens2Trade\r\n    _response32: Bytes[32] = empty(Bytes[32])\r\n    if ERC20(fromToken).allowance(self, UNISWAPV2ROUTER02) > 0:\r\n        _response32 = raw_call(\r\n            fromToken,\r\n            concat(\r\n                APPROVE_MID,\r\n                convert(UNISWAPV2ROUTER02, bytes32),\r\n                convert(0, bytes32)\r\n            ),\r\n            max_outsize=32\r\n        )  # dev: failed approve\r\n        if len(_response32) > 0:\r\n            assert convert(_response32, bool), \"Approve failed\"  # dev: failed approve\r\n    _response32 = raw_call(\r\n        fromToken,\r\n        concat(\r\n            APPROVE_MID,\r\n            convert(UNISWAPV2ROUTER02, bytes32),\r\n            convert(tokens2Trade, bytes32)\r\n        ),\r\n        max_outsize=32\r\n    )  # dev: failed approve\r\n    if len(_response32) > 0:\r\n        assert convert(_response32, bool), \"Approve failed\"  # dev: failed approve\r\n    \r\n    addrBytes: Bytes[288] = concat(convert(tokens2Trade, bytes32), convert(0, bytes32), convert(160, bytes32), convert(self, bytes32), convert(deadline, bytes32), convert(2, bytes32), convert(fromToken, bytes32), convert(toToken, bytes32))\r\n    funcsig: Bytes[4] = SWAPETFT_MID\r\n    full_data: Bytes[292] = concat(funcsig, addrBytes)\r\n    \r\n    _response128: Bytes[128] = raw_call(\r\n        UNISWAPV2ROUTER02,\r\n        full_data,\r\n        max_outsize=128\r\n    )\r\n    tokenBought: uint256 = convert(slice(_response128, 96, 32), uint256)\r\n    assert tokenBought > 0, \"Error Swapping Token 2\"\r\n    return tokenBought\r\n\r\n@internal\r\ndef _enter2BalancerViaUniswap(_toBalancerPoolAddress: address, _fromTokenContractAddress: address, _tokens2Trade: uint256) -> uint256:\r\n    tokens2Trade: uint256 = self._token2Token(_fromTokenContractAddress, WETH, _tokens2Trade, DEADLINE)\r\n    numTokens: uint256 = BPool(_toBalancerPoolAddress).getNumTokens()\r\n    \r\n    funcsig: Bytes[4] = GETCURRENTTOKENS_MID\r\n    \r\n    _response320: Bytes[320] = raw_call(\r\n        _toBalancerPoolAddress,\r\n        funcsig,\r\n        is_static_call=True,\r\n        max_outsize=320\r\n    )\r\n    tokens: address[8] = [ZERO_ADDRESS, ZERO_ADDRESS, ZERO_ADDRESS, ZERO_ADDRESS, ZERO_ADDRESS, ZERO_ADDRESS, ZERO_ADDRESS, ZERO_ADDRESS]\r\n    for i in range(8):\r\n        tokens[i] = convert(convert(slice(_response320, 32 * (convert(i, uint256) + 2), 32), uint256), address)\r\n        if convert(i, uint256) == (numTokens - 1):\r\n            break\r\n    midTokenNumber: uint256 = self._getMidTokenNumber(WETH, tokens)\r\n    tokens2Trade = self._token2Token(WETH, tokens[midTokenNumber], tokens2Trade, DEADLINE)\r\n    tokens2Trade = self._enter2Balancer(_toBalancerPoolAddress, tokens[midTokenNumber], tokens2Trade)\r\n    return tokens2Trade\r\n\r\n@external\r\n@payable\r\n@nonreentrant('lock')\r\ndef investTokenForBalancerPoolToken(_token: address, _pair: address, amount: uint256, minPoolTokens: uint256, deadline: uint256=DEADLINE) -> uint256:\r\n    assert amount > 0, \"Invalid input amount\"\r\n    assert block.timestamp <= deadline, \"Expired\"\r\n    assert not self.paused, \"Paused\"\r\n    assert BFactory(BALANCERFACTORY).isBPool(_pair), \"!Balancer Pool\"\r\n    fee: uint256 = self.feeAmount\r\n    assert msg.value >= fee, \"Insufficient fee\"\r\n    send(self.feeAddress, fee)\r\n    msg_value: uint256 = msg.value\r\n    msg_value -= fee\r\n    token: address = _token\r\n    _response32: Bytes[32] = empty(Bytes[32])\r\n    if token == VETH or token == ZERO_ADDRESS:\r\n        if msg_value > amount:\r\n            send(msg.sender, msg_value - amount)\r\n        else:\r\n            assert msg_value >= amount, \"Insufficient value\"\r\n        WrappedEth(WETH).deposit(value=amount)\r\n        token = WETH\r\n    else:\r\n        _response32 = raw_call(\r\n            token,\r\n            concat(\r\n                TRANSFERFROM_MID,\r\n                convert(msg.sender, bytes32),\r\n                convert(self, bytes32),\r\n                convert(amount, bytes32),\r\n            ),\r\n            max_outsize=32\r\n        )  # dev: failed transfer\r\n        if len(_response32) > 0:\r\n            assert convert(_response32, bool), \"TransferFrom failed\"  # dev: failed transfer\r\n    isBound: bool = BPool(_pair).isBound(token)\r\n    balancerTokens: uint256 = 0\r\n    if (isBound):\r\n        balancerTokens = self._enter2Balancer(_pair, token, amount)\r\n    else:\r\n        balancerTokens = self._enter2BalancerViaUniswap(_pair, token, amount)\r\n    _response32 = raw_call(\r\n        _pair,\r\n        concat(\r\n            TRANSFER_MID,\r\n            convert(msg.sender, bytes32),\r\n            convert(balancerTokens, bytes32),\r\n        ),\r\n        max_outsize=32\r\n    )  # dev: failed transfer\r\n    if len(_response32) > 0:\r\n        assert convert(_response32, bool), \"Transfer failed\"  # dev: failed transfer\r\n\r\n    assert balancerTokens >= minPoolTokens, \"High Slippage\"\r\n\r\n    log LPTokenMint(_pair, msg.sender, balancerTokens)\r\n\r\n    return balancerTokens\r\n\r\n# Admin functions\r\n@external\r\ndef pause(_paused: bool):\r\n    assert msg.sender == self.admin, \"Not admin\"\r\n    self.paused = _paused\r\n    log Paused(_paused)\r\n\r\n@external\r\ndef newAdmin(_admin: address):\r\n    assert msg.sender == self.admin, \"Not admin\"\r\n    self.admin = _admin\r\n\r\n@external\r\ndef newFeeAmount(_feeAmount: uint256):\r\n    assert msg.sender == self.admin, \"Not admin\"\r\n    self.feeAmount = _feeAmount\r\n    log FeeChanged(_feeAmount)\r\n\r\n@external\r\ndef newFeeAddress(_feeAddress: address):\r\n    assert msg.sender == self.admin, \"Not admin\"\r\n    self.feeAddress = _feeAddress\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef batchWithdraw(token: address[8], amount: uint256[8], to: address[8]):\r\n    assert msg.sender == self.admin, \"Not admin\"\r\n    for i in range(8):\r\n        if token[i] == VETH:\r\n            send(to[i], amount[i])\r\n        elif token[i] != ZERO_ADDRESS:\r\n            _response32: Bytes[32] = raw_call(\r\n                token[i],\r\n                concat(\r\n                    TRANSFER_MID,\r\n                    convert(to[i], bytes32),\r\n                    convert(amount[i], bytes32),\r\n                ),\r\n                max_outsize=32\r\n            )  # dev: failed transfer\r\n            if len(_response32) > 0:\r\n                assert convert(_response32, bool), \"Transfer failed\"  # dev: failed transfer\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef withdraw(token: address, amount: uint256, to: address):\r\n    assert msg.sender == self.admin, \"Not admin\"\r\n    if token == VETH:\r\n        send(to, amount)\r\n    elif token != ZERO_ADDRESS:\r\n        _response32: Bytes[32] = raw_call(\r\n            token,\r\n            concat(\r\n                TRANSFER_MID,\r\n                convert(to, bytes32),\r\n                convert(amount, bytes32),\r\n            ),\r\n            max_outsize=32\r\n        )  # dev: failed transfer\r\n        if len(_response32) > 0:\r\n            assert convert(_response32, bool), \"Transfer failed\"  # dev: failed transfer\r\n\r\n@external\r\n@payable\r\ndef __default__():\r\n    assert msg.sender == WETH, \"can't receive Eth\"","ABI":"[{\"name\":\"LPTokenMint\",\"inputs\":[{\"name\":\"lptoken\",\"type\":\"address\",\"indexed\":false},{\"name\":\"recipient\",\"type\":\"address\",\"indexed\":false},{\"name\":\"liquidity\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Paused\",\"inputs\":[{\"name\":\"paused\",\"type\":\"bool\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"FeeChanged\",\"inputs\":[{\"name\":\"newFee\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"investTokenForBalancerPoolToken\",\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_pair\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"minPoolTokens\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"investTokenForBalancerPoolToken\",\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_pair\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"minPoolTokens\",\"type\":\"uint256\"},{\"name\":\"deadline\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"pause\",\"inputs\":[{\"name\":\"_paused\",\"type\":\"bool\"}],\"outputs\":[],\"gas\":37741},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"newAdmin\",\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"}],\"outputs\":[],\"gas\":36424},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"newFeeAmount\",\"inputs\":[{\"name\":\"_feeAmount\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":37701},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"newFeeAddress\",\"inputs\":[{\"name\":\"_feeAddress\",\"type\":\"address\"}],\"outputs\":[],\"gas\":36484},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"batchWithdraw\",\"inputs\":[{\"name\":\"token\",\"type\":\"address[8]\"},{\"name\":\"amount\",\"type\":\"uint256[8]\"},{\"name\":\"to\",\"type\":\"address[8]\"}],\"outputs\":[],\"gas\":338340},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"withdraw\",\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"to\",\"type\":\"address\"}],\"outputs\":[],\"gas\":92440},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"paused\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":1388},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":1418},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"feeAmount\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":1448},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"feeAddress\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":1478}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.11","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":""}]}