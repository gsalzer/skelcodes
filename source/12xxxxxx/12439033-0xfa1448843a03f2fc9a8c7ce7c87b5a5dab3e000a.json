{"status":"1","message":"OK","result":[{"SourceCode":"{\"Addresses.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\n/**\\n * Utility library of inline functions on addresses\\n */\\nlibrary Address {\\n  \\n\\n  /**\\n   * Returns whether the target address is a contract\\n   * @dev This function will return false if invoked during the constructor of a contract,\\n   * as the code is not actually created until after the constructor finishes.\\n   * @param account address to check\\n   * @return whether the target address is a contract\\n   */\\n  function isContract(address account) internal view returns (bool) {\\n      // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n      // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n      // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`\\n      bytes32 codehash;\\n      bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n      // solhint-disable-next-line no-inline-assembly\\n      assembly { codehash := extcodehash(account) }\\n      return (codehash != accountHash \\u0026\\u0026 codehash != 0x0);\\n  }\\n\\n}\"},\"BaseERC721.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\nimport \\\"./ERC721Token.sol\\\";\\nimport \\\"./ERC20Interface.sol\\\";\\nimport \\\"./Freezable.sol\\\";\\n\\n/**\\n * @title Base ERC721 token\\n * @author Prashant Prabhakar Singh [prashantprabhakar123@gmail.com]\\n * This contract implements basic ERC721 token functionality with bulk functionalities\\n */\\ncontract BaseERC721 is ERC721Token, Freezable {\\n\\n  constructor(string memory name, string memory symbol, string memory _baseTokenURI) public  ERC721Token(name, symbol){\\n    baseTokenURI = _baseTokenURI;\\n  }\\n\\n  /**\\n   * @dev Updates the base URL of token\\n   * Reverts if the sender is not owner\\n   * @param _newURI New base URL\\n   */\\n  function updateBaseTokenURI(string memory _newURI)\\n    public\\n    onlyOwner\\n    noEmergencyFreeze\\n  {\\n    baseTokenURI = _newURI;\\n  }\\n\\n  /**\\n   * @dev Mints new token on blockchain\\n   * Reverts if the sender is not operator with level 1\\n   * @param _id Id of NFT to be minted\\n   * @dev URI is not provided because URI will be deducted based on baseURL\\n   */\\n  function mint(uint256 _id, address _to)\\n    public\\n    onlyDeputyOrOwner\\n    noEmergencyFreeze\\n    returns (bool)\\n  {\\n    super._mint(_to, _id);\\n    return true;\\n  }\\n\\n  function bulkMint(uint[] memory _ids, address[] memory _users)\\n    public\\n    onlyDeputyOrOwner\\n    noEmergencyFreeze\\n    returns (bool)\\n  {\\n    require(_ids.length == _users.length, \\\"Invalid params\\\");\\n    for(uint i=0; i\\u003c_ids.length; i++) {\\n      super._mint(_users[i], _ids[i]);\\n    }\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Transfer tokens (similar to ERC-20 transfer)\\n   * Reverts if the sender is not owner of the NFT or approved\\n   * @param _to address to which token is transferred\\n   * @param _tokenId Id of NFT being transferred\\n   */\\n  function transfer(address _to, uint256 _tokenId)\\n    public\\n    noEmergencyFreeze\\n    returns (bool)\\n  {\\n    safeTransferFrom(msg.sender, _to, _tokenId);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Burn an existing NFT\\n   * @param _id Id of NFT to be burned\\n   */\\n  function burn(uint _id)\\n    public\\n    noEmergencyFreeze\\n    returns (bool)\\n  {\\n    super._burn(msg.sender, _id);\\n    return true;\\n  }\\n\\n  //////////////////////////////////////////\\n  // PUBLICLY ACCESSIBLE METHODS (CONSTANT)\\n  //////////////////////////////////////////\\n\\n}\"},\"CustomERC721.sol\":{\"content\":\"/**\\n * This is custom ERC-721 token with some add on functionalities\\n*/\\n\\npragma solidity 0.5.17;\\n\\nimport \\\"./BaseERC721.sol\\\";\\n\\n/**\\n * @title CustomERC721\\n * @author Prashant Prabhakar Singh [prashantprabhakar123@gmail.com]\\n */\\ncontract CustomERC721 is BaseERC721 {\\n\\n  // mapping for replay protection\\n  mapping(address =\\u003e uint) private userNonce;\\n\\n  bool public isNormalUserAllowed; // can normal user access advanced features\\n  \\n  constructor(string memory name, string memory symbol, string memory baseURI) public BaseERC721(name, symbol, baseURI) {\\n    isNormalUserAllowed = false;\\n  }\\n\\n  modifier canAccessProvableFunctions() {\\n    require(isNormalUserAllowed || msg.sender == owner || isDeputyOwner[msg.sender], \\\"Not allowed to access provable fns\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Allows normal users to call provable fns\\n   * Reverts if the sender is not owner of contract\\n   * @param _perm permission to users\\n   */\\n  function allowNormalUser(bool _perm)\\n    public \\n    onlyOwner\\n  {\\n    isNormalUserAllowed = _perm;\\n  }\\n  \\n  /**\\n   * @dev Allows submitting already signed transaction\\n   * Reverts if the signed data is incorrect\\n   * @param message signed message by user\\n   * @param r signature\\n   * @param s signature\\n   * @param v recovery id of signature\\n   * @param spender address which is approved\\n   * @param approved bool value for status of approval\\n   * message should be hash(functionWord, contractAddress, nonce, fnParams)\\n   */\\n  function provable_setApprovalForAll(bytes32 message, bytes32 r, bytes32 s, uint8 v, address spender, bool approved)\\n    public\\n    noEmergencyFreeze\\n    canAccessProvableFunctions\\n  {\\n    address signer = getSigner(message, r, s, v);\\n    require (signer != address(0), \\\"Invalid signer\\\");\\n\\n    bytes32 proof = getMessageSetApprovalForAll(signer, spender, approved);\\n    require(proof == message, \\\"Invalid proof\\\");\\n\\n    // perform the original set Approval\\n    operatorApprovals[signer][spender] = approved;\\n    emit ApprovalForAll(signer, spender, approved);\\n    userNonce[signer] = userNonce[signer].add(1);\\n  }\\n\\n  /**\\n   * @dev Allows submitting already signed transaction for NFT transfer\\n   * Reverts if the signed data is incorrect\\n   * @param message signed message by user\\n   * @param r signature\\n   * @param s signature\\n   * @param v recovery id of signature\\n   * @param to recipient address\\n   * @param tokenId ID of NFT\\n   * message should be hash(functionWord, contractAddress, nonce, fnParams)\\n   */\\n  function provable_transfer(bytes32 message, bytes32 r, bytes32 s, uint8 v, address to, uint tokenId)\\n    public \\n    noEmergencyFreeze\\n    canAccessProvableFunctions\\n  {\\n    address signer = getSigner(message, r, s, v);\\n    require (signer != address(0),\\\"Invalid signer\\\");\\n\\n    bytes32 proof = getMessageTransfer(signer, to, tokenId);\\n    require (proof == message, \\\"Invalid proof\\\");\\n    \\n    // Execute original function\\n    require(to != address(0), \\\"Zero address not allowed\\\");\\n    clearApproval(signer, tokenId);\\n    removeTokenFrom(signer, tokenId);\\n    addTokenTo(to, tokenId);\\n    emit Transfer(signer, to, tokenId);\\n\\n    // update state variables\\n    userNonce[signer] = userNonce[signer].add(1);\\n  }\\n\\n  /**\\n   * @dev Check signer of a message\\n   * @param message signed message by user\\n   * @param r signature\\n   * @param s signature\\n   * @param v recovery id of signature\\n   * @return signer of message\\n   */\\n  function getSigner(bytes32 message, bytes32 r, bytes32 s,  uint8 v) public pure returns (address){\\n    bytes memory prefix = \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\";\\n    bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, message));\\n    address signer = ecrecover(prefixedHash,v,r,s);\\n    return signer;\\n  }\\n\\n  /**\\n   * @dev Get message to be signed for transfer\\n   * @param signer of message\\n   * @param to recipient address\\n   * @param id NFT id\\n   * @return hash of (functionWord, contractAddress, nonce, ...fnParams)\\n   */\\n  function getMessageTransfer(address signer, address to, uint id)\\n    public\\n    view\\n    returns (bytes32) \\n  {\\n    return keccak256(abi.encodePacked(\\n      bytes4(0xb483afd3),\\n      address(this),\\n      userNonce[signer],\\n      to,\\n      id\\n    ));\\n  }\\n\\n  /**\\n   * @dev Get message to be signed for set Approval\\n   * @param signer of message\\n   * @param spender address which is approved\\n   * @param approved bool value for status of approval\\n   * @return hash of (functionWord, contractAddress, nonce, ...fnParams)\\n   */\\n  function getMessageSetApprovalForAll(address signer, address spender, bool approved)\\n    public \\n    view \\n    returns (bytes32)\\n  {\\n    bytes32 proof = keccak256(abi.encodePacked(\\n      bytes4(0xbad4c8ea),\\n      address(this),\\n      userNonce[signer],\\n      spender,\\n      approved\\n    ));\\n    return proof;\\n  }\\n\\n  /**\\n  * returns nonce of user to be used for next signing\\n  */\\n  function getUserNonce(address user) public view returns (uint) {\\n    return userNonce[user];\\n  }\\n\\n  /**\\n   * @dev Owner can transfer out any accidentally sent ERC20 tokens\\n   * @param contractAddress ERC20 contract address\\n   * @param to withdrawal address\\n   * @param value no of tokens to be withdrawan\\n   */\\n  function transferAnyERC20Token(address contractAddress, address to,  uint value) public onlyOwner {\\n    ERC20Interface(contractAddress).transfer(to, value);\\n  }\\n\\n  /**\\n   * @dev Owner can transfer out any accidentally sent ERC721 tokens\\n   * @param contractAddress ERC721 contract address\\n   * @param to withdrawal address\\n   * @param tokenId Id of 721 token\\n   */\\n  function withdrawAnyERC721Token(address contractAddress, address to, uint tokenId) public onlyOwner {\\n    ERC721Basic(contractAddress).safeTransferFrom(address(this), to, tokenId);\\n  }\\n\\n  /**\\n   * @dev Owner kill the smart contract\\n   * @param message Confirmation message to prevent accidebtal calling\\n   * @notice BE VERY CAREFULL BEFORE CALLING THIS FUNCTION\\n   * Better pause the contract\\n   * DO CALL \\\"transferAnyERC20Token\\\" before TO WITHDRAW ANY ERC-2O\\u0027s FROM CONTRACT\\n   */\\n  function kill(uint message) public onlyOwner {\\n    require (message == 123456789987654321, \\\"Invalid code\\\");\\n    // Transfer Eth to owner and terminate contract\\n    selfdestruct(msg.sender);\\n  }\\n\\n}\"},\"ERC165.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\n/**\\n * @title ERC165\\n * @author Prashant Prabhakar Singh [prashantprabhakar123@gmail.com]\\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\\n */\\ninterface ERC165 {\\n\\n  /**\\n   * @notice Query if a contract implements an interface\\n   * @param _interfaceId The interface identifier, as specified in ERC-165\\n   * @dev Interface identification is specified in ERC-165. This function\\n   * uses less than 30,000 gas.\\n   */\\n  function supportsInterface(bytes4 _interfaceId)\\n    external\\n    view\\n    returns (bool);\\n}\\n\"},\"ERC20Interface.sol\":{\"content\":\"pragma solidity ^0.5.17;\\n\\ncontract ERC20Interface {\\n  function transfer(address to, uint tokens) public returns (bool success);\\n  function balanceOf(address _sender) public view returns (uint _bal);\\n  function allowance(address tokenOwner, address spender) public view returns (uint remaining);\\n  event Transfer(address indexed from, address indexed to, uint tokens);\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n  function transferFrom(address from, address to, uint tokens) public returns (bool success);\\n}\"},\"ERC721.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\nimport \\\"./ERC721Basic.sol\\\";\\nimport \\\"./ERC721Enumerable.sol\\\";\\nimport \\\"./ERC721Metadata.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, full implementation interface\\n * @author Prashant Prabhakar Singh [prashantprabhakar123@gmail.com]\\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\n */\\ncontract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {\\n\\n}\"},\"ERC721Basic.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\nimport \\\"./ERC165.sol\\\";\\n\\n/**\\n * @title ERC721 Non-Fungible Token Standard basic interface\\n * @author Prashant Prabhakar Singh [prashantprabhakar123@gmail.com]\\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\n */\\ncontract ERC721Basic is ERC165 {\\n  event Transfer(\\n    address indexed _from,\\n    address indexed _to,\\n    uint256 indexed _tokenId\\n  );\\n  event Approval(\\n    address indexed _owner,\\n    address indexed _approved,\\n    uint256 indexed _tokenId\\n  );\\n  event ApprovalForAll(\\n    address indexed _owner,\\n    address indexed _operator,\\n    bool _approved\\n  );\\n\\n  function balanceOf(address _owner) public view returns (uint256 _balance);\\n  function ownerOf(uint256 _tokenId) public view returns (address _owner);\\n  function exists(uint256 _tokenId) public view returns (bool _exists);\\n\\n  function approve(address _to, uint256 _tokenId) public;\\n  function getApproved(uint256 _tokenId)\\n    public view returns (address _operator);\\n\\n  function setApprovalForAll(address _operator, bool _approved) public;\\n  function isApprovedForAll(address _owner, address _operator)\\n    public view returns (bool);\\n\\n  function transferFrom(address _from, address _to, uint256 _tokenId) public;\\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId)\\n    public;\\n\\n  function safeTransferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _tokenId,\\n    bytes memory _data\\n  )\\n    public;\\n}\"},\"ERC721BasicToken.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\nimport \\\"./SupportsInterfaceWithLookup.sol\\\";\\nimport \\\"./ERC721Basic.sol\\\";\\nimport \\\"./ERC721Receiver.sol\\\";\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Addresses.sol\\\";\\n\\n/**\\n * @title ERC721 Non-Fungible Token Standard basic implementation\\n * @author Prashant Prabhakar Singh [prashantprabhakar123@gmail.com]\\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\n */\\ncontract ERC721BasicToken is SupportsInterfaceWithLookup, ERC721Basic {\\n\\n  bytes4 private constant InterfaceId_ERC721 = 0x80ac58cd;\\n  /*\\n   * 0x80ac58cd ===\\n   *   bytes4(keccak256(\\u0027balanceOf(address)\\u0027)) ^\\n   *   bytes4(keccak256(\\u0027ownerOf(uint256)\\u0027)) ^\\n   *   bytes4(keccak256(\\u0027approve(address,uint256)\\u0027)) ^\\n   *   bytes4(keccak256(\\u0027getApproved(uint256)\\u0027)) ^\\n   *   bytes4(keccak256(\\u0027setApprovalForAll(address,bool)\\u0027)) ^\\n   *   bytes4(keccak256(\\u0027isApprovedForAll(address,address)\\u0027)) ^\\n   *   bytes4(keccak256(\\u0027transferFrom(address,address,uint256)\\u0027)) ^\\n   *   bytes4(keccak256(\\u0027safeTransferFrom(address,address,uint256)\\u0027)) ^\\n   *   bytes4(keccak256(\\u0027safeTransferFrom(address,address,uint256,bytes)\\u0027))\\n   */\\n\\n  bytes4 private constant InterfaceId_ERC721Exists = 0x4f558e79;\\n  /*\\n   * 0x4f558e79 ===\\n   *   bytes4(keccak256(\\u0027exists(uint256)\\u0027))\\n   */\\n\\n  using SafeMath for uint256;\\n  using Address for address;\\n\\n  // Equals to `bytes4(keccak256(\\\"onERC721Received(address,uint256,bytes)\\\"))`\\n  // which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\\n  bytes4 private constant ERC721_RECEIVED = 0xf0b9e5ba;\\n\\n  // Mapping from token ID to owner\\n  mapping (uint256 =\\u003e address) internal tokenOwner;\\n\\n  // Mapping from token ID to approved address\\n  mapping (uint256 =\\u003e address) internal tokenApprovals;\\n\\n  // Mapping from owner to number of owned token\\n  mapping (address =\\u003e uint256) internal ownedTokensCount;\\n\\n  // Mapping from owner to operator approvals\\n  mapping (address =\\u003e mapping (address =\\u003e bool)) internal operatorApprovals;\\n\\n  /**\\n   * @dev Guarantees msg.sender is owner of the given token\\n   * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender\\n   */\\n  modifier onlyOwnerOf(uint256 _tokenId) {\\n    require(ownerOf(_tokenId) == msg.sender, \\\"Only asset owner is allowed\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Checks msg.sender can transfer a token, by being owner, approved, or operator\\n   * @param _tokenId uint256 ID of the token to validate\\n   */\\n  modifier canTransfer(uint256 _tokenId) {\\n    require(isApprovedOrOwner(msg.sender, _tokenId), \\\"Can not transfer\\\");\\n    _;\\n  }\\n\\n  constructor()\\n    public\\n  {\\n    // register the supported interfaces to conform to ERC721 via ERC165\\n    _registerInterface(InterfaceId_ERC721);\\n    _registerInterface(InterfaceId_ERC721Exists);\\n  }\\n\\n  /**\\n   * @dev Gets the balance of the specified address\\n   * @param _owner address to query the balance of\\n   * @return uint256 representing the amount owned by the passed address\\n   */\\n  function balanceOf(address _owner) public view returns (uint256) {\\n    require(_owner != address(0), \\\"Zero address not allowed\\\");\\n    return ownedTokensCount[_owner];\\n  }\\n\\n  /**\\n   * @dev Gets the owner of the specified token ID\\n   * @param _tokenId uint256 ID of the token to query the owner of\\n   * @return owner address currently marked as the owner of the given token ID\\n   */\\n  function ownerOf(uint256 _tokenId) public view returns (address) {\\n    address owner = tokenOwner[_tokenId];\\n    require(owner != address(0), \\\"Zero address not allowed\\\");\\n    return owner;\\n  }\\n\\n  /**\\n   * @dev Returns whether the specified token exists\\n   * @param _tokenId uint256 ID of the token to query the existence of\\n   * @return whether the token exists\\n   */\\n  function exists(uint256 _tokenId) public view returns (bool) {\\n    address owner = tokenOwner[_tokenId];\\n    return owner != address(0);\\n  }\\n\\n  /**\\n   * @dev Approves another address to transfer the given token ID\\n   * The zero address indicates there is no approved address.\\n   * There can only be one approved address per token at a given time.\\n   * Can only be called by the token owner or an approved operator.\\n   * @param _to address to be approved for the given token ID\\n   * @param _tokenId uint256 ID of the token to be approved\\n   */\\n  function approve(address _to, uint256 _tokenId) public {\\n    address owner = ownerOf(_tokenId);\\n    require(_to != owner, \\\"Can not approve to self\\\");\\n    require(msg.sender == owner || isApprovedForAll(owner, msg.sender), \\\"Not allowed to update approvals\\\");\\n\\n    tokenApprovals[_tokenId] = _to;\\n    emit Approval(owner, _to, _tokenId);\\n  }\\n\\n  /**\\n   * @dev Gets the approved address for a token ID, or zero if no address set\\n   * @param _tokenId uint256 ID of the token to query the approval of\\n   * @return address currently approved for the given token ID\\n   */\\n  function getApproved(uint256 _tokenId) public view returns (address) {\\n    return tokenApprovals[_tokenId];\\n  }\\n\\n  /**\\n   * @dev Sets or unsets the approval of a given operator\\n   * An operator is allowed to transfer all tokens of the sender on their behalf\\n   * @param _to operator address to set the approval\\n   * @param _approved representing the status of the approval to be set\\n   */\\n  function setApprovalForAll(address _to, bool _approved) public {\\n    require(_to != msg.sender, \\\"Can not approve to self\\\");\\n    operatorApprovals[msg.sender][_to] = _approved;\\n    emit ApprovalForAll(msg.sender, _to, _approved);\\n  }\\n\\n  /**\\n   * @dev Tells whether an operator is approved by a given owner\\n   * @param _owner owner address which you want to query the approval of\\n   * @param _operator operator address which you want to query the approval of\\n   * @return bool whether the given operator is approved by the given owner\\n   */\\n  function isApprovedForAll(\\n    address _owner,\\n    address _operator\\n  )\\n    public\\n    view\\n    returns (bool)\\n  {\\n    return operatorApprovals[_owner][_operator];\\n  }\\n\\n  /**\\n   * @dev Transfers the ownership of a given token ID to another address\\n   * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\\n   * Requires the msg sender to be the owner, approved, or operator\\n   * @param _from current owner of the token\\n   * @param _to address to receive the ownership of the given token ID\\n   * @param _tokenId uint256 ID of the token to be transferred\\n  */\\n  function transferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _tokenId\\n  )\\n    public\\n    canTransfer(_tokenId)\\n  \\n  {\\n    require(_from != address(0), \\\"Zero address not allowed\\\");\\n    require(_to != address(0), \\\"Zero address not allowed\\\");\\n\\n    clearApproval(_from, _tokenId);\\n    removeTokenFrom(_from, _tokenId);\\n    addTokenTo(_to, _tokenId);\\n\\n    emit Transfer(_from, _to, _tokenId);\\n  }\\n\\n  /**\\n   * @dev Safely transfers the ownership of a given token ID to another address\\n   * If the target address is a contract, it must implement `onERC721Received`,\\n   * which is called upon a safe transfer, and return the magic value\\n   * `bytes4(keccak256(\\\"onERC721Received(address,uint256,bytes)\\\"))`; otherwise,\\n   * the transfer is reverted.\\n   *\\n   * Requires the msg sender to be the owner, approved, or operator\\n   * @param _from current owner of the token\\n   * @param _to address to receive the ownership of the given token ID\\n   * @param _tokenId uint256 ID of the token to be transferred\\n  */\\n  function safeTransferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _tokenId\\n  )\\n    public\\n    canTransfer(_tokenId)\\n  \\n  {\\n    // solium-disable-next-line arg-overflow\\n    safeTransferFrom(_from, _to, _tokenId, \\\"\\\");\\n  }\\n\\n  /**\\n   * @dev Safely transfers the ownership of a given token ID to another address\\n   * If the target address is a contract, it must implement `onERC721Received`,\\n   * which is called upon a safe transfer, and return the magic value\\n   * `bytes4(keccak256(\\\"onERC721Received(address,uint256,bytes)\\\"))`; otherwise,\\n   * the transfer is reverted.\\n   * Requires the msg sender to be the owner, approved, or operator\\n   * @param _from current owner of the token\\n   * @param _to address to receive the ownership of the given token ID\\n   * @param _tokenId uint256 ID of the token to be transferred\\n   * @param _data bytes data to send along with a safe transfer check\\n   */\\n  function safeTransferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _tokenId,\\n    bytes memory _data\\n  )\\n    public\\n    canTransfer(_tokenId)\\n  {\\n    transferFrom(_from, _to, _tokenId);\\n    // solium-disable-next-line arg-overflow\\n    require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data), \\\"Safe Transfer failed\\\");\\n  }\\n\\n  /**\\n   * @dev Returns whether the given spender can transfer a given token ID\\n   * @param _spender address of the spender to query\\n   * @param _tokenId uint256 ID of the token to be transferred\\n   * @return bool whether the msg.sender is approved for the given token ID,\\n   *  is an operator of the owner, or is the owner of the token\\n   */\\n  function isApprovedOrOwner(\\n    address _spender,\\n    uint256 _tokenId\\n  )\\n    internal\\n    view\\n    returns (bool)\\n  {\\n    address owner = ownerOf(_tokenId);\\n    // Disable solium check because of\\n    // https://github.com/duaraghav8/Solium/issues/175\\n    // solium-disable-next-line operator-whitespace\\n    return (\\n      _spender == owner ||\\n      getApproved(_tokenId) == _spender ||\\n      isApprovedForAll(owner, _spender)\\n    );\\n  }\\n\\n  /**\\n   * @dev Internal function to mint a new token\\n   * Reverts if the given token ID already exists\\n   * @param _to The address that will own the minted token\\n   * @param _tokenId uint256 ID of the token to be minted by the msg.sender\\n   */\\n  function _mint(address _to, uint256 _tokenId) internal {\\n    require(_to != address(0), \\\"Zero address not allowed\\\");\\n    addTokenTo(_to, _tokenId);\\n    emit Transfer(address(0), _to, _tokenId);\\n  }\\n\\n  /**\\n   * @dev Internal function to burn a specific token\\n   * Reverts if the token does not exist\\n   * @param _tokenId uint256 ID of the token being burned by the msg.sender\\n   */\\n  function _burn(address _owner, uint256 _tokenId) internal {\\n    clearApproval(_owner, _tokenId);\\n    removeTokenFrom(_owner, _tokenId);\\n    emit Transfer(_owner, address(0), _tokenId);\\n  }\\n\\n  /**\\n   * @dev Internal function to clear current approval of a given token ID\\n   * Reverts if the given address is not indeed the owner of the token\\n   * @param _owner owner of the token\\n   * @param _tokenId uint256 ID of the token to be transferred\\n   */\\n  function clearApproval(address _owner, uint256 _tokenId) internal {\\n    require(ownerOf(_tokenId) == _owner, \\\"Asset does not belong to given owmer\\\");\\n    if (tokenApprovals[_tokenId] != address(0)) {\\n      tokenApprovals[_tokenId] = address(0);\\n      emit Approval(_owner, address(0), _tokenId);\\n    }\\n  }\\n\\n  /**\\n   * @dev Internal function to add a token ID to the list of a given address\\n   * @param _to address representing the new owner of the given token ID\\n   * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\\n   */\\n  function addTokenTo(address _to, uint256 _tokenId) internal {\\n    require(tokenOwner[_tokenId] == address(0), \\\"Asset already exists\\\");\\n    tokenOwner[_tokenId] = _to;\\n    ownedTokensCount[_to] = ownedTokensCount[_to].add(1);\\n  }\\n\\n  /**\\n   * @dev Internal function to remove a token ID from the list of a given address\\n   * @param _from address representing the previous owner of the given token ID\\n   * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\\n   */\\n  function removeTokenFrom(address _from, uint256 _tokenId) internal {\\n    require(ownerOf(_tokenId) == _from, \\\"Asset does not belong to given owmer\\\");\\n    ownedTokensCount[_from] = ownedTokensCount[_from].sub(1);\\n    tokenOwner[_tokenId] = address(0);\\n  }\\n\\n  /**\\n   * @dev Internal function to invoke `onERC721Received` on a target address\\n   * The call is not executed if the target address is not a contract\\n   * @param _from address representing the previous owner of the given token ID\\n   * @param _to target address that will receive the tokens\\n   * @param _tokenId uint256 ID of the token to be transferred\\n   * @param _data bytes optional data to send along with the call\\n   * @return whether the call correctly returned the expected magic value\\n   */\\n  function checkAndCallSafeTransfer(\\n    address _from,\\n    address _to,\\n    uint256 _tokenId,\\n    bytes memory _data\\n  )\\n    internal\\n    returns (bool)\\n  {\\n    if (!_to.isContract()) {\\n      return true;\\n    }\\n    bytes4 retval = ERC721Receiver(_to).onERC721Received(\\n      _from, _tokenId, _data);\\n    return (retval == ERC721_RECEIVED);\\n  }\\n}\"},\"ERC721Enumerable.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\nimport \\\"./ERC721Basic.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @author Prashant Prabhakar Singh [prashantprabhakar123@gmail.com]\\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\n */\\ncontract ERC721Enumerable is ERC721Basic {\\n  function totalSupply() public view returns (uint256);\\n  function tokenOfOwnerByIndex(\\n    address _owner,\\n    uint256 _index\\n  )\\n    public\\n    view\\n    returns (uint256 _tokenId);\\n\\n  function tokenByIndex(uint256 _index) public view returns (uint256);\\n}\"},\"ERC721Metadata.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\nimport \\\"./ERC721Basic.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata \\n * @author Prashant Prabhakar Singh [prashantprabhakar123@gmail.com]\\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\n */\\ncontract ERC721Metadata is ERC721Basic {\\n  function name() external view returns (string memory _name);\\n  function symbol() external view returns (string memory _symbol);\\n  function tokenURI(uint256 _tokenId) public view returns (string memory);\\n}\"},\"ERC721Receiver.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @author Prashant Prabhakar Singh [prashantprabhakar123@gmail.com]\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ncontract ERC721Receiver {\\n  /**\\n   * @dev Magic value to be returned upon successful reception of an NFT\\n   *  Equals to `bytes4(keccak256(\\\"onERC721Received(address,uint256,bytes)\\\"))`,\\n   *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\\n   */\\n  bytes4 internal constant ERC721_RECEIVED = 0xf0b9e5ba;\\n\\n  /**\\n   * @notice Handle the receipt of an NFT\\n   * @dev The ERC721 smart contract calls this function on the recipient\\n   * after a `safetransfer`. This function MAY throw to revert and reject the\\n   * transfer. This function MUST use 50,000 gas or less. Return of other\\n   * than the magic value MUST result in the transaction being reverted.\\n   * Note: the contract address is always the message sender.\\n   * @param _from The sending address\\n   * @param _tokenId The NFT identifier which is being transfered\\n   * @param _data Additional data with no specified format\\n   * @return `bytes4(keccak256(\\\"onERC721Received(address,uint256,bytes)\\\"))`\\n   */\\n  function onERC721Received(\\n    address _from,\\n    uint256 _tokenId,\\n    bytes memory _data\\n  )\\n    public\\n    returns(bytes4);\\n}\"},\"ERC721Token.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\nimport \\\"./ERC721.sol\\\";\\nimport \\\"./ERC721BasicToken.sol\\\";\\nimport \\\"./SupportsInterfaceWithLookup.sol\\\";\\nimport \\\"./Strings.sol\\\";\\n\\n\\n/**\\n * @title Full ERC721 Token\\n * @author Prashant Prabhakar Singh [prashantprabhakar123@gmail.com]\\n * This implementation includes all the required and some optional functionality of the ERC721 standard\\n * Moreover, it includes approve all functionality using operator terminology\\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\n */\\ncontract ERC721Token is SupportsInterfaceWithLookup, ERC721BasicToken, ERC721 {\\n\\n  bytes4 private constant InterfaceId_ERC721Enumerable = 0x780e9d63;\\n  /**\\n   * 0x780e9d63 ===\\n   *   bytes4(keccak256(\\u0027totalSupply()\\u0027)) ^\\n   *   bytes4(keccak256(\\u0027tokenOfOwnerByIndex(address,uint256)\\u0027)) ^\\n   *   bytes4(keccak256(\\u0027tokenByIndex(uint256)\\u0027))\\n   */\\n\\n  bytes4 private constant InterfaceId_ERC721Metadata = 0x5b5e139f;\\n  /**\\n   * 0x5b5e139f ===\\n   *   bytes4(keccak256(\\u0027name()\\u0027)) ^\\n   *   bytes4(keccak256(\\u0027symbol()\\u0027)) ^\\n   *   bytes4(keccak256(\\u0027tokenURI(uint256)\\u0027))\\n   */\\n\\n  // Token name\\n  string internal name_;\\n\\n  // Token symbol\\n  string internal symbol_;\\n\\n  // to store base URL\\n  string internal baseTokenURI;\\n\\n  // Mapping from owner to list of owned token IDs\\n  mapping(address =\\u003e uint256[]) internal ownedTokens;\\n\\n  // Mapping from token ID to index of the owner tokens list\\n  mapping(uint256 =\\u003e uint256) internal ownedTokensIndex;\\n\\n  // Array with all token ids, used for enumeration\\n  uint256[] internal allTokens;\\n\\n  // Mapping from token id to position in the allTokens array\\n  mapping(uint256 =\\u003e uint256) internal allTokensIndex;\\n\\n  /**\\n   * @dev Constructor function\\n   */\\n  constructor(string memory _name, string memory _symbol) public {\\n    name_ = _name;\\n    symbol_ = _symbol;\\n\\n    // register the supported interfaces to conform to ERC721 via ERC165\\n    _registerInterface(InterfaceId_ERC721Enumerable);\\n    _registerInterface(InterfaceId_ERC721Metadata);\\n  }\\n\\n  /**\\n   * @dev Gets the token name\\n   * @return string representing the token name\\n   */\\n  function name() external view returns (string memory) {\\n    return name_;\\n  }\\n\\n  /**\\n   * @dev Gets the token symbol\\n   * @return string representing the token symbol\\n   */\\n  function symbol() external view returns (string memory) {\\n    return symbol_;\\n  }\\n\\n  /**\\n   * @dev Returns an URI for a given token ID\\n   * Throws if the token ID does not exist. May return an empty string.\\n   * @param _tokenId uint256 ID of the token to query\\n   */\\n  function tokenURI(uint256 _tokenId) public view returns (string memory) {\\n    require(exists(_tokenId), \\\"Asset does not exist\\\");\\n    return string(abi.encodePacked(baseTokenURI, Strings.toString(_tokenId)));\\n  }\\n\\n  /**\\n   * @dev Gets the token ID at a given index of the tokens list of the requested owner\\n   * @param _owner address owning the tokens list to be accessed\\n   * @param _index uint256 representing the index to be accessed of the requested tokens list\\n   * @return uint256 token ID at the given index of the tokens list owned by the requested address\\n   */\\n  function tokenOfOwnerByIndex(\\n    address _owner,\\n    uint256 _index\\n  )\\n    public\\n    view\\n    returns (uint256)\\n  {\\n    require(_index \\u003c balanceOf(_owner), \\\"Invalid index\\\");\\n    return ownedTokens[_owner][_index];\\n  }\\n\\n  /**\\n   * @dev Gets the total amount of tokens stored by the contract\\n   * @return uint256 representing the total amount of tokens\\n   */\\n  function totalSupply() public view returns (uint256) {\\n    return allTokens.length;\\n  }\\n\\n  /**\\n   * @dev Gets the token ID at a given index of all the tokens in this contract\\n   * Reverts if the index is greater or equal to the total number of tokens\\n   * @param _index uint256 representing the index to be accessed of the tokens list\\n   * @return uint256 token ID at the given index of the tokens list\\n   */\\n  function tokenByIndex(uint256 _index) public view returns (uint256) {\\n    require(_index \\u003c totalSupply(), \\\"Invalid index\\\");\\n    return allTokens[_index];\\n  }\\n\\n  // @dev This function is not needed as token URI will be created automatically based in base URL\\n  // /**\\n  //  * @dev Internal function to set the token URI for a given token\\n  //  * Reverts if the token ID does not exist\\n  //  * @param _tokenId uint256 ID of the token to set its URI\\n  //  * @param _uri string URI to assign\\n  //  */\\n  // function _setTokenURI(uint256 _tokenId, string memory _uri) internal {\\n  //   require(exists(_tokenId));\\n  //   tokenURI[_tokenId] = _uri;\\n  // }\\n\\n  /**\\n   * @dev Internal function to add a token ID to the list of a given address\\n   * @param _to address representing the new owner of the given token ID\\n   * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\\n   */\\n  function addTokenTo(address _to, uint256 _tokenId) internal {\\n    super.addTokenTo(_to, _tokenId);\\n    uint256 length = ownedTokens[_to].length;\\n    ownedTokens[_to].push(_tokenId);\\n    ownedTokensIndex[_tokenId] = length;\\n  }\\n\\n  /**\\n   * @dev Internal function to remove a token ID from the list of a given address\\n   * @param _from address representing the previous owner of the given token ID\\n   * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\\n   */\\n  function removeTokenFrom(address _from, uint256 _tokenId) internal {\\n    super.removeTokenFrom(_from, _tokenId);\\n\\n    uint256 tokenIndex = ownedTokensIndex[_tokenId];\\n    uint256 lastTokenIndex = ownedTokens[_from].length.sub(1);\\n    uint256 lastToken = ownedTokens[_from][lastTokenIndex];\\n\\n    ownedTokens[_from][tokenIndex] = lastToken;\\n    ownedTokens[_from][lastTokenIndex] = 0;\\n    // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to\\n    // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping\\n    // the lastToken to the first position, and then dropping the element placed in the last position of the list\\n\\n    ownedTokens[_from].length--;\\n    ownedTokensIndex[_tokenId] = 0;\\n    ownedTokensIndex[lastToken] = tokenIndex;\\n  }\\n\\n  /**\\n   * @dev Internal function to mint a new token\\n   * Reverts if the given token ID already exists\\n   * @param _to address the beneficiary that will own the minted token\\n   * @param _tokenId uint256 ID of the token to be minted by the msg.sender\\n   */\\n  function _mint(address _to, uint256 _tokenId) internal {\\n    super._mint(_to, _tokenId);\\n\\n    allTokensIndex[_tokenId] = allTokens.length;\\n    allTokens.push(_tokenId);\\n  }\\n\\n  /**\\n   * @dev Internal function to burn a specific token\\n   * Reverts if the token does not exist\\n   * @param _owner owner of the token to burn\\n   * @param _tokenId uint256 ID of the token being burned by the msg.sender\\n   */\\n  function _burn(address _owner, uint256 _tokenId) internal {\\n    super._burn(_owner, _tokenId);\\n\\n    // Clear metadata (if any)\\n    // if (bytes(tokenURI[_tokenId]).length != 0) {\\n    //   delete tokenURIs[_tokenId];\\n    // }\\n\\n    // Reorg all tokens array\\n    uint256 tokenIndex = allTokensIndex[_tokenId];\\n    uint256 lastTokenIndex = allTokens.length.sub(1);\\n    uint256 lastToken = allTokens[lastTokenIndex];\\n\\n    allTokens[tokenIndex] = lastToken;\\n    allTokens[lastTokenIndex] = 0;\\n\\n    allTokens.length--;\\n    allTokensIndex[_tokenId] = 0;\\n    allTokensIndex[lastToken] = tokenIndex;\\n  }\\n}\"},\"Freezable.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\nimport \\\"./Ownership.sol\\\";\\n\\ncontract Freezable is Ownership {\\n    \\n    mapping (address =\\u003e bool) frozen;\\n    bool public emergencyFreeze = false;\\n\\n    event Freezed(address targetAddress, bool frozen);\\n    event EmerygencyFreezed(bool emergencyFreezeStatus);\\n\\n    modifier unfreezed(address _account) { \\n        require(!frozen[_account]);\\n        _;  \\n    }\\n    \\n    modifier noEmergencyFreeze() { \\n        require(!emergencyFreeze);\\n        _; \\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Freeze account - onlyOwner\\n    // ------------------------------------------------------------------------\\n    function freezeAccount (address _target, bool _freeze) public onlyOwner returns(bool) {\\n        frozen[_target] = _freeze;\\n        emit Freezed(_target, _freeze);\\n        return true;\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Emerygency freeze - onlyOwner\\n    // ------------------------------------------------------------------------\\n    function emergencyFreezeAllAccounts (bool _freeze) public onlyOwner returns(bool) {\\n        emergencyFreeze = _freeze;\\n        emit EmerygencyFreezed(_freeze);\\n        return true;\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Get Freeze Status : Constant\\n    // ------------------------------------------------------------------------\\n    function isFreezed(address _targetAddress) public view returns (bool) {\\n        return frozen[_targetAddress]; \\n    }\\n\\n}\"},\"Ownership.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\ncontract Ownership {\\n\\n  address public owner;\\n  address[] public deputyOwners;\\n\\n  mapping(address =\\u003e bool) public isDeputyOwner;\\n\\n  event OwnershipUpdated(address oldOwner, address newOwner);\\n  event DeputyOwnerUpdated(address _do, bool _isAdded);\\n\\n  constructor() public {\\n    owner = msg.sender;\\n    deputyOwners = [msg.sender];\\n  }\\n\\n  modifier onlyOwner() {\\n    require(msg.sender == owner, \\\"Not owner\\\");\\n    _;\\n  }\\n\\n  modifier onlyDeputyOrOwner() {\\n    require(msg.sender == owner || isDeputyOwner[msg.sender], \\\"Only owner or deputy owner is allowed\\\");\\n    _;\\n  }\\n\\n\\n  /**\\n   * @dev Transfer the ownership to some other address.\\n   * new owner can not be a zero address.\\n   * Only owner can call this function\\n   * @param _newOwner Address to which ownership is being transferred\\n   */\\n  function updateOwner(address _newOwner)\\n    public\\n    onlyOwner\\n  {\\n    require(_newOwner != address(0x0), \\\"Invalid address\\\");\\n    owner = _newOwner;\\n    emit OwnershipUpdated(msg.sender, owner);\\n  }\\n\\n  /**\\n    * @dev Add new deputy owner.\\n    * Only Owner can call this function\\n    * New Deputy should not be zero address\\n    * New Deputy should not be be already exisitng\\n    * emit DeputyOwnerUdpatd event\\n    * @param _newDO Address of new deputy owner\\n   */\\n  function addDeputyOwner(address _newDO)\\n    public\\n    onlyOwner\\n  {\\n    require(!isDeputyOwner[_newDO], \\\"Deputy Owner already exists\\\");\\n    require(_newDO != address(0), \\\"Zero address not allowed\\\");\\n    deputyOwners.push(_newDO);\\n    isDeputyOwner[_newDO] = true;\\n    emit DeputyOwnerUpdated(_newDO, true);\\n  }\\n\\n  /**\\n    * @dev Remove an existing deputy owner.\\n    * Only Owner can call this function\\n    * Given address should be a deputy owner\\n    * emit DeputyOwnerUdpatd event\\n    * @param _existingDO Address of existing deputy owner\\n   */\\n  function removeDeputyOwner(address _existingDO)\\n    public\\n    onlyOwner\\n  {\\n    require(isDeputyOwner[_existingDO], \\\"Deputy Owner does not exits\\\");\\n    uint existingId;\\n    for(uint i=0; i\\u003cdeputyOwners.length; i++) {\\n      if(deputyOwners[i] == _existingDO) existingId=i;\\n    }\\n\\n    // swap this with last element\\n    deputyOwners[existingId] = deputyOwners[deputyOwners.length-1];\\n    delete deputyOwners[deputyOwners.length-1];\\n    deputyOwners.length--;\\n    isDeputyOwner[_existingDO] = false;\\n    emit DeputyOwnerUpdated(_existingDO, false);\\n  }\\n\\n  /**\\n   * @dev Renounce the ownership.\\n   * This will leave the contract without any owner.\\n   * Only owner can call this function\\n   * @param _validationCode A code to prevent aaccidental calling of this function\\n   */\\n  function renounceOwnership(uint _validationCode)\\n    public\\n    onlyOwner\\n  {\\n    require(_validationCode == 123456789, \\\"Invalid code\\\");\\n    owner = address(0);\\n    emit OwnershipUpdated(msg.sender, owner);\\n  }\\n}\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.17;\\n\\nlibrary SafeMath {\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n    uint256 c = a * b;\\n    assert(c / a == b);\\n    return c;\\n  }\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // assert(b \\u003e 0); // Solidity automatically throws when dividing by 0\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n    return c;\\n  }\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    assert(b \\u003c= a);\\n    return a - b;\\n  }\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    assert(c \\u003e= a \\u0026\\u0026 c\\u003e=b);\\n    return c;\\n  }\\n}\"},\"Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.5.17;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI\\u0027s implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        uint256 index = digits - 1;\\n        temp = value;\\n        while (temp != 0) {\\n            buffer[index--] = byte(uint8(48 + temp % 10));\\n            temp /= 10;\\n        }\\n        return string(buffer);\\n    }\\n}\"},\"SupportsInterfaceWithLookup.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\nimport \\\"./ERC165.sol\\\";\\n\\n/**\\n * @title SupportsInterfaceWithLookup\\n * @author Prashant Prabhakar Singh [prashantprabhakar123@gmail.com]\\n * @dev Implements ERC165 using a lookup table.\\n */\\ncontract SupportsInterfaceWithLookup is ERC165 {\\n  bytes4 public constant InterfaceId_ERC165 = 0x01ffc9a7;\\n  /**\\n   * 0x01ffc9a7 ===\\n   *   bytes4(keccak256(\\u0027supportsInterface(bytes4)\\u0027))\\n   */\\n\\n  /**\\n   * @dev a mapping of interface id to whether or not it\\u0027s supported\\n   */\\n  mapping(bytes4 =\\u003e bool) internal supportedInterfaces;\\n\\n  /**\\n   * @dev A contract implementing SupportsInterfaceWithLookup\\n   * implement ERC165 itself\\n   */\\n  constructor()\\n    public\\n  {\\n    _registerInterface(InterfaceId_ERC165);\\n  }\\n\\n  /**\\n   * @dev implement supportsInterface(bytes4) using a lookup table\\n   */\\n  function supportsInterface(bytes4 _interfaceId)\\n    external\\n    view\\n    returns (bool)\\n  {\\n    return supportedInterfaces[_interfaceId];\\n  }\\n\\n  /**\\n   * @dev private method for registering an interface\\n   */\\n  function _registerInterface(bytes4 _interfaceId)\\n    internal\\n  {\\n    require(_interfaceId != 0xffffffff);\\n    supportedInterfaces[_interfaceId] = true;\\n  }\\n}\"},\"UserMintableNFT.sol\":{\"content\":\"/**\\n * This is enhancement over custom NFT allowing users to mint tokens approved by admin\\n * This contract will be used as enhanced version of NFT (v2)\\n*/\\n\\npragma solidity 0.5.17;\\n\\nimport \\\"./CustomERC721.sol\\\";\\n\\ncontract UserMintableNFT is CustomERC721 {\\n\\n  mapping(address =\\u003e mapping(uint =\\u003e bool)) isNonceUsed;\\n\\n  constructor(string memory name, string memory symbol, string memory baseURI) public CustomERC721(name, symbol, baseURI)\\n  {\\n\\n  }\\n\\n  /**\\n   * @dev Allows anyone to mint token signed by admin\\n   * Reverts if admin has not signed for `tokenId` or `to`\\n   * @param r signature\\n   * @param s signature\\n   * @param v recovery id of signature\\n   * @param tokenId tokenId to be minted\\n   * @param to address to which tokens needs to be minted\\n   * @param _signerNonce non-sequential nonce of signer to avoid replay protection\\n   * @return bool true when operation is successful\\n\\n   */\\n  function userMint(\\n    bytes32 r, bytes32 s, uint8 v,\\n    uint256 tokenId,\\n    address to,\\n    uint256 _signerNonce\\n  )\\n    public\\n    noEmergencyFreeze\\n    returns (bool)\\n  {\\n    \\n    bytes32 message = keccak256(abi.encodePacked(\\n      bytes4(0x8cd49589), // Keccak-256 hash of \\\"userMint\\\"\\n      address(this),\\n      _signerNonce,\\n      to,\\n      tokenId\\n    ));\\n    address signer = getSigner(message, r, s, v);\\n    require(signer == owner || isDeputyOwner[signer], \\\"Admin should sign message\\\");\\n    require(isNonceUsed[signer][_signerNonce], \\\"nonce already used\\\");\\n    super._mint(to, tokenId);\\n    isNonceUsed[signer][_signerNonce] = true;\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Allows anyone to mint tokens signed by admin\\n   * Reverts if admin has not signed for `tokenIds` or `to`\\n   * @param r signature\\n   * @param s signature\\n   * @param v recovery id of signature\\n   * @param tokenIds tokenIds to be minted\\n   * @param to address to which tokens needs to be minted\\n   * @param _signerNonce non-sequential nonce of signer to avoid replay protection\\n   * @return bool true when operation is successful\\n   */\\n  function userBulkMint(\\n    bytes32 r, bytes32 s, uint8 v,\\n    uint256[] memory tokenIds,\\n    address to,\\n    uint256 _signerNonce\\n  )\\n    public\\n    noEmergencyFreeze\\n    returns (bool)\\n  {\\n    bytes32 message = keccak256(abi.encodePacked(\\n      bytes4(0x5827c1ff), // Keccak-256 hash of \\\"userBulkMint\\\"\\n      address(this),\\n      _signerNonce,\\n      to,\\n      tokenIds\\n    ));\\n    address signer = getSigner(message, r, s, v);\\n    require(signer == owner || isDeputyOwner[signer], \\\"Admin should sign message\\\");\\n    require(isNonceUsed[signer][_signerNonce], \\\"nonce already used\\\");\\n    for(uint256 i=0; i\\u003ctokenIds.length; i++) {\\n      super._mint(to, tokenIds[i]);\\n    }\\n    isNonceUsed[signer][_signerNonce] = true;\\n    return true;\\n  }\\n  \\n}\\n\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_baseTokenURI\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_do\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_isAdded\",\"type\":\"bool\"}],\"name\":\"DeputyOwnerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"emergencyFreezeStatus\",\"type\":\"bool\"}],\"name\":\"EmerygencyFreezed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"targetAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"Freezed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"InterfaceId_ERC165\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newDO\",\"type\":\"address\"}],\"name\":\"addDeputyOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"}],\"name\":\"bulkMint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"deputyOwners\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"emergencyFreeze\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_freeze\",\"type\":\"bool\"}],\"name\":\"emergencyFreezeAllAccounts\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_freeze\",\"type\":\"bool\"}],\"name\":\"freezeAccount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isDeputyOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_targetAddress\",\"type\":\"address\"}],\"name\":\"isFreezed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_existingDO\",\"type\":\"address\"}],\"name\":\"removeDeputyOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_validationCode\",\"type\":\"uint256\"}],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_newURI\",\"type\":\"string\"}],\"name\":\"updateBaseTokenURI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"updateOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"BaseERC721","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000019446f63746f722057686f202d20576f726c64732041706172740000000000000000000000000000000000000000000000000000000000000000000000000000044457574100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003968747470733a2f2f646f63746f7277686f2d776f726c647361706172742e636f6d2f647277686f2f61737365742f64657461696c732f69642f00000000000000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://2629ada9d4e32422862f1866b3fbdf659a683171356fa694c87c1a1a775f4bd8"}]}