{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: GPL-2.0-or-later\r\n/*\r\n â–„â–„â–„â–„â–„â–„   â–„â–ˆâ–ˆâ–ˆâ–„      â–„   â–ˆ  â–ˆâ–€ â–ˆâ–ˆâ–ˆâ–ˆâ–„ \r\nâ–€   â–„â–„â–€   â–ˆâ–€   â–€      â–ˆ  â–ˆâ–„â–ˆ   â–ˆ   â–ˆ \r\n â–„â–€â–€   â–„â–€ â–ˆâ–ˆâ–„â–„    â–ˆâ–ˆ   â–ˆ â–ˆâ–€â–„   â–ˆ   â–ˆ \r\n â–€â–€â–€â–€â–€â–€   â–ˆâ–„   â–„â–€ â–ˆ â–ˆ  â–ˆ â–ˆ  â–ˆ  â–€â–ˆâ–ˆâ–ˆâ–ˆ \r\n          â–€â–ˆâ–ˆâ–ˆâ–€   â–ˆ  â–ˆ â–ˆ   â–ˆ         \r\n                  â–ˆ   â–ˆâ–ˆ  â–€       */\r\n/// ðŸ¦ŠðŸŒ¾ Special thanks to Keno / Boring / Gonpachi / Karbon for review and continued inspiration.\r\npragma solidity 0.8.6;\r\n\r\ninterface IERC20 {} interface IBentoHelper {\r\n    function toAmount(\r\n        IERC20 token,\r\n        uint256 share,\r\n        bool roundUp\r\n    ) external view returns (uint256 amount);\r\n\r\n    function toShare(\r\n        IERC20 token,\r\n        uint256 amount,\r\n        bool roundUp\r\n    ) external view returns (uint256 share);\r\n}\r\n\r\ninterface ICompoundHelper {\r\n    function getCash() external view returns (uint256);\r\n    function totalBorrows() external view returns (uint256);\r\n    function totalReserves() external view returns (uint256);\r\n    function totalSupply() external view returns (uint256);\r\n}\r\n\r\ninterface IKashiHelper {\r\n    function asset() external view returns (IERC20);\r\n    function totalAsset() external view returns (Rebase memory);\r\n    function totalBorrow() external view returns (Rebase memory);\r\n    struct Rebase {\r\n        uint128 elastic;\r\n        uint128 base;\r\n    }\r\n}\r\n\r\n/// @notice Helper for Inari SushiZap calculations.\r\ncontract Zenko {\r\n    IBentoHelper constant bento = IBentoHelper(0xF5BCE5077908a1b7370B9ae04AdC565EBd643966); // BENTO vault contract (multinet)\r\n    \r\n    // **** BENTO \r\n    function toBento(IERC20 token, uint256 amount) external view returns (uint256 share) {\r\n        share = bento.toShare(token, amount, false);\r\n    }\r\n    \r\n    function fromBento(IERC20 token, uint256 share) external view returns (uint256 amount) {\r\n        amount = bento.toAmount(token, share, false);\r\n    }\r\n    \r\n    // **** COMPOUND/CREAM\r\n    function toCtoken(ICompoundHelper cToken, uint256 underlyingAmount) public view returns (uint256 cTokenAmount) {\r\n        cTokenAmount = divScalarByExpTruncate(underlyingAmount, Exp({mantissa: exchangeRateStoredInternal(cToken)}));\r\n    }\r\n    \r\n    function fromCtoken(ICompoundHelper cToken, uint256 cTokenAmount) public view returns (uint256 underlyingAmount) {\r\n        underlyingAmount = mulScalarTruncate(Exp({mantissa: exchangeRateStoredInternal(cToken)}), cTokenAmount);\r\n    }\r\n\r\n    // **** KASHI - ASSET\r\n    function toKashi(IKashiHelper kmToken, uint256 underlyingAmount) external view returns (uint256 fraction) {\r\n        IERC20 token = kmToken.asset();\r\n        uint256 share = bento.toShare(token, underlyingAmount, false);\r\n        uint256 allShare = kmToken.totalAsset().elastic + bento.toShare(token, kmToken.totalBorrow().elastic, true);\r\n        fraction = allShare == 0 ? share : share * kmToken.totalAsset().base / allShare;\r\n    }\r\n    \r\n    function fromKashi(IKashiHelper kmToken, uint256 kmAmount) external view returns (uint256 share) {\r\n        uint256 allShare = kmToken.totalAsset().elastic + bento.toShare(kmToken.asset(), kmToken.totalBorrow().elastic, true);\r\n        share = kmAmount * allShare / kmToken.totalAsset().base;\r\n    }\r\n    \r\n    // **************\r\n    // CTOKEN HELPERS\r\n    // **************\r\n    struct Exp {\r\n        uint256 mantissa;\r\n    }\r\n    function addUInt(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n    function subUInt(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n    function addThenSubUInt(uint256 a, uint256 b, uint256 c) internal pure returns (uint256) {\r\n        uint256 sum = addUInt(a, b);\r\n        return subUInt(sum, c);\r\n    }\r\n    function mulUInt(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n    function divUInt(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n    function getExp(uint256 num, uint256 denom) pure internal returns (Exp memory) {\r\n        uint256 scaledNumerator = mulUInt(num, 1e18);\r\n        uint256 rational = divUInt(scaledNumerator, denom);\r\n        return Exp({mantissa: rational});\r\n    }\r\n    function truncate(Exp memory exp) pure internal returns (uint256) {\r\n        return exp.mantissa / 1e18;\r\n    }\r\n    function divScalarByExp(uint256 scalar, Exp memory divisor) pure internal returns (Exp memory) {\r\n        uint256 numerator = mulUInt(1e18, scalar);\r\n        return getExp(numerator, divisor.mantissa);\r\n    }\r\n    function divScalarByExpTruncate(uint256 scalar, Exp memory divisor) pure internal returns (uint256) {\r\n        Exp memory fraction = divScalarByExp(scalar, divisor);\r\n        return truncate(fraction);\r\n    }\r\n    function mulScalar(Exp memory a, uint256 scalar) pure internal returns (Exp memory) {\r\n        uint256 scaledMantissa = mulUInt(a.mantissa, scalar);\r\n        return Exp({mantissa: scaledMantissa});\r\n    }\r\n    function mulScalarTruncate(Exp memory a, uint256 scalar) pure internal returns (uint256) {\r\n        Exp memory product = mulScalar(a, scalar);\r\n        return truncate(product);\r\n    }\r\n    function exchangeRateStoredInternal(ICompoundHelper cToken) public view returns (uint256) {\r\n        uint256 _totalSupply = cToken.totalSupply();\r\n        /*\r\n         *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\r\n         */\r\n        uint256 totalCash = cToken.getCash();\r\n        uint256 cashPlusBorrowsMinusReserves;\r\n        Exp memory exchangeRate;\r\n        cashPlusBorrowsMinusReserves = addThenSubUInt(totalCash, cToken.totalBorrows(), cToken.totalReserves());\r\n        exchangeRate = getExp(cashPlusBorrowsMinusReserves, _totalSupply);\r\n        return exchangeRate.mantissa;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract ICompoundHelper\",\"name\":\"cToken\",\"type\":\"address\"}],\"name\":\"exchangeRateStoredInternal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"share\",\"type\":\"uint256\"}],\"name\":\"fromBento\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ICompoundHelper\",\"name\":\"cToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cTokenAmount\",\"type\":\"uint256\"}],\"name\":\"fromCtoken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"underlyingAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IKashiHelper\",\"name\":\"kmToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"kmAmount\",\"type\":\"uint256\"}],\"name\":\"fromKashi\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"share\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"toBento\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"share\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ICompoundHelper\",\"name\":\"cToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"underlyingAmount\",\"type\":\"uint256\"}],\"name\":\"toCtoken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cTokenAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IKashiHelper\",\"name\":\"kmToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"underlyingAmount\",\"type\":\"uint256\"}],\"name\":\"toKashi\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fraction\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Zenko","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv2","Proxy":"0","Implementation":"","SwarmSource":"ipfs://278fbf0707d489c3da809bd18a3502da20398555835d97bc2a20c92fc721f1dc"}]}