{"status":"1","message":"OK","result":[{"SourceCode":"// Sources flattened with hardhat v2.3.0 https://hardhat.org\r\n\r\n// File contracts/interfaces/INestPriceFacade.sol\r\n\r\n// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.6;\r\n\r\n/// @dev This interface defines the methods for price call entry\r\ninterface INestPriceFacade {\r\n    \r\n    // /// @dev Set the address flag. Only the address flag equals to config.normalFlag can the price be called\r\n    // /// @param addr Destination address\r\n    // /// @param flag Address flag\r\n    // function setAddressFlag(address addr, uint flag) external;\r\n\r\n    // /// @dev Get the flag. Only the address flag equals to config.normalFlag can the price be called\r\n    // /// @param addr Destination address\r\n    // /// @return Address flag\r\n    // function getAddressFlag(address addr) external view returns(uint);\r\n\r\n    // /// @dev Set INestQuery implementation contract address for token\r\n    // /// @param tokenAddress Destination token address\r\n    // /// @param nestQueryAddress INestQuery implementation contract address, 0 means delete\r\n    // function setNestQuery(address tokenAddress, address nestQueryAddress) external;\r\n\r\n    // /// @dev Get INestQuery implementation contract address for token\r\n    // /// @param tokenAddress Destination token address\r\n    // /// @return INestQuery implementation contract address, 0 means use default\r\n    // function getNestQuery(address tokenAddress) external view returns (address);\r\n\r\n    // /// @dev Get the latest trigger price\r\n    // /// @param tokenAddress Destination token address\r\n    // /// @param payback As the charging fee may change, it is suggested that the caller pay more fees, and the excess fees will be returned through this address\r\n    // /// @return blockNumber The block number of price\r\n    // /// @return price The token price. (1eth equivalent to (price) token)\r\n    // function triggeredPrice(address tokenAddress, address payback) external payable returns (uint blockNumber, uint price);\r\n\r\n    // /// @dev Get the full information of latest trigger price\r\n    // /// @param tokenAddress Destination token address\r\n    // /// @param payback As the charging fee may change, it is suggested that the caller pay more fees, and the excess fees will be returned through this address\r\n    // /// @return blockNumber The block number of price\r\n    // /// @return price The token price. (1eth equivalent to (price) token)\r\n    // /// @return avgPrice Average price\r\n    // /// @return sigmaSQ The square of the volatility (18 decimal places). The current implementation assumes that \r\n    // ///         the volatility cannot exceed 1. Correspondingly, when the return value is equal to 999999999999996447,\r\n    // ///         it means that the volatility has exceeded the range that can be expressed\r\n    // function triggeredPriceInfo(address tokenAddress, address payback) external payable returns (uint blockNumber, uint price, uint avgPrice, uint sigmaSQ);\r\n\r\n    // /// @dev Find the price at block number\r\n    // /// @param tokenAddress Destination token address\r\n    // /// @param height Destination block number\r\n    // /// @param payback As the charging fee may change, it is suggested that the caller pay more fees, and the excess fees will be returned through this address\r\n    // /// @return blockNumber The block number of price\r\n    // /// @return price The token price. (1eth equivalent to (price) token)\r\n    // function findPrice(address tokenAddress, uint height, address payback) external payable returns (uint blockNumber, uint price);\r\n\r\n    /// @dev Get the latest effective price\r\n    /// @param tokenAddress Destination token address\r\n    /// @param payback As the charging fee may change, it is suggested that the caller pay more fees, and the excess fees will be returned through this address\r\n    /// @return blockNumber The block number of price\r\n    /// @return price The token price. (1eth equivalent to (price) token)\r\n    function latestPrice(address tokenAddress, address payback) external payable returns (uint blockNumber, uint price);\r\n\r\n    // /// @dev Get the last (num) effective price\r\n    // /// @param tokenAddress Destination token address\r\n    // /// @param count The number of prices that want to return\r\n    // /// @param payback As the charging fee may change, it is suggested that the caller pay more fees, and the excess fees will be returned through this address\r\n    // /// @return An array which length is num * 2, each two element expresses one price like blockNumber｜price\r\n    // function lastPriceList(address tokenAddress, uint count, address payback) external payable returns (uint[] memory);\r\n\r\n    /// @dev Returns the results of latestPrice() and triggeredPriceInfo()\r\n    /// @param tokenAddress Destination token address\r\n    /// @param payback As the charging fee may change, it is suggested that the caller pay more fees, and the excess fees will be returned through this address\r\n    /// @return latestPriceBlockNumber The block number of latest price\r\n    /// @return latestPriceValue The token latest price. (1eth equivalent to (price) token)\r\n    /// @return triggeredPriceBlockNumber The block number of triggered price\r\n    /// @return triggeredPriceValue The token triggered price. (1eth equivalent to (price) token)\r\n    /// @return triggeredAvgPrice Average price\r\n    /// @return triggeredSigmaSQ The square of the volatility (18 decimal places). The current implementation assumes that \r\n    ///         the volatility cannot exceed 1. Correspondingly, when the return value is equal to 999999999999996447,\r\n    ///         it means that the volatility has exceeded the range that can be expressed\r\n    function latestPriceAndTriggeredPriceInfo(address tokenAddress, address payback) \r\n    external \r\n    payable \r\n    returns (\r\n        uint latestPriceBlockNumber, \r\n        uint latestPriceValue,\r\n        uint triggeredPriceBlockNumber,\r\n        uint triggeredPriceValue,\r\n        uint triggeredAvgPrice,\r\n        uint triggeredSigmaSQ\r\n    );\r\n\r\n    /// @dev Returns lastPriceList and triggered price info\r\n    /// @param tokenAddress Destination token address\r\n    /// @param count The number of prices that want to return\r\n    /// @param payback As the charging fee may change, it is suggested that the caller pay more fees, and the excess fees will be returned through this address\r\n    /// @return prices An array which length is num * 2, each two element expresses one price like blockNumber｜price\r\n    /// @return triggeredPriceBlockNumber The block number of triggered price\r\n    /// @return triggeredPriceValue The token triggered price. (1eth equivalent to (price) token)\r\n    /// @return triggeredAvgPrice Average price\r\n    /// @return triggeredSigmaSQ The square of the volatility (18 decimal places). The current implementation assumes that \r\n    ///         the volatility cannot exceed 1. Correspondingly, when the return value is equal to 999999999999996447,\r\n    ///         it means that the volatility has exceeded the range that can be expressed\r\n    function lastPriceListAndTriggeredPriceInfo(\r\n        address tokenAddress, \r\n        uint count, \r\n        address payback\r\n    ) external payable \r\n    returns (\r\n        uint[] memory prices,\r\n        uint triggeredPriceBlockNumber,\r\n        uint triggeredPriceValue,\r\n        uint triggeredAvgPrice,\r\n        uint triggeredSigmaSQ\r\n    );\r\n\r\n    // /// @dev Get the latest trigger price. (token and ntoken)\r\n    // /// @param tokenAddress Destination token address\r\n    // /// @param payback As the charging fee may change, it is suggested that the caller pay more fees, and the excess fees will be returned through this address\r\n    // /// @return blockNumber The block number of price\r\n    // /// @return price The token price. (1eth equivalent to (price) token)\r\n    // /// @return ntokenBlockNumber The block number of ntoken price\r\n    // /// @return ntokenPrice The ntoken price. (1eth equivalent to (price) ntoken)\r\n    // function triggeredPrice2(address tokenAddress, address payback) external payable returns (uint blockNumber, uint price, uint ntokenBlockNumber, uint ntokenPrice);\r\n\r\n    // /// @dev Get the full information of latest trigger price. (token and ntoken)\r\n    // /// @param tokenAddress Destination token address\r\n    // /// @param payback As the charging fee may change, it is suggested that the caller pay more fees, and the excess fees will be returned through this address\r\n    // /// @return blockNumber The block number of price\r\n    // /// @return price The token price. (1eth equivalent to (price) token)\r\n    // /// @return avgPrice Average price\r\n    // /// @return sigmaSQ The square of the volatility (18 decimal places). The current implementation assumes that \r\n    // ///         the volatility cannot exceed 1. Correspondingly, when the return value is equal to 999999999999996447, \r\n    // ///         it means that the volatility has exceeded the range that can be expressed\r\n    // /// @return ntokenBlockNumber The block number of ntoken price\r\n    // /// @return ntokenPrice The ntoken price. (1eth equivalent to (price) ntoken)\r\n    // /// @return ntokenAvgPrice Average price of ntoken\r\n    // /// @return ntokenSigmaSQ The square of the volatility (18 decimal places). The current implementation assumes that\r\n    // ///         the volatility cannot exceed 1. Correspondingly, when the return value is equal to 999999999999996447,\r\n    // ///         it means that the volatility has exceeded the range that can be expressed\r\n    // function triggeredPriceInfo2(address tokenAddress, address payback) external payable returns (uint blockNumber, uint price, uint avgPrice, uint sigmaSQ, uint ntokenBlockNumber, uint ntokenPrice, uint ntokenAvgPrice, uint ntokenSigmaSQ);\r\n\r\n    // /// @dev Get the latest effective price. (token and ntoken)\r\n    // /// @param tokenAddress Destination token address\r\n    // /// @param payback As the charging fee may change, it is suggested that the caller pay more fees, and the excess fees will be returned through this address\r\n    // /// @return blockNumber The block number of price\r\n    // /// @return price The token price. (1eth equivalent to (price) token)\r\n    // /// @return ntokenBlockNumber The block number of ntoken price\r\n    // /// @return ntokenPrice The ntoken price. (1eth equivalent to (price) ntoken)\r\n    // function latestPrice2(address tokenAddress, address payback) external payable returns (uint blockNumber, uint price, uint ntokenBlockNumber, uint ntokenPrice);\r\n}\r\n\r\n\r\n// File contracts/interfaces/ICoFiXController.sol\r\n\r\n// GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.6;\r\n/// @dev This interface defines the methods for price call entry\r\ninterface ICoFiXController {\r\n\r\n    // Calc variance of price and K in CoFiX is very expensive\r\n    // We use expected value of K based on statistical calculations here to save gas\r\n    // In the near future, NEST could provide the variance of price directly. We will adopt it then.\r\n    // We can make use of `data` bytes in the future\r\n\r\n    /// @dev Query price\r\n    /// @param tokenAddress Target address of token\r\n    /// @param payback As the charging fee may change, it is suggested that the caller pay more fees, \r\n    /// and the excess fees will be returned through this address\r\n    /// @return ethAmount Oracle price - eth amount\r\n    /// @return tokenAmount Oracle price - token amount\r\n    /// @return blockNumber Block number of price\r\n    function queryPrice(\r\n        address tokenAddress,\r\n        address payback\r\n    ) external payable returns (\r\n        uint ethAmount, \r\n        uint tokenAmount, \r\n        uint blockNumber\r\n    );\r\n\r\n    /// @dev Calc variance of price and K in CoFiX is very expensive\r\n    /// We use expected value of K based on statistical calculations here to save gas\r\n    /// In the near future, NEST could provide the variance of price directly. We will adopt it then.\r\n    /// We can make use of `data` bytes in the future\r\n    /// @param tokenAddress Target address of token\r\n    /// @param payback As the charging fee may change, it is suggested that the caller pay more fees, \r\n    /// and the excess fees will be returned through this address\r\n    /// @return k The K value(18 decimal places).\r\n    /// @return ethAmount Oracle price - eth amount\r\n    /// @return tokenAmount Oracle price - token amount\r\n    /// @return blockNumber Block number of price\r\n    function queryOracle(\r\n        address tokenAddress,\r\n        address payback\r\n    ) external payable returns (\r\n        uint k, \r\n        uint ethAmount, \r\n        uint tokenAmount, \r\n        uint blockNumber\r\n    );\r\n    \r\n    /// @dev K value is calculated by revised volatility\r\n    /// @param sigmaSQ The square of the volatility (18 decimal places).\r\n    /// @param p0 Last price (number of tokens equivalent to 1 ETH)\r\n    /// @param bn0 Block number of the last price\r\n    /// @param p Latest price (number of tokens equivalent to 1 ETH)\r\n    /// @param bn The block number when (ETH, TOKEN) price takes into effective\r\n    function calcRevisedK(uint sigmaSQ, uint p0, uint bn0, uint p, uint bn) external view returns (uint k);\r\n\r\n    /// @dev Query latest price info\r\n    /// @param tokenAddress Target address of token\r\n    /// @param payback As the charging fee may change, it is suggested that the caller pay more fees, \r\n    /// and the excess fees will be returned through this address\r\n    /// @return blockNumber Block number of price\r\n    /// @return priceEthAmount Oracle price - eth amount\r\n    /// @return priceTokenAmount Oracle price - token amount\r\n    /// @return avgPriceEthAmount Avg price - eth amount\r\n    /// @return avgPriceTokenAmount Avg price - token amount\r\n    /// @return sigmaSQ The square of the volatility (18 decimal places)\r\n    function latestPriceInfo(address tokenAddress, address payback) \r\n    external \r\n    payable \r\n    returns (\r\n        uint blockNumber, \r\n        uint priceEthAmount,\r\n        uint priceTokenAmount,\r\n        uint avgPriceEthAmount,\r\n        uint avgPriceTokenAmount,\r\n        uint sigmaSQ\r\n    );\r\n}\r\n\r\n\r\n// File contracts/CoFiXController.sol\r\n\r\n// GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.6;\r\n/// @dev This interface defines the methods for price call entry\r\ncontract CoFiXController is ICoFiXController {\r\n\r\n    uint constant BLOCK_TIME = 14;\r\n\r\n    // Address of NestPriceFacade contract\r\n    address constant NEST_PRICE_FACADE = 0xB5D2890c061c321A5B6A4a4254bb1522425BAF0A;\r\n\r\n    /// @dev To support open-zeppelin/upgrades\r\n    function initialize(address nestPriceFacade) external {\r\n        //NEST_PRICE_FACADE = nestPriceFacade;\r\n    }\r\n\r\n    /// @dev Query latest price info\r\n    /// @param tokenAddress Target address of token\r\n    /// @param payback As the charging fee may change, it is suggested that the caller pay more fees, \r\n    /// and the excess fees will be returned through this address\r\n    /// @return blockNumber Block number of price\r\n    /// @return priceEthAmount Oracle price - eth amount\r\n    /// @return priceTokenAmount Oracle price - token amount\r\n    /// @return avgPriceEthAmount Avg price - eth amount\r\n    /// @return avgPriceTokenAmount Avg price - token amount\r\n    /// @return sigmaSQ The square of the volatility (18 decimal places)\r\n    function latestPriceInfo(address tokenAddress, address payback) \r\n    public \r\n    payable \r\n    override\r\n    returns (\r\n        uint blockNumber, \r\n        uint priceEthAmount,\r\n        uint priceTokenAmount,\r\n        uint avgPriceEthAmount,\r\n        uint avgPriceTokenAmount,\r\n        uint sigmaSQ\r\n    ) {\r\n        (\r\n            blockNumber, \r\n            priceTokenAmount,\r\n            ,//uint triggeredPriceBlockNumber,\r\n            ,//uint triggeredPriceValue,\r\n            avgPriceTokenAmount,\r\n            sigmaSQ\r\n        ) = INestPriceFacade(NEST_PRICE_FACADE).latestPriceAndTriggeredPriceInfo { \r\n            value: msg.value \r\n        } (tokenAddress, payback);\r\n        \r\n        _checkPrice(priceTokenAmount, avgPriceTokenAmount);\r\n        priceEthAmount = 1 ether;\r\n        avgPriceEthAmount = 1 ether;\r\n    }\r\n\r\n    // Calc variance of price and K in CoFiX is very expensive\r\n    // We use expected value of K based on statistical calculations here to save gas\r\n    // In the near future, NEST could provide the variance of price directly. We will adopt it then.\r\n    // We can make use of `data` bytes in the future\r\n\r\n    /// @dev Query price\r\n    /// @param tokenAddress Target address of token\r\n    /// @param payback As the charging fee may change, it is suggested that the caller pay more fees, \r\n    /// and the excess fees will be returned through this address\r\n    /// @return ethAmount Oracle price - eth amount\r\n    /// @return tokenAmount Oracle price - token amount\r\n    /// @return blockNumber Block number of price\r\n    function queryPrice(\r\n        address tokenAddress,\r\n        address payback\r\n    ) external payable override returns (\r\n        uint ethAmount, \r\n        uint tokenAmount, \r\n        uint blockNumber\r\n    ) {\r\n        (blockNumber, tokenAmount) = INestPriceFacade(NEST_PRICE_FACADE).latestPrice { \r\n            value: msg.value \r\n        } (tokenAddress, payback);\r\n        ethAmount = 1 ether;\r\n\r\n        // (\r\n        //     uint latestPriceBlockNumber, \r\n        //     uint latestPriceValue,\r\n        //     ,//uint triggeredPriceBlockNumber,\r\n        //     ,//uint triggeredPriceValue,\r\n        //     uint triggeredAvgPrice,\r\n        //     //uint triggeredSigmaSQ\r\n        // ) = INestPriceFacade(NEST_PRICE_FACADE).latestPriceAndTriggeredPriceInfo { \r\n        //     value: msg.value \r\n        // } (tokenAddress, payback);\r\n        \r\n        // _checkPrice(latestPriceValue, triggeredAvgPrice);\r\n\r\n        // ethAmount = 1 ether;\r\n        // tokenAmount = latestPriceValue;\r\n        // blockNumber = latestPriceBlockNumber;\r\n    }\r\n\r\n    /// @dev Calc variance of price and K in CoFiX is very expensive\r\n    /// We use expected value of K based on statistical calculations here to save gas\r\n    /// In the near future, NEST could provide the variance of price directly. We will adopt it then.\r\n    /// We can make use of `data` bytes in the future\r\n    /// @param tokenAddress Target address of token\r\n    /// @param payback As the charging fee may change, it is suggested that the caller pay more fees, \r\n    /// and the excess fees will be returned through this address\r\n    /// @return k The K value(18 decimal places).\r\n    /// @return ethAmount Oracle price - eth amount\r\n    /// @return tokenAmount Oracle price - token amount\r\n    /// @return blockNumber Block number of price\r\n    function queryOracle(\r\n        address tokenAddress,\r\n        address payback\r\n    ) external override payable returns (\r\n        uint k, \r\n        uint ethAmount, \r\n        uint tokenAmount, \r\n        uint blockNumber\r\n    ) {\r\n        (\r\n            uint[] memory prices,\r\n            ,//uint triggeredPriceBlockNumber,\r\n            ,//uint triggeredPriceValue,\r\n            uint triggeredAvgPrice,\r\n            uint triggeredSigmaSQ\r\n        ) = INestPriceFacade(NEST_PRICE_FACADE).lastPriceListAndTriggeredPriceInfo {\r\n            value: msg.value  \r\n        } (tokenAddress, 2, payback);\r\n\r\n        tokenAmount = prices[1];\r\n        _checkPrice(tokenAmount, triggeredAvgPrice);\r\n        blockNumber = prices[0];\r\n        ethAmount = 1 ether;\r\n\r\n        k = calcRevisedK(triggeredSigmaSQ, prices[3], prices[2], tokenAmount, blockNumber);\r\n    }\r\n\r\n    /// @dev K value is calculated by revised volatility\r\n    /// @param sigmaSQ The square of the volatility (18 decimal places).\r\n    /// @param p0 Last price (number of tokens equivalent to 1 ETH)\r\n    /// @param bn0 Block number of the last price\r\n    /// @param p Latest price (number of tokens equivalent to 1 ETH)\r\n    /// @param bn The block number when (ETH, TOKEN) price takes into effective\r\n    function calcRevisedK(uint sigmaSQ, uint p0, uint bn0, uint p, uint bn) public view override returns (uint k) {\r\n        k = _calcK(_calcRevisedSigmaSQ(sigmaSQ, p0, bn0, p, bn), bn);\r\n    }\r\n\r\n    // Calculate the corrected volatility\r\n    function _calcRevisedSigmaSQ(\r\n        uint sigmaSQ,\r\n        uint p0, \r\n        uint bn0, \r\n        uint p, \r\n        uint bn\r\n    ) private pure returns (uint revisedSigmaSQ) {\r\n        // sq2 = sq1 * 0.9 + rq2 * dt * 0.1\r\n        // sq1 = (sq2 - rq2 * dt * 0.1) / 0.9\r\n        // 1. \r\n        // rq2 <= 4 * dt * sq1\r\n        // sqt = sq2\r\n        // 2. rq2 > 4 * dt * sq1 && rq2 <= 9 * dt * sq1\r\n        // sqt = (sq1 + rq2 * dt) / 2\r\n        // 3. rq2 > 9 * dt * sq1\r\n        // sqt = sq1 * 0.2 + rq2 * dt * 0.8\r\n\r\n        uint rq2 = p * 1 ether / p0;\r\n        if (rq2 > 1 ether) {\r\n            rq2 -= 1 ether;\r\n        } else {\r\n            rq2 = 1 ether - rq2;\r\n        }\r\n        rq2 = rq2 * rq2 / 1 ether;\r\n\r\n        uint dt = (bn - bn0) * BLOCK_TIME;\r\n        uint sq1 = 0;\r\n        uint rq2dt = rq2 / dt;\r\n        if (sigmaSQ * 10 > rq2dt) {\r\n            sq1 = (sigmaSQ * 10 - rq2dt) / 9;\r\n        }\r\n\r\n        uint dds = dt * dt * dt * sq1;\r\n        if (rq2 <= (dds << 2)) {\r\n            revisedSigmaSQ = sigmaSQ;\r\n        } else if (rq2 <= 9 * dds) {\r\n            revisedSigmaSQ = (sq1 + rq2dt) >> 1;\r\n        } else {\r\n            revisedSigmaSQ = (sq1 + (rq2dt << 2)) / 5;\r\n        }\r\n    }\r\n\r\n    /// @dev Calc K value\r\n    /// @param sigmaSQ The square of the volatility (18 decimal places).\r\n    /// @param bn The block number when (ETH, TOKEN) price takes into effective\r\n    /// @return k The K value\r\n    function _calcK(uint sigmaSQ, uint bn) private view returns (uint k) {\r\n        k = 0.002 ether + _sqrt((block.number - bn) * BLOCK_TIME * sigmaSQ / 1e4) * 2e11;\r\n    }\r\n\r\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\r\n    function _sqrt(uint y) private pure returns (uint z) {\r\n        if (y > 3) {\r\n            z = y;\r\n            uint x = (y >> 1) + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) >> 1;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n    }\r\n\r\n    // Check price\r\n    function _checkPrice(uint price, uint avgPrice) private pure {\r\n        require(\r\n            price <= avgPrice * 11 / 10 &&\r\n            price >= avgPrice * 9 / 10, \r\n            \"CoFiXController: price deviation\"\r\n        );\r\n    }\r\n    \r\n    /// @return adm The admin slot.\r\n    function getAdmin() external view returns (address adm) {\r\n        assembly {\r\n            adm := sload(0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103)\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sigmaSQ\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"p0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bn0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"p\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bn\",\"type\":\"uint256\"}],\"name\":\"calcRevisedK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"k\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"adm\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nestPriceFacade\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"payback\",\"type\":\"address\"}],\"name\":\"latestPriceInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceEthAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"avgPriceEthAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"avgPriceTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sigmaSQ\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"payback\",\"type\":\"address\"}],\"name\":\"queryOracle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"k\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"payback\",\"type\":\"address\"}],\"name\":\"queryPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"CoFiXController","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"888888","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://09c0c53e48f210498cc8fed0d8a76127a60d7edf7c9ff0cd8f28737246a08c23"}]}