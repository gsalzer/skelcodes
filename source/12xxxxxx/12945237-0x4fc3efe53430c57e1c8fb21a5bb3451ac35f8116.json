{"status":"1","message":"OK","result":[{"SourceCode":"// File: @chainlink/contracts/src/v0.6/vendor/SafeMathChainlink.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMathChainlink {\r\n  /**\r\n    * @dev Returns the addition of two unsigned integers, reverting on\r\n    * overflow.\r\n    *\r\n    * Counterpart to Solidity's `+` operator.\r\n    *\r\n    * Requirements:\r\n    * - Addition cannot overflow.\r\n    */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the subtraction of two unsigned integers, reverting on\r\n    * overflow (when the result is negative).\r\n    *\r\n    * Counterpart to Solidity's `-` operator.\r\n    *\r\n    * Requirements:\r\n    * - Subtraction cannot overflow.\r\n    */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a, \"SafeMath: subtraction overflow\");\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the multiplication of two unsigned integers, reverting on\r\n    * overflow.\r\n    *\r\n    * Counterpart to Solidity's `*` operator.\r\n    *\r\n    * Requirements:\r\n    * - Multiplication cannot overflow.\r\n    */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the integer division of two unsigned integers. Reverts on\r\n    * division by zero. The result is rounded towards zero.\r\n    *\r\n    * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n    * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n    * uses an invalid opcode to revert (consuming all remaining gas).\r\n    *\r\n    * Requirements:\r\n    * - The divisor cannot be zero.\r\n    */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Solidity only automatically asserts when dividing by 0\r\n    require(b > 0, \"SafeMath: division by zero\");\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n    * Reverts when dividing by zero.\r\n    *\r\n    * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n    * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n    * invalid opcode to revert (consuming all remaining gas).\r\n    *\r\n    * Requirements:\r\n    * - The divisor cannot be zero.\r\n    */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0, \"SafeMath: modulo by zero\");\r\n    return a % b;\r\n  }\r\n}\r\n\r\n// File: @chainlink/contracts/src/v0.6/interfaces/LinkTokenInterface.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\ninterface LinkTokenInterface {\r\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\r\n  function approve(address spender, uint256 value) external returns (bool success);\r\n  function balanceOf(address owner) external view returns (uint256 balance);\r\n  function decimals() external view returns (uint8 decimalPlaces);\r\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\r\n  function increaseApproval(address spender, uint256 subtractedValue) external;\r\n  function name() external view returns (string memory tokenName);\r\n  function symbol() external view returns (string memory tokenSymbol);\r\n  function totalSupply() external view returns (uint256 totalTokensIssued);\r\n  function transfer(address to, uint256 value) external returns (bool success);\r\n  function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool success);\r\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\r\n}\r\n\r\n// File: @chainlink/contracts/src/v0.6/VRFRequestIDBase.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\ncontract VRFRequestIDBase {\r\n\r\n  /**\r\n   * @notice returns the seed which is actually input to the VRF coordinator\r\n   *\r\n   * @dev To prevent repetition of VRF output due to repetition of the\r\n   * @dev user-supplied seed, that seed is combined in a hash with the\r\n   * @dev user-specific nonce, and the address of the consuming contract. The\r\n   * @dev risk of repetition is mostly mitigated by inclusion of a blockhash in\r\n   * @dev the final seed, but the nonce does protect against repetition in\r\n   * @dev requests which are included in a single block.\r\n   *\r\n   * @param _userSeed VRF seed input provided by user\r\n   * @param _requester Address of the requesting contract\r\n   * @param _nonce User-specific nonce at the time of the request\r\n   */\r\n  function makeVRFInputSeed(bytes32 _keyHash, uint256 _userSeed,\r\n    address _requester, uint256 _nonce)\r\n    internal pure returns (uint256)\r\n  {\r\n    return  uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the id for this request\r\n   * @param _keyHash The serviceAgreement ID to be used for this request\r\n   * @param _vRFInputSeed The seed to be passed directly to the VRF\r\n   * @return The id for this request\r\n   *\r\n   * @dev Note that _vRFInputSeed is not the seed passed by the consuming\r\n   * @dev contract, but the one generated by makeVRFInputSeed\r\n   */\r\n  function makeRequestId(\r\n    bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {\r\n    return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));\r\n  }\r\n}\r\n\r\n// File: @chainlink/contracts/src/v0.6/VRFConsumerBase.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n/** ****************************************************************************\r\n * @notice Interface for contracts using VRF randomness\r\n * *****************************************************************************\r\n * @dev PURPOSE\r\n *\r\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\r\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\r\n * @dev making his output up to suit himself. Reggie provides Vera a public key\r\n * @dev to which he knows the secret key. Each time Vera provides a seed to\r\n * @dev Reggie, he gives back a value which is computed completely\r\n * @dev deterministically from the seed and the secret key.\r\n *\r\n * @dev Reggie provides a proof by which Vera can verify that the output was\r\n * @dev correctly computed once Reggie tells it to her, but without that proof,\r\n * @dev the output is indistinguishable to her from a uniform random sample\r\n * @dev from the output space.\r\n *\r\n * @dev The purpose of this contract is to make it easy for unrelated contracts\r\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\r\n * @dev simple access to a verifiable source of randomness.\r\n * *****************************************************************************\r\n * @dev USAGE\r\n *\r\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\r\n * @dev initialize VRFConsumerBase's attributes in their constructor as\r\n * @dev shown:\r\n *\r\n * @dev   contract VRFConsumer {\r\n * @dev     constuctor(<other arguments>, address _vrfCoordinator, address _link)\r\n * @dev       VRFConsumerBase(_vrfCoordinator, _link) public {\r\n * @dev         <initialization with other arguments goes here>\r\n * @dev       }\r\n * @dev   }\r\n *\r\n * @dev The oracle will have given you an ID for the VRF keypair they have\r\n * @dev committed to (let's call it keyHash), and have told you the minimum LINK\r\n * @dev price for VRF service. Make sure your contract has sufficient LINK, and\r\n * @dev call requestRandomness(keyHash, fee, seed), where seed is the input you\r\n * @dev want to generate randomness from.\r\n *\r\n * @dev Once the VRFCoordinator has received and validated the oracle's response\r\n * @dev to your request, it will call your contract's fulfillRandomness method.\r\n *\r\n * @dev The randomness argument to fulfillRandomness is the actual random value\r\n * @dev generated from your seed.\r\n *\r\n * @dev The requestId argument is generated from the keyHash and the seed by\r\n * @dev makeRequestId(keyHash, seed). If your contract could have concurrent\r\n * @dev requests open, you can use the requestId to track which seed is\r\n * @dev associated with which randomness. See VRFRequestIDBase.sol for more\r\n * @dev details. (See \"SECURITY CONSIDERATIONS\" for principles to keep in mind,\r\n * @dev if your contract could have multiple requests in flight simultaneously.)\r\n *\r\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\r\n * @dev differ. (Which is critical to making unpredictable randomness! See the\r\n * @dev next section.)\r\n *\r\n * *****************************************************************************\r\n * @dev SECURITY CONSIDERATIONS\r\n *\r\n * @dev A method with the ability to call your fulfillRandomness method directly\r\n * @dev could spoof a VRF response with any random value, so it's critical that\r\n * @dev it cannot be directly called by anything other than this base contract\r\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\r\n *\r\n * @dev For your users to trust that your contract's random behavior is free\r\n * @dev from malicious interference, it's best if you can write it so that all\r\n * @dev behaviors implied by a VRF response are executed *during* your\r\n * @dev fulfillRandomness method. If your contract must store the response (or\r\n * @dev anything derived from it) and use it later, you must ensure that any\r\n * @dev user-significant behavior which depends on that stored value cannot be\r\n * @dev manipulated by a subsequent VRF request.\r\n *\r\n * @dev Similarly, both miners and the VRF oracle itself have some influence\r\n * @dev over the order in which VRF responses appear on the blockchain, so if\r\n * @dev your contract could have multiple VRF requests in flight simultaneously,\r\n * @dev you must ensure that the order in which the VRF responses arrive cannot\r\n * @dev be used to manipulate your contract's user-significant behavior.\r\n *\r\n * @dev Since the ultimate input to the VRF is mixed with the block hash of the\r\n * @dev block in which the request is made, user-provided seeds have no impact\r\n * @dev on its economic security properties. They are only included for API\r\n * @dev compatability with previous versions of this contract.\r\n *\r\n * @dev Since the block hash of the block which contains the requestRandomness\r\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\r\n * @dev miner could, in principle, fork the blockchain to evict the block\r\n * @dev containing the request, forcing the request to be included in a\r\n * @dev different block with a different hash, and therefore a different input\r\n * @dev to the VRF. However, such an attack would incur a substantial economic\r\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\r\n * @dev until it calls responds to a request.\r\n */\r\nabstract contract VRFConsumerBase is VRFRequestIDBase {\r\n\r\n  using SafeMathChainlink for uint256;\r\n\r\n  /**\r\n   * @notice fulfillRandomness handles the VRF response. Your contract must\r\n   * @notice implement it. See \"SECURITY CONSIDERATIONS\" above for important\r\n   * @notice principles to keep in mind when implementing your fulfillRandomness\r\n   * @notice method.\r\n   *\r\n   * @dev VRFConsumerBase expects its subcontracts to have a method with this\r\n   * @dev signature, and will call it once it has verified the proof\r\n   * @dev associated with the randomness. (It is triggered via a call to\r\n   * @dev rawFulfillRandomness, below.)\r\n   *\r\n   * @param requestId The Id initially returned by requestRandomness\r\n   * @param randomness the VRF output\r\n   */\r\n  function fulfillRandomness(bytes32 requestId, uint256 randomness)\r\n    internal virtual;\r\n\r\n  /**\r\n   * @dev In order to keep backwards compatibility we have kept the user\r\n   * seed field around. We remove the use of it because given that the blockhash\r\n   * enters later, it overrides whatever randomness the used seed provides.\r\n   * Given that it adds no security, and can easily lead to misunderstandings,\r\n   * we have removed it from usage and can now provide a simpler API.\r\n   */\r\n  uint256 constant private USER_SEED_PLACEHOLDER = 0;\r\n\r\n  /**\r\n   * @notice requestRandomness initiates a request for VRF output given _seed\r\n   *\r\n   * @dev The fulfillRandomness method receives the output, once it's provided\r\n   * @dev by the Oracle, and verified by the vrfCoordinator.\r\n   *\r\n   * @dev The _keyHash must already be registered with the VRFCoordinator, and\r\n   * @dev the _fee must exceed the fee specified during registration of the\r\n   * @dev _keyHash.\r\n   *\r\n   * @dev The _seed parameter is vestigial, and is kept only for API\r\n   * @dev compatibility with older versions. It can't *hurt* to mix in some of\r\n   * @dev your own randomness, here, but it's not necessary because the VRF\r\n   * @dev oracle will mix the hash of the block containing your request into the\r\n   * @dev VRF seed it ultimately uses.\r\n   *\r\n   * @param _keyHash ID of public key against which randomness is generated\r\n   * @param _fee The amount of LINK to send with the request\r\n   *\r\n   * @return requestId unique ID for this request\r\n   *\r\n   * @dev The returned requestId can be used to distinguish responses to\r\n   * @dev concurrent requests. It is passed as the first argument to\r\n   * @dev fulfillRandomness.\r\n   */\r\n  function requestRandomness(bytes32 _keyHash, uint256 _fee)\r\n    internal returns (bytes32 requestId)\r\n  {\r\n    LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, USER_SEED_PLACEHOLDER));\r\n    // This is the seed passed to VRFCoordinator. The oracle will mix this with\r\n    // the hash of the block containing this request to obtain the seed/input\r\n    // which is finally passed to the VRF cryptographic machinery.\r\n    uint256 vRFSeed  = makeVRFInputSeed(_keyHash, USER_SEED_PLACEHOLDER, address(this), nonces[_keyHash]);\r\n    // nonces[_keyHash] must stay in sync with\r\n    // VRFCoordinator.nonces[_keyHash][this], which was incremented by the above\r\n    // successful LINK.transferAndCall (in VRFCoordinator.randomnessRequest).\r\n    // This provides protection against the user repeating their input seed,\r\n    // which would result in a predictable/duplicate output, if multiple such\r\n    // requests appeared in the same block.\r\n    nonces[_keyHash] = nonces[_keyHash].add(1);\r\n    return makeRequestId(_keyHash, vRFSeed);\r\n  }\r\n\r\n  LinkTokenInterface immutable internal LINK;\r\n  address immutable private vrfCoordinator;\r\n\r\n  // Nonces for each VRF key from which randomness has been requested.\r\n  //\r\n  // Must stay in sync with VRFCoordinator[_keyHash][this]\r\n  mapping(bytes32 /* keyHash */ => uint256 /* nonce */) private nonces;\r\n\r\n  /**\r\n   * @param _vrfCoordinator address of VRFCoordinator contract\r\n   * @param _link address of LINK token contract\r\n   *\r\n   * @dev https://docs.chain.link/docs/link-token-contracts\r\n   */\r\n  constructor(address _vrfCoordinator, address _link) public {\r\n    vrfCoordinator = _vrfCoordinator;\r\n    LINK = LinkTokenInterface(_link);\r\n  }\r\n\r\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\r\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\r\n  // the origin of the call\r\n  function rawFulfillRandomness(bytes32 requestId, uint256 randomness) external {\r\n    require(msg.sender == vrfCoordinator, \"Only VRFCoordinator can fulfill\");\r\n    fulfillRandomness(requestId, randomness);\r\n  }\r\n}\r\n\r\n// File: @chainlink/contracts/src/v0.6/Owned.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity >0.6.0 <0.8.0;\r\n\r\n/**\r\n * @title The Owned contract\r\n * @notice A contract with helpers for basic contract ownership.\r\n */\r\ncontract Owned {\r\n\r\n  address public owner;\r\n  address private pendingOwner;\r\n\r\n  event OwnershipTransferRequested(\r\n    address indexed from,\r\n    address indexed to\r\n  );\r\n  event OwnershipTransferred(\r\n    address indexed from,\r\n    address indexed to\r\n  );\r\n\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows an owner to begin transferring ownership to a new address,\r\n   * pending.\r\n   */\r\n  function transferOwnership(address _to)\r\n    external\r\n    onlyOwner()\r\n  {\r\n    pendingOwner = _to;\r\n\r\n    emit OwnershipTransferRequested(owner, _to);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows an ownership transfer to be completed by the recipient.\r\n   */\r\n  function acceptOwnership()\r\n    external\r\n  {\r\n    require(msg.sender == pendingOwner, \"Must be proposed owner\");\r\n\r\n    address oldOwner = owner;\r\n    owner = msg.sender;\r\n    pendingOwner = address(0);\r\n\r\n    emit OwnershipTransferred(oldOwner, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Reverts if called by anyone other than the contract owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner, \"Only callable by owner\");\r\n    _;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/OVRChainlinkCompetition.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\ncontract OVRChainlinkCompetition is VRFConsumerBase, Owned  {\r\n    bytes32 internal keyHash;\r\n    uint256 internal fee;\r\n    \r\n    uint256 public NUMBER_OF_PARTICIPANTS = 17953; \r\n    uint256 public randomResult;\r\n    \r\n    uint public times = 0;\r\n\r\n     /**\r\n     * Constructor inherits VRFConsumerBase\r\n     * \r\n     * Network: Ethereum Mainnet\r\n     * Chainlink VRF Coordinator address: 0xf0d54349aDdcf704F77AE15b96510dEA15cb7952\r\n     * LINK token address:                0x514910771AF9Ca656af840dff83E8264EcF986CA\r\n     * Key Hash: 0xAA77729D3466CA35AE8D28B3BBAC7CC36A5031EFDC430821C02BC31A238AF445\r\n     */\r\n    constructor() \r\n        VRFConsumerBase(\r\n            0xf0d54349aDdcf704F77AE15b96510dEA15cb7952, // VRF Coordinator\r\n            0x514910771AF9Ca656af840dff83E8264EcF986CA  // LINK Token\r\n        ) public {\r\n        keyHash = 0xAA77729D3466CA35AE8D28B3BBAC7CC36A5031EFDC430821C02BC31A238AF445;\r\n        fee = 2 * 10 ** 18; \r\n        // 2 LINK (Ethereum Mainnet)\r\n    }\r\n\r\n    modifier onlyOneTime() {\r\n        require(times == 0, \"You can ask it only one time.\");\r\n        _;\r\n    }\r\n\r\n    /** \r\n     * Requests randomness \r\n     */\r\n    function getRandomNumber() public onlyOwner onlyOneTime returns (bytes32 requestId) {\r\n        require(LINK.balanceOf(address(this)) >= fee, \"Not enough LINK\");\r\n        times += 1;\r\n        return requestRandomness(keyHash, fee);\r\n    }\r\n\r\n    /**\r\n     * Callback function used by VRF Coordinator\r\n     * Random Number between 1 and NUMBER_OF_PARTICIPANTS.\r\n     * +1 because the random number can be zero\r\n     */\r\n    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {\r\n        randomResult = (randomness % NUMBER_OF_PARTICIPANTS) + 1;\r\n    } \r\n\r\n    receive() external payable {\r\n\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"NUMBER_OF_PARTICIPANTS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRandomNumber\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"randomResult\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"randomness\",\"type\":\"uint256\"}],\"name\":\"rawFulfillRandomness\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"times\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"OVRChainlinkCompetition","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://8fa9306178abde4c403288fd59834bd55e71e44da4511ef35e7b3294470c7991"}]}