{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.18;\r\n\r\n\r\ncontract CrowdsaleParameters {\r\n    // Vesting time stamps:\r\n    // 1534672800 = August 19, 2018. 180 days from February 20, 2018. 10:00:00 GMT\r\n    // 1526896800 = May 21, 2018. 90 days from February 20, 2018. 10:00:00 GMT\r\n    uint32 internal vestingTime90Days = 1526896800;\r\n    uint32 internal vestingTime180Days = 1534672800;\r\n\r\n    uint256 internal constant presaleStartDate = 1513072800; // Dec-12-2017 10:00:00 GMT\r\n    uint256 internal constant presaleEndDate = 1515751200; // Jan-12-2018 10:00:00 GMT\r\n    uint256 internal constant generalSaleStartDate = 1516442400; // Jan-20-2018 00:00:00 GMT\r\n    uint256 internal constant generalSaleEndDate = 1519120800; // Feb-20-2018 00:00:00 GMT\r\n\r\n    struct AddressTokenAllocation {\r\n        address addr;\r\n        uint256 amount;\r\n        uint256 vestingTS;\r\n    }\r\n\r\n    AddressTokenAllocation internal presaleWallet       = AddressTokenAllocation(0x43C5FB6b419E6dF1a021B9Ad205A18369c19F57F, 100e6, 0);\r\n    AddressTokenAllocation internal generalSaleWallet   = AddressTokenAllocation(0x0635c57CD62dA489f05c3dC755bAF1B148FeEdb0, 550e6, 0);\r\n    AddressTokenAllocation internal wallet1             = AddressTokenAllocation(0xae46bae68D0a884812bD20A241b6707F313Cb03a,  20e6, vestingTime180Days);\r\n    AddressTokenAllocation internal wallet2             = AddressTokenAllocation(0xfe472389F3311e5ea19B4Cd2c9945b6D64732F13,  20e6, vestingTime180Days);\r\n    AddressTokenAllocation internal wallet3             = AddressTokenAllocation(0xE37dfF409AF16B7358Fae98D2223459b17be0B0B,  20e6, vestingTime180Days);\r\n    AddressTokenAllocation internal wallet4             = AddressTokenAllocation(0x39482f4cd374D0deDD68b93eB7F3fc29ae7105db,  10e6, vestingTime180Days);\r\n    AddressTokenAllocation internal wallet5             = AddressTokenAllocation(0x03736d5B560fE0784b0F5c2D0eA76A7F15E5b99e,   5e6, vestingTime180Days);\r\n    AddressTokenAllocation internal wallet6             = AddressTokenAllocation(0xD21726226c32570Ab88E12A9ac0fb2ed20BE88B9,   5e6, vestingTime180Days);\r\n    AddressTokenAllocation internal foundersWallet      = AddressTokenAllocation(0xC66Cbb7Ba88F120E86920C0f85A97B2c68784755,  30e6, vestingTime90Days);\r\n    AddressTokenAllocation internal wallet7             = AddressTokenAllocation(0x24ce108d1975f79B57c6790B9d4D91fC20DEaf2d,   6e6, 0);\r\n    AddressTokenAllocation internal wallet8genesis      = AddressTokenAllocation(0x0125c6Be773bd90C0747012f051b15692Cd6Df31,   5e6, 0);\r\n    AddressTokenAllocation internal wallet9             = AddressTokenAllocation(0xFCF0589B6fa8A3f262C4B0350215f6f0ed2F630D,   5e6, 0);\r\n    AddressTokenAllocation internal wallet10            = AddressTokenAllocation(0x0D016B233e305f889BC5E8A0fd6A5f99B07F8ece,   4e6, 0);\r\n    AddressTokenAllocation internal wallet11bounty      = AddressTokenAllocation(0x68433cFb33A7Fdbfa74Ea5ECad0Bc8b1D97d82E9,  19e6, 0);\r\n    AddressTokenAllocation internal wallet12            = AddressTokenAllocation(0xd620A688adA6c7833F0edF48a45F3e39480149A6,   4e6, 0);\r\n    AddressTokenAllocation internal wallet13rsv         = AddressTokenAllocation(0x8C393F520f75ec0F3e14d87d67E95adE4E8b16B1, 100e6, 0);\r\n    AddressTokenAllocation internal wallet14partners    = AddressTokenAllocation(0x6F842b971F0076C4eEA83b051523d76F098Ffa52,  96e6, 0);\r\n    AddressTokenAllocation internal wallet15lottery     = AddressTokenAllocation(0xcaA48d91D49f5363B2974bb4B2DBB36F0852cf83,   1e6, 0);\r\n\r\n    uint256 public minimumICOCap = 3333;\r\n}\r\n\r\ncontract Owned {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n    *  Constructor\r\n    *\r\n    *  Sets contract owner to address of constructor caller\r\n    */\r\n    function Owned() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    *  Change Owner\r\n    *\r\n    *  Changes ownership of this contract. Only owner can call this method.\r\n    *\r\n    * @param newOwner - new owner's address\r\n    */\r\n    function changeOwner(address newOwner) onlyOwner public {\r\n        require(newOwner != address(0));\r\n        require(newOwner != owner);\r\n        OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract TKLNToken is Owned, CrowdsaleParameters {\r\n    /* Public variables of the token */\r\n    string public standard = 'Token 0.1';\r\n    string public name = 'Taklimakan';\r\n    string public symbol = 'TKLN';\r\n    uint8 public decimals = 18;\r\n\r\n    /* Arrays of all balances, vesting, approvals, and approval uses */\r\n    mapping (address => uint256) private balances;              // Total token balances\r\n    mapping (address => uint256) private balances90dayFreeze;   // Balances frozen for 90 days after ICO end\r\n    mapping (address => uint256) private balances180dayFreeze;  // Balances frozen for 180 days after ICO end\r\n    mapping (address => uint) private vestingTimesForPools;\r\n    mapping (address => mapping (address => uint256)) private allowed;\r\n    mapping (address => mapping (address => bool)) private allowanceUsed;\r\n\r\n    /* This generates a public event on the blockchain that will notify clients */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Transfer(address indexed spender, address indexed from, address indexed to, uint256 value);\r\n    event VestingTransfer(address indexed from, address indexed to, uint256 value, uint256 vestingTime);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    event Issuance(uint256 _amount); // triggered when the total supply is increased\r\n    event Destruction(uint256 _amount); // triggered when the total supply is decreased\r\n    event NewTKLNToken(address _token);\r\n\r\n    /* Miscellaneous */\r\n    uint256 public totalSupply = 0;\r\n    bool public transfersEnabled = true;\r\n\r\n    /**\r\n    *  Constructor\r\n    *\r\n    *  Initializes contract with initial supply tokens to the creator of the contract\r\n    */\r\n    function TKLNToken() public {\r\n        owner = msg.sender;\r\n\r\n        mintToken(presaleWallet);\r\n        mintToken(generalSaleWallet);\r\n        mintToken(wallet1);\r\n        mintToken(wallet2);\r\n        mintToken(wallet3);\r\n        mintToken(wallet4);\r\n        mintToken(wallet5);\r\n        mintToken(wallet6);\r\n        mintToken(foundersWallet);\r\n        mintToken(wallet7);\r\n        mintToken(wallet8genesis);\r\n        mintToken(wallet9);\r\n        mintToken(wallet10);\r\n        mintToken(wallet11bounty);\r\n        mintToken(wallet12);\r\n        mintToken(wallet13rsv);\r\n        mintToken(wallet14partners);\r\n        mintToken(wallet15lottery);\r\n\r\n        NewTKLNToken(address(this));\r\n    }\r\n\r\n    modifier transfersAllowed {\r\n        require(transfersEnabled);\r\n        _;\r\n    }\r\n\r\n    modifier onlyPayloadSize(uint size) {\r\n        assert(msg.data.length >= size + 4);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    *  1. Associate crowdsale contract address with this Token\r\n    *  2. Allocate general sale amount\r\n    *\r\n    * @param _crowdsaleAddress - crowdsale contract address\r\n    */\r\n    function approveCrowdsale(address _crowdsaleAddress) external onlyOwner {\r\n        approveAllocation(generalSaleWallet, _crowdsaleAddress);\r\n    }\r\n\r\n    /**\r\n    *  1. Associate pre-sale contract address with this Token\r\n    *  2. Allocate presale amount\r\n    *\r\n    * @param _presaleAddress - pre-sale contract address\r\n    */\r\n    function approvePresale(address _presaleAddress) external onlyOwner {\r\n        approveAllocation(presaleWallet, _presaleAddress);\r\n    }\r\n\r\n    function approveAllocation(AddressTokenAllocation tokenAllocation, address _crowdsaleAddress) internal {\r\n        uint uintDecimals = decimals;\r\n        uint exponent = 10**uintDecimals;\r\n        uint amount = tokenAllocation.amount * exponent;\r\n\r\n        allowed[tokenAllocation.addr][_crowdsaleAddress] = amount;\r\n        Approval(tokenAllocation.addr, _crowdsaleAddress, amount);\r\n    }\r\n\r\n    /**\r\n    *  Get token balance of an address\r\n    *\r\n    * @param _address - address to query\r\n    * @return Token balance of _address\r\n    */\r\n    function balanceOf(address _address) public constant returns (uint256 balance) {\r\n        return balances[_address];\r\n    }\r\n\r\n    /**\r\n    *  Get vested token balance of an address\r\n    *\r\n    * @param _address - address to query\r\n    * @return balance that has vested\r\n    */\r\n    function vestedBalanceOf(address _address) public constant returns (uint256 balance) {\r\n        return balances[_address] - balances90dayFreeze[_address] - balances180dayFreeze[_address];\r\n    }\r\n\r\n    /**\r\n    *  Get token amount allocated for a transaction from _owner to _spender addresses\r\n    *\r\n    * @param _owner - owner address, i.e. address to transfer from\r\n    * @param _spender - spender address, i.e. address to transfer to\r\n    * @return Remaining amount allowed to be transferred\r\n    */\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n    *  Send coins from sender's address to address specified in parameters\r\n    *\r\n    * @param _to - address to send to\r\n    * @param _value - amount to send in Wei\r\n    */\r\n    function transfer(address _to, uint256 _value) public transfersAllowed onlyPayloadSize(2*32) returns (bool success) {\r\n        updateVesting(msg.sender);\r\n\r\n        require(vestedBalanceOf(msg.sender) >= _value);\r\n\r\n        // Subtract from the sender\r\n        // _value is never greater than balance of input validation above\r\n        balances[msg.sender] -= _value;\r\n\r\n        // If tokens issued from this address need to vest (i.e. this address is a pool), freeze them here\r\n        if (vestingTimesForPools[msg.sender] > 0) {\r\n            addToVesting(msg.sender, _to, vestingTimesForPools[msg.sender], _value);\r\n        }\r\n\r\n        // Overflow is never possible due to input validation above\r\n        balances[_to] += _value;\r\n\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    *  Create token and credit it to target address\r\n    *  Created tokens need to vest\r\n    *\r\n    */\r\n    function mintToken(AddressTokenAllocation tokenAllocation) internal {\r\n        // Add vesting time for this pool\r\n        vestingTimesForPools[tokenAllocation.addr] = tokenAllocation.vestingTS;\r\n\r\n        uint uintDecimals = decimals;\r\n        uint exponent = 10**uintDecimals;\r\n        uint mintedAmount = tokenAllocation.amount * exponent;\r\n\r\n        // Mint happens right here: Balance becomes non-zero from zero\r\n        balances[tokenAllocation.addr] += mintedAmount;\r\n        totalSupply += mintedAmount;\r\n\r\n        // Emit Issue and Transfer events\r\n        Issuance(mintedAmount);\r\n        Transfer(address(this), tokenAllocation.addr, mintedAmount);\r\n    }\r\n\r\n    /**\r\n    *  Allow another contract to spend some tokens on your behalf\r\n    *\r\n    * @param _spender - address to allocate tokens for\r\n    * @param _value - number of tokens to allocate\r\n    * @return True in case of success, otherwise false\r\n    */\r\n    function approve(address _spender, uint256 _value) public onlyPayloadSize(2*32) returns (bool success) {\r\n        require(_value == 0 || allowanceUsed[msg.sender][_spender] == false);\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n        allowanceUsed[msg.sender][_spender] = false;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    *  Allow another contract to spend some tokens on your behalf\r\n    *\r\n    * @param _spender - address to allocate tokens for\r\n    * @param _currentValue - current number of tokens approved for allocation\r\n    * @param _value - number of tokens to allocate\r\n    * @return True in case of success, otherwise false\r\n    */\r\n    function approve(address _spender, uint256 _currentValue, uint256 _value) public onlyPayloadSize(3*32) returns (bool success) {\r\n        require(allowed[msg.sender][_spender] == _currentValue);\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    *  A contract attempts to get the coins. Tokens should be previously allocated\r\n    *\r\n    * @param _to - address to transfer tokens to\r\n    * @param _from - address to transfer tokens from\r\n    * @param _value - number of tokens to transfer\r\n    * @return True in case of success, otherwise false\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _value) public transfersAllowed onlyPayloadSize(3*32) returns (bool success) {\r\n        updateVesting(_from);\r\n\r\n        // Check if the sender has enough\r\n        require(vestedBalanceOf(_from) >= _value);\r\n\r\n        // Check allowed\r\n        require(_value <= allowed[_from][msg.sender]);\r\n\r\n        // Subtract from the sender\r\n        // _value is never greater than balance because of input validation above\r\n        balances[_from] -= _value;\r\n        // Add the same to the recipient\r\n        // Overflow is not possible because of input validation above\r\n        balances[_to] += _value;\r\n\r\n        // Deduct allocation\r\n        // _value is never greater than allowed amount because of input validation above\r\n        allowed[_from][msg.sender] -= _value;\r\n\r\n        // If tokens issued from this address need to vest (i.e. this address is a pool), freeze them here\r\n        if (vestingTimesForPools[_from] > 0) {\r\n            addToVesting(_from, _to, vestingTimesForPools[_from], _value);\r\n        }\r\n\r\n        Transfer(msg.sender, _from, _to, _value);\r\n        allowanceUsed[_from][msg.sender] = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    *  Default method\r\n    *\r\n    *  This unnamed function is called whenever someone tries to send ether to\r\n    *  it. Just revert transaction because there is nothing that Token can do\r\n    *  with incoming ether.\r\n    *\r\n    *  Missing payable modifier prevents accidental sending of ether\r\n    */\r\n    function() public {\r\n    }\r\n\r\n    /**\r\n    *  Enable or disable transfers\r\n    *\r\n    * @param _enable - True = enable, False = disable\r\n    */\r\n    function toggleTransfers(bool _enable) external onlyOwner {\r\n        transfersEnabled = _enable;\r\n    }\r\n\r\n    /**\r\n    *  Destroy unsold preICO tokens\r\n    *\r\n    */\r\n    function closePresale() external onlyOwner {\r\n        // Destroyed amount is never greater than total supply,\r\n        // so no underflow possible here\r\n        uint destroyedAmount = balances[presaleWallet.addr];\r\n        totalSupply -= destroyedAmount;\r\n        balances[presaleWallet.addr] = 0;\r\n        Destruction(destroyedAmount);\r\n        Transfer(presaleWallet.addr, 0x0, destroyedAmount);\r\n    }\r\n\r\n    /**\r\n    *  Destroy unsold general sale tokens\r\n    *\r\n    */\r\n    function closeGeneralSale() external onlyOwner {\r\n        // Destroyed amount is never greater than total supply,\r\n        // so no underflow possible here\r\n        uint destroyedAmount = balances[generalSaleWallet.addr];\r\n        totalSupply -= destroyedAmount;\r\n        balances[generalSaleWallet.addr] = 0;\r\n        Destruction(destroyedAmount);\r\n        Transfer(generalSaleWallet.addr, 0x0, destroyedAmount);\r\n    }\r\n\r\n    function addToVesting(address _from, address _target, uint256 _vestingTime, uint256 _amount) internal {\r\n        if (CrowdsaleParameters.vestingTime90Days == _vestingTime) {\r\n            balances90dayFreeze[_target] += _amount;\r\n            VestingTransfer(_from, _target, _amount, _vestingTime);\r\n        } else if (CrowdsaleParameters.vestingTime180Days == _vestingTime) {\r\n            balances180dayFreeze[_target] += _amount;\r\n            VestingTransfer(_from, _target, _amount, _vestingTime);\r\n        }\r\n    }\r\n\r\n    function updateVesting(address sender) internal {\r\n        if (CrowdsaleParameters.vestingTime90Days < now) {\r\n            balances90dayFreeze[sender] = 0;\r\n        }\r\n        if (CrowdsaleParameters.vestingTime180Days < now) {\r\n            balances180dayFreeze[sender] = 0;\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"vestedBalanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_presaleAddress\",\"type\":\"address\"}],\"name\":\"approvePresale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_currentValue\",\"type\":\"uint256\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"standard\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_crowdsaleAddress\",\"type\":\"address\"}],\"name\":\"approveCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closePresale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_enable\",\"type\":\"bool\"}],\"name\":\"toggleTransfers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumICOCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeGeneralSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transfersEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"vestingTime\",\"type\":\"uint256\"}],\"name\":\"VestingTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Issuance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Destruction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"NewTKLNToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"TKLNToken","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://169bb9f0ac7b5d92c0bf592abd4690bea78a0218c5bb0e21cdda1ac3711aab1e"}]}