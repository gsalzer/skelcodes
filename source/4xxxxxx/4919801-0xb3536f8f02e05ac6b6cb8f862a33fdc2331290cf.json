{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n * @author Hieu Phan - https://github.com/phanletrunghieu\r\n * @author Hanh Pham - https://github.com/HanhPhamPhuoc\r\n */\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n}\r\n\r\n/*****\r\n    * Orginally from https://github.com/OpenZeppelin/zeppelin-solidity\r\n    * Modified by https://github.com/agarwalakarsh\r\n    */\r\n\r\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }\r\n/*****\r\n    * @title Basic Token\r\n    * @dev Basic Version of a Generic Token\r\n    */\r\ncontract ERC20BasicToken is Pausable{\r\n    // 18 decimals is the strongly suggested default, avoid changing it\r\n    uint256 public totalSupply;\r\n\r\n    // This creates an array with all balances\r\n    mapping (address => uint256) public balances;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n    // This generates a public event on the blockchain that will notify clients\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    // This notifies clients about the amount burnt\r\n    event Burn(address indexed from, uint256 value);\r\n\r\n    //Fix for the ERC20 short address attack.\r\n    modifier onlyPayloadSize(uint size) {\r\n        require(msg.data.length >= size + 4) ;\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Internal transfer, only can be called by this contract\r\n     */\r\n    function _transfer(address _from, address _to, uint _value) whenNotPaused internal {\r\n        // Prevent transfer to 0x0 address. Use burn() instead\r\n        require(_to != 0x0);\r\n        // Check if the sender has enough\r\n        require(balances[_from] >= _value);\r\n        // Check for overflows\r\n        require(balances[_to] + _value > balances[_to]);\r\n        // Save this for an assertion in the future\r\n        uint previousBalances = balances[_from] + balances[_to];\r\n        // Subtract from the sender\r\n        balances[_from] -= _value;\r\n        // Add the same to the recipient\r\n        balances[_to] += _value;\r\n        Transfer(_from, _to, _value);\r\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\r\n        assert(balances[_from] + balances[_to] == previousBalances);\r\n    }\r\n\r\n\r\n    /**\r\n     * Transfer tokens from other address\r\n     *\r\n     * Send `_value` tokens to `_to` in behalf of `_from`\r\n     *\r\n     * @param _from The address of the sender\r\n     * @param _to The address of the recipient\r\n     * @param _value the amount to send\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) whenNotPaused onlyPayloadSize(2 * 32) public returns (bool success) {\r\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\r\n        allowance[_from][msg.sender] -= _value;\r\n        _transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Transfer tokens\r\n     *\r\n     * Send `_value` tokens to `_to` from your account\r\n     *\r\n     * @param _to The address of the recipient\r\n     * @param _value the amount to send\r\n     */\r\n    function transfer(address _to, uint256 _value) whenNotPaused onlyPayloadSize(2 * 32) public {\r\n        _transfer(msg.sender, _to, _value);\r\n    }\r\n\r\n    /**\r\n     * @notice Create `mintedAmount` tokens and send it to `target`\r\n     * @param target Address to receive the tokens\r\n     * @param mintedAmount the amount of tokens it will receive\r\n     */\r\n    function mintToken(address target, uint256 mintedAmount) onlyOwner public {\r\n        balances[target] += mintedAmount;\r\n        totalSupply += mintedAmount;\r\n        Transfer(0, this, mintedAmount);\r\n        Transfer(this, target, mintedAmount);\r\n    }\r\n\r\n    /**\r\n     * Set allowance for other address\r\n     *\r\n     * Allows `_spender` to spend no more than `_value` tokens in your behalf\r\n     *\r\n     * @param _spender The address authorized to spend\r\n     * @param _value the max amount they can spend\r\n     */\r\n    function approve(address _spender, uint256 _value) public\r\n        returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set allowance for other address and notify\r\n     *\r\n     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\r\n     *\r\n     * @param _spender The address authorized to spend\r\n     * @param _value the max amount they can spend\r\n     * @param _extraData some extra information to send to the approved contract\r\n     */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\r\n        public\r\n        returns (bool success) {\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Destroy tokens\r\n     *\r\n     * Remove `_value` tokens from the system irreversibly\r\n     *\r\n     * @param _value the amount of money to burn\r\n     */\r\n    function burn(uint256 _value) public returns (bool success) {\r\n        require(balances[msg.sender] >= _value);   // Check if the sender has enough\r\n        balances[msg.sender] -= _value;            // Subtract from the sender\r\n        totalSupply -= _value;                      // Updates totalSupply\r\n        Burn(msg.sender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Destroy tokens from other account\r\n     *\r\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\r\n     *\r\n     * @param _from the address of the sender\r\n     * @param _value the amount of money to burn\r\n     */\r\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\r\n        require(balances[_from] >= _value);                // Check if the targeted balance is enough\r\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\r\n        balances[_from] -= _value;                         // Subtract from the targeted balance\r\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\r\n        totalSupply -= _value;                              // Update totalSupply\r\n        Burn(_from, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n  \t * Return balance of an account\r\n     * @param _owner the address to get balance\r\n  \t */\r\n  \tfunction balanceOf(address _owner) public constant returns (uint balance) {\r\n  \t\treturn balances[_owner];\r\n  \t}\r\n\r\n    /**\r\n  \t * Return allowance for other address\r\n     * @param _owner The address spend to the other\r\n     * @param _spender The address authorized to spend\r\n  \t */\r\n  \tfunction allowance(address _owner, address _spender) public constant returns (uint remaining) {\r\n  \t\treturn allowance[_owner][_spender];\r\n  \t}\r\n}\r\n\r\ncontract JWCToken is ERC20BasicToken {\r\n\tusing SafeMath for uint256;\r\n\r\n\tstring public constant name      = \"JWC Blockchain Ventures\";   //tokens name\r\n\tstring public constant symbol    = \"JWC\";                       //token symbol\r\n\tuint256 public constant decimals = 18;                          //token decimal\r\n\tstring public constant version   = \"1.0\";                       //tokens version\r\n\r\n\tuint256 public constant tokenPreSale         = 100000000 * 10**decimals;//tokens for pre-sale\r\n\tuint256 public constant tokenPublicSale      = 400000000 * 10**decimals;//tokens for public-sale\r\n\tuint256 public constant tokenReserve         = 300000000 * 10**decimals;//tokens for reserve\r\n\tuint256 public constant tokenTeamSupporter   = 120000000 * 10**decimals;//tokens for Team & Supporter\r\n\tuint256 public constant tokenAdvisorPartners = 80000000  * 10**decimals;//tokens for Advisor\r\n\r\n\taddress public icoContract;\r\n\r\n\t// constructor\r\n\tfunction JWCToken() public {\r\n\t\ttotalSupply = tokenPreSale + tokenPublicSale + tokenReserve + tokenTeamSupporter + tokenAdvisorPartners;\r\n\t}\r\n\r\n\t/**\r\n\t * Set ICO Contract for this token to make sure called by our ICO contract\r\n\t * @param _icoContract - ICO Contract address\r\n\t */\r\n\tfunction setIcoContract(address _icoContract) public onlyOwner {\r\n\t\tif (_icoContract != address(0)) {\r\n\t\t\ticoContract = _icoContract;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Sell tokens when ICO. Only called by ICO Contract\r\n\t * @param _recipient - address send ETH to buy tokens\r\n\t * @param _value - amount of ETHs\r\n\t */\r\n\tfunction sell(address _recipient, uint256 _value) public whenNotPaused returns (bool success) {\r\n\t\tassert(_value > 0);\r\n\t\trequire(msg.sender == icoContract);\r\n\r\n\t\tbalances[_recipient] = balances[_recipient].add(_value);\r\n\r\n\t\tTransfer(0x0, _recipient, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Pay bonus & affiliate to address\r\n\t * @param _recipient - address to receive bonus & affiliate\r\n\t * @param _value - value bonus & affiliate to give\r\n\t */\r\n\tfunction payBonusAffiliate(address _recipient, uint256 _value) public returns (bool success) {\r\n\t\tassert(_value > 0);\r\n\t\trequire(msg.sender == icoContract);\r\n\r\n\t\tbalances[_recipient] = balances[_recipient].add(_value);\r\n\t\ttotalSupply = totalSupply.add(_value);\r\n\r\n\t\tTransfer(0x0, _recipient, _value);\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\n/**\r\n * Store config of phase ICO\r\n */\r\ncontract IcoPhase {\r\n  uint256 public constant phasePresale_From = 1516456800;//14h 20/01/2018 GMT\r\n  uint256 public constant phasePresale_To = 1517839200;//14h 05/02/2018 GMT\r\n\r\n  uint256 public constant phasePublicSale1_From = 1519912800;//14h 01/03/2018 GMT\r\n  uint256 public constant phasePublicSale1_To = 1520344800;//14h 06/03/2018 GMT\r\n\r\n  uint256 public constant phasePublicSale2_From = 1520344800;//14h 06/03/2018 GMT\r\n  uint256 public constant phasePublicSale2_To = 1520776800;//14h 11/03/2018 GMT\r\n\r\n  uint256 public constant phasePublicSale3_From = 1520776800;//14h 11/03/2018 GMT\r\n  uint256 public constant phasePublicSale3_To = 1521208800;//14h 16/03/2018 GMT\r\n}\r\n\r\n/**\r\n * This contract will give bonus for user when buy tokens. The bonus will be paid after finishing ICO\r\n */\r\ncontract Bonus is IcoPhase, Ownable {\r\n\tusing SafeMath for uint256;\r\n\r\n\t//decimals of tokens\r\n\tuint256 constant decimals = 18;\r\n\r\n\t//enable/disable\r\n\tbool public isBonus;\r\n\r\n\t//max tokens for time bonus\r\n\tuint256 public maxTimeBonus = 225000000*10**decimals;\r\n\r\n\t//max tokens for amount bonus\r\n\tuint256 public maxAmountBonus = 125000000*10**decimals;\r\n\r\n\t//storage\r\n\tmapping(address => uint256) public bonusAccountBalances;\r\n\tmapping(uint256 => address) public bonusAccountIndex;\r\n\tuint256 public bonusAccountCount;\r\n\r\n\tuint256 public indexPaidBonus;//amount of accounts have been paid bonus\r\n\r\n\tfunction Bonus() public {\r\n\t\tisBonus = true;\r\n\t}\r\n\r\n\t/**\r\n\t * Enable bonus\r\n\t */\r\n\tfunction enableBonus() public onlyOwner returns (bool)\r\n\t{\r\n\t\trequire(!isBonus);\r\n\t\tisBonus=true;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Disable bonus\r\n\t */\r\n\tfunction disableBonus() public onlyOwner returns (bool)\r\n\t{\r\n\t\trequire(isBonus);\r\n\t\tisBonus=false;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Get bonus percent by time\r\n\t */\r\n\tfunction getTimeBonus() public constant returns(uint256) {\r\n\t\tuint256 bonus = 0;\r\n\r\n\t\tif(now>=phasePresale_From && now<phasePresale_To){\r\n\t\t\tbonus = 40;\r\n\t\t} else if (now>=phasePublicSale1_From && now<phasePublicSale1_To) {\r\n\t\t\tbonus = 20;\r\n\t\t} else if (now>=phasePublicSale2_From && now<phasePublicSale2_To) {\r\n\t\t\tbonus = 10;\r\n\t\t} else if (now>=phasePublicSale3_From && now<phasePublicSale3_To) {\r\n\t\t\tbonus = 5;\r\n\t\t}\r\n\r\n\t\treturn bonus;\r\n\t}\r\n\r\n\t/**\r\n\t * Get bonus by eth\r\n\t * @param _value - eth to convert to bonus\r\n\t */\r\n\tfunction getBonusByETH(uint256 _value) public pure returns(uint256) {\r\n\t\tuint256 bonus = 0;\r\n\r\n\t\tif(_value>=1500*10**decimals){\r\n\t\t\tbonus=_value.mul(25)/100;\r\n\t\t} else if(_value>=300*10**decimals){\r\n\t\t\tbonus=_value.mul(20)/100;\r\n\t\t} else if(_value>=150*10**decimals){\r\n\t\t\tbonus=_value.mul(15)/100;\r\n\t\t} else if(_value>=30*10**decimals){\r\n\t\t\tbonus=_value.mul(10)/100;\r\n\t\t} else if(_value>=15*10**decimals){\r\n\t\t\tbonus=_value.mul(5)/100;\r\n\t\t}\r\n\r\n\t\treturn bonus;\r\n\t}\r\n\r\n\t/**\r\n\t * Get bonus balance of an account\r\n\t * @param _owner - the address to get bonus of\r\n\t */\r\n\tfunction balanceBonusOf(address _owner) public constant returns (uint256 balance)\r\n\t{\r\n\t\treturn bonusAccountBalances[_owner];\r\n\t}\r\n\r\n\t/**\r\n\t * Get bonus balance of an account\r\n\t */\r\n\tfunction payBonus() public onlyOwner returns (bool success);\r\n}\r\n\r\n\r\n/**\r\n * This contract will give affiliate for user when buy tokens. The affiliate will be paid after finishing ICO\r\n */\r\ncontract Affiliate is Ownable {\r\n\r\n\t//Control Affiliate feature.\r\n\tbool public isAffiliate;\r\n\r\n\t//Affiliate level, init is 1\r\n\tuint256 public affiliateLevel = 1;\r\n\r\n\t//Each user will have different rate\r\n\tmapping(uint256 => uint256) public affiliateRate;\r\n\r\n\t//Keep balance of user\r\n\tmapping(address => uint256) public referralBalance;//referee=>value\r\n\r\n\tmapping(address => address) public referral;//referee=>referrer\r\n\tmapping(uint256 => address) public referralIndex;//index=>referee\r\n\r\n\tuint256 public referralCount;\r\n\r\n\t//amount of accounts have been paid affiliate\r\n\tuint256 public indexPaidAffiliate;\r\n\r\n\t// max tokens for affiliate\r\n\tuint256 public maxAffiliate = 100000000*(10**18);\r\n\r\n\t/**\r\n\t * Throw if affiliate is disable\r\n\t */\r\n\tmodifier whenAffiliate() {\r\n\t\trequire (isAffiliate);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * constructor affiliate with level 1 rate = 10%\r\n\t */\r\n\tfunction Affiliate() public {\r\n\t\tisAffiliate=true;\r\n\t\taffiliateLevel=1;\r\n\t\taffiliateRate[0]=10;\r\n\t}\r\n\r\n\t/**\r\n\t * Enable affiliate for the contract\r\n\t */\r\n\tfunction enableAffiliate() public onlyOwner returns (bool) {\r\n\t\trequire (!isAffiliate);\r\n\t\tisAffiliate=true;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Disable affiliate for the contract\r\n\t */\r\n\tfunction disableAffiliate() public onlyOwner returns (bool) {\r\n\t\trequire (isAffiliate);\r\n\t\tisAffiliate=false;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Return current affiliate level\r\n\t */\r\n\tfunction getAffiliateLevel() public constant returns(uint256)\r\n\t{\r\n\t\treturn affiliateLevel;\r\n\t}\r\n\r\n\t/**\r\n\t * Update affiliate level by owner\r\n\t * @param _level - new level\r\n\t */\r\n\tfunction setAffiliateLevel(uint256 _level) public onlyOwner whenAffiliate returns(bool)\r\n\t{\r\n\t\taffiliateLevel=_level;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Get referrer address\r\n\t * @param _referee - the referee address\r\n\t */\r\n\tfunction getReferrerAddress(address _referee) public constant returns (address)\r\n\t{\r\n\t\treturn referral[_referee];\r\n\t}\r\n\r\n\t/**\r\n\t * Get referee address\r\n\t * @param _referrer - the referrer address\r\n\t */\r\n\tfunction getRefereeAddress(address _referrer) public constant returns (address[] _referee)\r\n\t{\r\n\t\taddress[] memory refereeTemp = new address[](referralCount);\r\n\t\tuint count = 0;\r\n\t\tuint i;\r\n\t\tfor (i=0; i<referralCount; i++){\r\n\t\t\tif(referral[referralIndex[i]] == _referrer){\r\n\t\t\t\trefereeTemp[count] = referralIndex[i];\r\n\r\n\t\t\t\tcount += 1;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t_referee = new address[](count);\r\n\t\tfor (i=0; i<count; i++)\r\n\t\t\t_referee[i] = refereeTemp[i];\r\n\t}\r\n\r\n\t/**\r\n\t * Mapping referee address with referrer address\r\n\t * @param _parent - the referrer address\r\n\t * @param _child - the referee address\r\n\t */\r\n\tfunction setReferralAddress(address _parent, address _child) public onlyOwner whenAffiliate returns (bool)\r\n\t{\r\n\t\trequire(_parent != address(0x00));\r\n\t\trequire(_child != address(0x00));\r\n\r\n\t\treferralIndex[referralCount]=_child;\r\n\t\treferral[_child]=_parent;\r\n\t\treferralCount++;\r\n\r\n\t\treferralBalance[_child]=0;\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Get affiliate rate by level\r\n\t * @param _level - level to get affiliate rate\r\n\t */\r\n\tfunction getAffiliateRate(uint256 _level) public constant returns (uint256 rate)\r\n\t{\r\n\t\treturn affiliateRate[_level];\r\n\t}\r\n\r\n\t/**\r\n\t * Set affiliate rate for level\r\n\t * @param _level - the level to be set the new rate\r\n\t * @param _rate - new rate\r\n\t */\r\n\tfunction setAffiliateRate(uint256 _level, uint256 _rate) public onlyOwner whenAffiliate returns (bool)\r\n\t{\r\n\t\taffiliateRate[_level]=_rate;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Get affiliate balance of an account\r\n\t * @param _referee - the address to get affiliate of\r\n\t */\r\n\tfunction balanceAffiliateOf(address _referee) public constant returns (uint256)\r\n\t{\r\n\t\treturn referralBalance[_referee];\r\n\t}\r\n\r\n\t/**\r\n\t * Pay affiliate\r\n\t */\r\n\tfunction payAffiliate() public onlyOwner returns (bool success);\r\n}\r\n\r\n\r\n/**\r\n * This contract will send tokens when an account send eth\r\n * Note: before send eth to token, address has to be registered by registerRecipient function\r\n */\r\ncontract IcoContract is IcoPhase, Ownable, Pausable, Affiliate, Bonus {\r\n\tusing SafeMath for uint256;\r\n\r\n\tJWCToken ccc;\r\n\r\n\tuint256 public totalTokenSale;\r\n\tuint256 public minContribution = 0.1 ether;//minimun eth used to buy tokens\r\n\tuint256 public tokenExchangeRate = 7000;//1ETH=7000 tokens\r\n\tuint256 public constant decimals = 18;\r\n\r\n\tuint256 public tokenRemainPreSale;//tokens remain for pre-sale\r\n\tuint256 public tokenRemainPublicSale;//tokens for public-sale\r\n\r\n\taddress public ethFundDeposit = 0x8780eCF6DB001B223aE48372f4045097e1a11aA9;//multi-sig wallet\r\n\taddress public tokenAddress;\r\n\r\n\tbool public isFinalized;\r\n\r\n\tuint256 public maxGasRefund = 0.0046 ether;//maximum gas used to refund for each transaction\r\n\r\n\t//constructor\r\n\tfunction IcoContract(address _tokenAddress) public {\r\n\t\ttokenAddress = _tokenAddress;\r\n\r\n\t\tccc = JWCToken(tokenAddress);\r\n\t\ttotalTokenSale = ccc.tokenPreSale() + ccc.tokenPublicSale();\r\n\r\n\t\ttokenRemainPreSale = ccc.tokenPreSale();//tokens remain for pre-sale\r\n\t\ttokenRemainPublicSale = ccc.tokenPublicSale();//tokens for public-sale\r\n\r\n\t\tisFinalized=false;\r\n\t}\r\n\r\n\t//usage: web3 change token from eth\r\n\tfunction changeETH2Token(uint256 _value) public constant returns(uint256) {\r\n\t\tuint256 etherRecev = _value + maxGasRefund;\r\n\t\trequire (etherRecev >= minContribution);\r\n\r\n\t\tuint256 rate = getTokenExchangeRate();\r\n\r\n\t\tuint256 tokens = etherRecev.mul(rate);\r\n\r\n\t\t//get current phase of ICO\r\n\t\tuint256 phaseICO = getCurrentICOPhase();\r\n\t\tuint256 tokenRemain = 0;\r\n\t\tif(phaseICO == 1){//pre-sale\r\n\t\t\ttokenRemain = tokenRemainPreSale;\r\n\t\t} else if (phaseICO == 2 || phaseICO == 3 || phaseICO == 4) {\r\n\t\t\ttokenRemain = tokenRemainPublicSale;\r\n\t\t}\r\n\r\n\t\tif (tokenRemain < tokens) {\r\n\t\t\ttokens=tokenRemain;\r\n\t\t}\r\n\r\n\t\treturn tokens;\r\n\t}\r\n\r\n\tfunction () public payable whenNotPaused {\r\n\t\trequire (!isFinalized);\r\n\t\trequire (msg.sender != address(0));\r\n\r\n\t\tuint256 etherRecev = msg.value + maxGasRefund;\r\n\t\trequire (etherRecev >= minContribution);\r\n\r\n\t\t//get current token exchange rate\r\n\t\ttokenExchangeRate = getTokenExchangeRate();\r\n\r\n\t\tuint256 tokens = etherRecev.mul(tokenExchangeRate);\r\n\r\n\t\t//get current phase of ICO\r\n\t\tuint256 phaseICO = getCurrentICOPhase();\r\n\r\n\t\trequire(phaseICO!=0);\r\n\r\n\t\tuint256 tokenRemain = 0;\r\n\t\tif(phaseICO == 1){//pre-sale\r\n\t\t\ttokenRemain = tokenRemainPreSale;\r\n\t\t} else if (phaseICO == 2 || phaseICO == 3 || phaseICO == 4) {\r\n\t\t\ttokenRemain = tokenRemainPublicSale;\r\n\t\t}\r\n\r\n\t\t//throw if tokenRemain==0\r\n\t\trequire(tokenRemain>0);\r\n\r\n\t\tif (tokenRemain < tokens) {\r\n\t\t\t//if tokens is not enough to buy\r\n\r\n\t\t\tuint256 tokensToRefund = tokens.sub(tokenRemain);\r\n\t\t\tuint256 etherToRefund = tokensToRefund / tokenExchangeRate;\r\n\r\n\t\t\t//refund eth to buyer\r\n\t\t\tmsg.sender.transfer(etherToRefund);\r\n\r\n\t\t\ttokens=tokenRemain;\r\n\t\t\tetherRecev = etherRecev.sub(etherToRefund);\r\n\r\n\t\t\ttokenRemain = 0;\r\n\t\t} else {\r\n\t\t\ttokenRemain = tokenRemain.sub(tokens);\r\n\t\t}\r\n\r\n\t\t//store token remain by phase\r\n\t\tif(phaseICO == 1){//pre-sale\r\n\t\t\ttokenRemainPreSale = tokenRemain;\r\n\t\t} else if (phaseICO == 2 || phaseICO == 3 || phaseICO == 4) {\r\n\t\t\ttokenRemainPublicSale = tokenRemain;\r\n\t\t}\r\n\r\n\t\t//send token\r\n\t\tccc.sell(msg.sender, tokens);\r\n\t\tethFundDeposit.transfer(this.balance);\r\n\r\n\t\t//bonus\r\n\t\tif(isBonus){\r\n\t\t\t//bonus amount\r\n\t\t\t//get bonus by eth\r\n\t\t\tuint256 bonusAmountETH = getBonusByETH(etherRecev);\r\n\t\t\t//get bonus by token\r\n\t\t\tuint256 bonusAmountTokens = bonusAmountETH.mul(tokenExchangeRate);\r\n\r\n\t\t\t//check if we have enough tokens for bonus\r\n\t\t\tif(maxAmountBonus>0){\r\n\t\t\t\tif(maxAmountBonus>=bonusAmountTokens){\r\n\t\t\t\t\tmaxAmountBonus-=bonusAmountTokens;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbonusAmountTokens = maxAmountBonus;\r\n\t\t\t\t\tmaxAmountBonus = 0;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tbonusAmountTokens = 0;\r\n\t\t\t}\r\n\r\n\t\t\t//bonus time\r\n\t\t\tuint256 bonusTimeToken = tokens.mul(getTimeBonus())/100;\r\n\t\t\t//check if we have enough tokens for bonus\r\n\t\t\tif(maxTimeBonus>0){\r\n\t\t\t\tif(maxTimeBonus>=bonusTimeToken){\r\n\t\t\t\t\tmaxTimeBonus-=bonusTimeToken;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbonusTimeToken = maxTimeBonus;\r\n\t\t\t\t\tmaxTimeBonus = 0;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tbonusTimeToken = 0;\r\n\t\t\t}\r\n\r\n\t\t\t//store bonus\r\n\t\t\tif(bonusAccountBalances[msg.sender]==0){//new\r\n\t\t\t\tbonusAccountIndex[bonusAccountCount]=msg.sender;\r\n\t\t\t\tbonusAccountCount++;\r\n\t\t\t}\r\n\r\n\t\t\tuint256 bonusTokens=bonusAmountTokens + bonusTimeToken;\r\n\t\t\tbonusAccountBalances[msg.sender]=bonusAccountBalances[msg.sender].add(bonusTokens);\r\n\t\t}\r\n\r\n\t\t//affiliate\r\n\t\tif(isAffiliate){\r\n\t\t\taddress child=msg.sender;\r\n\t\t\tfor(uint256 i=0; i<affiliateLevel; i++){\r\n\t\t\t\tuint256 giftToken=affiliateRate[i].mul(tokens)/100;\r\n\r\n\t\t\t\t//check if we have enough tokens for affiliate\r\n\t\t\t\tif(maxAffiliate<=0){\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif(maxAffiliate>=giftToken){\r\n\t\t\t\t\t\tmaxAffiliate-=giftToken;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tgiftToken = maxAffiliate;\r\n\t\t\t\t\t\tmaxAffiliate = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\taddress parent = referral[child];\r\n\t\t\t\tif(parent != address(0x00)){//has affiliate\r\n\t\t\t\t\treferralBalance[child]=referralBalance[child].add(giftToken);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tchild=parent;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Pay affiliate to address. Called when ICO finish\r\n\t */\r\n\tfunction payAffiliate() public onlyOwner returns (bool success) {\r\n\t\tuint256 toIndex = indexPaidAffiliate + 15;\r\n\t\tif(referralCount < toIndex)\r\n\t\t\ttoIndex = referralCount;\r\n\r\n\t\tfor(uint256 i=indexPaidAffiliate; i<toIndex; i++) {\r\n\t\t\taddress referee = referralIndex[i];\r\n\t\t\tpayAffiliate1Address(referee);\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Pay affiliate to only a address\r\n\t */\r\n\tfunction payAffiliate1Address(address _referee) public onlyOwner returns (bool success) {\r\n\t\taddress referrer = referral[_referee];\r\n\t\tccc.payBonusAffiliate(referrer, referralBalance[_referee]);\r\n\r\n\t\treferralBalance[_referee]=0;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Pay bonus to address. Called when ICO finish\r\n\t */\r\n\tfunction payBonus() public onlyOwner returns (bool success) {\r\n\t\tuint256 toIndex = indexPaidBonus + 15;\r\n\t\tif(bonusAccountCount < toIndex)\r\n\t\t\ttoIndex = bonusAccountCount;\r\n\r\n\t\tfor(uint256 i=indexPaidBonus; i<toIndex; i++)\r\n\t\t{\r\n\t\t\tpayBonus1Address(bonusAccountIndex[i]);\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Pay bonus to only a address\r\n\t */\r\n\tfunction payBonus1Address(address _address) public onlyOwner returns (bool success) {\r\n\t\tccc.payBonusAffiliate(_address, bonusAccountBalances[_address]);\r\n\t\tbonusAccountBalances[_address]=0;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction finalize() external onlyOwner {\r\n\t\trequire (!isFinalized);\r\n\t\t// move to operational\r\n\t\tisFinalized = true;\r\n\t\tpayAffiliate();\r\n\t\tpayBonus();\r\n\t\tethFundDeposit.transfer(this.balance);\r\n\t}\r\n\r\n\t/**\r\n\t * Get token exchange rate\r\n\t * Note: just use when ICO\r\n\t */\r\n\tfunction getTokenExchangeRate() public constant returns(uint256 rate) {\r\n\t\trate = tokenExchangeRate;\r\n\t\tif(now<phasePresale_To){\r\n\t\t\tif(now>=phasePresale_From)\r\n\t\t\t\trate = 10000;\r\n\t\t} else if(now<phasePublicSale3_To){\r\n\t\t\trate = 7000;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Get the current ICO phase\r\n\t */\r\n\tfunction getCurrentICOPhase() public constant returns(uint256 phase) {\r\n\t\tphase = 0;\r\n\t\tif(now>=phasePresale_From && now<phasePresale_To){\r\n\t\t\tphase = 1;\r\n\t\t} else if (now>=phasePublicSale1_From && now<phasePublicSale1_To) {\r\n\t\t\tphase = 2;\r\n\t\t} else if (now>=phasePublicSale2_From && now<phasePublicSale2_To) {\r\n\t\t\tphase = 3;\r\n\t\t} else if (now>=phasePublicSale3_From && now<phasePublicSale3_To) {\r\n\t\t\tphase = 4;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Get amount of tokens that be sold\r\n\t */\r\n\tfunction getTokenSold() public constant returns(uint256 tokenSold) {\r\n\t\t//get current phase of ICO\r\n\t\tuint256 phaseICO = getCurrentICOPhase();\r\n\t\ttokenSold = 0;\r\n\t\tif(phaseICO == 1){//pre-sale\r\n\t\t\ttokenSold = ccc.tokenPreSale().sub(tokenRemainPreSale);\r\n\t\t} else if (phaseICO == 2 || phaseICO == 3 || phaseICO == 4) {\r\n\t\t\ttokenSold = ccc.tokenPreSale().sub(tokenRemainPreSale) + ccc.tokenPublicSale().sub(tokenRemainPublicSale);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Set token exchange rate\r\n\t */\r\n\tfunction setTokenExchangeRate(uint256 _tokenExchangeRate) public onlyOwner returns (bool) {\r\n\t\trequire(_tokenExchangeRate>0);\r\n\t\ttokenExchangeRate=_tokenExchangeRate;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * set min eth contribute\r\n\t * @param _minContribution - min eth to contribute\r\n\t */\r\n\tfunction setMinContribution(uint256 _minContribution) public onlyOwner returns (bool) {\r\n\t\trequire(_minContribution>0);\r\n\t\tminContribution=_minContribution;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Change multi-sig address, the address to receive ETH\r\n\t * @param _ethFundDeposit - new multi-sig address\r\n\t */\r\n\tfunction setEthFundDeposit(address _ethFundDeposit) public onlyOwner returns (bool) {\r\n\t\trequire(_ethFundDeposit != address(0));\r\n\t\tethFundDeposit=_ethFundDeposit;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Set max gas to refund when an address send ETH to buy tokens\r\n\t * @param _maxGasRefund - max gas\r\n\t */\r\n\tfunction setMaxGasRefund(uint256 _maxGasRefund) public onlyOwner returns (bool) {\r\n\t\trequire(_maxGasRefund > 0);\r\n\t\tmaxGasRefund = _maxGasRefund;\r\n\t\treturn true;\r\n\t}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bonusAccountIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_referee\",\"type\":\"address\"}],\"name\":\"payAffiliate1Address\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"phasePublicSale1_From\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payBonus\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokenSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enableAffiliate\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_parent\",\"type\":\"address\"},{\"name\":\"_child\",\"type\":\"address\"}],\"name\":\"setReferralAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enableBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenExchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"affiliateLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"referralIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isAffiliate\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minContribution\",\"type\":\"uint256\"}],\"name\":\"setMinContribution\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"changeETH2Token\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAffiliateLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"setAffiliateLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"referralBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceBonusOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"getBonusByETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"indexPaidAffiliate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"phasePresale_To\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"phasePublicSale1_To\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"affiliateRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"phasePublicSale3_To\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusAccountCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"getRefereeAddress\",\"outputs\":[{\"name\":\"_referee\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"referral\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"payBonus1Address\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxGasRefund\",\"type\":\"uint256\"}],\"name\":\"setMaxGasRefund\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"indexPaidBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"phasePresale_From\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"referralCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payAffiliate\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentICOPhase\",\"outputs\":[{\"name\":\"phase\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableAffiliate\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenSold\",\"outputs\":[{\"name\":\"tokenSold\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"phasePublicSale3_From\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethFundDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minContribution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxAmountBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenRemainPublicSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxAffiliate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_referee\",\"type\":\"address\"}],\"name\":\"getReferrerAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenExchangeRate\",\"outputs\":[{\"name\":\"rate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"getAffiliateRate\",\"outputs\":[{\"name\":\"rate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenExchangeRate\",\"type\":\"uint256\"}],\"name\":\"setTokenExchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_referee\",\"type\":\"address\"}],\"name\":\"balanceAffiliateOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxTimeBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ethFundDeposit\",\"type\":\"address\"}],\"name\":\"setEthFundDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_level\",\"type\":\"uint256\"},{\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"setAffiliateRate\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenRemainPreSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"bonusAccountBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTimeBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"phasePublicSale2_To\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxGasRefund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"phasePublicSale2_From\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"IcoContract","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000f0840466b8ac28ec53fb78561399316a18769f55","Library":"","SwarmSource":"bzzr://87fb77cee97387d6aff1788a8e4cc0aff8a366f1b4867f25908f2d1c1c40b4d8"}]}