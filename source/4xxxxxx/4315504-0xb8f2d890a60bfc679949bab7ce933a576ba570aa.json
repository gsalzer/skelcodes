{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n * evolve110\r\n * https://github.com/vsergeev/evolve110\r\n *\r\n * Copyright (c) 2017 Ivan (Vanya) A. Sergeev\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n */\r\n\r\npragma solidity ^0.4.0;\r\n\r\ncontract Rule110 {\r\n    event GameStateUpdated(uint256 cells);\r\n\r\n    uint256 public state;\r\n    uint16 public size;\r\n\r\n    function Rule110(uint16 _size, uint256 initialCells) {\r\n        require(_size >= 3 && _size <= 256);\r\n\r\n        size = _size;\r\n        state = initialCells;\r\n\r\n        GameStateUpdated(initialCells);\r\n    }\r\n\r\n    uint256 constant PAT1 = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n    uint256 constant PAT2 = 0x4924924924924924924924924924924924924924924924924924924924924924;\r\n    uint256 constant MASK = 0x2492492492492492492492492492492492492492492492492492492492492492;\r\n\r\n    function evolve() {\r\n        uint256 temp;\r\n        uint256 cell_mask;\r\n        uint256 patt_mask;\r\n        uint256 mat1;\r\n        uint256 mat2;\r\n        uint256 mat3;\r\n\r\n        /* Mask for active game cells */\r\n        cell_mask = (uint256(1) << size)-1;\r\n\r\n        /* Mask for pattern matches */\r\n        patt_mask = MASK & (cell_mask >> 1);\r\n\r\n        /* Rule 110\r\n            111 -> 0, 100 -> 0, 000 -> 0, else -> 1\r\n         */\r\n\r\n        /* Find cells that do not match pattern 111 */\r\n        temp = state ^ PAT1;\r\n        mat1 = (temp | (temp >> 1) | (temp << 1)) & patt_mask;\r\n        temp = ((state >> 1) | (state << (size-1))) ^ PAT1;\r\n        mat1 |= ((temp | (temp >> 1) | (temp << 1)) & patt_mask) << 1;\r\n        temp = ((state << 1) | (state >> (size-1))) ^ PAT1;\r\n        mat1 |= ((temp | (temp >> 1) | (temp << 1)) & patt_mask) >> 1;\r\n        temp = ((state >> 2) | (state << (size-2))) ^ PAT1;\r\n        mat1 |= (((temp | (temp >> 1) | (temp << 1)) & patt_mask) << 2) & cell_mask;\r\n        temp = ((state >> 3) | (state << (size-3))) ^ PAT1;\r\n        mat1 |= (((temp | (temp >> 1) | (temp << 1)) & patt_mask) << 3) & cell_mask;\r\n\r\n        /* Find cells that do not match pattern 100 */\r\n        temp = state ^ PAT2;\r\n        mat2 = (temp | (temp >> 1) | (temp << 1)) & patt_mask;\r\n        temp = ((state >> 1) | (state << (size-1))) ^ PAT2;\r\n        mat2 |= ((temp | (temp >> 1) | (temp << 1)) & patt_mask) << 1;\r\n        temp = ((state << 1) | (state >> (size-1))) ^ PAT2;\r\n        mat2 |= ((temp | (temp >> 1) | (temp << 1)) & patt_mask) >> 1;\r\n        temp = ((state >> 2) | (state << (size-2))) ^ PAT2;\r\n        mat2 |= (((temp | (temp >> 1) | (temp << 1)) & patt_mask) << 2) & cell_mask;\r\n        temp = ((state >> 3) | (state << (size-3))) ^ PAT2;\r\n        mat2 |= (((temp | (temp >> 1) | (temp << 1)) & patt_mask) << 3) & cell_mask;\r\n\r\n        /* Find cells that do not match pattern 000 */\r\n        temp = state;\r\n        mat3 = (temp | (temp >> 1) | (temp << 1)) & patt_mask;\r\n        temp = ((state >> 1) | (state << (size-1)));\r\n        mat3 |= ((temp | (temp >> 1) | (temp << 1)) & patt_mask) << 1;\r\n        temp = ((state << 1) | (state >> (size-1)));\r\n        mat3 |= ((temp | (temp >> 1) | (temp << 1)) & patt_mask) >> 1;\r\n        temp = ((state >> 2) | (state << (size-2)));\r\n        mat3 |= (((temp | (temp >> 1) | (temp << 1)) & patt_mask) << 2) & cell_mask;\r\n        temp = ((state >> 3) | (state << (size-3)));\r\n        mat3 |= (((temp | (temp >> 1) | (temp << 1)) & patt_mask) << 3) & cell_mask;\r\n\r\n        /* Any match to patterns 111, 100, or 000, will have a 0 bit in mat1,\r\n         * mat2, or mat3, respectively, in that cell position. Otherwise, that\r\n         * new cell corresponds to one of the 4 other patterns and should be\r\n         * alive. */\r\n\r\n        state = mat1 & mat2 & mat3;\r\n\r\n        GameStateUpdated(state);\r\n    }\r\n}\r\n\r\ncontract Rule110Factory {\r\n    event GameCreated(address game, uint16 size, bytes32 description);\r\n\r\n    string constant public VERSION = \"1.0.0\";\r\n\r\n    function newRule110(uint16 size, uint256 initialCells, bytes32 description) {\r\n        GameCreated(new Rule110(size, initialCells), size, description);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"size\",\"type\":\"uint16\"},{\"name\":\"initialCells\",\"type\":\"uint256\"},{\"name\":\"description\",\"type\":\"bytes32\"}],\"name\":\"newRule110\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"game\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"size\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"description\",\"type\":\"bytes32\"}],\"name\":\"GameCreated\",\"type\":\"event\"}]","ContractName":"Rule110Factory","CompilerVersion":"v0.4.15+commit.8b45bddb","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://693246148c201cd8b56da78399810c723b6c03747da308ce0e88137400f65b65"}]}