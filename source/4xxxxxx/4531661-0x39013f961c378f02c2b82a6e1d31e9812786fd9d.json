{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.8;\r\n\r\n/**\r\nSMSCoin is a token implementation for Speed Mining Service (SMS) project.\r\nWe are aim to issue the SMS tokens to give the privilege to the closed group of investors,\r\nas then they will be able to receive the devidends from our mining farm in Hokkaido and the other countries as well.\r\n\r\nOur cloudsale starts from 27 October 2017, 14:00 (JST) with the different bonus ratio based on the number of token and the sale period.\r\n\r\nSMS coin team,\r\nhttps://smscoin.jp\r\nhttps://github.com/Speed-Mining/SMSCoin\r\nhttps://etherscan.io/address/0x39013f961c378f02c2b82a6e1d31e9812786fd9d\r\n */\r\n\r\nlibrary SMSLIB {\r\n    /**\r\n     * Divide with safety check\r\n     */\r\n    function safeDiv(uint a, uint b) pure internal returns(uint) {\r\n        //overflow check; b must not be 0\r\n        assert(b > 0);\r\n        uint c = a / b;\r\n        assert(a == b * c + a % b);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract ERC20 {\r\n    // Standard interface\r\n    function totalSupply() public constant returns(uint256 _totalSupply);\r\n    function balanceOf(address who) public constant returns(uint256 balance);\r\n    function transfer(address to, uint value) public returns(bool success);\r\n    function transferFrom(address from, address to, uint value) public returns(bool success);\r\n    function approve(address spender, uint value) public returns(bool success);\r\n    function allowance(address owner, address spender) public constant returns(uint remaining);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract SMSCoin is ERC20 {\r\n    string public constant name = \"Speed Mining Service\";\r\n    string public constant symbol = \"SMS\";\r\n    uint256 public constant decimals = 3;\r\n\r\n    uint256 public constant UNIT = 10 ** decimals;\r\n\r\n    uint public totalSupply = 0; // (initial with 0), targeted 2.9 Million SMS\r\n\r\n    uint tokenSaleLot1 = 150000 * UNIT;\r\n    uint reservedBonusLot1 = 45000 * UNIT; // 45,000 tokens are the maximum possible bonus from 30% of 150,000 tokens in the bonus phase\r\n    uint tokenSaleLot3X = 50000 * UNIT;\r\n\r\n    struct BonusStruct {\r\n        uint8 ratio1;\r\n        uint8 ratio2;\r\n        uint8 ratio3;\r\n        uint8 ratio4;\r\n    }\r\n    BonusStruct bonusRatio;\r\n\r\n    uint public saleCounterThisPhase = 0;\r\n\r\n    uint public limitedSale = 0;\r\n\r\n    uint public sentBonus = 0;\r\n\r\n    uint public soldToken = 0;\r\n\r\n    mapping(address => uint) balances;\r\n\r\n    mapping(address => mapping(address => uint)) allowed;\r\n\r\n    address[] addresses;\r\n    address[] investorAddresses;\r\n\r\n    mapping(address => address) private userStructs;\r\n\r\n    address owner;\r\n\r\n    address mint = address(this);   // Contract address as a minter\r\n    \r\n    address genesis = 0x0;\r\n\r\n    uint256 public tokenPrice = 0.8 ether;\r\n    uint256 public firstMembershipPurchase = 0.16 ether;   // White card membership\r\n\r\n    event Log(uint e);\r\n\r\n    event Message(string msg);\r\n\r\n    event TOKEN(string e);\r\n\r\n    bool icoOnSale = false;\r\n\r\n    bool icoOnPaused = false;\r\n\r\n    bool spPhase = false;\r\n\r\n    uint256 startDate;\r\n\r\n    uint256 endDate;\r\n\r\n    uint currentPhase = 0;\r\n\r\n    bool needToDrain = false;\r\n\r\n    modifier onlyOwner() {\r\n        if (msg.sender != owner) {\r\n            revert();\r\n        }\r\n        _;\r\n    }\r\n\r\n    function SMSCoin() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function setBonus(uint8 ratio1, uint8 ratio2, uint8 ratio3, uint8 ratio4) private {\r\n        bonusRatio.ratio1 = ratio1;\r\n        bonusRatio.ratio2 = ratio2;\r\n        bonusRatio.ratio3 = ratio3;\r\n        bonusRatio.ratio4 = ratio4;\r\n    }\r\n\r\n    function calcBonus(uint256 sendingSMSToken) view private returns(uint256) {\r\n        // Calculating bonus\r\n        if (sendingSMSToken < (10 * UNIT)) {            // 0-9\r\n            return (sendingSMSToken * bonusRatio.ratio1) / 100;\r\n        } else if (sendingSMSToken < (50 * UNIT)) {     // 10-49\r\n            return (sendingSMSToken * bonusRatio.ratio2) / 100;\r\n        } else if (sendingSMSToken < (100 * UNIT)) {    // 50-99\r\n            return (sendingSMSToken * bonusRatio.ratio3) / 100;\r\n        } else {                                        // 100+\r\n            return (sendingSMSToken * bonusRatio.ratio4) / 100;\r\n        }\r\n    }\r\n\r\n    // Selling SMS token\r\n    function () public payable {\r\n        uint256 receivedETH = 0;\r\n        uint256 receivedETHUNIT = 0;\r\n        uint256 sendingSMSToken = 0;\r\n        uint256 sendingSMSBonus = 0;\r\n        Log(msg.value);\r\n\r\n        // Only for selling to investors\r\n        if (icoOnSale && !icoOnPaused && msg.sender != owner) {\r\n            if (now <= endDate) {\r\n                // All the phases\r\n                Log(currentPhase);\r\n                \r\n                receivedETH = msg.value;\r\n                // Check if the investor already joined and completed membership payment\r\n                // If a new investor, check if the first purchase is at least equal to the membership price\r\n                if ((checkAddress(msg.sender) && checkMinBalance(msg.sender)) || firstMembershipPurchase <= receivedETH) {\r\n                    // Calculating SMS\r\n                    receivedETHUNIT = receivedETH * UNIT;\r\n                    sendingSMSToken = SMSLIB.safeDiv(receivedETHUNIT, tokenPrice);\r\n                    Log(sendingSMSToken);\r\n\r\n                    // Calculating Bonus\r\n                    if (currentPhase == 1 || currentPhase == 2 || currentPhase == 3) {\r\n                        // Phase 1-3 with Bonus 1\r\n                        sendingSMSBonus = calcBonus(sendingSMSToken);\r\n                        Log(sendingSMSBonus);\r\n                    }\r\n\r\n                    // Giving SMS + Bonus (if any)\r\n                    Log(sendingSMSToken);\r\n                    if (!transferTokens(msg.sender, sendingSMSToken, sendingSMSBonus))\r\n                        revert();\r\n                } else {\r\n                    // Revert if too few ETH for the first purchase\r\n                    revert();\r\n                }\r\n            } else {\r\n                // Revert for end phase\r\n                revert();\r\n            }\r\n        } else {\r\n            // Revert for ICO Paused, Stopped\r\n            revert();\r\n        }\r\n    }\r\n\r\n    // ======== Bonus Period 1 ========\r\n    // --- Bonus ---\r\n    // 0-9 SMS -> 5%\r\n    // 10-49 SMS -> 10%\r\n    // 50-99 SMS -> 20%\r\n    // 100~ SMS -> 30%\r\n    // --- Time --- (2 days 9 hours 59 minutes 59 seconds )\r\n    // From 27 Oct 2017, 14:00 PM JST (27 Oct 2017, 5:00 AM GMT)\r\n    // To   29 Oct 2017, 23:59 PM JST (29 Oct 2017, 14:59 PM GMT)\r\n    function start1BonusPeriod1() external onlyOwner {\r\n        // Supply setting (only once)\r\n        require(currentPhase == 0);\r\n\r\n        balances[owner] = tokenSaleLot1; // Start balance for SpeedMining Co., Ltd.\r\n        balances[address(this)] = tokenSaleLot1;  // Start balance for SMSCoin (for investors)\r\n        totalSupply = balances[owner] + balances[address(this)];\r\n        saleCounterThisPhase = 0;\r\n        limitedSale = tokenSaleLot1;\r\n\r\n        // Add owner address into the list as the first wallet who own token(s)\r\n        addAddress(owner);\r\n\r\n        // Send owner account the initial tokens (rather than only a contract address)\r\n        Transfer(address(this), owner, balances[owner]);\r\n\r\n        // Set draining is needed\r\n        needToDrain = true;\r\n\r\n        // ICO stage init\r\n        icoOnSale = true;\r\n        icoOnPaused = false;\r\n        spPhase = false;\r\n        currentPhase = 1;\r\n        startDate = block.timestamp;\r\n        endDate = startDate + 2 days + 9 hours + 59 minutes + 59 seconds;\r\n\r\n        // Bonus setting \r\n        setBonus(5, 10, 20, 30);\r\n    }\r\n\r\n    // ======== Bonus Period 2 ========\r\n    // --- Bonus ---\r\n    // 0-9 SMS -> 3%\r\n    // 10-49 SMS -> 5%\r\n    // 50-99 SMS -> 10%\r\n    // 100~ SMS -> 15%\r\n    // --- Time --- (11 days 9 hours 59 minutes 59 seconds)\r\n    // From 30 Oct 2017, 14:00 PM JST (30 Oct 2017, 5:00 AM GMT)\r\n    // To   10 Nov 2017, 23:59 PM JST (10 Nov 2017, 14:59 PM GMT)\r\n    function start2BonusPeriod2() external onlyOwner {\r\n        // ICO stage init\r\n        icoOnSale = true;\r\n        icoOnPaused = false;\r\n        spPhase = false;\r\n        currentPhase = 2;\r\n        startDate = block.timestamp;\r\n        endDate = startDate + 11 days + 9 hours + 59 minutes + 59 seconds;\r\n\r\n        // Bonus setting \r\n        setBonus(3, 5, 10, 15);\r\n    }\r\n\r\n    // ======== Bonus Period 3 ========\r\n    // --- Bonus ---\r\n    // 0-9 SMS -> 1%\r\n    // 10-49 SMS -> 3%\r\n    // 50-99 SMS -> 5%\r\n    // 100~ SMS -> 8%\r\n    // --- Time --- (50 days, 5 hours, 14 minutes and 59 seconds)\r\n    // From 11 Nov 2017, 18:45 PM JST (11 Nov 2017, 09:45 AM GMT) (hardfork maintenance 00:00-18:45 JST)\r\n    // To   31 Dec 2017, 23:59 PM JST (31 Dec 2017, 14:59 PM GMT)\r\n    function start3BonusPeriod3() external onlyOwner {\r\n        // ICO stage init\r\n        icoOnSale = true;\r\n        icoOnPaused = false;\r\n        spPhase = false;\r\n        currentPhase = 3;\r\n        startDate = block.timestamp;\r\n        endDate = startDate + 50 days + 5 hours + 14 minutes + 59 seconds;\r\n\r\n        // Bonus setting \r\n        setBonus(1, 3, 5, 8);\r\n    }\r\n\r\n    // ======== Normal Period 1 (2018) ========\r\n    // --- Time --- (31 days)\r\n    // From 1 Jan 2018, 00:00 AM JST (31 Dec 2017, 15:00 PM GMT)\r\n    // To   31 Jan 2018, 23:59 PM JST (31 Jan 2018, 14:59 PM GMT)\r\n    function start4NormalPeriod() external onlyOwner {\r\n        // ICO stage init\r\n        icoOnSale = true;\r\n        icoOnPaused = false;\r\n        spPhase = false;\r\n        currentPhase = 4;\r\n        startDate = block.timestamp;\r\n        endDate = startDate + 31 days;\r\n\r\n        // Reset bonus\r\n        setBonus(0, 0, 0, 0);\r\n    }\r\n\r\n    // ======== Normal Period 2 (2020) ========\r\n    // --- Bonus ---\r\n    // 3X\r\n    // --- Time --- (7 days)\r\n    // From 2 Jan 2020, 00:00 AM JST (1 Jan 2020, 15:00 PM GMT)\r\n    // To   8 Jan 2020, 23:59 PM JST (8 Oct 2020, 14:59 PM GMT)\r\n\r\n    // ======== Normal Period 3 (2025) ========\r\n    // --- Bonus ---\r\n    // 3X\r\n    // --- Time --- (7 days)\r\n    // From 2 Jan 2025, 00:00 AM JST (1 Jan 2025, 15:00 PM GMT)\r\n    // To   8 Jan 2025, 23:59 PM JST (8 Oct 2025, 14:59 PM GMT)\r\n    function start3XPhase() external onlyOwner {\r\n        // Supply setting (only after phase 4 or 5)\r\n        require(currentPhase == 4 || currentPhase == 5);\r\n            \r\n        // Please drain SMS if it was not done yet\r\n        require(!needToDrain);\r\n            \r\n        balances[address(this)] = tokenSaleLot3X;\r\n        totalSupply = 3 * totalSupply;\r\n        totalSupply += balances[address(this)];\r\n        saleCounterThisPhase = 0;\r\n        limitedSale = tokenSaleLot3X;\r\n\r\n        // Bonus\r\n        x3Token(); // 3X distributions to token holders\r\n\r\n        // Mint new tokens\r\n        Transfer(mint, address(this), balances[address(this)]);\r\n        \r\n        // Set draining is needed\r\n        needToDrain = true;\r\n        \r\n        // ICO stage init\r\n        icoOnSale = true;\r\n        icoOnPaused = false;\r\n        spPhase = false;\r\n        currentPhase = 5;\r\n        startDate = block.timestamp;\r\n        endDate = startDate + 7 days;\r\n    }\r\n\r\n    // Selling from the available tokens (on owner wallet) that we collected after each sale end\r\n    // Amount is including full digit\r\n    function startManualPeriod(uint _saleToken) external onlyOwner {\r\n        // Supply setting\r\n\r\n        // Require enough token from owner to be sold on manual phase        \r\n        require(balances[owner] >= _saleToken);\r\n        \r\n        // Please drain SMS if it was not done yet\r\n        require(!needToDrain);\r\n\r\n        // Transfer sale amount to SMS\r\n        balances[owner] -= _saleToken;\r\n        balances[address(this)] += _saleToken;\r\n        saleCounterThisPhase = 0;\r\n        limitedSale = _saleToken;\r\n        Transfer(owner, address(this), _saleToken);\r\n        \r\n        // Set draining is needed\r\n        needToDrain = true;\r\n        \r\n        // ICO stage init\r\n        icoOnSale = true;\r\n        icoOnPaused = false;\r\n        spPhase = true;\r\n        startDate = block.timestamp;\r\n        endDate = startDate + 7 days; // Default running manual mode for 7 days\r\n    }\r\n\r\n    function x3Token() private {\r\n        // Multiply token by 3 to all the current addresses\r\n        for (uint i = 0; i < addresses.length; i++) {\r\n            uint curr1XBalance = balances[addresses[i]];\r\n            // In total 3X, then also calculate value to balances\r\n            balances[addresses[i]] = 3 * curr1XBalance;\r\n            // Transfer 2X from Mint to add with the existing 1X\r\n            Transfer(mint, addresses[i], 2 * curr1XBalance);\r\n            // To keep tracking bonus distribution\r\n            sentBonus += (2 * curr1XBalance);\r\n        }\r\n    }\r\n\r\n    // Called by the owner, to end the current phase and mark as burnable\t\t\r\n    function endPhase() external onlyOwner {\r\n        icoOnSale = false;\r\n        icoOnPaused = true;\r\n    }\r\n\r\n    // Called by the owner, to emergency pause the current phase\r\n    function pausePhase() external onlyOwner {\r\n        icoOnPaused = true;\r\n    }\r\n\r\n    // Called by the owner, to resumes the ended/paused phase\r\n    function resumePhase() external onlyOwner {\r\n        icoOnSale = true;\r\n        icoOnPaused = false;\r\n    }\r\n\r\n    // Called by the owner, to extend deadline (usually for special phase mode)\r\n    function extend1Week() external onlyOwner {\r\n        endDate += 7 days;\r\n    }\r\n\r\n    // Standard interface\r\n    function totalSupply() public constant returns(uint256 _totalSupply) {\r\n        return totalSupply;\r\n    }\r\n\r\n    function balanceOf(address sender) public constant returns(uint256 balance) {\r\n        return balances[sender];\r\n    }\r\n\r\n    function soldToken() public constant returns(uint256 _soldToken) {\r\n        return soldToken;\r\n    }\r\n\r\n    function sentBonus() public constant returns(uint256 _sentBonus) {\r\n        return sentBonus;\r\n    }\r\n\r\n    function saleCounterThisPhase() public constant returns(uint256 _saleCounter) {\r\n        return saleCounterThisPhase;\r\n    }\r\n\r\n    // Price should be entered in multiple of 10000's\r\n    // E.g. for .0001 ether enter 1, for 5 ether price enter 50000\r\n    function setTokenPrice(uint ethRate) external onlyOwner {\r\n        tokenPrice = (ethRate * 10 ** 18) / 10000; // (Convert to ether unit then make 4 decimals for ETH)\r\n    }\r\n\r\n    function setMembershipPrice(uint ethRate) external onlyOwner {\r\n        firstMembershipPurchase = (ethRate * 10 ** 18) / 10000; // (Convert to ether unit then make 4 decimals for ETH)\r\n    }\r\n\r\n    // Transfer the SMS balance from caller's wallet address to target's wallet address\r\n    function transfer(address _to, uint256 _amount) public returns(bool success) {\r\n        if (balances[msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]) {\r\n\r\n            balances[msg.sender] -= _amount;\r\n            balances[_to] += _amount;\r\n            Transfer(msg.sender, _to, _amount);\r\n\r\n            // Add destination wallet address to the list\r\n            addAddress(_to);\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // Transfer the SMS balance from specific wallet address to target's wallet address\r\n    function transferFrom(address _from, address _to, uint256 _amount) public returns(bool success) {\r\n        if (balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]) {\r\n                \r\n            balances[_from] -= _amount;\r\n            allowed[_from][msg.sender] -= _amount;\r\n            balances[_to] += _amount;\r\n            Transfer(_from, _to, _amount);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\r\n    // If this function is called again it overwrites the current allowance with _value.\r\n    function approve(address _spender, uint256 _amount) public returns(bool success) {\r\n        allowed[msg.sender][_spender] = _amount;\r\n        Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n    // Checking allowance\r\n    function allowance(address _owner, address _spender) public constant returns(uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    // Transfer the SMS balance from SMS's contract address to an investor's wallet account\r\n    function transferTokens(address _to, uint256 _amount, uint256 _bonus) private returns(bool success) {\r\n        if (_amount > 0 && balances[address(this)] >= _amount && balances[address(this)] - _amount >= 0 && soldToken + _amount > soldToken && saleCounterThisPhase + _amount <= limitedSale && balances[_to] + _amount > balances[_to]) {\r\n            \r\n            // Transfer token from contract to target\r\n            balances[address(this)] -= _amount;\r\n            soldToken += _amount;\r\n            saleCounterThisPhase += _amount;\r\n            balances[_to] += _amount;\r\n            Transfer(address(this), _to, _amount);\r\n            \r\n            // Transfer bonus token from owner to target\r\n            if (currentPhase <= 3 && _bonus > 0 && balances[owner] - _bonus >= 0 && sentBonus + _bonus > sentBonus && sentBonus + _bonus <= reservedBonusLot1 && balances[_to] + _bonus > balances[_to]) {\r\n\r\n                // Transfer with bonus\r\n                balances[owner] -= _bonus;\r\n                sentBonus += _bonus;\r\n                balances[_to] += _bonus;\r\n                Transfer(owner, _to, _bonus);\r\n            }\r\n\r\n            // Add investor wallet address to the list\r\n            addAddress(_to);\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // Function to give token to investors\r\n    // Will be used to initialize the number of token and number of bonus after migration\r\n    // Also investor can buy token from thridparty channel then owner will run this function\r\n    // Amount and bonus both including full digit\r\n    function giveAways(address _to, uint256 _amount, uint256 _bonus) external onlyOwner {\r\n        // Calling internal transferTokens\r\n        if (!transferTokens(_to, _amount, _bonus))\r\n            revert();\r\n    }\r\n\r\n    // Token bonus reward will be given to investor on each sale end\r\n    // This bonus part will be transferred from the company\r\n    // Bonus will be given to the one who has paid membership (0.16 ETH or holding minimum of 0.2 SMS)\r\n    // Amount is including full digit\r\n    function giveReward(uint256 _amount) external onlyOwner {\r\n        // Checking if amount is available and had sold some token\r\n        require(balances[owner] >= _amount);\r\n\r\n        uint totalInvestorHand = 0;\r\n        // ------------ Sum up all investor token\r\n        for (uint idx = 0; idx < investorAddresses.length; idx++) {\r\n            if (checkMinBalance(investorAddresses[idx]))\r\n                totalInvestorHand += balances[investorAddresses[idx]];\r\n        }\r\n        uint valuePerToken = _amount * UNIT / totalInvestorHand;\r\n\r\n        // ------------ Giving Reward ------------\r\n        for (idx = 0; idx < investorAddresses.length; idx++) {\r\n            if (checkMinBalance(investorAddresses[idx])) {\r\n                uint bonusForThisInvestor = balances[investorAddresses[idx]] * valuePerToken / UNIT;\r\n                sentBonus += bonusForThisInvestor;\r\n                balances[owner] -= bonusForThisInvestor;\r\n                balances[investorAddresses[idx]] += bonusForThisInvestor;\r\n                Transfer(owner, investorAddresses[idx], bonusForThisInvestor);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Check wallet address if exist\r\n    function checkAddress(address _addr) public constant returns(bool exist) {\r\n        return userStructs[_addr] == _addr;\r\n    }\r\n\r\n    // Check if minBalance is enough\r\n    function checkMinBalance(address _addr) public constant returns(bool enough) {\r\n        return balances[_addr] >= (firstMembershipPurchase * 10000 / tokenPrice * UNIT / 10000);\r\n    }\r\n    \r\n    // Add wallet address with existing check\r\n    function addAddress(address _to) private {\r\n        if (addresses.length > 0) {\r\n            if (userStructs[_to] != _to) {\r\n                userStructs[_to] = _to;\r\n                // Adding all addresses\r\n                addresses.push(_to);\r\n                // Adding investor addresses\r\n                if (_to != address(this) && _to != owner)\r\n                    investorAddresses.push(_to);\r\n            }\r\n        } else {\r\n            userStructs[_to] = _to;\r\n            // Adding all addresses\r\n            addresses.push(_to);\r\n            // Adding investor addresses\r\n            if (_to != address(this) && _to != owner)\r\n                investorAddresses.push(_to);\r\n        }\r\n    }\r\n\r\n    // Drain all the available ETH from the contract back to owner's wallet\r\n    function drainETH() external onlyOwner {\r\n        owner.transfer(this.balance);\r\n    }\r\n\r\n    // Drain all the available SMS from the contract back to owner's wallet\r\n    // This will drain only the available token up to the current phase\r\n    function drainSMS() external onlyOwner {\r\n        // Only allowed to be executed after endPhase\r\n        require(!icoOnSale);\r\n\r\n        // Allow to drain SMS and SMS Bonus back to owner only on Phase 4, 5, 6\r\n        if (currentPhase >= 4 || spPhase) {\r\n            // Drain all available SMS\r\n            // From SMS contract\r\n            if (balances[address(this)] > 0) {\r\n                balances[owner] += balances[address(this)];\r\n                Transfer(address(this), owner, balances[address(this)]);\r\n                balances[address(this)] = 0;\r\n\r\n                // Clear draining status\r\n                needToDrain = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Manual burning function\r\n    // Force to burn it in some situation\r\n    // Amount is including decimal points\r\n    function hardBurnSMS(address _from, uint _amount) external onlyOwner {\r\n        // Burning from source address\r\n        if (balances[_from] > 0) {\r\n            balances[_from] -= _amount;\r\n            totalSupply -= _amount;\r\n            Transfer(_from, genesis, _amount);\r\n        }\r\n    }\r\n\r\n    // Function used in Reward contract to know address of token holder\r\n    function getAddress(uint i) public constant returns(address) {\r\n        return addresses[i];\r\n    }\r\n\r\n    // Function used in Reward contract to get to know the address array length\r\n    function getAddressSize() public constant returns(uint) {\r\n        return addresses.length;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"start2BonusPeriod2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"checkAddress\",\"outputs\":[{\"name\":\"exist\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleCounterThisPhase\",\"outputs\":[{\"name\":\"_saleCounter\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"_totalSupply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"start3XPhase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"hardBurnSMS\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"start4NormalPeriod\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sentBonus\",\"outputs\":[{\"name\":\"_sentBonus\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"soldToken\",\"outputs\":[{\"name\":\"_soldToken\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ethRate\",\"type\":\"uint256\"}],\"name\":\"setMembershipPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ethRate\",\"type\":\"uint256\"}],\"name\":\"setTokenPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"checkMinBalance\",\"outputs\":[{\"name\":\"enough\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"giveReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_bonus\",\"type\":\"uint256\"}],\"name\":\"giveAways\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"UNIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resumePhase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"extend1Week\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"getAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"limitedSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_saleToken\",\"type\":\"uint256\"}],\"name\":\"startManualPeriod\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"start1BonusPeriod1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAddressSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pausePhase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endPhase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"start3BonusPeriod3\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"drainETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstMembershipPurchase\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"drainSMS\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"e\",\"type\":\"uint256\"}],\"name\":\"Log\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"msg\",\"type\":\"string\"}],\"name\":\"Message\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"e\",\"type\":\"string\"}],\"name\":\"TOKEN\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"SMSCoin","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://eebba9701c6f958b8671ea95a7039d696db9cb5878965ae5207e9c1c16d5bcbe"}]}