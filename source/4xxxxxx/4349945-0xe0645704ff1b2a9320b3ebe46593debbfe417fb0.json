{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.17;\r\n\r\ncontract owned {\r\n    \r\n    address public owner;\r\n    \r\n    function owned() {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    modifier onlyOwner {\r\n        if (msg.sender != owner) throw;\r\n        _;\r\n    }\r\n    \r\n    function transferOwnership(address newOwner) onlyOwner {\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract ITestekToken {\r\n  function mintTokens(address _to, uint256 _amount);\r\n  function totalSupply() constant returns (uint256 totalSupply);\r\n}\r\n\r\ncontract IERC20Token {\r\n  function totalSupply() constant returns (uint256 totalSupply);\r\n  function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n  function transfer(address _to, uint256 _value) returns (bool success) {}\r\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n  function approve(address _spender, uint256 _value) returns (bool success) {}\r\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract TestekCrowdsale is owned {\r\n    uint256 public startBlock;\r\n    uint256 public endBlock;\r\n    uint256 public minEthToRaise;\r\n    uint256 public maxEthToRaise;\r\n    uint256 public totalEthRaised;\r\n    address public multisigAddress;\r\n    \r\n    ITestekToken TestekTokenContract; \r\n\r\n    uint256 nextFreeParticipantIndex;\r\n    mapping (uint => address) participantIndex;\r\n    mapping (address => uint256) participantContribution;\r\n    \r\n    bool crowdsaleHasStarted;\r\n    bool softCapReached;\r\n    bool hardCapReached;\r\n    bool crowdsaleHasSucessfulyEnded;\r\n    uint256 blocksInADay;\r\n    bool ownerHasClaimedTokens;\r\n    \r\n    uint256 lastEthReturnIndex;\r\n    mapping (address => bool) hasClaimedEthWhenFail;\r\n    \r\n    event CrowdsaleStarted(uint256 _blockNumber);\r\n    event CrowdsaleSoftCapReached(uint256 _blockNumber);\r\n    event CrowdsaleHardCapReached(uint256 _blockNumber);\r\n    event CrowdsaleEndedSuccessfuly(uint256 _blockNumber, uint256 _amountRaised);\r\n    event Crowdsale(uint256 _blockNumber, uint256 _ammountRaised);\r\n    event ErrorSendingETH(address _from, uint256 _amount);\r\n    \r\n    function TestekCrowdsale(uint256 _startBlock, address _multisigAddress){\r\n        \r\n        blocksInADay = 300;\r\n        startBlock = _startBlock;\r\n        endBlock = _startBlock + blocksInADay * 29;      \r\n        minEthToRaise = 3 * 10**18;                     \r\n        maxEthToRaise = 33 * 10**18;                 \r\n        multisigAddress = _multisigAddress;\r\n    }\r\n    \r\n  //  \r\n  /* User accessible methods */   \r\n  //  \r\n    \r\n    function () payable{\r\n      if(msg.value == 0) throw;\r\n      if (crowdsaleHasSucessfulyEnded || block.number > endBlock) throw;        // Throw if the Crowdsale has ended     \r\n      if (!crowdsaleHasStarted){                                                // Check if this is the first Crowdsale transaction       \r\n        if (block.number >= startBlock){                                        // Check if the Crowdsale should start        \r\n          crowdsaleHasStarted = true;                                           // Set that the Crowdsale has started         \r\n          CrowdsaleStarted(block.number);                                       // Raise CrowdsaleStarted event     \r\n        } else{\r\n          throw;\r\n        }\r\n      }\r\n      if (participantContribution[msg.sender] == 0){                            // Check if the sender is a new user       \r\n        participantIndex[nextFreeParticipantIndex] = msg.sender;                // Add a new user to the participant index       \r\n        nextFreeParticipantIndex += 1;\r\n      }  \r\n      if (maxEthToRaise > (totalEthRaised + msg.value)){                        // Check if the user sent too much ETH       \r\n        participantContribution[msg.sender] += msg.value;                       // Add contribution      \r\n        totalEthRaised += msg.value; // Add to total eth Raised\r\n        TestekTokenContract.mintTokens(msg.sender, getTestekTokenIssuance(block.number, msg.value));\r\n        if (!softCapReached && totalEthRaised >= minEthToRaise){                // Check if the min treshold has been reached one time        \r\n          CrowdsaleSoftCapReached(block.number);                                // Raise CrowdsalesoftCapReached event        \r\n          softCapReached = true;                                                // Set that the min treshold has been reached       \r\n        }     \r\n      }else{                                                                    // If user sent to much eth       \r\n        uint maxContribution = maxEthToRaise - totalEthRaised;                  // Calculate maximum contribution       \r\n        participantContribution[msg.sender] += maxContribution;                 // Add maximum contribution to account      \r\n        totalEthRaised += maxContribution;  \r\n        TestekTokenContract.mintTokens(msg.sender, getTestekTokenIssuance(block.number, maxContribution));\r\n        uint toReturn = msg.value - maxContribution;                            // Calculate how much should be returned       \r\n        crowdsaleHasSucessfulyEnded = true;                                     // Set that Crowdsale has successfully ended    \r\n        CrowdsaleHardCapReached(block.number);\r\n        hardCapReached = true;\r\n        CrowdsaleEndedSuccessfuly(block.number, totalEthRaised);      \r\n        if(!msg.sender.send(toReturn)){                                        // Refund the balance that is over the cap         \r\n          ErrorSendingETH(msg.sender, toReturn);                               // Raise event for manual return if transaction throws       \r\n        }     \r\n      }     \r\n    }\r\n    \r\n    /* Users can claim ETH by themselves if they want to in case of ETH failure */   \r\n    function claimEthIfFailed(){    \r\n      if (block.number <= endBlock || totalEthRaised >= minEthToRaise) throw; // Check if Crowdsale has failed    \r\n      if (participantContribution[msg.sender] == 0) throw;                    // Check if user has participated     \r\n      if (hasClaimedEthWhenFail[msg.sender]) throw;                           // Check if this account has already claimed ETH    \r\n      uint256 ethContributed = participantContribution[msg.sender];           // Get participant ETH Contribution     \r\n      hasClaimedEthWhenFail[msg.sender] = true;     \r\n      if (!msg.sender.send(ethContributed)){      \r\n        ErrorSendingETH(msg.sender, ethContributed);                          // Raise event if send failed, solve manually     \r\n      }   \r\n    } \r\n\r\n    /* Owner can return eth for multiple users in one call */  \r\n    function batchReturnEthIfFailed(uint256 _numberOfReturns) onlyOwner{    \r\n      if (block.number < endBlock || totalEthRaised >= minEthToRaise) throw;    // Check if Crowdsale failed  \r\n      address currentParticipantAddress;    \r\n      uint256 contribution;\r\n      for (uint cnt = 0; cnt < _numberOfReturns; cnt++){      \r\n        currentParticipantAddress = participantIndex[lastEthReturnIndex];       // Get next account       \r\n        if (currentParticipantAddress == 0x0) return;                           // Check if participants were reimbursed      \r\n        if (!hasClaimedEthWhenFail[currentParticipantAddress]) {                // Check if user has manually recovered ETH         \r\n          contribution = participantContribution[currentParticipantAddress];    // Get accounts contribution        \r\n          hasClaimedEthWhenFail[msg.sender] = true;                             // Set that user got his ETH back         \r\n          if (!currentParticipantAddress.send(contribution)){                   // Send fund back to account          \r\n             ErrorSendingETH(currentParticipantAddress, contribution);           // Raise event if send failed, resolve manually         \r\n          }       \r\n        }       \r\n        lastEthReturnIndex += 1;    \r\n      }   \r\n    }\r\n      \r\n    /* Owner sets new address of escrow */\r\n    function changeMultisigAddress(address _newAddress) onlyOwner {     \r\n      multisigAddress = _newAddress;\r\n    } \r\n    \r\n    /* Show how many participants was */\r\n    function participantCount() constant returns(uint){\r\n      return nextFreeParticipantIndex;\r\n    }\r\n\r\n    /* Owner can claim reserved tokens on the end of crowsale */  \r\n    function claimTeamTokens(address _to) onlyOwner{     \r\n      if (!crowdsaleHasSucessfulyEnded) throw; \r\n      if (ownerHasClaimedTokens) throw;\r\n        \r\n      TestekTokenContract.mintTokens(_to, TestekTokenContract.totalSupply() * 49/51); /* 51% Crowdsale - 49% Testek */\r\n      ownerHasClaimedTokens = true;\r\n    } \r\n      \r\n    /* Set token contract where mints will be done (tokens will be issued) */  \r\n    function setTokenContract(address _TestekTokenContractAddress) onlyOwner {     \r\n      TestekTokenContract = ITestekToken(_TestekTokenContractAddress);   \r\n    }   \r\n       \r\n    function getTestekTokenIssuance(uint256 _blockNumber, uint256 _ethSent) constant returns(uint){\r\n      if (_blockNumber >= startBlock && _blockNumber < startBlock + blocksInADay * 2) return _ethSent * 3540;\r\n      if (_blockNumber >= startBlock + blocksInADay * 2 && _blockNumber < startBlock + blocksInADay * 7) return _ethSent * 3289; \r\n      if (_blockNumber >= startBlock + blocksInADay * 7 && _blockNumber < startBlock + blocksInADay * 14) return _ethSent * 3184; \r\n      if (_blockNumber >= startBlock + blocksInADay * 14 && _blockNumber < startBlock + blocksInADay * 21) return _ethSent * 3097; \r\n      if (_blockNumber >= startBlock + blocksInADay * 21 ) return _ethSent * 3009;\r\n    }\r\n    \r\n    /* Withdraw funds from contract */  \r\n    function withdrawEther() onlyOwner{     \r\n      if (this.balance == 0) throw;                                            // Check if there is balance on the contract     \r\n      if (totalEthRaised < minEthToRaise) throw;                               // Check if minEthToRaise treshold is exceeded     \r\n          \r\n      if(multisigAddress.send(this.balance)){}                                 // Send the contract's balance to multisig address   \r\n    }\r\n\r\n    function endCrowdsale() onlyOwner{\r\n      if (totalEthRaised < minEthToRaise) throw;\r\n      if (block.number < endBlock) throw;\r\n      crowdsaleHasSucessfulyEnded = true;\r\n      CrowdsaleEndedSuccessfuly(block.number, totalEthRaised);\r\n    }\r\n    \r\n    \r\n    function salvageTokensFromContract(address _tokenAddress, address _to, uint _amount) onlyOwner{\r\n    IERC20Token(_tokenAddress).transfer(_to, _amount);\r\n    }\r\n    /* Getters */     \r\n    \r\n    function getTSTTokenAddress() constant returns(address _tokenAddress){    \r\n      return address(TestekTokenContract);   \r\n    }   \r\n    \r\n    function crowdsaleInProgress() constant returns (bool answer){    \r\n      return crowdsaleHasStarted && !crowdsaleHasSucessfulyEnded;   \r\n    }   \r\n    \r\n    function participantContributionInEth(address _querryAddress) constant returns (uint256 answer){    \r\n      return participantContribution[_querryAddress];   \r\n    }\r\n    \r\n    /* Withdraw remaining balance to manually return where contract send has failed */  \r\n    function withdrawRemainingBalanceForManualRecovery() onlyOwner{     \r\n      if (this.balance == 0) throw;                                         // Check if there is balance on the contract    \r\n      if (block.number < endBlock) throw;                                   // Check if Crowdsale failed    \r\n      if (participantIndex[lastEthReturnIndex] != 0x0) throw;               // Check if all the participants have been reimbursed     \r\n      if (multisigAddress.send(this.balance)){}                             // Send remainder so it can be manually processed   \r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"changeMultisigAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minEthToRaise\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_blockNumber\",\"type\":\"uint256\"},{\"name\":\"_ethSent\",\"type\":\"uint256\"}],\"name\":\"getTestekTokenIssuance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawRemainingBalanceForManualRecovery\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_querryAddress\",\"type\":\"address\"}],\"name\":\"participantContributionInEth\",\"outputs\":[{\"name\":\"answer\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"participantCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTSTTokenAddress\",\"outputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multisigAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimEthIfFailed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_numberOfReturns\",\"type\":\"uint256\"}],\"name\":\"batchReturnEthIfFailed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"salvageTokensFromContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_TestekTokenContractAddress\",\"type\":\"address\"}],\"name\":\"setTokenContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEthRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleInProgress\",\"outputs\":[{\"name\":\"answer\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxEthToRaise\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"claimTeamTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_startBlock\",\"type\":\"uint256\"},{\"name\":\"_multisigAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"CrowdsaleStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"CrowdsaleSoftCapReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"CrowdsaleHardCapReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_blockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_amountRaised\",\"type\":\"uint256\"}],\"name\":\"CrowdsaleEndedSuccessfuly\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_blockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_ammountRaised\",\"type\":\"uint256\"}],\"name\":\"Crowdsale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ErrorSendingETH\",\"type\":\"event\"}]","ContractName":"TestekCrowdsale","CompilerVersion":"v0.4.17+commit.bdeb9e52","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000425ff5000000000000000000000000d2f041f2eeb31f18f577e4855a90525c2ac89e40","Library":"","SwarmSource":"bzzr://3567acab0550c5655e4a3a66f79c154ace69b0379d77b601734af3d1d1950ee4"}]}