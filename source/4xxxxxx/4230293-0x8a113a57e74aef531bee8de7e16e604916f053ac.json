{"status":"1","message":"OK","result":[{"SourceCode":"//////////////////////////////////////////////////////////////////////////////////////////\r\n//\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\r\n//\tTitle: \t\t\t\t\t\tClipper Coin Creation Contract\t\t\t\t\t\t\t//\r\n//\tAuthor: \t\t\t\t\tMarko Valentin Micic\t\t\t\t\t\t\t\t\t//\r\n//\tVersion: \t\t\t\t\tv0.1\t\t\t\t\t\t\t\t\t\t\t\t\t//\r\n//\tDate of current version:\t2017/09/01\t\t\t\t\t\t\t\t\t\t\t\t//\r\n//\tBrief Description:\t\t\tThe smart contract that will create tokens. The tokens\t//\r\n//\t\t\t\t\t\t\t\twill be apportioned according to the results of the \t//\r\n//\t\t\t\t\t\t\t\tICO conducted on ico.info earlier. Results of the ICO\t// \r\n//\t\t\t\t\t\t\t\tcan be viewed at https://ico.info/projects/19 and are \t//\r\n//\t\t\t\t\t\t\t\tsummarized below:\t\t\t\t\t\t\t\t\t\t//\r\n//\t\t\t\t\t\t\t\tBTC raised: 386.808\t\t\t\t\t\t\t\t\t\t//\r\n//\t\t\t\t\t\t\t\tETH raised: 24451.896\t\t\t\t\t\t\t\t\t//\r\n//\t\t\t\t\t\t\t\tEOS raised: 1468860\t\t\t\t\t\t\t\t\t\t//\r\n//\t\t\t\t\t\t\t\tIn accordance with Clipper Coin Venture's plan (also\t//\r\n//\t\t\t\t\t\t\t\tviewable on the same website), the appropriate \t\t\t//\r\n//\t\t\t\t\t\t\t\tproportion of coins will be delivered to ICOInfo, a \t//\r\n//\t\t\t\t\t\t\t\tcertain proportion will be deleted, and the rest held \t//\r\n//\t\t\t\t\t\t\t\tin reserve for uses that will be determined by later\t//\r\n//\t\t\t\t\t\t\t\tsmart contracts. \t\t\t\t\t\t\t\t\t\t//\r\n//\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\r\n//////////////////////////////////////////////////////////////////////////////////////////\r\npragma solidity ^0.4.11;\r\n\r\ncontract ERC20Protocol {\r\n/* This is a slight change to the ERC20 base standard.\r\n    function totalSupply() constant returns (uint supply);\r\n    is replaced with:\r\n    uint public totalSupply;\r\n    This automatically creates a getter function for the totalSupply.\r\n    This is moved to the base contract since public getter functions are not\r\n    currently recognised as an implementation of the matching abstract\r\n    function by the compiler.\r\n    */\r\n    /// total amount of tokens\r\n    uint public totalSupply;\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint _value) returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of tokens to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint _value) returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\n/**\r\n * Math operations with safety checks\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint a, uint b) internal returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a / b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n\r\n  function sub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n}\r\n\r\n/// @dev `Owned` is a base level contract that assigns an `owner` that can be\r\n///  later changed\r\ncontract Owned {\r\n\r\n    /// @dev `owner` is the only address that can call a function with this\r\n    /// modifier\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    address public owner;\r\n\r\n    /// @notice The Constructor assigns the message sender to be `owner`\r\n    function Owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    address public newOwner;\r\n\r\n    /// @notice `owner` can step down and assign some other address to this role\r\n    /// @param _newOwner The address of the new owner. 0x0 can be used to create\r\n    ///  an unowned neutral vault, however that cannot be undone\r\n    function changeOwner(address _newOwner) onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n\r\n    function acceptOwnership() {\r\n        if (msg.sender == newOwner) {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n}\r\n\r\ncontract StandardToken is ERC20Protocol {\r\n    using SafeMath for uint;\r\n\r\n    /**\r\n    * @dev Fix for the ERC20 short address attack.\r\n    */\r\n    modifier onlyPayloadSize(uint size) {\r\n        require(msg.data.length >= size + 4);\r\n        _;\r\n    }\r\n\r\n    function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint _value) onlyPayloadSize(2 * 32) returns (bool success) {\r\n        // To change the approve amount you first have to reduce the addresses`\r\n        //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n        //  already 0 to mitigate the race condition described here:\r\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        assert((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint) balances;\r\n    mapping (address => mapping (address => uint)) allowed;\r\n}\r\n\r\ncontract tokenRecipient { \r\n\tfunction receiveApproval(\r\n\t\taddress _from, \r\n\t\tuint256 _value, \r\n\t\taddress _token, \r\n\t\tbytes _extraData); \r\n}\r\n\r\ncontract ClipperCoin is Owned{\r\n    using SafeMath for uint;\r\n\r\n    /// Constant token specific fields\r\n    string public name = \"Clipper Coin\";\r\n    string public symbol = \"CCCT\";\r\n    uint public decimals = 18;\r\n\r\n    /// Total supply of Clipper Coin\r\n    uint public totalSupply = 200000000 ether;\r\n    \r\n    /// Create an array with all balances\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n    \r\n    /// Generate public event on the blockchain that will notify clients of transfers\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    \r\n    /// Generate public event on the blockchain that notifies clients how much CCC has \r\n    /// been destroyed\r\n    event Burn(address indexed from, uint256 value);\r\n    \r\n    /// Initialize contract with initial supply of tokens sent to the creator of the \r\n    /// contract, who is defined as the minter of the coin\r\n    function ClipperCoin(\r\n    \tuint256 initialSupply,\r\n    \tstring tokenName,\r\n    \tuint8 tokenDecimals,\r\n    \tstring tokenSymbol\r\n    \t) {\r\n    \t    \r\n    \t//Give creator all initial tokens\r\n    \tbalanceOf[msg.sender]  = initialSupply;\r\n    \t\r\n    \t// Set the total supply of all Clipper Coins\r\n    \ttotalSupply  = initialSupply;\r\n    \t\r\n    \t// Set the name of Clipper Coins\r\n    \tname = tokenName;\r\n    \t\r\n    \t// Set the symbol of Clipper Coins: CCC\r\n    \tsymbol = tokenSymbol;\r\n    \t\r\n    \t// Set the amount of decimal places present in Clipper Coin: 18\r\n    \t// Note: 18 is the ethereum standard\r\n    \tdecimals = tokenDecimals;\r\n    }\r\n    \r\n    \r\n    /// Internal transfers, which can only be called by this contract.\r\n    function _transfer(\r\n    \taddress _from,\r\n    \taddress _to,\r\n    \tuint _value)\r\n    \tinternal {\r\n    \t    \r\n    \t// Prevent transfers to the 0x0 address. Use burn() instead to \r\n    \t// permanently remove Clipper Coins from the Blockchain\r\n    \trequire (_to != 0x0);\r\n    \t\r\n    \t// Check that the account has enough Clipper Coins to be transferred\r\n        require (balanceOf[_from] > _value);                \r\n        \r\n        // Check that the subraction of coins is not occuring\r\n        require (balanceOf[_to] + _value > balanceOf[_to]); \r\n        balanceOf[_from] -= _value;                         \r\n        balanceOf[_to] += _value;                           \r\n        Transfer(_from, _to, _value);\r\n    }\r\n    \r\n    /// @notice Send `_value` tokens to `_to` from your account\r\n    /// @param _to The address of the recipient\r\n    /// @param _value the amount to send\r\n    function transfer(\r\n    \taddress _to, \r\n    \tuint256 _value) {\r\n        _transfer(msg.sender, _to, _value);\r\n    }\r\n\r\n    /// @notice Send `_value` tokens to `_to` on behalf of `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value the amount to send\r\n    function transferFrom(\r\n    \taddress _from, \r\n    \taddress _to, \r\n    \tuint256 _value) returns (bool success) {\r\n        require (_value < allowance[_from][msg.sender]);     \r\n        allowance[_from][msg.sender] -= _value;\r\n        _transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Allows `_spender` to spend no more than `_value` tokens on your behalf\r\n    /// @param _spender The address authorized to spend\r\n    /// @param _value the max amount they can spend\r\n    function approve(\r\n    \taddress _spender, \r\n    \tuint256 _value) returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        return true;\r\n    }\r\n\r\n    /// @notice Allows `_spender` to spend no more than `_value` tokens on your behalf, \r\n    ///\t\t\tand then ping the contract about it\r\n    /// @param _spender The address authorized to spend\r\n    /// @param _value the max amount they can spend\r\n    /// @param _extraData some extra information to send to the approved contract\r\n    function approveAndCall(\r\n    \taddress _spender, \r\n    \tuint256 _value, \r\n    \tbytes _extraData) returns (bool success) {\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }\r\n    }        \r\n\r\n    /// @notice Remove `_value` tokens from the system irreversibly\r\n    /// @param _value the amount of money to burn\r\n    function burn(uint256 _value) returns (bool success) {\r\n        require (balanceOf[msg.sender] > _value);            \r\n        balanceOf[msg.sender] -= _value;                      \r\n        totalSupply -= _value;                                \r\n        Burn(msg.sender, _value);\r\n        return true;\r\n    }\r\n\r\n    function burnFrom(\r\n    \taddress _from, \r\n    \tuint256 _value) returns (bool success) {\r\n        require(balanceOf[_from] >= _value);                \r\n        require(_value <= allowance[_from][msg.sender]);    \r\n        balanceOf[_from] -= _value;                         \r\n        allowance[_from][msg.sender] -= _value;             \r\n        totalSupply -= _value;                              \r\n        Burn(_from, _value);\r\n        return true;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"initialSupply\",\"type\":\"uint256\"},{\"name\":\"tokenName\",\"type\":\"string\"},{\"name\":\"tokenDecimals\",\"type\":\"uint8\"},{\"name\":\"tokenSymbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"}]","ContractName":"ClipperCoin","CompilerVersion":"v0.4.16+commit.d7661dd9","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000a56fa5b99019a5c80000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000013436c697070657220436f696e205465737420320000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044343437400000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://b9b7e08988748f121d5f839ae3fb035f278dfd7237283353e1ca1c79a18cc11e"}]}