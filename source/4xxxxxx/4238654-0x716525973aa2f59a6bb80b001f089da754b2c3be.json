{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\n/*\r\n\r\nLottery\r\n========================\r\n\r\nAllows users to participate in a game-theoretically sound lottery.\r\nAuthor: /u/Cintix\r\n\r\n*/\r\n\r\ncontract Lottery {\r\n  // The Ticket struct encodes an address' range of winning numbers.\r\n  struct Ticket {\r\n    // Offset from 0 of the Ticket's range of winning numbers.\r\n    uint128 offset;\r\n    // The value of the Ticket in Wei and the size of the range of winning numbers.\r\n    uint128 value;\r\n  }\r\n  // Store the Ticket corresponding to each user's address.\r\n  mapping (address => Ticket) public tickets;\r\n  // Store the commited hash of each host.\r\n  mapping (address => bytes32) public commits;\r\n  // Store the number of hosts securing the lottery's RNG.\r\n  uint256 public num_hosts;\r\n  // Store the number of hosts that have revealed their secret random number.\r\n  uint256 public num_hosts_revealed;\r\n  // Store the host-generated random number that determines the lottery winner.\r\n  uint256 public rng;\r\n  // Boolean indicating whether the lottery has been cancelled.\r\n  bool public cancelled;\r\n  // Store total ETH spent by users on tickets.\r\n  uint256 public total_user_eth;\r\n  // Maximum total ETH users may spend on tickets.\r\n  uint256 public total_user_eth_cap = 100 ether;\r\n  // Cut of the winnings used to incentivize host participation.\r\n  uint256 public host_percentage = 10;\r\n  // Store end time of the ticket buying phase.\r\n  uint256 public buy_end_time = 1503829813;\r\n  // Store end time of the host commit phase.\r\n  uint256 public commit_end_time = buy_end_time + 1 days;\r\n  // Store end time of the host reveal phase.\r\n  uint256 public reveal_end_time = commit_end_time + 1 days;\r\n  \r\n  // Cancel the lottery if the host quorum isn't met or a host failed to reveal in time.\r\n  function cancel_lottery() {\r\n    // Only allow canceling the lottery after the commit phase has ended.\r\n    require(now > commit_end_time);\r\n    // Determine whether there are enough hosts for trustless RNG.\r\n    bool quorum_met = num_hosts >= 2;\r\n    // Determine whether all hosts have revealed their secret random numbers.\r\n    bool all_hosts_revealed = num_hosts == num_hosts_revealed;\r\n    // Determine whether the reveal phase has ended.\r\n    bool reveal_phase_ended = now > reveal_end_time;\r\n    // Only allow canceling the lottery if the quorum hasn't been met or not all hosts revealed.\r\n    require(!quorum_met || (!all_hosts_revealed && reveal_phase_ended));\r\n    // Irreversibly cancel the lottery.\r\n    cancelled = true;\r\n  }\r\n  \r\n  // Adds a host to the lottery, increasing the security of the lottery's random number generation.\r\n  function host_lottery(bytes32 commit) payable {\r\n    // Hosts must guarantee their hashed secret random number up to the value of the lottery.\r\n    require(msg.value == total_user_eth);\r\n    // Only allow new hosts to join during the lottery's commit phase.\r\n    require((now > buy_end_time) && (now <= commit_end_time));\r\n    // Sanity check hashed secret and only allow each host to join once.\r\n    require((commit != 0) && (commits[msg.sender] == 0));\r\n    // Store the host's hashed secret random number.\r\n    commits[msg.sender] = commit;\r\n    // Increment the host counter to account for the new host.\r\n    num_hosts += 1;\r\n  }\r\n  \r\n  // Allows anyone to steal a host's committed ETH if their secret random number isn't random or isn't secret.\r\n  function steal_reveal(address host, uint256 secret_random_number) {\r\n    // Only allow stealing during the lottery's commit phase to prevent higher-gas-tx-sniping host reveals.\r\n    require((now > buy_end_time) && (now <= commit_end_time));\r\n    // Verify the secret random number matches the committed hash.\r\n    require(commits[host] == keccak256(secret_random_number));\r\n    // Irreversibly cancel the lottery, as rng is compromised.\r\n    cancelled = true;\r\n    // Update commitment prior to sending ETH to prevent recursive call.\r\n    commits[host] = 0;\r\n    // Send the thief the host's committed ETH.\r\n    msg.sender.transfer(total_user_eth);\r\n  }\r\n  \r\n  // Allow hosts to reveal their secret random number during the lottery's reveal phase.\r\n  function host_reveal(uint256 secret_random_number) {\r\n    // Only allow revealing during the lottery's reveal phase.\r\n    require((now > commit_end_time) && (now <= reveal_end_time));\r\n    // Verify the secret random number matches the committed hash.\r\n    require(commits[msg.sender] == keccak256(secret_random_number));\r\n    // Update commitment prior to sending ETH to prevent recursive call.\r\n    commits[msg.sender] = 0;\r\n    // Update random number by XORing with host's revealed secret random number.\r\n    rng ^= secret_random_number;\r\n    // Increment the counter of hosts that have revealed their secret number.\r\n    num_hosts_revealed += 1;\r\n    // Send the host back their committed ETH.\r\n    msg.sender.transfer(total_user_eth);\r\n  }\r\n  \r\n  // Allow hosts to claim their earnings from a successful lottery.\r\n  function host_claim_earnings(address host) {\r\n    // Only allow claims if the lottery hasn't been cancelled.\r\n    require(!cancelled);\r\n    // Only allow claims if there were enough hosts for trustless RNG.\r\n    require(num_hosts >= 2);\r\n    // Only allow claims if all hosts have revealed their secret random numbers.\r\n    require(num_hosts == num_hosts_revealed);\r\n    // Send the host their earnings (i.e. an even cut of 10% of ETH spent on tickets).\r\n    host.transfer(total_user_eth * host_percentage / (num_hosts * 100));\r\n  }\r\n  \r\n  // Allow anyone to send the winner their winnings.\r\n  function claim_winnings(address winner) {\r\n    // Only allow winning if the lottery hasn't been cancelled.\r\n    require(!cancelled);\r\n    // Only allow winning if there were enough hosts for trustless RNG.\r\n    require(num_hosts >= 2);\r\n    // Only allow winning if all hosts have revealed their secret random numbers.\r\n    require(num_hosts == num_hosts_revealed);\r\n    // Calculate the winning number.\r\n    uint256 winning_number = rng % total_user_eth;\r\n    // Require the winning number to fall within the winning Ticket's range of winning numbers.\r\n    require((winning_number >= tickets[winner].offset) && (winning_number < tickets[winner].offset + tickets[winner].value));\r\n    // Send the winner their winnings (i.e. 90% of ETH spent on tickets).\r\n    winner.transfer(total_user_eth * (100 - host_percentage) / 100);\r\n  }\r\n  \r\n  // Withdraw a user's ETH for them in the event the lottery is cancelled.\r\n  function withdraw(address user) {\r\n    // Only allow withdrawals if the lottery has been cancelled.\r\n    require(cancelled);\r\n    // Only allow withdrawals for users who have funds in the contract.\r\n    require(tickets[user].value != 0);\r\n    // Store the user's balance prior to withdrawal in a temporary variable.\r\n    uint256 eth_to_withdraw = tickets[user].value;\r\n    // Update the user's stored funds prior to transfer to prevent recursive call.\r\n    tickets[user].value = 0;\r\n    // Return the user's funds.  Throws on failure to prevent loss of funds.\r\n    user.transfer(eth_to_withdraw);\r\n  }\r\n  \r\n  // Default function, called when a user sends ETH to the contract.  Buys Tickets.\r\n  function () payable {\r\n    // Only allow Tickets to be purchased during the ticket buying phase.\r\n    require(now <= buy_end_time);\r\n    // Only allow one lottery Ticket per account.\r\n    require(tickets[msg.sender].value == 0);\r\n    // Set winning numbers offset to the first numbers not owned by anyone else.\r\n    tickets[msg.sender].offset = uint128(total_user_eth);\r\n    // Set the ticket value and range of winning numbers to the amount of ETH sent.\r\n    tickets[msg.sender].value = uint128(msg.value);\r\n    // Update the total amount of ETH spent on tickets.\r\n    total_user_eth += msg.value;\r\n    // Only allow tickets to be purchased up to the lottery's ETH cap.\r\n    require(total_user_eth <= total_user_eth_cap);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"total_user_eth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"num_hosts_revealed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"host\",\"type\":\"address\"},{\"name\":\"secret_random_number\",\"type\":\"uint256\"}],\"name\":\"steal_reveal\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"secret_random_number\",\"type\":\"uint256\"}],\"name\":\"host_reveal\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"host\",\"type\":\"address\"}],\"name\":\"host_claim_earnings\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"commit\",\"type\":\"bytes32\"}],\"name\":\"host_lottery\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tickets\",\"outputs\":[{\"name\":\"offset\",\"type\":\"uint128\"},{\"name\":\"value\",\"type\":\"uint128\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cancel_lottery\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"commits\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reveal_end_time\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"winner\",\"type\":\"address\"}],\"name\":\"claim_winnings\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cancelled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"host_percentage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"commit_end_time\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"total_user_eth_cap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buy_end_time\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"num_hosts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rng\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"payable\":true,\"type\":\"fallback\"}]","ContractName":"Lottery","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://a1e67973659afcbd07766866681bbd42084df7122b4a8668eefb3985bc14d65d"}]}