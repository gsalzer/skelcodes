{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.8;\r\n\r\n// https://github.com/ethereum/EIPs/issues/20\r\ncontract ERC20 {\r\n    function totalSupply() constant returns (uint totalSupply);\r\n    function balanceOf(address _owner) constant returns (uint balance);\r\n    function transfer(address _to, uint _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool success);\r\n    function approve(address _spender, uint _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint remaining);\r\n    function decimals() constant returns(uint digits);\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\n\r\n\r\n/// @title Kyber Reserve contract\r\n/// @author Yaron Velner\r\n\r\ncontract KyberReserve {\r\n    address public reserveOwner;\r\n    address public kyberNetwork;\r\n    ERC20 constant public ETH_TOKEN_ADDRESS = ERC20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\r\n    uint  constant PRECISION = (10**18);\r\n    bool public tradeEnabled;\r\n\r\n    struct ConversionRate {\r\n        uint rate;\r\n        uint expirationBlock;\r\n    }\r\n\r\n    mapping(bytes32=>ConversionRate) pairConversionRate;\r\n\r\n    /// @dev c'tor.\r\n    /// @param _kyberNetwork The address of kyber network\r\n    /// @param _reserveOwner Address of the reserve owner\r\n    function KyberReserve( address _kyberNetwork, address _reserveOwner ) {\r\n        kyberNetwork = _kyberNetwork;\r\n        reserveOwner = _reserveOwner;\r\n        tradeEnabled = true;\r\n    }\r\n\r\n\r\n    /// @dev check if a pair is listed for trading.\r\n    /// @param source Source token\r\n    /// @param dest Destination token\r\n    /// @param blockNumber Current block number\r\n    /// @return true iff pair is listed\r\n    function isPairListed( ERC20 source, ERC20 dest, uint blockNumber ) internal constant returns(bool) {\r\n        ConversionRate memory rateInfo = pairConversionRate[sha3(source,dest)];\r\n        if( rateInfo.rate == 0 ) return false;\r\n        return rateInfo.expirationBlock >= blockNumber;\r\n    }\r\n\r\n    /// @dev get current conversion rate\r\n    /// @param source Source token\r\n    /// @param dest Destination token\r\n    /// @param blockNumber Current block number\r\n    /// @return conversion rate with PRECISION precision\r\n\r\n    function getConversionRate( ERC20 source, ERC20 dest, uint blockNumber ) internal constant returns(uint) {\r\n        ConversionRate memory rateInfo = pairConversionRate[sha3(source,dest)];\r\n        if( rateInfo.rate == 0 ) return 0;\r\n        if( rateInfo.expirationBlock < blockNumber ) return 0;\r\n        return rateInfo.rate * (10 ** getDecimals(dest)) / (10**getDecimals(source));\r\n    }\r\n\r\n    event ErrorReport( address indexed origin, uint error, uint errorInfo );\r\n    event DoTrade( address indexed origin, address source, uint sourceAmount, address destToken, uint destAmount, address destAddress );\r\n\r\n    function getDecimals( ERC20 token ) constant returns(uint) {\r\n      if( token == ETH_TOKEN_ADDRESS ) return 18;\r\n      return token.decimals();\r\n    }\r\n\r\n    /// @dev do a trade\r\n    /// @param sourceToken Source token\r\n    /// @param sourceAmount Amount of source token\r\n    /// @param destToken Destination token\r\n    /// @param destAddress Destination address to send tokens to\r\n    /// @param validate If true, additional validations are applicable\r\n    /// @return true iff trade is succesful\r\n    function doTrade( ERC20 sourceToken,\r\n                      uint sourceAmount,\r\n                      ERC20 destToken,\r\n                      address destAddress,\r\n                      bool validate ) internal returns(bool) {\r\n\r\n        // can skip validation if done at kyber network level\r\n        if( validate ) {\r\n            if( ! isPairListed( sourceToken, destToken, block.number ) ) {\r\n                // pair is not listed\r\n                ErrorReport( tx.origin, 0x800000001, 0 );\r\n                return false;\r\n\r\n            }\r\n            if( sourceToken == ETH_TOKEN_ADDRESS ) {\r\n                if( msg.value != sourceAmount ) {\r\n                    // msg.value != sourceAmmount\r\n                    ErrorReport( tx.origin, 0x800000002, msg.value );\r\n                    return false;\r\n                }\r\n            }\r\n            else if( msg.value > 0 ) {\r\n                // msg.value must be 0\r\n                ErrorReport( tx.origin, 0x800000003, msg.value );\r\n                return false;\r\n            }\r\n            else if( sourceToken.allowance(msg.sender, this ) < sourceAmount ) {\r\n                // allowance is not enough\r\n                ErrorReport( tx.origin, 0x800000004, sourceToken.allowance(msg.sender, this ) );\r\n                return false;\r\n            }\r\n        }\r\n\r\n        uint conversionRate = getConversionRate( sourceToken, destToken, block.number );\r\n        // TODO - safe multiplication\r\n        uint destAmount = (conversionRate * sourceAmount) / PRECISION;\r\n\r\n        // sanity check\r\n        if( destAmount == 0 ) {\r\n            // unexpected error: dest amount is 0\r\n            ErrorReport( tx.origin, 0x800000005, 0 );\r\n            return false;\r\n        }\r\n\r\n        // check for sufficient balance\r\n        if( destToken == ETH_TOKEN_ADDRESS ) {\r\n            if( this.balance < destAmount ) {\r\n                // insufficient ether balance\r\n                ErrorReport( tx.origin, 0x800000006, destAmount );\r\n                return false;\r\n            }\r\n        }\r\n        else {\r\n            if( destToken.balanceOf(this) < destAmount ) {\r\n                // insufficient token balance\r\n                ErrorReport( tx.origin, 0x800000007, uint(destToken) );\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // collect source tokens\r\n        if( sourceToken != ETH_TOKEN_ADDRESS ) {\r\n            if( ! sourceToken.transferFrom(msg.sender,this,sourceAmount) ) {\r\n                // transfer from source token failed\r\n                ErrorReport( tx.origin, 0x800000008, uint(sourceToken) );\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // send dest tokens\r\n        if( destToken == ETH_TOKEN_ADDRESS ) {\r\n            if( ! destAddress.send(destAmount) ) {\r\n                // transfer ether to dest failed\r\n                ErrorReport( tx.origin, 0x800000009, uint(destAddress) );\r\n                return false;\r\n            }\r\n        }\r\n        else {\r\n            if( ! destToken.transfer(destAddress, destAmount) ) {\r\n                // transfer token to dest failed\r\n                ErrorReport( tx.origin, 0x80000000a, uint(destAddress) );\r\n                return false;\r\n            }\r\n        }\r\n\r\n        DoTrade( tx.origin, sourceToken, sourceAmount, destToken, destAmount, destAddress );\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev trade\r\n    /// @param sourceToken Source token\r\n    /// @param sourceAmount Amount of source token\r\n    /// @param destToken Destination token\r\n    /// @param destAddress Destination address to send tokens to\r\n    /// @param validate If true, additional validations are applicable\r\n    /// @return true iff trade is succesful\r\n    function trade( ERC20 sourceToken,\r\n                    uint sourceAmount,\r\n                    ERC20 destToken,\r\n                    address destAddress,\r\n                    bool validate ) payable returns(bool) {\r\n\r\n        if( ! tradeEnabled ) {\r\n            // trade is not enabled\r\n            ErrorReport( tx.origin, 0x810000000, 0 );\r\n            if( msg.value > 0 ) {\r\n                if( ! msg.sender.send(msg.value) ) throw;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        if( msg.sender != kyberNetwork ) {\r\n            // sender must be kyber network\r\n            ErrorReport( tx.origin, 0x810000001, uint(msg.sender) );\r\n            if( msg.value > 0 ) {\r\n                if( ! msg.sender.send(msg.value) ) throw;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        if( ! doTrade( sourceToken, sourceAmount, destToken, destAddress, validate ) ) {\r\n            // do trade failed\r\n            ErrorReport( tx.origin, 0x810000002, 0 );\r\n            if( msg.value > 0 ) {\r\n                if( ! msg.sender.send(msg.value) ) throw;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        ErrorReport( tx.origin, 0, 0 );\r\n        return true;\r\n    }\r\n\r\n    event SetRate( ERC20 source, ERC20 dest, uint rate, uint expiryBlock );\r\n\r\n    /// @notice can be called only by owner\r\n    /// @dev set rate of pair of tokens\r\n    /// @param sources an array contain source tokens\r\n    /// @param dests an array contain dest tokens\r\n    /// @param conversionRates an array with rates\r\n    /// @param expiryBlocks array of expiration blocks\r\n    /// @param validate If true, additional validations are applicable\r\n    /// @return true iff trade is succesful\r\n    function setRate( ERC20[] sources, ERC20[] dests, uint[] conversionRates, uint[] expiryBlocks, bool validate ) returns(bool) {\r\n        if( msg.sender != reserveOwner ) {\r\n            // sender must be reserve owner\r\n            ErrorReport( tx.origin, 0x820000000, uint(msg.sender) );\r\n            return false;\r\n        }\r\n\r\n        if( validate ) {\r\n            if( ( sources.length != dests.length ) ||\r\n                ( sources.length != conversionRates.length ) ||\r\n                ( sources.length != expiryBlocks.length ) ) {\r\n                // arrays length are not identical\r\n                ErrorReport( tx.origin, 0x820000001, 0 );\r\n                return false;\r\n            }\r\n        }\r\n\r\n        for( uint i = 0 ; i < sources.length ; i++ ) {\r\n            SetRate( sources[i], dests[i], conversionRates[i], expiryBlocks[i] );\r\n            pairConversionRate[sha3(sources[i],dests[i])] = ConversionRate( conversionRates[i], expiryBlocks[i] );\r\n        }\r\n\r\n        ErrorReport( tx.origin, 0, 0 );\r\n        return true;\r\n    }\r\n\r\n    event EnableTrade( bool enable );\r\n\r\n    /// @notice can be called only by owner\r\n    /// @dev enable of disable trade\r\n    /// @param enable if true trade is enabled, otherwise disabled\r\n    /// @return true iff trade is succesful\r\n    function enableTrade( bool enable ) returns(bool){\r\n        if( msg.sender != reserveOwner ) {\r\n            // sender must be reserve owner\r\n            ErrorReport( tx.origin, 0x830000000, uint(msg.sender) );\r\n            return false;\r\n        }\r\n\r\n        tradeEnabled = enable;\r\n        ErrorReport( tx.origin, 0, 0 );\r\n        EnableTrade( enable );\r\n\r\n        return true;\r\n    }\r\n\r\n    event DepositToken( ERC20 token, uint amount );\r\n    function() payable {\r\n        DepositToken( ETH_TOKEN_ADDRESS, msg.value );\r\n    }\r\n\r\n    /// @notice ether could also be deposited without calling this function\r\n    /// @dev an auxilary function that allows ether deposits\r\n    /// @return true iff deposit is succesful\r\n    function depositEther( ) payable returns(bool) {\r\n        ErrorReport( tx.origin, 0, 0 );\r\n\r\n        DepositToken( ETH_TOKEN_ADDRESS, msg.value );\r\n        return true;\r\n    }\r\n\r\n    /// @notice tokens could also be deposited without calling this function\r\n    /// @dev an auxilary function that allows token deposits\r\n    /// @param token Token address\r\n    /// @param amount Amount of tokens to deposit\r\n    /// @return true iff deposit is succesful\r\n    function depositToken( ERC20 token, uint amount ) returns(bool) {\r\n        if( token.allowance( msg.sender, this ) < amount ) {\r\n            // allowence is smaller then amount\r\n            ErrorReport( tx.origin, 0x850000001, token.allowance( msg.sender, this ) );\r\n            return false;\r\n        }\r\n\r\n        if( ! token.transferFrom(msg.sender, this, amount ) ) {\r\n            // transfer from failed\r\n            ErrorReport( tx.origin, 0x850000002, uint(token) );\r\n            return false;\r\n        }\r\n\r\n        DepositToken( token, amount );\r\n        return true;\r\n    }\r\n\r\n\r\n    event Withdraw( ERC20 token, uint amount, address destination );\r\n\r\n    /// @notice can only be called by owner.\r\n    /// @dev withdaw tokens or ether from contract\r\n    /// @param token Token address\r\n    /// @param amount Amount of tokens to deposit\r\n    /// @param destination address that get withdrewed funds\r\n    /// @return true iff withdrawal is succesful\r\n    function withdraw( ERC20 token, uint amount, address destination ) returns(bool) {\r\n        if( msg.sender != reserveOwner ) {\r\n            // sender must be reserve owner\r\n            ErrorReport( tx.origin, 0x860000000, uint(msg.sender) );\r\n            return false;\r\n        }\r\n\r\n        if( token == ETH_TOKEN_ADDRESS ) {\r\n            if( ! destination.send(amount) ) throw;\r\n        }\r\n        else if( ! token.transfer(destination,amount) ) {\r\n            // transfer to reserve owner failed\r\n            ErrorReport( tx.origin, 0x860000001, uint(token) );\r\n            return false;\r\n        }\r\n\r\n        ErrorReport( tx.origin, 0, 0 );\r\n        Withdraw( token, amount, destination );\r\n    }\r\n\r\n    function changeOwner( address newOwner ) {\r\n      if( msg.sender != reserveOwner ) throw;\r\n      reserveOwner = newOwner;\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    /// status functions ///////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////////////////////\r\n\r\n    /// @notice use token address ETH_TOKEN_ADDRESS for ether\r\n    /// @dev information on conversion rate from source to dest\r\n    /// @param source Source token\r\n    /// @param dest   Destinatoin token\r\n    /// @return (conversion rate,experation block,dest token balance of reserve)\r\n    function getPairInfo( ERC20 source, ERC20 dest ) constant returns(uint rate, uint expBlock, uint balance) {\r\n        ConversionRate memory rateInfo = pairConversionRate[sha3(source,dest)];\r\n        balance = 0;\r\n        if( dest == ETH_TOKEN_ADDRESS ) balance = this.balance;\r\n        else balance = dest.balanceOf(this);\r\n\r\n        expBlock = rateInfo.expirationBlock;\r\n        rate = rateInfo.rate;\r\n    }\r\n\r\n    /// @notice a debug function\r\n    /// @dev get the balance of the reserve\r\n    /// @param token The token type\r\n    /// @return The balance\r\n    function getBalance( ERC20 token ) constant returns(uint){\r\n        if( token == ETH_TOKEN_ADDRESS ) return this.balance;\r\n        else return token.balanceOf(this);\r\n    }\r\n}\r\n\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n/// @title Kyber Network main contract\r\n/// @author Yaron Velner\r\n\r\ncontract KyberNetwork {\r\n    address admin;\r\n    ERC20 constant public ETH_TOKEN_ADDRESS = ERC20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\r\n    uint  constant PRECISION = (10**18);\r\n    uint  constant EPSILON = (10);\r\n    KyberReserve[] public reserves;\r\n\r\n    mapping(address=>mapping(bytes32=>bool)) perReserveListedPairs;\r\n\r\n    event ErrorReport( address indexed origin, uint error, uint errorInfo );\r\n\r\n    /// @dev c'tor.\r\n    /// @param _admin The address of the administrator\r\n    function KyberNetwork( address _admin ) {\r\n        admin = _admin;\r\n    }\r\n\r\n\r\n    struct KyberReservePairInfo {\r\n        uint rate;\r\n        uint reserveBalance;\r\n        KyberReserve reserve;\r\n    }\r\n\r\n\r\n    /// @dev returns number of reserves\r\n    /// @return number of reserves\r\n    function getNumReserves() constant returns(uint){\r\n        return reserves.length;\r\n    }\r\n\r\n    /// @notice use token address ETH_TOKEN_ADDRESS for ether\r\n    /// @dev information on conversion rate from source to dest in specific reserve manager\r\n    /// @param source Source token\r\n    /// @param dest   Destinatoin token\r\n    /// @return (conversion rate,experation block,dest token balance of reserve)\r\n    function getRate( ERC20 source, ERC20 dest, uint reserveIndex ) constant returns(uint rate, uint expBlock, uint balance){\r\n        (rate,expBlock, balance) = reserves[reserveIndex].getPairInfo(source,dest);\r\n    }\r\n\r\n    /// @notice use token address ETH_TOKEN_ADDRESS for ether\r\n    /// @dev information on conversion rate to a front end application\r\n    /// @param source Source token\r\n    /// @param dest   Destinatoin token\r\n    /// @return rate. If not available returns 0.\r\n\r\n    function getPrice( ERC20 source, ERC20 dest ) constant returns(uint) {\r\n      uint rate; uint expBlock; uint balance;\r\n      (rate, expBlock, balance) = getRate( source, dest, 0 );\r\n      if( expBlock <= block.number ) return 0; // TODO - consider add 1\r\n      if( balance == 0 ) return 0; // TODO - decide on minimal qty\r\n      return rate;\r\n    }\r\n\r\n    function getDecimals( ERC20 token ) constant returns(uint) {\r\n      if( token == ETH_TOKEN_ADDRESS ) return 18;\r\n      return token.decimals();\r\n    }\r\n\r\n    /// @notice use token address ETH_TOKEN_ADDRESS for ether\r\n    /// @dev best conversion rate for a pair of tokens\r\n    /// @param source Source token\r\n    /// @param dest   Destinatoin token\r\n    /// @return KyberReservePairInfo structure\r\n    function findBestRate( ERC20 source, ERC20 dest ) internal constant returns(KyberReservePairInfo) {\r\n        uint bestRate;\r\n        uint bestReserveBalance = 0;\r\n        uint numReserves = reserves.length;\r\n\r\n        KyberReservePairInfo memory output;\r\n        KyberReserve bestReserve = KyberReserve(0);\r\n\r\n        for( uint i = 0 ; i < numReserves ; i++ ) {\r\n            var (rate,expBlock,balance) = reserves[i].getPairInfo(source,dest);\r\n\r\n            if( (expBlock >= block.number) && (balance > 0) && (rate > bestRate ) ) {\r\n                bestRate = rate;\r\n                bestReserveBalance = balance;\r\n                bestReserve = reserves[i];\r\n            }\r\n        }\r\n\r\n        output.rate = bestRate;\r\n        output.reserveBalance = bestReserveBalance;\r\n        output.reserve = bestReserve;\r\n\r\n        return output;\r\n    }\r\n\r\n\r\n    /// @notice use token address ETH_TOKEN_ADDRESS for ether\r\n    /// @dev do one trade with a reserve\r\n    /// @param source Source token\r\n    /// @param amount amount of source tokens\r\n    /// @param dest   Destinatoin token\r\n    /// @param destAddress Address to send tokens to\r\n    /// @param reserve Reserve to use\r\n    /// @param validate If true, additional validations are applicable\r\n    /// @return true if trade is succesful\r\n    function doSingleTrade( ERC20 source, uint amount,\r\n                            ERC20 dest, address destAddress,\r\n                            KyberReserve reserve,\r\n                            bool validate ) internal returns(bool) {\r\n\r\n        uint callValue = 0;\r\n        if( source == ETH_TOKEN_ADDRESS ) callValue = amount;\r\n        else {\r\n            // take source tokens to this contract\r\n            source.transferFrom(msg.sender, this, amount);\r\n\r\n            // let reserve use network tokens\r\n            source.approve( reserve, amount);\r\n        }\r\n\r\n        if( ! reserve.trade.value(callValue)(source, amount, dest, destAddress, validate ) ) {\r\n            if( source != ETH_TOKEN_ADDRESS ) {\r\n                // reset tokens for reserve\r\n                if( ! source.approve( reserve, 0) ) throw;\r\n\r\n                // send tokens back to sender\r\n                if( ! source.transfer(msg.sender, amount) ) throw;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        if( source != ETH_TOKEN_ADDRESS ) {\r\n            source.approve( reserve, 0);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @notice use token address ETH_TOKEN_ADDRESS for ether\r\n    /// @dev checks that user sent ether/tokens to contract before trade\r\n    /// @param source Source token\r\n    /// @param srcAmount amount of source tokens\r\n    /// @return true if input is valid\r\n    function validateTradeInput( ERC20 source, uint srcAmount ) constant internal returns(bool) {\r\n        if( source != ETH_TOKEN_ADDRESS && msg.value > 0 ) {\r\n            // shouldn't send ether for token exchange\r\n            ErrorReport( tx.origin, 0x85000000, 0 );\r\n            return false;\r\n        }\r\n        else if( source == ETH_TOKEN_ADDRESS && msg.value != srcAmount ) {\r\n            // amount of sent ether is wrong\r\n            ErrorReport( tx.origin, 0x85000001, msg.value );\r\n            return false;\r\n        }\r\n        else if( source != ETH_TOKEN_ADDRESS ) {\r\n            if( source.allowance(msg.sender,this) < srcAmount ) {\r\n                // insufficient allowane\r\n                ErrorReport( tx.origin, 0x85000002, msg.value );\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n    event Trade( address indexed sender, ERC20 source, ERC20 dest, uint actualSrcAmount, uint actualDestAmount );\r\n\r\n    struct ReserveTokenInfo {\r\n        uint rate;\r\n        KyberReserve reserve;\r\n        uint reserveBalance;\r\n    }\r\n\r\n    struct TradeInfo {\r\n        uint convertedDestAmount;\r\n        uint remainedSourceAmount;\r\n\r\n        bool tradeFailed;\r\n    }\r\n\r\n    /// @notice use token address ETH_TOKEN_ADDRESS for ether\r\n    /// @dev makes a trade between source and dest token and send dest token to\r\n    /// destAddress and record wallet id for later payment\r\n    /// @param source Source token\r\n    /// @param srcAmount amount of source tokens\r\n    /// @param dest   Destinatoin token\r\n    /// @param destAddress Address to send tokens to\r\n    /// @param maxDestAmount A limit on the amount of dest tokens\r\n    /// @param minConversionRate The minimal conversion rate. If actual rate is lower, trade is canceled.\r\n    /// @param throwOnFailure if true and trade is not completed, then function throws.\r\n    /// @return amount of actual dest tokens\r\n    function walletTrade( ERC20 source, uint srcAmount,\r\n                    ERC20 dest, address destAddress, uint maxDestAmount,\r\n                    uint minConversionRate,\r\n                    bool throwOnFailure,\r\n                    bytes32 walletId ) payable returns(uint) {\r\n       // TODO - log wallet id\r\n       return trade( source, srcAmount, dest, destAddress, maxDestAmount,\r\n                     minConversionRate, throwOnFailure );\r\n    }\r\n\r\n\r\n    function isNegligable( uint currentValue, uint originalValue ) constant returns(bool){\r\n      return (currentValue < (originalValue / 1000)) || (currentValue == 0);\r\n    }\r\n    /// @notice use token address ETH_TOKEN_ADDRESS for ether\r\n    /// @dev makes a trade between source and dest token and send dest token to destAddress\r\n    /// @param source Source token\r\n    /// @param srcAmount amount of source tokens\r\n    /// @param dest   Destinatoin token\r\n    /// @param destAddress Address to send tokens to\r\n    /// @param maxDestAmount A limit on the amount of dest tokens\r\n    /// @param minConversionRate The minimal conversion rate. If actual rate is lower, trade is canceled.\r\n    /// @param throwOnFailure if true and trade is not completed, then function throws.\r\n    /// @return amount of actual dest tokens\r\n    function trade( ERC20 source, uint srcAmount,\r\n                    ERC20 dest, address destAddress, uint maxDestAmount,\r\n                    uint minConversionRate,\r\n                    bool throwOnFailure ) payable returns(uint) {\r\n\r\n        if( ! validateTradeInput( source, srcAmount ) ) {\r\n            // invalid input\r\n            ErrorReport( tx.origin, 0x86000000, 0 );\r\n            if( msg.value > 0 ) {\r\n                if( ! msg.sender.send(msg.value) ) throw;\r\n            }\r\n            if( throwOnFailure ) throw;\r\n            return 0;\r\n        }\r\n\r\n        TradeInfo memory tradeInfo = TradeInfo(0,srcAmount,false);\r\n\r\n        while( !isNegligable(maxDestAmount-tradeInfo.convertedDestAmount, maxDestAmount)\r\n               && !isNegligable(tradeInfo.remainedSourceAmount, srcAmount)) {\r\n            KyberReservePairInfo memory reserveInfo = findBestRate(source,dest);\r\n\r\n            if( reserveInfo.rate == 0 || reserveInfo.rate < minConversionRate ) {\r\n                tradeInfo.tradeFailed = true;\r\n                // no more available funds\r\n                ErrorReport( tx.origin, 0x86000001, tradeInfo.remainedSourceAmount );\r\n                break;\r\n            }\r\n\r\n            reserveInfo.rate = (reserveInfo.rate * (10 ** getDecimals(dest))) /\r\n                                                      (10**getDecimals(source));\r\n\r\n            uint actualSrcAmount = tradeInfo.remainedSourceAmount;\r\n            // TODO - overflow check\r\n            uint actualDestAmount = (actualSrcAmount * reserveInfo.rate) / PRECISION;\r\n            if( actualDestAmount > reserveInfo.reserveBalance ) {\r\n                actualDestAmount = reserveInfo.reserveBalance;\r\n            }\r\n            if( actualDestAmount + tradeInfo.convertedDestAmount > maxDestAmount ) {\r\n                actualDestAmount = maxDestAmount - tradeInfo.convertedDestAmount;\r\n            }\r\n\r\n            // TODO - check overflow\r\n            actualSrcAmount = (actualDestAmount * PRECISION)/reserveInfo.rate;\r\n\r\n            // do actual trade\r\n            if( ! doSingleTrade( source,actualSrcAmount, dest, destAddress, reserveInfo.reserve, true ) ) {\r\n                tradeInfo.tradeFailed = true;\r\n                // trade failed in reserve\r\n                ErrorReport( tx.origin, 0x86000002, tradeInfo.remainedSourceAmount );\r\n                break;\r\n            }\r\n\r\n            // todo - check overflow\r\n            tradeInfo.remainedSourceAmount -= actualSrcAmount;\r\n            tradeInfo.convertedDestAmount += actualDestAmount;\r\n        }\r\n\r\n        if( tradeInfo.tradeFailed ) {\r\n            if( throwOnFailure ) throw;\r\n            if( msg.value > 0 ) {\r\n                if( ! msg.sender.send(msg.value) ) throw;\r\n            }\r\n\r\n            return 0;\r\n        }\r\n        else {\r\n            ErrorReport( tx.origin, 0, 0 );\r\n            if( tradeInfo.remainedSourceAmount > 0 && source == ETH_TOKEN_ADDRESS ) {\r\n                if( ! msg.sender.send(tradeInfo.remainedSourceAmount) ) throw;\r\n            }\r\n\r\n\r\n\r\n            ErrorReport( tx.origin, 0, 0 );\r\n            Trade( msg.sender, source, dest, srcAmount-tradeInfo.remainedSourceAmount, tradeInfo.convertedDestAmount );\r\n            return tradeInfo.convertedDestAmount;\r\n        }\r\n    }\r\n\r\n    event AddReserve( KyberReserve reserve, bool add );\r\n\r\n    /// @notice can be called only by admin\r\n    /// @dev add or deletes a reserve to/from the network.\r\n    /// @param reserve The reserve address.\r\n    /// @param add If true, the add reserve. Otherwise delete reserve.\r\n    function addReserve( KyberReserve reserve, bool add ) {\r\n        if( msg.sender != admin ) {\r\n            // only admin can add to reserve\r\n            ErrorReport( msg.sender, 0x87000000, 0 );\r\n            return;\r\n        }\r\n\r\n        if( add ) {\r\n            reserves.push(reserve);\r\n            AddReserve( reserve, true );\r\n        }\r\n        else {\r\n            // will have truble if more than 50k reserves...\r\n            for( uint i = 0 ; i < reserves.length ; i++ ) {\r\n                if( reserves[i] == reserve ) {\r\n                    if( reserves.length == 0 ) return;\r\n                    reserves[i] = reserves[--reserves.length];\r\n                    AddReserve( reserve, false );\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        ErrorReport( msg.sender, 0, 0 );\r\n    }\r\n\r\n    event ListPairsForReserve( address reserve, ERC20 source, ERC20 dest, bool add );\r\n\r\n    /// @notice can be called only by admin\r\n    /// @dev allow or prevent a specific reserve to trade a pair of tokens\r\n    /// @param reserve The reserve address.\r\n    /// @param source Source token\r\n    /// @param dest Destination token\r\n    /// @param add If true then enable trade, otherwise delist pair.\r\n    function listPairForReserve(address reserve, ERC20 source, ERC20 dest, bool add ) {\r\n        if( msg.sender != admin ) {\r\n            // only admin can add to reserve\r\n            ErrorReport( msg.sender, 0x88000000, 0 );\r\n            return;\r\n        }\r\n\r\n        (perReserveListedPairs[reserve])[sha3(source,dest)] = add;\r\n        ListPairsForReserve( reserve, source, dest, add );\r\n        ErrorReport( tx.origin, 0, 0 );\r\n    }\r\n\r\n    /// @notice can be called only by admin. still not implemented\r\n    /// @dev upgrade network to a new contract\r\n    /// @param newAddress The address of the new network\r\n    function upgrade( address newAddress ) {\r\n        // TODO\r\n        newAddress; // unused warning\r\n        throw;\r\n    }\r\n\r\n    /// @notice should be called off chain with as much gas as needed\r\n    /// @dev get an array of all reserves\r\n    /// @return An array of all reserves\r\n    function getReserves( ) constant returns(KyberReserve[]) {\r\n        return reserves;\r\n    }\r\n\r\n\r\n    /// @notice a debug function\r\n    /// @dev get the balance of the network. It is expected to be 0 all the time.\r\n    /// @param token The token type\r\n    /// @return The balance\r\n    function getBalance( ERC20 token ) constant returns(uint){\r\n        if( token == ETH_TOKEN_ADDRESS ) return this.balance;\r\n        else return token.balanceOf(this);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"reserve\",\"type\":\"address\"},{\"name\":\"source\",\"type\":\"address\"},{\"name\":\"dest\",\"type\":\"address\"},{\"name\":\"add\",\"type\":\"bool\"}],\"name\":\"listPairForReserve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"upgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getReserves\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETH_TOKEN_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"currentValue\",\"type\":\"uint256\"},{\"name\":\"originalValue\",\"type\":\"uint256\"}],\"name\":\"isNegligable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"reserves\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"source\",\"type\":\"address\"},{\"name\":\"srcAmount\",\"type\":\"uint256\"},{\"name\":\"dest\",\"type\":\"address\"},{\"name\":\"destAddress\",\"type\":\"address\"},{\"name\":\"maxDestAmount\",\"type\":\"uint256\"},{\"name\":\"minConversionRate\",\"type\":\"uint256\"},{\"name\":\"throwOnFailure\",\"type\":\"bool\"}],\"name\":\"trade\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"reserve\",\"type\":\"address\"},{\"name\":\"add\",\"type\":\"bool\"}],\"name\":\"addReserve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"source\",\"type\":\"address\"},{\"name\":\"dest\",\"type\":\"address\"}],\"name\":\"getPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getDecimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumReserves\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"source\",\"type\":\"address\"},{\"name\":\"dest\",\"type\":\"address\"},{\"name\":\"reserveIndex\",\"type\":\"uint256\"}],\"name\":\"getRate\",\"outputs\":[{\"name\":\"rate\",\"type\":\"uint256\"},{\"name\":\"expBlock\",\"type\":\"uint256\"},{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"source\",\"type\":\"address\"},{\"name\":\"srcAmount\",\"type\":\"uint256\"},{\"name\":\"dest\",\"type\":\"address\"},{\"name\":\"destAddress\",\"type\":\"address\"},{\"name\":\"maxDestAmount\",\"type\":\"uint256\"},{\"name\":\"minConversionRate\",\"type\":\"uint256\"},{\"name\":\"throwOnFailure\",\"type\":\"bool\"},{\"name\":\"walletId\",\"type\":\"bytes32\"}],\"name\":\"walletTrade\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"origin\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"error\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"errorInfo\",\"type\":\"uint256\"}],\"name\":\"ErrorReport\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"source\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"dest\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"actualSrcAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"actualDestAmount\",\"type\":\"uint256\"}],\"name\":\"Trade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"reserve\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"add\",\"type\":\"bool\"}],\"name\":\"AddReserve\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"reserve\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"source\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"dest\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"add\",\"type\":\"bool\"}],\"name\":\"ListPairsForReserve\",\"type\":\"event\"}]","ContractName":"KyberNetwork","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000346fbe5d02c89fb4599f33bdce987981d573740a","Library":"","SwarmSource":"bzzr://b937ac6d8cec2ad9bf347f5f5407661565af376e3c3ca7353f11b4163ebcaa2f"}]}