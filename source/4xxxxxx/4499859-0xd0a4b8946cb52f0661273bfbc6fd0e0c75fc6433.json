{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\ncontract ItokenRecipient {\r\n  function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData);\r\n}\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract Owned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    function Owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != owner);\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = 0x0;\r\n    }\r\n\r\n    event OwnerUpdate(address _prevOwner, address _newOwner);\r\n}\r\n\r\ncontract IERC20Token {\r\n  function totalSupply() constant returns (uint256 totalSupply);\r\n  function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n  function transfer(address _to, uint256 _value) returns (bool success) {}\r\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n  function approve(address _spender, uint256 _value) returns (bool success) {}\r\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract Token is IERC20Token, Owned {\r\n\r\n  using SafeMath for uint256;\r\n\r\n  /* Public variables of the token */\r\n  string public standard;\r\n  string public name;\r\n  string public symbol;\r\n  uint8 public decimals;\r\n\r\n  address public crowdsaleContractAddress;\r\n\r\n  /* Private variables of the token */\r\n  uint256 supply = 0;\r\n  mapping (address => uint256) balances;\r\n  mapping (address => mapping (address => uint256)) allowances;\r\n\r\n  /* Events */\r\n  event Mint(address indexed _to, uint256 _value);\r\n\r\n  // validates address is the crowdsale owner\r\n  modifier onlyCrowdsaleOwner() {\r\n      require(msg.sender == crowdsaleContractAddress);\r\n      _;\r\n  }\r\n\r\n  /* Returns total supply of issued tokens */\r\n  function totalSupply() constant returns (uint256) {\r\n    return supply;\r\n  }\r\n\r\n  /* Returns balance of address */\r\n  function balanceOf(address _owner) constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  /* Transfers tokens from your address to other */\r\n  function transfer(address _to, uint256 _value) returns (bool success) {\r\n    require(_to != 0x0 && _to != address(this));\r\n    balances[msg.sender] = balances[msg.sender].sub(_value); // Deduct senders balance\r\n    balances[_to] = balances[_to].add(_value);               // Add recivers blaance\r\n    Transfer(msg.sender, _to, _value);                       // Raise Transfer event\r\n    return true;\r\n  }\r\n\r\n  /* Approve other address to spend tokens on your account */\r\n  function approve(address _spender, uint256 _value) returns (bool success) {\r\n    allowances[msg.sender][_spender] = _value;        // Set allowance\r\n    Approval(msg.sender, _spender, _value);           // Raise Approval event\r\n    return true;\r\n  }\r\n\r\n  /* Approve and then communicate the approved contract in a single tx */\r\n  function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n    ItokenRecipient spender = ItokenRecipient(_spender);            // Cast spender to tokenRecipient contract\r\n    approve(_spender, _value);                                      // Set approval to contract for _value\r\n    spender.receiveApproval(msg.sender, _value, this, _extraData);  // Raise method on _spender contract\r\n    return true;\r\n  }\r\n\r\n  /* A contract attempts to get the coins */\r\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n    require(_to != 0x0 && _to != address(this));\r\n    balances[_from] = balances[_from].sub(_value);                              // Deduct senders balance\r\n    balances[_to] = balances[_to].add(_value);                                  // Add recipient blaance\r\n    allowances[_from][msg.sender] = allowances[_from][msg.sender].sub(_value);  // Deduct allowance for this address\r\n    Transfer(_from, _to, _value);                                               // Raise Transfer event\r\n    return true;\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n    return allowances[_owner][_spender];\r\n  }\r\n\r\n  function mintTokens(address _to, uint256 _amount) onlyCrowdsaleOwner {\r\n    supply = supply.add(_amount);\r\n    balances[_to] = balances[_to].add(_amount);\r\n    Mint(_to, _amount);\r\n    Transfer(msg.sender, _to, _amount);\r\n  }\r\n\r\n  function salvageTokensFromContract(address _tokenAddress, address _to, uint _amount) onlyOwner {\r\n    IERC20Token(_tokenAddress).transfer(_to, _amount);\r\n  }\r\n}\r\n\r\ncontract StormToken is Token {\r\n\r\n\tbool public transfersEnabled = false;    // true if transfer/transferFrom are enabled, false if not\r\n\r\n\t// triggered when the total supply is increased\r\n\tevent Issuance(uint256 _amount);\r\n\t// triggered when the total supply is decreased\r\n\tevent Destruction(uint256 _amount);\r\n\r\n\r\n  /* Initializes contract */\r\n  function StormToken(address _crowdsaleAddress) public {\r\n    standard = \"Storm Token v1.0\";\r\n    name = \"Storm Token\";\r\n    symbol = \"STORM\"; // token symbol\r\n    decimals = 18;\r\n    crowdsaleContractAddress = _crowdsaleAddress;\r\n  }\r\n\r\n    // validates an address - currently only checks that it isn't null\r\n    modifier validAddress(address _address) {\r\n        require(_address != 0x0);\r\n        _;\r\n    }\r\n\r\n    // verifies that the address is different than this contract address\r\n    modifier notThis(address _address) {\r\n        require(_address != address(this));\r\n        _;\r\n    }\r\n\r\n    // allows execution only when transfers aren't disabled\r\n    modifier transfersAllowed {\r\n        assert(transfersEnabled);\r\n        _;\r\n    }\r\n\r\n   /**\r\n        @dev disables/enables transfers\r\n        can only be called by the contract owner\r\n\r\n        @param _disable    true to disable transfers, false to enable them\r\n    */\r\n    function disableTransfers(bool _disable) public onlyOwner {\r\n        transfersEnabled = !_disable;\r\n    }\r\n\r\n    /**\r\n        @dev increases the token supply and sends the new tokens to an account\r\n        can only be called by the contract owner\r\n\r\n        @param _to         account to receive the new amount\r\n        @param _amount     amount to increase the supply by\r\n    */\r\n    function issue(address _to, uint256 _amount)\r\n        public\r\n        onlyOwner\r\n        validAddress(_to)\r\n        notThis(_to)\r\n    {\r\n        supply = supply.add(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n\r\n        Issuance(_amount);\r\n        Transfer(this, _to, _amount);\r\n    }\r\n\r\n    /**\r\n        @dev removes tokens from an account and decreases the token supply\r\n        can be called by the contract owner to destroy tokens from any account or by any holder to destroy tokens from his/her own account\r\n\r\n        @param _from       account to remove the amount from\r\n        @param _amount     amount to decrease the supply by\r\n    */\r\n    function destroy(address _from, uint256 _amount) public {\r\n        require(msg.sender == _from || msg.sender == owner); // validate input\r\n\r\n        balances[_from] = balances[_from].sub(_amount);\r\n        supply = supply.sub(_amount);\r\n\r\n        Transfer(_from, this, _amount);\r\n        Destruction(_amount);\r\n    }\r\n\r\n    // ERC20 standard method overrides with some extra functionality\r\n\r\n    /**\r\n        @dev send coins\r\n        throws on any error rather then return a false flag to minimize user errors\r\n        in addition to the standard checks, the function throws if transfers are disabled\r\n\r\n        @param _to      target address\r\n        @param _value   transfer amount\r\n\r\n        @return true if the transfer was successful, false if it wasn't\r\n    */\r\n    function transfer(address _to, uint256 _value) public transfersAllowed returns (bool success) {\r\n        assert(super.transfer(_to, _value));\r\n        return true;\r\n    }\r\n  \r\n    function transfers(address[] _recipients, uint256[] _values) public transfersAllowed onlyOwner returns (bool success) {\r\n        require(_recipients.length == _values.length); // Check if input data is correct\r\n\r\n        for (uint cnt = 0; cnt < _recipients.length; cnt++) {\r\n            assert(super.transfer(_recipients[cnt], _values[cnt]));\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n        @dev an account/contract attempts to get the coins\r\n        throws on any error rather then return a false flag to minimize user errors\r\n        in addition to the standard checks, the function throws if transfers are disabled\r\n\r\n        @param _from    source address\r\n        @param _to      target address\r\n        @param _value   transfer amount\r\n\r\n        @return true if the transfer was successful, false if it wasn't\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _value) public transfersAllowed returns (bool success) {\r\n        assert(super.transferFrom(_from, _to, _value));\r\n        return true;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_disable\",\"type\":\"bool\"}],\"name\":\"disableTransfers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipients\",\"type\":\"address[]\"},{\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"transfers\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"standard\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"issue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleContractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"salvageTokensFromContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transfersEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mintTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_crowdsaleAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Issuance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Destruction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_prevOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"StormToken","CompilerVersion":"v0.4.19-nightly.2017.11.11+commit.284c3839","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000c88c7e1aebd89187d13bd42e1ff814d32f492bf6","Library":"","SwarmSource":"bzzr://2b424472ad171d122a55f8b481c05231ea661e11ceab650924712502f94c900b"}]}