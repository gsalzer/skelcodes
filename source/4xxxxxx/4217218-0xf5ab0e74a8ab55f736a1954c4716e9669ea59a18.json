{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.15;\r\n\r\n/**\r\n * Basic interface for contracts, following ERC20 standard\r\n */\r\ncontract ERC20Token {\r\n    \r\n\r\n    /**\r\n     * Triggered when tokens are transferred.\r\n     * @param from - address tokens were transfered from\r\n     * @param to - address tokens were transfered to\r\n     * @param value - amount of tokens transfered\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * Triggered whenever allowance status changes\r\n     * @param owner - tokens owner, allowance changed for\r\n     * @param spender - tokens spender, allowance changed for\r\n     * @param value - new allowance value (overwriting the old value)\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * Returns total supply of tokens ever emitted\r\n     * @return totalSupply - total supply of tokens ever emitted\r\n     */\r\n    function totalSupply() constant returns (uint256 totalSupply);\r\n\r\n    /**\r\n     * Returns `owner` balance of tokens\r\n     * @param owner address to request balance for\r\n     * @return balance - token balance of `owner`\r\n     */\r\n    function balanceOf(address owner) constant returns (uint256 balance);\r\n\r\n    /**\r\n     * Transfers `amount` of tokens to `to` address\r\n     * @param  to - address to transfer to\r\n     * @param  value - amount of tokens to transfer\r\n     * @return success - `true` if the transfer was succesful, `false` otherwise\r\n     */\r\n    function transfer(address to, uint256 value) returns (bool success);\r\n\r\n    /**\r\n     * Transfers `value` tokens from `from` address to `to`\r\n     * the sender needs to have allowance for this operation\r\n     * @param  from - address to take tokens from\r\n     * @param  to - address to send tokens to\r\n     * @param  value - amount of tokens to send\r\n     * @return success - `true` if the transfer was succesful, `false` otherwise\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) returns (bool success);\r\n\r\n    /**\r\n     * Allow spender to withdraw from your account, multiple times, up to the value amount.\r\n     * If this function is called again it overwrites the current allowance with `value`.\r\n     * this function is required for some DEX functionality\r\n     * @param spender - address to give allowance to\r\n     * @param value - the maximum amount of tokens allowed for spending\r\n     * @return success - `true` if the allowance was given, `false` otherwise\r\n     */\r\n    function approve(address spender, uint256 value) returns (bool success);\r\n\r\n    /**\r\n     * Returns the amount which `spender` is still allowed to withdraw from `owner`\r\n     * @param  owner - tokens owner\r\n     * @param  spender - addres to request allowance for\r\n     * @return remaining - remaining allowance (token count)\r\n     */\r\n    function allowance(address owner, address spender) constant returns (uint256 remaining);\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Token Holder\r\n * Given a ERC20 compatible Token allows holding for a certain amount of time\r\n * after that time, the beneficiar can acquire his Tokens\r\n */\r\n contract TokenHolder {\r\n    \r\n    \r\n    \r\n\r\n    uint256 constant MIN_TOKENS_TO_HOLD = 1000;\r\n\r\n    /**\r\n     * A single token deposit for a certain amount of time for a certain beneficiar\r\n     */\r\n    struct TokenDeposit {\r\n        uint256 tokens;\r\n        uint256 releaseTime;\r\n    }\r\n\r\n    /** Emited when Tokens where put on hold\r\n     * @param tokens - amount of Tokens\r\n     * @param beneficiar - the address that will be able to claim Tokens in the future\r\n     * @param depositor - the address deposited tokens\r\n     * @param releaseTime - timestamp of a moment which `beneficiar` would be able to claim Tokens after\r\n     */\r\n    event Deposited(address indexed depositor, address indexed beneficiar, uint256 tokens, uint256 releaseTime);\r\n\r\n    /** Emited when Tokens where claimed back\r\n     * @param tokens - amount of Tokens claimed\r\n     * @param beneficiar - who claimed the Tokens\r\n     */\r\n    event Claimed(address indexed beneficiar, uint256 tokens);\r\n\r\n    /** all the deposits made */\r\n    mapping(address => TokenDeposit[]) deposits;\r\n\r\n    /** Tokens contract instance */\r\n    ERC20Token public tokenContract;\r\n\r\n    /**\r\n     * Creates the Token Holder with the specifief `ERC20` Token Contract instance\r\n     * @param _tokenContract `ERC20` Token Contract instance to use\r\n     */\r\n    function TokenHolder (address _tokenContract)   {  \r\n        tokenContract = ERC20Token(_tokenContract);\r\n    }\r\n\r\n    /**\r\n     * Puts some amount of Tokens on hold to be retrieved later\r\n     * @param  tokenCount - amount of tokens\r\n     * @param  tokenBeneficiar - will be able to retrieve tokens in the future\r\n     * @param  depositTime - time to hold in seconds\r\n     */\r\n    function depositTokens (uint256 tokenCount, address tokenBeneficiar, uint256 depositTime)   {  \r\n        require(tokenCount >= MIN_TOKENS_TO_HOLD);\r\n        require(tokenContract.allowance(msg.sender, address(this)) >= tokenCount);\r\n\r\n        if(tokenContract.transferFrom(msg.sender, address(this), tokenCount)) {\r\n            deposits[tokenBeneficiar].push(TokenDeposit(tokenCount, now + depositTime));\r\n            Deposited(msg.sender, tokenBeneficiar, tokenCount, now + depositTime);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the amount of deposits for `beneficiar`\r\n     */\r\n    function getDepositCount (address beneficiar)   constant   returns (uint count) {  \r\n        return deposits[beneficiar].length;\r\n    }\r\n\r\n    /**\r\n     * returns the `idx` deposit for `beneficiar`\r\n     */\r\n    function getDeposit (address beneficiar, uint idx)   constant   returns (uint256 deposit_dot_tokens, uint256 deposit_dot_releaseTime) {  \r\nTokenDeposit memory deposit;\r\n\r\n        require(idx < deposits[beneficiar].length);\r\n        deposit = deposits[beneficiar][idx];\r\n    deposit_dot_tokens = uint256(deposit.tokens);\r\ndeposit_dot_releaseTime = uint256(deposit.releaseTime);}\r\n\r\n    /**\r\n     * Transfers all the Tokens already unlocked to `msg.sender`\r\n     */\r\n    function claimAllTokens ()   {  \r\n        uint256 toPay = 0;\r\n\r\n        TokenDeposit[] storage myDeposits = deposits[msg.sender];\r\n\r\n        uint idx = 0;\r\n        while(true) {\r\n            if(idx >= myDeposits.length) { break; }\r\n            if(now > myDeposits[idx].releaseTime) {\r\n                toPay += myDeposits[idx].tokens;\r\n                myDeposits[idx] = myDeposits[myDeposits.length - 1];\r\n                myDeposits.length--;\r\n            } else {\r\n                idx++;\r\n            }\r\n        }\r\n\r\n        if(toPay > 0) {\r\n            tokenContract.transfer(msg.sender, toPay);\r\n            Claimed(msg.sender, toPay);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"tokenCount\",\"type\":\"uint256\"},{\"name\":\"tokenBeneficiar\",\"type\":\"address\"},{\"name\":\"depositTime\",\"type\":\"uint256\"}],\"name\":\"depositTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"beneficiar\",\"type\":\"address\"}],\"name\":\"getDepositCount\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimAllTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"beneficiar\",\"type\":\"address\"},{\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"getDeposit\",\"outputs\":[{\"name\":\"deposit_dot_tokens\",\"type\":\"uint256\"},{\"name\":\"deposit_dot_releaseTime\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"depositor\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiar\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"releaseTime\",\"type\":\"uint256\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiar\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"}]","ContractName":"TokenHolder","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000d96f07627a7c05771eb89e00aecb9346c1e9759a","Library":"","SwarmSource":"bzzr://2b5879c6a5e1cd3e9157440639650b36416dfaaf6fee52f6335de0692e98a513"}]}