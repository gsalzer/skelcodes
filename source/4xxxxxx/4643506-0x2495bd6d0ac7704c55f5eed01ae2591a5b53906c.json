{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n\r\n  Copyright 2017 Cofound.it.\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n\r\n*/\r\n\r\npragma solidity ^0.4.13;\r\n\r\ncontract ReentrancyHandlingContract {\r\n\r\n    bool locked;\r\n\r\n    modifier noReentrancy() {\r\n        require(!locked);\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n}\r\ncontract Owned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    function Owned() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != owner);\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = 0x0;\r\n    }\r\n\r\n    event OwnerUpdate(address _prevOwner, address _newOwner);\r\n}\r\ncontract PriorityPassInterface {\r\n    function getAccountLimit(address _accountAddress) public constant returns (uint);\r\n    function getAccountActivity(address _accountAddress) public constant returns (bool);\r\n}\r\ncontract ERC20TokenInterface {\r\n  function totalSupply() public constant returns (uint256 _totalSupply);\r\n  function balanceOf(address _owner) public constant returns (uint256 balance);\r\n  function transfer(address _to, uint256 _value) public returns (bool success);\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n  function approve(address _spender, uint256 _value) public returns (bool success);\r\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract SeedCrowdsaleContract is ReentrancyHandlingContract, Owned {\r\n\r\n  struct ContributorData {\r\n    uint contributionAmount;\r\n  }\r\n\r\n  mapping(address => ContributorData) public contributorList;\r\n  uint public nextContributorIndex;\r\n  mapping(uint => address) public contributorIndexes;\r\n\r\n  state public crowdsaleState = state.pendingStart;\r\n  enum state { pendingStart, priorityPass, openedPriorityPass, crowdsaleEnded }\r\n\r\n  uint public presaleStartTime;\r\n  uint public presaleUnlimitedStartTime;\r\n  uint public crowdsaleEndedTime;\r\n\r\n  event PresaleStarted(uint blocktime);\r\n  event PresaleUnlimitedStarted(uint blocktime);\r\n  event CrowdsaleEnded(uint blocktime);\r\n  event ErrorSendingETH(address to, uint amount);\r\n  event MinCapReached(uint blocktime);\r\n  event MaxCapReached(uint blocktime);\r\n  event ContributionMade(address indexed contributor, uint amount);\r\n\r\n  PriorityPassInterface priorityPassContract = PriorityPassInterface(0x0);\r\n\r\n  uint public minCap;\r\n  uint public maxP1Cap;\r\n  uint public maxCap;\r\n  uint public ethRaised;\r\n\r\n  address public multisigAddress;\r\n\r\n  uint nextContributorToClaim;\r\n  mapping(address => bool) hasClaimedEthWhenFail;\r\n\r\n  //\r\n  // Unnamed function that runs when eth is sent to the contract\r\n  // @payable\r\n  //\r\n  function() noReentrancy payable public {\r\n    require(msg.value != 0);                                                    // Throw if value is 0\r\n    require(crowdsaleState != state.crowdsaleEnded);                            // Check if crowdsale has ended\r\n\r\n    bool stateChanged = checkCrowdsaleState();                                  // Check blocks time and calibrate crowdsale state\r\n\r\n    if (crowdsaleState == state.priorityPass) {\r\n      if (priorityPassContract.getAccountActivity(msg.sender)) {                // Check if contributor is in priorityPass\r\n        processTransaction(msg.sender, msg.value);                              // Process transaction and issue tokens\r\n      } else {\r\n        refundTransaction(stateChanged);                                        // Set state and return funds or throw\r\n      }\r\n    } else if (crowdsaleState == state.openedPriorityPass) {\r\n      if (priorityPassContract.getAccountActivity(msg.sender)) {                // Check if contributor is in priorityPass\r\n        processTransaction(msg.sender, msg.value);                              // Process transaction and issue tokens\r\n      } else {\r\n        refundTransaction(stateChanged);                                        // Set state and return funds or throw\r\n      }\r\n    } else {\r\n      refundTransaction(stateChanged);                                          // Set state and return funds or throw\r\n    }\r\n  }\r\n\r\n  //\r\n  // @internal checks crowdsale state and emits events it\r\n  // @returns boolean\r\n  //\r\n  function checkCrowdsaleState() internal returns (bool) {\r\n    if (ethRaised == maxCap && crowdsaleState != state.crowdsaleEnded) {        // Check if max cap is reached\r\n      crowdsaleState = state.crowdsaleEnded;\r\n      MaxCapReached(block.timestamp);                                           // Close the crowdsale\r\n      CrowdsaleEnded(block.timestamp);                                          // Raise event\r\n      return true;\r\n    }\r\n\r\n    if (block.timestamp > presaleStartTime && block.timestamp <= presaleUnlimitedStartTime) { // Check if we are in presale phase\r\n      if (crowdsaleState != state.priorityPass) {                               // Check if state needs to be changed\r\n        crowdsaleState = state.priorityPass;                                    // Set new state\r\n        PresaleStarted(block.timestamp);                                        // Raise event\r\n        return true;\r\n      }\r\n    } else if (block.timestamp > presaleUnlimitedStartTime && block.timestamp <= crowdsaleEndedTime) {  // Check if we are in presale unlimited phase\r\n      if (crowdsaleState != state.openedPriorityPass) {                         // Check if state needs to be changed\r\n        crowdsaleState = state.openedPriorityPass;                              // Set new state\r\n        PresaleUnlimitedStarted(block.timestamp);                               // Raise event\r\n        return true;\r\n      }\r\n    } else {\r\n      if (crowdsaleState != state.crowdsaleEnded && block.timestamp > crowdsaleEndedTime) {// Check if crowdsale is over\r\n        crowdsaleState = state.crowdsaleEnded;                                  // Set new state\r\n        CrowdsaleEnded(block.timestamp);                                        // Raise event\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  //\r\n  // @internal determines if return eth or throw according to changing state\r\n  // @param _stateChanged boolean message about state change\r\n  //\r\n  function refundTransaction(bool _stateChanged) internal {\r\n    if (_stateChanged) {\r\n      msg.sender.transfer(msg.value);\r\n    } else {\r\n      revert();\r\n    }\r\n  }\r\n\r\n  //\r\n  // Getter to calculate how much user can contribute\r\n  // @param _contributor address of the contributor\r\n  //\r\n  function calculateMaxContribution(address _contributor) constant public returns (uint maxContribution) {\r\n    uint maxContrib;\r\n\r\n    if (crowdsaleState == state.priorityPass) {                                 // Check if we are in priority pass\r\n      maxContrib = priorityPassContract.getAccountLimit(_contributor) - contributorList[_contributor].contributionAmount;\r\n\r\n\t    if (maxContrib > (maxP1Cap - ethRaised)) {                                // Check if max contribution is more that max cap\r\n        maxContrib = maxP1Cap - ethRaised;                                      // Alter max cap\r\n      }\r\n\r\n    } else {\r\n      maxContrib = maxCap - ethRaised;                                          // Alter max cap\r\n    }\r\n    return maxContrib;\r\n  }\r\n\r\n  //\r\n  // Return if there is overflow of contributed eth\r\n  // @internal processes transactions\r\n  // @param _contributor address of an contributor\r\n  // @param _amount contributed amount\r\n  //\r\n  function processTransaction(address _contributor, uint _amount) internal {\r\n    uint maxContribution = calculateMaxContribution(_contributor);              // Calculate max users contribution\r\n    uint contributionAmount = _amount;\r\n    uint returnAmount = 0;\r\n\r\n\t  if (maxContribution < _amount) {                                            // Check if max contribution is lower than _amount sent\r\n      contributionAmount = maxContribution;                                     // Set that user contributes his maximum alowed contribution\r\n      returnAmount = _amount - maxContribution;                                 // Calculate how much he must get back\r\n    }\r\n\r\n    if (ethRaised + contributionAmount >= minCap && minCap > ethRaised) {\r\n      MinCapReached(block.timestamp);\r\n    } \r\n\r\n    if (contributorList[_contributor].contributionAmount == 0) {                // Check if contributor has already contributed\r\n      contributorList[_contributor].contributionAmount = contributionAmount;    // Set their contribution\r\n      contributorIndexes[nextContributorIndex] = _contributor;                  // Set contributors index\r\n      nextContributorIndex++;\r\n    } else {\r\n      contributorList[_contributor].contributionAmount += contributionAmount;   // Add contribution amount to existing contributor\r\n    }\r\n    ethRaised += contributionAmount;                                            // Add to eth raised\r\n\r\n    ContributionMade(msg.sender, contributionAmount);                           // Raise event about contribution\r\n\r\n\t  if (returnAmount != 0) {\r\n      _contributor.transfer(returnAmount);                                      // Return overflow of ether\r\n    } \r\n  }\r\n\r\n  //\r\n  // Recovers ERC20 tokens other than eth that are send to this address\r\n  // @owner refunds the erc20 tokens\r\n  // @param _tokenAddress address of the erc20 token\r\n  // @param _to address to where tokens should be send to\r\n  // @param _amount amount of tokens to refund\r\n  //\r\n  function salvageTokensFromContract(address _tokenAddress, address _to, uint _amount) onlyOwner public {\r\n    ERC20TokenInterface(_tokenAddress).transfer(_to, _amount);\r\n  }\r\n\r\n  //\r\n  // withdrawEth when minimum cap is reached\r\n  // @owner sets contributions to withdraw\r\n  //\r\n  function withdrawEth() onlyOwner public {\r\n    require(this.balance != 0);\r\n    require(ethRaised >= minCap);\r\n\r\n    pendingEthWithdrawal = this.balance;\r\n  }\r\n\r\n\r\n  uint public pendingEthWithdrawal;\r\n  //\r\n  // pulls the funds that were set to send with calling of\r\n  // withdrawEth when minimum cap is reached\r\n  // @multisig pulls the contributions to self\r\n  //\r\n  function pullBalance() public {\r\n    require(msg.sender == multisigAddress);\r\n    require(pendingEthWithdrawal > 0);\r\n\r\n    multisigAddress.transfer(pendingEthWithdrawal);\r\n    pendingEthWithdrawal = 0;\r\n  }\r\n\r\n  //\r\n  // Owner can batch return contributors contributions(eth)\r\n  // @owner returns contributions\r\n  // @param _numberOfReturns number of returns to do in one transaction\r\n  //\r\n  function batchReturnEthIfFailed(uint _numberOfReturns) onlyOwner public {\r\n    require(block.timestamp > crowdsaleEndedTime && ethRaised < minCap);        // Check if crowdsale has failed\r\n\r\n    address currentParticipantAddress;\r\n    uint contribution;\r\n\r\n    for (uint cnt = 0; cnt < _numberOfReturns; cnt++) {\r\n      currentParticipantAddress = contributorIndexes[nextContributorToClaim];   // Get next unclaimed participant\r\n\r\n      if (currentParticipantAddress == 0x0) {\r\n         return;                                                                // Check if all the participants were compensated\r\n      }\r\n\r\n      if (!hasClaimedEthWhenFail[currentParticipantAddress]) {                  // Check if participant has already claimed\r\n        contribution = contributorList[currentParticipantAddress].contributionAmount; // Get contribution of participant\r\n        hasClaimedEthWhenFail[currentParticipantAddress] = true;                // Set that he has claimed\r\n\r\n        if (!currentParticipantAddress.send(contribution)) {                    // Refund eth\r\n          ErrorSendingETH(currentParticipantAddress, contribution);             // If there is an issue raise event for manual recovery\r\n        }\r\n      }\r\n      nextContributorToClaim += 1;                                              // Repeat\r\n    }\r\n  }\r\n\r\n  //\r\n  // If there were any issue with refund owner can withdraw eth at the end for manual recovery\r\n  // @owner withdraws remaining funds\r\n  //\r\n  function withdrawRemainingBalanceForManualRecovery() onlyOwner public {\r\n    require(this.balance != 0);                                                 // Check if there are any eth to claim\r\n    require(block.timestamp > crowdsaleEndedTime);                              // Check if crowdsale is over\r\n    require(contributorIndexes[nextContributorToClaim] == 0x0);                 // Check if all the users were refunded\r\n    multisigAddress.transfer(this.balance);                                     // Withdraw to multisig for manual processing\r\n  }\r\n\r\n  //\r\n  // Owner can set multisig address for crowdsale\r\n  // @owner sets an address where funds will go\r\n  // @param _newAddress\r\n  //\r\n  function setMultisigAddress(address _newAddress) onlyOwner public {\r\n    multisigAddress = _newAddress;\r\n  }\r\n\r\n  //\r\n  // Setter for the whitelist contract\r\n  // @owner sets address of whitelist contract\r\n  // @param address\r\n  //\r\n  function setPriorityPassContract(address _newAddress) onlyOwner public {\r\n    priorityPassContract = PriorityPassInterface(_newAddress);\r\n  }\r\n\r\n  //\r\n  // Getter for the whitelist contract\r\n  // @returns white list contract address\r\n  //\r\n  function priorityPassContractAddress() constant public returns (address) {\r\n    return address(priorityPassContract);\r\n  }\r\n\r\n  //\r\n  // Before crowdsale starts owner can calibrate time of crowdsale stages\r\n  // @owner sends new times for the sale\r\n  // @param _presaleStartTime timestamp for sale limited start\r\n  // @param _presaleUnlimitedStartTime timestamp for sale unlimited\r\n  // @param _crowdsaleEndedTime timestamp for ending sale\r\n  //\r\n  function setCrowdsaleTimes(uint _presaleStartTime, uint _presaleUnlimitedStartTime, uint _crowdsaleEndedTime) onlyOwner public {\r\n    require(crowdsaleState == state.pendingStart);                              // Check if crowdsale has started\r\n    require(_presaleStartTime != 0);                                            // Check if any value is 0\r\n    require(_presaleStartTime < _presaleUnlimitedStartTime);                    // Check if presaleUnlimitedStartTime is set properly\r\n    require(_presaleUnlimitedStartTime != 0);                                   // Check if any value is 0\r\n    require(_presaleUnlimitedStartTime < _crowdsaleEndedTime);                  // Check if crowdsaleEndedTime is set properly\r\n    require(_crowdsaleEndedTime != 0);                                          // Check if any value is 0\r\n    presaleStartTime = _presaleStartTime;\r\n    presaleUnlimitedStartTime = _presaleUnlimitedStartTime;\r\n    crowdsaleEndedTime = _crowdsaleEndedTime;\r\n  }\r\n}\r\n\r\ncontract LegacySeedCrowdsale is SeedCrowdsaleContract {\r\n  \r\n  function LegacySeedCrowdsale() {\r\n\r\n    presaleStartTime = 1512032400;\r\n    presaleUnlimitedStartTime = 1512063000;\r\n    crowdsaleEndedTime = 1512140400;\r\n\r\n    minCap = 356 ether;\r\n    maxP1Cap = 748 ether;\r\n    maxCap = 831 ether;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"setMultisigAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presaleUnlimitedStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"contributorIndexes\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawRemainingBalanceForManualRecovery\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingEthWithdrawal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priorityPassContractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxP1Cap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multisigAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"setPriorityPassContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_presaleStartTime\",\"type\":\"uint256\"},{\"name\":\"_presaleUnlimitedStartTime\",\"type\":\"uint256\"},{\"name\":\"_crowdsaleEndedTime\",\"type\":\"uint256\"}],\"name\":\"setCrowdsaleTimes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contributor\",\"type\":\"address\"}],\"name\":\"calculateMaxContribution\",\"outputs\":[{\"name\":\"maxContribution\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_numberOfReturns\",\"type\":\"uint256\"}],\"name\":\"batchReturnEthIfFailed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"contributorList\",\"outputs\":[{\"name\":\"contributionAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextContributorIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"salvageTokensFromContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presaleStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pullBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleEndedTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"blocktime\",\"type\":\"uint256\"}],\"name\":\"PresaleStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"blocktime\",\"type\":\"uint256\"}],\"name\":\"PresaleUnlimitedStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"blocktime\",\"type\":\"uint256\"}],\"name\":\"CrowdsaleEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ErrorSendingETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"blocktime\",\"type\":\"uint256\"}],\"name\":\"MinCapReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"blocktime\",\"type\":\"uint256\"}],\"name\":\"MaxCapReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ContributionMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_prevOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdate\",\"type\":\"event\"}]","ContractName":"LegacySeedCrowdsale","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://904f25f0e8335b8b3d7e9e1eae5934db6acebddbc62330227b1be00499ad6389"}]}