{"status":"1","message":"OK","result":[{"SourceCode":"//File: node_modules/liquidpledging/contracts/ILiquidPledgingPlugin.sol\r\npragma solidity ^0.4.11;\r\n\r\n/*\r\n    Copyright 2017, Jordi Baylina\r\n    Contributor: Adrià Massanet <adria@codecontext.io>\r\n\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n\r\n/// @dev `ILiquidPledgingPlugin` is the basic interface for any\r\n///  liquid pledging plugin\r\ncontract ILiquidPledgingPlugin {\r\n\r\n    /// @notice Plugins are used (much like web hooks) to initiate an action\r\n    ///  upon any donation, delegation, or transfer; this is an optional feature\r\n    ///  and allows for extreme customization of the contract. This function\r\n    ///  implements any action that should be initiated before a transfer.\r\n    /// @param pledgeManager The admin or current manager of the pledge\r\n    /// @param pledgeFrom This is the Id from which value will be transfered.\r\n    /// @param pledgeTo This is the Id that value will be transfered to.    \r\n    /// @param context The situation that is triggering the plugin:\r\n    ///  0 -> Plugin for the owner transferring pledge to another party\r\n    ///  1 -> Plugin for the first delegate transferring pledge to another party\r\n    ///  2 -> Plugin for the second delegate transferring pledge to another party\r\n    ///  ...\r\n    ///  255 -> Plugin for the intendedProject transferring pledge to another party\r\n    ///\r\n    ///  256 -> Plugin for the owner receiving pledge to another party\r\n    ///  257 -> Plugin for the first delegate receiving pledge to another party\r\n    ///  258 -> Plugin for the second delegate receiving pledge to another party\r\n    ///  ...\r\n    ///  511 -> Plugin for the intendedProject receiving pledge to another party\r\n    /// @param amount The amount of value that will be transfered.\r\n    function beforeTransfer(\r\n        uint64 pledgeManager,\r\n        uint64 pledgeFrom,\r\n        uint64 pledgeTo,\r\n        uint64 context,\r\n        uint amount ) returns (uint maxAllowed);\r\n\r\n    /// @notice Plugins are used (much like web hooks) to initiate an action\r\n    ///  upon any donation, delegation, or transfer; this is an optional feature\r\n    ///  and allows for extreme customization of the contract. This function\r\n    ///  implements any action that should be initiated after a transfer.\r\n    /// @param pledgeManager The admin or current manager of the pledge\r\n    /// @param pledgeFrom This is the Id from which value will be transfered.\r\n    /// @param pledgeTo This is the Id that value will be transfered to.    \r\n    /// @param context The situation that is triggering the plugin:\r\n    ///  0 -> Plugin for the owner transferring pledge to another party\r\n    ///  1 -> Plugin for the first delegate transferring pledge to another party\r\n    ///  2 -> Plugin for the second delegate transferring pledge to another party\r\n    ///  ...\r\n    ///  255 -> Plugin for the intendedProject transferring pledge to another party\r\n    ///\r\n    ///  256 -> Plugin for the owner receiving pledge to another party\r\n    ///  257 -> Plugin for the first delegate receiving pledge to another party\r\n    ///  258 -> Plugin for the second delegate receiving pledge to another party\r\n    ///  ...\r\n    ///  511 -> Plugin for the intendedProject receiving pledge to another party\r\n    ///  @param amount The amount of value that will be transfered.\r\n    function afterTransfer(\r\n        uint64 pledgeManager,\r\n        uint64 pledgeFrom,\r\n        uint64 pledgeTo,\r\n        uint64 context,\r\n        uint amount\r\n    );\r\n}\r\n\r\n//File: node_modules/giveth-common-contracts/contracts/Owned.sol\r\npragma solidity ^0.4.15;\r\n\r\n\r\n/// @title Owned\r\n/// @author Adrià Massanet <adria@codecontext.io>\r\n/// @notice The Owned contract has an owner address, and provides basic \r\n///  authorization control functions, this simplifies & the implementation of\r\n///  user permissions; this contract has three work flows for a change in\r\n///  ownership, the first requires the new owner to validate that they have the\r\n///  ability to accept ownership, the second allows the ownership to be\r\n///  directly transfered without requiring acceptance, and the third allows for\r\n///  the ownership to be removed to allow for decentralization \r\ncontract Owned {\r\n\r\n    address public owner;\r\n    address public newOwnerCandidate;\r\n\r\n    event OwnershipRequested(address indexed by, address indexed to);\r\n    event OwnershipTransferred(address indexed from, address indexed to);\r\n    event OwnershipRemoved();\r\n\r\n    /// @dev The constructor sets the `msg.sender` as the`owner` of the contract\r\n    function Owned() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /// @dev `owner` is the only address that can call a function with this\r\n    /// modifier\r\n    modifier onlyOwner() {\r\n        require (msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    /// @dev In this 1st option for ownership transfer `proposeOwnership()` must\r\n    ///  be called first by the current `owner` then `acceptOwnership()` must be\r\n    ///  called by the `newOwnerCandidate`\r\n    /// @notice `onlyOwner` Proposes to transfer control of the contract to a\r\n    ///  new owner\r\n    /// @param _newOwnerCandidate The address being proposed as the new owner\r\n    function proposeOwnership(address _newOwnerCandidate) public onlyOwner {\r\n        newOwnerCandidate = _newOwnerCandidate;\r\n        OwnershipRequested(msg.sender, newOwnerCandidate);\r\n    }\r\n\r\n    /// @notice Can only be called by the `newOwnerCandidate`, accepts the\r\n    ///  transfer of ownership\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwnerCandidate);\r\n\r\n        address oldOwner = owner;\r\n        owner = newOwnerCandidate;\r\n        newOwnerCandidate = 0x0;\r\n\r\n        OwnershipTransferred(oldOwner, owner);\r\n    }\r\n\r\n    /// @dev In this 2nd option for ownership transfer `changeOwnership()` can\r\n    ///  be called and it will immediately assign ownership to the `newOwner`\r\n    /// @notice `owner` can step down and assign some other address to this role\r\n    /// @param _newOwner The address of the new owner\r\n    function changeOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != 0x0);\r\n\r\n        address oldOwner = owner;\r\n        owner = _newOwner;\r\n        newOwnerCandidate = 0x0;\r\n\r\n        OwnershipTransferred(oldOwner, owner);\r\n    }\r\n\r\n    /// @dev In this 3rd option for ownership transfer `removeOwnership()` can\r\n    ///  be called and it will immediately assign ownership to the 0x0 address;\r\n    ///  it requires a 0xdece be input as a parameter to prevent accidental use\r\n    /// @notice Decentralizes the contract, this operation cannot be undone \r\n    /// @param _dac `0xdac` has to be entered for this function to work\r\n    function removeOwnership(address _dac) public onlyOwner {\r\n        require(_dac == 0xdac);\r\n        owner = 0x0;\r\n        newOwnerCandidate = 0x0;\r\n        OwnershipRemoved();     \r\n    }\r\n} \r\n\r\n//File: node_modules/giveth-common-contracts/contracts/ERC20.sol\r\npragma solidity ^0.4.15;\r\n\r\n\r\n/**\r\n * @title ERC20\r\n * @dev A standard interface for tokens.\r\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n */\r\ncontract ERC20 {\r\n  \r\n    /// @dev Returns the total token supply\r\n    function totalSupply() public constant returns (uint256 supply);\r\n\r\n    /// @dev Returns the account balance of the account with address _owner\r\n    function balanceOf(address _owner) public constant returns (uint256 balance);\r\n\r\n    /// @dev Transfers _value number of tokens to address _to\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @dev Transfers _value number of tokens from address _from to address _to\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @dev Allows _spender to withdraw from the msg.sender's account up to the _value amount\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n    /// @dev Returns the amount which _spender is still allowed to withdraw from _owner\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n}\r\n\r\n//File: node_modules/giveth-common-contracts/contracts/Escapable.sol\r\npragma solidity ^0.4.15;\r\n/*\r\n    Copyright 2016, Jordi Baylina\r\n    Contributor: Adrià Massanet <adria@codecontext.io>\r\n\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n/// @dev `Escapable` is a base level contract built off of the `Owned`\r\n///  contract; it creates an escape hatch function that can be called in an\r\n///  emergency that will allow designated addresses to send any ether or tokens\r\n///  held in the contract to an `escapeHatchDestination` as long as they were\r\n///  not blacklisted\r\ncontract Escapable is Owned {\r\n    address public escapeHatchCaller;\r\n    address public escapeHatchDestination;\r\n    mapping (address=>bool) private escapeBlacklist; // Token contract addresses\r\n\r\n    /// @notice The Constructor assigns the `escapeHatchDestination` and the\r\n    ///  `escapeHatchCaller`\r\n    /// @param _escapeHatchCaller The address of a trusted account or contract\r\n    ///  to call `escapeHatch()` to send the ether in this contract to the\r\n    ///  `escapeHatchDestination` it would be ideal that `escapeHatchCaller`\r\n    ///  cannot move funds out of `escapeHatchDestination`\r\n    /// @param _escapeHatchDestination The address of a safe location (usu a\r\n    ///  Multisig) to send the ether held in this contract; if a neutral address\r\n    ///  is required, the WHG Multisig is an option:\r\n    ///  0x8Ff920020c8AD673661c8117f2855C384758C572 \r\n    function Escapable(address _escapeHatchCaller, address _escapeHatchDestination) public {\r\n        escapeHatchCaller = _escapeHatchCaller;\r\n        escapeHatchDestination = _escapeHatchDestination;\r\n    }\r\n\r\n    /// @dev The addresses preassigned as `escapeHatchCaller` or `owner`\r\n    ///  are the only addresses that can call a function with this modifier\r\n    modifier onlyEscapeHatchCallerOrOwner {\r\n        require ((msg.sender == escapeHatchCaller)||(msg.sender == owner));\r\n        _;\r\n    }\r\n\r\n    /// @notice Creates the blacklist of tokens that are not able to be taken\r\n    ///  out of the contract; can only be done at the deployment, and the logic\r\n    ///  to add to the blacklist will be in the constructor of a child contract\r\n    /// @param _token the token contract address that is to be blacklisted \r\n    function blacklistEscapeToken(address _token) internal {\r\n        escapeBlacklist[_token] = true;\r\n        EscapeHatchBlackistedToken(_token);\r\n    }\r\n\r\n    /// @notice Checks to see if `_token` is in the blacklist of tokens\r\n    /// @param _token the token address being queried\r\n    /// @return False if `_token` is in the blacklist and can't be taken out of\r\n    ///  the contract via the `escapeHatch()`\r\n    function isTokenEscapable(address _token) constant public returns (bool) {\r\n        return !escapeBlacklist[_token];\r\n    }\r\n\r\n    /// @notice The `escapeHatch()` should only be called as a last resort if a\r\n    /// security issue is uncovered or something unexpected happened\r\n    /// @param _token to transfer, use 0x0 for ether\r\n    function escapeHatch(address _token) public onlyEscapeHatchCallerOrOwner {   \r\n        require(escapeBlacklist[_token]==false);\r\n\r\n        uint256 balance;\r\n\r\n        /// @dev Logic for ether\r\n        if (_token == 0x0) {\r\n            balance = this.balance;\r\n            escapeHatchDestination.transfer(balance);\r\n            EscapeHatchCalled(_token, balance);\r\n            return;\r\n        }\r\n        /// @dev Logic for tokens\r\n        ERC20 token = ERC20(_token);\r\n        balance = token.balanceOf(this);\r\n        require(token.transfer(escapeHatchDestination, balance));\r\n        EscapeHatchCalled(_token, balance);\r\n    }\r\n\r\n    /// @notice Changes the address assigned to call `escapeHatch()`\r\n    /// @param _newEscapeHatchCaller The address of a trusted account or\r\n    ///  contract to call `escapeHatch()` to send the value in this contract to\r\n    ///  the `escapeHatchDestination`; it would be ideal that `escapeHatchCaller`\r\n    ///  cannot move funds out of `escapeHatchDestination`\r\n    function changeHatchEscapeCaller(address _newEscapeHatchCaller) public onlyEscapeHatchCallerOrOwner {\r\n        escapeHatchCaller = _newEscapeHatchCaller;\r\n    }\r\n\r\n    event EscapeHatchBlackistedToken(address token);\r\n    event EscapeHatchCalled(address token, uint amount);\r\n}\r\n\r\n//File: node_modules/liquidpledging/contracts/LiquidPledgingBase.sol\r\npragma solidity ^0.4.11;\r\n/*\r\n    Copyright 2017, Jordi Baylina\r\n    Contributors: Adrià Massanet <adria@codecontext.io>, RJ Ewing, Griff\r\n    Green, Arthur Lunn\r\n\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n\r\n\r\n\r\n/// @dev This is an interface for `LPVault` which serves as a secure storage for\r\n///  the ETH that backs the Pledges, only after `LiquidPledging` authorizes\r\n///  payments can Pledges be converted for ETH\r\ninterface LPVault {\r\n    function authorizePayment(bytes32 _ref, address _dest, uint _amount);\r\n    function () payable;\r\n}\r\n\r\n/// @dev `LiquidPledgingBase` is the base level contract used to carry out\r\n///  liquidPledging's most basic functions, mostly handling and searching the\r\n///  data structures\r\ncontract LiquidPledgingBase is Escapable {\r\n\r\n    // Limits inserted to prevent large loops that could prevent canceling\r\n    uint constant MAX_DELEGATES = 20;\r\n    uint constant MAX_SUBPROJECT_LEVEL = 20;\r\n    uint constant MAX_INTERPROJECT_LEVEL = 20;\r\n\r\n    enum PledgeAdminType { Giver, Delegate, Project }\r\n    enum PledgeState { Pledged, Paying, Paid }\r\n\r\n    /// @dev This struct defines the details of a `PledgeAdmin` which are \r\n    ///  commonly referenced by their index in the `admins` array\r\n    ///  and can own pledges and act as delegates\r\n    struct PledgeAdmin { \r\n        PledgeAdminType adminType; // Giver, Delegate or Project\r\n        address addr; // Account or contract address for admin\r\n        string name;\r\n        string url;  // Can be IPFS hash\r\n        uint64 commitTime;  // In seconds, used for Givers' & Delegates' vetos\r\n        uint64 parentProject;  // Only for projects\r\n        bool canceled;      //Always false except for canceled projects\r\n\r\n        /// @dev if the plugin is 0x0 then nothing happens, if its an address\r\n        // than that smart contract is called when appropriate\r\n        ILiquidPledgingPlugin plugin; \r\n    }\r\n\r\n    struct Pledge {\r\n        uint amount;\r\n        uint64 owner; // PledgeAdmin\r\n        uint64[] delegationChain; // List of delegates in order of authority\r\n        uint64 intendedProject; // Used when delegates are sending to projects\r\n        uint64 commitTime;  // When the intendedProject will become the owner  \r\n        uint64 oldPledge; // Points to the id that this Pledge was derived from\r\n        PledgeState pledgeState; //  Pledged, Paying, Paid\r\n    }\r\n\r\n    Pledge[] pledges;\r\n    PledgeAdmin[] admins; //The list of pledgeAdmins 0 means there is no admin\r\n    LPVault public vault;\r\n\r\n    /// @dev this mapping allows you to search for a specific pledge's \r\n    ///  index number by the hash of that pledge\r\n    mapping (bytes32 => uint64) hPledge2idx;\r\n    mapping (bytes32 => bool) pluginWhitelist;\r\n    \r\n    bool public usePluginWhitelist = true;\r\n\r\n/////////////\r\n// Modifiers\r\n/////////////\r\n\r\n\r\n    /// @dev The `vault`is the only addresses that can call a function with this\r\n    ///  modifier\r\n    modifier onlyVault() {\r\n        require(msg.sender == address(vault));\r\n        _;\r\n    }\r\n\r\n\r\n///////////////\r\n// Constructor\r\n///////////////\r\n\r\n    /// @notice The Constructor creates `LiquidPledgingBase` on the blockchain\r\n    /// @param _vault The vault where the ETH backing the pledges is stored\r\n    function LiquidPledgingBase(\r\n        address _vault,\r\n        address _escapeHatchCaller,\r\n        address _escapeHatchDestination\r\n    ) Escapable(_escapeHatchCaller, _escapeHatchDestination) public {\r\n        admins.length = 1; // we reserve the 0 admin\r\n        pledges.length = 1; // we reserve the 0 pledge\r\n        vault = LPVault(_vault); // Assigns the specified vault\r\n    }\r\n\r\n\r\n/////////////////////////\r\n// PledgeAdmin functions\r\n/////////////////////////\r\n\r\n    /// @notice Creates a Giver Admin with the `msg.sender` as the Admin address\r\n    /// @param name The name used to identify the Giver\r\n    /// @param url The link to the Giver's profile often an IPFS hash\r\n    /// @param commitTime The length of time in seconds the Giver has to\r\n    ///   veto when the Giver's delegates Pledge funds to a project\r\n    /// @param plugin This is Giver's liquid pledge plugin allowing for \r\n    ///  extended functionality\r\n    /// @return idGiver The id number used to reference this Admin\r\n    function addGiver(\r\n        string name,\r\n        string url,\r\n        uint64 commitTime,\r\n        ILiquidPledgingPlugin plugin\r\n    ) returns (uint64 idGiver) {\r\n\r\n        require(isValidPlugin(plugin)); // Plugin check\r\n\r\n        idGiver = uint64(admins.length);\r\n\r\n        admins.push(PledgeAdmin(\r\n            PledgeAdminType.Giver,\r\n            msg.sender,\r\n            name,\r\n            url,\r\n            commitTime,\r\n            0,\r\n            false,\r\n            plugin));\r\n\r\n        GiverAdded(idGiver);\r\n    }\r\n\r\n    event GiverAdded(uint64 indexed idGiver);\r\n\r\n    /// @notice Updates a Giver's info to change the address, name, url, or \r\n    ///  commitTime, it cannot be used to change a plugin, and it must be called\r\n    ///  by the current address of the Giver\r\n    /// @param idGiver This is the Admin id number used to specify the Giver\r\n    /// @param newAddr The new address that represents this Giver\r\n    /// @param newName The new name used to identify the Giver\r\n    /// @param newUrl The new link to the Giver's profile often an IPFS hash\r\n    /// @param newCommitTime Sets the length of time in seconds the Giver has to\r\n    ///   veto when the Giver's delegates Pledge funds to a project\r\n    function updateGiver(\r\n        uint64 idGiver,\r\n        address newAddr,\r\n        string newName,\r\n        string newUrl,\r\n        uint64 newCommitTime)\r\n    {\r\n        PledgeAdmin storage giver = findAdmin(idGiver);\r\n        require(giver.adminType == PledgeAdminType.Giver); // Must be a Giver\r\n        require(giver.addr == msg.sender); // Current addr had to send this tx\r\n        giver.addr = newAddr;\r\n        giver.name = newName;\r\n        giver.url = newUrl;\r\n        giver.commitTime = newCommitTime;\r\n        GiverUpdated(idGiver);\r\n    }\r\n\r\n    event GiverUpdated(uint64 indexed idGiver);\r\n\r\n    /// @notice Creates a Delegate Admin with the `msg.sender` as the Admin addr\r\n    /// @param name The name used to identify the Delegate\r\n    /// @param url The link to the Delegate's profile often an IPFS hash\r\n    /// @param commitTime Sets the length of time in seconds that this delegate\r\n    ///  can be vetoed. Whenever this delegate is in a delegate chain the time\r\n    ///  allowed to veto any event must be greater than or equal to this time.\r\n    /// @param plugin This is Delegate's liquid pledge plugin allowing for \r\n    ///  extended functionality\r\n    /// @return idxDelegate The id number used to reference this Delegate within\r\n    ///  the admins array\r\n    function addDelegate(\r\n        string name,\r\n        string url,\r\n        uint64 commitTime,\r\n        ILiquidPledgingPlugin plugin\r\n    ) returns (uint64 idDelegate) { \r\n\r\n        require(isValidPlugin(plugin)); // Plugin check\r\n\r\n        idDelegate = uint64(admins.length);\r\n\r\n        admins.push(PledgeAdmin(\r\n            PledgeAdminType.Delegate,\r\n            msg.sender,\r\n            name,\r\n            url,\r\n            commitTime,\r\n            0,\r\n            false,\r\n            plugin));\r\n\r\n        DelegateAdded(idDelegate);\r\n    }\r\n\r\n    event DelegateAdded(uint64 indexed idDelegate);\r\n\r\n    /// @notice Updates a Delegate's info to change the address, name, url, or \r\n    ///  commitTime, it cannot be used to change a plugin, and it must be called\r\n    ///  by the current address of the Delegate\r\n    /// @param idDelegate The Admin id number used to specify the Delegate\r\n    /// @param newAddr The new address that represents this Delegate\r\n    /// @param newName The new name used to identify the Delegate\r\n    /// @param newUrl The new link to the Delegate's profile often an IPFS hash\r\n    /// @param newCommitTime Sets the length of time in seconds that this \r\n    ///  delegate can be vetoed. Whenever this delegate is in a delegate chain \r\n    ///  the time allowed to veto any event must be greater than or equal to\r\n    ///  this time.\r\n    function updateDelegate(\r\n        uint64 idDelegate,\r\n        address newAddr,\r\n        string newName,\r\n        string newUrl,\r\n        uint64 newCommitTime) {\r\n        PledgeAdmin storage delegate = findAdmin(idDelegate);\r\n        require(delegate.adminType == PledgeAdminType.Delegate);\r\n        require(delegate.addr == msg.sender);// Current addr had to send this tx\r\n        delegate.addr = newAddr;\r\n        delegate.name = newName;\r\n        delegate.url = newUrl;\r\n        delegate.commitTime = newCommitTime;\r\n        DelegateUpdated(idDelegate);\r\n    }\r\n\r\n    event DelegateUpdated(uint64 indexed idDelegate);\r\n\r\n    /// @notice Creates a Project Admin with the `msg.sender` as the Admin addr\r\n    /// @param name The name used to identify the Project\r\n    /// @param url The link to the Project's profile often an IPFS hash\r\n    /// @param projectAdmin The address for the trusted project manager \r\n    /// @param parentProject The Admin id number for the parent project or 0 if\r\n    ///  there is no parentProject\r\n    /// @param commitTime Sets the length of time in seconds the Project has to\r\n    ///   veto when the Project delegates to another Delegate and they pledge \r\n    ///   those funds to a project\r\n    /// @param plugin This is Project's liquid pledge plugin allowing for \r\n    ///  extended functionality\r\n    /// @return idProject The id number used to reference this Admin\r\n    function addProject(\r\n        string name,\r\n        string url,\r\n        address projectAdmin,\r\n        uint64 parentProject,\r\n        uint64 commitTime,\r\n        ILiquidPledgingPlugin plugin\r\n    ) returns (uint64 idProject) {\r\n        require(isValidPlugin(plugin));\r\n\r\n        if (parentProject != 0) {\r\n            PledgeAdmin storage pa = findAdmin(parentProject);\r\n            require(pa.adminType == PledgeAdminType.Project);\r\n            require(getProjectLevel(pa) < MAX_SUBPROJECT_LEVEL);\r\n        }\r\n\r\n        idProject = uint64(admins.length);\r\n\r\n        admins.push(PledgeAdmin(\r\n            PledgeAdminType.Project,\r\n            projectAdmin,\r\n            name,\r\n            url,\r\n            commitTime,\r\n            parentProject,\r\n            false,\r\n            plugin));\r\n\r\n\r\n        ProjectAdded(idProject);\r\n    }\r\n\r\n    event ProjectAdded(uint64 indexed idProject);\r\n\r\n\r\n    /// @notice Updates a Project's info to change the address, name, url, or \r\n    ///  commitTime, it cannot be used to change a plugin or a parentProject,\r\n    ///  and it must be called by the current address of the Project\r\n    /// @param idProject The Admin id number used to specify the Project\r\n    /// @param newAddr The new address that represents this Project\r\n    /// @param newName The new name used to identify the Project\r\n    /// @param newUrl The new link to the Project's profile often an IPFS hash\r\n    /// @param newCommitTime Sets the length of time in seconds the Project has\r\n    ///  to veto when the Project delegates to a Delegate and they pledge those\r\n    ///  funds to a project\r\n    function updateProject(\r\n        uint64 idProject,\r\n        address newAddr,\r\n        string newName,\r\n        string newUrl,\r\n        uint64 newCommitTime)\r\n    {\r\n        PledgeAdmin storage project = findAdmin(idProject);\r\n        require(project.adminType == PledgeAdminType.Project);\r\n        require(project.addr == msg.sender);\r\n        project.addr = newAddr;\r\n        project.name = newName;\r\n        project.url = newUrl;\r\n        project.commitTime = newCommitTime;\r\n        ProjectUpdated(idProject);\r\n    }\r\n\r\n    event ProjectUpdated(uint64 indexed idAdmin);\r\n\r\n\r\n//////////\r\n// Public constant functions\r\n//////////\r\n\r\n    /// @notice A constant getter that returns the total number of pledges\r\n    /// @return The total number of Pledges in the system\r\n    function numberOfPledges() constant returns (uint) {\r\n        return pledges.length - 1;\r\n    }\r\n\r\n    /// @notice A getter that returns the details of the specified pledge\r\n    /// @param idPledge the id number of the pledge being queried\r\n    /// @return the amount, owner, the number of delegates (but not the actual\r\n    ///  delegates, the intendedProject (if any), the current commit time and\r\n    ///  the previous pledge this pledge was derived from\r\n    function getPledge(uint64 idPledge) constant returns(\r\n        uint amount,\r\n        uint64 owner,\r\n        uint64 nDelegates,\r\n        uint64 intendedProject,\r\n        uint64 commitTime,\r\n        uint64 oldPledge,\r\n        PledgeState pledgeState\r\n    ) {\r\n        Pledge storage p = findPledge(idPledge);\r\n        amount = p.amount;\r\n        owner = p.owner;\r\n        nDelegates = uint64(p.delegationChain.length);\r\n        intendedProject = p.intendedProject;\r\n        commitTime = p.commitTime;\r\n        oldPledge = p.oldPledge;\r\n        pledgeState = p.pledgeState;\r\n    }\r\n\r\n    /// @notice Getter to find Delegate w/ the Pledge ID & the Delegate index\r\n    /// @param idPledge The id number representing the pledge being queried\r\n    /// @param idxDelegate The index number for the delegate in this Pledge \r\n    function getPledgeDelegate(uint64 idPledge, uint idxDelegate) constant returns(\r\n        uint64 idDelegate,\r\n        address addr,\r\n        string name\r\n    ) {\r\n        Pledge storage p = findPledge(idPledge);\r\n        idDelegate = p.delegationChain[idxDelegate - 1];\r\n        PledgeAdmin storage delegate = findAdmin(idDelegate);\r\n        addr = delegate.addr;\r\n        name = delegate.name;\r\n    }\r\n\r\n    /// @notice A constant getter used to check how many total Admins exist\r\n    /// @return The total number of admins (Givers, Delegates and Projects) .\r\n    function numberOfPledgeAdmins() constant returns(uint) {\r\n        return admins.length - 1;\r\n    }\r\n\r\n    /// @notice A constant getter to check the details of a specified Admin  \r\n    /// @return addr Account or contract address for admin\r\n    /// @return name Name of the pledgeAdmin\r\n    /// @return url The link to the Project's profile often an IPFS hash\r\n    /// @return commitTime The length of time in seconds the Admin has to veto\r\n    ///   when the Admin delegates to a Delegate and that Delegate pledges those\r\n    ///   funds to a project\r\n    /// @return parentProject The Admin id number for the parent project or 0\r\n    ///  if there is no parentProject\r\n    /// @return canceled 0 for Delegates & Givers, true if a Project has been \r\n    ///  canceled\r\n    /// @return plugin This is Project's liquidPledging plugin allowing for \r\n    ///  extended functionality\r\n    function getPledgeAdmin(uint64 idAdmin) constant returns (\r\n        PledgeAdminType adminType,\r\n        address addr,\r\n        string name,\r\n        string url,\r\n        uint64 commitTime,\r\n        uint64 parentProject,\r\n        bool canceled,\r\n        address plugin)\r\n    {\r\n        PledgeAdmin storage m = findAdmin(idAdmin);\r\n        adminType = m.adminType;\r\n        addr = m.addr;\r\n        name = m.name;\r\n        url = m.url;\r\n        commitTime = m.commitTime;\r\n        parentProject = m.parentProject;\r\n        canceled = m.canceled;\r\n        plugin = address(m.plugin);\r\n    }\r\n\r\n////////\r\n// Private methods\r\n///////\r\n\r\n    /// @notice This creates a Pledge with an initial amount of 0 if one is not\r\n    ///  created already; otherwise it finds the pledge with the specified\r\n    ///  attributes; all pledges technically exist, if the pledge hasn't been\r\n    ///  created in this system yet it simply isn't in the hash array\r\n    ///  hPledge2idx[] yet\r\n    /// @param owner The owner of the pledge being looked up\r\n    /// @param delegationChain The list of delegates in order of authority\r\n    /// @param intendedProject The project this pledge will Fund after the\r\n    ///  commitTime has passed\r\n    /// @param commitTime The length of time in seconds the Giver has to\r\n    ///   veto when the Giver's delegates Pledge funds to a project\r\n    /// @param oldPledge This value is used to store the pledge the current\r\n    ///  pledge was came from, and in the case a Project is canceled, the Pledge\r\n    ///  will revert back to it's previous state\r\n    /// @param state The pledge state: Pledged, Paying, or state\r\n    /// @return The hPledge2idx index number\r\n    function findOrCreatePledge(\r\n        uint64 owner,\r\n        uint64[] delegationChain,\r\n        uint64 intendedProject,\r\n        uint64 commitTime,\r\n        uint64 oldPledge,\r\n        PledgeState state\r\n        ) internal returns (uint64)\r\n    {\r\n        bytes32 hPledge = sha3(\r\n            owner, delegationChain, intendedProject, commitTime, oldPledge, state);\r\n        uint64 idx = hPledge2idx[hPledge];\r\n        if (idx > 0) return idx;\r\n        idx = uint64(pledges.length);\r\n        hPledge2idx[hPledge] = idx;\r\n        pledges.push(Pledge(\r\n            0, owner, delegationChain, intendedProject, commitTime, oldPledge, state));\r\n        return idx;\r\n    }\r\n\r\n    /// @notice A getter to look up a Admin's details\r\n    /// @param idAdmin The id for the Admin to lookup\r\n    /// @return The PledgeAdmin struct for the specified Admin\r\n    function findAdmin(uint64 idAdmin) internal returns (PledgeAdmin storage) {\r\n        require(idAdmin < admins.length);\r\n        return admins[idAdmin];\r\n    }\r\n\r\n    /// @notice A getter to look up a Pledge's details\r\n    /// @param idPledge The id for the Pledge to lookup\r\n    /// @return The PledgeA struct for the specified Pledge\r\n    function findPledge(uint64 idPledge) internal returns (Pledge storage) {\r\n        require(idPledge < pledges.length);\r\n        return pledges[idPledge];\r\n    }\r\n\r\n    // a constant for when a delegate is requested that is not in the system\r\n    uint64 constant  NOTFOUND = 0xFFFFFFFFFFFFFFFF;\r\n\r\n    /// @notice A getter that searches the delegationChain for the level of\r\n    ///  authority a specific delegate has within a Pledge\r\n    /// @param p The Pledge that will be searched\r\n    /// @param idDelegate The specified delegate that's searched for\r\n    /// @return If the delegate chain contains the delegate with the\r\n    ///  `admins` array index `idDelegate` this returns that delegates\r\n    ///  corresponding index in the delegationChain. Otherwise it returns\r\n    ///  the NOTFOUND constant\r\n    function getDelegateIdx(Pledge p, uint64 idDelegate) internal returns(uint64) {\r\n        for (uint i=0; i < p.delegationChain.length; i++) {\r\n            if (p.delegationChain[i] == idDelegate) return uint64(i);\r\n        }\r\n        return NOTFOUND;\r\n    }\r\n\r\n    /// @notice A getter to find how many old \"parent\" pledges a specific Pledge\r\n    ///  had using a self-referential loop\r\n    /// @param p The Pledge being queried\r\n    /// @return The number of old \"parent\" pledges a specific Pledge had\r\n    function getPledgeLevel(Pledge p) internal returns(uint) {\r\n        if (p.oldPledge == 0) return 0;\r\n        Pledge storage oldN = findPledge(p.oldPledge);\r\n        return getPledgeLevel(oldN) + 1; // a loop lookup\r\n    }\r\n\r\n    /// @notice A getter to find the longest commitTime out of the owner and all\r\n    ///  the delegates for a specified pledge\r\n    /// @param p The Pledge being queried\r\n    /// @return The maximum commitTime out of the owner and all the delegates\r\n    function maxCommitTime(Pledge p) internal returns(uint commitTime) {\r\n        PledgeAdmin storage m = findAdmin(p.owner);\r\n        commitTime = m.commitTime; // start with the owner's commitTime\r\n\r\n        for (uint i=0; i<p.delegationChain.length; i++) {\r\n            m = findAdmin(p.delegationChain[i]);\r\n\r\n            // If a delegate's commitTime is longer, make it the new commitTime\r\n            if (m.commitTime > commitTime) commitTime = m.commitTime;\r\n        }\r\n    }\r\n\r\n    /// @notice A getter to find the level of authority a specific Project has\r\n    ///  using a self-referential loop\r\n    /// @param m The Project being queried\r\n    /// @return The level of authority a specific Project has\r\n    function getProjectLevel(PledgeAdmin m) internal returns(uint) {\r\n        assert(m.adminType == PledgeAdminType.Project);\r\n        if (m.parentProject == 0) return(1);\r\n        PledgeAdmin storage parentNM = findAdmin(m.parentProject);\r\n        return getProjectLevel(parentNM) + 1;\r\n    }\r\n\r\n    /// @notice A getter to find if a specified Project has been canceled\r\n    /// @param projectId The Admin id number used to specify the Project\r\n    /// @return True if the Project has been canceled\r\n    function isProjectCanceled(uint64 projectId) constant returns (bool) {\r\n        PledgeAdmin storage m = findAdmin(projectId);\r\n        if (m.adminType == PledgeAdminType.Giver) return false;\r\n        assert(m.adminType == PledgeAdminType.Project);\r\n        if (m.canceled) return true;\r\n        if (m.parentProject == 0) return false;\r\n        return isProjectCanceled(m.parentProject);\r\n    }\r\n\r\n    /// @notice A getter to find the oldest pledge that hasn't been canceled\r\n    /// @param idPledge The starting place to lookup the pledges \r\n    /// @return The oldest idPledge that hasn't been canceled (DUH!)\r\n    function getOldestPledgeNotCanceled(uint64 idPledge\r\n        ) internal constant returns(uint64) {\r\n        if (idPledge == 0) return 0;\r\n        Pledge storage p = findPledge(idPledge);\r\n        PledgeAdmin storage admin = findAdmin(p.owner);\r\n        if (admin.adminType == PledgeAdminType.Giver) return idPledge;\r\n\r\n        assert(admin.adminType == PledgeAdminType.Project);\r\n\r\n        if (!isProjectCanceled(p.owner)) return idPledge;\r\n\r\n        return getOldestPledgeNotCanceled(p.oldPledge);\r\n    }\r\n\r\n    /// @notice A check to see if the msg.sender is the owner or the\r\n    ///  plugin contract for a specific Admin\r\n    /// @param m The Admin being checked\r\n    function checkAdminOwner(PledgeAdmin m) internal constant {\r\n        require((msg.sender == m.addr) || (msg.sender == address(m.plugin)));\r\n    }\r\n///////////////////////////\r\n// Plugin Whitelist Methods\r\n///////////////////////////\r\n\r\n    function addValidPlugin(bytes32 contractHash) external onlyOwner {\r\n        pluginWhitelist[contractHash] = true;\r\n    }\r\n\r\n    function removeValidPlugin(bytes32 contractHash) external onlyOwner {\r\n        pluginWhitelist[contractHash] = false;\r\n    }\r\n\r\n    function useWhitelist(bool useWhitelist) external onlyOwner {\r\n        usePluginWhitelist = useWhitelist;\r\n    }\r\n\r\n    function isValidPlugin(address addr) public returns(bool) {\r\n        if (!usePluginWhitelist || addr == 0x0) return true;\r\n\r\n        bytes32 contractHash = getCodeHash(addr);\r\n\r\n        return pluginWhitelist[contractHash];\r\n    }\r\n\r\n    function getCodeHash(address addr) public returns(bytes32) {\r\n        bytes memory o_code;\r\n        assembly {\r\n            // retrieve the size of the code, this needs assembly\r\n            let size := extcodesize(addr)\r\n            // allocate output byte array - this could also be done without assembly\r\n            // by using o_code = new bytes(size)\r\n            o_code := mload(0x40)\r\n            // new \"memory end\" including padding\r\n            mstore(0x40, add(o_code, and(add(add(size, 0x20), 0x1f), not(0x1f))))\r\n            // store length in memory\r\n            mstore(o_code, size)\r\n            // actually retrieve the code, this needs assembly\r\n            extcodecopy(addr, add(o_code, 0x20), 0, size)\r\n        }\r\n        return keccak256(o_code);\r\n    }\r\n}\r\n\r\n//File: node_modules/liquidpledging/contracts/LiquidPledging.sol\r\npragma solidity ^0.4.11;\r\n\r\n/*\r\n    Copyright 2017, Jordi Baylina\r\n    Contributor: Adrià Massanet <adria@codecontext.io>\r\n\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n// Contract Imports\r\n\r\n\r\n/// @dev `LiquidPleding` allows for liquid pledging through the use of\r\n///  internal id structures and delegate chaining. All basic operations for\r\n///  handling liquid pledging are supplied as well as plugin features\r\n///  to allow for expanded functionality.\r\ncontract LiquidPledging is LiquidPledgingBase {\r\n\r\n\r\n//////\r\n// Constructor\r\n//////\r\n\r\n    /// @notice Basic constructor for LiquidPleding, also calls the\r\n    ///  LiquidPledgingBase contract\r\n    /// @dev This constructor  also calls the constructor \r\n    ///  for `LiquidPledgingBase`\r\n    /// @param _vault The vault where ETH backing this pledge is stored\r\n    function LiquidPledging(\r\n        address _vault,\r\n        address _escapeHatchCaller,\r\n        address _escapeHatchDestination\r\n    ) LiquidPledgingBase(_vault, _escapeHatchCaller, _escapeHatchDestination) {\r\n\r\n    }\r\n\r\n    /// @notice This is how value enters into the system which creates pledges;\r\n    ///  the token of value goes into the vault and the amount in the pledge\r\n    ///  relevant to this Giver without delegates is increased, and a normal\r\n    ///  transfer is done to the idReceiver\r\n    /// @param idGiver Identifier of the giver thats donating.\r\n    /// @param idReceiver To whom it's transfered. Can be the same giver,\r\n    ///  another giver, a delegate or a project.\r\n    function donate(uint64 idGiver, uint64 idReceiver) payable {\r\n        if (idGiver == 0) {\r\n            // default to 3 day commitTime\r\n            idGiver = addGiver(\"\", \"\", 259200, ILiquidPledgingPlugin(0x0));\r\n        }\r\n\r\n        PledgeAdmin storage sender = findAdmin(idGiver);\r\n\r\n        checkAdminOwner(sender);\r\n\r\n        require(sender.adminType == PledgeAdminType.Giver);\r\n\r\n        uint amount = msg.value;\r\n\r\n        require(amount > 0);\r\n\r\n        vault.transfer(amount); // transfers the baseToken to the Vault\r\n        uint64 idPledge = findOrCreatePledge(\r\n            idGiver,\r\n            new uint64[](0), //what is new?\r\n            0,\r\n            0,\r\n            0,\r\n            PledgeState.Pledged\r\n        );\r\n\r\n\r\n        Pledge storage nTo = findPledge(idPledge);\r\n        nTo.amount += amount;\r\n\r\n        Transfer(0, idPledge, amount);\r\n\r\n        transfer(idGiver, idPledge, amount, idReceiver);\r\n    }\r\n\r\n\r\n    /// @notice Moves value between pledges\r\n    /// @param idSender ID of the giver, delegate or project admin that is \r\n    ///  transferring the funds from Pledge to Pledge; this admin must have \r\n    ///  permissions to move the value\r\n    /// @param idPledge Id of the pledge that's moving the value\r\n    /// @param amount Quantity of value that's being moved\r\n    /// @param idReceiver Destination of the value, can be a giver sending to \r\n    ///  a giver or a delegate, a delegate to another delegate or a project \r\n    ///  to pre-commit it to that project if called from a delegate,\r\n    ///  or to commit it to the project if called from the owner. \r\n    function transfer(\r\n        uint64 idSender,\r\n        uint64 idPledge,\r\n        uint amount,\r\n        uint64 idReceiver\r\n    )\r\n    {\r\n\r\n        idPledge = normalizePledge(idPledge);\r\n\r\n        Pledge storage p = findPledge(idPledge);\r\n        PledgeAdmin storage receiver = findAdmin(idReceiver);\r\n        PledgeAdmin storage sender = findAdmin(idSender);\r\n\r\n        checkAdminOwner(sender);\r\n        require(p.pledgeState == PledgeState.Pledged);\r\n\r\n        // If the sender is the owner\r\n        if (p.owner == idSender) {\r\n            if (receiver.adminType == PledgeAdminType.Giver) {\r\n                transferOwnershipToGiver(idPledge, amount, idReceiver);\r\n            } else if (receiver.adminType == PledgeAdminType.Project) {\r\n                transferOwnershipToProject(idPledge, amount, idReceiver);\r\n            } else if (receiver.adminType == PledgeAdminType.Delegate) {\r\n                idPledge = undelegate(\r\n                    idPledge,\r\n                    amount,\r\n                    p.delegationChain.length\r\n                );\r\n                appendDelegate(idPledge, amount, idReceiver);\r\n            } else {\r\n                assert(false);\r\n            }\r\n            return;\r\n        }\r\n\r\n        // If the sender is a delegate\r\n        uint senderDIdx = getDelegateIdx(p, idSender);\r\n        if (senderDIdx != NOTFOUND) {\r\n\r\n            // If the receiver is another giver\r\n            if (receiver.adminType == PledgeAdminType.Giver) {\r\n                // Only accept to change to the original giver to\r\n                // remove all delegates\r\n                assert(p.owner == idReceiver);\r\n                undelegate(idPledge, amount, p.delegationChain.length);\r\n                return;\r\n            }\r\n\r\n            // If the receiver is another delegate\r\n            if (receiver.adminType == PledgeAdminType.Delegate) {\r\n                uint receiverDIdx = getDelegateIdx(p, idReceiver);\r\n\r\n                // If the receiver is not in the delegate list\r\n                if (receiverDIdx == NOTFOUND) {\r\n                    idPledge = undelegate(\r\n                        idPledge,\r\n                        amount,\r\n                        p.delegationChain.length - senderDIdx - 1\r\n                    );\r\n                    appendDelegate(idPledge, amount, idReceiver);\r\n\r\n                // If the receiver is already part of the delegate chain and is\r\n                // after the sender, then all of the other delegates after the\r\n                // sender are removed and the receiver is appended at the\r\n                // end of the delegation chain\r\n                } else if (receiverDIdx > senderDIdx) {\r\n                    idPledge = undelegate(\r\n                        idPledge,\r\n                        amount,\r\n                        p.delegationChain.length - senderDIdx - 1\r\n                    );\r\n                    appendDelegate(idPledge, amount, idReceiver);\r\n\r\n                // If the receiver is already part of the delegate chain and is\r\n                // before the sender, then the sender and all of the other\r\n                // delegates after the RECEIVER are removed from the chain,\r\n                // this is interesting because the delegate is removed from the\r\n                // delegates that delegated to this delegate. Are there game theory\r\n                // issues? should this be allowed?\r\n                } else if (receiverDIdx <= senderDIdx) {\r\n                    undelegate(\r\n                        idPledge,\r\n                        amount,\r\n                        p.delegationChain.length - receiverDIdx - 1\r\n                    );\r\n                }\r\n                return;\r\n            }\r\n\r\n            // If the delegate wants to support a project, they remove all\r\n            // the delegates after them in the chain and choose a project\r\n            if (receiver.adminType == PledgeAdminType.Project) {\r\n                idPledge = undelegate(\r\n                    idPledge,\r\n                    amount,\r\n                    p.delegationChain.length - senderDIdx - 1\r\n                );\r\n                proposeAssignProject(idPledge, amount, idReceiver);\r\n                return;\r\n            }\r\n        }\r\n        assert(false);  // It is not the owner nor any delegate.\r\n    }\r\n\r\n    /// @notice This method is used to withdraw value from the system.\r\n    ///  This can be used by the givers withdraw any un-commited donations.\r\n    /// @param idPledge Id of the pledge that wants to be withdrawn.\r\n    /// @param amount Quantity of Ether that wants to be withdrawn.\r\n    function withdraw(uint64 idPledge, uint amount) {\r\n\r\n        idPledge = normalizePledge(idPledge);\r\n\r\n        Pledge storage p = findPledge(idPledge);\r\n\r\n        require(p.pledgeState == PledgeState.Pledged);\r\n\r\n        PledgeAdmin storage owner = findAdmin(p.owner);\r\n\r\n        checkAdminOwner(owner);\r\n\r\n        uint64 idNewPledge = findOrCreatePledge(\r\n            p.owner,\r\n            p.delegationChain,\r\n            0,\r\n            0,\r\n            p.oldPledge,\r\n            PledgeState.Paying\r\n        );\r\n\r\n        doTransfer(idPledge, idNewPledge, amount);\r\n\r\n        vault.authorizePayment(bytes32(idNewPledge), owner.addr, amount);\r\n    }\r\n\r\n    /// @notice Method called by the vault to confirm a payment.\r\n    /// @param idPledge Id of the pledge that wants to be withdrawn.\r\n    /// @param amount Quantity of Ether that wants to be withdrawn.\r\n    function confirmPayment(uint64 idPledge, uint amount) onlyVault {\r\n        Pledge storage p = findPledge(idPledge);\r\n\r\n        require(p.pledgeState == PledgeState.Paying);\r\n\r\n        uint64 idNewPledge = findOrCreatePledge(\r\n            p.owner,\r\n            p.delegationChain,\r\n            0,\r\n            0,\r\n            p.oldPledge,\r\n            PledgeState.Paid\r\n        );\r\n\r\n        doTransfer(idPledge, idNewPledge, amount);\r\n    }\r\n\r\n    /// @notice Method called by the vault to cancel a payment.\r\n    /// @param idPledge Id of the pledge that wants to be canceled for withdraw.\r\n    /// @param amount Quantity of Ether that wants to be rolled back.\r\n    function cancelPayment(uint64 idPledge, uint amount) onlyVault {\r\n        Pledge storage p = findPledge(idPledge);\r\n\r\n        require(p.pledgeState == PledgeState.Paying); //TODO change to revert\r\n\r\n        // When a payment is canceled, never is assigned to a project.\r\n        uint64 oldPledge = findOrCreatePledge(\r\n            p.owner,\r\n            p.delegationChain,\r\n            0,\r\n            0,\r\n            p.oldPledge,\r\n            PledgeState.Pledged\r\n        );\r\n\r\n        oldPledge = normalizePledge(oldPledge);\r\n\r\n        doTransfer(idPledge, oldPledge, amount);\r\n    }\r\n\r\n    /// @notice Method called to cancel this project.\r\n    /// @param idProject Id of the projct that wants to be canceled.\r\n    function cancelProject(uint64 idProject) {\r\n        PledgeAdmin storage project = findAdmin(idProject);\r\n        checkAdminOwner(project);\r\n        project.canceled = true;\r\n\r\n        CancelProject(idProject);\r\n    }\r\n\r\n    /// @notice Method called to cancel specific pledge.\r\n    /// @param idPledge Id of the pledge that should be canceled.\r\n    /// @param amount Quantity of Ether that wants to be rolled back.\r\n    function cancelPledge(uint64 idPledge, uint amount) {\r\n        idPledge = normalizePledge(idPledge);\r\n\r\n        Pledge storage p = findPledge(idPledge);\r\n        require(p.oldPledge != 0);\r\n\r\n        PledgeAdmin storage m = findAdmin(p.owner);\r\n        checkAdminOwner(m);\r\n\r\n        uint64 oldPledge = getOldestPledgeNotCanceled(p.oldPledge);\r\n        doTransfer(idPledge, oldPledge, amount);\r\n    }\r\n\r\n\r\n////////\r\n// Multi pledge methods\r\n////////\r\n\r\n    // @dev This set of functions makes moving a lot of pledges around much more\r\n    // efficient (saves gas) than calling these functions in series\r\n    \r\n    \r\n    /// Bit mask used for dividing pledge amounts in Multi pledge methods\r\n    uint constant D64 = 0x10000000000000000;\r\n\r\n    /// @notice `mTransfer` allows for multiple pledges to be transferred\r\n    ///  efficiently\r\n    /// @param idSender ID of the giver, delegate or project admin that is\r\n    ///  transferring the funds from Pledge to Pledge. This admin must have \r\n    ///  permissions to move the value\r\n    /// @param pledgesAmounts An array of pledge amounts and IDs which are extrapolated\r\n    ///  using the D64 bitmask\r\n    /// @param idReceiver Destination of the value, can be a giver sending\r\n    ///  to a giver or a delegate or a delegate to another delegate or a\r\n    ///  project to pre-commit it to that project\r\n    function mTransfer(\r\n        uint64 idSender,\r\n        uint[] pledgesAmounts,\r\n        uint64 idReceiver\r\n    ) {\r\n        for (uint i = 0; i < pledgesAmounts.length; i++ ) {\r\n            uint64 idPledge = uint64( pledgesAmounts[i] & (D64-1) );\r\n            uint amount = pledgesAmounts[i] / D64;\r\n\r\n            transfer(idSender, idPledge, amount, idReceiver);\r\n        }\r\n    }\r\n\r\n    /// @notice `mWithdraw` allows for multiple pledges to be\r\n    ///  withdrawn efficiently\r\n    /// @param pledgesAmounts An array of pledge amounts and IDs which are\r\n    ///  extrapolated using the D64 bitmask\r\n    function mWithdraw(uint[] pledgesAmounts) {\r\n        for (uint i = 0; i < pledgesAmounts.length; i++ ) {\r\n            uint64 idPledge = uint64( pledgesAmounts[i] & (D64-1) );\r\n            uint amount = pledgesAmounts[i] / D64;\r\n\r\n            withdraw(idPledge, amount);\r\n        }\r\n    }\r\n\r\n    /// @notice `mConfirmPayment` allows for multiple pledges to be confirmed\r\n    ///  efficiently\r\n    /// @param pledgesAmounts An array of pledge amounts and IDs which are extrapolated\r\n    ///  using the D64 bitmask\r\n    function mConfirmPayment(uint[] pledgesAmounts) {\r\n        for (uint i = 0; i < pledgesAmounts.length; i++ ) {\r\n            uint64 idPledge = uint64( pledgesAmounts[i] & (D64-1) );\r\n            uint amount = pledgesAmounts[i] / D64;\r\n\r\n            confirmPayment(idPledge, amount);\r\n        }\r\n    }\r\n\r\n    /// @notice `mCancelPayment` allows for multiple pledges to be canceled\r\n    ///  efficiently\r\n    /// @param pledgesAmounts An array of pledge amounts and IDs which are extrapolated\r\n    ///  using the D64 bitmask\r\n    function mCancelPayment(uint[] pledgesAmounts) {\r\n        for (uint i = 0; i < pledgesAmounts.length; i++ ) {\r\n            uint64 idPledge = uint64( pledgesAmounts[i] & (D64-1) );\r\n            uint amount = pledgesAmounts[i] / D64;\r\n\r\n            cancelPayment(idPledge, amount);\r\n        }\r\n    }\r\n\r\n    /// @notice `mNormalizePledge` allows for multiple pledges to be\r\n    ///  normalized efficiently\r\n    /// @param pledges An array of pledge IDs\r\n    function mNormalizePledge(uint64[] pledges) {\r\n        for (uint i = 0; i < pledges.length; i++ ) {\r\n            normalizePledge( pledges[i] );\r\n        }\r\n    }\r\n\r\n////////\r\n// Private methods\r\n///////\r\n\r\n    /// @notice `transferOwnershipToProject` allows for the transfer of\r\n    ///  ownership to the project, but it can also be called by a project\r\n    ///  to un-delegate everyone by setting one's own id for the idReceiver\r\n    /// @param idPledge Id of the pledge to be transfered.\r\n    /// @param amount Quantity of value that's being transfered\r\n    /// @param idReceiver The new owner of the project (or self to un-delegate)\r\n    function transferOwnershipToProject(\r\n        uint64 idPledge,\r\n        uint amount,\r\n        uint64 idReceiver\r\n    ) internal {\r\n        Pledge storage p = findPledge(idPledge);\r\n\r\n        // Ensure that the pledge is not already at max pledge depth\r\n        // and the project has not been canceled\r\n        require(getPledgeLevel(p) < MAX_INTERPROJECT_LEVEL);\r\n        require(!isProjectCanceled(idReceiver));\r\n\r\n        uint64 oldPledge = findOrCreatePledge(\r\n            p.owner,\r\n            p.delegationChain,\r\n            0,\r\n            0,\r\n            p.oldPledge,\r\n            PledgeState.Pledged\r\n        );\r\n        uint64 toPledge = findOrCreatePledge(\r\n            idReceiver,                     // Set the new owner\r\n            new uint64[](0),                // clear the delegation chain\r\n            0,\r\n            0,\r\n            oldPledge,\r\n            PledgeState.Pledged\r\n        );\r\n        doTransfer(idPledge, toPledge, amount);\r\n    }   \r\n\r\n\r\n    /// @notice `transferOwnershipToGiver` allows for the transfer of\r\n    ///  value back to the Giver, value is placed in a pledged state\r\n    ///  without being attached to a project, delegation chain, or time line.\r\n    /// @param idPledge Id of the pledge to be transfered.\r\n    /// @param amount Quantity of value that's being transfered\r\n    /// @param idReceiver The new owner of the pledge\r\n    function transferOwnershipToGiver(\r\n        uint64 idPledge,\r\n        uint amount,\r\n        uint64 idReceiver\r\n    ) internal {\r\n        uint64 toPledge = findOrCreatePledge(\r\n            idReceiver,\r\n            new uint64[](0),\r\n            0,\r\n            0,\r\n            0,\r\n            PledgeState.Pledged\r\n        );\r\n        doTransfer(idPledge, toPledge, amount);\r\n    }\r\n\r\n    /// @notice `appendDelegate` allows for a delegate to be added onto the\r\n    ///  end of the delegate chain for a given Pledge.\r\n    /// @param idPledge Id of the pledge thats delegate chain will be modified.\r\n    /// @param amount Quantity of value that's being chained.\r\n    /// @param idReceiver The delegate to be added at the end of the chain\r\n    function appendDelegate(\r\n        uint64 idPledge,\r\n        uint amount,\r\n        uint64 idReceiver\r\n    ) internal {\r\n        Pledge storage p = findPledge(idPledge);\r\n\r\n        require(p.delegationChain.length < MAX_DELEGATES);\r\n        uint64[] memory newDelegationChain = new uint64[](\r\n            p.delegationChain.length + 1\r\n        );\r\n        for (uint i = 0; i<p.delegationChain.length; i++) {\r\n            newDelegationChain[i] = p.delegationChain[i];\r\n        }\r\n\r\n        // Make the last item in the array the idReceiver\r\n        newDelegationChain[p.delegationChain.length] = idReceiver;\r\n\r\n        uint64 toPledge = findOrCreatePledge(\r\n            p.owner,\r\n            newDelegationChain,\r\n            0,\r\n            0,\r\n            p.oldPledge,\r\n            PledgeState.Pledged\r\n        );\r\n        doTransfer(idPledge, toPledge, amount);\r\n    }\r\n\r\n    /// @notice `appendDelegate` allows for a delegate to be added onto the\r\n    ///  end of the delegate chain for a given Pledge.\r\n    /// @param idPledge Id of the pledge thats delegate chain will be modified.\r\n    /// @param amount Quantity of value that's shifted from delegates.\r\n    /// @param q Number (or depth) to remove as delegates\r\n    function undelegate(\r\n        uint64 idPledge,\r\n        uint amount,\r\n        uint q\r\n    ) internal returns (uint64){\r\n        Pledge storage p = findPledge(idPledge);\r\n        uint64[] memory newDelegationChain = new uint64[](\r\n            p.delegationChain.length - q\r\n        );\r\n        for (uint i=0; i<p.delegationChain.length - q; i++) {\r\n            newDelegationChain[i] = p.delegationChain[i];\r\n        }\r\n        uint64 toPledge = findOrCreatePledge(\r\n            p.owner,\r\n            newDelegationChain,\r\n            0,\r\n            0,\r\n            p.oldPledge,\r\n            PledgeState.Pledged\r\n        );\r\n        doTransfer(idPledge, toPledge, amount);\r\n\r\n        return toPledge;\r\n    }\r\n\r\n    /// @notice `proposeAssignProject` proposes the assignment of a pledge\r\n    ///  to a specific project.\r\n    /// @dev This function should potentially be named more specifically.\r\n    /// @param idPledge Id of the pledge that will be assigned.\r\n    /// @param amount Quantity of value this pledge leader would be assigned.\r\n    /// @param idReceiver The project this pledge will potentially \r\n    ///  be assigned to.\r\n    function proposeAssignProject(\r\n        uint64 idPledge,\r\n        uint amount,\r\n        uint64 idReceiver\r\n    ) internal {\r\n        Pledge storage p = findPledge(idPledge);\r\n\r\n        require(getPledgeLevel(p) < MAX_INTERPROJECT_LEVEL);\r\n        require(!isProjectCanceled(idReceiver));\r\n\r\n        uint64 toPledge = findOrCreatePledge(\r\n            p.owner,\r\n            p.delegationChain,\r\n            idReceiver,\r\n            uint64(getTime() + maxCommitTime(p)),\r\n            p.oldPledge,\r\n            PledgeState.Pledged\r\n        );\r\n        doTransfer(idPledge, toPledge, amount);\r\n    }\r\n\r\n    /// @notice `doTransfer` is designed to allow for pledge amounts to be \r\n    ///  shifted around internally.\r\n    /// @param from This is the Id from which value will be transfered.\r\n    /// @param to This is the Id that value will be transfered to.\r\n    /// @param _amount The amount of value that will be transfered.\r\n    function doTransfer(uint64 from, uint64 to, uint _amount) internal {\r\n        uint amount = callPlugins(true, from, to, _amount);\r\n        if (from == to) { \r\n            return;\r\n        }\r\n        if (amount == 0) {\r\n            return;\r\n        }\r\n        Pledge storage nFrom = findPledge(from);\r\n        Pledge storage nTo = findPledge(to);\r\n        require(nFrom.amount >= amount);\r\n        nFrom.amount -= amount;\r\n        nTo.amount += amount;\r\n\r\n        Transfer(from, to, amount);\r\n        callPlugins(false, from, to, amount);\r\n    }\r\n\r\n    /// @notice `normalizePledge` only affects pledges with the Pledged PledgeState\r\n    /// and does 2 things:\r\n    ///   #1: Checks if the pledge should be committed. This means that\r\n    ///       if the pledge has an intendedProject and it is past the\r\n    ///       commitTime, it changes the owner to be the proposed project\r\n    ///       (The UI will have to read the commit time and manually do what\r\n    ///       this function does to the pledge for the end user\r\n    ///       at the expiration of the commitTime)\r\n    ///\r\n    ///   #2: Checks to make sure that if there has been a cancellation in the\r\n    ///       chain of projects, the pledge's owner has been changed\r\n    ///       appropriately.\r\n    ///\r\n    /// This function can be called by anybody at anytime on any pledge.\r\n    /// In general it can be called to force the calls of the affected \r\n    /// plugins, which also need to be predicted by the UI\r\n    /// @param idPledge This is the id of the pledge that will be normalized\r\n    function normalizePledge(uint64 idPledge) returns(uint64) {\r\n\r\n        Pledge storage p = findPledge(idPledge);\r\n\r\n        // Check to make sure this pledge hasn't already been used \r\n        // or is in the process of being used\r\n        if (p.pledgeState != PledgeState.Pledged) {\r\n            return idPledge;\r\n        }\r\n\r\n        // First send to a project if it's proposed and committed\r\n        if ((p.intendedProject > 0) && ( getTime() > p.commitTime)) {\r\n            uint64 oldPledge = findOrCreatePledge(\r\n                p.owner,\r\n                p.delegationChain,\r\n                0,\r\n                0,\r\n                p.oldPledge,\r\n                PledgeState.Pledged\r\n            );\r\n            uint64 toPledge = findOrCreatePledge(\r\n                p.intendedProject,\r\n                new uint64[](0),\r\n                0,\r\n                0,\r\n                oldPledge,\r\n                PledgeState.Pledged\r\n            );\r\n            doTransfer(idPledge, toPledge, p.amount);\r\n            idPledge = toPledge;\r\n            p = findPledge(idPledge);\r\n        }\r\n\r\n        toPledge = getOldestPledgeNotCanceled(idPledge);\r\n        if (toPledge != idPledge) {\r\n            doTransfer(idPledge, toPledge, p.amount);\r\n        }\r\n\r\n        return toPledge;\r\n    }\r\n\r\n/////////////\r\n// Plugins\r\n/////////////\r\n\r\n    /// @notice `callPlugin` is used to trigger the general functions in the\r\n    ///  plugin for any actions needed before and after a transfer happens.\r\n    ///  Specifically what this does in relation to the plugin is something\r\n    ///  that largely depends on the functions of that plugin. This function\r\n    ///  is generally called in pairs, once before, and once after a transfer.\r\n    /// @param before This toggle determines whether the plugin call is occurring\r\n    ///  before or after a transfer.\r\n    /// @param adminId This should be the Id of the *trusted* individual\r\n    ///  who has control over this plugin.\r\n    /// @param fromPledge This is the Id from which value is being transfered.\r\n    /// @param toPledge This is the Id that value is being transfered to.\r\n    /// @param context The situation that is triggering the plugin. See plugin\r\n    ///  for a full description of contexts.\r\n    /// @param amount The amount of value that is being transfered.\r\n    function callPlugin(\r\n        bool before,\r\n        uint64 adminId,\r\n        uint64 fromPledge,\r\n        uint64 toPledge,\r\n        uint64 context,\r\n        uint amount\r\n    ) internal returns (uint allowedAmount) {\r\n\r\n        uint newAmount;\r\n        allowedAmount = amount;\r\n        PledgeAdmin storage admin = findAdmin(adminId);\r\n        // Checks admin has a plugin assigned and a non-zero amount is requested\r\n        if ((address(admin.plugin) != 0) && (allowedAmount > 0)) {\r\n            // There are two seperate functions called in the plugin.\r\n            // One is called before the transfer and one after\r\n            if (before) {\r\n                newAmount = admin.plugin.beforeTransfer(\r\n                    adminId,\r\n                    fromPledge,\r\n                    toPledge,\r\n                    context,\r\n                    amount\r\n                );\r\n                require(newAmount <= allowedAmount);\r\n                allowedAmount = newAmount;\r\n            } else {\r\n                admin.plugin.afterTransfer(\r\n                    adminId,\r\n                    fromPledge,\r\n                    toPledge,\r\n                    context,\r\n                    amount\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice `callPluginsPledge` is used to apply plugin calls to\r\n    ///  the delegate chain and the intended project if there is one.\r\n    ///  It does so in either a transferring or receiving context based\r\n    ///  on the `idPledge` and  `fromPledge` parameters.\r\n    /// @param before This toggle determines whether the plugin call is occuring\r\n    ///  before or after a transfer.\r\n    /// @param idPledge This is the Id of the pledge on which this plugin\r\n    ///  is being called.\r\n    /// @param fromPledge This is the Id from which value is being transfered.\r\n    /// @param toPledge This is the Id that value is being transfered to.\r\n    /// @param amount The amount of value that is being transfered.\r\n    function callPluginsPledge(\r\n        bool before,\r\n        uint64 idPledge,\r\n        uint64 fromPledge,\r\n        uint64 toPledge,\r\n        uint amount\r\n    ) internal returns (uint allowedAmount) {\r\n        // Determine if callPlugin is being applied in a receiving\r\n        // or transferring context\r\n        uint64 offset = idPledge == fromPledge ? 0 : 256;\r\n        allowedAmount = amount;\r\n        Pledge storage p = findPledge(idPledge);\r\n\r\n        // Always call the plugin on the owner\r\n        allowedAmount = callPlugin(\r\n            before,\r\n            p.owner,\r\n            fromPledge,\r\n            toPledge,\r\n            offset,\r\n            allowedAmount\r\n        );\r\n\r\n        // Apply call plugin to all delegates\r\n        for (uint64 i=0; i<p.delegationChain.length; i++) {\r\n            allowedAmount = callPlugin(\r\n                before,\r\n                p.delegationChain[i],\r\n                fromPledge,\r\n                toPledge,\r\n                offset + i+1,\r\n                allowedAmount\r\n            );\r\n        }\r\n\r\n        // If there is an intended project also call the plugin in\r\n        // either a transferring or receiving context based on offset\r\n        // on the intended project\r\n        if (p.intendedProject > 0) {\r\n            allowedAmount = callPlugin(\r\n                before,\r\n                p.intendedProject,\r\n                fromPledge,\r\n                toPledge,\r\n                offset + 255,\r\n                allowedAmount\r\n            );\r\n        }\r\n    }\r\n\r\n\r\n    /// @notice `callPlugins` calls `callPluginsPledge` once for the transfer\r\n    ///  context and once for the receiving context. The aggregated \r\n    ///  allowed amount is then returned.\r\n    /// @param before This toggle determines whether the plugin call is occurring\r\n    ///  before or after a transfer.\r\n    /// @param fromPledge This is the Id from which value is being transferred.\r\n    /// @param toPledge This is the Id that value is being transferred to.\r\n    /// @param amount The amount of value that is being transferred.\r\n    function callPlugins(\r\n        bool before,\r\n        uint64 fromPledge,\r\n        uint64 toPledge,\r\n        uint amount\r\n    ) internal returns (uint allowedAmount) {\r\n        allowedAmount = amount;\r\n\r\n        // Call the pledges plugins in the transfer context\r\n        allowedAmount = callPluginsPledge(\r\n            before,\r\n            fromPledge,\r\n            fromPledge,\r\n            toPledge,\r\n            allowedAmount\r\n        );\r\n\r\n        // Call the pledges plugins in the receive context\r\n        allowedAmount = callPluginsPledge(\r\n            before,\r\n            toPledge,\r\n            fromPledge,\r\n            toPledge,\r\n            allowedAmount\r\n        );\r\n    }\r\n\r\n/////////////\r\n// Test functions\r\n/////////////\r\n\r\n    /// @notice Basic helper function to return the current time\r\n    function getTime() internal returns (uint) {\r\n        return now;\r\n    }\r\n\r\n    // Event Delcerations\r\n    event Transfer(uint64 indexed from, uint64 indexed to, uint amount);\r\n    event CancelProject(uint64 indexed idProject);\r\n\r\n}\r\n\r\n//File: contracts/LPPCappedMilestones.sol\r\npragma solidity ^0.4.17;\r\n\r\n/*\r\n    Copyright 2017, RJ Ewing <perissology@protonmail.com>\r\n\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n\r\n\r\n\r\n\r\ncontract LPPCappedMilestones is Escapable {\r\n    uint constant TO_OWNER = 256;\r\n    uint constant TO_INTENDEDPROJECT = 511;\r\n\r\n    LiquidPledging public liquidPledging;\r\n\r\n    struct Milestone {\r\n        uint maxAmount;\r\n        uint received;\r\n        uint canCollect;\r\n        address reviewer;\r\n        address campaignReviewer;\r\n        address recipient;\r\n        bool accepted;\r\n    }\r\n\r\n    mapping (uint64 => Milestone) milestones;\r\n\r\n\r\n    event MilestoneAccepted(uint64 indexed idProject);\r\n    event PaymentCollected(uint64 indexed idProject);\r\n\r\n    //== constructor\r\n\r\n    function LPPCappedMilestones(\r\n        LiquidPledging _liquidPledging,\r\n        address _escapeHatchCaller,\r\n        address _escapeHatchDestination\r\n    ) Escapable(_escapeHatchCaller, _escapeHatchDestination) public\r\n    {\r\n        liquidPledging = _liquidPledging;\r\n    }\r\n\r\n    //== fallback\r\n\r\n    function() payable {}\r\n\r\n    //== external\r\n\r\n    /// @dev this is called by liquidPledging before every transfer to and from\r\n    ///      a pledgeAdmin that has this contract as its plugin\r\n    /// @dev see ILiquidPledgingPlugin interface for details about context param\r\n    function beforeTransfer(\r\n        uint64 pledgeManager,\r\n        uint64 pledgeFrom,\r\n        uint64 pledgeTo,\r\n        uint64 context,\r\n        uint amount\r\n    ) external returns (uint maxAllowed)\r\n    {\r\n        require(msg.sender == address(liquidPledging));\r\n        var (, , , fromIntendedProject, , ,) = liquidPledging.getPledge(pledgeFrom);\r\n        var (, toOwner, , toIntendedProject, , , toPledgeState) = liquidPledging.getPledge(pledgeTo);\r\n        Milestone storage m;\r\n\r\n        // if m is the intendedProject, make sure m is still accepting funds (not accepted or canceled)\r\n        if (context == TO_INTENDEDPROJECT) {\r\n            m = milestones[toIntendedProject];\r\n            // don't need to check if canceled b/c lp does this\r\n            if (m.accepted) {\r\n                return 0;\r\n            }\r\n        // if the pledge is being transferred to m and is in the Pledged state, make\r\n        // sure m is still accepting funds (not accepted or canceled)\r\n        } else if (context == TO_OWNER &&\r\n            (fromIntendedProject != toOwner &&\r\n                toPledgeState == LiquidPledgingBase.PledgeState.Pledged)) {\r\n            //TODO what if milestone isn't initialized? should we throw?\r\n            // this can happen if someone adds a project through lp with this contracts address as the plugin\r\n            // we can require(maxAmount > 0);\r\n            // don't need to check if canceled b/c lp does this\r\n            m = milestones[toOwner];\r\n            if (m.accepted) {\r\n                return 0;\r\n            }\r\n        }\r\n        return amount;\r\n    }\r\n\r\n    /// @dev this is called by liquidPledging after every transfer to and from\r\n    ///      a pledgeAdmin that has this contract as its plugin\r\n    /// @dev see ILiquidPledgingPlugin interface for details about context param\r\n    function afterTransfer(\r\n        uint64 pledgeManager,\r\n        uint64 pledgeFrom,\r\n        uint64 pledgeTo,\r\n        uint64 context,\r\n        uint amount\r\n    ) external\r\n    {\r\n        require(msg.sender == address(liquidPledging));\r\n\r\n        var (, fromOwner, , , , ,) = liquidPledging.getPledge(pledgeFrom);\r\n        var (, toOwner, , , , , toPledgeState) = liquidPledging.getPledge(pledgeTo);\r\n\r\n        if (context == TO_OWNER) {\r\n            Milestone storage m;\r\n\r\n            // If fromOwner != toOwner, the means that a pledge is being committed to\r\n            // milestone m. We will accept any amount up to m.maxAmount, and return\r\n            // the rest\r\n            if (fromOwner != toOwner) {\r\n                m = milestones[toOwner];\r\n                uint returnFunds = 0;\r\n\r\n                m.received += amount;\r\n                // milestone is no longer accepting new funds\r\n                if (m.accepted) {\r\n                    returnFunds = amount;\r\n                } else if (m.received > m.maxAmount) {\r\n                    returnFunds = m.received - m.maxAmount;\r\n                }\r\n\r\n                // send any exceeding funds back\r\n                if (returnFunds > 0) {\r\n                    m.received -= returnFunds;\r\n                    liquidPledging.cancelPledge(pledgeTo, returnFunds);\r\n                }\r\n            // if the pledge has been paid, then the vault should have transferred the\r\n            // the funds to this contract. update the milestone with the amount the recipient\r\n            // can collect. this is the amount of the paid pledge\r\n            } else if (toPledgeState == LiquidPledgingBase.PledgeState.Paid) {\r\n                m = milestones[toOwner];\r\n                m.canCollect += amount;\r\n            }\r\n        }\r\n    }\r\n\r\n    //== public\r\n\r\n    function addMilestone(\r\n        string name,\r\n        string url,\r\n        uint _maxAmount,\r\n        uint64 parentProject,\r\n        address _recipient,\r\n        address _reviewer,\r\n        address _campaignReviewer\r\n    ) public\r\n    {\r\n        uint64 idProject = liquidPledging.addProject(\r\n            name,\r\n            url,\r\n            address(this),\r\n            parentProject,\r\n            uint64(0),\r\n            ILiquidPledgingPlugin(this)\r\n        );\r\n\r\n        milestones[idProject] = Milestone(\r\n            _maxAmount,\r\n            0,\r\n            0,\r\n            _reviewer,\r\n            _campaignReviewer,\r\n            _recipient,\r\n            false\r\n        );\r\n    }\r\n\r\n    function acceptMilestone(uint64 idProject) public {\r\n        bool isCanceled = liquidPledging.isProjectCanceled(idProject);\r\n        require(!isCanceled);\r\n\r\n        Milestone storage m = milestones[idProject];\r\n        require(msg.sender == m.reviewer || msg.sender == m.campaignReviewer);\r\n        require(!m.accepted);\r\n\r\n        m.accepted = true;\r\n        MilestoneAccepted(idProject);\r\n    }\r\n\r\n    function cancelMilestone(uint64 idProject) public {\r\n        Milestone storage m = milestones[idProject];\r\n        require(msg.sender == m.reviewer || msg.sender == m.campaignReviewer);\r\n        require(!m.accepted);\r\n\r\n        liquidPledging.cancelProject(idProject);\r\n    }\r\n\r\n    function withdraw(uint64 idProject, uint64 idPledge, uint amount) public {\r\n        // we don't check if canceled here.\r\n        // lp.withdraw will normalize the pledge & check if canceled\r\n        Milestone storage m = milestones[idProject];\r\n        require(msg.sender == m.recipient);\r\n        require(m.accepted);\r\n\r\n        liquidPledging.withdraw(idPledge, amount);\r\n        collect(idProject);\r\n    }\r\n\r\n    /// Bit mask used for dividing pledge amounts in mWithdraw\r\n    uint constant D64 = 0x10000000000000000;\r\n\r\n    function mWithdraw(uint[] pledgesAmounts) public {\r\n        uint64[] memory mIds = new uint64[](pledgesAmounts.length);\r\n\r\n        for (uint i = 0; i < pledgesAmounts.length; i++ ) {\r\n            uint64 idPledge = uint64(pledgesAmounts[i] & (D64-1));\r\n            var (, idProject, , , , ,) = liquidPledging.getPledge(idPledge);\r\n\r\n            mIds[i] = idProject;\r\n            Milestone storage m = milestones[idProject];\r\n            require(msg.sender == m.recipient);\r\n            require(m.accepted);\r\n        }\r\n\r\n        liquidPledging.mWithdraw(pledgesAmounts);\r\n\r\n        for (i = 0; i < mIds.length; i++ ) {\r\n            collect(mIds[i]);\r\n        }\r\n    }\r\n\r\n    function collect(uint64 idProject) public {\r\n        Milestone storage m = milestones[idProject];\r\n        require(msg.sender == m.recipient);\r\n\r\n        if (m.canCollect > 0) {\r\n            uint amount = m.canCollect;\r\n            // TODO should this assert be removed?\r\n            assert(this.balance >= amount);\r\n            m.canCollect = 0;\r\n            m.recipient.transfer(amount);\r\n            PaymentCollected(idProject);\r\n        }\r\n    }\r\n\r\n    function getMilestone(uint64 idProject) public view returns (\r\n        uint maxAmount,\r\n        uint received,\r\n        uint canCollect,\r\n        address reviewer,\r\n        address campaignReviewer,\r\n        address recipient,\r\n        bool accepted\r\n    ) {\r\n        Milestone storage m = milestones[idProject];\r\n        maxAmount = m.maxAmount;\r\n        received = m.received;\r\n        canCollect = m.canCollect;\r\n        reviewer = m.reviewer;\r\n        campaignReviewer = m.campaignReviewer;\r\n        recipient = m.recipient;\r\n        accepted = m.accepted;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"idProject\",\"type\":\"uint64\"}],\"name\":\"cancelMilestone\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"escapeHatchCaller\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"idProject\",\"type\":\"uint64\"}],\"name\":\"getMilestone\",\"outputs\":[{\"name\":\"maxAmount\",\"type\":\"uint256\"},{\"name\":\"received\",\"type\":\"uint256\"},{\"name\":\"canCollect\",\"type\":\"uint256\"},{\"name\":\"reviewer\",\"type\":\"address\"},{\"name\":\"campaignReviewer\",\"type\":\"address\"},{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"accepted\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"idProject\",\"type\":\"uint64\"}],\"name\":\"acceptMilestone\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"pledgesAmounts\",\"type\":\"uint256[]\"}],\"name\":\"mWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dac\",\"type\":\"address\"}],\"name\":\"removeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwnerCandidate\",\"type\":\"address\"}],\"name\":\"proposeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"liquidPledging\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"isTokenEscapable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"escapeHatch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"idProject\",\"type\":\"uint64\"}],\"name\":\"collect\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"pledgeManager\",\"type\":\"uint64\"},{\"name\":\"pledgeFrom\",\"type\":\"uint64\"},{\"name\":\"pledgeTo\",\"type\":\"uint64\"},{\"name\":\"context\",\"type\":\"uint64\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"afterTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"url\",\"type\":\"string\"},{\"name\":\"_maxAmount\",\"type\":\"uint256\"},{\"name\":\"parentProject\",\"type\":\"uint64\"},{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_reviewer\",\"type\":\"address\"},{\"name\":\"_campaignReviewer\",\"type\":\"address\"}],\"name\":\"addMilestone\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwnerCandidate\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"idProject\",\"type\":\"uint64\"},{\"name\":\"idPledge\",\"type\":\"uint64\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"pledgeManager\",\"type\":\"uint64\"},{\"name\":\"pledgeFrom\",\"type\":\"uint64\"},{\"name\":\"pledgeTo\",\"type\":\"uint64\"},{\"name\":\"context\",\"type\":\"uint64\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"beforeTransfer\",\"outputs\":[{\"name\":\"maxAllowed\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newEscapeHatchCaller\",\"type\":\"address\"}],\"name\":\"changeHatchEscapeCaller\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"escapeHatchDestination\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_liquidPledging\",\"type\":\"address\"},{\"name\":\"_escapeHatchCaller\",\"type\":\"address\"},{\"name\":\"_escapeHatchDestination\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"idProject\",\"type\":\"uint64\"}],\"name\":\"MilestoneAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"idProject\",\"type\":\"uint64\"}],\"name\":\"PaymentCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"}],\"name\":\"EscapeHatchBlackistedToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EscapeHatchCalled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"by\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"OwnershipRemoved\",\"type\":\"event\"}]","ContractName":"LPPCappedMilestones","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000003f45d2d5feb6b4b000d2d3b84442eeddf54a735a000000000000000000000000502bd2529df24a36dfee57335791be0ee62f8c74000000000000000000000000502bd2529df24a36dfee57335791be0ee62f8c74","Library":"","SwarmSource":"bzzr://0fde52a2bd1e159a8a59b9c9816b9aae37a7a0bbb55f0840bfb3d29ee1bb41cb"}]}