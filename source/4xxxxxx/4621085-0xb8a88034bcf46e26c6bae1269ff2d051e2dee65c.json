{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public constant returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract BasicToken is ERC20Basic {\r\n    using SafeMath for uint256;\r\n    mapping (address => Snapshot[]) balances;\r\n    mapping (address => uint256) userWithdrawalBlocks;\r\n\t\r\n    /**\r\n     * @dev 'Snapshot' is the structure that attaches a block number to a\r\n     * given value, the block number attached is the one that last changed the value\r\n     * 'fromBlock' - is the block number that the value was generated from\r\n     * 'value' - is the amount of tokens at a specific block number\r\n     */\r\n    struct Snapshot {\r\n      uint128 fromBlock;\r\n      uint128 value;\r\n    }\r\n\t\r\n\t/**\r\n\t * @dev tracks history of totalSupply\r\n\t */\r\n    Snapshot[] totalSupplyHistory;\r\n    \r\n    /**\r\n     * @dev track history of 'ETH balance' for dividends\r\n     */\r\n    Snapshot[] balanceForDividendsHistory;\r\n\t\r\n\t/**\r\n\t* @dev transfer token for a specified address\r\n\t* @param to - the address to transfer to.\r\n\t* @param value - the amount to be transferred.\r\n\t*/\r\n\tfunction transfer(address to, uint256 value) public returns (bool) {\r\n        return doTransfer(msg.sender, to, value);\r\n\t}\r\n\t\r\n\t/**\r\n\t * @dev internal function for transfers handling\r\n\t */\r\n\tfunction doTransfer(address _from, address _to, uint _amount) internal returns(bool) {\r\n\t   if (_amount == 0) {\r\n\t\t   return true;\r\n\t   }\r\n     \r\n\t   // Do not allow transfer to 0x0 or the token contract itself\r\n\t   require((_to != 0) && (_to != address(this)));\r\n\r\n\t   // If the amount being transfered is more than the balance of the\r\n\t   //  account the transfer returns false\r\n\t   var previousBalanceFrom = balanceOfAt(_from, block.number);\r\n\t   if (previousBalanceFrom < _amount) {\r\n\t\t   return false;\r\n\t   }\r\n\r\n\t   // First update the balance array with the new value for the address\r\n\t   //  sending the tokens\r\n\t   updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\r\n\r\n\t   // Then update the balance array with the new value for the address\r\n\t   //  receiving the tokens\r\n\t   var previousBalanceTo = balanceOfAt(_to, block.number);\r\n\t   require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\r\n\t   updateValueAtNow(balances[_to], previousBalanceTo + _amount);\r\n\r\n\t   // An event to make the transfer easy to find on the blockchain\r\n\t   Transfer(_from, _to, _amount);\r\n\r\n\t   return true;\r\n    }\r\n    \r\n\t/**\r\n\t* @dev Gets the balance of the specified address.\r\n\t* @param _owner The address to query the the balance of. \r\n\t* @return An uint256 representing the amount owned by the passed address.\r\n\t*/\r\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance) {\r\n\t\treturn balanceOfAt(_owner, block.number);\r\n\t}\r\n\r\n    /**\r\n     * @dev Queries the balance of `_owner` at a specific `_blockNumber`\r\n     * @param _owner The address from which the balance will be retrieved\r\n     * @param _blockNumber The block number when the balance is queried\r\n     * @return The balance at `_blockNumber`\r\n     */\r\n    function balanceOfAt(address _owner, uint _blockNumber) public constant returns (uint) {\r\n        //  These next few lines are used when the balance of the token is\r\n        //  requested before a check point was ever created for this token\r\n        if ((balances[_owner].length == 0)|| (balances[_owner][0].fromBlock > _blockNumber)) {\r\n\t\t\treturn 0; \r\n        } else {\r\n            return getValueAt(balances[_owner], _blockNumber);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Total amount of tokens at a specific `_blockNumber`.\r\n     * @param _blockNumber The block number when the totalSupply is queried\r\n     * @return The total amount of tokens at `_blockNumber`\r\n     */\r\n    function totalSupplyAt(uint _blockNumber) public constant returns(uint) {\r\n        // These next few lines are used when the totalSupply of the token is\r\n        // requested before a check point was ever created for this token\r\n        if ((totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\r\n\t\t\treturn 0;\r\n        } else {\r\n            return getValueAt(totalSupplyHistory, _blockNumber);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev `getValueAt` retrieves the number of tokens at a given block number\r\n     * @param checkpoints The history of values being queried\r\n     * @param _block The block number to retrieve the value at\r\n     * @return The number of tokens being queried\r\n     */\r\n    function getValueAt(Snapshot[] storage checkpoints, uint _block) constant internal returns (uint) {\r\n        if (checkpoints.length == 0) return 0;\r\n\r\n        // Shortcut for the actual value\r\n        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\r\n            return checkpoints[checkpoints.length-1].value;\r\n        if (_block < checkpoints[0].fromBlock) return 0;\r\n\r\n        // Binary search of the value in the array\r\n        uint min = 0;\r\n        uint max = checkpoints.length-1;\r\n        while (max > min) {\r\n            uint mid = (max + min + 1)/ 2;\r\n            if (checkpoints[mid].fromBlock<=_block) {\r\n                min = mid;\r\n            } else {\r\n                max = mid-1;\r\n            }\r\n        }\r\n        return checkpoints[min].value;\r\n    }\r\n\r\n    /**\r\n     * @dev `updateValueAtNow` used to update the `balances` map and the `totalSupplyHistory`\r\n     * @param checkpoints The history of data being updated\r\n     * @param _value The new number of tokens\r\n     */ \r\n    function updateValueAtNow(Snapshot[] storage checkpoints, uint _value) internal  {\r\n        if ((checkpoints.length == 0) || (checkpoints[checkpoints.length -1].fromBlock < block.number)) {\r\n           Snapshot storage newCheckPoint = checkpoints[ checkpoints.length++ ];\r\n           newCheckPoint.fromBlock =  uint128(block.number);\r\n           newCheckPoint.value = uint128(_value);\r\n        } else {\r\n           Snapshot storage oldCheckPoint = checkpoints[checkpoints.length-1];\r\n           oldCheckPoint.value = uint128(_value);\r\n        }\r\n    }\r\n\t\r\n    /**\r\n     * @dev This function makes it easy to get the total number of tokens\r\n     * @return The total number of tokens\r\n     */\r\n    function redeemedSupply() public constant returns (uint) {\r\n        return totalSupplyAt(block.number);\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));      \r\n    owner = newOwner;\r\n  }\r\n}\r\n\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) allowed;\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n\t  return doTransfer(_from, _to, _value);\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    // To change the approve amount you first have to reduce the addresses`\r\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n    //  already 0 to mitigate the race condition described here:\r\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n}\r\n\r\ncontract MintableToken is StandardToken {\r\n  event Mint(address indexed to, uint256 amount);\r\n  event MintFinished();\r\n  \r\n  bool public mintingFinished = false;\r\n\r\n  string public name = \"Honey Mining Token\";\t\t\r\n  string public symbol = \"HMT\";\t\t\r\n  uint8 public decimals = 8;\t\t\r\n\r\n  modifier canMint() {\r\n    require(!mintingFinished);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to mint tokens\r\n   * @param _to The address that will receive the minted tokens.\r\n   * @param _amount The amount of tokens to mint.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function mint(address _to, uint256 _amount) public canMint returns (bool) {\r\n    totalSupply = totalSupply.add(_amount);\r\n\tuint curTotalSupply = redeemedSupply();\r\n\trequire(curTotalSupply + _amount >= curTotalSupply); // Check for overflow\r\n\tuint previousBalanceTo = balanceOf(_to);\r\n\trequire(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\r\n\tupdateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\r\n    updateValueAtNow(balances[_to], previousBalanceTo + _amount);\r\n    Mint(_to, _amount);\r\n    Transfer(0x0, _to, _amount);\r\n    return true;\r\n  }\r\n  \r\n  /**\r\n   * @dev Function to record snapshot block and amount\r\n   */\r\n  function recordDeposit(uint256 _amount) public {\r\n\t updateValueAtNow(balanceForDividendsHistory, _amount);\r\n  }\r\n  \r\n  /**\r\n   * @dev Function to stop minting new tokens.\r\n   * @return True if the operation was successful.\r\n   */\r\n  function finishMinting() public returns (bool) {\r\n    mintingFinished = true;\r\n    MintFinished();\r\n    return true;\r\n  }\r\n  \r\n  /**\r\n   * @dev Function to calculate dividends\r\n   * @return awailable for withdrawal ethere (wei value)\r\n   */\r\n  function awailableDividends(address userAddress) public view returns (uint256) {\r\n      uint256 userLastWithdrawalBlock = userWithdrawalBlocks[userAddress];\r\n      uint256 amountForWithdraw = 0;\r\n      for(uint i = 0; i<=balanceForDividendsHistory.length-1; i++){\r\n          Snapshot storage snapshot = balanceForDividendsHistory[i];\r\n          if(userLastWithdrawalBlock < snapshot.fromBlock)\r\n            amountForWithdraw = amountForWithdraw.add(balanceOfAt(userAddress, snapshot.fromBlock).mul(snapshot.value).div(totalSupplyAt(snapshot.fromBlock)));\r\n      }\r\n      return amountForWithdraw;\r\n  }\r\n  \r\n  /**\r\n   * @dev Function to record user withdrawal \r\n   */\r\n  function recordWithdraw(address userAddress) public {\r\n    userWithdrawalBlocks[userAddress] = balanceForDividendsHistory[balanceForDividendsHistory.length-1].fromBlock;\r\n  }\r\n}\r\n\r\ncontract HoneyMiningToken is Ownable {\r\n    \r\n  using SafeMath for uint256;\r\n\r\n  MintableToken public token;\r\n  /**\r\n   * @dev Info of max supply\r\n   */\r\n  uint256 public maxSupply = 300000000000000;\r\n  \r\n  /**\r\n   * event for token purchase logging\r\n   * @param purchaser who paid for the tokens, basically - 0x0, but could be user address on refferal case\r\n   * @param beneficiary who got the tokens\r\n   * @param value weis paid for purchase\r\n   * @param amount - of tokens purchased\r\n   */\r\n  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\r\n  \r\n  /**\r\n   * event for referral comission logging\r\n   * @param purchaser who paid for the tokens\r\n   * @param beneficiary who got the bonus tokens\r\n   * @param amount - of tokens as ref reward\r\n   */\r\n  event ReferralBonus(address indexed purchaser, address indexed beneficiary, uint amount);\r\n  \r\n   /**\r\n   * event for token dividends deposit logging\r\n   * @param amount - amount of ETH deposited\r\n   */\r\n  event DepositForDividends(uint256 indexed amount);\r\n  \r\n  /**\r\n   * event for dividends withdrawal logging \r\n   * @param holder - who has the tokens\r\n   * @param amount - amount of ETH which was withdraw\r\n  */\r\n  event WithdrawDividends(address indexed holder, uint256 amount);\r\n\r\n  /**\r\n   * event for dev rewards logging\r\n   * @param purchaser - who paid for the tokens\r\n   * @param amount  - representation of dev reward\r\n   */\r\n  event DevReward(address purchaser, uint amount);\r\n\r\n  function HoneyMiningToken() public {\r\n    token = new MintableToken();\r\n  }\r\n\r\n  /**\r\n   * @dev fallback function can be used to buy tokens\r\n   */\r\n  function () public payable {buyTokens(0x0);}\r\n\r\n  /**\r\n   * @dev low level token purchase function\r\n   * @param referrer - optional parameter for ref bonus\r\n   */\r\n  function buyTokens(address referrer) public payable {\r\n    require(msg.sender != 0x0);\r\n    require(msg.sender != referrer);\r\n    require(validPurchase());\r\n    \r\n    //we dont need 18 decimals - and will use only 8\r\n    uint256 amount = msg.value.div(10000000000);\r\n    \r\n    // calculate token amount to be created\r\n    uint256 tokens = amount.mul(rate());\r\n    require(tokens >= 100000000);\r\n    uint256 devTokens = tokens.mul(30).div(100);\r\n    if(referrer != 0x0){\r\n       require(token.balanceOf(referrer) >= 100000000);\r\n       // 2.5% for referral and referrer\r\n       uint256 refTokens = tokens.mul(25).div(1000);\r\n       //tokens = tokens+refTokens;\r\n       require(maxSupply.sub(redeemedSupply()) >= tokens.add(refTokens.mul(2)).add(devTokens));\r\n       \r\n       //generate tokens for purchser\r\n       token.mint(msg.sender, tokens.add(refTokens));\r\n       TokenPurchase(msg.sender, msg.sender, amount, tokens.add(refTokens));\r\n       token.mint(referrer, refTokens);\r\n       ReferralBonus(msg.sender, referrer, refTokens);\r\n       \r\n    } else{\r\n        require(maxSupply.sub(redeemedSupply())>=tokens.add(devTokens));\r\n        //updatedReddemedSupply = redeemedSupply().add(tokens.add(devTokens));\r\n        \r\n        //generate tokens for purchser\r\n        token.mint(msg.sender, tokens);\r\n    \r\n        // log purchase\r\n        TokenPurchase(msg.sender, msg.sender, amount, tokens);\r\n    }\r\n    token.mint(owner, devTokens);\r\n    DevReward(msg.sender, devTokens);\r\n    forwardFunds();\r\n  }\r\n\r\n  /**\r\n   * @return true if the transaction can buy tokens\r\n   */\r\n  function validPurchase() internal constant returns (bool) {\r\n    return !hasEnded() && msg.value != 0;\r\n  }\r\n\r\n  /**\r\n   * @return true if sale is over\r\n   */\r\n  function hasEnded() public constant returns (bool) {\r\n    return maxSupply <= redeemedSupply();\r\n  }\r\n  \r\n  /**\r\n   * @dev get current user balance\r\n   * @param userAddress - address of user\r\n   * @return current balance of tokens\r\n   */\r\n  function checkBalance(address userAddress) public constant returns (uint){\r\n      return token.balanceOf(userAddress);\r\n  }\r\n  \r\n  /**\r\n   * @dev get user balance of tokens on specific block\r\n   * @param userAddress - address of user\r\n   * @param targetBlock - block number\r\n   * @return address balance on block\r\n   */\r\n  function checkBalanceAt(address userAddress, uint256 targetBlock) public constant returns (uint){\r\n      return token.balanceOfAt(userAddress, targetBlock);\r\n  }\r\n  \r\n  /**\r\n   * @dev get awailable dividends for withdrawal\r\n   * @param userAddress - target \r\n   * @return amount of ether (wei value) for current user\r\n   */\r\n  function awailableDividends(address userAddress) public constant returns (uint){\r\n    return token.awailableDividends(userAddress);\r\n  }\r\n  \r\n  /**\r\n   * @return total purchased tokens value\r\n   */\r\n  function redeemedSupply() public view returns (uint){\r\n    return token.totalSupply();\r\n  }\r\n  \r\n  /**\r\n   * @dev user-related method for withdrawal dividends\r\n   */\r\n  function withdrawDividends() public {\r\n    uint _amount = awailableDividends(msg.sender);\r\n    require(_amount > 0);\r\n    msg.sender.transfer(_amount);\r\n    token.recordWithdraw(msg.sender);\r\n    WithdrawDividends(msg.sender, _amount);\r\n  }\r\n  \r\n  /**\r\n   * @dev function for deposit ether to token address as/for dividends\r\n   */\r\n  function depositForDividends() public payable onlyOwner {\r\n      require(msg.value > 0);\r\n      token.recordDeposit(msg.value);\r\n      DepositForDividends(msg.value);\r\n  }\r\n  \r\n  function stopSales() public onlyOwner{\r\n   maxSupply = token.totalSupply();\r\n  }\r\n   \r\n  function forwardFunds() internal {\r\n    owner.transfer(msg.value);\r\n  }\r\n  \r\n  function rate() internal constant returns (uint) {\r\n    if(redeemedSupply() < 1000000000000)\r\n        return 675;\r\n    else if (redeemedSupply() < 5000000000000)\r\n        return 563;\r\n    else\r\n        return 450;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"mintingFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"recordDeposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"recordWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"balanceOfAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"awailableDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishMinting\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"totalSupplyAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"redeemedSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"MintFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"MintableToken","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://03dff0794d040fcfa6fac5b018e8d8970ef1d5d94c491467d0ea8459c40f6f1d"}]}