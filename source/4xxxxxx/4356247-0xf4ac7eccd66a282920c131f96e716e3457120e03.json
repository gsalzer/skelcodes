{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.4;\r\n\r\n \r\n\r\n//Buffer overflow implementation\r\n\r\ncontract Math {\r\n\r\n \r\n\r\n    function safeMul(uint a, uint b) internal returns (uint) {\r\n\r\n        uint c = a * b;\r\n\r\n        assert(a != 0 && b != 0 );\r\n\r\n        return c;\r\n\r\n    }\r\n\r\n \r\n\r\n    function safeSub(uint a, uint b) internal returns (uint) {\r\n\r\n        assert(b <= a);\r\n\r\n        return a - b;\r\n\r\n    }\r\n\r\n \r\n\r\n    function safeAdd(uint a, uint b) internal returns (uint) {\r\n\r\n        uint c = a + b;\r\n\r\n        assert(b <= c && c >= a);\r\n\r\n        return c;\r\n\r\n   }\r\n\r\n \r\n\r\n}\r\n\r\n \r\n\r\ncontract ERC20 {\r\n\r\n \r\n\r\n    function transfer(address to, uint value) returns (bool success) {\r\n\r\n        if (tokenOwned[msg.sender] >= value && tokenOwned[to] + value > tokenOwned[to]) {\r\n\r\n            tokenOwned[msg.sender] -= value;\r\n\r\n            tokenOwned[to] += value;\r\n\r\n            Transfer(msg.sender, to, value);\r\n\r\n            return true;\r\n\r\n        } else { return false; }\r\n\r\n    }\r\n\r\n \r\n\r\n    function transferFrom(address from, address to, uint value) returns (bool success) {\r\n\r\n        if (tokenOwned[from] >= value && allowed[from][msg.sender] >= value && tokenOwned[to] + value > tokenOwned[to]) {\r\n\r\n            tokenOwned[to] += value;\r\n\r\n            tokenOwned[from] -= value;\r\n\r\n            allowed[from][msg.sender] -= value;\r\n\r\n            Transfer(from, to, value);\r\n\r\n            return true;\r\n\r\n        } else { return false; }\r\n\r\n    }\r\n\r\n \r\n\r\n    function balanceOf(address owner) constant returns (uint balance) {\r\n\r\n        return tokenOwned[owner];\r\n\r\n    }\r\n\r\n \r\n\r\n    function approve(address spender, uint value) returns (bool success) {\r\n\r\n        allowed[msg.sender][spender] = value;\r\n\r\n        Approval(msg.sender, spender, value);\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n \r\n\r\n    function allowance(address owner, address spender) constant returns (uint remaining) {\r\n\r\n        return allowed[owner][spender];\r\n\r\n    }\r\n\r\n \r\n\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n\r\n \r\n\r\n    mapping(address => uint) internal tokenOwned; // Contract field for storing token balance owned by certain address\r\n\r\n \r\n\r\n    mapping (address => mapping (address => uint)) allowed;\r\n\r\n \r\n\r\n    uint public totalSupply;\r\n\r\n \r\n\r\n    string public name = \"BitMohar\";\r\n\r\n \r\n\r\n    string public symbol = \"MOH\";\r\n\r\n \r\n\r\n    uint public decimals = 10;\r\n\r\n \r\n\r\n}\r\n\r\n \r\n\r\n//TokenDistibution contract inherits Math, ERC20 contracts, this class instatiates the token distribution process\r\n\r\n//This contract implements time windowed distribution of tokens, during each time window a slice of total token is distributed based emission curve\r\n\r\n//Once the uppercap of the slice of total tokens is reached, the contract no longer distributes the token.\r\n\r\ncontract TokenDistribution is Math, ERC20 {\r\n\r\n \r\n\r\n    //assigns owner to the contract & initilizes the number of tranches\r\n\r\n    function TokenDistribution() {\r\n\r\n        owner = msg.sender;\r\n\r\n \r\n\r\n        totalSupply = 15000000000000000000; // Total supply of tokens with 10 decimal places\r\n\r\n        startBlock = 4267514;\r\n\r\n        emissionPerblock = 80; //considering 25 secs a block generation with 10 decimal places\r\n\r\n        blocksPerYear = 10000000; //considering 25 secs a block\r\n\r\n        preMined = 9000000000000000000;\r\n\r\n        tokensMinted = 0;\r\n\r\n        preMineDone = false;\r\n\r\n \r\n\r\n    }\r\n\r\n \r\n\r\n    function preMine() returns (bool z) {\r\n\r\n        if(msg.sender == owner && !preMineDone) {\r\n\r\n            tokenOwned[0x60212b87C6e106d3852890FE6e8d00db3D99d002] = 9000000000000000000;\r\n\r\n            preMineDone = true;\r\n\r\n            return true;\r\n\r\n        } else {\r\n\r\n            return false;\r\n\r\n        }\r\n\r\n    }\r\n\r\n \r\n\r\n    function mine() returns (bool z) {\r\n\r\n        uint blockTime = (((block.number - startBlock) / blocksPerYear) + 1);\r\n\r\n        uint currentEmission = emissionPerblock / blockTime;\r\n\r\n        uint emittedBlocks = startBlock;\r\n\r\n        if(currentEmission != emissionPerblock) { //in case of halving and later time\r\n\r\n            emittedBlocks = startBlock + (blocksPerYear * blockTime);\r\n\r\n        }\r\n\r\n        uint mined = 0;\r\n\r\n        if(blockTime > 1) { //after halving\r\n\r\n            uint prevMinted = 0;\r\n\r\n            for (uint i = 1; i <= blockTime; i++) {\r\n\r\n                prevMinted += (blocksPerYear * (emissionPerblock / i));\r\n\r\n            }\r\n\r\n            prevMinted += (block.number - emittedBlocks) * currentEmission;\r\n\r\n            mined = safeSub(prevMinted, tokensMinted);\r\n\r\n        } else {\r\n\r\n            mined = safeSub((block.number - emittedBlocks) * currentEmission, tokensMinted);\r\n\r\n        }\r\n\r\n \r\n\r\n        if(safeAdd(preMined, safeAdd(mined, tokensMinted)) > totalSupply) {\r\n\r\n            return false;\r\n\r\n        } else {\r\n\r\n            tokenOwned[msg.sender] = safeAdd(tokenOwned[msg.sender], mined);\r\n\r\n            tokensMinted = safeAdd(tokensMinted, mined);\r\n\r\n            return true;\r\n\r\n        }\r\n\r\n    }\r\n\r\n \r\n\r\n    function changeTotalSupply(uint _totalSupply) returns (bool x){\r\n\r\n        if(msg.sender == owner){\r\n\r\n            totalSupply = _totalSupply;\r\n\r\n            return true;\r\n\r\n        }else{\r\n\r\n            return false;\r\n\r\n        }\r\n\r\n    }\r\n\r\n \r\n\r\n    function additionalPreMine(uint _supply) returns (bool x){\r\n\r\n        if(msg.sender == owner){\r\n\r\n            tokenOwned[msg.sender] = safeAdd(tokenOwned[msg.sender], _supply);\r\n\r\n            return true;\r\n\r\n        }else{\r\n\r\n            return false;\r\n\r\n        }\r\n\r\n    }\r\n\r\n \r\n\r\n    address owner;\r\n\r\n    mapping (address => uint) internal etherSent; // Contract field for storing how much Ether was sent from certain address\r\n\r\n    uint startBlock;\r\n\r\n    uint emissionPerblock; //considering 25 secs a block generation with 10 decimal places\r\n\r\n    uint blocksPerYear; //considering 25 secs a block\r\n\r\n    uint preMined;\r\n\r\n    uint tokensMinted;\r\n\r\n    bool preMineDone;\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_supply\",\"type\":\"uint256\"}],\"name\":\"additionalPreMine\",\"outputs\":[{\"name\":\"x\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"preMine\",\"outputs\":[{\"name\":\"z\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_totalSupply\",\"type\":\"uint256\"}],\"name\":\"changeTotalSupply\",\"outputs\":[{\"name\":\"x\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"mine\",\"outputs\":[{\"name\":\"z\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"TokenDistribution","CompilerVersion":"v0.4.16+commit.d7661dd9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://39ce2ccfefe0e4accb132bd680eee747355acf1a27ab875205948422c3b19a9d"}]}