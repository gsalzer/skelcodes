{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.15;\r\n\r\ncontract BTCRelay {\r\n    function getLastBlockHeight() public returns (int);\r\n    function getBlockchainHead() public returns (int);\r\n    function getFeeAmount(int blockHash) public returns (int);\r\n    function getBlockHeader(int blockHash) public returns (bytes32[5]);\r\n    function storeBlockHeader(bytes blockHeader) public returns (int);\r\n}\r\n\r\ncontract Escrow {\r\n    function deposit(address recipient) payable;\r\n}\r\n\r\ncontract EthereumLottery {\r\n    uint constant GAS_LIMIT_DEPOSIT = 300000;\r\n    uint constant GAS_LIMIT_BUY = 450000;\r\n\r\n    struct Lottery {\r\n        uint jackpot;\r\n        int decidingBlock;\r\n        uint numTickets;\r\n        uint numTicketsSold;\r\n        uint ticketPrice;\r\n        int winningTicket;\r\n        address winner;\r\n        uint finalizationBlock;\r\n        address finalizer;\r\n        string message;\r\n        mapping (uint => address) tickets;\r\n        int nearestKnownBlock;\r\n        int nearestKnownBlockHash;\r\n    }\r\n\r\n    address public owner;\r\n    address public admin;\r\n    address public proposedOwner;\r\n\r\n    int public id = -1;\r\n    uint public lastInitTimestamp;\r\n    uint public lastSaleTimestamp;\r\n\r\n    uint public recentActivityIdx;\r\n    uint[1000] public recentActivity;\r\n\r\n    mapping (int => Lottery) public lotteries;\r\n\r\n    address public btcRelay;\r\n    address public escrow;\r\n\r\n    enum Reason { TicketSaleClosed, TicketAlreadySold, InsufficientGas }\r\n    event PurchaseFailed(address indexed buyer, uint mark, Reason reason);\r\n    event PurchaseSuccessful(address indexed buyer, uint mark);\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdminOrOwner {\r\n        require(msg.sender == owner || msg.sender == admin);\r\n        _;\r\n    }\r\n\r\n    modifier afterInitialization {\r\n        require(id >= 0);\r\n        _;\r\n    }\r\n\r\n    function EthereumLottery(address _btcRelay,\r\n                             address _escrow) {\r\n        owner = msg.sender;\r\n        admin = msg.sender;\r\n        btcRelay = _btcRelay;\r\n        escrow = _escrow;\r\n    }\r\n\r\n    function needsInitialization() constant returns (bool) {\r\n        return id == -1 || lotteries[id].finalizationBlock > 0;\r\n    }\r\n\r\n    function initLottery(uint _jackpot, uint _numTickets, uint _ticketPrice)\r\n             onlyAdminOrOwner {\r\n        require(needsInitialization());\r\n        require(_numTickets * _ticketPrice > _jackpot);\r\n\r\n        id += 1;\r\n        lotteries[id].jackpot = _jackpot;\r\n        lotteries[id].decidingBlock = -1;\r\n        lotteries[id].numTickets = _numTickets;\r\n        lotteries[id].ticketPrice = _ticketPrice;\r\n        lotteries[id].winningTicket = -1;\r\n\r\n        lastInitTimestamp = block.timestamp;\r\n        lastSaleTimestamp = 0;\r\n    }\r\n\r\n    function buyTickets(uint[] _tickets, uint _mark, bytes _extraData)\r\n             payable afterInitialization {\r\n        if (msg.gas < GAS_LIMIT_BUY) {\r\n            PurchaseFailed(msg.sender, _mark, Reason.InsufficientGas);\r\n            return;\r\n        }\r\n\r\n        if (lotteries[id].numTicketsSold == lotteries[id].numTickets) {\r\n            PurchaseFailed(msg.sender, _mark, Reason.TicketSaleClosed);\r\n            return;\r\n        }\r\n\r\n        require(_tickets.length > 0);\r\n        require(msg.value == _tickets.length * lotteries[id].ticketPrice);\r\n\r\n        for (uint i = 0; i < _tickets.length; i++) {\r\n            uint ticket = _tickets[i];\r\n            require(ticket >= 0);\r\n            require(ticket < lotteries[id].numTickets);\r\n\r\n            if (lotteries[id].tickets[ticket] != 0) {\r\n                PurchaseFailed(msg.sender, _mark, Reason.TicketAlreadySold);\r\n                return;\r\n            }\r\n        }\r\n\r\n        for (i = 0; i < _tickets.length; i++) {\r\n            ticket = _tickets[i];\r\n            lotteries[id].tickets[ticket] = msg.sender;\r\n            recentActivity[recentActivityIdx] = ticket;\r\n\r\n            recentActivityIdx += 1;\r\n            if (recentActivityIdx >= recentActivity.length) {\r\n                recentActivityIdx = 0;\r\n            }\r\n        }\r\n\r\n        lotteries[id].numTicketsSold += _tickets.length;\r\n        lastSaleTimestamp = block.timestamp;\r\n\r\n        BTCRelay(btcRelay).storeBlockHeader(_extraData);\r\n\r\n        PurchaseSuccessful(msg.sender, _mark);\r\n    }\r\n\r\n    function needsBlockFinalization()\r\n             afterInitialization constant returns (bool) {\r\n        // Check the timestamp of the latest block known to BTCRelay\r\n        // and require it to be no more than 2 hours older than the\r\n        // timestamp of our block. This should ensure that BTCRelay\r\n        // is reasonably up to date.\r\n        uint btcTimestamp;\r\n        int blockHash = BTCRelay(btcRelay).getBlockchainHead();\r\n        (,btcTimestamp) = getBlockHeader(blockHash);\r\n\r\n        uint delta = 0;\r\n        if (btcTimestamp < block.timestamp) {\r\n            delta = block.timestamp - btcTimestamp;\r\n        }\r\n\r\n        return delta < 2 * 60 * 60 &&\r\n               lotteries[id].numTicketsSold == lotteries[id].numTickets &&\r\n               lotteries[id].decidingBlock == -1;\r\n    }\r\n\r\n    function finalizeBlock()\r\n             afterInitialization {\r\n        require(needsBlockFinalization());\r\n\r\n        // At this point we know that the timestamp of the latest block\r\n        // known to BTCRelay is within 2 hours of what the Ethereum network\r\n        // considers 'now'. If we assume this to be correct within +/- 3 hours,\r\n        // we can conclude that 'out there' in the real world at most 5 hours\r\n        // have passed. Assuming an actual block time of 9 minutes for Bitcoin,\r\n        // we can use the Poisson distribution to calculate, that if we wait for\r\n        // 54 more blocks, then the probability for all of these 54 blocks\r\n        // having already been mined in 5 hours is less than 0.1 %.\r\n        int blockHeight = BTCRelay(btcRelay).getLastBlockHeight();\r\n        lotteries[id].decidingBlock = blockHeight + 54;\r\n    }\r\n\r\n    function needsLotteryFinalization()\r\n             afterInitialization constant returns (bool) {\r\n        int blockHeight = BTCRelay(btcRelay).getLastBlockHeight();\r\n        return lotteries[id].decidingBlock != -1 &&\r\n               blockHeight >= lotteries[id].decidingBlock + 6 &&\r\n               lotteries[id].finalizationBlock == 0;\r\n    }\r\n\r\n    function finalizeLottery(uint _steps)\r\n             afterInitialization {\r\n        require(needsLotteryFinalization());\r\n\r\n        if (lotteries[id].nearestKnownBlock != lotteries[id].decidingBlock) {\r\n            walkTowardsBlock(_steps);\r\n        } else {\r\n            int winningTicket = lotteries[id].nearestKnownBlockHash %\r\n                                int(lotteries[id].numTickets);\r\n            address winner = lotteries[id].tickets[uint(winningTicket)];\r\n\r\n            lotteries[id].winningTicket = winningTicket;\r\n            lotteries[id].winner = winner;\r\n            lotteries[id].finalizationBlock = block.number;\r\n            lotteries[id].finalizer = tx.origin;\r\n\r\n            if (winner != 0) {\r\n                uint value = lotteries[id].jackpot;\r\n                bool successful =\r\n                    winner.call.gas(GAS_LIMIT_DEPOSIT).value(value)();\r\n                if (!successful) {\r\n                    Escrow(escrow).deposit.value(value)(winner);\r\n                }\r\n            }\r\n\r\n            var _ = admin.call.gas(GAS_LIMIT_DEPOSIT).value(this.balance)();\r\n        }\r\n    }\r\n\r\n    function walkTowardsBlock(uint _steps) internal {\r\n        int blockHeight;\r\n        int blockHash;\r\n        if (lotteries[id].nearestKnownBlock == 0) {\r\n            blockHeight = BTCRelay(btcRelay).getLastBlockHeight();\r\n            blockHash = BTCRelay(btcRelay).getBlockchainHead();\r\n        } else {\r\n            blockHeight = lotteries[id].nearestKnownBlock;\r\n            blockHash = lotteries[id].nearestKnownBlockHash;\r\n        }\r\n\r\n        // Walk only a few steps to keep an upper limit on gas costs.\r\n        for (uint step = 0; step < _steps; step++) {\r\n            blockHeight -= 1;\r\n            (blockHash,) = getBlockHeader(blockHash);\r\n\r\n            if (blockHeight == lotteries[id].decidingBlock) { break; }\r\n        }\r\n\r\n        // Store the progress to pick up from there next time.\r\n        lotteries[id].nearestKnownBlock = blockHeight;\r\n        lotteries[id].nearestKnownBlockHash = blockHash;\r\n    }\r\n\r\n    function getBlockHeader(int blockHash)\r\n             internal returns (int prevBlockHash, uint timestamp) {\r\n        // We expect free access to BTCRelay.\r\n        int fee = BTCRelay(btcRelay).getFeeAmount(blockHash);\r\n        require(fee == 0);\r\n\r\n        // Code is based on tjade273's BTCRelayTools.\r\n        bytes32[5] memory blockHeader =\r\n            BTCRelay(btcRelay).getBlockHeader(blockHash);\r\n\r\n        prevBlockHash = 0;\r\n        for (uint i = 0; i < 32; i++) {\r\n            uint pos = 68 + i;  // prev. block hash starts at position 68\r\n            byte data = blockHeader[pos / 32][pos % 32];\r\n            prevBlockHash = prevBlockHash | int(data) * int(0x100 ** i);\r\n        }\r\n\r\n        timestamp = 0;\r\n        for (i = 0; i < 4; i++) {\r\n            pos = 132 + i;  // timestamp starts at position 132\r\n            data = blockHeader[pos / 32][pos % 32];\r\n            timestamp = timestamp | uint(data) * uint(0x100 ** i);\r\n        }\r\n\r\n        return (prevBlockHash, timestamp);\r\n    }\r\n\r\n    function getMessageLength(string _message) constant returns (uint) {\r\n        return bytes(_message).length;\r\n    }\r\n\r\n    function setMessage(int _id, string _message)\r\n             afterInitialization {\r\n        require(lotteries[_id].winner != 0);\r\n        require(lotteries[_id].winner == msg.sender);\r\n        require(getMessageLength(_message) <= 500);\r\n        lotteries[_id].message = _message;\r\n    }\r\n\r\n    function getLotteryDetailsA(int _id)\r\n             constant returns (int _actualId, uint _jackpot,\r\n                               int _decidingBlock,\r\n                               uint _numTickets, uint _numTicketsSold,\r\n                               uint _lastSaleTimestamp, uint _ticketPrice) {\r\n        if (_id == -1) {\r\n            _actualId = id;\r\n        } else {\r\n            _actualId = _id;\r\n        }\r\n        _jackpot = lotteries[_actualId].jackpot;\r\n        _decidingBlock = lotteries[_actualId].decidingBlock;\r\n        _numTickets = lotteries[_actualId].numTickets;\r\n        _numTicketsSold = lotteries[_actualId].numTicketsSold;\r\n        _lastSaleTimestamp = lastSaleTimestamp;\r\n        _ticketPrice = lotteries[_actualId].ticketPrice;\r\n    }\r\n\r\n    function getLotteryDetailsB(int _id)\r\n             constant returns (int _actualId,\r\n                               int _winningTicket, address _winner,\r\n                               uint _finalizationBlock, address _finalizer,\r\n                               string _message,\r\n                               int _prevLottery, int _nextLottery,\r\n                               int _blockHeight) {\r\n        if (_id == -1) {\r\n            _actualId = id;\r\n        } else {\r\n            _actualId = _id;\r\n        }\r\n        _winningTicket = lotteries[_actualId].winningTicket;\r\n        _winner = lotteries[_actualId].winner;\r\n        _finalizationBlock = lotteries[_actualId].finalizationBlock;\r\n        _finalizer = lotteries[_actualId].finalizer;\r\n        _message = lotteries[_actualId].message;\r\n\r\n        if (_actualId == 0) {\r\n            _prevLottery = -1;\r\n        } else {\r\n            _prevLottery = _actualId - 1;\r\n        }\r\n        if (_actualId == id) {\r\n            _nextLottery = -1;\r\n        } else {\r\n            _nextLottery = _actualId + 1;\r\n        }\r\n\r\n        _blockHeight = BTCRelay(btcRelay).getLastBlockHeight();\r\n    }\r\n\r\n    function getTicketDetails(int _id, uint _offset, uint _n, address _addr)\r\n             constant returns (uint8[] details) {\r\n        require(_offset + _n <= lotteries[_id].numTickets);\r\n\r\n        details = new uint8[](_n);\r\n        for (uint i = 0; i < _n; i++) {\r\n            address addr = lotteries[_id].tickets[_offset + i];\r\n            if (addr == _addr && _addr != 0) {\r\n                details[i] = 2;\r\n            } else if (addr != 0) {\r\n                details[i] = 1;\r\n            } else {\r\n                details[i] = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getTicketOwner(int _id, uint _ticket) constant returns (address) {\r\n        require(_id >= 0);\r\n        return lotteries[_id].tickets[_ticket];\r\n    }\r\n\r\n    function getRecentActivity()\r\n             constant returns (int _id, uint _idx, uint[1000] _recentActivity) {\r\n        _id = id;\r\n        _idx = recentActivityIdx;\r\n        for (uint i = 0; i < recentActivity.length; i++) {\r\n            _recentActivity[i] = recentActivity[i];\r\n        }\r\n    }\r\n\r\n    function setAdmin(address _admin) onlyOwner {\r\n        admin = _admin;\r\n    }\r\n\r\n    function proposeOwner(address _owner) onlyOwner {\r\n        proposedOwner = _owner;\r\n    }\r\n\r\n    function acceptOwnership() {\r\n        require(proposedOwner != 0);\r\n        require(msg.sender == proposedOwner);\r\n        owner = proposedOwner;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"lastInitTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"name\":\"lotteries\",\"outputs\":[{\"name\":\"jackpot\",\"type\":\"uint256\"},{\"name\":\"decidingBlock\",\"type\":\"int256\"},{\"name\":\"numTickets\",\"type\":\"uint256\"},{\"name\":\"numTicketsSold\",\"type\":\"uint256\"},{\"name\":\"ticketPrice\",\"type\":\"uint256\"},{\"name\":\"winningTicket\",\"type\":\"int256\"},{\"name\":\"winner\",\"type\":\"address\"},{\"name\":\"finalizationBlock\",\"type\":\"uint256\"},{\"name\":\"finalizer\",\"type\":\"address\"},{\"name\":\"message\",\"type\":\"string\"},{\"name\":\"nearestKnownBlock\",\"type\":\"int256\"},{\"name\":\"nearestKnownBlockHash\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tickets\",\"type\":\"uint256[]\"},{\"name\":\"_mark\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"buyTickets\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"recentActivity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"needsBlockFinalization\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"needsLotteryFinalization\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"int256\"},{\"name\":\"_offset\",\"type\":\"uint256\"},{\"name\":\"_n\",\"type\":\"uint256\"},{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getTicketDetails\",\"outputs\":[{\"name\":\"details\",\"type\":\"uint8[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_message\",\"type\":\"string\"}],\"name\":\"getMessageLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalizeBlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"int256\"}],\"name\":\"getLotteryDetailsB\",\"outputs\":[{\"name\":\"_actualId\",\"type\":\"int256\"},{\"name\":\"_winningTicket\",\"type\":\"int256\"},{\"name\":\"_winner\",\"type\":\"address\"},{\"name\":\"_finalizationBlock\",\"type\":\"uint256\"},{\"name\":\"_finalizer\",\"type\":\"address\"},{\"name\":\"_message\",\"type\":\"string\"},{\"name\":\"_prevLottery\",\"type\":\"int256\"},{\"name\":\"_nextLottery\",\"type\":\"int256\"},{\"name\":\"_blockHeight\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRecentActivity\",\"outputs\":[{\"name\":\"_id\",\"type\":\"int256\"},{\"name\":\"_idx\",\"type\":\"uint256\"},{\"name\":\"_recentActivity\",\"type\":\"uint256[1000]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"recentActivityIdx\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"id\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"int256\"},{\"name\":\"_message\",\"type\":\"string\"}],\"name\":\"setMessage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"proposeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"needsInitialization\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_jackpot\",\"type\":\"uint256\"},{\"name\":\"_numTickets\",\"type\":\"uint256\"},{\"name\":\"_ticketPrice\",\"type\":\"uint256\"}],\"name\":\"initLottery\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proposedOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"btcRelay\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"int256\"}],\"name\":\"getLotteryDetailsA\",\"outputs\":[{\"name\":\"_actualId\",\"type\":\"int256\"},{\"name\":\"_jackpot\",\"type\":\"uint256\"},{\"name\":\"_decidingBlock\",\"type\":\"int256\"},{\"name\":\"_numTickets\",\"type\":\"uint256\"},{\"name\":\"_numTicketsSold\",\"type\":\"uint256\"},{\"name\":\"_lastSaleTimestamp\",\"type\":\"uint256\"},{\"name\":\"_ticketPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"escrow\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"int256\"},{\"name\":\"_ticket\",\"type\":\"uint256\"}],\"name\":\"getTicketOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_steps\",\"type\":\"uint256\"}],\"name\":\"finalizeLottery\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastSaleTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_btcRelay\",\"type\":\"address\"},{\"name\":\"_escrow\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"mark\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"reason\",\"type\":\"uint8\"}],\"name\":\"PurchaseFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"mark\",\"type\":\"uint256\"}],\"name\":\"PurchaseSuccessful\",\"type\":\"event\"}]","ContractName":"EthereumLottery","CompilerVersion":"v0.4.17+commit.bdeb9e52","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000041f274c0023f83391de4e0733c609df5a124c3d4000000000000000000000000e28942df3b9502193a3547e6f6bad16ce63b1e2d","Library":"","SwarmSource":"bzzr://8203c24ff4a7f2ab86627b07d7faa85bde30cbbe3ffa1e139db5946180c162bf"}]}