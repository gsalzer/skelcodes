{"status":"1","message":"OK","result":[{"SourceCode":"interface ERC20 {\r\n    function balanceOf(address _owner) public constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n}\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  //function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    //// require(b > 0); // Solidity automatically throws when dividing by 0\r\n    //uint256 c = a / b;\r\n    //// require(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    //return c;\r\n  //}\r\n\r\n  //function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    //require(b <= a);\r\n    //return a - b;\r\n  //}\r\n\r\n  //function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    //uint256 c = a + b;\r\n    //require(c >= a);\r\n    //return c;\r\n  //}\r\n}\r\n\r\n// A contract that distributes ERC20 tokens with predetermined terms.\r\n// WARNING: This contract does not protect against malicious token contracts,\r\n//          under the assumption that if the token sellers are malicious,\r\n//          the tokens will be worthless anyway.\r\ncontract Distribution {\r\n  using SafeMath for uint256;\r\n\r\n  enum State {\r\n    AwaitingTokens,\r\n    DistributingNormally,\r\n    DistributingProRata,\r\n    Done\r\n  }\r\n \r\n  address admin;\r\n  ERC20 tokenContract;\r\n  State state;\r\n  uint256 actualTotalTokens;\r\n  uint256 tokensTransferred;\r\n\r\n  bytes32[] contributionHashes;\r\n  uint256 expectedTotalTokens;\r\n\r\n  function Distribution(address _admin, ERC20 _tokenContract,\r\n                        bytes32[] _contributionHashes, uint256 _expectedTotalTokens) public {\r\n    expectedTotalTokens = _expectedTotalTokens;\r\n    contributionHashes = _contributionHashes;\r\n    tokenContract = _tokenContract;\r\n    admin = _admin;\r\n\r\n    state = State.AwaitingTokens;\r\n  }\r\n\r\n  function handleTokensReceived() public {\r\n    require(state == State.AwaitingTokens);\r\n    uint256 totalTokens = tokenContract.balanceOf(this);\r\n    require(totalTokens > 0);\r\n\r\n    tokensTransferred = 0;\r\n    if (totalTokens == expectedTotalTokens) {\r\n      state = State.DistributingNormally;\r\n    } else {\r\n      actualTotalTokens = totalTokens;\r\n      state = State.DistributingProRata;\r\n    }\r\n  }\r\n\r\n  function _numTokensForContributor(uint256 contributorExpectedTokens,\r\n                                    uint256 _tokensTransferred, State _state)\r\n      internal view returns (uint256) {\r\n    if (_state == State.DistributingNormally) {\r\n      return contributorExpectedTokens;\r\n    } else if (_state == State.DistributingProRata) {\r\n      uint256 tokens = actualTotalTokens.mul(contributorExpectedTokens) / expectedTotalTokens;\r\n\r\n      // Handle roundoff on last contributor.\r\n      uint256 tokensRemaining = actualTotalTokens - _tokensTransferred;\r\n      if (tokens < tokensRemaining) {\r\n        return tokens;\r\n      } else {\r\n        return tokensRemaining;\r\n      }\r\n    } else {\r\n      revert();\r\n    }\r\n  }\r\n\r\n  function doDistribution(uint256 contributorIndex, address contributor,\r\n                          uint256 contributorExpectedTokens)\r\n      public {\r\n    // Make sure the arguments match the compressed storage.\r\n    require(contributionHashes[contributorIndex] == keccak256(contributor, contributorExpectedTokens));\r\n\r\n    uint256 numTokens = _numTokensForContributor(contributorExpectedTokens,\r\n                                                 tokensTransferred, state);\r\n    contributionHashes[contributorIndex] = 0x00000000000000000000000000000000;\r\n    tokensTransferred += numTokens;\r\n    if (tokensTransferred == actualTotalTokens) {\r\n      state = State.Done;\r\n    }\r\n\r\n    require(tokenContract.transfer(contributor, numTokens));\r\n  }\r\n\r\n  function doDistributionRange(uint256 start, address[] contributors,\r\n                               uint256[] contributorExpectedTokens) public {\r\n    require(contributors.length == contributorExpectedTokens.length);\r\n\r\n    uint256 tokensTransferredSoFar = tokensTransferred;\r\n    uint256 end = start + contributors.length;\r\n    State _state = state;\r\n    for (uint256 i = start; i < end; ++i) {\r\n      address contributor = contributors[i];\r\n      uint256 expectedTokens = contributorExpectedTokens[i];\r\n      require(contributionHashes[i] == keccak256(contributor, expectedTokens));\r\n      contributionHashes[i] = 0x00000000000000000000000000000000;\r\n\r\n      uint256 numTokens = _numTokensForContributor(expectedTokens, tokensTransferredSoFar, _state);\r\n      tokensTransferredSoFar += numTokens;\r\n      require(tokenContract.transfer(contributor, numTokens));\r\n    }\r\n\r\n    tokensTransferred = tokensTransferredSoFar;\r\n    if (tokensTransferred == actualTotalTokens) {\r\n      state = State.Done;\r\n    }\r\n  }\r\n\r\n  function numTokensForContributor(uint256 contributorExpectedTokens)\r\n      public view returns (uint256) {\r\n    return _numTokensForContributor(contributorExpectedTokens, tokensTransferred, state);\r\n  }\r\n\r\n  function temporaryEscapeHatch(address to, uint256 value, bytes data) public {\r\n    require(msg.sender == admin);\r\n    require(to.call.value(value)(data));\r\n  }\r\n\r\n  function temporaryKill(address to) public {\r\n    require(msg.sender == admin);\r\n    require(tokenContract.balanceOf(this) == 0);\r\n    selfdestruct(to);\r\n  }\r\n}\r\ncontract DistributionForTesting is Distribution {\r\n  function DistributionForTesting(address _admin, ERC20 _tokenContract,\r\n                                  bytes32[] _contributionHashes, uint256 _expectedTotalTokens)\r\n    Distribution(_admin, _tokenContract, _contributionHashes, _expectedTotalTokens) public { }\r\n\r\n  function getContributionHash(address contributor, uint256 expectedTokens)\r\n      public pure returns (bytes32 result) {\r\n    result = keccak256(contributor, expectedTokens);\r\n  }\r\n\r\n  function getNumTokensForContributorInternal(uint256 contributorExpectedTokens,\r\n                                              uint256 _tokensTransferred, State _state)\r\n      public view returns (uint256) {\r\n    return _numTokensForContributor(contributorExpectedTokens, _tokensTransferred, _state);\r\n  }\r\n\r\n  function getAdmin() public pure returns (address) { return Distribution.admin; }\r\n  function getTokenContract() public pure returns (ERC20) { return Distribution.tokenContract; }\r\n  function getState() public pure returns (Distribution.State) { return Distribution.state; }\r\n  function getActualTotalTokens() public pure returns (uint256) { return Distribution.actualTotalTokens; }\r\n\r\n  function getContributionHashes() public pure returns (bytes32[]) { return Distribution.contributionHashes; }\r\n  function getContributionHashByIndex(uint256 contributorIndex)\r\n      public view returns (bytes32) { return Distribution.contributionHashes[contributorIndex]; }\r\n  function getExpectedTotalTokens() public pure returns (uint256) { return Distribution.expectedTotalTokens; }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"contributorExpectedTokens\",\"type\":\"uint256\"},{\"name\":\"_tokensTransferred\",\"type\":\"uint256\"},{\"name\":\"_state\",\"type\":\"uint8\"}],\"name\":\"getNumTokensForContributorInternal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"contributorIndex\",\"type\":\"uint256\"}],\"name\":\"getContributionHashByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getContributionHashes\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"contributors\",\"type\":\"address[]\"},{\"name\":\"contributorExpectedTokens\",\"type\":\"uint256[]\"}],\"name\":\"doDistributionRange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"contributorExpectedTokens\",\"type\":\"uint256\"}],\"name\":\"numTokensForContributor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"temporaryEscapeHatch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getExpectedTotalTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"contributor\",\"type\":\"address\"},{\"name\":\"expectedTokens\",\"type\":\"uint256\"}],\"name\":\"getContributionHash\",\"outputs\":[{\"name\":\"result\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"}],\"name\":\"temporaryKill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contributorIndex\",\"type\":\"uint256\"},{\"name\":\"contributor\",\"type\":\"address\"},{\"name\":\"contributorExpectedTokens\",\"type\":\"uint256\"}],\"name\":\"doDistribution\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getActualTotalTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"handleTokensReceived\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"},{\"name\":\"_tokenContract\",\"type\":\"address\"},{\"name\":\"_contributionHashes\",\"type\":\"bytes32[]\"},{\"name\":\"_expectedTotalTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"DistributionForTesting","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000008ab0a7de69635082663a4450f1247b381dc6030000000000000000000000000107c4504cd79c5d2696ea0030a8dd4e92601b82e000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000095b79bf56f0c6135794000000000000000000000000000000000000000000000000000000000000001d577ffb9bc10787e9f5f463102c138445835644c3400ee778a47de8249b3df2346802036ce147f78c928ba480be277461733b96472d8c5aed654f98d9e4cd5818cf2db038285d37e29cd9109bff29c78a115b0904c83aa4ac1bbd260cca5f0e54c9db686e177524eadb4ad22582e37f89cd2d01d8ce78c6ef463a128b02578342270afcb2c36d5882a9ced0eedffb4ddc5fefdeda21d9af6cc6b61b9336b3c4461a1005795011b26e08341f97bfa3f32d7b80305060beb7521bed68937d9d8688f7d621de8dad7e656c3bd4435340133b481e269ffb53eb856ca7ef7218e05f6c69372bd065fb95bd2ef53ccc7c4f2a9931834321b6b664bbd714fd4874dd4895ad42021ac6d96147ee0f74c57c82a3369900b9e0e68ff659943dbd8f8e2c0904b72665f47d598032801da1796e073dcb04446ad20105b4e6e0fe997c2fc5c69d4c6a222fb02322b0a9bfd27d7b526295bd0c8f39dd51b9993f35a7bb50f39f0b17b180ea36a1635746cebd7f4a933c22c30b88bcb2e937d6de9524e1aa849d2d80091302b70cb2f99200003f274bfc47425e9f29f4efec1e112235001e37f88441acc8dbbd9139240783c3fbf814a51c59ddb3d13af228b5c126d71aa50b5d0fdd9ccee40272683936679956e0ede0d28a1ddec2cb3f4b663380f8c770a45361c1c0e276f06690d7cce18970959fe2cb9552831499f5e7ebf053e0ac1b4476d174b04840e21fd49539703be43b8f8f0bddedebb856d840576f65bb3934a1263a3c4080c47af1afc487940450bf86e893a9247e8133fa1cb0cc58b8a13e3ba5a464bdeca758a0c48daea45a5aa733dde6480c3359b197cbf79d47cbd16697068fc551ea43dc52452f5242acbcd18f97d76eb282ef85e89a4894110369aa703df96341edf8f9090f34531fb1782f86481a9074477b0ac8ccfe8042ff5fcdb03e69e8e03f6c1345c6d242959b08dccca0c2bc9065b90eaa5246c5411a58b23492b73d63698176205cf277ee5b258aaaca73038da75f4b4dd955a78903523c96e87d2cb382c4556aced5e93db853f85b03d6b31b5962d3137c5bbb17d2e5d55897012b7e95f5ca9debf6736481288e41b9386991abb1db691a458958cf45cf94164a5c6eb646aa3e1f42911be4dbbdbb6e5273d936ad64836ac3080578e71d51e1be053465cb23eb692b9e5714aea1b55efe4f56627f9f53df9a5db58561973b8c7798e233e947d643890dcf6b60894369e32830c2535250706bdc3256c1f77c65c46bb6cf2d74691c996c8259f2340ae0809d83c317220d03da1f94e593ccf90fec","Library":"","SwarmSource":"bzzr://56bd7c1fdf3940571462f5375b089b0afcbfb33355200fa0c4513476ba8e883b"}]}