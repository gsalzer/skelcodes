{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n\r\n\r\ninterface Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply);\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract Utils {\r\n    string constant public contract_version = \"0.1._\";\r\n    /// @notice Check if a contract exists\r\n    /// @param channel The address to check whether a contract is deployed or not\r\n    /// @return True if a contract exists, false otherwise\r\n    function contractExists(address channel) constant returns (bool) {\r\n        uint size;\r\n\r\n        assembly {\r\n            size := extcodesize(channel)\r\n        }\r\n\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\nlibrary NettingChannelLibrary {\r\n    string constant public contract_version = \"0.1._\";\r\n\r\n    struct Participant\r\n    {\r\n        address node_address;\r\n\r\n        // Total amount of token transferred to this smart contract through the\r\n        // `deposit` function, note that direct token transfer cannot be\r\n        // tracked and will be burned.\r\n        uint256 balance;\r\n\r\n        // The latest known merkle root of the pending hash-time locks, used to\r\n        // validate the withdrawn proofs.\r\n        bytes32 locksroot;\r\n\r\n        // The latest known transferred_amount from this node to the other\r\n        // participant, used to compute the net balance on settlement.\r\n        uint256 transferred_amount;\r\n\r\n        // Value used to order transfers and only accept the latest on calls to\r\n        // update, this will only be relevant after either #182 or #293 is\r\n        // implemented.\r\n        uint64 nonce;\r\n\r\n        // A mapping to keep track of locks that have been withdrawn.\r\n        mapping(bytes32 => bool) withdrawn_locks;\r\n    }\r\n\r\n    struct Data {\r\n        uint settle_timeout;\r\n        uint opened;\r\n        uint closed;\r\n        uint settled;\r\n        address closing_address;\r\n        Token token;\r\n        Participant[2] participants;\r\n        mapping(address => uint8) participant_index;\r\n        bool updated;\r\n    }\r\n\r\n\r\n    modifier notSettledButClosed(Data storage self) {\r\n        require(self.settled <= 0 && self.closed > 0);\r\n        _;\r\n    }\r\n\r\n    modifier stillTimeout(Data storage self) {\r\n        require(self.closed + self.settle_timeout >= block.number);\r\n        _;\r\n    }\r\n\r\n    modifier timeoutOver(Data storage self) {\r\n        require(self.closed + self.settle_timeout <= block.number);\r\n        _;\r\n    }\r\n\r\n    modifier channelSettled(Data storage self) {\r\n        require(self.settled != 0);\r\n        _;\r\n    }\r\n\r\n    /// @notice Deposit amount to channel.\r\n    /// @dev Deposit an amount to the channel. At least one of the participants\r\n    /// must deposit before the channel is opened.\r\n    /// @param amount The amount to be deposited to the address\r\n    /// @return Success if the transfer was successful\r\n    /// @return The new balance of the invoker\r\n    function deposit(Data storage self, uint256 amount)\r\n        returns (bool success, uint256 balance)\r\n    {\r\n        uint8 index;\r\n\r\n        require(self.opened > 0);\r\n        require(self.closed == 0);\r\n        require(self.token.balanceOf(msg.sender) >= amount);\r\n\r\n        index = index_or_throw(self, msg.sender);\r\n        Participant storage participant = self.participants[index];\r\n\r\n        success = self.token.transferFrom(msg.sender, this, amount);\r\n        if (success == true) {\r\n            balance = participant.balance;\r\n            balance += amount;\r\n            participant.balance = balance;\r\n\r\n            return (true, balance);\r\n        }\r\n\r\n        return (false, 0);\r\n    }\r\n\r\n    /// @notice Close a channel between two parties that was used bidirectionally\r\n    function close(\r\n        Data storage self,\r\n        uint64 nonce,\r\n        uint256 transferred_amount,\r\n        bytes32 locksroot,\r\n        bytes32 extra_hash,\r\n        bytes signature\r\n    ) {\r\n        address transfer_address;\r\n        uint closer_index;\r\n        uint counterparty_index;\r\n\r\n        // close can be called only once\r\n        require(self.closed == 0);\r\n        self.closed = block.number;\r\n\r\n        // Only a participant can call close\r\n        closer_index = index_or_throw(self, msg.sender);\r\n        self.closing_address = msg.sender;\r\n\r\n        // Only the closing party can provide a transfer from the counterparty,\r\n        // and only when this function is called, i.e. this value can not be\r\n        // updated afterwards.\r\n\r\n        // An empty value means that the closer never received a transfer, or\r\n        // he is intentionally not providing the latest transfer, in which case\r\n        // the closing party is going to lose the tokens that were transferred\r\n        // to him.\r\n        if (signature.length == 65) {\r\n            transfer_address = recoverAddressFromSignature(\r\n                nonce,\r\n                transferred_amount,\r\n                locksroot,\r\n                extra_hash,\r\n                signature \r\n            );\r\n\r\n            counterparty_index = index_or_throw(self, transfer_address);\r\n            require(closer_index != counterparty_index);\r\n\r\n            // update the structure of the counterparty with its data provided\r\n            // by the closing node\r\n            Participant storage counterparty = self.participants[counterparty_index];\r\n            counterparty.nonce = uint64(nonce);\r\n            counterparty.locksroot = locksroot;\r\n            counterparty.transferred_amount = transferred_amount;\r\n        }\r\n    }\r\n\r\n    /// @notice Updates counter party transfer after closing.\r\n    function updateTransfer(\r\n        Data storage self,\r\n        uint64 nonce,\r\n        uint256 transferred_amount,\r\n        bytes32 locksroot,\r\n        bytes32 extra_hash,\r\n        bytes signature\r\n    )\r\n        notSettledButClosed(self)\r\n        stillTimeout(self)\r\n    {\r\n        address transfer_address;\r\n        uint8 caller_index;\r\n        uint8 closer_index;\r\n\r\n        // updateTransfer can be called by the counter party only once\r\n        require(!self.updated);\r\n        self.updated = true;\r\n\r\n        // Only a participant can call updateTransfer (#293 for third parties)\r\n        caller_index = index_or_throw(self, msg.sender);\r\n\r\n        // The closer is not allowed to call updateTransfer\r\n        require(self.closing_address != msg.sender);\r\n\r\n        // Counter party can only update the closer transfer\r\n        transfer_address = recoverAddressFromSignature(\r\n            nonce,\r\n            transferred_amount,\r\n            locksroot,\r\n            extra_hash,\r\n            signature \r\n        );\r\n        require(transfer_address == self.closing_address);\r\n\r\n        // Update the structure of the closer with its data provided by the\r\n        // counterparty\r\n        closer_index = 1 - caller_index;\r\n\r\n        self.participants[closer_index].nonce = nonce;\r\n        self.participants[closer_index].locksroot = locksroot;\r\n        self.participants[closer_index].transferred_amount = transferred_amount;\r\n    }\r\n\r\n    function recoverAddressFromSignature(\r\n        uint64 nonce,\r\n        uint256 transferred_amount,\r\n        bytes32 locksroot,\r\n        bytes32 extra_hash,\r\n        bytes signature\r\n    )\r\n        constant internal returns (address)\r\n    {\r\n        bytes32 signed_hash;\r\n\r\n        require(signature.length == 65);\r\n\r\n        signed_hash = sha3(\r\n            nonce,\r\n            transferred_amount,\r\n            locksroot,\r\n            this,\r\n            extra_hash\r\n        );\r\n\r\n        var (r, s, v) = signatureSplit(signature);\r\n        return ecrecover(signed_hash, v, r, s);\r\n    }\r\n\r\n    /// @notice Unlock a locked transfer\r\n    /// @dev Unlock a locked transfer\r\n    /// @param locked_encoded The lock\r\n    /// @param merkle_proof The merkle proof\r\n    /// @param secret The secret\r\n    function withdraw(Data storage self, bytes locked_encoded, bytes merkle_proof, bytes32 secret)\r\n        notSettledButClosed(self)\r\n    {\r\n        uint amount;\r\n        uint8 index;\r\n        uint64 expiration;\r\n        bytes32 h;\r\n        bytes32 hashlock;\r\n\r\n        // Check if msg.sender is a participant and select the partner (for\r\n        // third party unlock see #541)\r\n        index = 1 - index_or_throw(self, msg.sender);\r\n        Participant storage counterparty = self.participants[index];\r\n\r\n        // An empty locksroot means there are no pending locks\r\n        require(counterparty.locksroot != 0);\r\n\r\n        (expiration, amount, hashlock) = decodeLock(locked_encoded);\r\n\r\n        // A lock can be withdrawn only once per participant\r\n        require(!counterparty.withdrawn_locks[hashlock]);\r\n\r\n        counterparty.withdrawn_locks[hashlock] = true;\r\n\r\n        // The lock must not have expired, it does not matter how far in the\r\n        // future it would have expired\r\n        require(expiration >= block.number);\r\n        require(hashlock == sha3(secret));\r\n\r\n        h = computeMerkleRoot(locked_encoded, merkle_proof);\r\n\r\n        require(counterparty.locksroot == h);\r\n\r\n        // This implementation allows for each transfer to be set only once, so\r\n        // it's safe to update the transferred_amount in place.\r\n        //\r\n        // Once third parties are allowed to update the counter party transfer\r\n        // (#293, #182) the locksroot may change, if the locksroot change the\r\n        // transferred_amount must be reset and locks must be re-withdrawn, so\r\n        // this is also safe.\r\n        //\r\n        // This may be problematic if an update changes the transferred_amount\r\n        // but not the locksroot, since the locks don't need to be\r\n        // re-withdrawn, the difference in the transferred_amount must be\r\n        // accounted for.\r\n        counterparty.transferred_amount += amount;\r\n    }\r\n\r\n    function computeMerkleRoot(bytes lock, bytes merkle_proof)\r\n        internal\r\n        constant\r\n        returns (bytes32)\r\n    {\r\n        require(merkle_proof.length % 32 == 0);\r\n\r\n        uint i;\r\n        bytes32 h;\r\n        bytes32 el;\r\n\r\n        h = sha3(lock);\r\n        for (i = 32; i <= merkle_proof.length; i += 32) {\r\n            assembly {\r\n                el := mload(add(merkle_proof, i))\r\n            }\r\n\r\n            if (h < el) {\r\n                h = sha3(h, el);\r\n            } else {\r\n                h = sha3(el, h);\r\n            }\r\n        }\r\n\r\n        return h;\r\n    }\r\n\r\n    /// @notice Settles the balance between the two parties\r\n    /// @dev Settles the balances of the two parties fo the channel\r\n    /// @return The participants with netted balances\r\n    function settle(Data storage self)\r\n        notSettledButClosed(self)\r\n        timeoutOver(self)\r\n    {\r\n        uint8 closing_index;\r\n        uint8 counter_index;\r\n        uint256 total_deposit;\r\n        uint256 counter_net;\r\n        uint256 closer_amount;\r\n        uint256 counter_amount;\r\n\r\n        self.settled = block.number;\r\n\r\n        closing_index = index_or_throw(self, self.closing_address);\r\n        counter_index = 1 - closing_index;\r\n\r\n        Participant storage closing_party = self.participants[closing_index];\r\n        Participant storage counter_party = self.participants[counter_index];\r\n\r\n        counter_net = (\r\n            counter_party.balance\r\n            + closing_party.transferred_amount\r\n            - counter_party.transferred_amount\r\n        );\r\n\r\n        // Direct token transfers done through the token `transfer` function\r\n        // cannot be accounted for, these superfluous tokens will be burned,\r\n        // this is because there is no way to tell which participant (if any)\r\n        // had ownership over the token.\r\n        total_deposit = closing_party.balance + counter_party.balance;\r\n\r\n        // When the closing party does not provide the counter party transfer,\r\n        // the `counter_net` may be larger than the `total_deposit`, without\r\n        // the min the token transfer fail and the token is locked.\r\n        counter_amount = min(counter_net, total_deposit);\r\n\r\n        // When the counter party does not provide the closing party transfer,\r\n        // then `counter_amount` may be negative and the transfer fails, force\r\n        // the value to 0.\r\n        counter_amount = max(counter_amount, 0);\r\n\r\n        // At this point `counter_amount` is between [0,total_deposit], so this\r\n        // is safe.\r\n        closer_amount = total_deposit - counter_amount;\r\n\r\n        if (counter_amount > 0) {\r\n            require(self.token.transfer(counter_party.node_address, counter_amount));\r\n        }\r\n\r\n        if (closer_amount > 0) {\r\n            require(self.token.transfer(closing_party.node_address, closer_amount));\r\n        }\r\n\r\n        kill(self);\r\n    }\r\n\r\n    // NOTES:\r\n    //\r\n    // - The EVM is a big-endian, byte addressing machine, with 32bytes/256bits\r\n    //   words.\r\n    // - The Ethereum Contract ABI specifies that variable length types have a\r\n    //   32bytes prefix to define the variable size.\r\n    // - Solidity has additional data types that are narrower than 32bytes\r\n    //   (e.g. uint128 uses a half word).\r\n    // - Solidity uses the *least-significant* bits of the word to store the\r\n    //   values of a narrower type.\r\n    //\r\n    // GENERAL APPROACH:\r\n    //\r\n    // Add to the message pointer the number of bytes required to move the\r\n    // address so that the target data is at the end of the 32bytes word.\r\n    //\r\n    // EXAMPLE:\r\n    //\r\n    // To decode the cmdid, consider this initial state:\r\n    //\r\n    //\r\n    //     v- pointer word start\r\n    //     [ 32 bytes length prefix ][ cmdid ] ----\r\n    //                              ^- pointer word end\r\n    //\r\n    //\r\n    // Because the cmdid has 1 byte length the type uint8 is used, the decoder\r\n    // needs to move the pointer so the cmdid is at the end of the pointer\r\n    // word.\r\n    //\r\n    //\r\n    //             v- pointer word start [moved 1byte ahead]\r\n    //     [ 32 bytes length prefix ][ cmdid ] ----\r\n    //                                       ^- pointer word end\r\n    //\r\n    //\r\n    // Now the data of the cmdid can be loaded to the uint8 variable.\r\n    //\r\n    // REFERENCES:\r\n    // - https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\r\n    // - http://solidity.readthedocs.io/en/develop/assembly.html\r\n\r\n    function decodeLock(bytes lock) internal returns (uint64 expiration, uint amount, bytes32 hashlock) {\r\n        require(lock.length == 72);\r\n\r\n        // Lock format:\r\n        // [0:8] expiration\r\n        // [8:40] amount\r\n        // [40:72] hashlock\r\n        assembly {\r\n            expiration := mload(add(lock, 8))\r\n            amount := mload(add(lock, 40))\r\n            hashlock := mload(add(lock, 72))\r\n        }\r\n    }\r\n\r\n    function signatureSplit(bytes signature) internal returns (bytes32 r, bytes32 s, uint8 v) {\r\n        // The signature format is a compact form of:\r\n        //   {bytes32 r}{bytes32 s}{uint8 v}\r\n        // Compact means, uint8 is not padded to 32 bytes.\r\n        assembly {\r\n            r := mload(add(signature, 32))\r\n            s := mload(add(signature, 64))\r\n            // Here we are loading the last 32 bytes, including 31 bytes\r\n            // of 's'. There is no 'mload8' to do this.\r\n            //\r\n            // 'byte' is not working due to the Solidity parser, so lets\r\n            // use the second best option, 'and'\r\n            v := and(mload(add(signature, 65)), 0xff)\r\n        }\r\n\r\n        require(v == 27 || v == 28);\r\n    }\r\n\r\n    function index_or_throw(Data storage self, address participant_address) private returns (uint8) {\r\n        uint8 n;\r\n        // Return index of participant, or throw\r\n        n = self.participant_index[participant_address];\r\n        assert(n != 0);\r\n        return n - 1;\r\n    }\r\n\r\n    function min(uint a, uint b) constant internal returns (uint) {\r\n        return a > b ? b : a;\r\n    }\r\n\r\n    function max(uint a, uint b) constant internal returns (uint) {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n    function kill(Data storage self) channelSettled(self) {\r\n        selfdestruct(0x00000000000000000000);\r\n    }\r\n}\r\n\r\ncontract NettingChannelContract {\r\n    string constant public contract_version = \"0.1._\";\r\n\r\n    using NettingChannelLibrary for NettingChannelLibrary.Data;\r\n    NettingChannelLibrary.Data public data;\r\n\r\n    event ChannelNewBalance(address token_address, address participant, uint balance, uint block_number);\r\n    event ChannelClosed(address closing_address, uint block_number);\r\n    event TransferUpdated(address node_address, uint block_number);\r\n    event ChannelSettled(uint block_number);\r\n    event ChannelSecretRevealed(bytes32 secret, address receiver_address);\r\n\r\n    modifier settleTimeoutNotTooLow(uint t) {\r\n        assert(t >= 6);\r\n        _;\r\n    }\r\n\r\n    function NettingChannelContract(\r\n        address token_address,\r\n        address participant1,\r\n        address participant2,\r\n        uint timeout)\r\n        settleTimeoutNotTooLow(timeout)\r\n    {\r\n        require(participant1 != participant2);\r\n\r\n        data.participants[0].node_address = participant1;\r\n        data.participants[1].node_address = participant2;\r\n        data.participant_index[participant1] = 1;\r\n        data.participant_index[participant2] = 2;\r\n\r\n        data.token = Token(token_address);\r\n        data.settle_timeout = timeout;\r\n        data.opened = block.number;\r\n    }\r\n\r\n    /// @notice Caller makes a deposit into their channel balance.\r\n    /// @param amount The amount caller wants to deposit.\r\n    /// @return True if deposit is successful.\r\n    function deposit(uint256 amount) returns (bool) {\r\n        bool success;\r\n        uint256 balance;\r\n\r\n        (success, balance) = data.deposit(amount);\r\n\r\n        if (success == true) {\r\n            ChannelNewBalance(data.token, msg.sender, balance, block.number);\r\n        }\r\n\r\n        return success;\r\n    }\r\n\r\n    /// @notice Get the address and balance of both partners in a channel.\r\n    /// @return The address and balance pairs.\r\n    function addressAndBalance()\r\n        constant\r\n        returns (\r\n        address participant1,\r\n        uint balance1,\r\n        address participant2,\r\n        uint balance2)\r\n    {\r\n        NettingChannelLibrary.Participant storage node1 = data.participants[0];\r\n        NettingChannelLibrary.Participant storage node2 = data.participants[1];\r\n\r\n        participant1 = node1.node_address;\r\n        balance1 = node1.balance;\r\n        participant2 = node2.node_address;\r\n        balance2 = node2.balance;\r\n    }\r\n\r\n    /// @notice Close the channel. Can only be called by a participant in the channel.\r\n    function close(\r\n        uint64 nonce,\r\n        uint256 transferred_amount,\r\n        bytes32 locksroot,\r\n        bytes32 extra_hash,\r\n        bytes signature\r\n    ) {\r\n        data.close(\r\n            nonce,\r\n            transferred_amount,\r\n            locksroot,\r\n            extra_hash,\r\n            signature\r\n        );\r\n        ChannelClosed(msg.sender, data.closed);\r\n    }\r\n\r\n    /// @notice Dispute the state after closing, called by the counterparty (the\r\n    ///         participant who did not close the channel).\r\n    function updateTransfer(\r\n        uint64 nonce,\r\n        uint256 transferred_amount,\r\n        bytes32 locksroot,\r\n        bytes32 extra_hash,\r\n        bytes signature\r\n    ) {\r\n        data.updateTransfer(\r\n            nonce,\r\n            transferred_amount,\r\n            locksroot,\r\n            extra_hash,\r\n            signature\r\n        );\r\n        TransferUpdated(msg.sender, block.number);\r\n    }\r\n\r\n    /// @notice Unlock a locked transfer.\r\n    /// @param locked_encoded The locked transfer to be unlocked.\r\n    /// @param merkle_proof The merke_proof for the locked transfer.\r\n    /// @param secret The secret to unlock the locked transfer.\r\n    function withdraw(bytes locked_encoded, bytes merkle_proof, bytes32 secret) {\r\n        // throws if sender is not a participant\r\n        data.withdraw(locked_encoded, merkle_proof, secret);\r\n        ChannelSecretRevealed(secret, msg.sender);\r\n    }\r\n\r\n    /// @notice Settle the transfers and balances of the channel and pay out to\r\n    ///         each participant. Can only be called after the channel is closed\r\n    ///         and only after the number of blocks in the settlement timeout\r\n    ///         have passed.\r\n    function settle() {\r\n        data.settle();\r\n        ChannelSettled(data.settled);\r\n    }\r\n\r\n    /// @notice Returns the number of blocks until the settlement timeout.\r\n    /// @return The number of blocks until the settlement timeout.\r\n    function settleTimeout() constant returns (uint) {\r\n        return data.settle_timeout;\r\n    }\r\n\r\n    /// @notice Returns the address of the token.\r\n    /// @return The address of the token.\r\n    function tokenAddress() constant returns (address) {\r\n        return data.token;\r\n    }\r\n\r\n    /// @notice Returns the block number for when the channel was opened.\r\n    /// @return The block number for when the channel was opened.\r\n    function opened() constant returns (uint) {\r\n        return data.opened;\r\n    }\r\n\r\n    /// @notice Returns the block number for when the channel was closed.\r\n    /// @return The block number for when the channel was closed.\r\n    function closed() constant returns (uint) {\r\n        return data.closed;\r\n    }\r\n\r\n    /// @notice Returns the block number for when the channel was settled.\r\n    /// @return The block number for when the channel was settled.\r\n    function settled() constant returns (uint) {\r\n        return data.settled;\r\n    }\r\n\r\n    /// @notice Returns the address of the closing participant.\r\n    /// @return The address of the closing participant.\r\n    function closingAddress() constant returns (address) {\r\n        return data.closing_address;\r\n    }\r\n\r\n    function () { revert(); }\r\n}\r\n\r\nlibrary ChannelManagerLibrary {\r\n    string constant public contract_version = \"0.1._\";\r\n\r\n    struct Data {\r\n        Token token;\r\n\r\n        address[] all_channels;\r\n        mapping(bytes32 => uint) partyhash_to_channelpos;\r\n\r\n        mapping(address => address[]) nodeaddress_to_channeladdresses;\r\n        mapping(address => mapping(address => uint)) node_index;\r\n    }\r\n\r\n    /// @notice Get the address of channel with a partner\r\n    /// @param partner The address of the partner\r\n    /// @return The address of the channel\r\n    function getChannelWith(Data storage self, address partner) constant returns (address) {\r\n        bytes32 party_hash = partyHash(msg.sender, partner);\r\n        uint channel_pos = self.partyhash_to_channelpos[party_hash];\r\n\r\n        if (channel_pos != 0) {\r\n            return self.all_channels[channel_pos - 1];\r\n        }\r\n    }\r\n\r\n    /// @notice Create a new payment channel between two parties\r\n    /// @param partner The address of the partner\r\n    /// @param settle_timeout The settle timeout in blocks\r\n    /// @return The address of the newly created NettingChannelContract.\r\n    function newChannel(Data storage self, address partner, uint settle_timeout)\r\n        returns (address)\r\n    {\r\n        address[] storage caller_channels = self.nodeaddress_to_channeladdresses[msg.sender];\r\n        address[] storage partner_channels = self.nodeaddress_to_channeladdresses[partner];\r\n\r\n        bytes32 party_hash = partyHash(msg.sender, partner);\r\n        uint channel_pos = self.partyhash_to_channelpos[party_hash];\r\n\r\n        address new_channel_address = new NettingChannelContract(\r\n            self.token,\r\n            msg.sender,\r\n            partner,\r\n            settle_timeout\r\n        );\r\n\r\n        if (channel_pos != 0) {\r\n            // Check if the channel was settled. Once a channel is settled it\r\n            // kills itself, so address must not have code.\r\n            address settled_channel = self.all_channels[channel_pos - 1];\r\n            require(!contractExists(settled_channel));\r\n\r\n            uint caller_pos = self.node_index[msg.sender][partner];\r\n            uint partner_pos = self.node_index[partner][msg.sender];\r\n\r\n            // replace the channel address in-place\r\n            self.all_channels[channel_pos - 1] = new_channel_address;\r\n            caller_channels[caller_pos - 1] = new_channel_address;\r\n            partner_channels[partner_pos - 1] = new_channel_address;\r\n\r\n        } else {\r\n            self.all_channels.push(new_channel_address);\r\n            caller_channels.push(new_channel_address);\r\n            partner_channels.push(new_channel_address);\r\n\r\n            // using the 1-index, 0 is used for the absence of a value\r\n            self.partyhash_to_channelpos[party_hash] = self.all_channels.length;\r\n            self.node_index[msg.sender][partner] = caller_channels.length;\r\n            self.node_index[partner][msg.sender] = partner_channels.length;\r\n        }\r\n\r\n        return new_channel_address;\r\n    }\r\n\r\n    /// @notice Get the hash of the two addresses\r\n    /// @param address_one address of one party\r\n    /// @param address_two of the other party\r\n    /// @return The sha3 hash of both parties sorted by size of address\r\n    function partyHash(address address_one, address address_two) internal constant returns (bytes32) {\r\n        if (address_one < address_two) {\r\n            return sha3(address_one, address_two);\r\n        } else {\r\n            // The two participants can't be the same here due to this check in\r\n            // the netting channel constructor:\r\n            // https://github.com/raiden-network/raiden/blob/e17d96db375d31b134ae7b4e2ad2c1f905b47857/raiden/smart_contracts/NettingChannelContract.sol#L27\r\n            return sha3(address_two, address_one);\r\n        }\r\n    }\r\n\r\n    /// TODO: Find a way to remove this function duplication from Utils.sol here\r\n    ///       At the moment libraries can't inherit so we need to add this here\r\n    ///       explicitly.\r\n    /// @notice Check if a contract exists\r\n    /// @param channel The address to check whether a contract is deployed or not\r\n    /// @return True if a contract exists, false otherwise\r\n    function contractExists(address channel) private constant returns (bool) {\r\n        uint size;\r\n\r\n        assembly {\r\n            size := extcodesize(channel)\r\n        }\r\n\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n// for each token a manager will be deployed, to reduce gas usage for manager\r\n// deployment the logic is moved into a library and this contract will work\r\n// only as a proxy/state container.\r\ncontract ChannelManagerContract is Utils {\r\n    string constant public contract_version = \"0.1._\";\r\n\r\n    using ChannelManagerLibrary for ChannelManagerLibrary.Data;\r\n    ChannelManagerLibrary.Data data;\r\n\r\n    event ChannelNew(\r\n        address netting_channel,\r\n        address participant1,\r\n        address participant2,\r\n        uint settle_timeout\r\n    );\r\n\r\n    event ChannelDeleted(\r\n        address caller_address,\r\n        address partner\r\n    );\r\n\r\n    function ChannelManagerContract(address token_address) {\r\n        data.token = Token(token_address);\r\n    }\r\n\r\n    /// @notice Get all channels\r\n    /// @return All the open channels\r\n    function getChannelsAddresses() constant returns (address[]) {\r\n        return data.all_channels;\r\n    }\r\n\r\n    /// @notice Get all participants of all channels\r\n    /// @return All participants in all channels\r\n    function getChannelsParticipants() constant returns (address[]) {\r\n        uint i;\r\n        uint pos;\r\n        address[] memory result;\r\n        NettingChannelContract channel;\r\n\r\n        uint open_channels_num = 0;\r\n        for (i = 0; i < data.all_channels.length; i++) {\r\n            if (contractExists(data.all_channels[i])) {\r\n                open_channels_num += 1;\r\n            }\r\n        }\r\n        result = new address[](open_channels_num * 2);\r\n\r\n        pos = 0;\r\n        for (i = 0; i < data.all_channels.length; i++) {\r\n            if (!contractExists(data.all_channels[i])) {\r\n                continue;\r\n            }\r\n            channel = NettingChannelContract(data.all_channels[i]);\r\n\r\n            var (address1, , address2, ) = channel.addressAndBalance();\r\n\r\n            result[pos] = address1;\r\n            pos += 1;\r\n            result[pos] = address2;\r\n            pos += 1;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /// @notice Get all channels that an address participates in.\r\n    /// @param node_address The address of the node\r\n    /// @return The channel's addresses that node_address participates in.\r\n    function nettingContractsByAddress(address node_address) constant returns (address[]) {\r\n        return data.nodeaddress_to_channeladdresses[node_address];\r\n    }\r\n\r\n    /// @notice Get the address of the channel token\r\n    /// @return The token\r\n    function tokenAddress() constant returns (address) {\r\n        return data.token;\r\n    }\r\n\r\n    /// @notice Get the address of channel with a partner\r\n    /// @param partner The address of the partner\r\n    /// @return The address of the channel\r\n    function getChannelWith(address partner) constant returns (address) {\r\n        return data.getChannelWith(partner);\r\n    }\r\n\r\n    /// @notice Create a new payment channel between two parties\r\n    /// @param partner The address of the partner\r\n    /// @param settle_timeout The settle timeout in blocks\r\n    /// @return The address of the newly created NettingChannelContract.\r\n    function newChannel(address partner, uint settle_timeout) returns (address) {\r\n        address old_channel = getChannelWith(partner);\r\n        if (old_channel != 0) {\r\n            ChannelDeleted(msg.sender, partner);\r\n        }\r\n\r\n        address new_channel = data.newChannel(partner, settle_timeout);\r\n        ChannelNew(new_channel, msg.sender, partner, settle_timeout);\r\n        return new_channel;\r\n    }\r\n\r\n    function () { revert(); }\r\n}\r\n\r\ncontract Registry {\r\n    string constant public contract_version = \"0.1._\";\r\n\r\n    mapping(address => address) public registry;\r\n    address[] public tokens;\r\n\r\n    event TokenAdded(address token_address, address channel_manager_address);\r\n\r\n    modifier addressExists(address _address) {\r\n        require(registry[_address] != 0x0);\r\n        _;\r\n    }\r\n\r\n    modifier doesNotExist(address _address) {\r\n        // Check if it's already registered or token contract is invalid.\r\n        // We assume if it has a valid totalSupply() function it's a valid Token contract\r\n        require(registry[_address] == 0x0);\r\n        Token token = Token(_address);\r\n        token.totalSupply();\r\n        _;\r\n    }\r\n\r\n    /// @notice Register a new ERC20 token\r\n    /// @param token_address Address of the token\r\n    /// @return The address of the channel manager\r\n    function addToken(address token_address)\r\n        doesNotExist(token_address)\r\n        returns (address)\r\n    {\r\n        address manager_address;\r\n\r\n        manager_address = new ChannelManagerContract(token_address);\r\n\r\n        registry[token_address] = manager_address;\r\n        tokens.push(token_address);\r\n\r\n        TokenAdded(token_address, manager_address);\r\n\r\n        return manager_address;\r\n    }\r\n\r\n    /// @notice Get the ChannelManager address for a specific token\r\n    /// @param token_address The address of the given token\r\n    /// @return Address of channel manager\r\n    function channelManagerByToken(address token_address)\r\n        addressExists(token_address)\r\n        constant\r\n        returns (address)\r\n    {\r\n        return registry[token_address];\r\n    }\r\n\r\n    /// @notice Get all registered tokens\r\n    /// @return addresses of all registered tokens\r\n    function tokenAddresses()\r\n        constant\r\n        returns (address[])\r\n    {\r\n        return tokens;\r\n    }\r\n\r\n    /// @notice Get the addresses of all channel managers for all registered tokens\r\n    /// @return addresses of all channel managers\r\n    function channelManagerAddresses()\r\n        constant\r\n        returns (address[])\r\n    {\r\n        uint i;\r\n        address token_address;\r\n        address[] memory result;\r\n\r\n        result = new address[](tokens.length);\r\n\r\n        for (i = 0; i < tokens.length; i++) {\r\n            token_address = tokens[i];\r\n            result[i] = registry[token_address];\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function () { revert(); }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"NettingChannelLibrary.Data storage\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"},{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"NettingChannelLibrary.Data storage\"}],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contract_version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"NettingChannelLibrary.Data storage\"},{\"name\":\"locked_encoded\",\"type\":\"bytes\"},{\"name\":\"merkle_proof\",\"type\":\"bytes\"},{\"name\":\"secret\",\"type\":\"bytes32\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"NettingChannelLibrary.Data storage\"},{\"name\":\"nonce\",\"type\":\"uint64\"},{\"name\":\"transferred_amount\",\"type\":\"uint256\"},{\"name\":\"locksroot\",\"type\":\"bytes32\"},{\"name\":\"extra_hash\",\"type\":\"bytes32\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"close\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"NettingChannelLibrary.Data storage\"}],\"name\":\"settle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"NettingChannelLibrary.Data storage\"},{\"name\":\"nonce\",\"type\":\"uint64\"},{\"name\":\"transferred_amount\",\"type\":\"uint256\"},{\"name\":\"locksroot\",\"type\":\"bytes32\"},{\"name\":\"extra_hash\",\"type\":\"bytes32\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"updateTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"NettingChannelLibrary","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://6e889d42f24590fbc3e905e2d0848939fd963bf6b35dffe93f1c3b5ddd9d96f0"}]}