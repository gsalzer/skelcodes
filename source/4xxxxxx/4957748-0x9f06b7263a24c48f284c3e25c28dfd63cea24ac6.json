{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\nlibrary SafeMath {\r\n    \r\n   function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n \r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n \r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n \r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n  function percent(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = (a * b)/100;\r\n    uint256 k = a * b;\r\n    assert(a == 0 || k / a == b);\r\n    return c;\r\n  }\r\n  \r\n}\r\n\r\ncontract Ownable {\r\naddress public owner;\r\nfunction Ownable() public {    owner = msg.sender;  }\r\n\r\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\nmodifier onlyOwner() {    require(msg.sender == owner);    _;  }\r\n\r\nfunction transferOwnership(address newOwner) public onlyOwner {\r\nrequire(newOwner != address(0));\r\nOwnershipTransferred(owner, newOwner);\r\nowner = newOwner;\r\n  }\r\n\r\n}\r\n\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply=1000000;\r\n  function balanceOf(address who) public constant returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n \r\n}\r\ncontract BasicToken is ERC20Basic, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint) public Account_balances;\r\n    mapping (address => uint) public Account_frozen;\r\n    mapping (address => uint) public Account_timePayout; \r\n    \r\n    event FrozenAccount_event(address target, uint frozen);\r\n\r\n\r\n  function transfer(address _toaddress, uint256 _value) public returns (bool) {\r\n    require(Account_frozen[msg.sender]==0 );\r\n    require(Account_frozen[_toaddress]==0 );\r\n    Account_timePayout[_toaddress]=Account_timePayout[msg.sender];\r\n    Account_balances[msg.sender] = Account_balances[msg.sender].sub(_value);\r\n    Account_balances[_toaddress] = Account_balances[_toaddress].add(_value);\r\n    Transfer(msg.sender, _toaddress, _value);\r\n    return true;\r\n  }\r\n \r\n  function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n    return Account_balances[_owner];\r\n     }\r\n  \r\n function BasicToken()    public {   \r\n     Account_balances[msg.sender] =   totalSupply;    \r\n          }\r\n }\r\ncontract AESconstants is BasicToken {\r\n    string public constant name = \"Adept Ethereum Stocks\";\r\n    string public constant symbol = \"AES\";\r\n    string public constant tagline = \"AES - when resoluteness is rewarded!\";\r\n    uint32 public constant decimals = 0;\r\n}\r\ncontract Freeze_contract is AESconstants {\r\n   \r\nfunction Freeze(address _address, uint _uint)   private {\r\nAccount_frozen[_address] = _uint;\r\nFrozenAccount_event(_address, _uint);\r\n}    \r\n    \r\n// mapping (address => uint) public frozenAccount;\r\n// 0 NO FREEZE\r\n// 1 Freeze onlyOwner\r\n// 2 Freeze user    \r\n\r\n//Freeze user //this is done to freeze your account. To avoid an attack: a block of dividend payments using spam transactions.\r\nfunction user_on_freeze() public  {     require(Account_frozen[msg.sender]==0);  Freeze(msg.sender,2);   }\r\nfunction user_off_freeze() public {    require(Account_frozen[msg.sender]==2);   Freeze(msg.sender,0);   }\r\n//Freeze used bounty company\r\n\r\n\r\nfunction pay_Bounty(address _address, uint _sum_pay )  onlyOwner public {\r\ntransfer(_address, _sum_pay); \r\nFreeze(_address, 1);\r\n} \r\n\r\nfunction offFreeze_Bounty(address _address) onlyOwner public { Freeze(_address, 0); }     \r\n   \r\n}\r\n\r\n\r\ncontract AES_token_contract is Freeze_contract {\r\nusing SafeMath for uint;\r\n\r\nuint public next_payout=now + 90 days;\r\nuint public payout = 0; // Бюджет дивидентов\r\n\r\n//--------Выплата доли  \r\nfunction Take_payout() public {\r\n//Проверка можно ли пользователю запрашивать\r\nrequire(Account_timePayout[msg.sender] < now);\r\n//Проверка периода, если период прошел начисляем  бюджет выплат\r\nif(next_payout<now){\r\npayout=this.balance; \r\nnext_payout=now + 90 days;\r\n}   \r\n\r\nmsg.sender.transfer(payout.mul(Account_balances[msg.sender]).div(totalSupply));\r\nAccount_timePayout[msg.sender]=next_payout;\r\n      }\r\n\r\nfunction() external payable {} \r\n   \r\n }\r\ncontract Hype is Ownable {\r\nusing SafeMath for uint;  \r\naddress public investors;\r\nfunction Hype(address _addres)  onlyOwner public {investors=_addres;    }\r\n    mapping (uint => address) public level;    \r\n    uint private price=5000000000000000;      // in wei    1000 finney in 1 ether\r\n    uint public step_level=0;\r\n    uint public step_pay=0;\r\n    uint private constant percent_hype=10;\r\n    uint private constant percent_investors=3;\r\n    uint private bonus=price.percent(100+percent_hype);\r\n    \r\nfunction() external payable {\r\nrequire(msg.value > 4999999999999999);\r\nuint amt_deposit=msg.value.div(price); // Количество шагов // обязательно перед выплатой инвесторам\r\ninvestors.transfer(msg.value.percent(percent_investors));       //Переводим процент инвесторам\r\n\r\n for (  uint i= 0; i < amt_deposit; i++) { \r\n        if (level[step_pay].send(bonus)==true){\r\n          step_pay++;\r\n                                              }\r\n     level[step_level]=msg.sender;\r\n     step_level++;\r\n                                              }\r\n                                              }\r\n\r\n   \r\n}\r\ncontract BigHype is Ownable {\r\nusing SafeMath for uint;  \r\naddress public investors;\r\nfunction BigHype(address _addres)  onlyOwner public {investors=_addres;      }\r\n\r\nstruct info {\r\n        address i_address;\r\n        uint i_balance;\r\n            }\r\n\r\n    mapping (uint => info) public level;    \r\n    uint public step_level=0;\r\n    uint public step_pay=0;\r\n    uint private constant percent_hype=10;\r\n    uint private constant percent_investors=3;\r\n \r\nfunction() external payable {\r\nrequire(msg.value > 4999999999999999); \r\ninvestors.transfer(msg.value.percent(percent_investors));       \r\nuint bonus=(level[step_pay].i_balance).percent(100+percent_hype);  \r\n if (step_level>0 && level[step_pay].i_address.send(bonus)==true){\r\n          step_pay++;\r\n                                                                 }\r\n     level[step_level].i_address=msg.sender;\r\n     level[step_level].i_balance=msg.value;\r\n     step_level++;\r\n}\r\n\r\n}\r\n\r\n\r\ncontract Crowdsale is Ownable {\r\n  \r\naddress private\tmultisig = msg.sender; \r\nbool private share_team_AES=false;\r\n\r\n\r\nusing SafeMath for uint;\r\n\r\nAES_token_contract   public AEStoken  = new AES_token_contract(); \r\nHype     public hype    = new Hype(AEStoken);\r\nBigHype  public bighype = new BigHype(AEStoken);\r\n\r\nuint public Time_Start_Crowdsale= 1518210000; // 1518210000  - 10 February 2018\r\n\r\n// Выплата команде и баунти\r\nfunction Take_share_team_AES() onlyOwner public {\r\nrequire(share_team_AES == false);\r\nAEStoken.transfer(multisig,500000); \r\nshare_team_AES=true;\r\n}\r\n\r\n// старт\r\nfunction For_admin() onlyOwner public {\r\nAEStoken.transferOwnership(multisig); \r\nhype.transferOwnership(multisig); \r\nbighype.transferOwnership(multisig); \r\n}\r\n\r\n\r\nfunction getTokensSale() public  view returns(uint){  return AEStoken.balanceOf(this);  }\r\nfunction getBalance_in_token() public view returns(uint){  return AEStoken.balanceOf(msg.sender); }\r\n \r\nmodifier isSaleTime() {  require(Time_Start_Crowdsale<now);  _;  } \r\n \r\n // Всего 1 000 000 токенов AES\r\n // 400 000 баунти          40%\r\n // 100 000 команда проекта 10%\r\n // 500 000 SALE IN ICO     50%\r\n\r\n \r\n   function createTokens() isSaleTime private  {\r\n      \r\n        uint Tokens_on_Sale = AEStoken.balanceOf(this);      \r\n        uint CenaTokena=1000000000000000; //1 finney= 1000 Szabo =0.002 Ether  //   1000 Szabo= 1 finney\r\n        \r\n        uint Discount=0;\r\n        \r\n      // Скидка от остатка для распродажи\r\n            if(Tokens_on_Sale>400000)   {Discount+=20;}   //Szabo\r\n       else if(Tokens_on_Sale>300000)   {Discount+=15; }   //Szabo\r\n       else if(Tokens_on_Sale>200000)   {Discount+=10; }   //2000 Szabo   1000 Szabo= 1 finney\r\n       else if(Tokens_on_Sale>100000)   {Discount+=5; } \r\n       \r\n       // Скидка от объема\r\n            if(msg.value> 1000000000000000000 && Tokens_on_Sale>2500 )  {Discount+=20; }   // Если покупка больше чем на 1 эфиров \r\n       else if(msg.value>  900000000000000000 && Tokens_on_Sale>1500 )  {Discount+=15;  }   // Если покупка больше чем на 0.9 эфиров \r\n       else if(msg.value>  600000000000000000 && Tokens_on_Sale>500  )  {Discount+=10;  }   // Если покупка больше чем на 0.6 эфира \r\n       else if(msg.value>  300000000000000000 && Tokens_on_Sale>250  )  {Discount+=5;  }   // Если покупка больше чем на 0.3 эфир \r\n       \r\n       //Скидка от времени\r\n     uint256   Time_Discount=now-Time_Start_Crowdsale;\r\n             if(Time_Discount < 3 days)   {Discount+=20; }\r\n        else if(Time_Discount < 5 days)   {Discount+=15; }       \r\n        else if(Time_Discount < 10 days)  {Discount+=10; }\r\n        else if(Time_Discount < 20 days)  {Discount+=5;  } \r\n         \r\n     CenaTokena=CenaTokena.percent(100-Discount); // Делаем скидку\r\n     uint256 Tokens=msg.value.div(CenaTokena); // Узнаем сколько токенов купили\r\n       \r\n        if (Tokens_on_Sale>=Tokens)   {         \r\n            multisig.transfer(msg.value);\r\n          }\r\n     else {\r\n        multisig.transfer(msg.value.mul(Tokens_on_Sale.div(Tokens)));   // Оплату приняли сколько влезло\r\n        msg.sender.transfer(msg.value.mul(Tokens-Tokens_on_Sale).div(Tokens));  // Что не влезло назад\r\n        Tokens=Tokens_on_Sale;\r\n        }\r\n        \r\n       AEStoken.transfer(msg.sender, Tokens);\r\n        \r\n        }\r\n       \r\n \r\n    function() external payable {\r\n     \r\n      if (AEStoken.balanceOf(this)>0)  { createTokens(); }\r\n      else { AEStoken.transfer(msg.value); }// После окончания ICO принимаем пожертвования\r\n        \r\n    }\r\n    \r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"Time_Start_Crowdsale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bighype\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hype\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"For_admin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokensSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"AEStoken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"Take_share_team_AES\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBalance_in_token\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Crowdsale","CompilerVersion":"v0.4.20-nightly.2018.1.22+commit.e5def2da","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://14ae6876cdc362f5d54adde91d80645cff3d5c8ab77c6561d15a6c0df3bac7df"}]}