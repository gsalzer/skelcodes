{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^ 0.4.13;\r\n\r\ncontract MigrationAgent {\r\n    function migrateFrom(address _from, uint256 _value);\r\n}\r\n\r\ncontract PreZeusToken {\r\n    function balanceOf(address _owner) constant returns(uint256 balance);\r\n}\r\n\r\ncontract Owned {\r\n\r\n    address public owner;\r\n    address public newOwner;\r\n    address public oracle;\r\n    address public btcOracle;\r\n\r\n    function Owned() payable {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(owner == msg.sender);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerOrOracle {\r\n        require(owner == msg.sender || oracle == msg.sender);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerOrBtcOracle {\r\n        require(owner == msg.sender || btcOracle == msg.sender);\r\n        _;\r\n    }\r\n\r\n    function changeOwner(address _owner) onlyOwner external {\r\n        require(_owner != 0);\r\n        newOwner = _owner;\r\n    }\r\n\r\n    function confirmOwner() external {\r\n        require(newOwner == msg.sender);\r\n        owner = newOwner;\r\n        delete newOwner;\r\n    }\r\n\r\n    function changeOracle(address _oracle) onlyOwner external {\r\n        require(_oracle != 0);\r\n        oracle = _oracle;\r\n    }\r\n\r\n    function changeBtcOracle(address _btcOracle) onlyOwner external {\r\n        require(_btcOracle != 0);\r\n        btcOracle = _btcOracle;\r\n    }\r\n}\r\n\r\ncontract KnownContract {\r\n    function transfered(address _sender, uint256 _value, bytes32[] _data) external;\r\n}\r\n\r\ncontract ERC20 {\r\n    uint public totalSupply;\r\n\r\n    function balanceOf(address who) constant returns(uint);\r\n\r\n    function transfer(address to, uint value);\r\n\r\n    function allowance(address owner, address spender) constant returns(uint);\r\n\r\n    function transferFrom(address from, address to, uint value);\r\n\r\n    function approve(address spender, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n}\r\n\r\ncontract Stateful {\r\n    enum State {\r\n        Initial,\r\n        PrivateSale,\r\n        PreSale,\r\n        WaitingForSale,\r\n        Sale,\r\n        CrowdsaleCompleted,\r\n        SaleFailed\r\n    }\r\n    State public state = State.Initial;\r\n\r\n    event StateChanged(State oldState, State newState);\r\n\r\n    function setState(State newState) internal {\r\n        State oldState = state;\r\n        state = newState;\r\n        StateChanged(oldState, newState);\r\n    }\r\n}\r\n\r\ncontract Crowdsale is Owned, Stateful {\r\n\r\n    uint public etherPriceUSDWEI;\r\n    address public beneficiary;\r\n    uint public totalLimitUSDWEI;\r\n    uint public minimalSuccessUSDWEI;\r\n    uint public collectedUSDWEI;\r\n\r\n    uint public crowdsaleStartTime;\r\n    uint public crowdsaleFinishTime;\r\n\r\n    struct Investor {\r\n        uint amountTokens;\r\n        uint amountWei;\r\n    }\r\n\r\n    struct BtcDeposit {\r\n        uint amountBTCWEI;\r\n        uint btcPriceUSDWEI;\r\n        address investor;\r\n    }\r\n\r\n    mapping(bytes32 => BtcDeposit) public btcDeposits;\r\n\r\n    mapping(address => Investor) public investors;\r\n    mapping(uint => address) public investorsIter;\r\n    uint public numberOfInvestors;\r\n\r\n    mapping(uint => address) public investorsToWithdrawIter;\r\n    uint public numberOfInvestorsToWithdraw;\r\n\r\n    function Crowdsale() payable Owned() {}\r\n\r\n    //abstract methods\r\n    function emitTokens(address _investor, uint _tokenPriceUSDWEI, uint _usdwei) internal returns(uint tokensToEmit);\r\n\r\n    function emitAdditionalTokens() internal;\r\n\r\n    function burnTokens(address _address, uint _amount) internal;\r\n\r\n    function() payable crowdsaleState limitNotExceeded {\r\n        uint valueWEI = msg.value;\r\n        uint valueUSDWEI = valueWEI * etherPriceUSDWEI / 1 ether;\r\n        uint tokenPriceUSDWEI = getTokenPriceUSDWEI(valueUSDWEI);\r\n\r\n        if (collectedUSDWEI + valueUSDWEI > totalLimitUSDWEI) { // don't need so much ether\r\n            valueUSDWEI = totalLimitUSDWEI - collectedUSDWEI;\r\n            valueWEI = valueUSDWEI * 1 ether / etherPriceUSDWEI;\r\n            uint weiToReturn = msg.value - valueWEI;\r\n            bool isSent = msg.sender.call.gas(3000000).value(weiToReturn)();\r\n            require(isSent);\r\n            collectedUSDWEI = totalLimitUSDWEI; // to be sure!                                                   \r\n        } else {\r\n            collectedUSDWEI += valueUSDWEI;\r\n        }\r\n        emitTokensFor(msg.sender, tokenPriceUSDWEI, valueUSDWEI, valueWEI);\r\n\r\n    }\r\n\r\n    function depositUSD(address _to, uint _amountUSDWEI) external onlyOwner crowdsaleState limitNotExceeded {\r\n        uint tokenPriceUSDWEI = getTokenPriceUSDWEI(_amountUSDWEI);\r\n        collectedUSDWEI += _amountUSDWEI;\r\n        emitTokensFor(_to, tokenPriceUSDWEI, _amountUSDWEI, 0);\r\n    }\r\n\r\n    function depositBTC(address _to, uint _amountBTCWEI, uint _btcPriceUSDWEI, bytes32 _btcTxId) external onlyOwnerOrBtcOracle crowdsaleState limitNotExceeded {\r\n        uint valueUSDWEI = _amountBTCWEI * _btcPriceUSDWEI / 1 ether;\r\n        uint tokenPriceUSDWEI = getTokenPriceUSDWEI(valueUSDWEI);\r\n        BtcDeposit storage btcDep = btcDeposits[_btcTxId];\r\n        require(btcDep.amountBTCWEI == 0);\r\n        btcDep.amountBTCWEI = _amountBTCWEI;\r\n        btcDep.btcPriceUSDWEI = _btcPriceUSDWEI;\r\n        btcDep.investor = _to;\r\n        collectedUSDWEI += valueUSDWEI;\r\n        emitTokensFor(_to, tokenPriceUSDWEI, valueUSDWEI, 0);\r\n    }\r\n\r\n    function emitTokensFor(address _investor, uint _tokenPriceUSDWEI, uint _valueUSDWEI, uint _valueWEI) internal {\r\n        var emittedTokens = emitTokens(_investor, _tokenPriceUSDWEI, _valueUSDWEI);\r\n        Investor storage inv = investors[_investor];\r\n        if (inv.amountTokens == 0) { // new investor\r\n            investorsIter[numberOfInvestors++] = _investor;\r\n        }\r\n        inv.amountTokens += emittedTokens;\r\n        if (state == State.Sale) {\r\n            inv.amountWei += _valueWEI;\r\n        }\r\n    }\r\n\r\n    function getTokenPriceUSDWEI(uint _valueUSDWEI) internal returns(uint tokenPriceUSDWEI) {\r\n        tokenPriceUSDWEI = 0;\r\n        if (state == State.PrivateSale) {\r\n            tokenPriceUSDWEI = 6000000000000000;\r\n        }\r\n        if (state == State.PreSale) {\r\n            require(now < crowdsaleFinishTime);\r\n            tokenPriceUSDWEI = 7000000000000000;\r\n        }\r\n        if (state == State.Sale) {\r\n            require(now < crowdsaleFinishTime);\r\n            if (now < crowdsaleStartTime + 1 days) {\r\n                if (_valueUSDWEI > 30000 * 1 ether) {\r\n                    tokenPriceUSDWEI = 7500000000000000;\r\n                } else {\r\n                    tokenPriceUSDWEI = 8500000000000000;\r\n                }\r\n            } else if (now < crowdsaleStartTime + 1 weeks) {\r\n                tokenPriceUSDWEI = 9000000000000000;\r\n            } else if (now < crowdsaleStartTime + 2 weeks) {\r\n                tokenPriceUSDWEI = 9500000000000000;\r\n            } else {\r\n                tokenPriceUSDWEI = 10000000000000000;\r\n            }\r\n        }\r\n    }\r\n\r\n    function startPrivateSale(address _beneficiary, uint _etherPriceUSDWEI, uint _totalLimitUSDWEI) external onlyOwner {\r\n        require(state == State.Initial);\r\n        beneficiary = _beneficiary;\r\n        etherPriceUSDWEI = _etherPriceUSDWEI;\r\n        totalLimitUSDWEI = _totalLimitUSDWEI;\r\n        crowdsaleStartTime = now;\r\n        setState(State.PrivateSale);\r\n    }\r\n\r\n    function finishPrivateSaleAndStartPreSale(\r\n        address _beneficiary,\r\n        uint _etherPriceUSDWEI,\r\n        uint _totalLimitUSDWEI,\r\n        uint _crowdsaleDurationDays) public onlyOwner {\r\n        require(state == State.PrivateSale);\r\n\r\n        bool isSent = beneficiary.call.gas(3000000).value(this.balance)();\r\n        require(isSent);\r\n\r\n        crowdsaleStartTime = now;\r\n        beneficiary = _beneficiary;\r\n        etherPriceUSDWEI = _etherPriceUSDWEI;\r\n        totalLimitUSDWEI = _totalLimitUSDWEI;\r\n        crowdsaleFinishTime = now + _crowdsaleDurationDays * 1 days;\r\n        collectedUSDWEI = 0;\r\n        setState(State.PreSale);\r\n    }\r\n\r\n\r\n    function finishPreSale() public onlyOwner {\r\n        require(state == State.PreSale);\r\n        bool isSent = beneficiary.call.gas(3000000).value(this.balance)();\r\n        require(isSent);\r\n        setState(State.WaitingForSale);\r\n    }\r\n\r\n    function startSale(\r\n        address _beneficiary,\r\n        uint _etherPriceUSDWEI,\r\n        uint _totalLimitUSDWEI,\r\n        uint _crowdsaleDurationDays,\r\n        uint _minimalSuccessUSDWEI) external onlyOwner {\r\n\r\n        require(state == State.WaitingForSale);\r\n        crowdsaleStartTime = now;\r\n        beneficiary = _beneficiary;\r\n        etherPriceUSDWEI = _etherPriceUSDWEI;\r\n        totalLimitUSDWEI = _totalLimitUSDWEI;\r\n        crowdsaleFinishTime = now + _crowdsaleDurationDays * 1 days;\r\n        minimalSuccessUSDWEI = _minimalSuccessUSDWEI;\r\n        collectedUSDWEI = 0;\r\n        setState(State.Sale);\r\n    }\r\n\r\n    function failSale(uint _investorsToProcess) public {\r\n        require(state == State.Sale);\r\n        require(now >= crowdsaleFinishTime && collectedUSDWEI < minimalSuccessUSDWEI);\r\n        while (_investorsToProcess > 0 && numberOfInvestors > 0) {\r\n            address addr = investorsIter[--numberOfInvestors];\r\n            Investor memory inv = investors[addr];\r\n            burnTokens(addr, inv.amountTokens);\r\n            --_investorsToProcess;\r\n            delete investorsIter[numberOfInvestors];\r\n\r\n            investorsToWithdrawIter[numberOfInvestorsToWithdraw] = addr;\r\n            numberOfInvestorsToWithdraw++;\r\n        }\r\n        if (numberOfInvestors > 0) {\r\n            return;\r\n        }\r\n        setState(State.SaleFailed);\r\n    }\r\n\r\n    function completeSale(uint _investorsToProcess) public onlyOwner {\r\n        require(state == State.Sale);\r\n        require(collectedUSDWEI >= minimalSuccessUSDWEI);\r\n\r\n        while (_investorsToProcess > 0 && numberOfInvestors > 0) {\r\n            --numberOfInvestors;\r\n            --_investorsToProcess;\r\n            delete investors[investorsIter[numberOfInvestors]];\r\n            delete investorsIter[numberOfInvestors];\r\n        }\r\n\r\n        if (numberOfInvestors > 0) {\r\n            return;\r\n        }\r\n\r\n        emitAdditionalTokens();\r\n\r\n        bool isSent = beneficiary.call.gas(3000000).value(this.balance)();\r\n        require(isSent);\r\n        setState(State.CrowdsaleCompleted);\r\n    }\r\n\r\n\r\n    function setEtherPriceUSDWEI(uint _etherPriceUSDWEI) external onlyOwnerOrOracle {\r\n        etherPriceUSDWEI = _etherPriceUSDWEI;\r\n    }\r\n\r\n    function setBeneficiary(address _beneficiary) external onlyOwner {\r\n        require(_beneficiary != 0);\r\n        beneficiary = _beneficiary;\r\n    }\r\n\r\n    // This function must be called by token holder in case of crowdsale failed\r\n    function withdrawBack() external saleFailedState {\r\n        returnInvestmentsToInternal(msg.sender);\r\n    }\r\n\r\n    function returnInvestments(uint _investorsToProcess) public saleFailedState {\r\n        while (_investorsToProcess > 0 && numberOfInvestorsToWithdraw > 0) {\r\n            address addr = investorsToWithdrawIter[--numberOfInvestorsToWithdraw];\r\n            delete investorsToWithdrawIter[numberOfInvestorsToWithdraw];\r\n            --_investorsToProcess;\r\n            returnInvestmentsToInternal(addr);\r\n        }\r\n    }\r\n\r\n    function returnInvestmentsTo(address _to) public saleFailedState {\r\n        returnInvestmentsToInternal(_to);\r\n    }\r\n\r\n    function returnInvestmentsToInternal(address _to) internal {\r\n        Investor memory inv = investors[_to];\r\n        uint value = inv.amountWei;\r\n        if (value > 0) {\r\n            delete investors[_to];\r\n            require(_to.call.gas(3000000).value(value)());\r\n        }\r\n    }\r\n\r\n    function withdrawFunds(uint _value) public onlyOwner {\r\n        require(state == State.PrivateSale || state == State.PreSale || (state == State.Sale && collectedUSDWEI > minimalSuccessUSDWEI));\r\n        if (_value == 0) {\r\n            _value = this.balance;\r\n        }\r\n        bool isSent = beneficiary.call.gas(3000000).value(_value)();\r\n        require(isSent);\r\n    }\r\n\r\n    modifier limitNotExceeded {\r\n        require(collectedUSDWEI < totalLimitUSDWEI);\r\n        _;\r\n    }\r\n\r\n    modifier crowdsaleState {\r\n        require(state == State.PrivateSale || state == State.PreSale || state == State.Sale);\r\n        _;\r\n    }\r\n\r\n    modifier saleFailedState {\r\n        require(state == State.SaleFailed);\r\n        _;\r\n    }\r\n\r\n    modifier completedSaleState {\r\n        require(state == State.CrowdsaleCompleted);\r\n        _;\r\n    }\r\n}\r\n\r\ncontract Token is Crowdsale, ERC20 {\r\n\r\n    mapping(address => uint) internal balances;\r\n    mapping(address => mapping(address => uint)) public allowed;\r\n    uint8 public constant decimals = 8;\r\n\r\n    function Token() payable Crowdsale() {}\r\n\r\n    function balanceOf(address who) constant returns(uint) {\r\n        return balances[who];\r\n    }\r\n\r\n    function transfer(address _to, uint _value) public completedSaleState onlyPayloadSize(2 * 32) {\r\n        require(balances[msg.sender] >= _value);\r\n        require(balances[_to] + _value >= balances[_to]); // overflow\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) public completedSaleState onlyPayloadSize(3 * 32) {\r\n        require(balances[_from] >= _value);\r\n        require(balances[_to] + _value >= balances[_to]); // overflow\r\n        require(allowed[_from][msg.sender] >= _value);\r\n        balances[_from] -= _value;\r\n        balances[_to] += _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n    }\r\n\r\n    function approve(address _spender, uint _value) public completedSaleState {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public constant completedSaleState returns(uint remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    modifier onlyPayloadSize(uint size) {\r\n        require(msg.data.length >= size + 4);\r\n        _;\r\n    }\r\n}\r\n\r\ncontract MigratableToken is Token {\r\n\r\n    function MigratableToken() payable Token() {}\r\n\r\n    address public migrationAgent;\r\n    uint public totalMigrated;\r\n    address public migrationHost;\r\n    mapping(address => bool) migratedInvestors;\r\n\r\n    event Migrated(address indexed from, address indexed to, uint value);\r\n\r\n    function setMigrationHost(address _address) external onlyOwner {\r\n        require(_address != 0);\r\n        migrationHost = _address;\r\n    }\r\n\r\n    //manual migration by owner\r\n    function migrateInvestorFromHost(address _address) external onlyOwner {\r\n        require(migrationHost != 0 && state != State.SaleFailed && migratedInvestors[_address] == false);\r\n        PreZeusToken preZeus = PreZeusToken(migrationHost);\r\n        uint tokensToTransfer = preZeus.balanceOf(_address);\r\n        require(tokensToTransfer > 0);\r\n\r\n        balances[_address] = tokensToTransfer;\r\n        totalSupply += tokensToTransfer;\r\n        migratedInvestors[_address] = true;\r\n\r\n        if (state != State.CrowdsaleCompleted) {\r\n            Investor storage inv = investors[_address];\r\n            investorsIter[numberOfInvestors++] = _address;\r\n            inv.amountTokens += tokensToTransfer;\r\n        }\r\n\r\n        Transfer(this, _address, tokensToTransfer);\r\n    }\r\n\r\n    //migration by investor\r\n    function migrate() external {\r\n        require(migrationAgent != 0);\r\n        uint value = balances[msg.sender];\r\n        balances[msg.sender] -= value;\r\n        Transfer(msg.sender, this, value);\r\n        totalSupply -= value;\r\n        totalMigrated += value;\r\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, value);\r\n        Migrated(msg.sender, migrationAgent, value);\r\n    }\r\n\r\n    function setMigrationAgent(address _agent) external onlyOwner {\r\n        require(migrationAgent == 0);\r\n        migrationAgent = _agent;\r\n    }\r\n}\r\n\r\ncontract ZeusToken is MigratableToken {\r\n\r\n    string public constant symbol = \"ZST\";\r\n\r\n    string public constant name = \"Zeus Token\";\r\n\r\n    mapping(address => bool) public allowedContracts;\r\n\r\n    function ZeusToken() payable MigratableToken() {}\r\n\r\n    function emitTokens(address _investor, uint _tokenPriceUSDWEI, uint _valueUSDWEI) internal returns(uint tokensToEmit) {\r\n        tokensToEmit = (_valueUSDWEI * (10 ** uint(decimals))) / _tokenPriceUSDWEI;\r\n        require(balances[_investor] + tokensToEmit > balances[_investor]); // overflow\r\n        require(tokensToEmit > 0);\r\n        balances[_investor] += tokensToEmit;\r\n        totalSupply += tokensToEmit;\r\n        Transfer(this, _investor, tokensToEmit);\r\n    }\r\n\r\n    function emitAdditionalTokens() internal {\r\n        uint tokensToEmit = totalSupply * 1000 / 705 - totalSupply;\r\n        require(balances[beneficiary] + tokensToEmit > balances[beneficiary]); // overflow\r\n        require(tokensToEmit > 0);\r\n        balances[beneficiary] += tokensToEmit;\r\n        totalSupply += tokensToEmit;\r\n        Transfer(this, beneficiary, tokensToEmit);\r\n    }\r\n\r\n    function burnTokens(address _address, uint _amount) internal {\r\n        balances[_address] -= _amount;\r\n        totalSupply -= _amount;\r\n        Transfer(_address, this, _amount);\r\n    }\r\n\r\n    function addAllowedContract(address _address) external onlyOwner {\r\n        require(_address != 0);\r\n        allowedContracts[_address] = true;\r\n    }\r\n\r\n    function removeAllowedContract(address _address) external onlyOwner {\r\n        require(_address != 0);\r\n        delete allowedContracts[_address];\r\n    }\r\n\r\n    function transferToKnownContract(address _to, uint256 _value, bytes32[] _data) external onlyAllowedContracts(_to) {\r\n        var knownContract = KnownContract(_to);\r\n        transfer(_to, _value);\r\n        knownContract.transfered(msg.sender, _value, _data);\r\n    }\r\n\r\n    modifier onlyAllowedContracts(address _address) {\r\n        require(allowedContracts[_address] == true);\r\n        _;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_etherPriceUSDWEI\",\"type\":\"uint256\"},{\"name\":\"_totalLimitUSDWEI\",\"type\":\"uint256\"},{\"name\":\"_crowdsaleDurationDays\",\"type\":\"uint256\"},{\"name\":\"_minimalSuccessUSDWEI\",\"type\":\"uint256\"}],\"name\":\"startSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"investorsIter\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBack\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investorsToProcess\",\"type\":\"uint256\"}],\"name\":\"failSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_etherPriceUSDWEI\",\"type\":\"uint256\"}],\"name\":\"setEtherPriceUSDWEI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimalSuccessUSDWEI\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_btcOracle\",\"type\":\"address\"}],\"name\":\"changeBtcOracle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfInvestors\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"setBeneficiary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"btcOracle\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_etherPriceUSDWEI\",\"type\":\"uint256\"},{\"name\":\"_totalLimitUSDWEI\",\"type\":\"uint256\"}],\"name\":\"startPrivateSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"addAllowedContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"returnInvestmentsTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"collectedUSDWEI\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishPreSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amountBTCWEI\",\"type\":\"uint256\"},{\"name\":\"_btcPriceUSDWEI\",\"type\":\"uint256\"},{\"name\":\"_btcTxId\",\"type\":\"bytes32\"}],\"name\":\"depositBTC\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"changeOracle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowedContracts\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"investors\",\"outputs\":[{\"name\":\"amountTokens\",\"type\":\"uint256\"},{\"name\":\"amountWei\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investorsToProcess\",\"type\":\"uint256\"}],\"name\":\"completeSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_agent\",\"type\":\"address\"}],\"name\":\"setMigrationAgent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setMigrationHost\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investorsToProcess\",\"type\":\"uint256\"}],\"name\":\"returnInvestments\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"migrationAgent\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"migrate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalMigrated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleFinishTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"removeAllowedContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfInvestorsToWithdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"btcDeposits\",\"outputs\":[{\"name\":\"amountBTCWEI\",\"type\":\"uint256\"},{\"name\":\"btcPriceUSDWEI\",\"type\":\"uint256\"},{\"name\":\"investor\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"migrateInvestorFromHost\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"etherPriceUSDWEI\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"migrationHost\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"investorsToWithdrawIter\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"confirmOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amountUSDWEI\",\"type\":\"uint256\"}],\"name\":\"depositUSD\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes32[]\"}],\"name\":\"transferToKnownContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalLimitUSDWEI\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_etherPriceUSDWEI\",\"type\":\"uint256\"},{\"name\":\"_totalLimitUSDWEI\",\"type\":\"uint256\"},{\"name\":\"_crowdsaleDurationDays\",\"type\":\"uint256\"}],\"name\":\"finishPrivateSaleAndStartPreSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Migrated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldState\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"newState\",\"type\":\"uint8\"}],\"name\":\"StateChanged\",\"type\":\"event\"}]","ContractName":"ZeusToken","CompilerVersion":"v0.4.16+commit.d7661dd9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://55bc755028b4f72823e1318437a1b032609655fc4c0b137982d3579405e12b55"}]}