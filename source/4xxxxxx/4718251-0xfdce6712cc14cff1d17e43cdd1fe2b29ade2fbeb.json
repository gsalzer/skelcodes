{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.18;\r\n\r\n/**\r\n * @title Wallet Admin Library\r\n * @author Modular.network\r\n *\r\n * version 1.1.0\r\n * Copyright (c) 2017 Modular, Inc\r\n * The MIT License (MIT)\r\n * https://github.com/Modular-Network/ethereum-libraries/blob/master/LICENSE\r\n *\r\n * The Wallet Library family is inspired by the multisig wallets built by Consensys\r\n * at https://github.com/ConsenSys/MultiSigWallet and Parity at\r\n * https://github.com/paritytech/contracts/blob/master/Wallet.sol with added\r\n * functionality. Modular works on open source projects in the Ethereum\r\n * community with the purpose of testing, documenting, and deploying reusable\r\n * code onto the blockchain to improve security and usability of smart contracts.\r\n * Modular also strives to educate non-profits, schools, and other community\r\n * members about the application of blockchain technology. For further\r\n * information: modular.network, consensys.net, paritytech.io\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\nlibrary WalletAdminLib {\r\n  using WalletMainLib for WalletMainLib.WalletData;\r\n\r\n  /*Events*/\r\n  event LogTransactionConfirmed(bytes32 txid, address sender, uint256 confirmsNeeded);\r\n  event LogOwnerAdded(address newOwner);\r\n  event LogOwnerRemoved(address ownerRemoved);\r\n  event LogOwnerChanged(address from, address to);\r\n  event LogRequirementChange(uint256 newRequired);\r\n  event LogThresholdChange(address token, uint256 newThreshold);\r\n  event LogErrorMsg(uint256 amount, string msg);\r\n\r\n  /*Checks*/\r\n\r\n  /// @dev Validates arguments for changeOwner function\r\n  /// @param _from Index of current owner removing\r\n  /// @param _to Index of new potential owner, should be 0\r\n  /// @return Returns true if check passes, false otherwise\r\n  function checkChangeOwnerArgs(uint256 _from, uint256 _to)\r\n           private returns (bool)\r\n  {\r\n    if(_from == 0){\r\n      LogErrorMsg(_from, \"Change from address is not an owner\");\r\n      return false;\r\n    }\r\n    if(_to != 0){\r\n      LogErrorMsg(_to, \"Change to address is an owner\");\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /// @dev Validates arguments for addOwner function\r\n  /// @param _index Index of new owner, should be 0\r\n  /// @param _length Current length of owner array\r\n  /// @return Returns true if check passes, false otherwise\r\n  function checkNewOwnerArgs(uint256 _index, uint256 _length, uint256 _max)\r\n           private returns (bool)\r\n  {\r\n    if(_index != 0){\r\n      LogErrorMsg(_index, \"New owner already owner\");\r\n      return false;\r\n    }\r\n    if((_length + 1) > _max){\r\n      LogErrorMsg(_length, \"Too many owners\");\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /// @dev Validates arguments for removeOwner function\r\n  /// @param _index Index of owner removing\r\n  /// @param _length Current number of owners\r\n  /// @param _min Minimum owners currently required to meet sig requirements\r\n  /// @return Returs true if check passes, false otherwise\r\n  function checkRemoveOwnerArgs(uint256 _index, uint256 _length, uint256 _min)\r\n           private returns (bool)\r\n  {\r\n    if(_index == 0){\r\n      LogErrorMsg(_index, \"Owner removing not an owner\");\r\n      return false;\r\n    }\r\n    if(_length - 2 < _min) {\r\n      LogErrorMsg(_index, \"Must reduce requiredAdmin first\");\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /// @dev Validates arguments for changing any of the sig requirement parameters\r\n  /// @param _newRequired The new sig requirement\r\n  /// @param _length Current number of owners\r\n  /// @return Returns true if checks pass, false otherwise\r\n  function checkRequiredChange(uint256 _newRequired, uint256 _length)\r\n           private returns (bool)\r\n  {\r\n    if(_newRequired == 0){\r\n      LogErrorMsg(_newRequired, \"Cant reduce to 0\");\r\n      return false;\r\n    }\r\n    if(_length - 2 < _newRequired){\r\n      LogErrorMsg(_length, \"Making requirement too high\");\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /*Utility Functions*/\r\n\r\n  /// @dev Used later to calculate the number of confirmations needed for tx\r\n  /// @param _required Number of sigs required\r\n  /// @param _count Current number of sigs\r\n  function calcConfirmsNeeded(uint256 _required, uint256 _count) private pure returns (uint256) {\r\n    return _required - _count;\r\n  }\r\n\r\n  /*Administrative Functions*/\r\n\r\n  /// @dev Changes owner address to a new address\r\n  /// @param self Wallet in contract storage\r\n  /// @param _from Current owner address\r\n  /// @param _to New address\r\n  /// @param _confirm True if confirming, false if revoking confirmation\r\n  /// @param _data Message data passed from wallet contract\r\n  /// @return bool Returns true if successful, false otherwise\r\n  /// @return bytes32 Returns the tx ID, can be used for confirm/revoke functions\r\n  function changeOwner(WalletMainLib.WalletData storage self,\r\n                       address _from,\r\n                       address _to,\r\n                       bool _confirm,\r\n                       bytes _data)\r\n                       public\r\n                       returns (bool,bytes32)\r\n  {\r\n    bytes32 _id = keccak256(\"changeOwner\",_from,_to);\r\n    uint256 _txIndex = self.transactionInfo[_id].length;\r\n    bool allGood;\r\n\r\n    if(msg.sender != address(this)){\r\n      if(!_confirm) {\r\n        allGood = self.revokeConfirm(_id);\r\n        return (allGood,_id);\r\n      } else {\r\n        if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){\r\n          require(self.ownerIndex[msg.sender] > 0);\r\n          allGood = checkChangeOwnerArgs(self.ownerIndex[_from], self.ownerIndex[_to]);\r\n          if(!allGood)\r\n            return (false,0);\r\n\r\n          self.transactionInfo[_id].length++;\r\n          self.transactionInfo[_id][_txIndex].confirmRequired = self.requiredAdmin;\r\n          self.transactionInfo[_id][_txIndex].day = now / 1 days;\r\n          self.transactions[now / 1 days].push(_id);\r\n        } else {\r\n          _txIndex--;\r\n          allGood = self.checkNotConfirmed(_id, _txIndex);\r\n          if(!allGood)\r\n            return (false,_id);\r\n        }\r\n      }\r\n      self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender));\r\n      self.transactionInfo[_id][_txIndex].confirmCount++;\r\n    } else {\r\n      _txIndex--;\r\n    }\r\n\r\n    if(self.transactionInfo[_id][_txIndex].confirmCount ==\r\n       self.transactionInfo[_id][_txIndex].confirmRequired)\r\n    {\r\n      self.transactionInfo[_id][_txIndex].success = true;\r\n      uint256 i = self.ownerIndex[_from];\r\n      self.ownerIndex[_from] = 0;\r\n      self.owners[i] = _to;\r\n      self.ownerIndex[_to] = i;\r\n      delete self.transactionInfo[_id][_txIndex].data;\r\n      LogOwnerChanged(_from, _to);\r\n    } else {\r\n      if(self.transactionInfo[_id][_txIndex].data.length == 0)\r\n        self.transactionInfo[_id][_txIndex].data = _data;\r\n\r\n      uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired,\r\n                                               self.transactionInfo[_id][_txIndex].confirmCount);\r\n\r\n      LogTransactionConfirmed(_id, msg.sender, confirmsNeeded);\r\n    }\r\n\r\n    return (true,_id);\r\n\t}\r\n\r\n  /// @dev Adds owner to wallet\r\n  /// @param self Wallet in contract storage\r\n  /// @param _newOwner Address for new owner\r\n  /// @param _confirm True if confirming, false if revoking confirmation\r\n  /// @param _data Message data passed from wallet contract\r\n  /// @return bool Returns true if successful, false otherwise\r\n  /// @return bytes32 Returns the tx ID, can be used for confirm/revoke functions\r\n  function addOwner(WalletMainLib.WalletData storage self,\r\n                    address _newOwner,\r\n                    bool _confirm,\r\n                    bytes _data)\r\n                    public\r\n                    returns (bool,bytes32)\r\n  {\r\n    bytes32 _id = keccak256(\"addOwner\",_newOwner);\r\n    uint256 _txIndex = self.transactionInfo[_id].length;\r\n    bool allGood;\r\n\r\n    if(msg.sender != address(this)){\r\n      require(_newOwner != 0);\r\n\r\n      if(!_confirm) {\r\n        allGood = self.revokeConfirm(_id);\r\n        return (allGood,_id);\r\n      } else {\r\n        if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){\r\n          require(self.ownerIndex[msg.sender] > 0);\r\n          allGood = checkNewOwnerArgs(self.ownerIndex[_newOwner],\r\n                                      self.owners.length,\r\n                                      self.maxOwners);\r\n          if(!allGood)\r\n            return (false,0);\r\n\r\n          self.transactionInfo[_id].length++;\r\n          self.transactionInfo[_id][_txIndex].confirmRequired = self.requiredAdmin;\r\n          self.transactionInfo[_id][_txIndex].day = now / 1 days;\r\n          self.transactions[now / 1 days].push(_id);\r\n        } else {\r\n          _txIndex--;\r\n          allGood = self.checkNotConfirmed(_id, _txIndex);\r\n          if(!allGood)\r\n            return (false,_id);\r\n        }\r\n      }\r\n\r\n      self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender));\r\n      self.transactionInfo[_id][_txIndex].confirmCount++;\r\n    } else {\r\n      _txIndex--;\r\n    }\r\n\r\n    if(self.transactionInfo[_id][_txIndex].confirmCount ==\r\n       self.transactionInfo[_id][_txIndex].confirmRequired)\r\n    {\r\n      self.transactionInfo[_id][_txIndex].success = true;\r\n      self.owners.push(_newOwner);\r\n      self.ownerIndex[_newOwner] = self.owners.length - 1;\r\n      delete self.transactionInfo[_id][_txIndex].data;\r\n      LogOwnerAdded(_newOwner);\r\n    } else {\r\n      if(self.transactionInfo[_id][_txIndex].data.length == 0)\r\n        self.transactionInfo[_id][_txIndex].data = _data;\r\n\r\n      uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired,\r\n                                               self.transactionInfo[_id][_txIndex].confirmCount);\r\n      LogTransactionConfirmed(_id, msg.sender, confirmsNeeded);\r\n    }\r\n\r\n    return (true,_id);\r\n\t}\r\n\r\n  /// @dev Removes owner from wallet\r\n  /// @param self Wallet in contract storage\r\n  /// @param _ownerRemoving Address of owner to be removed\r\n  /// @param _confirm True if confirming, false if revoking confirmation\r\n  /// @param _data Message data passed from wallet contract\r\n  /// @return bool Returns true if successful, false otherwise\r\n  /// @return bytes32 Returns the tx ID, can be used for confirm/revoke functions\r\n  function removeOwner(WalletMainLib.WalletData storage self,\r\n                       address _ownerRemoving,\r\n                       bool _confirm,\r\n                       bytes _data)\r\n                       public\r\n                       returns (bool,bytes32)\r\n  {\r\n    bytes32 _id = keccak256(\"removeOwner\",_ownerRemoving);\r\n    uint256 _txIndex = self.transactionInfo[_id].length;\r\n    bool allGood;\r\n\r\n    if(msg.sender != address(this)){\r\n      if(!_confirm) {\r\n        allGood = self.revokeConfirm(_id);\r\n        return (allGood,_id);\r\n      } else {\r\n        if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){\r\n          require(self.ownerIndex[msg.sender] > 0);\r\n          allGood = checkRemoveOwnerArgs(self.ownerIndex[_ownerRemoving],\r\n                                         self.owners.length,\r\n                                         self.requiredAdmin);\r\n          if(!allGood)\r\n            return (false,0);\r\n\r\n          self.transactionInfo[_id].length++;\r\n          self.transactionInfo[_id][_txIndex].confirmRequired = self.requiredAdmin;\r\n          self.transactionInfo[_id][_txIndex].day = now / 1 days;\r\n          self.transactions[now / 1 days].push(_id);\r\n        } else {\r\n          _txIndex--;\r\n          allGood = self.checkNotConfirmed(_id, _txIndex);\r\n          if(!allGood)\r\n            return (false,_id);\r\n        }\r\n      }\r\n\r\n      self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender));\r\n      self.transactionInfo[_id][_txIndex].confirmCount++;\r\n    } else {\r\n      _txIndex--;\r\n    }\r\n\r\n    if(self.transactionInfo[_id][_txIndex].confirmCount ==\r\n       self.transactionInfo[_id][_txIndex].confirmRequired)\r\n    {\r\n      self.transactionInfo[_id][_txIndex].success = true;\r\n      self.owners[self.ownerIndex[_ownerRemoving]] = self.owners[self.owners.length - 1];\r\n      self.ownerIndex[self.owners[self.owners.length - 1]] = self.ownerIndex[_ownerRemoving];\r\n      self.ownerIndex[_ownerRemoving] = 0;\r\n      self.owners.length--;\r\n      delete self.transactionInfo[_id][_txIndex].data;\r\n      LogOwnerRemoved(_ownerRemoving);\r\n    } else {\r\n      if(self.transactionInfo[_id][_txIndex].data.length == 0)\r\n        self.transactionInfo[_id][_txIndex].data = _data;\r\n\r\n      uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired,\r\n                                               self.transactionInfo[_id][_txIndex].confirmCount);\r\n      LogTransactionConfirmed(_id, msg.sender, confirmsNeeded);\r\n    }\r\n\r\n    return (true,_id);\r\n\t}\r\n\r\n  /// @dev Changes required sigs to change wallet parameters\r\n  /// @param self Wallet in contract storage\r\n  /// @param _requiredAdmin The new signature requirement\r\n  /// @param _confirm True if confirming, false if revoking confirmation\r\n  /// @param _data Message data passed from wallet contract\r\n  /// @return bool Returns true if successful, false otherwise\r\n  /// @return bytes32 Returns the tx ID, can be used for confirm/revoke functions\r\n  function changeRequiredAdmin(WalletMainLib.WalletData storage self,\r\n                               uint256 _requiredAdmin,\r\n                               bool _confirm,\r\n                               bytes _data)\r\n                               public\r\n                               returns (bool,bytes32)\r\n  {\r\n    bytes32 _id = keccak256(\"changeRequiredAdmin\",_requiredAdmin);\r\n    uint256 _txIndex = self.transactionInfo[_id].length;\r\n\r\n    if(msg.sender != address(this)){\r\n      bool allGood;\r\n\r\n      if(!_confirm) {\r\n        allGood = self.revokeConfirm(_id);\r\n        return (allGood,_id);\r\n      } else {\r\n        if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){\r\n          require(self.ownerIndex[msg.sender] > 0);\r\n          allGood = checkRequiredChange(_requiredAdmin, self.owners.length);\r\n          if(!allGood)\r\n            return (false,0);\r\n\r\n          self.transactionInfo[_id].length++;\r\n          self.transactionInfo[_id][_txIndex].confirmRequired = self.requiredAdmin;\r\n          self.transactionInfo[_id][_txIndex].day = now / 1 days;\r\n          self.transactions[now / 1 days].push(_id);\r\n        } else {\r\n          _txIndex--;\r\n          allGood = self.checkNotConfirmed(_id, _txIndex);\r\n          if(!allGood)\r\n            return (false,_id);\r\n        }\r\n      }\r\n\r\n      self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender));\r\n      self.transactionInfo[_id][_txIndex].confirmCount++;\r\n    } else {\r\n      _txIndex--;\r\n    }\r\n\r\n    if(self.transactionInfo[_id][_txIndex].confirmCount ==\r\n      self.transactionInfo[_id][_txIndex].confirmRequired)\r\n    {\r\n      self.transactionInfo[_id][_txIndex].success = true;\r\n      self.requiredAdmin = _requiredAdmin;\r\n      delete self.transactionInfo[_id][_txIndex].data;\r\n      LogRequirementChange(_requiredAdmin);\r\n    } else {\r\n      if(self.transactionInfo[_id][_txIndex].data.length == 0)\r\n        self.transactionInfo[_id][_txIndex].data = _data;\r\n\r\n      uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired,\r\n                                               self.transactionInfo[_id][_txIndex].confirmCount);\r\n      LogTransactionConfirmed(_id, msg.sender, confirmsNeeded);\r\n    }\r\n\r\n    return (true,_id);\r\n\t}\r\n\r\n  /// @dev Changes required sigs for major transactions\r\n  /// @param self Wallet in contract storage\r\n  /// @param _requiredMajor The new signature requirement\r\n  /// @param _confirm True if confirming, false if revoking confirmation\r\n  /// @param _data Message data passed from wallet contract\r\n  /// @return bool Returns true if successful, false otherwise\r\n  /// @return bytes32 Returns the tx ID, can be used for confirm/revoke functions\r\n  function changeRequiredMajor(WalletMainLib.WalletData storage self,\r\n                               uint256 _requiredMajor,\r\n                               bool _confirm,\r\n                               bytes _data)\r\n                               public\r\n                               returns (bool,bytes32)\r\n  {\r\n    bytes32 _id = keccak256(\"changeRequiredMajor\",_requiredMajor);\r\n    uint256 _txIndex = self.transactionInfo[_id].length;\r\n\r\n    if(msg.sender != address(this)){\r\n      bool allGood;\r\n\r\n      if(!_confirm) {\r\n        allGood = self.revokeConfirm(_id);\r\n        return (allGood,_id);\r\n      } else {\r\n        if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){\r\n          require(self.ownerIndex[msg.sender] > 0);\r\n          allGood = checkRequiredChange(_requiredMajor, self.owners.length);\r\n          if(!allGood)\r\n            return (false,0);\r\n\r\n          self.transactionInfo[_id].length++;\r\n          self.transactionInfo[_id][_txIndex].confirmRequired = self.requiredAdmin;\r\n          self.transactionInfo[_id][_txIndex].day = now / 1 days;\r\n          self.transactions[now / 1 days].push(_id);\r\n        } else {\r\n          _txIndex--;\r\n          allGood = self.checkNotConfirmed(_id, _txIndex);\r\n          if(!allGood)\r\n            return (false,_id);\r\n        }\r\n      }\r\n\r\n      self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender));\r\n      self.transactionInfo[_id][_txIndex].confirmCount++;\r\n    } else {\r\n      _txIndex--;\r\n    }\r\n\r\n    if(self.transactionInfo[_id][_txIndex].confirmCount ==\r\n       self.transactionInfo[_id][_txIndex].confirmRequired)\r\n    {\r\n      self.transactionInfo[_id][_txIndex].success = true;\r\n      self.requiredMajor = _requiredMajor;\r\n      delete self.transactionInfo[_id][_txIndex].data;\r\n      LogRequirementChange(_requiredMajor);\r\n    } else {\r\n      if(self.transactionInfo[_id][_txIndex].data.length == 0)\r\n        self.transactionInfo[_id][_txIndex].data = _data;\r\n\r\n      uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired,\r\n                                               self.transactionInfo[_id][_txIndex].confirmCount);\r\n      LogTransactionConfirmed(_id, msg.sender, confirmsNeeded);\r\n    }\r\n\r\n    return (true,_id);\r\n\t}\r\n\r\n  /// @dev Changes required sigs for minor transactions\r\n  /// @param self Wallet in contract storage\r\n  /// @param _requiredMinor The new signature requirement\r\n  /// @param _confirm True if confirming, false if revoking confirmation\r\n  /// @param _data Message data passed from wallet contract\r\n  /// @return bool Returns true if successful, false otherwise\r\n  /// @return bytes32 Returns the tx ID, can be used for confirm/revoke functions\r\n  function changeRequiredMinor(WalletMainLib.WalletData storage self,\r\n                               uint256 _requiredMinor,\r\n                               bool _confirm,\r\n                               bytes _data)\r\n                               public\r\n                               returns (bool,bytes32)\r\n  {\r\n    bytes32 _id = keccak256(\"changeRequiredMinor\",_requiredMinor);\r\n    uint256 _txIndex = self.transactionInfo[_id].length;\r\n\r\n    if(msg.sender != address(this)){\r\n      bool allGood;\r\n\r\n      if(!_confirm) {\r\n        allGood = self.revokeConfirm(_id);\r\n        return (allGood,_id);\r\n      } else {\r\n        if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){\r\n          require(self.ownerIndex[msg.sender] > 0);\r\n          allGood = checkRequiredChange(_requiredMinor, self.owners.length);\r\n          if(!allGood)\r\n            return (false,0);\r\n\r\n          self.transactionInfo[_id].length++;\r\n          self.transactionInfo[_id][_txIndex].confirmRequired = self.requiredAdmin;\r\n          self.transactionInfo[_id][_txIndex].day = now / 1 days;\r\n          self.transactions[now / 1 days].push(_id);\r\n        } else {\r\n          _txIndex--;\r\n          allGood = self.checkNotConfirmed(_id, _txIndex);\r\n          if(!allGood)\r\n            return (false,_id);\r\n        }\r\n      }\r\n\r\n      self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender));\r\n      self.transactionInfo[_id][_txIndex].confirmCount++;\r\n    } else {\r\n      _txIndex--;\r\n    }\r\n\r\n    if(self.transactionInfo[_id][_txIndex].confirmCount ==\r\n       self.transactionInfo[_id][_txIndex].confirmRequired)\r\n    {\r\n      self.transactionInfo[_id][_txIndex].success = true;\r\n      self.requiredMinor = _requiredMinor;\r\n      delete self.transactionInfo[_id][_txIndex].data;\r\n      LogRequirementChange(_requiredMinor);\r\n    } else {\r\n      if(self.transactionInfo[_id][_txIndex].data.length == 0)\r\n        self.transactionInfo[_id][_txIndex].data = _data;\r\n\r\n      uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired,\r\n                                               self.transactionInfo[_id][_txIndex].confirmCount);\r\n      LogTransactionConfirmed(_id, msg.sender, confirmsNeeded);\r\n    }\r\n\r\n    return (true,_id);\r\n\t}\r\n\r\n  /// @dev Changes threshold for major transaction day spend per token\r\n  /// @param self Wallet in contract storage\r\n  /// @param _token Address of token, ether is 0\r\n  /// @param _majorThreshold New threshold\r\n  /// @param _confirm True if confirming, false if revoking confirmation\r\n  /// @param _data Message data passed from wallet contract\r\n  /// @return bool Returns true if successful, false otherwise\r\n  /// @return bytes32 Returns the tx ID, can be used for confirm/revoke functions\r\n  function changeMajorThreshold(WalletMainLib.WalletData storage self,\r\n                                address _token,\r\n                                uint256 _majorThreshold,\r\n                                bool _confirm,\r\n                                bytes _data)\r\n                                public\r\n                                returns (bool,bytes32)\r\n  {\r\n    bytes32 _id = keccak256(\"changeMajorThreshold\", _token, _majorThreshold);\r\n    uint256 _txIndex = self.transactionInfo[_id].length;\r\n\r\n    if(msg.sender != address(this)){\r\n      bool allGood;\r\n\r\n      if(!_confirm) {\r\n        allGood = self.revokeConfirm(_id);\r\n        return (allGood,_id);\r\n      } else {\r\n        if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){\r\n          require(self.ownerIndex[msg.sender] > 0);\r\n\r\n          self.transactionInfo[_id].length++;\r\n          self.transactionInfo[_id][_txIndex].confirmRequired = self.requiredAdmin;\r\n          self.transactionInfo[_id][_txIndex].day = now / 1 days;\r\n          self.transactions[now / 1 days].push(_id);\r\n        } else {\r\n          _txIndex--;\r\n          allGood = self.checkNotConfirmed(_id, _txIndex);\r\n          if(!allGood)\r\n            return (false,_id);\r\n        }\r\n      }\r\n\r\n      self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender));\r\n      self.transactionInfo[_id][_txIndex].confirmCount++;\r\n    } else {\r\n      _txIndex--;\r\n    }\r\n\r\n    if(self.transactionInfo[_id][_txIndex].confirmCount ==\r\n       self.transactionInfo[_id][_txIndex].confirmRequired)\r\n    {\r\n      self.transactionInfo[_id][_txIndex].success = true;\r\n      self.majorThreshold[_token] = _majorThreshold;\r\n      delete self.transactionInfo[_id][_txIndex].data;\r\n      LogThresholdChange(_token, _majorThreshold);\r\n    } else {\r\n      if(self.transactionInfo[_id][_txIndex].data.length == 0)\r\n        self.transactionInfo[_id][_txIndex].data = _data;\r\n\r\n      uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired,\r\n                                               self.transactionInfo[_id][_txIndex].confirmCount);\r\n      LogTransactionConfirmed(_id, msg.sender, confirmsNeeded);\r\n    }\r\n\r\n    return (true,_id);\r\n\t}\r\n}\r\n\r\nlibrary WalletMainLib {\r\n  using Array256Lib for uint256[];\r\n  using BasicMathLib for uint256;\r\n\r\n  struct WalletData {\r\n    uint256 maxOwners; //Maximum wallet owners, should be 50\r\n    address[] owners; //Array of all owners\r\n    uint256 requiredAdmin; //Number of sigs required for administrative changes\r\n    uint256 requiredMajor; //Number of sigs required for major transactions\r\n    uint256 requiredMinor; //Number of sigs required for minor transactions\r\n\r\n    // The amount of a token spent per day, ether is at address mapping 0,\r\n    // all other tokens defined by address. uint256[0] corresponds to the current\r\n    // day,  uint256[1] is the spend amount\r\n    mapping (address => uint256[2]) currentSpend;\r\n    //The day spend threshold for transactions to be major, ether at 0, all others by address\r\n    mapping (address => uint256) majorThreshold;\r\n    //Array of transactions per day, uint256 is the day timestamp, bytes32 is the transaction id\r\n    mapping (uint256 => bytes32[]) transactions;\r\n    //Tracks the index of each owner in the owners Array\r\n    mapping (address => uint256) ownerIndex;\r\n    //Array of Transaction's by id, new tx's with exact inputs as previous tx will add to array\r\n    mapping (bytes32 => Transaction[]) transactionInfo;\r\n\r\n  }\r\n\r\n  struct Transaction {\r\n    uint256 day; //Timestamp of the day initialized\r\n    uint256 value; //Amount of ether being sent\r\n    address tokenAdress; //Address of token transferred\r\n    uint256 amount; //Amount of tokens transferred\r\n    bytes data; //Temp location for pending transactions, erased after final confirmation\r\n    uint256[] confirmedOwners; //Array of owners confirming transaction\r\n    uint256 confirmCount; //Tracks the number of confirms\r\n    uint256 confirmRequired; //Number of sigs required for this transaction\r\n    bool success; //True after final confirmation\r\n  }\r\n\r\n  /*Events*/\r\n  event LogRevokeNotice(bytes32 txid, address sender, uint256 confirmsNeeded);\r\n  event LogTransactionFailed(bytes32 txid, address sender);\r\n  event LogTransactionConfirmed(bytes32 txid, address sender, uint256 confirmsNeeded);\r\n  event LogTransactionComplete(bytes32 txid, address target, uint256 value, bytes data);\r\n  event LogContractCreated(address newContract, uint256 value);\r\n  event LogErrorMsg(uint256 amount, string msg);\r\n\r\n  /// @dev Constructor\r\n  /// @param self The wallet in contract storage\r\n  /// @param _owners Array of initial owners\r\n  /// @param _requiredAdmin Set number of sigs for administrative tasks\r\n  /// @param _requiredMajor Set number of sigs for major tx\r\n  /// @param _requiredMinor Set number of sigs for minor tx\r\n  /// @param _majorThreshold Set major tx threshold amount for ether\r\n  /// @return Will return true when complete\r\n  function init(WalletData storage self,\r\n                address[] _owners,\r\n                uint256 _requiredAdmin,\r\n                uint256 _requiredMajor,\r\n                uint256 _requiredMinor,\r\n                uint256 _majorThreshold) public returns (bool)\r\n  {\r\n    require(self.owners.length == 0);\r\n    require(_owners.length >= _requiredAdmin && _requiredAdmin > 0);\r\n    require(_owners.length >= _requiredMajor && _requiredMajor > 0);\r\n    require(_owners.length >= _requiredMinor && _requiredMinor > 0);\r\n    self.owners.push(0); //Leave index-0 empty for easier owner checks\r\n\r\n    for (uint256 i=0; i<_owners.length; i++) {\r\n      require(_owners[i] != 0);\r\n      self.owners.push(_owners[i]);\r\n      self.ownerIndex[_owners[i]] = i+1;\r\n    }\r\n    self.requiredAdmin = _requiredAdmin;\r\n    self.requiredMajor = _requiredMajor;\r\n    self.requiredMinor = _requiredMinor;\r\n    self.maxOwners = 50; //Limits to 50 owners, should create wallet pools for more owners\r\n    self.majorThreshold[0] = _majorThreshold; //Sets ether threshold at address 0\r\n\r\n    return true;\r\n  }\r\n\r\n  /*Checks*/\r\n\r\n  /// @dev Verifies a confirming owner has not confirmed already\r\n  /// @param self Contract wallet in storage\r\n  /// @param _id ID of the tx being checked\r\n  /// @param _txIndex Index number of this tx\r\n  /// @return Returns true if check passes, false otherwise\r\n  function checkNotConfirmed(WalletData storage self, bytes32 _id, uint256 _txIndex)\r\n           public returns (bool)\r\n  {\r\n    require(self.ownerIndex[msg.sender] > 0);\r\n    uint256 _txLen = self.transactionInfo[_id].length;\r\n\r\n    if(_txLen == 0 || _txIndex >= _txLen){\r\n      LogErrorMsg(_txLen, \"Tx not initiated\");\r\n      LogTransactionFailed(_id, msg.sender);\r\n      return false;\r\n    }\r\n\r\n    if(self.transactionInfo[_id][_txIndex].success){\r\n      LogErrorMsg(_txIndex, \"Transaction already complete\");\r\n      LogTransactionFailed(_id, msg.sender);\r\n      return false;\r\n    }\r\n\r\n    //Function from Modular.io array utility library\r\n    bool found;\r\n    uint256 index;\r\n    (found, index) = self.transactionInfo[_id][_txIndex].confirmedOwners.indexOf(uint256(msg.sender), false);\r\n    if(found){\r\n      LogErrorMsg(index, \"Owner already confirmed\");\r\n      LogTransactionFailed(_id, msg.sender);\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /*Utility Functions*/\r\n\r\n  /// @dev Used later to calculate the number of confirmations needed for tx\r\n  /// @param _required Number of sigs required\r\n  /// @param _count Current number of sigs\r\n  function calcConfirmsNeeded(uint256 _required, uint256 _count) public pure returns (uint256){\r\n    return _required - _count;\r\n  }\r\n\r\n  /// @dev Used to check if tx is moving tokens and parses amount\r\n  /// @param _txData Data for proposed tx\r\n  /// @return bool True if transaction is moving tokens\r\n  /// @return uint256 Amount of tokens involved, 0 if not spending tx\r\n  function getAmount(bytes _txData) public pure returns (bool,uint256) {\r\n    bytes32 getSig;\r\n    bytes4 sig;\r\n    bytes4 tSig = 0xa9059cbb; //transfer func signature\r\n    bytes4 aSig = 0x095ea7b3; //approve func signature\r\n    bytes4 tfSig = 0x23b872dd; //transferFrom func signature\r\n    bool transfer;\r\n    bytes32 _amountData;\r\n    uint256 _amount;\r\n\r\n    assembly { getSig := mload(add(_txData,0x20)) }\r\n    sig = bytes4(getSig);\r\n    if(sig ==  tSig || sig == aSig){\r\n      transfer = true;\r\n      assembly { _amountData := mload(add(_txData,0x44)) }\r\n      _amount = uint256(_amountData);\r\n    } else if(sig == tfSig){\r\n      transfer = true;\r\n      assembly { _amountData := mload(add(_txData,0x64)) }\r\n      _amount = uint256(_amountData);\r\n    }\r\n    return (transfer,_amount);\r\n  }\r\n\r\n  /// @dev Retrieves sig requirement for spending tx\r\n  /// @param self Contract wallet in storage\r\n  /// @param _to Target address of transaction\r\n  /// @param _value Amount of ether spend\r\n  /// @param _isTransfer True if transferring other tokens, false otherwise\r\n  /// @param _amount Amount of tokens being transferred, 0 if not a transfer tx\r\n  /// @return uint256 The required sigs for tx\r\n  function getRequired(WalletData storage self,\r\n                       address _to,\r\n                       uint256 _value,\r\n                       bool _isTransfer,\r\n                       uint256 _amount)\r\n                       public returns (uint256)\r\n  {\r\n    bool err;\r\n    uint256 res;\r\n    bool major = true;\r\n    //Reset spend if this is first check of the day\r\n    if((now / 1 days) > self.currentSpend[0][0]){\r\n      self.currentSpend[0][0] = now / 1 days;\r\n      self.currentSpend[0][1] = 0;\r\n    }\r\n\r\n    (err, res) = self.currentSpend[0][1].plus(_value);\r\n    require(!err);\r\n\r\n    if(res < self.majorThreshold[0])\r\n      major = false;\r\n\r\n    if(_to != 0 && _isTransfer){\r\n      if((now / 1 days) > self.currentSpend[_to][0]){\r\n        self.currentSpend[_to][0] = now / 1 days;\r\n        self.currentSpend[_to][1] = 0;\r\n      }\r\n\r\n      (err, res) = self.currentSpend[_to][1].plus(_amount);\r\n      require(!err);\r\n\r\n      if(res >= self.majorThreshold[_to])\r\n        major = true;\r\n    }\r\n\r\n    return major ? self.requiredMajor : self.requiredMinor;\r\n  }\r\n\r\n  /// @dev Function to create new contract\r\n  /// @param _txData Transaction data\r\n  /// @param _value Amount of eth sending to new contract\r\n  function createContract(bytes _txData, uint256 _value) public {\r\n    address _newContract;\r\n    bool allGood;\r\n\r\n    assembly {\r\n      _newContract := create(_value, add(_txData, 0x20), mload(_txData))\r\n      allGood := gt(extcodesize(_newContract),0)\r\n    }\r\n    require(allGood);\r\n    LogContractCreated(_newContract, _value);\r\n  }\r\n\r\n  /*Primary Function*/\r\n\r\n  /// @dev Create and execute transaction from wallet\r\n  /// @param self Wallet in contract storage\r\n  /// @param _to Address of target\r\n  /// @param _value Amount of ether sending\r\n  /// @param _txData Data for executing transaction\r\n  /// @param _confirm True if confirming, false if revoking confirmation\r\n  /// @param _data Message data passed from wallet contract\r\n  /// @return bool Returns true if successful, false otherwise\r\n  /// @return bytes32 Returns the tx ID, can be used for confirm/revoke functions\r\n  function serveTx(WalletData storage self,\r\n                   address _to,\r\n                   uint256 _value,\r\n                   bytes _txData,\r\n                   bool _confirm,\r\n                   bytes _data)\r\n                   public returns (bool,bytes32)\r\n  {\r\n    bytes32 _id = keccak256(\"serveTx\",_to,_value,_txData);\r\n    uint256 _txIndex = self.transactionInfo[_id].length;\r\n    uint256 _required = self.requiredMajor;\r\n\r\n    //Run checks if not called from generic confirm/revoke function\r\n    if(msg.sender != address(this)){\r\n      bool allGood;\r\n      uint256 _amount;\r\n      // if the owner is revoking his/her confirmation but doesn't know the\r\n      // specific transaction id hash\r\n      if(!_confirm) {\r\n        allGood = revokeConfirm(self, _id);\r\n        return (allGood,_id);\r\n      } else { // else confirming the transaction\r\n        //Reuse allGood due to stack limit\r\n        if(_to != 0)\r\n          (allGood,_amount) = getAmount(_txData);\r\n\r\n        //if this is a new transaction id or if a previous identical transaction had already succeeded\r\n        if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){\r\n          require(self.ownerIndex[msg.sender] > 0);\r\n\r\n          _required = getRequired(self, _to, _value, allGood,_amount);\r\n\r\n          // add this transaction to the wallets record and initialize the settings\r\n          self.transactionInfo[_id].length++;\r\n          self.transactionInfo[_id][_txIndex].confirmRequired = _required;\r\n          self.transactionInfo[_id][_txIndex].day = now / 1 days;\r\n          self.transactions[now / 1 days].push(_id);\r\n        } else { // else the transaction is already pending\r\n          _txIndex--; // set the index to the index of the existing transaction\r\n          //make sure the sender isn't already confirmed\r\n          allGood = checkNotConfirmed(self, _id, _txIndex);\r\n          if(!allGood)\r\n            return (false,_id);\r\n        }\r\n      }\r\n\r\n      // add the senders confirmation to the transaction\r\n      self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender));\r\n      self.transactionInfo[_id][_txIndex].confirmCount++;\r\n    } else {\r\n      // else were calling from generic confirm/revoke function, set the\r\n      // _txIndex index to the index of the existing transaction\r\n      _txIndex--;\r\n    }\r\n\r\n    // if there are enough confirmations\r\n    if(self.transactionInfo[_id][_txIndex].confirmCount ==\r\n       self.transactionInfo[_id][_txIndex].confirmRequired)\r\n    {\r\n      // execute the transaction\r\n      self.currentSpend[0][1] += _value;\r\n      self.currentSpend[_to][1] += _amount;\r\n      self.transactionInfo[_id][_txIndex].success = true;\r\n\r\n      if(_to == 0){\r\n        //Failure is self contained in method\r\n        createContract(_txData, _value);\r\n      } else {\r\n        require(_to.call.value(_value)(_txData));\r\n      }\r\n      delete self.transactionInfo[_id][_txIndex].data;\r\n      LogTransactionComplete(_id, _to, _value, _data);\r\n    } else {\r\n      if(self.transactionInfo[_id][_txIndex].data.length == 0)\r\n        self.transactionInfo[_id][_txIndex].data = _data;\r\n\r\n      uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired,\r\n                                               self.transactionInfo[_id][_txIndex].confirmCount);\r\n      LogTransactionConfirmed(_id, msg.sender, confirmsNeeded);\r\n    }\r\n\r\n    return (true,_id);\r\n  }\r\n\r\n  /* Confirm/Revoke functions using tx ID */\r\n\r\n  /// @dev Confirms a current pending tx, will execute if final confirmation\r\n  /// @param self Wallet in contract storage\r\n  /// @param _id ID of the transaction\r\n  /// @return Returns true if successful, false otherwise\r\n  function confirmTx(WalletData storage self, bytes32 _id)\r\n                     public returns (bool) {\r\n    require(self.ownerIndex[msg.sender] > 0);\r\n    uint256 _txIndex = self.transactionInfo[_id].length;\r\n    bool ret;\r\n\r\n    if(_txIndex == 0){\r\n      LogErrorMsg(_txIndex, \"Tx not initiated\");\r\n      LogTransactionFailed(_id, msg.sender);\r\n      return false;\r\n    }\r\n\r\n    _txIndex--;\r\n    bool allGood = checkNotConfirmed(self, _id, _txIndex);\r\n    if(!allGood)\r\n      return false;\r\n\r\n    self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender));\r\n    self.transactionInfo[_id][_txIndex].confirmCount++;\r\n\r\n    if(self.transactionInfo[_id][_txIndex].confirmCount ==\r\n       self.transactionInfo[_id][_txIndex].confirmRequired)\r\n    {\r\n      address a = address(this);\r\n      require(a.call(self.transactionInfo[_id][_txIndex].data));\r\n    } else {\r\n      uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired,\r\n                                               self.transactionInfo[_id][_txIndex].confirmCount);\r\n\r\n      LogTransactionConfirmed(_id, msg.sender, confirmsNeeded);\r\n      ret = true;\r\n    }\r\n\r\n    return ret;\r\n  }\r\n\r\n  /// @dev Revokes a prior confirmation from sender, call with tx ID\r\n  /// @param self Wallet in contract storage\r\n  /// @param _id ID of the transaction\r\n  /// @return Returns true if successful, false otherwise\r\n  function revokeConfirm(WalletData storage self, bytes32 _id)\r\n           public\r\n           returns (bool)\r\n  {\r\n    require(self.ownerIndex[msg.sender] > 0);\r\n    uint256 _txIndex = self.transactionInfo[_id].length;\r\n\r\n    if(_txIndex == 0){\r\n      LogErrorMsg(_txIndex, \"Tx not initiated\");\r\n      LogTransactionFailed(_id, msg.sender);\r\n      return false;\r\n    }\r\n\r\n    _txIndex--;\r\n    if(self.transactionInfo[_id][_txIndex].success){\r\n      LogErrorMsg(_txIndex, \"Transaction already complete\");\r\n      LogTransactionFailed(_id, msg.sender);\r\n      return false;\r\n    }\r\n\r\n    //Function from Modular.io array utility library\r\n    bool found;\r\n    uint256 index;\r\n    (found, index) = self.transactionInfo[_id][_txIndex].confirmedOwners.indexOf(uint256(msg.sender), false);\r\n    if(!found){\r\n      LogErrorMsg(index, \"Owner has not confirmed tx\");\r\n      LogTransactionFailed(_id, msg.sender);\r\n      return false;\r\n    }\r\n    self.transactionInfo[_id][_txIndex].confirmedOwners[index] = 0;\r\n    self.transactionInfo[_id][_txIndex].confirmCount--;\r\n\r\n    uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired,\r\n                                             self.transactionInfo[_id][_txIndex].confirmCount);\r\n    //Transaction removed if all sigs revoked but id remains in wallet transaction list\r\n    if(self.transactionInfo[_id][_txIndex].confirmCount == 0)\r\n      self.transactionInfo[_id].length--;\r\n\r\n    LogRevokeNotice(_id, msg.sender, confirmsNeeded);\r\n    return true;\r\n  }\r\n}\r\n\r\nlibrary Array256Lib {\r\n\r\n  /// @dev Sum vector\r\n  /// @param self Storage array containing uint256 type variables\r\n  /// @return sum The sum of all elements, does not check for overflow\r\n  function sumElements(uint256[] storage self) public view returns(uint256 sum) {\r\n    assembly {\r\n      mstore(0x60,self_slot)\r\n\r\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\r\n        sum := add(sload(add(sha3(0x60,0x20),i)),sum)\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @dev Returns the max value in an array.\r\n  /// @param self Storage array containing uint256 type variables\r\n  /// @return maxValue The highest value in the array\r\n  function getMax(uint256[] storage self) public view returns(uint256 maxValue) {\r\n    assembly {\r\n      mstore(0x60,self_slot)\r\n      maxValue := sload(sha3(0x60,0x20))\r\n\r\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\r\n        switch gt(sload(add(sha3(0x60,0x20),i)), maxValue)\r\n        case 1 {\r\n          maxValue := sload(add(sha3(0x60,0x20),i))\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @dev Returns the minimum value in an array.\r\n  /// @param self Storage array containing uint256 type variables\r\n  /// @return minValue The highest value in the array\r\n  function getMin(uint256[] storage self) public view returns(uint256 minValue) {\r\n    assembly {\r\n      mstore(0x60,self_slot)\r\n      minValue := sload(sha3(0x60,0x20))\r\n\r\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\r\n        switch gt(sload(add(sha3(0x60,0x20),i)), minValue)\r\n        case 0 {\r\n          minValue := sload(add(sha3(0x60,0x20),i))\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @dev Finds the index of a given value in an array\r\n  /// @param self Storage array containing uint256 type variables\r\n  /// @param value The value to search for\r\n  /// @param isSorted True if the array is sorted, false otherwise\r\n  /// @return found True if the value was found, false otherwise\r\n  /// @return index The index of the given value, returns 0 if found is false\r\n  function indexOf(uint256[] storage self, uint256 value, bool isSorted)\r\n           public\r\n           view\r\n           returns(bool found, uint256 index) {\r\n    assembly{\r\n      mstore(0x60,self_slot)\r\n      switch isSorted\r\n      case 1 {\r\n        let high := sub(sload(self_slot),1)\r\n        let mid := 0\r\n        let low := 0\r\n        for { } iszero(gt(low, high)) { } {\r\n          mid := div(add(low,high),2)\r\n\r\n          switch lt(sload(add(sha3(0x60,0x20),mid)),value)\r\n          case 1 {\r\n             low := add(mid,1)\r\n          }\r\n          case 0 {\r\n            switch gt(sload(add(sha3(0x60,0x20),mid)),value)\r\n            case 1 {\r\n              high := sub(mid,1)\r\n            }\r\n            case 0 {\r\n              found := 1\r\n              index := mid\r\n              low := add(high,1)\r\n            }\r\n          }\r\n        }\r\n      }\r\n      case 0 {\r\n        for { let low := 0 } lt(low, sload(self_slot)) { low := add(low, 1) } {\r\n          switch eq(sload(add(sha3(0x60,0x20),low)), value)\r\n          case 1 {\r\n            found := 1\r\n            index := low\r\n            low := sload(self_slot)\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @dev Utility function for heapSort\r\n  /// @param index The index of child node\r\n  /// @return pI The parent node index\r\n  function getParentI(uint256 index) private pure returns (uint256 pI) {\r\n    uint256 i = index - 1;\r\n    pI = i/2;\r\n  }\r\n\r\n  /// @dev Utility function for heapSort\r\n  /// @param index The index of parent node\r\n  /// @return lcI The index of left child\r\n  function getLeftChildI(uint256 index) private pure returns (uint256 lcI) {\r\n    uint256 i = index * 2;\r\n    lcI = i + 1;\r\n  }\r\n\r\n  /// @dev Sorts given array in place\r\n  /// @param self Storage array containing uint256 type variables\r\n  function heapSort(uint256[] storage self) public {\r\n    uint256 end = self.length - 1;\r\n    uint256 start = getParentI(end);\r\n    uint256 root = start;\r\n    uint256 lChild;\r\n    uint256 rChild;\r\n    uint256 swap;\r\n    uint256 temp;\r\n    while(start >= 0){\r\n      root = start;\r\n      lChild = getLeftChildI(start);\r\n      while(lChild <= end){\r\n        rChild = lChild + 1;\r\n        swap = root;\r\n        if(self[swap] < self[lChild])\r\n          swap = lChild;\r\n        if((rChild <= end) && (self[swap]<self[rChild]))\r\n          swap = rChild;\r\n        if(swap == root)\r\n          lChild = end+1;\r\n        else {\r\n          temp = self[swap];\r\n          self[swap] = self[root];\r\n          self[root] = temp;\r\n          root = swap;\r\n          lChild = getLeftChildI(root);\r\n        }\r\n      }\r\n      if(start == 0)\r\n        break;\r\n      else\r\n        start = start - 1;\r\n    }\r\n    while(end > 0){\r\n      temp = self[end];\r\n      self[end] = self[0];\r\n      self[0] = temp;\r\n      end = end - 1;\r\n      root = 0;\r\n      lChild = getLeftChildI(0);\r\n      while(lChild <= end){\r\n        rChild = lChild + 1;\r\n        swap = root;\r\n        if(self[swap] < self[lChild])\r\n          swap = lChild;\r\n        if((rChild <= end) && (self[swap]<self[rChild]))\r\n          swap = rChild;\r\n        if(swap == root)\r\n          lChild = end + 1;\r\n        else {\r\n          temp = self[swap];\r\n          self[swap] = self[root];\r\n          self[root] = temp;\r\n          root = swap;\r\n          lChild = getLeftChildI(root);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @dev Removes duplicates from a given array.\r\n  /// @param self Storage array containing uint256 type variables\r\n  function uniq(uint256[] storage self) public returns (uint256 length) {\r\n    bool contains;\r\n    uint256 index;\r\n\r\n    for (uint256 i = 0; i < self.length; i++) {\r\n      (contains, index) = indexOf(self, self[i], false);\r\n\r\n      if (i > index) {\r\n        for (uint256 j = i; j < self.length - 1; j++){\r\n          self[j] = self[j + 1];\r\n        }\r\n\r\n        delete self[self.length - 1];\r\n        self.length--;\r\n        i--;\r\n      }\r\n    }\r\n\r\n    length = self.length;\r\n  }\r\n}\r\n\r\nlibrary BasicMathLib {\r\n  /// @dev Multiplies two numbers and checks for overflow before returning.\r\n  /// Does not throw.\r\n  /// @param a First number\r\n  /// @param b Second number\r\n  /// @return err False normally, or true if there is overflow\r\n  /// @return res The product of a and b, or 0 if there is overflow\r\n  function times(uint256 a, uint256 b) public view returns (bool err,uint256 res) {\r\n    assembly{\r\n      res := mul(a,b)\r\n      switch or(iszero(b), eq(div(res,b), a))\r\n      case 0 {\r\n        err := 1\r\n        res := 0\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @dev Divides two numbers but checks for 0 in the divisor first.\r\n  /// Does not throw.\r\n  /// @param a First number\r\n  /// @param b Second number\r\n  /// @return err False normally, or true if `b` is 0\r\n  /// @return res The quotient of a and b, or 0 if `b` is 0\r\n  function dividedBy(uint256 a, uint256 b) public view returns (bool err,uint256 i) {\r\n    uint256 res;\r\n    assembly{\r\n      switch iszero(b)\r\n      case 0 {\r\n        res := div(a,b)\r\n        let loc := mload(0x40)\r\n        mstore(add(loc,0x20),res)\r\n        i := mload(add(loc,0x20))\r\n      }\r\n      default {\r\n        err := 1\r\n        i := 0\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @dev Adds two numbers and checks for overflow before returning.\r\n  /// Does not throw.\r\n  /// @param a First number\r\n  /// @param b Second number\r\n  /// @return err False normally, or true if there is overflow\r\n  /// @return res The sum of a and b, or 0 if there is overflow\r\n  function plus(uint256 a, uint256 b) public view returns (bool err, uint256 res) {\r\n    assembly{\r\n      res := add(a,b)\r\n      switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b)))\r\n      case 0 {\r\n        err := 1\r\n        res := 0\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @dev Subtracts two numbers and checks for underflow before returning.\r\n  /// Does not throw but rather logs an Err event if there is underflow.\r\n  /// @param a First number\r\n  /// @param b Second number\r\n  /// @return err False normally, or true if there is underflow\r\n  /// @return res The difference between a and b, or 0 if there is underflow\r\n  function minus(uint256 a, uint256 b) public view returns (bool err,uint256 res) {\r\n    assembly{\r\n      res := sub(a,b)\r\n      switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1)\r\n      case 0 {\r\n        err := 1\r\n        res := 0\r\n      }\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"WalletMainLib.WalletData storage\"},{\"name\":\"_requiredMinor\",\"type\":\"uint256\"},{\"name\":\"_confirm\",\"type\":\"bool\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"changeRequiredMinor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"WalletMainLib.WalletData storage\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_majorThreshold\",\"type\":\"uint256\"},{\"name\":\"_confirm\",\"type\":\"bool\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"changeMajorThreshold\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"WalletMainLib.WalletData storage\"},{\"name\":\"_newOwner\",\"type\":\"address\"},{\"name\":\"_confirm\",\"type\":\"bool\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"addOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"WalletMainLib.WalletData storage\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_confirm\",\"type\":\"bool\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"changeOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"WalletMainLib.WalletData storage\"},{\"name\":\"_requiredAdmin\",\"type\":\"uint256\"},{\"name\":\"_confirm\",\"type\":\"bool\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"changeRequiredAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"WalletMainLib.WalletData storage\"},{\"name\":\"_requiredMajor\",\"type\":\"uint256\"},{\"name\":\"_confirm\",\"type\":\"bool\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"changeRequiredMajor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"WalletMainLib.WalletData storage\"},{\"name\":\"_ownerRemoving\",\"type\":\"address\"},{\"name\":\"_confirm\",\"type\":\"bool\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"removeOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"txid\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"confirmsNeeded\",\"type\":\"uint256\"}],\"name\":\"LogTransactionConfirmed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"LogOwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"ownerRemoved\",\"type\":\"address\"}],\"name\":\"LogOwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"LogOwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequired\",\"type\":\"uint256\"}],\"name\":\"LogRequirementChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newThreshold\",\"type\":\"uint256\"}],\"name\":\"LogThresholdChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"msg\",\"type\":\"string\"}],\"name\":\"LogErrorMsg\",\"type\":\"event\"}]","ContractName":"WalletAdminLib","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"WalletMainLib:89B5B861dcb455483f48a87bf430bFA48CC6F385","SwarmSource":"bzzr://8cc895d9c492589abbd1203b32134c8982eb5ad3728feab2c01a5574b6d2ebd8"}]}