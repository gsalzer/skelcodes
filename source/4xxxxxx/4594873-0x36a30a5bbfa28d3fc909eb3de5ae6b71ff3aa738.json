{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n\r\ncontract IPFSEvents {\r\n\tevent HashAdded(address PubKey, string IPFSHash, uint ttl);\r\n\tevent HashRemoved(address PubKey, string IPFSHash);\r\n}\r\n\r\ncontract Multimember {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint membersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has seven types of events: it can accept a confirmation, in which case\r\n    // we record member and operation (hash) alongside it.\r\n    event Confirmation(address member, bytes32 operation);\r\n    event Revoke(address member, bytes32 operation);\r\n    // some others are in the case of an member changing.\r\n    event MemberChanged(address oldMember, address newMember);\r\n    event MemberAdded(address newMember);\r\n    event MemberRemoved(address oldMember);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlymember {\r\n        if (isMember(msg.sender))\r\n            _;\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanymembers(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanymembers\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function Multimember(address[] _members, uint _required) public {\r\n        m_numMembers = _members.length + 1;\r\n        m_members[1] = uint(msg.sender);\r\n        m_memberIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _members.length; ++i) {\r\n            m_members[2 + i] = uint(_members[i]);\r\n            m_memberIndex[uint(_members[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint memberIndex = m_memberIndex[uint(msg.sender)];\r\n        // make sure they're an member\r\n        if (memberIndex == 0) \r\n            return;\r\n        uint memberIndexBit = 2**memberIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.membersDone & memberIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.membersDone -= memberIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an member `_from` with another `_to`.\r\n    function changeMember(address _from, address _to) onlymanymembers(keccak256(_from,_to)) external {\r\n        if (isMember(_to)) \r\n            return;\r\n        uint memberIndex = m_memberIndex[uint(_from)];\r\n        if (memberIndex == 0) \r\n            return;\r\n\r\n        clearPending();\r\n        m_members[memberIndex] = uint(_to);\r\n        m_memberIndex[uint(_from)] = 0;\r\n        m_memberIndex[uint(_to)] = memberIndex;\r\n        MemberChanged(_from, _to);\r\n    }\r\n    \r\n    function addMember(address _member) onlymanymembers(keccak256(_member)) public {\r\n        if (isMember(_member)) \r\n            return;\r\n\r\n        clearPending();\r\n        if (m_numMembers >= c_maxMembers)\r\n            reorganizeMembers();\r\n        if (m_numMembers >= c_maxMembers)\r\n            return;\r\n        m_numMembers++;\r\n        m_members[m_numMembers] = uint(_member);\r\n        m_memberIndex[uint(_member)] = m_numMembers;\r\n        MemberAdded(_member);\r\n    }\r\n    \r\n    function removeMember(address _member) onlymanymembers(keccak256(_member)) public {\r\n        uint memberIndex = m_memberIndex[uint(_member)];\r\n        if (memberIndex == 0) \r\n            return;\r\n        if (m_required > m_numMembers - 1) \r\n            return;\r\n\r\n        m_members[memberIndex] = 0;\r\n        m_memberIndex[uint(_member)] = 0;\r\n        clearPending();\r\n        reorganizeMembers(); //make sure m_numMembers is equal to the number of members and always points to the optimal free slot\r\n        MemberRemoved(_member);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanymembers(keccak256(_newRequired)) external {\r\n        if (_newRequired > m_numMembers) \r\n            return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isMember(address _addr) public constant returns (bool) { \r\n        return m_memberIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _member) external constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint memberIndex = m_memberIndex[uint(_member)];\r\n\r\n        // make sure they're an member\r\n        if (memberIndex == 0) \r\n            return false;\r\n\r\n        // determine the bit to set for this member.\r\n        uint memberIndexBit = 2**memberIndex;\r\n        return !(pending.membersDone & memberIndexBit == 0);\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint memberIndex = m_memberIndex[uint(msg.sender)];\r\n        // make sure they're an member\r\n        if (memberIndex == 0) \r\n            return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which members have confirmed (none) - set our bitmap to 0.\r\n            pending.membersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this member.\r\n        uint memberIndexBit = 2**memberIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.membersDone & memberIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            } else {\r\n                // not enough: record that this member in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.membersDone |= memberIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeMembers() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numMembers) {\r\n            while (free < m_numMembers && m_members[free] != 0) {\r\n                free++;\r\n            } \r\n\r\n            while (m_numMembers > 1 && m_members[m_numMembers] == 0) {\r\n                m_numMembers--;\r\n            } \r\n\r\n            if (free < m_numMembers && m_members[m_numMembers] != 0 && m_members[free] == 0) {\r\n                m_members[free] = m_members[m_numMembers];\r\n                m_memberIndex[m_members[free]] = free;\r\n                m_members[m_numMembers] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i) {\r\n            if (m_pendingIndex[i] != 0) {\r\n                delete m_pending[m_pendingIndex[i]];\r\n            }\r\n        }\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of members that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_members\r\n    uint public m_numMembers;\r\n    \r\n    // list of members\r\n    uint[256] m_members;\r\n    uint constant c_maxMembers = 250;\r\n    // index on the list of members to allow reverse lookup\r\n    mapping(uint => uint) m_memberIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\ncontract IPFSProxy is IPFSEvents, Multimember {\r\n\tmapping(address => mapping( address => bool)) public complained;\r\n\tmapping(address => uint) public complaint;\r\n\tuint public banThreshold;\r\n\tuint public sizeLimit;\r\n\taddress[] members;\r\n\t\r\n\t/**\r\n\t* @dev Throws if called by any account other than a valid member. \r\n\t*/\r\n\tmodifier onlyValidMembers {\r\n\t\trequire (isMember(msg.sender));\r\n\t\t_;\r\n\t}\r\n\r\n    event ContractAdded(address PubKey, uint ttl);\r\n    event ContractRemoved(address PubKey);\r\n\tevent Banned(string IPFSHash);\r\n\tevent BanAttempt(address complainer, address _Member, uint complaints );\r\n\tevent PersistLimitChanged(uint Limit);\t\r\n\r\n\t/**\r\n\t* @dev Constructor - adds the owner of the contract to the list of valid members\r\n\t*/\r\n\tfunction IPFSProxy() Multimember (members, 1) public {\r\n\t\taddContract(this, 0);\r\n\t\tupdateBanThreshold(1);\r\n\t\tsetTotalPersistLimit(10000000000); //10 GB\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Add hash to persistent storage\r\n\t* @param _IPFSHash The ipfs hash to propagate.\r\n\t* @param _ttl amount of time is seconds to persist this. \r\n\t*/\r\n\tfunction addHash(string _IPFSHash, uint _ttl) public onlyValidMembers {\r\n\t\tHashAdded(msg.sender,_IPFSHash,_ttl);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Remove hash from persistent storage\r\n\t* @param _IPFSHash The ipfs hash to propagate.\t\r\n\t*/\r\n\tfunction removeHash(string _IPFSHash) public onlyValidMembers {\r\n\t\tHashRemoved(msg.sender,_IPFSHash);\r\n\t}\r\n\r\n\r\n\t/** \r\n\t* Add a contract to watch list. Each node will then \r\n\t* watch it for `HashAdded(msg.sender,_IPFSHash,_ttl);` \r\n\t* events and it will cache these events\r\n\t*/\r\n\r\n\tfunction addContract(address _toWatch, uint _ttl) public onlyValidMembers {\r\n\t\tContractAdded(_toWatch, _ttl);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Remove contract from watch list\r\n\t*/\r\n\tfunction removeContract(address _contractAddress) public onlyValidMembers {\r\n\t\tContractRemoved(_contractAddress);\r\n\t}\r\n\r\n\t/**\r\n\t*@dev removes a member who exceeds the cap\r\n\t*/\r\n\tfunction banMember (address _Member, string _evidence) public onlyValidMembers {\r\n\t\trequire(isMember(_Member));\r\n\t\trequire(!complained[msg.sender][_Member]);\r\n\t\tcomplained[msg.sender][_Member] = true;\r\n\t\tcomplaint[_Member] += 1;\t\r\n\t\tif (complaint[_Member] >= banThreshold) { \r\n\t\t\tremoveMember(_Member);\r\n\t\t\tif (!isMember(_Member)) {\r\n\t\t\t\tBanned(_evidence);\r\n\t\t\t} \r\n\t\t} else {\r\n\t\t\tBanAttempt(msg.sender, _Member, complaint[_Member]);\r\n\t\t}\r\n\t}\r\n\t/**\r\n\t* @dev update ban threshold\r\n\t*/\r\n\tfunction updateBanThreshold (uint _banThreshold) public onlymanymembers(keccak256(_banThreshold)) {\r\n\t\tbanThreshold = _banThreshold;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev set total allowed upload\r\n\t*\r\n\t**/\r\n\tfunction setTotalPersistLimit (uint _limit) public onlymanymembers(keccak256(_limit)) {\r\n\t\tsizeLimit = _limit;\r\n\t\tPersistLimitChanged(_limit);\r\n\t}\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"removeMember\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"complained\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sizeLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"complaint\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_Member\",\"type\":\"address\"},{\"name\":\"_evidence\",\"type\":\"string\"}],\"name\":\"banMember\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numMembers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"banThreshold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_banThreshold\",\"type\":\"uint256\"}],\"name\":\"updateBanThreshold\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isMember\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_toWatch\",\"type\":\"address\"},{\"name\":\"_ttl\",\"type\":\"uint256\"}],\"name\":\"addContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"setTotalPersistLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeMember\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractAddress\",\"type\":\"address\"}],\"name\":\"removeContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_IPFSHash\",\"type\":\"string\"},{\"name\":\"_ttl\",\"type\":\"uint256\"}],\"name\":\"addHash\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"addMember\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_IPFSHash\",\"type\":\"string\"}],\"name\":\"removeHash\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"PubKey\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ttl\",\"type\":\"uint256\"}],\"name\":\"ContractAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"PubKey\",\"type\":\"address\"}],\"name\":\"ContractRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"IPFSHash\",\"type\":\"string\"}],\"name\":\"Banned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"complainer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_Member\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"complaints\",\"type\":\"uint256\"}],\"name\":\"BanAttempt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"Limit\",\"type\":\"uint256\"}],\"name\":\"PersistLimitChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"member\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"member\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldMember\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newMember\",\"type\":\"address\"}],\"name\":\"MemberChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newMember\",\"type\":\"address\"}],\"name\":\"MemberAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldMember\",\"type\":\"address\"}],\"name\":\"MemberRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"PubKey\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"IPFSHash\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"ttl\",\"type\":\"uint256\"}],\"name\":\"HashAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"PubKey\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"IPFSHash\",\"type\":\"string\"}],\"name\":\"HashRemoved\",\"type\":\"event\"}]","ContractName":"IPFSProxy","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://dfef6e611b98a9bbdf2db63ceb9cfde70d8cd29ad161da750a6f592b5a738c17"}]}