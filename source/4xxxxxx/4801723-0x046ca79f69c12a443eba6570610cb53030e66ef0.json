{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n * @title ECVerify\r\n * @dev Singature Verifier \r\n * @author Dinesh\r\n */\r\ncontract ECVerify  { \r\n    \r\n    /**\r\n     * The signature format is a compact form of: {bytes32 r}{bytes32 s}{uint8 v} \r\n     * Compact means, uint8 is not padded to 32 bytes.\r\n     * \r\n     * @dev Function to Recover signer address from a message by using his signature\r\n     * @param _msgHash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n     * @param v singnature type 27/28, 0/1\r\n     * @param r signature section\r\n     * @param s Signtaure salt\r\n     * \r\n     */\r\n    function ecrecovery(bytes32 _msgHash, uint8 v, bytes32 r, bytes32 s) public pure returns (address) { \r\n        // albeit non-transactional signatures are not specified by the YP, one would expect it\r\n        // to match the YP range of [27, 28].  geth uses [0, 1] and some clients have followed.\r\n        // So, Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n        // Check the version is valid or not\r\n        if (v != 27 && v != 28) {\r\n            return (address(0));\r\n        } \r\n        \r\n        if (v==27) {\r\n            return ecrecover(_msgHash, v, r, s); \r\n        }\r\n        else if (v==28) {\r\n            //bytes memory _prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n            //bytes32 _prefixedHash = keccak256(_prefix, _msgHash);\r\n            return ecrecover(_msgHash, v, r, s); \r\n        } \r\n        return (address(0));\r\n    }\r\n    \r\n    /**\r\n     * @dev function to verify the signature with given input signer\r\n     * @param _msgHash hashed messages\r\n     * @param v singnature type 27/28, 0/1\r\n     * @param r signature section\r\n     * @param s Signtaure salt\r\n     * @param _signer is the address the user who signed the message\r\n     */\r\n    function ecverify(bytes32 _msgHash, uint8 v, bytes32 r, bytes32 s, address _signer) public pure returns (bool) {\r\n        if (_signer == address(0)) {\r\n            return false;\r\n        } \r\n        // extract the signers address and compare to the input\r\n        return ecrecovery(_msgHash, v, r, s) == _signer;\r\n    } \r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_msgHash\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"ecrecovery\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_msgHash\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"_signer\",\"type\":\"address\"}],\"name\":\"ecverify\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"ECVerify","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://5afcee66e9753f86c7db302dce5efd9cb564b4e451a03d80e7dbd53f495ba818"}]}