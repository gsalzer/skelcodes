{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\n\r\ncontract SafeMath {\r\n\r\n\tfunction safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tuint256 c = a + b;\r\n\t\tassert(c >= a && c >= b);\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tassert(b <= a);\r\n\t\treturn a - b;\r\n\t}\r\n\r\n\tfunction safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tuint256 c = a * b;\r\n\t\tassert(a == 0 || c / a == b);\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tassert(b > 0);\r\n\t\tuint256 c = a / b;\r\n\t\tassert(a == b * c + a % b);\r\n\t\treturn c;\r\n\t}\r\n}\r\n\r\n\r\ncontract ERC20Token {\r\n\r\n\t// --------\r\n\t//\tEvents\r\n\t// ---------\r\n\r\n\t// publicize actions to external listeners.\r\n\t/// @notice Triggered when tokens are transferred.\r\n\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n\t/// @notice Triggered whenever approve(address _spender, uint256 _value) is called.\r\n\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n\t// --------\r\n\t//\tGetters\r\n\t// ---------\r\n\r\n\t/// @notice Get the total amount of token supply\r\n\tfunction totalSupply() public constant returns (uint256 _totalSupply);\r\n\r\n\t/// @notice Get the account balance of address _owner\r\n\t/// @param _owner The address from which the balance will be retrieved\r\n\t/// @return The balance\r\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance);\r\n\r\n\t/// @param _owner The address of the account owning tokens\r\n\t/// @param _spender The address of the account able to transfer the tokens\r\n\t/// @return Amount of remaining tokens allowed to spent by the _spender from _owner account\r\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining);\r\n\r\n\t// --------\r\n\t//\tActions\r\n\t// ---------\r\n\r\n\t/// @notice send _value amount of tokens to _to address from msg.sender address\r\n\t/// @param _to The address of the recipient\r\n\t/// @param _value The amount of token to be transferred\r\n\t/// @return a boolean - whether the transfer was successful or not\r\n\tfunction transfer(address _to, uint256 _value) public returns (bool success);\r\n\r\n\t/// @notice send _value amount of tokens to _to address from _from address, on the condition it is approved by _from\r\n\t/// @param _from The address of the sender\r\n\t/// @param _to The address of the recipient\r\n\t/// @param _value The amount of token to be transferred\r\n\t/// @return a boolean - whether the transfer was successful or not\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n\t/// @notice msg.sender approves _spender to spend multiple times up to _value amount of tokens\r\n\t/// If this function is called again it overwrites the current allowance with _value.\r\n\t/// @param _spender The address of the account able to transfer the tokens\r\n\t/// @param _value The amount of tokens to be approved for transfer\r\n\t/// @return a boolean - whether the approval was successful or not\r\n\tfunction approve(address _spender, uint256 _value) public returns (bool success);\r\n}\r\n\r\n\r\ncontract SecureERC20Token is ERC20Token {\r\n\r\n\t// State variables\r\n\r\n\t// balances dictionary that maps addresses to balances\r\n\tmapping (address => uint256) private balances;\r\n\r\n\t// locked account dictionary that maps addresses to boolean\r\n\tmapping (address => bool) private lockedAccounts;\r\n\r\n\t // allowed dictionary that allow transfer rights to other addresses.\r\n\tmapping (address => mapping(address => uint256)) private allowed;\r\n\r\n\t// The Token's name: e.g. 'Gilgamesh Tokens'\r\n\tstring public name;\r\n\r\n\t// Symbol of the token: e.q 'GIL'\r\n\tstring public symbol;\r\n\r\n\t// Number of decimals of the smallest unit: e.g '18'\r\n\tuint8 public decimals;\r\n\r\n\t// Number of total tokens: e,g: '1000000000'\r\n\tuint256 public totalSupply;\r\n\r\n\t// token version\r\n\tuint8 public version = 1;\r\n\r\n\t// address of the contract admin\r\n\taddress public admin;\r\n\r\n\t// address of the contract minter\r\n\taddress public minter;\r\n\r\n\t// creationBlock is the block number that the Token was created\r\n\tuint256 public creationBlock;\r\n\r\n\t// Flag that determines if the token is transferable or not\r\n\t// disable actionable ERC20 token methods\r\n\tbool public isTransferEnabled;\r\n\r\n\tevent AdminOwnershipTransferred(address indexed previousAdmin, address indexed newAdmin);\r\n\tevent MinterOwnershipTransferred(address indexed previousMinter, address indexed newMinter);\r\n\tevent TransferStatus(address indexed sender, bool status);\r\n\r\n\t// @notice Constructor to create Gilgamesh ERC20 Token\r\n\tfunction SecureERC20Token(\r\n\t\tuint256 initialSupply,\r\n\t\tstring _name,\r\n\t\tstring _symbol,\r\n\t\tuint8 _decimals,\r\n\t\tbool _isTransferEnabled\r\n\t) public {\r\n\t\t// assign all tokens to the deployer\r\n\t\tbalances[msg.sender] = initialSupply;\r\n\r\n\t\ttotalSupply = initialSupply; // set initial supply of Tokens\r\n\t\tname = _name;\t\t\t\t // set token name\r\n\t\tdecimals = _decimals;\t\t // set the decimals\r\n\t\tsymbol = _symbol;\t\t\t // set the token symbol\r\n\t\tisTransferEnabled = _isTransferEnabled;\r\n\t\tcreationBlock = block.number;\r\n\t\tminter = msg.sender;\t\t// by default the contract deployer is the minter\r\n\t\tadmin = msg.sender;\t\t\t// by default the contract deployer is the admin\r\n\t}\r\n\r\n\t// --------------\r\n\t// ERC20 Methods\r\n\t// --------------\r\n\r\n\t/// @notice Get the total amount of token supply\r\n\tfunction totalSupply() public constant returns (uint256 _totalSupply) {\r\n\t\treturn totalSupply;\r\n\t}\r\n\r\n\t/// @notice Get the account balance of address _owner\r\n\t/// @param _owner The address from which the balance will be retrieved\r\n\t/// @return The balance\r\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance) {\r\n\t\treturn balances[_owner];\r\n\t}\r\n\r\n\t/// @notice send _value amount of tokens to _to address from msg.sender address\r\n\t/// @param _to The address of the recipient\r\n\t/// @param _value The amount of token to be transferred\r\n\t/// @return a boolean - whether the transfer was successful or not\r\n\tfunction transfer(address _to, uint256 _value) public returns (bool success) {\r\n\t\t// if transfer is not enabled throw an error and stop execution.\r\n\t\trequire(isTransferEnabled);\r\n\r\n\t\t// continue with transfer\r\n\t\treturn doTransfer(msg.sender, _to, _value);\r\n\t}\r\n\r\n\t/// @notice send _value amount of tokens to _to address from _from address, on the condition it is approved by _from\r\n\t/// @param _from The address of the sender\r\n\t/// @param _to The address of the recipient\r\n\t/// @param _value The amount of token to be transferred\r\n\t/// @return a boolean - whether the transfer was successful or not\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n\t\t// if transfer is not enabled throw an error and stop execution.\r\n\t\trequire(isTransferEnabled);\r\n\r\n\t\t// if from allowed transferrable rights to sender for amount _value\r\n\t\tif (allowed[_from][msg.sender] < _value) revert();\r\n\r\n\t\t// subtreact allowance\r\n\t\tallowed[_from][msg.sender] -= _value;\r\n\r\n\t\t// continue with transfer\r\n\t\treturn doTransfer(_from, _to, _value);\r\n\t}\r\n\r\n\t/// @notice msg.sender approves _spender to spend _value tokens\r\n\t/// @param _spender The address of the account able to transfer the tokens\r\n\t/// @param _value The amount of tokens to be approved for transfer\r\n\t/// @return a boolean - whether the approval was successful or not\r\n\tfunction approve(address _spender, uint256 _value)\r\n\tpublic\r\n\tis_not_locked(_spender)\r\n\treturns (bool success) {\r\n\t\t// if transfer is not enabled throw an error and stop execution.\r\n\t\trequire(isTransferEnabled);\r\n\r\n\t\t// user can only reassign an allowance of 0 if value is greater than 0\r\n\t\t// sender should first change the allowance to zero by calling approve(_spender, 0)\r\n\t\t// race condition is explained below:\r\n\t\t// https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n\t\tif(_value != 0 && allowed[msg.sender][_spender] != 0) revert();\r\n\r\n\t\tif (\r\n\t\t\t// if sender balance is less than _value return false;\r\n\t\t\tbalances[msg.sender] < _value\r\n\t\t) {\r\n\t\t\t// transaction failure\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// allow transfer rights from msg.sender to _spender for _value token amount\r\n\t\tallowed[msg.sender][_spender] = _value;\r\n\r\n\t\t// log approval event\r\n\t\tApproval(msg.sender, _spender, _value);\r\n\r\n\t\t// transaction successful\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/// @param _owner The address of the account owning tokens\r\n\t/// @param _spender The address of the account able to transfer the tokens\r\n\t/// @return Amount of remaining tokens allowed to spent by the _spender from _owner account\r\n\tfunction allowance(address _owner, address _spender)\r\n\tpublic\r\n\tconstant\r\n\treturns (uint256 remaining) {\r\n\t\treturn allowed[_owner][_spender];\r\n\t}\r\n\r\n\t// --------------\r\n\t// Contract Custom Methods - Non ERC20\r\n\t// --------------\r\n\r\n\t/* Public Methods */\r\n\r\n\t/// @notice only the admin is allowed to lock accounts.\r\n\t/// @param _owner the address of the account to be locked\r\n\tfunction lockAccount(address _owner)\r\n\tpublic\r\n\tis_not_locked(_owner)\r\n\tvalidate_address(_owner)\r\n\tonlyAdmin {\r\n\t\tlockedAccounts[_owner] = true;\r\n\t}\r\n\r\n\t/// @notice only the admin is allowed to unlock accounts.\r\n\t/// @param _owner the address of the account to be unlocked\r\n\tfunction unlockAccount(address _owner)\r\n\tpublic\r\n\tis_locked(_owner)\r\n\tvalidate_address(_owner)\r\n\tonlyAdmin {\r\n\t\tlockedAccounts[_owner] = false;\r\n\t}\r\n\r\n\t/// @notice only the admin is allowed to burn tokens - in case if the user haven't verified identity or performed fraud\r\n\t/// @param _owner the address of the account that their tokens needs to be burnt\r\n\tfunction burnUserTokens(address _owner)\r\n\tpublic\r\n\tvalidate_address(_owner)\r\n\tonlyAdmin {\r\n\t\t// if user balance is 0 ignore\r\n\t\tif (balances[_owner] == 0) revert();\r\n\r\n\t\t// should never happen but just in case\r\n\t\tif (balances[_owner] > totalSupply) revert();\r\n\r\n\t\t// decrease the total supply\r\n\t\ttotalSupply -= balances[_owner];\r\n\r\n\t\t// burn it all\r\n\t\tbalances[_owner] = 0;\r\n\t}\r\n\r\n\t/// @notice only the admin is allowed to change the minter.\r\n\t/// @param newMinter the address of the minter\r\n\tfunction changeMinter(address newMinter)\r\n\tpublic\r\n\tvalidate_address(newMinter)\r\n\tonlyAdmin {\r\n\t\tif (minter == newMinter) revert();\r\n\t\tMinterOwnershipTransferred(minter, newMinter);\r\n\t\tminter = newMinter;\r\n\t}\r\n\r\n\t/// @notice only the admin is allowed to change the admin.\r\n\t/// @param newAdmin the address of the new admin\r\n\tfunction changeAdmin(address newAdmin)\r\n\tpublic\r\n\tvalidate_address(newAdmin)\r\n\tonlyAdmin {\r\n\t\tif (admin == newAdmin) revert();\r\n\t\tAdminOwnershipTransferred(admin, newAdmin);\r\n\t\tadmin = newAdmin;\r\n\t}\r\n\r\n\t/// @notice mint new tokens by the minter\r\n\t/// @param _owner the owner of the newly tokens\r\n\t/// @param _amount the amount of new token to be minted\r\n\tfunction mint(address _owner, uint256 _amount)\r\n\tpublic\r\n\tonlyMinter\r\n\tvalidate_address(_owner)\r\n\treturns (bool success) {\r\n\t\t// preventing overflow on the totalSupply\r\n\t\tif (totalSupply + _amount < totalSupply) revert();\r\n\r\n\t\t// preventing overflow on the receiver account\r\n\t\tif (balances[_owner] + _amount < balances[_owner]) revert();\r\n\r\n\t\t// increase the total supply\r\n\t\ttotalSupply += _amount;\r\n\r\n\t\t// assign the additional supply to the target account.\r\n\t\tbalances[_owner] += _amount;\r\n\r\n\t\t// contract has minted new token by the minter\r\n\t\tTransfer(0x0, msg.sender, _amount);\r\n\r\n\t\t// minter has transferred token to the target account\r\n\t\tTransfer(msg.sender, _owner, _amount);\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/// @notice Enables token holders to transfer their tokens freely if true\r\n\t/// after the crowdsale is finished it will be true\r\n\t/// for security reasons can be switched to false\r\n\t/// @param _isTransferEnabled boolean\r\n\tfunction enableTransfers(bool _isTransferEnabled) public onlyAdmin {\r\n\t\tisTransferEnabled = _isTransferEnabled;\r\n\t\tTransferStatus(msg.sender, isTransferEnabled);\r\n\t}\r\n\r\n\t/* Internal Methods */\r\n\r\n\t///\t@dev this is the actual transfer function and it can only be called internally\r\n\t/// @notice send _value amount of tokens to _to address from _from address\r\n\t/// @param _to The address of the recipient\r\n\t/// @param _value The amount of token to be transferred\r\n\t/// @return a boolean - whether the transfer was successful or not\r\n\tfunction doTransfer(address _from, address _to, uint256 _value)\r\n\tvalidate_address(_to)\r\n\tis_not_locked(_from)\r\n\tinternal\r\n\treturns (bool success) {\r\n\t\tif (\r\n\t\t\t// if the value is not more than 0 fail\r\n\t\t\t_value <= 0 ||\r\n\t\t\t// if the sender doesn't have enough balance fail\r\n\t\t\tbalances[_from] < _value ||\r\n\t\t\t// if token supply overflows (total supply exceeds 2^256 - 1) fail\r\n\t\t\tbalances[_to] + _value < balances[_to]\r\n\t\t) {\r\n\t\t\t// transaction failed\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// decrease the number of tokens from sender address.\r\n\t\tbalances[_from] -= _value;\r\n\r\n\t\t// increase the number of tokens for _to address\r\n\t\tbalances[_to] += _value;\r\n\r\n\t\t// log transfer event\r\n\t\tTransfer(_from, _to, _value);\r\n\r\n\t\t// transaction successful\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// --------------\r\n\t// Modifiers\r\n\t// --------------\r\n\tmodifier onlyMinter() {\r\n\t\t// if sender is not the minter stop the execution\r\n\t\tif (msg.sender != minter) revert();\r\n\t\t// if the sender is the minter continue\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier onlyAdmin() {\r\n\t\t// if sender is not the admin stop the execution\r\n\t\tif (msg.sender != admin) revert();\r\n\t\t// if the sender is the admin continue\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier validate_address(address _address) {\r\n\t\tif (_address == address(0)) revert();\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier is_not_locked(address _address) {\r\n\t\tif (lockedAccounts[_address] == true) revert();\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier is_locked(address _address) {\r\n\t\tif (lockedAccounts[_address] != true) revert();\r\n\t\t_;\r\n\t}\r\n}\r\n\r\n\r\ncontract GilgameshToken is SecureERC20Token {\r\n\t// @notice Constructor to create Gilgamesh ERC20 Token\r\n\tfunction GilgameshToken()\r\n\tpublic\r\n\tSecureERC20Token(\r\n\t\t0, // no token in the begning\r\n\t\t\"Gilgamesh Token\", // Token Name\r\n\t\t\"GIL\", // Token Symbol\r\n\t\t18, // Decimals\r\n\t\tfalse // Enable token transfer\r\n\t) {}\r\n\r\n}\r\n\r\n\r\n/*\r\n\tCopyright 2017, Skiral Inc\r\n*/\r\ncontract GilgameshTokenSale is SafeMath{\r\n\r\n\t// creationBlock is the block number that the Token was created\r\n\tuint256 public creationBlock;\r\n\r\n\t// startBlock token sale starting block\r\n\tuint256 public startBlock;\r\n\r\n\t// endBlock token sale ending block\r\n\t// end block is not a valid block for crowdfunding. endBlock - 1 is the last valid block\r\n\tuint256 public endBlock;\r\n\r\n\t// total Wei rasised\r\n\tuint256 public totalRaised = 0;\r\n\r\n\t// Has Gilgamesh stopped the sale\r\n\tbool public saleStopped = false;\r\n\r\n\t// Has Gilgamesh finalized the sale\r\n\tbool public saleFinalized = false;\r\n\r\n\t// Minimum purchase - 0.1 Ether\r\n\tuint256 constant public minimumInvestment = 100 finney;\r\n\r\n\t// Maximum hard Cap\r\n\tuint256 public hardCap = 50000 ether;\r\n\r\n\t// number of wei GIL tokens for sale - 60 Million GIL Tokens\r\n\tuint256 public tokenCap = 60000000 * 10**18;\r\n\r\n\t// Minimum cap\r\n\tuint256 public minimumCap = 1250 ether;\r\n\r\n\t/* Contract Info */\r\n\r\n\t// the deposit address for the Eth that is raised.\r\n\taddress public fundOwnerWallet;\r\n\r\n\t// the deposit address for the tokens that is minted for the dev team.\r\n\taddress public tokenOwnerWallet;\r\n\r\n\t// owner the address of the contract depoloyer\r\n\taddress public owner;\r\n\r\n\t// List of stage bonus percentages in every stage\r\n\t// this will get generated in the constructor\r\n\tuint[] public stageBonusPercentage;\r\n\r\n\t// number of participants\r\n\tuint256 public totalParticipants;\r\n\r\n\t// a map of userId to wei\r\n\tmapping(uint256 => uint256) public paymentsByUserId;\r\n\r\n\t// a map of user address to wei\r\n\tmapping(address => uint256) public paymentsByAddress;\r\n\r\n\t// total number of bonus stages.\r\n\tuint8 public totalStages;\r\n\r\n\t// max bonus percentage on first stage\r\n\tuint8 public stageMaxBonusPercentage;\r\n\r\n\t// number of wei-GIL tokens for 1 wei (18 decimals)\r\n\tuint256 public tokenPrice;\r\n\r\n\t// the team owns 25% of the tokens - 3 times more than token purchasers.\r\n\tuint8 public teamTokenRatio = 3;\r\n\r\n\t// GIL token address\r\n\tGilgameshToken public token;\r\n\r\n\t// if Ether or Token cap has been reached\r\n\tbool public isCapReached = false;\r\n\r\n\t// log when token sale has been initialized\r\n\tevent LogTokenSaleInitialized(\r\n\t\taddress indexed owner,\r\n\t\taddress indexed fundOwnerWallet,\r\n\t\tuint256 startBlock,\r\n\t\tuint256 endBlock,\r\n\t\tuint256 creationBlock\r\n\t);\r\n\r\n\t// log each contribution\r\n\tevent LogContribution(\r\n\t\taddress indexed contributorAddress,\r\n\t\taddress indexed invokerAddress,\r\n\t\tuint256 amount,\r\n\t\tuint256 totalRaised,\r\n\t\tuint256 userAssignedTokens,\r\n\t\tuint256 indexed userId\r\n\t);\r\n\r\n\t// log when crowd fund is finalized\r\n\tevent LogFinalized(address owner, uint256 teamTokens);\r\n\r\n\t// Constructor\r\n\tfunction GilgameshTokenSale(\r\n\t\tuint256 _startBlock, // starting block number\r\n\t\tuint256 _endBlock, // ending block number\r\n\t\taddress _fundOwnerWallet, // fund owner wallet address - transfer ether to this address during and after fund has been closed\r\n\t\taddress _tokenOwnerWallet, // token fund owner wallet address - transfer GIL tokens to this address after fund is finalized\r\n\t\tuint8 _totalStages, // total number of bonus stages\r\n\t\tuint8 _stageMaxBonusPercentage, // maximum percentage for bonus in the first stage\r\n\t\tuint256 _tokenPrice, // price of each GIL token in wei\r\n\t\taddress _gilgameshToken, // address of the gilgamesh ERC20 token contract\r\n\t\tuint256 _minimumCap, // minimum cap, minimum amount of wei to be raised\r\n\t\tuint256 _tokenCap // tokenCap\r\n\t)\r\n\tpublic\r\n\tvalidate_address(_fundOwnerWallet) {\r\n\r\n\t\tif (\r\n\t\t\t_gilgameshToken == 0x0 ||\r\n\t\t\t_tokenOwnerWallet == 0x0 ||\r\n\t\t\t// start block needs to be in the future\r\n\t\t\t_startBlock < getBlockNumber()  ||\r\n\t\t\t// start block should be less than ending block\r\n\t\t\t_startBlock >= _endBlock  ||\r\n\t\t\t// minimum number of stages is 2\r\n\t\t\t_totalStages < 2 ||\r\n\t\t\t// verify stage max bonus\r\n\t\t\t_stageMaxBonusPercentage < 0  ||\r\n\t\t\t_stageMaxBonusPercentage > 100 ||\r\n\t\t\t// stage bonus percentage needs to be devisible by number of stages\r\n\t\t\t_stageMaxBonusPercentage % (_totalStages - 1) != 0 ||\r\n\t\t\t// total number of blocks needs to be devisible by the total stages\r\n\t\t\t(_endBlock - _startBlock) % _totalStages != 0\r\n\t\t) revert();\r\n\r\n\t\towner = msg.sender; // make the contract creator the `owner`\r\n\t\ttoken = GilgameshToken(_gilgameshToken);\r\n\t\tendBlock = _endBlock;\r\n\t\tstartBlock = _startBlock;\r\n\t\tcreationBlock = getBlockNumber();\r\n\t\tfundOwnerWallet = _fundOwnerWallet;\r\n\t\ttokenOwnerWallet = _tokenOwnerWallet;\r\n\t\ttokenPrice = _tokenPrice;\r\n\t\ttotalStages = _totalStages;\r\n\t\tminimumCap = _minimumCap;\r\n\t\tstageMaxBonusPercentage = _stageMaxBonusPercentage;\r\n\t\ttotalRaised = 0; //\ttotal number of wei raised\r\n\t\ttokenCap = _tokenCap;\r\n\r\n\t\t// spread bonuses evenly between stages - e.g 27 / 9 = 3%\r\n\t\tuint spread = stageMaxBonusPercentage / (totalStages - 1);\r\n\r\n\t\t// loop through [10 to 1] => ( 9 to 0) * 3% = [27%, 24%, 21%, 18%, 15%, 12%, 9%, 6%, 3%, 0%]\r\n\t\tfor (uint stageNumber = totalStages; stageNumber > 0; stageNumber--) {\r\n\t\t\tstageBonusPercentage.push((stageNumber - 1) * spread);\r\n\t\t}\r\n\r\n\t\tLogTokenSaleInitialized(\r\n\t\t\towner,\r\n\t\t\tfundOwnerWallet,\r\n\t\t\tstartBlock,\r\n\t\t\tendBlock,\r\n\t\t\tcreationBlock\r\n\t\t);\r\n\t}\r\n\r\n\t// --------------\r\n\t// Public Funtions\r\n\t// --------------\r\n\r\n\t/// @notice Function to stop sale for an emergency.\r\n\t/// @dev Only Gilgamesh Dev can do it after it has been activated.\r\n\tfunction emergencyStopSale()\r\n\tpublic\r\n\tonly_sale_active\r\n\tonlyOwner {\r\n\t\tsaleStopped = true;\r\n\t}\r\n\r\n\t/// @notice Function to restart stopped sale.\r\n\t/// @dev Only Gilgamesh Dev can do it after it has been disabled and sale has stopped.\r\n\t/// can it's in a valid time range for sale\r\n\tfunction restartSale()\r\n\tpublic\r\n\tonly_during_sale_period\r\n\tonly_sale_stopped\r\n\tonlyOwner {\r\n\t\t// if sale is finalized fail\r\n\t\tif (saleFinalized) revert();\r\n\t\tsaleStopped = false;\r\n\t}\r\n\r\n\t/// @notice Function to change the fund owner wallet address\r\n\t/// @dev Only Gilgamesh Dev can trigger this function\r\n\tfunction changeFundOwnerWalletAddress(address _fundOwnerWallet)\r\n\tpublic\r\n\tvalidate_address(_fundOwnerWallet)\r\n\tonlyOwner {\r\n\t\tfundOwnerWallet = _fundOwnerWallet;\r\n\t}\r\n\r\n\t/// @notice Function to change the token fund owner wallet address\r\n\t/// @dev Only Gilgamesh Dev can trigger this function\r\n\tfunction changeTokenOwnerWalletAddress(address _tokenOwnerWallet)\r\n\tpublic\r\n\tvalidate_address(_tokenOwnerWallet)\r\n\tonlyOwner {\r\n\t\ttokenOwnerWallet = _tokenOwnerWallet;\r\n\t}\r\n\r\n\t/// @notice finalize the sale\r\n\t/// @dev Only Gilgamesh Dev can trigger this function\r\n\tfunction finalizeSale()\r\n\tpublic\r\n\tonlyOwner {\r\n\t\tdoFinalizeSale();\r\n\t}\r\n\r\n\t/// @notice change hard cap and if it reaches hard cap finalize sale\r\n\tfunction changeCap(uint256 _cap)\r\n\tpublic\r\n\tonlyOwner {\r\n\t\tif (_cap < minimumCap) revert();\r\n\t\tif (_cap <= totalRaised) revert();\r\n\r\n\t\thardCap = _cap;\r\n\r\n\t\tif (totalRaised + minimumInvestment >= hardCap) {\r\n\t\t\tisCapReached = true;\r\n\t\t\tdoFinalizeSale();\r\n\t\t}\r\n\t}\r\n\r\n\t/// @notice change minimum cap, in case Ether price fluctuates.\r\n\tfunction changeMinimumCap(uint256 _cap)\r\n\tpublic\r\n\tonlyOwner {\r\n\t\tif (minimumCap < _cap) revert();\r\n\t\tminimumCap = _cap;\r\n\t}\r\n\r\n\t/// @notice remove conttact only when sale has been finalized\r\n\t/// transfer all the fund to the contract owner\r\n\t/// @dev only Gilgamesh Dev can trigger this function\r\n\tfunction removeContract()\r\n\tpublic\r\n\tonlyOwner {\r\n\t\tif (!saleFinalized) revert();\r\n\t\tselfdestruct(msg.sender);\r\n\t}\r\n\r\n\t/// @notice only the owner is allowed to change the owner.\r\n\t/// @param _newOwner the address of the new owner\r\n\tfunction changeOwner(address _newOwner)\r\n\tpublic\r\n\tvalidate_address(_newOwner)\r\n\tonlyOwner {\r\n\t\trequire(_newOwner != owner);\r\n\t\towner = _newOwner;\r\n\t}\r\n\r\n\t/// @dev The fallback function is called when ether is sent to the contract\r\n\t/// Payable is a required solidity modifier to receive ether\r\n\t/// every contract only has one unnamed function\r\n\t/// 2300 gas available for this function\r\n\t/*function () public payable {\r\n\t\treturn deposit();\r\n\t}*/\r\n\r\n\t/**\r\n\t* Pay on a behalf of the sender.\r\n\t*\r\n\t* @param customerId Identifier in the central database, UUID v4\r\n\t*\r\n\t*/\r\n\t/// @dev allow purchasers to deposit ETH for GIL Tokens.\r\n\tfunction depositForMySelf(uint256 userId)\r\n\tpublic\r\n\tonly_sale_active\r\n\tminimum_contribution()\r\n\tpayable {\r\n\t\tdeposit(userId, msg.sender);\r\n\t}\r\n\r\n\t///\t@dev deposit() is an public function that accepts a userId and userAddress\r\n\t///\tcontract receives ETH in return of GIL tokens\r\n\tfunction deposit(uint256 userId, address userAddress)\r\n\tpublic\r\n\tpayable\r\n\tonly_sale_active\r\n\tminimum_contribution()\r\n\tvalidate_address(userAddress) {\r\n\t\t// if it passes hard cap throw\r\n\t\tif (totalRaised + msg.value > hardCap) revert();\r\n\r\n\t\tuint256 userAssignedTokens = calculateTokens(msg.value);\r\n\r\n\t\t// if user tokens are 0 throw\r\n\t\tif (userAssignedTokens <= 0) revert();\r\n\r\n\t\t// if number of tokens exceed the token cap stop execution\r\n\t\tif (token.totalSupply() + userAssignedTokens > tokenCap) revert();\r\n\r\n\t\t// send funds to fund owner wallet\r\n\t\tif (!fundOwnerWallet.send(msg.value)) revert();\r\n\r\n\t\t// mint tokens for the user\r\n\t\tif (!token.mint(userAddress, userAssignedTokens)) revert();\r\n\r\n\t\t// save total number wei raised\r\n\t\ttotalRaised = safeAdd(totalRaised, msg.value);\r\n\r\n\t\t// if cap is reached mark it\r\n\t\tif (totalRaised >= hardCap) {\r\n\t\t\tisCapReached = true;\r\n\t\t}\r\n\r\n\t\t// if token supply has exceeded or reached the token cap stop\r\n\t\tif (token.totalSupply() >= tokenCap) {\r\n\t\t\tisCapReached = true;\r\n\t\t}\r\n\r\n\t\t// increase the number of participants for the first transaction\r\n\t\tif (paymentsByUserId[userId] == 0) {\r\n\t\t\ttotalParticipants++;\r\n\t\t}\r\n\r\n\t\t// increase the amount that the user has payed\r\n\t\tpaymentsByUserId[userId] += msg.value;\r\n\r\n\t\t// total wei based on address\r\n\t\tpaymentsByAddress[userAddress] += msg.value;\r\n\r\n\t\t// log contribution event\r\n\t\tLogContribution(\r\n\t\t\tuserAddress,\r\n\t\t\tmsg.sender,\r\n\t\t\tmsg.value,\r\n\t\t\ttotalRaised,\r\n\t\t\tuserAssignedTokens,\r\n\t\t\tuserId\r\n\t\t);\r\n\t}\r\n\r\n\t/// @notice calculate number of tokens need to be issued based on the amount received\r\n\t/// @param amount number of wei received\r\n\tfunction calculateTokens(uint256 amount)\r\n\tpublic\r\n\tview\r\n\treturns (uint256) {\r\n\t\t// return 0 if the crowd fund has ended or it hasn't started\r\n\t\tif (!isDuringSalePeriod(getBlockNumber())) return 0;\r\n\r\n\t\t// get the current stage number by block number\r\n\t\tuint8 currentStage = getStageByBlockNumber(getBlockNumber());\r\n\r\n\t\t// if current stage is more than the total stage return 0 - something is wrong\r\n\t\tif (currentStage > totalStages) return 0;\r\n\r\n\t\t// calculate number of tokens that needs to be issued for the purchaser\r\n\t\tuint256 purchasedTokens = safeMul(amount, tokenPrice);\r\n\t\t// calculate number of tokens that needs to be rewraded to the purchaser\r\n\t\tuint256 rewardedTokens = calculateRewardTokens(purchasedTokens, currentStage);\r\n\t\t// add purchasedTokens and rewardedTokens\r\n\t\treturn safeAdd(purchasedTokens, rewardedTokens);\r\n\t}\r\n\r\n\t/// @notice calculate reward based on amount of tokens that will be issued to the purchaser\r\n\t/// @param amount number tokens that will be minted for the purchaser\r\n\t/// @param stageNumber number of current stage in the crowd fund process\r\n\tfunction calculateRewardTokens(uint256 amount, uint8 stageNumber)\r\n\tpublic\r\n\tview\r\n\treturns (uint256 rewardAmount) {\r\n\t\t// throw if it's invalid stage number\r\n\t\tif (\r\n\t\t\tstageNumber < 1 ||\r\n\t\t\tstageNumber > totalStages\r\n\t\t) revert();\r\n\r\n\t\t// get stage index for the array\r\n\t\tuint8 stageIndex = stageNumber - 1;\r\n\r\n\t\t// calculate reward - e.q 100 token creates 100 * 20 /100 = 20 tokens for reward\r\n\t\treturn safeDiv(safeMul(amount, stageBonusPercentage[stageIndex]), 100);\r\n\t}\r\n\r\n\t/// @notice get crowd fund stage by block number\r\n\t/// @param _blockNumber block number\r\n\tfunction getStageByBlockNumber(uint256 _blockNumber)\r\n\tpublic\r\n\tview\r\n\treturns (uint8) {\r\n\t\t// throw error, if block number is out of range\r\n\t\tif (!isDuringSalePeriod(_blockNumber)) revert();\r\n\r\n\t\tuint256 totalBlocks = safeSub(endBlock, startBlock);\r\n\t\tuint256 numOfBlockPassed = safeSub(_blockNumber, startBlock);\r\n\r\n\t\t// since numbers round down we need to add one to number of stage\r\n\t\treturn uint8(safeDiv(safeMul(totalStages, numOfBlockPassed), totalBlocks) + 1);\r\n\t}\r\n\r\n\t// --------------\r\n\t// Internal Funtions\r\n\t// --------------\r\n\r\n\t/// @notice check if the block number is during the sale period\r\n\t/// @param _blockNumber block number\r\n\tfunction isDuringSalePeriod(uint256 _blockNumber)\r\n\tview\r\n\tinternal\r\n\treturns (bool) {\r\n\t\treturn (_blockNumber >= startBlock && _blockNumber < endBlock);\r\n\t}\r\n\r\n\t/// @notice finalize the crowdfun sale\r\n\t/// @dev Only Gilgamesh Dev can trigger this function\r\n\tfunction doFinalizeSale()\r\n\tinternal\r\n\tonlyOwner {\r\n\r\n\t\tif (saleFinalized) revert();\r\n\r\n\t\t// calculate the number of tokens that needs to be assigned to Gilgamesh team\r\n\t\tuint256 teamTokens = safeMul(token.totalSupply(), teamTokenRatio);\r\n\r\n\t\tif (teamTokens > 0){\r\n\t\t\t// mint tokens for the team\r\n\t\t\tif (!token.mint(tokenOwnerWallet, teamTokens)) revert();\r\n\t\t}\r\n\r\n\t\t// if there is any fund drain it\r\n\t\tif(this.balance > 0) {\r\n\t\t\t// send ether funds to fund owner wallet\r\n\t\t\tif (!fundOwnerWallet.send(this.balance)) revert();\r\n\t\t}\r\n\r\n\t\t// finalize sale flag\r\n\t\tsaleFinalized = true;\r\n\r\n\t\t// stop sale flag\r\n\t\tsaleStopped = true;\r\n\r\n\t\t// log finalized\r\n\t\tLogFinalized(tokenOwnerWallet, teamTokens);\r\n\t}\r\n\r\n\t/// @notice returns block.number\r\n\tfunction getBlockNumber() constant internal returns (uint) {\r\n\t\treturn block.number;\r\n\t}\r\n\r\n\t// --------------\r\n\t// Modifiers\r\n\t// --------------\r\n\r\n\t/// continue only when sale has stopped\r\n\tmodifier only_sale_stopped {\r\n\t\tif (!saleStopped) revert();\r\n\t\t_;\r\n\t}\r\n\r\n\r\n\t/// validates an address - currently only checks that it isn't null\r\n\tmodifier validate_address(address _address) {\r\n\t\tif (_address == 0x0) revert();\r\n\t\t_;\r\n\t}\r\n\r\n\t/// continue only during the sale period\r\n\tmodifier only_during_sale_period {\r\n\t\t// if block number is less than starting block fail\r\n\t\tif (getBlockNumber() < startBlock) revert();\r\n\t\t// if block number has reach to the end block fail\r\n\t\tif (getBlockNumber() >= endBlock) revert();\r\n\t\t// otherwise safe to continue\r\n\t\t_;\r\n\t}\r\n\r\n\t/// continue when sale is active and valid\r\n\tmodifier only_sale_active {\r\n\t\t// if sale is finalized fail\r\n\t\tif (saleFinalized) revert();\r\n\t\t// if sale is stopped fail\r\n\t\tif (saleStopped) revert();\r\n\t\t// if cap is reached\r\n\t\tif (isCapReached) revert();\r\n\t\t// if block number is less than starting block fail\r\n\t\tif (getBlockNumber() < startBlock) revert();\r\n\t\t// if block number has reach to the end block fail\r\n\t\tif (getBlockNumber() >= endBlock) revert();\r\n\t\t// otherwise safe to continue\r\n\t\t_;\r\n\t}\r\n\r\n\t/// continue if minimum contribution has reached\r\n\tmodifier minimum_contribution() {\r\n\t\tif (msg.value < minimumInvestment) revert();\r\n\t\t_;\r\n\t}\r\n\r\n\t/// continue when the invoker is the owner\r\n\tmodifier onlyOwner() {\r\n\t\tif (msg.sender != owner) revert();\r\n\t\t_;\r\n\t}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"endBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"paymentsByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fundOwnerWallet\",\"type\":\"address\"}],\"name\":\"changeFundOwnerWalletAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"userId\",\"type\":\"uint256\"}],\"name\":\"depositForMySelf\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"creationBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenOwnerWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"emergencyStopSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumInvestment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stageMaxBonusPercentage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenOwnerWallet\",\"type\":\"address\"}],\"name\":\"changeTokenOwnerWalletAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stageBonusPercentage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleStopped\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"getStageByBlockNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalizeSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"userId\",\"type\":\"uint256\"},{\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"calculateTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"restartSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cap\",\"type\":\"uint256\"}],\"name\":\"changeCap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cap\",\"type\":\"uint256\"}],\"name\":\"changeMinimumCap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalParticipants\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleFinalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"paymentsByUserId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundOwnerWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"stageNumber\",\"type\":\"uint8\"}],\"name\":\"calculateRewardTokens\",\"outputs\":[{\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamTokenRatio\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isCapReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalStages\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"removeContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_startBlock\",\"type\":\"uint256\"},{\"name\":\"_endBlock\",\"type\":\"uint256\"},{\"name\":\"_fundOwnerWallet\",\"type\":\"address\"},{\"name\":\"_tokenOwnerWallet\",\"type\":\"address\"},{\"name\":\"_totalStages\",\"type\":\"uint8\"},{\"name\":\"_stageMaxBonusPercentage\",\"type\":\"uint8\"},{\"name\":\"_tokenPrice\",\"type\":\"uint256\"},{\"name\":\"_gilgameshToken\",\"type\":\"address\"},{\"name\":\"_minimumCap\",\"type\":\"uint256\"},{\"name\":\"_tokenCap\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"fundOwnerWallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"startBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"endBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"creationBlock\",\"type\":\"uint256\"}],\"name\":\"LogTokenSaleInitialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"contributorAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"invokerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalRaised\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"userAssignedTokens\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"userId\",\"type\":\"uint256\"}],\"name\":\"LogContribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"teamTokens\",\"type\":\"uint256\"}],\"name\":\"LogFinalized\",\"type\":\"event\"}]","ContractName":"GilgameshTokenSale","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000004af9e3000000000000000000000000000000000000000000000000000000000050f7fd000000000000000000000000365999e63fa10a80e263f6db5aaf4e19f5baf5d500000000000000000000000079fad5d5537daf2721901836e91626745cbb7497000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000001b00000000000000000000000000000000000000000000000000000000000004b000000000000000000000000018361baeb2afd717e36e3c9b44ad12d084911ae0000000000000000000000000000000000000000000000043c33c19375648000000000000000000000000000000000000000000000031a17e847807b1bc000000","Library":"","SwarmSource":"bzzr://2e14ff47493caf40d0f90f49c19594d41b1a93c8d2d8592b3ba48051d3680286"}]}