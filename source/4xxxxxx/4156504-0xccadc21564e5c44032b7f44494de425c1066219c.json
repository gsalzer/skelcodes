{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\n\r\n/* taking ideas from FirstBlood token */\r\ncontract SafeMath {\r\n\r\n    function safeAdd(uint256 x, uint256 y) internal returns (uint256) {\r\n        uint256 z = x + y;\r\n        assert((z >= x) && (z >= y));\r\n        return z;\r\n    }\r\n\r\n    function safeSubtract(uint256 x, uint256 y) internal returns (uint256) {\r\n        assert(x >= y);\r\n        uint256 z = x - y;\r\n        return z;\r\n    }\r\n\r\n    function safeMult(uint256 x, uint256 y) internal returns (uint256) {\r\n        uint256 z = x * y;\r\n        assert((x == 0) || (z / x == y));\r\n        return z;\r\n    }\r\n}\r\n\r\n\r\n/*\r\n * Ownable\r\n *\r\n * Base contract with an owner.\r\n * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    function Ownable() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) onlyOwner {\r\n        if (newOwner != address(0)) {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n/*\r\n * Haltable\r\n *\r\n * Abstract contract that allows children to implement an\r\n * emergency stop mechanism. Differs from Pausable by causing a throw when in halt mode.\r\n *\r\n *\r\n * Originally envisioned in FirstBlood ICO contract.\r\n */\r\ncontract Haltable is Ownable {\r\n    bool public halted;\r\n\r\n    modifier stopInEmergency {\r\n        require(!halted);\r\n        _;\r\n    }\r\n\r\n    modifier onlyInEmergency {\r\n        require(halted);\r\n        _;\r\n    }\r\n\r\n    // called by the owner on emergency, triggers stopped state\r\n    function halt() external onlyOwner {\r\n        halted = true;\r\n    }\r\n\r\n    // called by the owner on end of emergency, returns to normal state\r\n    function unhalt() external onlyOwner onlyInEmergency {\r\n        halted = false;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract FluencePreSale is Haltable, SafeMath {\r\n\r\n    mapping (address => uint256) public balanceOf;\r\n\r\n    /*/\r\n     *  Constants\r\n    /*/\r\n\r\n    string public constant name = \"Fluence Presale Token\";\r\n\r\n    string public constant symbol = \"FPT\";\r\n\r\n    uint   public constant decimals = 18;\r\n\r\n    // 6% of tokens\r\n    uint256 public constant SUPPLY_LIMIT = 6000000 ether;\r\n\r\n    // What is given to contributors, <= SUPPLY_LIMIT\r\n    uint256 public totalSupply;\r\n\r\n    // If soft cap is not reached, refund process is started\r\n    uint256 public softCap = 1000 ether;\r\n\r\n    // Basic price\r\n    uint256 public constant basicThreshold = 500 finney;\r\n\r\n    uint public constant basicTokensPerEth = 1500;\r\n\r\n    // Advanced price\r\n    uint256 public constant advancedThreshold = 5 ether;\r\n\r\n    uint public constant advancedTokensPerEth = 2250;\r\n\r\n    // Expert price\r\n    uint256 public constant expertThreshold = 100 ether;\r\n\r\n    uint public constant expertTokensPerEth = 3000;\r\n\r\n    // As we have different prices for different amounts,\r\n    // we keep a mapping of contributions to make refund\r\n    mapping (address => uint256) public etherContributions;\r\n\r\n    // Max balance of the contract\r\n    uint256 public etherCollected;\r\n\r\n    // Address to withdraw ether to\r\n    address public beneficiary;\r\n\r\n    uint public startAtBlock;\r\n\r\n    uint public endAtBlock;\r\n\r\n    // All tokens are sold\r\n    event GoalReached(uint amountRaised);\r\n\r\n    // Minimal ether cap collected\r\n    event SoftCapReached(uint softCap);\r\n\r\n    // New contribution received and tokens are issued\r\n    event NewContribution(address indexed holder, uint256 tokenAmount, uint256 etherAmount);\r\n\r\n    // Ether is taken back\r\n    event Refunded(address indexed holder, uint256 amount);\r\n\r\n    // If soft cap is reached, withdraw should be available\r\n    modifier softCapReached {\r\n        if (etherCollected < softCap) {\r\n            revert();\r\n        }\r\n        assert(etherCollected >= softCap);\r\n        _;\r\n    }\r\n\r\n    // Allow contribution only during presale\r\n    modifier duringPresale {\r\n        if (block.number < startAtBlock || block.number > endAtBlock || totalSupply >= SUPPLY_LIMIT) {\r\n            revert();\r\n        }\r\n        assert(block.number >= startAtBlock && block.number <= endAtBlock && totalSupply < SUPPLY_LIMIT);\r\n        _;\r\n    }\r\n\r\n    // Allow withdraw only during refund\r\n    modifier duringRefund {\r\n        if(block.number <= endAtBlock || etherCollected >= softCap || this.balance == 0) {\r\n            revert();\r\n        }\r\n        assert(block.number > endAtBlock && etherCollected < softCap && this.balance > 0);\r\n        _;\r\n    }\r\n\r\n    function FluencePreSale(uint _startAtBlock, uint _endAtBlock, uint softCapInEther){\r\n        require(_startAtBlock > 0 && _endAtBlock > 0);\r\n        beneficiary = msg.sender;\r\n        startAtBlock = _startAtBlock;\r\n        endAtBlock = _endAtBlock;\r\n        softCap = softCapInEther * 1 ether;\r\n    }\r\n\r\n    // Change beneficiary address\r\n    function setBeneficiary(address to) onlyOwner external {\r\n        require(to != address(0));\r\n        beneficiary = to;\r\n    }\r\n\r\n    // Withdraw contract's balance to beneficiary account\r\n    function withdraw() onlyOwner softCapReached external {\r\n        require(this.balance > 0);\r\n        beneficiary.transfer(this.balance);\r\n    }\r\n\r\n    // Process contribution, issue tokens to user\r\n    function contribute(address _address) private stopInEmergency duringPresale {\r\n        if(msg.value < basicThreshold && owner != _address) {\r\n            revert();\r\n        }\r\n        assert(msg.value >= basicThreshold || owner == _address);\r\n        // Minimal contribution\r\n\r\n        uint256 tokensToIssue;\r\n\r\n        if (msg.value >= expertThreshold) {\r\n            tokensToIssue = safeMult(msg.value, expertTokensPerEth);\r\n        }\r\n        else if (msg.value >= advancedThreshold) {\r\n            tokensToIssue = safeMult(msg.value, advancedTokensPerEth);\r\n        }\r\n        else {\r\n            tokensToIssue = safeMult(msg.value, basicTokensPerEth);\r\n        }\r\n\r\n        assert(tokensToIssue > 0);\r\n\r\n        totalSupply = safeAdd(totalSupply, tokensToIssue);\r\n\r\n        // Goal is already reached, can't issue any more tokens\r\n        if(totalSupply > SUPPLY_LIMIT) {\r\n            revert();\r\n        }\r\n        assert(totalSupply <= SUPPLY_LIMIT);\r\n\r\n        // Saving ether contributions for the case of refund\r\n        etherContributions[_address] = safeAdd(etherContributions[_address], msg.value);\r\n\r\n        // Track ether before adding current contribution to notice the event of reaching soft cap\r\n        uint collectedBefore = etherCollected;\r\n        etherCollected = safeAdd(etherCollected, msg.value);\r\n\r\n        // Tokens are issued\r\n        balanceOf[_address] = safeAdd(balanceOf[_address], tokensToIssue);\r\n\r\n        NewContribution(_address, tokensToIssue, msg.value);\r\n\r\n        if (totalSupply == SUPPLY_LIMIT) {\r\n            GoalReached(etherCollected);\r\n        }\r\n        if (etherCollected >= softCap && collectedBefore < softCap) {\r\n            SoftCapReached(etherCollected);\r\n        }\r\n    }\r\n\r\n    function() external payable {\r\n        contribute(msg.sender);\r\n    }\r\n\r\n    function refund() stopInEmergency duringRefund external {\r\n        uint tokensToBurn = balanceOf[msg.sender];\r\n\r\n\r\n        // Sender must have tokens\r\n        require(tokensToBurn > 0);\r\n\r\n        // Burn\r\n        balanceOf[msg.sender] = 0;\r\n\r\n        // User contribution amount\r\n        uint amount = etherContributions[msg.sender];\r\n\r\n        // Amount must be positive -- refund is not processed yet\r\n        assert(amount > 0);\r\n\r\n        etherContributions[msg.sender] = 0;\r\n        // Clear state\r\n\r\n        // Reduce counters\r\n        etherCollected = safeSubtract(etherCollected, amount);\r\n        totalSupply = safeSubtract(totalSupply, tokensToBurn);\r\n\r\n        // Process refund. In case of error, it will be thrown\r\n        msg.sender.transfer(amount);\r\n\r\n        Refunded(msg.sender, amount);\r\n    }\r\n\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"}],\"name\":\"setBeneficiary\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"basicTokensPerEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SUPPLY_LIMIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"etherContributions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"etherCollected\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"expertThreshold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endAtBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"halt\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startAtBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"advancedThreshold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"softCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"basicThreshold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"halted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unhalt\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"advancedTokensPerEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"expertTokensPerEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_startAtBlock\",\"type\":\"uint256\"},{\"name\":\"_endAtBlock\",\"type\":\"uint256\"},{\"name\":\"softCapInEther\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amountRaised\",\"type\":\"uint256\"}],\"name\":\"GoalReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"softCap\",\"type\":\"uint256\"}],\"name\":\"SoftCapReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"etherAmount\",\"type\":\"uint256\"}],\"name\":\"NewContribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Refunded\",\"type\":\"event\"}]","ContractName":"FluencePreSale","CompilerVersion":"v0.4.13+commit.fb4cb1a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000003f6d9d000000000000000000000000000000000000000000000000000000000040c80000000000000000000000000000000000000000000000000000000000000003e8","Library":"","SwarmSource":"bzzr://eabe9ff8b41f137f55e450471a9738eb16e87ca1c707b8423e2ff3f9faed0634"}]}