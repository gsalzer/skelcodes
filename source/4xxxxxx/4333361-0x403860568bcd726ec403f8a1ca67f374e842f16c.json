{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.14;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() constant returns (uint supply);\r\n    function balanceOf( address who ) constant returns (uint value);\r\n    function allowance( address owner, address spender ) constant returns (uint _allowance);\r\n\r\n    function transfer( address to, uint value) returns (bool ok);\r\n    function transferFrom( address from, address to, uint value) returns (bool ok);\r\n    function approve( address spender, uint value ) returns (bool ok);\r\n\r\n    event Transfer( address indexed from, address indexed to, uint value);\r\n    event Approval( address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract DSMath {\r\n    \r\n    /*\r\n    standard uint256 functions\r\n     */\r\n\r\n    function add(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        assert((z = x + y) >= x);\r\n    }\r\n\r\n    function sub(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        assert((z = x - y) <= x);\r\n    }\r\n\r\n    function mul(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        assert((z = x * y) >= x);\r\n    }\r\n\r\n    function div(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        z = x / y;\r\n    }\r\n\r\n    function min(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    /*\r\n    uint128 functions (h is for half)\r\n     */\r\n\r\n\r\n    function hadd(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        assert((z = x + y) >= x);\r\n    }\r\n\r\n    function hsub(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        assert((z = x - y) <= x);\r\n    }\r\n\r\n    function hmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        assert((z = x * y) >= x);\r\n    }\r\n\r\n    function hdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        z = x / y;\r\n    }\r\n\r\n    function hmin(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function hmax(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n\r\n    /*\r\n    int256 functions\r\n     */\r\n\r\n    function imin(int256 x, int256 y) constant internal returns (int256 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int256 x, int256 y) constant internal returns (int256 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    /*\r\n    WAD math\r\n     */\r\n\r\n    uint128 constant WAD = 10 ** 18;\r\n\r\n    function wadd(uint128 x, uint128 y) constant internal returns (uint128) {\r\n        return hadd(x, y);\r\n    }\r\n\r\n    function wsub(uint128 x, uint128 y) constant internal returns (uint128) {\r\n        return hsub(x, y);\r\n    }\r\n\r\n    function wmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        z = cast((uint256(x) * y + WAD / 2) / WAD);\r\n    }\r\n\r\n    function wdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        z = cast((uint256(x) * WAD + y / 2) / y);\r\n    }\r\n\r\n    function wmin(uint128 x, uint128 y) constant internal returns (uint128) {\r\n        return hmin(x, y);\r\n    }\r\n    function wmax(uint128 x, uint128 y) constant internal returns (uint128) {\r\n        return hmax(x, y);\r\n    }\r\n\r\n    /*\r\n    RAY math\r\n     */\r\n\r\n    uint128 constant RAY = 10 ** 27;\r\n\r\n    function radd(uint128 x, uint128 y) constant internal returns (uint128) {\r\n        return hadd(x, y);\r\n    }\r\n\r\n    function rsub(uint128 x, uint128 y) constant internal returns (uint128) {\r\n        return hsub(x, y);\r\n    }\r\n\r\n    function rmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        z = cast((uint256(x) * y + RAY / 2) / RAY);\r\n    }\r\n\r\n    function rdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        z = cast((uint256(x) * RAY + y / 2) / y);\r\n    }\r\n\r\n    function rpow(uint128 x, uint64 n) constant internal returns (uint128 z) {\r\n        // This famous algorithm is called \"exponentiation by squaring\"\r\n        // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n        //\r\n        // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n        //\r\n        // These facts are why it works:\r\n        //\r\n        //  If n is even, then x^n = (x^2)^(n/2).\r\n        //  If n is odd,  then x^n = x * x^(n-1),\r\n        //   and applying the equation for even x gives\r\n        //    x^n = x * (x^2)^((n-1) / 2).\r\n        //\r\n        //  Also, EVM division is flooring and\r\n        //    floor[(n-1) / 2] = floor[n / 2].\r\n\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n\r\n    function rmin(uint128 x, uint128 y) constant internal returns (uint128) {\r\n        return hmin(x, y);\r\n    }\r\n    function rmax(uint128 x, uint128 y) constant internal returns (uint128) {\r\n        return hmax(x, y);\r\n    }\r\n\r\n    function cast(uint256 x) constant internal returns (uint128 z) {\r\n        assert((z = uint128(x)) == x);\r\n    }\r\n\r\n}\r\n\r\ncontract TokenBase is ERC20, DSMath {\r\n    uint256                                            _supply;\r\n    mapping (address => uint256)                       _balances;\r\n    mapping (address => mapping (address => uint256))  _approvals;\r\n\r\n    function totalSupply() constant returns (uint256) {\r\n        return _supply;\r\n    }\r\n    function balanceOf(address addr) constant returns (uint256) {\r\n        return _balances[addr];\r\n    }\r\n    function allowance(address from, address to) constant returns (uint256) {\r\n        return _approvals[from][to];\r\n    }\r\n    \r\n    function transfer(address to, uint value) returns (bool) {\r\n        assert(_balances[msg.sender] >= value);\r\n        \r\n        _balances[msg.sender] = sub(_balances[msg.sender], value);\r\n        _balances[to] = add(_balances[to], value);\r\n        \r\n        Transfer(msg.sender, to, value);\r\n        \r\n        return true;\r\n    }\r\n    \r\n    function transferFrom(address from, address to, uint value) returns (bool) {\r\n        assert(_balances[from] >= value);\r\n        assert(_approvals[from][msg.sender] >= value);\r\n        \r\n        _approvals[from][msg.sender] = sub(_approvals[from][msg.sender], value);\r\n        _balances[from] = sub(_balances[from], value);\r\n        _balances[to] = add(_balances[to], value);\r\n        \r\n        Transfer(from, to, value);\r\n        \r\n        return true;\r\n    }\r\n    \r\n    function approve(address to, uint256 value) returns (bool) {\r\n        _approvals[msg.sender][to] = value;\r\n        \r\n        Approval(msg.sender, to, value);\r\n        \r\n        return true;\r\n    }\r\n\r\n}\r\n\r\ncontract Owned\r\n{\r\n    address public owner;\r\n    \r\n    function Owned()\r\n    {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    modifier onlyOwner()\r\n    {\r\n        if (msg.sender != owner) revert();\r\n        _;\r\n    }\r\n}\r\n\r\ncontract Migrable is TokenBase, Owned\r\n{\r\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\r\n    address public migrationAgent;\r\n    uint256 public totalMigrated;\r\n\r\n\r\n    function migrate() external {\r\n        if (migrationAgent == 0)  revert();\r\n        if (_balances[msg.sender] == 0)  revert();\r\n        \r\n        uint256 _value = _balances[msg.sender];\r\n        _balances[msg.sender] = 0;\r\n        _supply = sub(_supply, _value);\r\n        totalMigrated = add(totalMigrated, _value);\r\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\r\n        Migrate(msg.sender, migrationAgent, _value);\r\n    }\r\n\r\n    function setMigrationAgent(address _agent) onlyOwner external {\r\n        if (migrationAgent != 0)  revert();\r\n        migrationAgent = _agent;\r\n    }\r\n}\r\n\r\ncontract CrowdCoin is TokenBase, Owned, Migrable {\r\n    string public constant name = \"Crowd Coin\";\r\n    string public constant symbol = \"CRC\";\r\n    uint8 public constant decimals = 18; \r\n\r\n    uint public constant pre_ico_allocation = 10000000 * WAD;\r\n    uint public constant bounty_allocation = 1000000 * WAD;\r\n    \r\n    uint public ico_allocation = 5000000 * WAD;\r\n\r\n    bool public locked = true;\r\n\r\n    address public bounty;\r\n    CrowdCoinPreICO public pre_ico;\r\n    CrowdCoinICO public ico;\r\n\r\n    function transfer(address to, uint value) returns (bool)\r\n    {\r\n        if (locked == true && msg.sender != address(ico) && msg.sender != address(pre_ico)) revert();\r\n        return super.transfer(to, value);\r\n    }\r\n    \r\n    function transferFrom(address from, address to, uint value)  returns (bool)\r\n    {\r\n        if (locked == true) revert();\r\n        return super.transferFrom(from, to, value);\r\n    }\r\n\r\n    function init_pre_ico(address _pre_ico) onlyOwner\r\n    {\r\n        if (address(0) != address(pre_ico)) revert();\r\n        pre_ico = CrowdCoinPreICO(_pre_ico);\r\n        mint_tokens(pre_ico, pre_ico_allocation);\r\n    }\r\n    \r\n    function close_pre_ico() onlyOwner\r\n    {\r\n        ico_allocation = add(ico_allocation, _balances[pre_ico]);   \r\n        burn_balance(pre_ico);\r\n    }\r\n\r\n    function init_ico(address _ico) onlyOwner\r\n    {\r\n        if (address(0) != address(ico) || address(0) == address(pre_ico) || _balances[pre_ico] > 0) revert();\r\n        ico = CrowdCoinICO(_ico);\r\n        mint_tokens(ico, ico_allocation);\r\n    }\r\n    \r\n    function init_bounty_program(address _bounty) onlyOwner\r\n    {\r\n        if (address(0) != address(bounty)) revert();\r\n        bounty = _bounty;\r\n        mint_tokens(bounty, bounty_allocation);\r\n    }\r\n    \r\n    function finalize(address team_allocation) onlyOwner {\r\n        if (ico.successfully_closed() == false || locked == false || address(0) == address(bounty)) revert();\r\n        burn_balance(ico);\r\n\r\n        uint256 percentOfTotal = 20;\r\n        uint256 additionalTokens =\r\n            _supply * percentOfTotal / (100 - percentOfTotal);\r\n        \r\n        mint_tokens(team_allocation, additionalTokens);\r\n        \r\n        locked = false;\r\n    }\r\n\r\n    function mint_tokens(address addr, uint amount) private\r\n    {\r\n        _balances[addr] = add(_balances[addr], amount);\r\n        _supply = add(_supply, amount);\r\n        Transfer(0, addr, amount);\r\n    }\r\n    \r\n    function burn_balance(address addr) private\r\n    {\r\n        uint amount = _balances[addr];\r\n        if (amount > 0)\r\n        {\r\n            _balances[addr] = 0;\r\n            _supply = sub(_supply, amount);\r\n            Transfer(addr, 0, amount);\r\n        }\r\n    }\r\n}\r\n\r\ncontract CrowdCoinManualSell\r\n{\r\n    CrowdCoin public token;\r\n    address public dev_multisig;\r\n    address private constant owner_1 = 0x792030B6811043f79ae49d2C4bA33cC6a6326049;\r\n    address private constant owner_2 = 0x886531ed00cF51B6219Bf9EF9201ff4DEc622E6f;\r\n\r\n    event Purchased(address participant, uint eth_amount, uint token_amount);\r\n    event ManualPurchase(address sender, address participant, uint token_amount);\r\n\r\n    function transfer_coins(address _to, uint _value) public\r\n    {\r\n        if (msg.sender != owner_1 && msg.sender != owner_2) revert();\r\n        token.transfer(_to, _value);\r\n        ManualPurchase(msg.sender, _to, _value);\r\n    }\r\n\r\n    function my_token_balance() public constant returns (uint)\r\n    {\r\n        return token.balanceOf(this);\r\n    }\r\n\r\n    modifier has_value\r\n    {\r\n        if (msg.value < 0.01 ether) revert();\r\n        _;\r\n    }\r\n}\r\n\r\ncontract CrowdCoinSaleBonus\r\n{\r\n    function get_bonus(uint buy_amount) internal returns(uint)\r\n    {\r\n        uint bonus = 0;\r\n        if (buy_amount >= 100000 ether)\r\n        {\r\n            bonus = 30;            \r\n        }\r\n        else if (buy_amount >= 50000 ether)\r\n        {\r\n            bonus = 25;            \r\n        }\r\n        else if (buy_amount >= 30000 ether)\r\n        {\r\n            bonus = 23;            \r\n        }\r\n        else if (buy_amount >= 20000 ether)\r\n        {\r\n            bonus = 20;            \r\n        }\r\n        else if (buy_amount >= 13000 ether)\r\n        {\r\n            bonus = 18;            \r\n        }\r\n        else if (buy_amount >= 8000 ether)\r\n        {\r\n            bonus = 15;            \r\n        }\r\n        else if (buy_amount >= 5000 ether)\r\n        {\r\n            bonus = 13;            \r\n        }\r\n        else if (buy_amount >= 3000 ether)\r\n        {\r\n            bonus = 10;            \r\n        }\r\n        return buy_amount * bonus / 100;\r\n    }\r\n}\r\n\r\ncontract CrowdCoinPreICO is Owned, DSMath, CrowdCoinSaleBonus, CrowdCoinManualSell\r\n{\r\n    \r\n    uint public total_raised;\r\n\r\n    uint public constant price =  0.00125 * 10**18; //have to set price here\r\n\r\n    function CrowdCoinPreICO(address _token_address, address _dev_multisig)\r\n    {\r\n        token = CrowdCoin(_token_address);\r\n        dev_multisig = _dev_multisig;\r\n    }\r\n    \r\n    function () has_value payable external \r\n    {\r\n        if (my_token_balance() == 0) revert();\r\n\r\n        var can_buy = wdiv(cast(msg.value), cast(price));\r\n        can_buy = wadd(can_buy, cast(get_bonus(can_buy)));\r\n        var buy_amount = cast(min(can_buy, my_token_balance()));\r\n\r\n        if (can_buy > buy_amount) revert();\r\n\r\n        total_raised = add(total_raised, msg.value);\r\n\r\n        dev_multisig.transfer(this.balance); //transfer eth to dev\r\n        token.transfer(msg.sender, buy_amount); //transfer tokens to participant\r\n        Purchased(msg.sender, msg.value, buy_amount);\r\n    }\r\n}\r\n\r\ncontract CrowdCoinICO is Owned, DSMath, CrowdCoinSaleBonus, CrowdCoinManualSell\r\n{\r\n    uint public total_raised; //crowdsale total funds raised\r\n\r\n    uint public start_time = 0;\r\n    uint public end_time = 0;\r\n    uint public constant goal = 350 ether;\r\n    uint256 public constant default_price = 0.005 * 10**18;\r\n    \r\n    mapping (uint => uint256) public price;\r\n\r\n    mapping(address => uint) funded; //needed to save amounts of ETH for refund\r\n    \r\n    modifier in_time //allows send eth only when crowdsale is active\r\n    {\r\n        if (time() < start_time || time() > end_time)  revert();\r\n        _;\r\n    }\r\n\r\n    function successfully_closed() public constant returns (bool)\r\n    {\r\n        return time() > start_time && (time() > end_time || my_token_balance() == 0) && total_raised >= goal;\r\n    }\r\n    \r\n    function time() public constant returns (uint)\r\n    {\r\n        return block.timestamp;\r\n    }\r\n\r\n    function CrowdCoinICO(address _token_address, address _dev_multisig)\r\n    {\r\n        token = CrowdCoin(_token_address);\r\n        dev_multisig = _dev_multisig;\r\n        \r\n        price[0] = 0.0025 * 10**18;\r\n        price[1] = 0.0033 * 10**18;\r\n        price[2] = 0.0044 * 10**18;\r\n    }\r\n    \r\n    function init(uint _start_time, uint _end_time) onlyOwner\r\n    {\r\n        if (start_time != 0) revert();\r\n        start_time = _start_time;\r\n        end_time = _end_time;\r\n    }\r\n    \r\n    function () has_value in_time payable external \r\n    {\r\n        if (my_token_balance() == 0) revert();\r\n\r\n        var can_buy = wdiv(cast(msg.value), cast(get_current_price()));\r\n        can_buy = wadd(can_buy, cast(get_bonus(can_buy)));\r\n        var buy_amount = cast(min(can_buy, my_token_balance()));\r\n\r\n        if (can_buy > buy_amount) revert();\r\n\r\n        total_raised = add(total_raised, msg.value);\r\n        funded[msg.sender] = add(funded[msg.sender], msg.value);\r\n        token.transfer(msg.sender, buy_amount); //transfer tokens to participant\r\n        Purchased(msg.sender, msg.value, buy_amount);\r\n    }\r\n    \r\n    function refund()\r\n    {\r\n        if (total_raised >= goal || time() < end_time) revert();\r\n        var amount = funded[msg.sender];\r\n        if (amount > 0)\r\n        {\r\n            funded[msg.sender] = 0;\r\n            msg.sender.transfer(amount);\r\n        }\r\n    }\r\n    \r\n    function collect() //collect eth by devs if min goal reached\r\n    {\r\n        if (total_raised < goal) revert();\r\n        dev_multisig.transfer(this.balance);\r\n    }\r\n    \r\n    function get_current_price() constant returns (uint256) {\r\n        return price[current_week()] == 0 ? default_price : price[current_week()];\r\n    }\r\n    \r\n    function current_week() constant returns (uint) {\r\n        return sub(block.timestamp, start_time) / 7 days;\r\n    }\r\n}\r\n\r\n\r\ncontract CrowdDevAllocation is Owned\r\n{\r\n    CrowdCoin public token;\r\n    uint public initial_time;\r\n    address tokens_multisig;\r\n\r\n    mapping(uint => bool) public unlocked;\r\n    mapping(uint => uint) public unlock_times;\r\n    mapping(uint => uint) unlock_values;\r\n    \r\n    function CrowdDevAllocation(address _token)\r\n    {\r\n        token = CrowdCoin(_token);\r\n    }\r\n    \r\n    function init() onlyOwner\r\n    {\r\n        if (token.balanceOf(this) == 0 || initial_time != 0) revert();\r\n        initial_time = block.timestamp;\r\n        uint256 balance = token.balanceOf(this);\r\n\r\n        unlock_values[0] = balance / 100 * 33;\r\n        unlock_values[1] = balance / 100 * 33;\r\n        unlock_values[2] = balance / 100 * 34;\r\n\r\n        unlock_times[0] = 180 days; //33% of tokens will be available after 180 days\r\n        unlock_times[1] = 1080 days; //33% of tokens will be available after 1080 days\r\n        unlock_times[2] = 1800 days; //34% of tokens will be available after 1800 days\r\n    }\r\n\r\n    function unlock(uint part)\r\n    {\r\n        if (unlocked[part] == true || block.timestamp < initial_time + unlock_times[part] || unlock_values[part] == 0) revert();\r\n        token.transfer(tokens_multisig, unlock_values[part]);\r\n        unlocked[part] = true;\r\n    }\r\n}\r\n\r\ncontract MigrationAgent {\r\n    function migrateFrom(address _from, uint256 _value);\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"my_token_balance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer_coins\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"total_raised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dev_multisig\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token_address\",\"type\":\"address\"},{\"name\":\"_dev_multisig\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"participant\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"eth_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"token_amount\",\"type\":\"uint256\"}],\"name\":\"Purchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"participant\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token_amount\",\"type\":\"uint256\"}],\"name\":\"ManualPurchase\",\"type\":\"event\"}]","ContractName":"CrowdCoinPreICO","CompilerVersion":"v0.4.17+commit.bdeb9e52","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000047808C1Ea94EDe42CfA2fa429140D097f177D6b3000000000000000000000000F6b1A808b8003f4227EB0622bB101818e19B6FE2","Library":"","SwarmSource":"bzzr://a062380e90036a1d51230e978dc83b9a9068eabd214b84f3147efd0bebd40a52"}]}