{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.2;\r\n\r\nlibrary SafeMath {\r\n  function mul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n  function div(uint a, uint b) internal returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a / b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n  function sub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n  function add(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n \r\n}\r\n\r\n/*\r\n * Token - is a smart contract interface \r\n * for managing common functionality of \r\n * a token.\r\n *\r\n * ERC.20 Token standard: https://github.com/eth ereum/EIPs/issues/20\r\n */\r\ncontract TokenInterface {\r\n        // total amount of tokens\r\n        uint256 totalSupply;\r\n\r\n        /**\r\n         *\r\n         * balanceOf() - constant function check concrete tokens balance  \r\n         *\r\n         *  @param owner - account owner\r\n         *  \r\n         *  @return the value of balance \r\n         */\r\n        function balanceOf(address owner) constant returns(uint256 balance);\r\n        function transfer(address to, uint256 value) returns(bool success);\r\n        function transferFrom(address from, address to, uint256 value) returns(bool success);\r\n\r\n        /**\r\n         *\r\n         * approve() - function approves to a person to spend some tokens from \r\n         *           owner balance. \r\n         *\r\n         *  @param spender - person whom this right been granted.\r\n         *  @param value   - value to spend.\r\n         * \r\n         *  @return true in case of succes, otherwise failure\r\n         * \r\n         */\r\n        function approve(address spender, uint256 value) returns(bool success);\r\n\r\n        /**\r\n         *\r\n         * allowance() - constant function to check how much is \r\n         *               permitted to spend to 3rd person from owner balance\r\n         *\r\n         *  @param owner   - owner of the balance\r\n         *  @param spender - permitted to spend from this balance person \r\n         *  \r\n         *  @return - remaining right to spend \r\n         * \r\n         */\r\n        function allowance(address owner, address spender) constant returns(uint256 remaining);\r\n\r\n        // events notifications\r\n        event Transfer(address indexed from, address indexed to, uint256 value);\r\n        event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n/*\r\n * StandardToken - is a smart contract  \r\n * for managing common functionality of \r\n * a token.\r\n *\r\n * ERC.20 Token standard: \r\n *         https://github.com/eth ereum/EIPs/issues/20\r\n */\r\ncontract StandardToken is TokenInterface {\r\n        // token ownership\r\n        mapping(address => uint256) balances;\r\n\r\n        // spending permision management\r\n        mapping(address => mapping(address => uint256)) allowed;\r\n\r\n        address owner;\r\n        //best 10 owners\r\n        address[] best_wals;\r\n        uint[] best_count;\r\n\r\n        function StandardToken() {\r\n            for(uint8 i = 0; i < 10; i++) {\r\n                best_wals.push(address(0));\r\n                best_count.push(0);\r\n            }\r\n        }\r\n        \r\n        /**\r\n         * transfer() - transfer tokens from msg.sender balance \r\n         *              to requested account\r\n         *\r\n         *  @param to    - target address to transfer tokens\r\n         *  @param value - ammount of tokens to transfer\r\n         *\r\n         *  @return - success / failure of the transaction\r\n         */\r\n        function transfer(address to, uint256 value) returns(bool success) {\r\n\r\n                if (balances[msg.sender] >= value && value > 0) {\r\n                        // do actual tokens transfer       \r\n                        balances[msg.sender] -= value;\r\n                        balances[to] += value;\r\n\r\n                        CheckBest(balances[to], to);\r\n\r\n                        // rise the Transfer event\r\n                        Transfer(msg.sender, to, value);\r\n                        return true;\r\n                } else {\r\n\r\n                        return false;\r\n                }\r\n\r\n        }\r\n\r\n        function transferWithoutChangeBest(address to, uint256 value) returns(bool success) {\r\n\r\n                if (balances[msg.sender] >= value && value > 0) {\r\n                        // do actual tokens transfer       \r\n                        balances[msg.sender] -= value;\r\n                        balances[to] += value;\r\n\r\n                        // rise the Transfer event\r\n                        Transfer(msg.sender, to, value);\r\n                        return true;\r\n                } else {\r\n\r\n                        return false;\r\n                }\r\n\r\n        }\r\n\r\n        /**\r\n         * transferFrom() - \r\n         *\r\n         *  @param from  - \r\n         *  @param to    - \r\n         *  @param value - \r\n         *\r\n         *  @return \r\n         */\r\n        function transferFrom(address from, address to, uint256 value) returns(bool success) {\r\n\r\n                if (balances[from] >= value &&\r\n                        allowed[from][msg.sender] >= value &&\r\n                        value > 0) {\r\n\r\n\r\n                        // do the actual transfer\r\n                        balances[from] -= value;\r\n                        balances[to] += value;\r\n\r\n                        CheckBest(balances[to], to);\r\n\r\n                        // addjust the permision, after part of \r\n                        // permited to spend value was used\r\n                        allowed[from][msg.sender] -= value;\r\n\r\n                        // rise the Transfer event\r\n                        Transfer(from, to, value);\r\n                        return true;\r\n                } else {\r\n\r\n                        return false;\r\n                }\r\n        }\r\n\r\n        function CheckBest(uint _tokens, address _address) {\r\n            //дописать токен проверку лучших (перенести из краудсейла)\r\n            for(uint8 i = 0; i < 10; i++) {\r\n                            if(best_count[i] < _tokens) {\r\n                                for(uint8 j = 9; j > i; j--) {\r\n                                    best_count[j] = best_count[j-1];\r\n                                    best_wals[j] = best_wals[j-1];\r\n                                }\r\n\r\n                                best_count[i] = _tokens;\r\n                                best_wals[i] = _address;\r\n                                break;\r\n                            }\r\n                        }\r\n        }\r\n\r\n        /**\r\n         *\r\n         * balanceOf() - constant function check concrete tokens balance  \r\n         *\r\n         *  @param owner - account owner\r\n         *  \r\n         *  @return the value of balance \r\n         */\r\n        function balanceOf(address owner) constant returns(uint256 balance) {\r\n                return balances[owner];\r\n        }\r\n\r\n        /**\r\n         *\r\n         * approve() - function approves to a person to spend some tokens from \r\n         *           owner balance. \r\n         *\r\n         *  @param spender - person whom this right been granted.\r\n         *  @param value   - value to spend.\r\n         * \r\n         *  @return true in case of succes, otherwise failure\r\n         * \r\n         */\r\n        function approve(address spender, uint256 value) returns(bool success) {\r\n\r\n                // now spender can use balance in \r\n                // ammount of value from owner balance\r\n                allowed[msg.sender][spender] = value;\r\n\r\n                // rise event about the transaction\r\n                Approval(msg.sender, spender, value);\r\n\r\n                return true;\r\n        }\r\n\r\n        /**\r\n         *\r\n         * allowance() - constant function to check how mouch is \r\n         *               permited to spend to 3rd person from owner balance\r\n         *\r\n         *  @param owner   - owner of the balance\r\n         *  @param spender - permited to spend from this balance person \r\n         *  \r\n         *  @return - remaining right to spend \r\n         * \r\n         */\r\n        function allowance(address owner, address spender) constant returns(uint256 remaining) {\r\n                return allowed[owner][spender];\r\n        }\r\n\r\n}\r\n\r\ncontract LeviusDAO is StandardToken {\r\n\r\n    string public constant symbol = \"LeviusDAO\";\r\n    string public constant name = \"LeviusDAO\";\r\n\r\n    uint8 public constant decimals = 8;\r\n    uint DECIMAL_ZEROS = 10**8;\r\n\r\n    modifier onlyOwner { assert(msg.sender == owner); _; }\r\n\r\n    event BestCountTokens(uint _amount);\r\n    event BestWallet(address _address);\r\n\r\n    // Constructor\r\n    function LeviusDAO() {\r\n        totalSupply = 5000000000 * DECIMAL_ZEROS;\r\n        owner = msg.sender;\r\n        balances[msg.sender] = totalSupply;\r\n    }\r\n\r\n    function GetBestTokenCount(uint8 _num) returns (uint) {\r\n        assert(_num < 10);\r\n        BestCountTokens(best_count[_num]);\r\n        return best_count[_num];\r\n    }\r\n\r\n    function GetBestWalletAddress(uint8 _num) onlyOwner returns (address) {\r\n        assert(_num < 10);\r\n        BestWallet(best_wals[_num]);\r\n        return best_wals[_num];\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferWithoutChangeBest\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokens\",\"type\":\"uint256\"},{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"CheckBest\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_num\",\"type\":\"uint8\"}],\"name\":\"GetBestWalletAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_num\",\"type\":\"uint8\"}],\"name\":\"GetBestTokenCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"BestCountTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"BestWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"LeviusDAO","CompilerVersion":"v0.4.13+commit.fb4cb1a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://1ab212ae2a883bfa60a965fe18df9e3cbd4bb0064118d615c795830b7293ad1d"}]}