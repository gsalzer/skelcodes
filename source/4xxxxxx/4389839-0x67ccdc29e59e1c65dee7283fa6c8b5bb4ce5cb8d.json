{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.4.10;\r\n\r\n/*  ----------------------------------------------------------------------------------------\r\n\r\n    Dev:    \"Owned\" to ensure control of contracts\r\n\r\n            Identical to https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/ownership/Ownable.sol\r\n\r\n    ---------------------------------------------------------------------------------------- */\r\ncontract Owned {\r\n    address public owner;\r\n\r\n    function Owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) onlyOwner {\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n/*  ----------------------------------------------------------------------------------------\r\n\r\n    Dev:    SafeMath library\r\n\r\n            Identical to https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\r\n\r\n    ---------------------------------------------------------------------------------------- */\r\nlibrary SafeMath {\r\n  function safeMul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeDiv(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a); // Ensuring no negatives\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a && c>=b);\r\n    return c;\r\n  }\r\n}\r\n\r\n/*  ----------------------------------------------------------------------------------------\r\n\r\n    Dev:    ESG Asset Holder is called when the token \"burn\" function is called\r\n\r\n    Sum:    Locked to false so users cannot burn their tokens until the Asset Contract is\r\n            put in place with value.\r\n\r\n    ---------------------------------------------------------------------------------------- */\r\ncontract ESGAssetHolder {\r\n    \r\n    function burn(address _holder, uint _amount) returns (bool result) {\r\n\r\n        _holder = 0x0;                              // To avoid variable not used issue on deployment\r\n        _amount = 0;                                // To avoid variable not used issue on deployment\r\n        return false;\r\n    }\r\n}\r\n\r\n\r\n/*  ----------------------------------------------------------------------------------------\r\n\r\n    Dev:    The Esports Gold Token:  ERC20 standard token with MINT and BURN functions\r\n\r\n    Func:   Mint, Approve, Transfer, TransferFrom  \r\n\r\n    Note:   Mint function takes UNITS of tokens to mint as ICO event is set to have a minimum\r\n            contribution of 1 token. All other functions (transfer etc), the value to transfer\r\n            is the FULL DECIMAL value\r\n            The user is only ever presented with the latter option, therefore should avoid\r\n            any confusion.\r\n    ---------------------------------------------------------------------------------------- */\r\ncontract ESGToken is Owned {\r\n        \r\n    string public name = \"ESG Token\";               // Name of token\r\n    string public symbol = \"ESG\";                   // Token symbol\r\n    uint256 public decimals = 3;                    // Decimals for the token\r\n    uint256 public totalSupply;                   // Current supply of tokens\r\n    uint256 public supplyCap;                       // Hard cap on supply of tokens\r\n    address public ICOcontroller;                   // Controlling contract from ICO\r\n    address public timelockTokens;                  // Address for locked management tokens\r\n    bool public tokenParametersSet;                        // Ensure that parameters required are set\r\n    bool public controllerSet;                             // Ensure that ICO controller is set\r\n\r\n    mapping (address => uint256) public balanceOf;                      // Balances of addresses\r\n    mapping (address => mapping (address => uint)) public allowance;    // Allowances from addresses\r\n    mapping (address => bool) public frozenAccount;                     // Safety mechanism\r\n\r\n\r\n    modifier onlyControllerOrOwner() {            // Ensures that only contracts can manage key functions\r\n        require(msg.sender == ICOcontroller || msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Mint(address owner, uint amount);\r\n    event FrozenFunds(address target, bool frozen);\r\n    event Burn(address coinholder, uint amount);\r\n    \r\n    /*  ----------------------------------------------------------------------------------------\r\n\r\n    Dev:    Constructor\r\n\r\n    param:  Owner:  Address of owner\r\n            Name:   Esports Gold Token\r\n            Sym:    ESG_TKN\r\n            Dec:    3\r\n            Cap:    Hard coded cap to ensure excess tokens cannot be minted\r\n\r\n    Other parameters have been set up as a separate function to help lower initial gas deployment cost.\r\n\r\n    ---------------------------------------------------------------------------------------- */\r\n    function ESGToken() {\r\n        totalSupply = 0;                      // Starting supply is zero\r\n        supplyCap = 0;                          // Hard cap supply in Tokens set by ICO\r\n        tokenParametersSet = false;             // Ensure parameters are set\r\n        controllerSet = false;                  // Ensure controller is set\r\n    }\r\n\r\n    /*  ----------------------------------------------------------------------------------------\r\n\r\n    Dev:    Key parameters to setup for ICO event\r\n\r\n    Param:  _ico    Address of the ICO Event contract to ensure the ICO event can control\r\n                    the minting function\r\n    \r\n    ---------------------------------------------------------------------------------------- */\r\n    function setICOController(address _ico) onlyOwner {     // ICO event address is locked in\r\n        require(_ico != 0x0);\r\n        ICOcontroller = _ico;\r\n        controllerSet = true;\r\n    }\r\n\r\n\r\n    /*  ----------------------------------------------------------------------------------------\r\n    NEW\r\n    Dev:    Address for the timelock tokens to be held\r\n\r\n    Param:  _timelockAddr   Address of the timelock contract that will hold the locked tokens\r\n    \r\n    ---------------------------------------------------------------------------------------- */\r\n    function setParameters(address _timelockAddr) onlyOwner {\r\n        require(_timelockAddr != 0x0);\r\n\r\n        timelockTokens = _timelockAddr;\r\n\r\n        tokenParametersSet = true;\r\n    }\r\n\r\n    function parametersAreSet() constant returns (bool) {\r\n        return tokenParametersSet && controllerSet;\r\n    }\r\n\r\n    /*  ----------------------------------------------------------------------------------------\r\n\r\n    Dev:    Set the total number of Tokens that can be minted\r\n\r\n    Param:  _supplyCap  The number of tokens (in whole units) that can be minted. This number then\r\n                        gets increased by the decimal number\r\n   \r\n    ---------------------------------------------------------------------------------------- */\r\n    function setTokenCapInUnits(uint256 _supplyCap) onlyControllerOrOwner {   // Supply cap in UNITS\r\n        assert(_supplyCap > 0);\r\n        \r\n        supplyCap = SafeMath.safeMul(_supplyCap, (10**decimals));\r\n    }\r\n\r\n    /*  ----------------------------------------------------------------------------------------\r\n\r\n    Dev:    Mint the number of tokens for the timelock contract\r\n\r\n    Param:  _mMentTkns  Number of tokens in whole units that need to be locked into the Timelock\r\n    \r\n    ---------------------------------------------------------------------------------------- */\r\n    function mintLockedTokens(uint256 _mMentTkns) onlyControllerOrOwner {\r\n        assert(_mMentTkns > 0);\r\n        assert(tokenParametersSet);\r\n\r\n        mint(timelockTokens, _mMentTkns);  \r\n    }\r\n\r\n    /*  ----------------------------------------------------------------------------------------\r\n\r\n    Dev:    ERC20 protocols\r\n    \r\n    ---------------------------------------------------------------------------------------- */\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balanceOf[_owner];\r\n    }\r\n\r\n    /*  ----------------------------------------------------------------------------------------\r\n\r\n    Dev:    Mint ESG Tokens by controller\r\n\r\n    Control:            OnlyControllers. ICO event needs to be able to control the minting\r\n                        function\r\n\r\n    Param:  Address     Address for tokens to be minted to\r\n            Amount      Number of tokens to be minted (in whole UNITS. Min minting is 1 token)\r\n                        Minimum ETH contribution in ICO event is 0.01ETH at 100 tokens per ETH\r\n    \r\n    ---------------------------------------------------------------------------------------- */\r\n    function mint(address _address, uint _amount) onlyControllerOrOwner {\r\n        require(_address != 0x0);\r\n        uint256 amount = SafeMath.safeMul(_amount, (10**decimals));             // Tokens minted using unit parameter supplied\r\n\r\n        // Ensure that supplyCap is set and that new tokens don't breach cap\r\n        assert(supplyCap > 0 && amount > 0 && SafeMath.safeAdd(totalSupply, amount) <= supplyCap);\r\n        \r\n        balanceOf[_address] = SafeMath.safeAdd(balanceOf[_address], amount);    // Add tokens to address\r\n        totalSupply = SafeMath.safeAdd(totalSupply, amount);                // Add to supply\r\n        \r\n        Mint(_address, amount);\r\n        Transfer(0x0, _address, amount);\r\n    }\r\n    \r\n    /*  ----------------------------------------------------------------------------------------\r\n\r\n    Dev:    ERC20 standard transfer function\r\n\r\n    Param:  _to         Address to send to\r\n            _value      Number of tokens to be sent - in FULL decimal length\r\n    \r\n    Ref:    https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/BasicToken.sol\r\n    ---------------------------------------------------------------------------------------- */\r\n    function transfer(address _to, uint _value) returns (bool success) {\r\n        require(!frozenAccount[msg.sender]);        // Ensure account is not frozen\r\n\r\n        /* \r\n            Update balances from \"from\" and \"to\" addresses with the tokens transferred\r\n            safeSub method ensures that address sender has enough tokens to send\r\n        */\r\n        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);    \r\n        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                  \r\n        Transfer(msg.sender, _to, _value);\r\n        \r\n        return true;\r\n    }\r\n    \r\n    /*  ----------------------------------------------------------------------------------------\r\n\r\n    Dev:    ERC20 standard transferFrom function\r\n\r\n    Param:  _from       Address to send from\r\n            _to         Address to send to\r\n            Amount      Number of tokens to be sent - in FULL decimal length\r\n\r\n    ---------------------------------------------------------------------------------------- */\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {   \r\n        require(!frozenAccount[_from]);                         // Check account is not frozen\r\n        \r\n        /* \r\n            Ensure sender has been authorised to send the required number of tokens\r\n        */\r\n        if (allowance[_from][msg.sender] < _value)\r\n            return false;\r\n\r\n        /* \r\n            Update allowance of sender to reflect tokens sent\r\n        */\r\n        allowance[_from][msg.sender] = SafeMath.safeSub(allowance[_from][msg.sender], _value); \r\n\r\n        /* \r\n            Update balances from \"from\" and \"to\" addresses with the tokens transferred\r\n            safeSub method ensures that address sender has enough tokens to send\r\n        */\r\n        balanceOf[_from] = SafeMath.safeSub(balanceOf[_from], _value);\r\n        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);\r\n\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n    \r\n    /*  ----------------------------------------------------------------------------------------\r\n\r\n    Dev:    ERC20 standard approve function\r\n\r\n    Param:  _spender        Address of sender who is approved\r\n            _value          The number of tokens (full decimals) that are approved\r\n\r\n    ---------------------------------------------------------------------------------------- */\r\n    function approve(address _spender, uint256 _value)      // FULL DECIMALS OF TOKENS\r\n        returns (bool success)\r\n    {\r\n        require(!frozenAccount[msg.sender]);                // Check account is not frozen\r\n\r\n        /* Requiring the user to set to zero before resetting to nonzero */\r\n        if ((_value != 0) && (allowance[msg.sender][_spender] != 0)) {\r\n           return false;\r\n        }\r\n\r\n        allowance[msg.sender][_spender] = _value;\r\n        \r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /*  ----------------------------------------------------------------------------------------\r\n\r\n    Dev:    Function to check the amount of tokens that the owner has allowed the \"spender\" to\r\n            transfer\r\n\r\n    Param:  _owner          Address of the authoriser who owns the tokens\r\n            _spender        Address of sender who will be authorised to spend the tokens\r\n\r\n    ---------------------------------------------------------------------------------------- */\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return allowance[_owner][_spender];\r\n    }\r\n    \r\n    /*  ----------------------------------------------------------------------------------------\r\n\r\n    Dev:    As ESG is aiming to be a regulated betting operator. Regulatory hurdles may require\r\n            this function if an account on the betting platform, using the token, breaches\r\n            a regulatory requirement.\r\n\r\n            ESG can then engage with the account holder to get it unlocked\r\n\r\n            This does not stop the token accruing value from its share of the Asset Contract\r\n\r\n    Param:  _target         Address of account\r\n            _freeze         Boolean to lock/unlock account\r\n\r\n    Ref:    This is a replica of the code as per https://ethereum.org/token\r\n    ---------------------------------------------------------------------------------------- */\r\n    function freezeAccount(address target, bool freeze) onlyOwner {\r\n        frozenAccount[target] = freeze;\r\n        FrozenFunds(target, freeze);\r\n    }\r\n\r\n    /*  ----------------------------------------------------------------------------------------\r\n\r\n    Dev:    Burn function: User is able to burn their token for a share of the ESG Asset Contract\r\n\r\n    Note:   Deployed with the ESG Asset Contract set to false to ensure token holders cannot\r\n            accidentally burn their tokens for zero value\r\n\r\n    Param:  _amount         Number of tokens (full decimals) that should be burnt\r\n\r\n    Ref:    Based on the open source TokenCard Burn function. A copy can be found at\r\n            https://github.com/bokkypoobah/TokenCardICOAnalysis\r\n    ---------------------------------------------------------------------------------------- */\r\n    function burn(uint _amount) returns (bool result) {\r\n\r\n        if (_amount > balanceOf[msg.sender])\r\n            return false;       // If owner has enough to burn\r\n\r\n        /* \r\n            Remove tokens from circulation\r\n            Update sender's balance of tokens\r\n        */\r\n        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _amount);\r\n        totalSupply = SafeMath.safeSub(totalSupply, _amount);\r\n\r\n        // Call burn function\r\n        result = esgAssetHolder.burn(msg.sender, _amount);\r\n        require(result);\r\n\r\n        Burn(msg.sender, _amount);\r\n    }\r\n\r\n    /*  ----------------------------------------------------------------------------------------\r\n\r\n    Dev:    Section of the contract that links to the ESG Asset Contract\r\n\r\n    Note:   Deployed with the ESG Asset Contract set to false to ensure token holders cannot\r\n            accidentally burn their tokens for zero value\r\n\r\n    Param:  _amount         Number of tokens (full decimals) that should be burnt\r\n\r\n    Ref:    Based on the open source TokenCard Burn function. A copy can be found at\r\n            https://github.com/bokkypoobah/TokenCardICOAnalysis\r\n    ---------------------------------------------------------------------------------------- */\r\n\r\n    ESGAssetHolder esgAssetHolder;              // Holds the accumulated asset contract\r\n    bool lockedAssetHolder;                     // Will be locked to stop tokenholder to be upgraded\r\n\r\n    function lockAssetHolder() onlyOwner {      // Locked once deployed\r\n        lockedAssetHolder = true;\r\n    }\r\n\r\n    function setAssetHolder(address _assetAdress) onlyOwner {   // Used to lock in the Asset Contract\r\n        assert(!lockedAssetHolder);             // Check that we haven't locked the asset holder yet\r\n        esgAssetHolder = ESGAssetHolder(_assetAdress);\r\n    }    \r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"controllerSet\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ico\",\"type\":\"address\"}],\"name\":\"setICOController\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"parametersAreSet\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lockAssetHolder\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenParametersSet\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"result\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_timelockAddr\",\"type\":\"address\"}],\"name\":\"setParameters\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"supplyCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_mMentTkns\",\"type\":\"uint256\"}],\"name\":\"mintLockedTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_assetAdress\",\"type\":\"address\"}],\"name\":\"setAssetHolder\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"frozenAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_supplyCap\",\"type\":\"uint256\"}],\"name\":\"setTokenCapInUnits\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"freeze\",\"type\":\"bool\"}],\"name\":\"freezeAccount\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ICOcontroller\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timelockTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"FrozenFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"coinholder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"}]","ContractName":"ESGToken","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://9651feccf0f562624e1377e02235995cfd2669aeceb3727c972a32b37748ad98"}]}