{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n* This is the source code of the smart contract for the SOUL token, aka Soul Napkins.\r\n* Copyright 2017 and all rights reserved by the owner of the following Ethereum address:\r\n* 0x10E44C6bc685c4E4eABda326c211561d5367EEec\r\n*/\r\n\r\npragma solidity ^0.4.17;\r\n\r\n// ERC Token standard #20 Interface\r\n// https://github.com/ethereum/EIPs/issues/20\r\ncontract ERC20Interface {\r\n\r\n    // Token symbol\r\n    string public constant symbol = \"TBA\";\r\n\r\n    // Name of token\r\n    string public constant name =\"TBA\";\r\n\r\n    // Decimals of token\r\n    uint8 public constant decimals = 18;\r\n\r\n    // Total token supply\r\n    function totalSupply() public constant returns (uint256 supply);\r\n\r\n    // The balance of account with address _owner\r\n    function balanceOf(address _owner) public constant returns (uint256 balance);\r\n\r\n    // Send _value tokens to address _to\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n\r\n    // Send _value tokens from address _from to address _to\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\r\n    // If this function is called again it overwrites the current allowance with _value.\r\n    // this function is required for some DEX functionality\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n    // Returns the amount which _spender is still allowed to withdraw from _owner\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\r\n\r\n    // Triggered when tokens are transferred.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n    // Triggered whenever approve(address _spender, uint256 _value) is called.\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\n// Implementation of ERC20Interface\r\ncontract ERC20Token is ERC20Interface{\r\n\r\n    // account balances\r\n    mapping(address => uint256) balances;\r\n\r\n    // Owner of account approves the transfer of amount to another account\r\n    mapping(address => mapping (address => uint256)) allowed;\r\n\r\n    // Function to access acount balances\r\n    function balanceOf(address _owner) public constant returns (uint256) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    // Transfer the _amount from msg.sender to _to account\r\n    function transfer(address _to, uint256 _amount) public returns (bool) {\r\n        if (balances[msg.sender] >= _amount && _amount > 0\r\n                && balances[_to] + _amount > balances[_to]) {\r\n            balances[msg.sender] -= _amount;\r\n            balances[_to] += _amount;\r\n            Transfer(msg.sender, _to, _amount);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // Send _value amount of tokens from address _from to address _to\r\n    // The transferFrom method is used for a withdraw workflow, allowing contracts to send\r\n    // tokens on your behalf, for example to \"deposit\" to a contract address and/or to charge\r\n    // fees in sub-currencies; the command should fail unless the _from account has\r\n    // deliberately authorized the sender of the message via some mechanism; we propose\r\n    // these standardized APIs for approval:\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    ) public returns (bool) {\r\n        if (balances[_from] >= _amount\r\n            && allowed[_from][msg.sender] >= _amount && _amount > 0\r\n                && balances[_to] + _amount > balances[_to]) {\r\n            balances[_from] -= _amount;\r\n            allowed[_from][msg.sender] -= _amount;\r\n            balances[_to] += _amount;\r\n            Transfer(_from, _to, _amount);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\r\n    // If this function is called again it overwrites the current allowance with _value.\r\n    function approve(address _spender, uint256 _amount) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _amount;\r\n        Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n    // Function to specify how much _spender is allowed to transfer on _owner's behalf\r\n    function allowance(address _owner, address _spender) public constant returns (uint256) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n}\r\n\r\n\r\n// Token implementation that allows selling of souls and distribution of napkins\r\ncontract SoulToken is ERC20Token{\r\n\r\n    // The three letter symbol of token\r\n    string public constant symbol = \"SOUL\";\r\n\r\n    // Name of token\r\n    string public constant name = \"Soul Napkins\";\r\n\r\n    // 6 is a holy number (2*3) so there are 6 decimals\r\n    uint8 public constant decimals = 6;\r\n\r\n    // With 6 decimals, a single unit is 10**6\r\n    uint256 public constant unit = 1000000;\r\n\r\n    // fee to pay to transfer soul, 10% like the ecclesiastical tithe\r\n    uint8 public constant obol = 10;\r\n\r\n    // price per token, 100 napkins per Ether\r\n    uint256 public constant napkinPrice = 10 finney / unit;\r\n\r\n    // Total number of napkins available\r\n    // 144,000 (get it?)\r\n    uint256 constant totalSupply_ = 144000 * unit;\r\n\r\n    // mapping to keep the reason of the soul sale!\r\n    mapping(address => string) reasons;\r\n\r\n    // prices that people put up for their soul\r\n    mapping(address => uint256) soulPrices;\r\n\r\n    // who owns a particular soul\r\n    mapping(address => address) ownedBy;\r\n\r\n    // number of souls owned by someone\r\n    mapping(address => uint256) soulsOwned;\r\n\r\n    // book of souls, listing all souls on sale and sold\r\n    mapping(uint256 => address) soulBook;\r\n\r\n    // owner of the contract\r\n    address public owner;\r\n\r\n    // Address where soul obol is due to\r\n    address public charonsBoat;\r\n\r\n    // small fee to insert soul into soulbook\r\n    uint256 public bookingFee;\r\n\r\n    // souls for sale\r\n    uint256 public soulsForSale;\r\n\r\n    // souls already sold\r\n    uint256 public soulsSold;\r\n\r\n    // total amount of Wei collected by Charon\r\n    uint256 public totalObol;\r\n\r\n    // Logs a soul transfer\r\n    event SoulTransfer(address indexed _from, address indexed _to);\r\n\r\n    function SoulToken() public{\r\n        owner = msg.sender;\r\n        charonsBoat = msg.sender;\r\n        // fee for inserting into soulbook, unholy 13 finney\r\n        bookingFee = 13 finney;\r\n        soulsForSale = 0;\r\n        soulsSold = 0;\r\n        totalObol = 0;\r\n        // all napkins belong to the contract at first:\r\n        balances[this] = totalSupply_;\r\n        // 1111 napkins for the dev ;-)\r\n        payOutNapkins(1111 * unit);\r\n    }\r\n\r\n    // fallback function, Charon sells napkins as merchandise!\r\n    function () public payable {\r\n        uint256 amount;\r\n        uint256 checkedAmount;\r\n        // give away some napkins in return proportional to value\r\n        amount = msg.value / napkinPrice;\r\n        checkedAmount = checkAmount(amount);\r\n        // only payout napkins if there is the appropriate amount available\r\n        // else throw\r\n        require(amount == checkedAmount);\r\n        // forward money to Charon\r\n        payCharon(msg.value);\r\n        // finally payout napkins\r\n        payOutNapkins(checkedAmount);\r\n    }\r\n\r\n    // allows changing of the booking fee, note obol and token price are fixed and cannot change\r\n    function changeBookingFee(uint256 fee) public {\r\n        require(msg.sender == owner);\r\n        bookingFee = fee;\r\n    }\r\n\r\n    // changes Charon's boat, i.e. the address where the obol is paid to\r\n    function changeBoat(address newBoat) public{\r\n        require(msg.sender == owner);\r\n        charonsBoat = newBoat;\r\n    }\r\n\r\n    // total number of napkins distributed by Charon\r\n    function totalSupply() public constant returns (uint256){\r\n        return totalSupply_;\r\n    }\r\n\r\n    // returns the reason for the selling of one's soul\r\n    function soldSoulBecause(address noSoulMate) public constant returns(string){\r\n        return reasons[noSoulMate];\r\n    }\r\n\r\n    // returns the owner of a soul\r\n    function soulIsOwnedBy(address noSoulMate) public constant returns(address){\r\n        return ownedBy[noSoulMate];\r\n    }\r\n\r\n    // returns number of souls owned by someone\r\n    function ownsSouls(address soulOwner) public constant returns(uint256){\r\n        return soulsOwned[soulOwner];\r\n    }\r\n\r\n    // returns price of a soul\r\n    function soldSoulFor(address noSoulMate) public constant returns(uint256){\r\n        return soulPrices[noSoulMate];\r\n    }\r\n\r\n    // returns the nth entry in the soulbook\r\n    function soulBookPage(uint256 page) public constant returns(address){\r\n        return soulBook[page];\r\n    }\r\n\r\n    // sells your soul for a given price and a given reason!\r\n    function sellSoul(string reason, uint256 price) public payable{\r\n        uint256 charonsObol;\r\n        string storage has_reason = reasons[msg.sender];\r\n\r\n        // require that user gives a reason\r\n        require(bytes(reason).length > 0);\r\n\r\n        // require to pay bookingFee\r\n        require(msg.value >= bookingFee);\r\n\r\n        // you cannot give away your soul for free, at least Charon wants some share\r\n        charonsObol = price / obol;\r\n        require(charonsObol > 0);\r\n\r\n        // assert has not sold her or his soul, yet\r\n        require(bytes(has_reason).length == 0);\r\n        require(soulPrices[msg.sender] == 0);\r\n        require(ownedBy[msg.sender] == address(0));\r\n\r\n        // pay book keeping fee\r\n        payCharon(msg.value);\r\n\r\n        // store the reason forever on the blockchain\r\n        reasons[msg.sender] = reason;\r\n        // also the price is forever kept on the blockchain, so do not be too cheap\r\n        soulPrices[msg.sender] = price;\r\n        // and keep the soul in the soul book\r\n        soulBook[soulsForSale + soulsSold] = msg.sender;\r\n        soulsForSale += 1;\r\n    }\r\n\r\n    // buys msg.sender a soul and rewards him with tokens!\r\n    function buySoul(address noSoulMate) public payable returns(uint256 amount){\r\n        uint256 charonsObol;\r\n        uint256 price;\r\n\r\n        // you cannot buy an owned soul:\r\n        require(ownedBy[noSoulMate] == address(0));\r\n        // get the price of the soul\r\n        price = soulPrices[noSoulMate];\r\n        // Soul must be for sale\r\n        require(price > 0);\r\n        require(bytes(reasons[noSoulMate]).length > 0);\r\n        // Msg sender needs to pay the soul price\r\n        require(msg.value >= price);\r\n        charonsObol = msg.value / obol;\r\n\r\n        // check for wrap around\r\n        require(soulsOwned[msg.sender] + 1 > soulsOwned[msg.sender]);\r\n\r\n        // pay Charon\r\n        payCharon(charonsObol);\r\n        // pay the soul owner\r\n        noSoulMate.transfer(msg.value - charonsObol);\r\n\r\n        // Update the soul stats\r\n        soulsForSale -= 1;\r\n        soulsSold += 1;\r\n        // Increase the sender's balance by the appropriate amount of souls ;-)\r\n        soulsOwned[msg.sender] += 1;\r\n        ownedBy[noSoulMate] = msg.sender;\r\n        // log the transfer\r\n        SoulTransfer(noSoulMate, msg.sender);\r\n\r\n        // and give away napkins proportional to obol plus 1 bonus napkin ;-)\r\n        amount = charonsObol / napkinPrice + unit;\r\n        amount = checkAmount(amount);\r\n        if (amount > 0){\r\n            // only payout napkins if they are available\r\n            payOutNapkins(amount);\r\n        }\r\n\r\n        return amount;\r\n    }\r\n\r\n    // can transfer a soul to a different account, but beware you have to pay Charon again!\r\n    function transferSoul(address _to, address noSoulMate) public payable{\r\n        uint256 charonsObol;\r\n\r\n        // require correct ownership\r\n        require(ownedBy[noSoulMate] == msg.sender);\r\n        require(soulsOwned[_to] + 1 > soulsOwned[_to]);\r\n        // require transfer fee is payed again\r\n        charonsObol = soulPrices[noSoulMate] / obol;\r\n        require(msg.value >= charonsObol);\r\n        // pay Charon\r\n        payCharon(msg.value);\r\n        // transfer the soul\r\n        soulsOwned[msg.sender] -= 1;\r\n        soulsOwned[_to] += 1;\r\n        ownedBy[noSoulMate] = _to;\r\n\r\n        // Log the soul transfer\r\n        SoulTransfer(msg.sender, _to);\r\n    }\r\n\r\n    // logs and pays charon fees\r\n    function payCharon(uint256 obolValue) internal{\r\n        totalObol += obolValue;\r\n        charonsBoat.transfer(obolValue);\r\n    }\r\n\r\n    // checks if napkins are still available and adjusts amount accordingly\r\n    function checkAmount(uint256 amount) internal constant returns(uint256 checkedAmount){\r\n\r\n        if (amount > balances[this]){\r\n            checkedAmount = balances[this];\r\n        } else {\r\n            checkedAmount = amount;\r\n        }\r\n\r\n        return checkedAmount;\r\n    }\r\n\r\n    // transfers napkins to people\r\n    function payOutNapkins(uint256 amount) internal{\r\n        // check for amount and wrap around\r\n        require(amount > 0);\r\n        // yeah some sanity check\r\n        require(amount <= balances[this]);\r\n\r\n        // send napkins from contract to msg.sender\r\n        balances[this] -= amount;\r\n        balances[msg.sender] += amount;\r\n        // log napkin transfer\r\n        Transfer(this, msg.sender, amount);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"noSoulMate\",\"type\":\"address\"}],\"name\":\"soulIsOwnedBy\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"soulOwner\",\"type\":\"address\"}],\"name\":\"ownsSouls\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"soulsForSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"soulsSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalObol\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"napkinPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"charonsBoat\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"changeBookingFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"noSoulMate\",\"type\":\"address\"}],\"name\":\"transferSoul\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bookingFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"noSoulMate\",\"type\":\"address\"}],\"name\":\"buySoul\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"noSoulMate\",\"type\":\"address\"}],\"name\":\"soldSoulBecause\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"page\",\"type\":\"uint256\"}],\"name\":\"soulBookPage\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"reason\",\"type\":\"string\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"sellSoul\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"noSoulMate\",\"type\":\"address\"}],\"name\":\"soldSoulFor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newBoat\",\"type\":\"address\"}],\"name\":\"changeBoat\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"obol\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"SoulTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"SoulToken","CompilerVersion":"v0.4.17+commit.bdeb9e52","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://8ae5e58b78d75ae4ad58d7467363ad20e9b8a539106b699ae79bca65ad42724d"}]}