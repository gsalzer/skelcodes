{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n// File: zeppelin-solidity/contracts/math/Math.sol\r\n\r\n/**\r\n * @title Math\r\n * @dev Assorted math operations\r\n */\r\n\r\nlibrary Math {\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/StandingOrder.sol\r\n\r\n/**\r\n * @title Standing order\r\n * @dev Lifecycle of a standing order:\r\n *  - the payment amount per interval is set at construction time and can not be changed afterwards\r\n *  - the payee is set by the owner and can not be changed after creation\r\n *  - at <startTime> (unix timestamp) the first payment is due\r\n *  - every <intervall> seconds the next payment is due\r\n *  - the owner can add funds to the order contract at any time\r\n *  - the owner can withdraw only funds that do not (yet) belong to the payee\r\n *  - the owner can terminate a standingorder anytime. Termination results in:\r\n *    - No further funding being allowed\r\n *    - order marked as \"terminated\" and not being displayed anymore in owner UI\r\n *    - as long as there are uncollected funds entitled to the payee, it is still displayed in payee UI\r\n *    - the payee can still collect funds owned to him\r\n *\r\n *   * Terminology *\r\n *   \"withdraw\" -> performed by owner - transfer funds stored in contract back to owner\r\n *   \"collect\"  -> performed by payee - transfer entitled funds from contract to payee\r\n *\r\n *   * How does a payment work? *\r\n *   Since a contract can not trigger a payment by itself, it provides the method \"collectFunds\" for the payee.\r\n *   The payee can always query the contract to determine how many funds he is entitled to collect.\r\n *   The payee can call \"collectFunds\" to initiate transfer of entitled funds to his address.\r\n */\r\ncontract StandingOrder {\r\n\r\n    using SafeMath for uint;\r\n    using Math for uint;\r\n\r\n    address public owner;        /** The owner of this order */\r\n    address public payee;        /** The payee is the receiver of funds */\r\n    uint public startTime;       /** Date and time (unix timestamp - seconds since 1970) when first payment can be claimed by payee */\r\n    uint public paymentInterval; /** Interval for payments (Unit: seconds) */\r\n    uint public paymentAmount;   /** How much can payee claim per period (Unit: Wei) */\r\n    uint public claimedFunds;    /** How much funds have been claimed already (Unit: Wei) */\r\n    string public ownerLabel;    /** Label (set by contract owner) */\r\n    bool public isTerminated;    /** Marks order as terminated */\r\n    uint public terminationTime; /** Date and time (unix timestamp - seconds since 1970) when order terminated */\r\n\r\n    modifier onlyPayee() {\r\n        require(msg.sender == payee);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /** Event triggered when payee collects funds */\r\n    event Collect(uint amount);\r\n    /** Event triggered when contract gets funded */\r\n    event Fund(uint amount);\r\n    /** Event triggered when owner withdraws funds */\r\n    event Withdraw(uint amount);\r\n\r\n    /**\r\n     * Constructor\r\n     * @param _owner The owner of the contract\r\n     * @param _payee The payee - the account that can collect payments from this contract\r\n     * @param _paymentInterval Interval for payments, unit: seconds\r\n     * @param _paymentAmount The amount payee can claim per period, unit: wei\r\n     * @param _startTime Date and time (unix timestamp - seconds since 1970) when first payment can be claimed by payee\r\n     * @param _label Label for contract, e.g \"rent\" or \"weekly paycheck\"\r\n     */\r\n    function StandingOrder(\r\n        address _owner,\r\n        address _payee,\r\n        uint _paymentInterval,\r\n        uint _paymentAmount,\r\n        uint _startTime,\r\n        string _label\r\n    )\r\n        payable\r\n    {\r\n        // Sanity check parameters\r\n        require(_paymentInterval > 0);\r\n        require(_paymentAmount > 0);\r\n        // Following check is not exact for unicode strings, but here i just want to make sure that some label is provided\r\n        // See https://ethereum.stackexchange.com/questions/13862/is-it-possible-to-check-string-variables-length-inside-the-contract/13886\r\n        require(bytes(_label).length > 2);\r\n\r\n        // Set owner to _owner, as msg.sender is the StandingOrderFactory contract\r\n        owner = _owner;\r\n\r\n        payee = _payee;\r\n        paymentInterval = _paymentInterval;\r\n        paymentAmount = _paymentAmount;\r\n        ownerLabel = _label;\r\n        startTime = _startTime;\r\n        isTerminated = false;\r\n    }\r\n\r\n    /**\r\n     * Fallback function.\r\n     * Allows adding funds to existing order. Will throw in case the order is terminated!\r\n     */\r\n    function() payable {\r\n        if (isTerminated) {\r\n            // adding funds not allowed for terminated orders\r\n            revert();\r\n        }\r\n        // Log Fund event\r\n        Fund(msg.value);\r\n    }\r\n\r\n    /**\r\n     * Determine how much funds payee is entitled to collect\r\n     * Note that this might be more than actual funds available!\r\n     * @return Number of wei that payee is entitled to collect\r\n     */\r\n    function getEntitledFunds() constant returns (uint) {\r\n        // First check if the contract startTime has been reached at all\r\n        if (now < startTime) {\r\n            // startTime not yet reached\r\n            return 0;\r\n        }\r\n\r\n        // startTime has been reached, so add first payment\r\n        uint entitledAmount = paymentAmount;\r\n\r\n        // Determine endTime for calculation. If order has been terminated -> terminationTime, otherwise current time\r\n        uint endTime = isTerminated ? terminationTime : now;\r\n\r\n        // calculate number of complete intervals since startTime\r\n        uint runtime = endTime.sub(startTime);\r\n        uint completeIntervals = runtime.div(paymentInterval); // Division always truncates, so implicitly rounding down here.\r\n        entitledAmount = entitledAmount.add(completeIntervals.mul(paymentAmount));\r\n\r\n        // subtract already collected funds\r\n        return entitledAmount.sub(claimedFunds);\r\n    }\r\n\r\n    /**\r\n     * Determine how much funds are available for payee to collect\r\n     * This can be less than the entitled amount if the contract does not have enough funds to cover the due payments,\r\n     * in other words: The owner has not put enough funds into the contract.\r\n     * @return Number of wei that payee can collect\r\n     */\r\n    function getUnclaimedFunds() constant returns (uint) {\r\n        // don't return more than available balance\r\n        return getEntitledFunds().min256(this.balance);\r\n    }\r\n\r\n    /**\r\n     * Determine how much funds are still owned by owner (not yet reserved for payee)\r\n     * Note that this can be negative in case contract is not funded enough to cover entitled amount for payee!\r\n     * @return number of wei belonging owner, negative if contract is missing funds to cover payments\r\n     */\r\n    function getOwnerFunds() constant returns (int) {\r\n        // Conversion from unsigned int to int will produce unexpected results only for very large\r\n        // numbers (2^255 and greater). This is about 5.7e+58 ether.\r\n        // -> There will be no situation when the contract balance (this.balance) will hit this limit\r\n        // -> getEntitledFunds() might end up hitting this limit when the contract creator INTENTIONALLY sets\r\n        //    any combination of absurdly high payment rate, low interval or a startTime way in the past.\r\n        //    Being entitled to more than 5.7e+58 ether obviously will never be an expected usecase\r\n        // Therefor the conversion can be considered safe here.\r\n        return int256(this.balance) - int256(getEntitledFunds());\r\n    }\r\n\r\n    /**\r\n     * Collect payment\r\n     * Can only be called by payee. This will transfer all available funds (see getUnclaimedFunds) to payee\r\n     * @return amount that has been transferred!\r\n     */\r\n    function collectFunds() onlyPayee returns(uint) {\r\n        uint amount = getUnclaimedFunds();\r\n        if (amount <= 0) {\r\n            // nothing to collect :-(\r\n            revert();\r\n        }\r\n\r\n        // keep track of collected funds\r\n        claimedFunds = claimedFunds.add(amount);\r\n\r\n        // create log entry\r\n        Collect(amount);\r\n\r\n        // initiate transfer of unclaimed funds to payee\r\n        payee.transfer(amount);\r\n\r\n        return amount;\r\n    }\r\n\r\n    /**\r\n     * Withdraw requested amount back to owner.\r\n     * Only funds not (yet) reserved for payee can be withdrawn. So it is not possible for the owner\r\n     * to withdraw unclaimed funds - They can only be claimed by payee!\r\n     * Withdrawing funds does not terminate the order, at any time owner can fund it again!\r\n     * @param amount Number of wei owner wants to withdraw\r\n     */\r\n    function WithdrawOwnerFunds(uint amount) onlyOwner {\r\n        int intOwnerFunds = getOwnerFunds(); // this might be negative in case of underfunded contract!\r\n        if (intOwnerFunds <= 0) {\r\n            // nothing available to withdraw :-(\r\n            revert();\r\n        }\r\n        // conversion int -> uint is safe here as I'm checking <= 0 above!\r\n        uint256 ownerFunds = uint256(intOwnerFunds);\r\n\r\n        if (amount > ownerFunds) {\r\n            // Trying to withdraw more than available!\r\n            revert();\r\n        }\r\n\r\n        // Log Withdraw event\r\n        Withdraw(amount);\r\n\r\n        owner.transfer(amount);\r\n    }\r\n\r\n    /**\r\n     * Terminate order\r\n     * Marks the order as terminated.\r\n     * Can only be executed if no ownerfunds are left\r\n     */\r\n    function Terminate() onlyOwner {\r\n        assert(getOwnerFunds() <= 0);\r\n        terminationTime = now;\r\n        isTerminated = true;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title StandingOrder factory\r\n */\r\ncontract StandingOrderFactory {\r\n    // keep track who issued standing orders\r\n    mapping (address => StandingOrder[]) public standingOrdersByOwner;\r\n    // keep track of payees of standing orders\r\n    mapping (address => StandingOrder[]) public standingOrdersByPayee;\r\n\r\n    // Events\r\n    event LogOrderCreated(\r\n        address orderAddress,\r\n        address indexed owner,\r\n        address indexed payee\r\n    );\r\n\r\n    /**\r\n     * Create a new standing order\r\n     * The owner of the new order will be the address that called this function (msg.sender)\r\n     * @param _payee The payee - the account that can collect payments from this contract\r\n     * @param _paymentInterval Interval for payments, unit: seconds\r\n     * @param _paymentAmount The amount payee can claim per period, unit: wei\r\n     * @param _startTime Date and time (unix timestamp - seconds since 1970) when first payment can be claimed by payee\r\n     * @param _label Label for contract, e.g \"rent\" or \"weekly paycheck\"\r\n     * @return Address of new created standingOrder contract\r\n     */\r\n    function createStandingOrder(address _payee, uint _paymentAmount, uint _paymentInterval, uint _startTime, string _label) returns (StandingOrder) {\r\n        StandingOrder so = new StandingOrder(msg.sender, _payee, _paymentInterval, _paymentAmount, _startTime, _label);\r\n        standingOrdersByOwner[msg.sender].push(so);\r\n        standingOrdersByPayee[_payee].push(so);\r\n        LogOrderCreated(so, msg.sender, _payee);\r\n        return so;\r\n    }\r\n\r\n    /**\r\n     * Determine how many orders are owned by caller (msg.sender)\r\n     * @return Number of orders\r\n     */\r\n    function getNumOrdersByOwner() constant returns (uint) {\r\n        return standingOrdersByOwner[msg.sender].length;\r\n    }\r\n\r\n    /**\r\n     * Get order by index from the Owner mapping\r\n     * @param index Index of order\r\n     * @return standing order address\r\n     */\r\n    function getOwnOrderByIndex(uint index) constant returns (StandingOrder) {\r\n        return standingOrdersByOwner[msg.sender][index];\r\n    }\r\n\r\n    /**\r\n     * Determine how many orders are paying to caller (msg.sender)\r\n     * @return Number of orders\r\n     */\r\n    function getNumOrdersByPayee() constant returns (uint) {\r\n        return standingOrdersByPayee[msg.sender].length;\r\n    }\r\n\r\n    /**\r\n     * Get order by index from the Payee mapping\r\n     * @param index Index of order\r\n     * @return standing order address\r\n     */\r\n    function getPaidOrderByIndex(uint index) constant returns (StandingOrder) {\r\n        return standingOrdersByPayee[msg.sender][index];\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"standingOrdersByPayee\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getOwnOrderByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"standingOrdersByOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_payee\",\"type\":\"address\"},{\"name\":\"_paymentAmount\",\"type\":\"uint256\"},{\"name\":\"_paymentInterval\",\"type\":\"uint256\"},{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_label\",\"type\":\"string\"}],\"name\":\"createStandingOrder\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumOrdersByOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getPaidOrderByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumOrdersByPayee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"orderAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"payee\",\"type\":\"address\"}],\"name\":\"LogOrderCreated\",\"type\":\"event\"}]","ContractName":"StandingOrderFactory","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://c9a4ef9fe673caecea8ddeee122d6eb50fef633f68f91ee1d2e382ebbf52bee9"}]}