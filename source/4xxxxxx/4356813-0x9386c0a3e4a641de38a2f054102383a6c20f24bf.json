{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\ncontract Ownable {\r\n\r\n    address public owner;\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    function Ownable() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    address newOwner;\r\n    function transferOwnership(address _newOwner) onlyOwner {\r\n        if (_newOwner != address(0)) {\r\n            newOwner = _newOwner;\r\n        }\r\n    }\r\n\r\n    function acceptOwnership() {\r\n        if (msg.sender == newOwner) {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n}\r\n\r\ncontract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\r\n\r\ncontract ERC20 is Ownable {\r\n    /* Public variables of the token */\r\n    string public standard;\r\n\r\n    string public name;\r\n\r\n    string public symbol;\r\n\r\n    uint8 public decimals;\r\n\r\n    uint256 public initialSupply;\r\n\r\n    bool public locked;\r\n\r\n    uint256 public creationBlock;\r\n\r\n    mapping (address => uint256) public balances;\r\n\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n    /* This generates a public event on the blockchain that will notify clients */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    modifier onlyPayloadSize(uint numwords) {\r\n        assert(msg.data.length == numwords * 32 + 4);\r\n        _;\r\n    }\r\n\r\n    /* Initializes contract with initial supply tokens to the creator of the contract */\r\n    function ERC20(\r\n    uint256 _initialSupply,\r\n    string tokenName,\r\n    uint8 decimalUnits,\r\n    string tokenSymbol,\r\n    bool transferAllSupplyToOwner,\r\n    bool _locked\r\n    ) {\r\n        standard = 'ERC20 0.1';\r\n\r\n        initialSupply = _initialSupply;\r\n\r\n        if (transferAllSupplyToOwner) {\r\n            setBalance(msg.sender, initialSupply);\r\n        }\r\n        else {\r\n            setBalance(this, initialSupply);\r\n        }\r\n\r\n        name = tokenName;\r\n        // Set the name for display purposes\r\n        symbol = tokenSymbol;\r\n        // Set the symbol for display purposes\r\n        decimals = decimalUnits;\r\n        // Amount of decimals for display purposes\r\n        locked = _locked;\r\n        creationBlock = block.number;\r\n    }\r\n\r\n    /* internal balances */\r\n\r\n    function setBalance(address holder, uint256 amount) internal {\r\n        balances[holder] = amount;\r\n    }\r\n\r\n    function transferInternal(address _from, address _to, uint256 value) internal returns (bool success) {\r\n        if (value == 0) {\r\n            return true;\r\n        }\r\n\r\n        if (balances[_from] < value) {\r\n            return false;\r\n        }\r\n\r\n        if (balances[_to] + value <= balances[_to]) {\r\n            return false;\r\n        }\r\n\r\n        setBalance(_from, balances[_from] - value);\r\n        setBalance(_to, balances[_to] + value);\r\n\r\n        Transfer(_from, _to, value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /* public methods */\r\n    function totalSupply() returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n\r\n    function balanceOf(address _address) returns (uint256) {\r\n        return balances[_address];\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) onlyPayloadSize(2) returns (bool) {\r\n        require(locked == false);\r\n\r\n        bool status = transferInternal(msg.sender, _to, _value);\r\n\r\n        require(status == true);\r\n\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        if(locked) {\r\n            return false;\r\n        }\r\n\r\n        allowance[msg.sender][_spender] = _value;\r\n\r\n        return true;\r\n    }\r\n\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        if (locked) {\r\n            return false;\r\n        }\r\n\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        if (locked) {\r\n            return false;\r\n        }\r\n\r\n        if (allowance[_from][msg.sender] < _value) {\r\n            return false;\r\n        }\r\n\r\n        bool _success = transferInternal(_from, _to, _value);\r\n\r\n        if (_success) {\r\n            allowance[_from][msg.sender] -= _value;\r\n        }\r\n\r\n        return _success;\r\n    }\r\n\r\n}\r\n\r\ncontract MintingERC20 is ERC20 {\r\n\r\n    mapping (address => bool) public minters;\r\n\r\n    uint256 public maxSupply;\r\n\r\n    function MintingERC20(\r\n    uint256 _initialSupply,\r\n    uint256 _maxSupply,\r\n    string _tokenName,\r\n    uint8 _decimals,\r\n    string _symbol,\r\n    bool _transferAllSupplyToOwner,\r\n    bool _locked\r\n    )\r\n    ERC20(_initialSupply, _tokenName, _decimals, _symbol, _transferAllSupplyToOwner, _locked)\r\n\r\n    {\r\n        standard = \"MintingERC20 0.1\";\r\n        minters[msg.sender] = true;\r\n        maxSupply = _maxSupply;\r\n    }\r\n\r\n\r\n    function addMinter(address _newMinter) onlyOwner {\r\n        minters[_newMinter] = true;\r\n    }\r\n\r\n\r\n    function removeMinter(address _minter) onlyOwner {\r\n        minters[_minter] = false;\r\n    }\r\n\r\n\r\n    function mint(address _addr, uint256 _amount) onlyMinters returns (uint256) {\r\n        if (locked == true) {\r\n            return uint256(0);\r\n        }\r\n\r\n        if (_amount == uint256(0)) {\r\n            return uint256(0);\r\n        }\r\n        if (initialSupply + _amount <= initialSupply){\r\n            return uint256(0);\r\n        }\r\n        if (initialSupply + _amount > maxSupply) {\r\n            return uint256(0);\r\n        }\r\n\r\n        initialSupply += _amount;\r\n        balances[_addr] += _amount;\r\n        Transfer(this, _addr, _amount);\r\n        return _amount;\r\n    }\r\n\r\n\r\n    modifier onlyMinters () {\r\n        require(true == minters[msg.sender]);\r\n        _;\r\n    }\r\n}\r\n\r\ncontract Lamden is MintingERC20 {\r\n\r\n\r\n    uint8 public decimals = 18;\r\n\r\n    string public tokenName = \"Lamden Tau\";\r\n\r\n    string public tokenSymbol = \"TAU\";\r\n\r\n    uint256 public  maxSupply = 500 * 10 ** 6 * uint(10) ** decimals; // 500,000,000\r\n\r\n    // We block token transfers till ICO end.\r\n    bool public transferFrozen = true;\r\n\r\n    function Lamden(\r\n    uint256 initialSupply,\r\n    bool _locked\r\n    ) MintingERC20(initialSupply, maxSupply, tokenName, decimals, tokenSymbol, false, _locked) {\r\n        standard = 'Lamden 0.1';\r\n    }\r\n\r\n    function setLocked(bool _locked) onlyOwner {\r\n        locked = _locked;\r\n    }\r\n\r\n    // Allow token transfer.\r\n    function freezing(bool _transferFrozen) onlyOwner {\r\n        transferFrozen = _transferFrozen;\r\n    }\r\n\r\n    // ERC20 functions\r\n    // =========================\r\n\r\n    function transfer(address _to, uint _value) returns (bool) {\r\n        require(!transferFrozen);\r\n        return super.transfer(_to, _value);\r\n\r\n    }\r\n\r\n    // should  not have approve/transferFrom\r\n    function approve(address, uint) returns (bool success)  {\r\n        require(false);\r\n        return false;\r\n        //        super.approve(_spender, _value);\r\n    }\r\n\r\n    function approveAndCall(address, uint256, bytes) returns (bool success) {\r\n        require(false);\r\n        return false;\r\n    }\r\n\r\n    function transferFrom(address, address, uint)  returns (bool success) {\r\n        require(false);\r\n        return false;\r\n        //        super.transferFrom(_from, _to, _value);\r\n    }\r\n}\r\n\r\ncontract LamdenTokenAllocation is Ownable {\r\n\r\n    Lamden public tau;\r\n\r\n    uint256 public constant LAMDEN_DECIMALS = 10 ** 18;\r\n\r\n    uint256 allocatedTokens = 0;\r\n\r\n    Allocation[] allocations;\r\n\r\n    struct Allocation {\r\n    address _address;\r\n    uint256 amount;\r\n    }\r\n\r\n\r\n    function LamdenTokenAllocation(\r\n    address _tau,\r\n    address[] addresses\r\n    ){\r\n        require(uint8(addresses.length) == uint8(14));\r\n        allocations.push(Allocation(addresses[0], 20000000 * LAMDEN_DECIMALS)); //Stu\r\n        allocations.push(Allocation(addresses[1], 12500000 * LAMDEN_DECIMALS)); //Nick\r\n        allocations.push(Allocation(addresses[2], 8750000 * LAMDEN_DECIMALS)); //James\r\n        allocations.push(Allocation(addresses[3], 8750000 * LAMDEN_DECIMALS)); //Mario\r\n        allocations.push(Allocation(addresses[4], 250000 * LAMDEN_DECIMALS));     // Advisor\r\n        allocations.push(Allocation(addresses[5], 250000 * LAMDEN_DECIMALS));  // Advisor\r\n        allocations.push(Allocation(addresses[6], 250000 * LAMDEN_DECIMALS));  // Advisor\r\n        allocations.push(Allocation(addresses[7], 250000 * LAMDEN_DECIMALS));  // Advisor\r\n        allocations.push(Allocation(addresses[8], 250000 * LAMDEN_DECIMALS));  // Advisor\r\n        allocations.push(Allocation(addresses[9], 250000 * LAMDEN_DECIMALS));  // Advisor\r\n        allocations.push(Allocation(addresses[10], 250000 * LAMDEN_DECIMALS));  // Advisor\r\n        allocations.push(Allocation(addresses[11], 250000 * LAMDEN_DECIMALS));  // Advisor\r\n        allocations.push(Allocation(addresses[12], 48000000 * LAMDEN_DECIMALS));  // enterpriseCaseStudies\r\n        allocations.push(Allocation(addresses[13], 50000000  * LAMDEN_DECIMALS));  // AKA INNOVATION FUND\r\n        tau = Lamden(_tau);\r\n    }\r\n\r\n    function allocateTokens(){\r\n        require(uint8(allocations.length) == uint8(14));\r\n        require(address(tau) != 0x0);\r\n        require(allocatedTokens == 0);\r\n        for (uint8 i = 0; i < allocations.length; i++) {\r\n            Allocation storage allocation = allocations[i];\r\n            uint256 mintedAmount = tau.mint(allocation._address, allocation.amount);\r\n            require(mintedAmount == allocation.amount);\r\n            allocatedTokens += allocation.amount;\r\n        }\r\n    }\r\n\r\n    function setTau(address _tau) onlyOwner {\r\n        tau = Lamden(_tau);\r\n    }\r\n}\r\n\r\n\r\ncontract LamdenPhases is Ownable {\r\n\r\n    uint256 public constant LAMDEN_DECIMALS = 10 ** 18;\r\n\r\n    uint256 public soldTokens;\r\n\r\n    uint256 public collectedEthers;\r\n\r\n    uint256 todayCollectedEthers;\r\n\r\n    uint256 icoInitialThresholds;\r\n\r\n    uint256 currentDay;\r\n\r\n    Phase[] public phases;\r\n\r\n    Lamden public tau;\r\n\r\n    uint8 currentPhase;\r\n\r\n    address etherHolder;\r\n\r\n    address investor = 0x3669ad54675E94e14196528786645c858b8391F1;\r\n\r\n    mapping(address => uint256) alreadyContributed;\r\n\r\n    struct Phase {\r\n    uint256 price;\r\n    uint256 maxAmount;\r\n    uint256 since;\r\n    uint256 till;\r\n    uint256 soldTokens;\r\n    uint256 collectedEthers;\r\n    bool isFinished;\r\n    mapping (address => bool) whitelist;\r\n    }\r\n\r\n    function LamdenPhases(\r\n    address _etherHolder,\r\n    address _tau,\r\n    uint256 _tokenPreIcoPrice,\r\n    uint256 _preIcoSince,\r\n    uint256 _preIcoTill,\r\n    uint256 preIcoMaxAmount, // 1,805,067.01326114 +   53,280,090\r\n    uint256 _tokenIcoPrice,\r\n    uint256 _icoSince,\r\n    uint256 _icoTill,\r\n    uint256 icoMaxAmount,\r\n    uint256 icoThresholds\r\n    )\r\n    {\r\n        phases.push(Phase(_tokenPreIcoPrice, preIcoMaxAmount, _preIcoSince, _preIcoTill, 0, 0, false));\r\n        phases.push(Phase(_tokenIcoPrice, icoMaxAmount, _icoSince, _icoTill, 0, 0, false));\r\n        etherHolder = _etherHolder;\r\n        icoInitialThresholds = icoThresholds;\r\n        tau = Lamden(_tau);\r\n    }\r\n\r\n    // call add minter from TAU token after contract deploying\r\n    function sendTokensToInvestor() onlyOwner {\r\n        uint256 mintedAmount = mintInternal(investor, (1805067013261140000000000));\r\n        require(mintedAmount == uint256(1805067013261140000000000));\r\n    }\r\n\r\n    function getIcoTokensAmount(uint256 value, uint256 time, address _address) returns (uint256) {\r\n        if (value == 0) {\r\n            return uint256(0);\r\n        }\r\n        uint256 amount = 0;\r\n\r\n        for (uint8 i = 0; i < phases.length; i++) {\r\n            Phase storage phase = phases[i];\r\n\r\n            if (phase.whitelist[_address] == false) {\r\n                continue;\r\n            }\r\n\t\t\t\t\t\t\r\n            if(phase.isFinished){\r\n                continue;\r\n            }\r\n\r\n            if (phase.since > time) {\r\n                continue;\r\n            }\r\n\r\n            if (phase.till < time) {\r\n                continue;\r\n            }\r\n            currentPhase = i;\r\n\r\n            // should we be multiplying by 10 ** 18???\r\n            // 1 eth = 1000000000000000000 / \r\n            uint256 phaseAmount = value * LAMDEN_DECIMALS / phase.price;\r\n            \r\n            amount += phaseAmount;\r\n\r\n            if (phase.maxAmount < amount + soldTokens) {\r\n                return uint256(0);\r\n            }\r\n            //            phase.soldTokens += amount;\r\n            phase.collectedEthers += value;\r\n        }\r\n        return amount;\r\n    }\r\n\r\n    function() payable {\r\n        bool status = buy(msg.sender, msg.value);\r\n        require(status == true);\r\n    }\r\n\r\n    function setInternalFinished(uint8 phaseId, bool _finished) internal returns (bool){\r\n        if (phases.length < phaseId) {\r\n            return false;\r\n        }\r\n\r\n        Phase storage phase = phases[phaseId];\r\n\r\n        if (phase.isFinished == true) {\r\n            return true;\r\n        }\r\n\r\n        phase.isFinished = _finished;\r\n\r\n        return true;\r\n    }\r\n\r\n    function setFinished(uint8 phaseId, bool _finished) onlyOwner returns (bool){\r\n        return setInternalFinished(phaseId, _finished);\r\n    }\r\n\r\n    function buy(address _address, uint256 _value) internal returns (bool) {\r\n        if (_value == 0) {\r\n            return false;\r\n        }\r\n\r\n        if (phases.length < currentPhase) {\r\n            return false;\r\n        }\r\n        Phase storage icoPhase = phases[1];\r\n\r\n        if (icoPhase.since <= now) {\r\n\r\n            currentPhase = 1;\r\n            uint256 daysInterval = (now - icoPhase.since) / uint256(86400);\r\n            uint256 todayMaxEthers = icoInitialThresholds;\r\n\r\n            if (daysInterval != currentDay) {\r\n                currentDay = daysInterval;\r\n                todayCollectedEthers = 0;\r\n            }\r\n\r\n            todayMaxEthers = icoInitialThresholds * (2 ** daysInterval);\r\n\r\n            if(alreadyContributed[_address] + _value > todayMaxEthers) {\r\n                return false;\r\n            }\r\n\r\n            alreadyContributed[_address] += _value;\r\n        }\r\n\r\n        uint256 tokenAmount = getIcoTokensAmount(_value, now, _address);\r\n\r\n        if (tokenAmount == 0) {\r\n            return false;\r\n        }\r\n\r\n        uint256 mintedAmount = mintInternal(_address, tokenAmount);\r\n        require(mintedAmount == tokenAmount);\r\n\r\n        collectedEthers += _value;\r\n\r\n        Phase storage phase = phases[currentPhase];\r\n        if (soldTokens == phase.maxAmount) {\r\n            setInternalFinished(currentPhase, true);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function setTau(address _tau) onlyOwner {\r\n        tau = Lamden(_tau);\r\n    }\r\n\r\n    function setPhase(uint8 phaseId, uint256 since, uint256 till, uint256 price) onlyOwner returns (bool) {\r\n        if (phases.length <= phaseId) {\r\n            return false;\r\n        }\r\n\r\n        if (price == 0) {\r\n            return false;\r\n        }\r\n        Phase storage phase = phases[phaseId];\r\n\r\n        if (phase.isFinished == true) {\r\n            return false;\r\n        }\r\n        phase.since = since;\r\n        phase.till = till;\r\n\r\n        phase.price = price;\r\n\r\n        return true;\r\n    }\r\n\r\n    function transferEthers() onlyOwner {\r\n        require(etherHolder != 0x0);\r\n        etherHolder.transfer(this.balance);\r\n    }\r\n\r\n    function addToWhitelist(uint8 phaseId, address _address) onlyOwner {\r\n\r\n        require(phases.length > phaseId);\r\n\r\n        Phase storage phase = phases[phaseId];\r\n\r\n        phase.whitelist[_address] = true;\r\n\r\n    }\r\n\r\n    function removeFromWhitelist(uint8 phaseId, address _address) onlyOwner {\r\n\r\n        require(phases.length > phaseId);\r\n\r\n        Phase storage phase = phases[phaseId];\r\n\r\n        phase.whitelist[_address] = false;\r\n\r\n    }\r\n\r\n    function mint(address _address, uint256 tokenAmount) onlyOwner returns (uint256) {\r\n        return mintInternal(_address, tokenAmount);\r\n    }\r\n\r\n    function mintInternal(address _address, uint256 tokenAmount) internal returns (uint256) {\r\n        require(address(tau) != 0x0);\r\n        uint256 mintedAmount = tau.mint(_address, tokenAmount);\r\n        require(mintedAmount == tokenAmount);\r\n\r\n        require(phases.length > currentPhase);\r\n        Phase storage phase = phases[currentPhase];\r\n        phase.soldTokens += tokenAmount;\r\n        soldTokens += tokenAmount;\r\n        return tokenAmount;\r\n    }\r\n\r\n    function getPhase(uint8 phaseId) returns (uint256, uint256, uint256, uint256, uint256, uint256, bool)\r\n    {\r\n\r\n        require(phases.length > phaseId);\r\n\r\n        Phase storage phase = phases[phaseId];\r\n\r\n        return (phase.price, phase.maxAmount, phase.since, phase.till, phase.soldTokens, phase.collectedEthers, phase.isFinished);\r\n\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"collectedEthers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"phaseId\",\"type\":\"uint8\"},{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"removeFromWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"phases\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"maxAmount\",\"type\":\"uint256\"},{\"name\":\"since\",\"type\":\"uint256\"},{\"name\":\"till\",\"type\":\"uint256\"},{\"name\":\"soldTokens\",\"type\":\"uint256\"},{\"name\":\"collectedEthers\",\"type\":\"uint256\"},{\"name\":\"isFinished\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sendTokensToInvestor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"phaseId\",\"type\":\"uint8\"},{\"name\":\"since\",\"type\":\"uint256\"},{\"name\":\"till\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"setPhase\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"phaseId\",\"type\":\"uint8\"},{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"addToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"soldTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"phaseId\",\"type\":\"uint8\"},{\"name\":\"_finished\",\"type\":\"bool\"}],\"name\":\"setFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tau\",\"type\":\"address\"}],\"name\":\"setTau\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LAMDEN_DECIMALS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tau\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"transferEthers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"time\",\"type\":\"uint256\"},{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getIcoTokensAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"phaseId\",\"type\":\"uint8\"}],\"name\":\"getPhase\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_etherHolder\",\"type\":\"address\"},{\"name\":\"_tau\",\"type\":\"address\"},{\"name\":\"_tokenPreIcoPrice\",\"type\":\"uint256\"},{\"name\":\"_preIcoSince\",\"type\":\"uint256\"},{\"name\":\"_preIcoTill\",\"type\":\"uint256\"},{\"name\":\"preIcoMaxAmount\",\"type\":\"uint256\"},{\"name\":\"_tokenIcoPrice\",\"type\":\"uint256\"},{\"name\":\"_icoSince\",\"type\":\"uint256\"},{\"name\":\"_icoTill\",\"type\":\"uint256\"},{\"name\":\"icoMaxAmount\",\"type\":\"uint256\"},{\"name\":\"icoThresholds\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"LamdenPhases","CompilerVersion":"v0.4.17+commit.bdeb9e52","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000009c38c7e22cb20b055e008775617224d0ec25c91f00000000000000000000000055100b6e3e1cc3018881a4a68edf229a80bac94400000000000000000000000000000000000000000000000000011c80490ff5370000000000000000000000000000000000000000000000000000000059dd5f000000000000000000000000000000000000000000000000000000000059f90e800000000000000000000000000000000000000000002d90bc59a3e405078800000000000000000000000000000000000000000000000000000001ce96a5d10d17000000000000000000000000000000000000000000000000000000005a0cd500000000000000000000000000000000000000000000000000000000005a346200000000000000000000000000000000000000000000f3f2a5ab18493a3853a000000000000000000000000000000000000000000000000001a055690d9db80000","Library":"","SwarmSource":"bzzr://763499f99be8bb3d5481e7643f30ea2aa92b7c674f78fae7ac714222890900ca"}]}