{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\n/**\r\n * @title IDXM Contract. IDEX Membership Token contract.\r\n *\r\n * @author Ray Pulver, ray@auroradao.com\r\n */\r\n\r\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }\r\n\r\ncontract SafeMath {\r\n  function safeMul(uint256 a, uint256 b) returns (uint256) {\r\n    uint256 c = a * b;\r\n    require(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n  function safeSub(uint256 a, uint256 b) returns (uint256) {\r\n    require(b <= a);\r\n    return a - b;\r\n  }\r\n  function safeAdd(uint256 a, uint256 b) returns (uint256) {\r\n    uint c = a + b;\r\n    require(c >= a && c >= b);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract Owned {\r\n  address public owner;\r\n  function Owned() {\r\n    owner = msg.sender;\r\n  }\r\n  function setOwner(address _owner) returns (bool success) {\r\n    owner = _owner;\r\n    return true;\r\n  }\r\n  modifier onlyOwner {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n}\r\n\r\ncontract IDXM is Owned, SafeMath {\r\n  uint8 public decimals = 8;\r\n  bytes32 public standard = 'Token 0.1';\r\n  bytes32 public name = 'IDEX Membership';\r\n  bytes32 public symbol = 'IDXM';\r\n  uint256 public totalSupply;\r\n\r\n  event Approval(address indexed from, address indexed spender, uint256 amount);\r\n\r\n  mapping (address => uint256) public balanceOf;\r\n  mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  uint256 public baseFeeDivisor;\r\n  uint256 public feeDivisor;\r\n  uint256 public singleIDXMQty;\r\n\r\n  function () external {\r\n    throw;\r\n  }\r\n\r\n  uint8 public feeDecimals = 8;\r\n\r\n  struct Validity {\r\n    uint256 last;\r\n    uint256 ts;\r\n  }\r\n\r\n  mapping (address => Validity) public validAfter;\r\n  uint256 public mustHoldFor = 604800;\r\n  mapping (address => uint256) public exportFee;\r\n\r\n  /**\r\n   * Constructor.\r\n   *\r\n   */\r\n  function IDXM() {\r\n    totalSupply = 200000000000;\r\n    balanceOf[msg.sender] = totalSupply;\r\n    exportFee[0x00000000000000000000000000000000000000ff] = 100000000;\r\n    precalculate();\r\n  }\r\n\r\n  bool public balancesLocked = false;\r\n\r\n  function uploadBalances(address[] addresses, uint256[] balances) onlyOwner {\r\n    require(!balancesLocked);\r\n    require(addresses.length == balances.length);\r\n    uint256 sum;\r\n    for (uint256 i = 0; i < uint256(addresses.length); i++) {\r\n      sum = safeAdd(sum, safeSub(balances[i], balanceOf[addresses[i]]));\r\n      balanceOf[addresses[i]] = balances[i];\r\n    }\r\n    balanceOf[owner] = safeSub(balanceOf[owner], sum);\r\n  }\r\n\r\n  function lockBalances() onlyOwner {\r\n    balancesLocked = true;\r\n  }\r\n\r\n  /**\r\n   * @notice Transfer `_amount` from `msg.sender.address()` to `_to`.\r\n   *\r\n   * @param _to Address that will receive.\r\n   * @param _amount Amount to be transferred.\r\n   */\r\n  function transfer(address _to, uint256 _amount) returns (bool success) {\r\n    require(!locked);\r\n    require(balanceOf[msg.sender] >= _amount);\r\n    require(balanceOf[_to] + _amount >= balanceOf[_to]);\r\n    balanceOf[msg.sender] -= _amount;\r\n    uint256 preBalance = balanceOf[_to];\r\n    balanceOf[_to] += _amount;\r\n    bool alreadyMax = preBalance >= singleIDXMQty;\r\n    if (!alreadyMax) {\r\n      if (now >= validAfter[_to].ts + mustHoldFor) validAfter[_to].last = preBalance;\r\n      validAfter[_to].ts = now;\r\n    }\r\n    if (validAfter[msg.sender].last > balanceOf[msg.sender]) validAfter[msg.sender].last = balanceOf[msg.sender];\r\n    Transfer(msg.sender, _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Transfer `_amount` from `_from` to `_to`.\r\n   *\r\n   * @param _from Origin address\r\n   * @param _to Address that will receive\r\n   * @param _amount Amount to be transferred.\r\n   * @return result of the method call\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _amount) returns (bool success) {\r\n    require(!locked);\r\n    require(balanceOf[_from] >= _amount);\r\n    require(balanceOf[_to] + _amount >= balanceOf[_to]);\r\n    require(_amount <= allowance[_from][msg.sender]);\r\n    balanceOf[_from] -= _amount;\r\n    uint256 preBalance = balanceOf[_to];\r\n    balanceOf[_to] += _amount;\r\n    allowance[_from][msg.sender] -= _amount;\r\n    bool alreadyMax = preBalance >= singleIDXMQty;\r\n    if (!alreadyMax) {\r\n      if (now >= validAfter[_to].ts + mustHoldFor) validAfter[_to].last = preBalance;\r\n      validAfter[_to].ts = now;\r\n    }\r\n    if (validAfter[_from].last > balanceOf[_from]) validAfter[_from].last = balanceOf[_from];\r\n    Transfer(_from, _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Approve spender `_spender` to transfer `_amount` from `msg.sender.address()`\r\n   *\r\n   * @param _spender Address that receives the cheque\r\n   * @param _amount Amount on the cheque\r\n   * @param _extraData Consequential contract to be executed by spender in same transcation.\r\n   * @return result of the method call\r\n   */\r\n  function approveAndCall(address _spender, uint256 _amount, bytes _extraData) returns (bool success) {\r\n    tokenRecipient spender = tokenRecipient(_spender);\r\n    if (approve(_spender, _amount)) {\r\n      spender.receiveApproval(msg.sender, _amount, this, _extraData);\r\n      return true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Approve spender `_spender` to transfer `_amount` from `msg.sender.address()`\r\n   *\r\n   * @param _spender Address that receives the cheque\r\n   * @param _amount Amount on the cheque\r\n   * @return result of the method call\r\n   */\r\n  function approve(address _spender, uint256 _amount) returns (bool success) {\r\n    require(!locked);\r\n    allowance[msg.sender][_spender] = _amount;\r\n    Approval(msg.sender, _spender, _amount);\r\n    return true;\r\n  }\r\n\r\n  function setExportFee(address addr, uint256 fee) onlyOwner {\r\n    require(addr != 0x00000000000000000000000000000000000000ff);\r\n    exportFee[addr] = fee;\r\n  }\r\n\r\n  function setHoldingPeriod(uint256 ts) onlyOwner {\r\n    mustHoldFor = ts;\r\n  }\r\n\r\n\r\n  /* --------------- fee calculation method ---------------- */\r\n\r\n  /**\r\n   * @notice 'Returns the fee for a transfer from `from` to `to` on an amount `amount`.\r\n   *\r\n   * Fee's consist of a possible\r\n   *    - import fee on transfers to an address\r\n   *    - export fee on transfers from an address\r\n   * IDXM ownership on an address\r\n   *    - reduces fee on a transfer from this address to an import fee-ed address\r\n   *    - reduces the fee on a transfer to this address from an export fee-ed address\r\n   * IDXM discount does not work for addresses that have an import fee or export fee set up against them.\r\n   *\r\n   * IDXM discount goes up to 100%\r\n   *\r\n   * @param from From address\r\n   * @param to To address\r\n   * @param amount Amount for which fee needs to be calculated.\r\n   *\r\n   */\r\n  function feeFor(address from, address to, uint256 amount) constant external returns (uint256 value) {\r\n    uint256 fee = exportFee[from];\r\n    if (fee == 0) return 0;\r\n    uint256 amountHeld;\r\n    if (balanceOf[to] != 0) {\r\n      if (validAfter[to].ts + mustHoldFor < now) amountHeld = balanceOf[to];\r\n      else amountHeld = validAfter[to].last;\r\n      if (amountHeld >= singleIDXMQty) return 0;\r\n      return amount*fee*(singleIDXMQty - amountHeld) / feeDivisor;\r\n    } else return amount*fee / baseFeeDivisor;\r\n  }\r\n  \r\n  bool public locked = true;\r\n\r\n  function unlockToken() onlyOwner {\r\n    locked = false;\r\n  }\r\n\r\n  function precalculate() internal returns (bool success) {\r\n    baseFeeDivisor = pow10(1, feeDecimals);\r\n    feeDivisor = pow10(1, feeDecimals + decimals);\r\n    singleIDXMQty = pow10(1, decimals);\r\n  }\r\n  function div10(uint256 a, uint8 b) internal returns (uint256 result) {\r\n    for (uint8 i = 0; i < b; i++) {\r\n      a /= 10;\r\n    }\r\n    return a;\r\n  }\r\n  function pow10(uint256 a, uint8 b) internal returns (uint256 result) {\r\n    for (uint8 i = 0; i < b; i++) {\r\n      a *= 10;\r\n    }\r\n    return a;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unlockToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balancesLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"validAfter\",\"outputs\":[{\"name\":\"last\",\"type\":\"uint256\"},{\"name\":\"ts\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"standard\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lockBalances\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeDivisor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeSub\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setExportFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"singleIDXMQty\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"feeFor\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeDecimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"locked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeMul\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ts\",\"type\":\"uint256\"}],\"name\":\"setHoldingPeriod\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"exportFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addresses\",\"type\":\"address[]\"},{\"name\":\"balances\",\"type\":\"uint256[]\"}],\"name\":\"uploadBalances\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mustHoldFor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeAdd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"baseFeeDivisor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"IDXM","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://4227a2c7dc88966b19f381595b1f6cbe0bc5a477ac23f81d377b0b4867806b44"}]}