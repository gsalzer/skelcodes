{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.6;\r\n\r\ncontract SafeMath {\r\n    function mul(uint a, uint b) internal returns (uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint a, uint b) internal returns (uint) {\r\n        assert(b > 0);\r\n        uint c = a / b;\r\n        assert(a == b * c + a % b);\r\n        return c;\r\n    }\r\n\r\n    function sub(uint a, uint b) internal returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint a, uint b) internal returns (uint) {\r\n        uint c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract TokenController {\r\n    function proxyPayment(address _owner) payable returns (bool);\r\n\r\n    function onTransfer(address _from, address _to, uint _amount) returns (bool);\r\n\r\n    function onApprove(address _owner, address _spender, uint _amount)\r\n    returns (bool);\r\n}\r\n\r\n\r\ncontract Controlled {\r\n    modifier onlyController {if (msg.sender != controller) throw;\r\n        _;}\r\n\r\n    address public controller;\r\n\r\n    function Controlled() {controller = msg.sender;}\r\n\r\n    function changeController(address _newController) onlyController {\r\n        controller = _newController;\r\n    }\r\n}\r\n\r\n\r\ncontract ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 _amount, address _token, bytes _data);\r\n}\r\n\r\n\r\ncontract ShineCoinToken is Controlled {\r\n    string public name;\r\n    uint8 public decimals;\r\n    string public symbol;\r\n    string public version = 'SHINE_0.1';\r\n\r\n    struct Checkpoint {\r\n        uint128 fromBlock;\r\n        uint128 value;\r\n    }\r\n\r\n    ShineCoinToken public parentToken;\r\n\r\n    address public frozenReserveTeamRecipient;\r\n\r\n    uint public parentSnapShotBlock;\r\n\r\n    uint public creationBlock;\r\n\r\n    // Periods\r\n    uint public firstRewardPeriodEndBlock;\r\n\r\n    uint public secondRewardPeriodEndBlock;\r\n\r\n    uint public thirdRewardPeriodEndBlock;\r\n\r\n    uint public finalRewardPeriodEndBlock;\r\n\r\n    // Loos\r\n    uint public firstLoos;\r\n\r\n    uint public secondLoos;\r\n\r\n    uint public thirdLoos;\r\n\r\n    uint public finalLoos;\r\n\r\n\r\n    // Percents\r\n    uint public firstRewardPeriodPercent;\r\n\r\n    uint public secondRewardPeriodPercent;\r\n\r\n    uint public thirdRewardPeriodPercent;\r\n\r\n    uint public finalRewardPeriodPercent;\r\n\r\n    // Unfreeze team wallet for transfers\r\n    uint public unfreezeTeamRecepientBlock;\r\n\r\n    mapping (address => Checkpoint[]) balances;\r\n\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    Checkpoint[] totalSupplyHistory;\r\n\r\n    bool public transfersEnabled;\r\n\r\n    ShineCoinTokenFactory public tokenFactory;\r\n\r\n    function ShineCoinToken(\r\n        address _tokenFactory,\r\n        address _parentToken,\r\n        uint _parentSnapShotBlock,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol,\r\n        bool _transfersEnabled\r\n    ) {\r\n        tokenFactory = ShineCoinTokenFactory(_tokenFactory);\r\n        name = _tokenName;\r\n        decimals = _decimalUnits;\r\n        symbol = _tokenSymbol;\r\n        parentToken = ShineCoinToken(_parentToken);\r\n        parentSnapShotBlock = _parentSnapShotBlock;\r\n        transfersEnabled = _transfersEnabled;\r\n        creationBlock = block.number;\r\n        unfreezeTeamRecepientBlock = block.number + ((396 * 24 * 3600) / 18); // 396 days\r\n\r\n        firstRewardPeriodEndBlock = creationBlock + ((121 * 24 * 3600) / 18); // 121 days\r\n        secondRewardPeriodEndBlock = creationBlock + ((181 * 24 * 3600) / 18); // 181 days\r\n        thirdRewardPeriodEndBlock = creationBlock + ((211 * 24 * 3600) / 18); // 211 days\r\n        finalRewardPeriodEndBlock = creationBlock + ((760 * 24 * 3600) / 18); // 2 years\r\n\r\n        firstRewardPeriodPercent = 29;\r\n        secondRewardPeriodPercent = 23;\r\n        thirdRewardPeriodPercent = 18;\r\n        finalRewardPeriodPercent = 12;\r\n\r\n        firstLoos = ((15 * 24 * 3600) / 18); // 15 days;\r\n        secondLoos = ((10 * 24 * 3600) / 18); // 10 days;\r\n        thirdLoos = ((5 * 24 * 3600) / 18); // 5 days;\r\n        finalLoos = ((1 * 24 * 3600) / 18); // 1 days;\r\n    }\r\n\r\n    function changeReserveTeamRecepient(address _newReserveTeamRecipient) onlyController returns (bool) {\r\n        frozenReserveTeamRecipient = _newReserveTeamRecipient;\r\n        return true;\r\n    }\r\n\r\n    ///////////////////\r\n    // ERC20 Methods\r\n    ///////////////////\r\n\r\n    function transfer(address _to, uint256 _amount) returns (bool success) {\r\n        if (!transfersEnabled) throw;\r\n        if ((address(msg.sender) == frozenReserveTeamRecipient) && (block.number < unfreezeTeamRecepientBlock)) throw;\r\n        if ((_to == frozenReserveTeamRecipient) && (block.number < unfreezeTeamRecepientBlock)) throw;\r\n        return doTransfer(msg.sender, _to, _amount);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _amount) returns (bool success) {\r\n        if (msg.sender != controller) {\r\n            if (!transfersEnabled) throw;\r\n\r\n            if (allowed[_from][msg.sender] < _amount) return false;\r\n            allowed[_from][msg.sender] -= _amount;\r\n        }\r\n        return doTransfer(_from, _to, _amount);\r\n    }\r\n\r\n    function doTransfer(address _from, address _to, uint _amount) internal returns (bool) {\r\n\r\n        if (_amount == 0) {\r\n            return true;\r\n        }\r\n\r\n        if (parentSnapShotBlock >= block.number) throw;\r\n\r\n        if ((_to == 0) || (_to == address(this))) throw;\r\n\r\n        var previousBalanceFrom = balanceOfAt(_from, block.number);\r\n        if (previousBalanceFrom < _amount) {\r\n            return false;\r\n        }\r\n\r\n        if (isContract(controller)) {\r\n            if (!TokenController(controller).onTransfer(_from, _to, _amount))\r\n            throw;\r\n        }\r\n\r\n        Checkpoint[] checkpoints = balances[_from];\r\n        uint lastBlock = checkpoints[checkpoints.length - 1].fromBlock;\r\n        uint blocksFromLastBlock = block.number - lastBlock;\r\n        uint rewardAmount = 0;\r\n\r\n        if (block.number <= firstRewardPeriodEndBlock) {\r\n            if (blocksFromLastBlock > firstLoos) {\r\n                rewardAmount = previousBalanceFrom * firstRewardPeriodPercent * blocksFromLastBlock;\r\n            }\r\n        }\r\n        else if (block.number <= secondRewardPeriodEndBlock) {\r\n            if (blocksFromLastBlock > secondLoos) {\r\n                if (lastBlock < firstRewardPeriodEndBlock) {\r\n                    rewardAmount = previousBalanceFrom * firstRewardPeriodPercent * (firstRewardPeriodEndBlock - lastBlock) + previousBalanceFrom * secondRewardPeriodPercent * (secondRewardPeriodEndBlock - block.number);\r\n                }\r\n                else {\r\n                    rewardAmount = previousBalanceFrom * secondRewardPeriodPercent * blocksFromLastBlock;\r\n                }\r\n            }\r\n        }\r\n        else if (block.number <= thirdRewardPeriodEndBlock) {\r\n            if (blocksFromLastBlock > thirdLoos) {\r\n                if (lastBlock < firstRewardPeriodEndBlock) {\r\n                    rewardAmount = previousBalanceFrom * firstRewardPeriodPercent * (firstRewardPeriodEndBlock - lastBlock) + previousBalanceFrom * secondRewardPeriodPercent * (thirdRewardPeriodEndBlock - secondRewardPeriodEndBlock) + previousBalanceFrom * thirdRewardPeriodPercent * (thirdRewardPeriodEndBlock - block.number);\r\n                }\r\n                else if (lastBlock < secondRewardPeriodEndBlock) {\r\n                    rewardAmount = previousBalanceFrom * secondRewardPeriodPercent * (secondRewardPeriodEndBlock - lastBlock) + previousBalanceFrom * thirdRewardPeriodPercent * (thirdRewardPeriodEndBlock - block.number);\r\n                }\r\n                else {\r\n                    rewardAmount = previousBalanceFrom * thirdRewardPeriodPercent * blocksFromLastBlock;\r\n                }\r\n            }\r\n        }\r\n        else if (block.number <= finalRewardPeriodEndBlock) {\r\n            if (blocksFromLastBlock > finalLoos) {\r\n                if (lastBlock < firstRewardPeriodEndBlock) {\r\n                    rewardAmount = previousBalanceFrom * firstRewardPeriodPercent * (firstRewardPeriodEndBlock - lastBlock) + previousBalanceFrom * secondRewardPeriodPercent * (thirdRewardPeriodEndBlock - secondRewardPeriodEndBlock) + previousBalanceFrom * thirdRewardPeriodPercent * (finalRewardPeriodEndBlock - thirdRewardPeriodEndBlock) + previousBalanceFrom * finalRewardPeriodPercent * (finalRewardPeriodEndBlock - block.number);\r\n                }\r\n                else if (lastBlock < secondRewardPeriodEndBlock) {\r\n                    rewardAmount = previousBalanceFrom * secondRewardPeriodPercent * (secondRewardPeriodEndBlock - lastBlock) + previousBalanceFrom * thirdRewardPeriodPercent * (finalRewardPeriodEndBlock - thirdRewardPeriodEndBlock) + previousBalanceFrom * finalRewardPeriodPercent * (finalRewardPeriodEndBlock - block.number);\r\n                }\r\n                else if (lastBlock < secondRewardPeriodEndBlock) {\r\n                    rewardAmount = previousBalanceFrom * thirdRewardPeriodPercent * (finalRewardPeriodEndBlock - lastBlock) + previousBalanceFrom * finalRewardPeriodPercent * (finalRewardPeriodEndBlock - block.number);\r\n                }\r\n                else {\r\n                    rewardAmount = previousBalanceFrom * finalRewardPeriodPercent * blocksFromLastBlock;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if (blocksFromLastBlock > finalLoos) {\r\n                if (lastBlock < firstRewardPeriodEndBlock) {\r\n                    rewardAmount = previousBalanceFrom * firstRewardPeriodPercent * (firstRewardPeriodEndBlock - lastBlock) + previousBalanceFrom * secondRewardPeriodPercent * (thirdRewardPeriodEndBlock - secondRewardPeriodEndBlock) + previousBalanceFrom * thirdRewardPeriodPercent * (finalRewardPeriodEndBlock - thirdRewardPeriodEndBlock) + previousBalanceFrom * finalRewardPeriodPercent * (finalRewardPeriodEndBlock - block.number);\r\n                }\r\n                else if (lastBlock < secondRewardPeriodEndBlock) {\r\n                    rewardAmount = previousBalanceFrom * secondRewardPeriodPercent * (secondRewardPeriodEndBlock - lastBlock) + previousBalanceFrom * thirdRewardPeriodPercent * (finalRewardPeriodEndBlock - thirdRewardPeriodEndBlock) + previousBalanceFrom * finalRewardPeriodPercent * (finalRewardPeriodEndBlock - block.number);\r\n                }\r\n                else if (lastBlock < secondRewardPeriodEndBlock) {\r\n                    rewardAmount = previousBalanceFrom * thirdRewardPeriodPercent * (finalRewardPeriodEndBlock - lastBlock) + previousBalanceFrom * finalRewardPeriodPercent * (finalRewardPeriodEndBlock - block.number);\r\n                }\r\n                else {\r\n                    rewardAmount = previousBalanceFrom * finalRewardPeriodPercent * (finalRewardPeriodEndBlock - thirdRewardPeriodEndBlock);\r\n                }\r\n            }\r\n        }\r\n\r\n        rewardAmount = rewardAmount / 10000;\r\n        uint curTotalSupply = 0;\r\n\r\n        updateValueAtNow(balances[_from], previousBalanceFrom - _amount + rewardAmount);\r\n\r\n        // UPDATE TOTAL\r\n        if (rewardAmount > 0) {\r\n            curTotalSupply = getValueAt(totalSupplyHistory, block.number);\r\n            if (curTotalSupply + rewardAmount < curTotalSupply) throw; // Check for overflow\r\n            updateValueAtNow(totalSupplyHistory, curTotalSupply + rewardAmount);\r\n        }\r\n\r\n        rewardAmount = 0;\r\n\r\n        var previousBalanceTo = balanceOfAt(_to, block.number);\r\n        if (previousBalanceTo + _amount < previousBalanceTo) throw;\r\n\r\n        checkpoints = balances[_to];\r\n        if (checkpoints.length > 0) {\r\n            lastBlock = checkpoints[checkpoints.length - 1].fromBlock;\r\n            blocksFromLastBlock = block.number - lastBlock;\r\n\r\n            if (_amount >= (previousBalanceTo / 3)) {\r\n                if (blocksFromLastBlock > finalLoos) {\r\n\r\n                    if (block.number <= firstRewardPeriodEndBlock) {\r\n                        rewardAmount = previousBalanceFrom * firstRewardPeriodPercent * blocksFromLastBlock;\r\n                    }\r\n                    else if (block.number <= secondRewardPeriodEndBlock) {\r\n\r\n                        if (lastBlock < firstRewardPeriodEndBlock) {\r\n                            rewardAmount = previousBalanceFrom * firstRewardPeriodPercent * (firstRewardPeriodEndBlock - lastBlock) + previousBalanceFrom * secondRewardPeriodPercent * (secondRewardPeriodEndBlock - block.number);\r\n                        }\r\n                        else {\r\n                            rewardAmount = previousBalanceFrom * secondRewardPeriodPercent * blocksFromLastBlock;\r\n                        }\r\n\r\n                    }\r\n                    else if (block.number <= thirdRewardPeriodEndBlock) {\r\n\r\n                        if (lastBlock < firstRewardPeriodEndBlock) {\r\n                            rewardAmount = previousBalanceFrom * firstRewardPeriodPercent * (firstRewardPeriodEndBlock - lastBlock) + previousBalanceFrom * secondRewardPeriodPercent * (thirdRewardPeriodEndBlock - secondRewardPeriodEndBlock) + previousBalanceFrom * thirdRewardPeriodPercent * (thirdRewardPeriodEndBlock - block.number);\r\n                        }\r\n                        else if (lastBlock < secondRewardPeriodEndBlock) {\r\n                            rewardAmount = previousBalanceFrom * secondRewardPeriodPercent * (secondRewardPeriodEndBlock - lastBlock) + previousBalanceFrom * thirdRewardPeriodPercent * (thirdRewardPeriodEndBlock - block.number);\r\n                        }\r\n                        else {\r\n                            rewardAmount = previousBalanceFrom * thirdRewardPeriodPercent * blocksFromLastBlock;\r\n                        }\r\n\r\n                    }\r\n                    else if (block.number <= finalRewardPeriodEndBlock) {\r\n\r\n                        if (lastBlock < firstRewardPeriodEndBlock) {\r\n                            rewardAmount = previousBalanceFrom * firstRewardPeriodPercent * (firstRewardPeriodEndBlock - lastBlock) + previousBalanceFrom * secondRewardPeriodPercent * (thirdRewardPeriodEndBlock - secondRewardPeriodEndBlock) + previousBalanceFrom * thirdRewardPeriodPercent * (finalRewardPeriodEndBlock - thirdRewardPeriodEndBlock) + previousBalanceFrom * finalRewardPeriodPercent * (finalRewardPeriodEndBlock - block.number);\r\n                        }\r\n                        else if (lastBlock < secondRewardPeriodEndBlock) {\r\n                            rewardAmount = previousBalanceFrom * secondRewardPeriodPercent * (secondRewardPeriodEndBlock - lastBlock) + previousBalanceFrom * thirdRewardPeriodPercent * (finalRewardPeriodEndBlock - thirdRewardPeriodEndBlock) + previousBalanceFrom * finalRewardPeriodPercent * (finalRewardPeriodEndBlock - block.number);\r\n                        }\r\n                        else if (lastBlock < secondRewardPeriodEndBlock) {\r\n                            rewardAmount = previousBalanceFrom * thirdRewardPeriodPercent * (finalRewardPeriodEndBlock - lastBlock) + previousBalanceFrom * finalRewardPeriodPercent * (finalRewardPeriodEndBlock - block.number);\r\n                        }\r\n                        else {\r\n                            rewardAmount = previousBalanceFrom * finalRewardPeriodPercent * blocksFromLastBlock;\r\n                        }\r\n\r\n                    }\r\n                    else {\r\n\r\n                        if (lastBlock < firstRewardPeriodEndBlock) {\r\n                            rewardAmount = previousBalanceFrom * firstRewardPeriodPercent * (firstRewardPeriodEndBlock - lastBlock) + previousBalanceFrom * secondRewardPeriodPercent * (thirdRewardPeriodEndBlock - secondRewardPeriodEndBlock) + previousBalanceFrom * thirdRewardPeriodPercent * (finalRewardPeriodEndBlock - thirdRewardPeriodEndBlock) + previousBalanceFrom * finalRewardPeriodPercent * (finalRewardPeriodEndBlock - block.number);\r\n                        }\r\n                        else if (lastBlock < secondRewardPeriodEndBlock) {\r\n                            rewardAmount = previousBalanceFrom * secondRewardPeriodPercent * (secondRewardPeriodEndBlock - lastBlock) + previousBalanceFrom * thirdRewardPeriodPercent * (finalRewardPeriodEndBlock - thirdRewardPeriodEndBlock) + previousBalanceFrom * finalRewardPeriodPercent * (finalRewardPeriodEndBlock - block.number);\r\n                        }\r\n                        else if (lastBlock < secondRewardPeriodEndBlock) {\r\n                            rewardAmount = previousBalanceFrom * thirdRewardPeriodPercent * (finalRewardPeriodEndBlock - lastBlock) + previousBalanceFrom * finalRewardPeriodPercent * (finalRewardPeriodEndBlock - block.number);\r\n                        }\r\n                        else {\r\n                            rewardAmount = previousBalanceFrom * finalRewardPeriodPercent * (finalRewardPeriodEndBlock - thirdRewardPeriodEndBlock);\r\n                        }\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        rewardAmount = rewardAmount / 10000;\r\n        updateValueAtNow(balances[_to], previousBalanceTo + _amount + rewardAmount);\r\n\r\n        // UPDATE TOTAL\r\n        if (rewardAmount > 0) {\r\n            curTotalSupply = getValueAt(totalSupplyHistory, block.number);\r\n            if (curTotalSupply + rewardAmount < curTotalSupply) throw;\r\n            // Check for overflow\r\n            updateValueAtNow(totalSupplyHistory, curTotalSupply + rewardAmount);\r\n        }\r\n\r\n        Transfer(_from, _to, _amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balanceOfAt(_owner, block.number);\r\n    }\r\n\r\n    function approve(address _spender, uint256 _amount) returns (bool success) {\r\n        if (!transfersEnabled) throw;\r\n\r\n        if ((_amount != 0) && (allowed[msg.sender][_spender] != 0)) throw;\r\n\r\n        if (isContract(controller)) {\r\n            if (!TokenController(controller).onApprove(msg.sender, _spender, _amount))\r\n            throw;\r\n        }\r\n\r\n        allowed[msg.sender][_spender] = _amount;\r\n        Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender\r\n    ) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    function approveAndCall(address _spender, uint256 _amount, bytes _extraData\r\n    ) returns (bool success) {\r\n        if (!approve(_spender, _amount)) throw;\r\n\r\n        ApproveAndCallFallBack(_spender).receiveApproval(\r\n        msg.sender,\r\n        _amount,\r\n        this,\r\n        _extraData\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    function totalSupply() constant returns (uint) {\r\n        return totalSupplyAt(block.number);\r\n    }\r\n\r\n    function getBalancesOfAddress(address _owner) onlyController returns (uint128, uint128) {\r\n        Checkpoint[] checkpoints = balances[_owner];\r\n        return (checkpoints[checkpoints.length - 1].value, checkpoints[checkpoints.length - 1].fromBlock);\r\n    }\r\n\r\n    function balanceOfAt(address _owner, uint _blockNumber) constant\r\n    returns (uint) {\r\n\r\n        if ((balances[_owner].length == 0)\r\n        || (balances[_owner][0].fromBlock > _blockNumber)) {\r\n            if (address(parentToken) != 0) {\r\n                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\r\n            }\r\n            else {\r\n                return 0;\r\n            }\r\n        }\r\n        else {\r\n            return getValueAt(balances[_owner], _blockNumber);\r\n        }\r\n    }\r\n\r\n    function totalSupplyAt(uint _blockNumber) constant returns (uint) {\r\n        if ((totalSupplyHistory.length == 0)\r\n        || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\r\n            if (address(parentToken) != 0) {\r\n                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\r\n            }\r\n            else {\r\n                return 0;\r\n            }\r\n        }\r\n        else {\r\n            return getValueAt(totalSupplyHistory, _blockNumber);\r\n        }\r\n    }\r\n\r\n\r\n    function createCloneToken(\r\n        string _cloneTokenName,\r\n        uint8 _cloneDecimalUnits,\r\n        string _cloneTokenSymbol,\r\n        uint _snapshotBlock,\r\n        bool _transfersEnabled\r\n    ) returns (address) {\r\n        if (_snapshotBlock == 0) _snapshotBlock = block.number;\r\n        ShineCoinToken cloneToken = tokenFactory.createCloneToken(\r\n        this,\r\n        _snapshotBlock,\r\n        _cloneTokenName,\r\n        _cloneDecimalUnits,\r\n        _cloneTokenSymbol,\r\n        _transfersEnabled\r\n        );\r\n\r\n        cloneToken.changeController(msg.sender);\r\n\r\n        NewCloneToken(address(cloneToken), _snapshotBlock);\r\n        return address(cloneToken);\r\n    }\r\n\r\n    function generateTokens(address _owner, uint _amount\r\n    ) onlyController returns (bool) {\r\n        uint curTotalSupply = getValueAt(totalSupplyHistory, block.number);\r\n        if (curTotalSupply + _amount < curTotalSupply) throw;\r\n\r\n        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\r\n        var previousBalanceTo = balanceOf(_owner);\r\n        if (previousBalanceTo + _amount < previousBalanceTo) throw;\r\n\r\n        updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\r\n        Transfer(0, _owner, _amount);\r\n        return true;\r\n    }\r\n\r\n    function destroyTokens(address _owner, uint _amount\r\n    ) onlyController returns (bool) {\r\n        uint curTotalSupply = getValueAt(totalSupplyHistory, block.number);\r\n        if (curTotalSupply < _amount) throw;\r\n        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\r\n        var previousBalanceFrom = balanceOf(_owner);\r\n        if (previousBalanceFrom < _amount) throw;\r\n        updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\r\n        Transfer(_owner, 0, _amount);\r\n        return true;\r\n    }\r\n\r\n    function enableTransfers(bool _transfersEnabled) onlyController {\r\n        transfersEnabled = _transfersEnabled;\r\n    }\r\n\r\n    function getValueAt(Checkpoint[] storage checkpoints, uint _block\r\n    ) constant internal returns (uint) {\r\n        if (checkpoints.length == 0) return 0;\r\n\r\n        if (_block >= checkpoints[checkpoints.length - 1].fromBlock)\r\n        return checkpoints[checkpoints.length - 1].value;\r\n        if (_block < checkpoints[0].fromBlock) return 0;\r\n\r\n        uint min = 0;\r\n        uint max = checkpoints.length - 1;\r\n        while (max > min) {\r\n            uint mid = (max + min + 1) / 2;\r\n            if (checkpoints[mid].fromBlock <= _block) {\r\n                min = mid;\r\n            }\r\n            else {\r\n                max = mid - 1;\r\n            }\r\n        }\r\n        return checkpoints[min].value;\r\n    }\r\n\r\n    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value\r\n    ) internal {\r\n        if ((checkpoints.length == 0)\r\n        || (checkpoints[checkpoints.length - 1].fromBlock < block.number)) {\r\n            Checkpoint newCheckPoint = checkpoints[checkpoints.length++];\r\n            newCheckPoint.fromBlock = uint128(block.number);\r\n            newCheckPoint.value = uint128(_value);\r\n        }\r\n        else {\r\n            Checkpoint oldCheckPoint = checkpoints[checkpoints.length - 1];\r\n            oldCheckPoint.value = uint128(_value);\r\n        }\r\n    }\r\n\r\n    function isContract(address _addr) constant internal returns (bool) {\r\n        uint size;\r\n        if (_addr == 0) return false;\r\n        assembly {\r\n        size := extcodesize(_addr)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    function min(uint a, uint b) internal returns (uint) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function() payable {\r\n        if (isContract(controller)) {\r\n            if (!TokenController(controller).proxyPayment.value(msg.value)(msg.sender))\r\n            throw;\r\n        }\r\n        else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\r\n\r\n    event NewCloneToken(address indexed _cloneToken, uint _snapshotBlock);\r\n\r\n    event Approval(\r\n        address indexed _owner,\r\n        address indexed _spender,\r\n        uint256 _amount\r\n    );\r\n\r\n}\r\n\r\ncontract ShineCoinTokenFactory {\r\n        function createCloneToken(\r\n        address _parentToken,\r\n        uint _snapshotBlock,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol,\r\n        bool _transfersEnabled\r\n    ) returns (ShineCoinToken) {\r\n        ShineCoinToken newToken = new ShineCoinToken(\r\n        this,\r\n        _parentToken,\r\n        _snapshotBlock,\r\n        _tokenName,\r\n        _decimalUnits,\r\n        _tokenSymbol,\r\n        _transfersEnabled\r\n        );\r\n        newToken.changeController(msg.sender);\r\n        return newToken;\r\n    }\r\n}\r\n\r\n\r\ncontract ShineCrowdFunder is Controlled, SafeMath {\r\n    address public creator;\r\n\r\n    address public fundRecipient;\r\n\r\n    address public reserveTeamRecipient;\r\n\r\n    address public reserveBountyRecipient;\r\n\r\n    bool public isReserveGenerated;\r\n\r\n    State public state = State.Fundraising;\r\n\r\n    uint public minFundingGoal;\r\n\r\n    uint public currentBalance;\r\n\r\n    uint public tokensIssued;\r\n\r\n    uint public capTokenAmount;\r\n\r\n    uint public startBlockNumber;\r\n\r\n    uint public endBlockNumber;\r\n\r\n    uint public tokenExchangeRate;\r\n\r\n    ShineCoinToken public exchangeToken;\r\n\r\n    event GoalReached(address fundRecipient, uint amountRaised);\r\n\r\n    event FundTransfer(address backer, uint amount, bool isContribution);\r\n\r\n    event FrozenFunds(address target, bool frozen);\r\n\r\n    event LogFundingReceived(address addr, uint amount, uint currentTotal);\r\n\r\n    mapping (address => uint256) private balanceOf;\r\n\r\n    mapping (address => bool) private frozenAccount;\r\n\r\n    enum State {\r\n        Fundraising,\r\n        ExpiredRefund,\r\n        Successful,\r\n        Closed\r\n    }\r\n\r\n    modifier inState(State _state) {\r\n        if (state != _state) throw;\r\n        _;\r\n    }\r\n\r\n    modifier atEndOfFundraising() {\r\n        if (!((state == State.ExpiredRefund || state == State.Successful) && block.number > endBlockNumber)\r\n        ) {\r\n            throw;\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier accountNotFrozen() {\r\n        if (frozenAccount[msg.sender] == true) throw;\r\n        _;\r\n    }\r\n\r\n    modifier minInvestment() {\r\n        // User has to send at least 0.01 Eth\r\n        require(msg.value >= 10 ** 16);\r\n        _;\r\n    }\r\n\r\n\r\n    function ShineCrowdFunder(\r\n        address _fundRecipient,\r\n        address _reserveTeamRecipient,\r\n        address _reserveBountyRecipient,\r\n        ShineCoinToken _addressOfExchangeToken\r\n    ) {\r\n        creator = msg.sender;\r\n\r\n        fundRecipient = _fundRecipient;\r\n        reserveTeamRecipient = _reserveTeamRecipient;\r\n        reserveBountyRecipient = _reserveBountyRecipient;\r\n\r\n        isReserveGenerated = false;\r\n\r\n        minFundingGoal = 1250 * 1 ether;\r\n        capTokenAmount = 10000000 * 10 ** 9;\r\n\r\n        state = State.Fundraising;\r\n\r\n        currentBalance = 0;\r\n        tokensIssued = 0;\r\n\r\n        startBlockNumber = block.number;\r\n        endBlockNumber = startBlockNumber + ((31 * 24 * 3600) / 18); // 31 days\r\n\r\n        tokenExchangeRate = 400 * 10 ** 9;\r\n\r\n        exchangeToken = ShineCoinToken(_addressOfExchangeToken);\r\n    }\r\n\r\n    function changeReserveTeamRecipient(address _reserveTeamRecipient) onlyController {\r\n        reserveTeamRecipient = _reserveTeamRecipient;\r\n    }\r\n\r\n    function changeReserveBountyRecipient(address _reserveBountyRecipient) onlyController {\r\n        reserveBountyRecipient = _reserveBountyRecipient;\r\n    }\r\n\r\n    function freezeAccount(address target, bool freeze) onlyController {\r\n        frozenAccount[target] = freeze;\r\n        FrozenFunds(target, freeze);\r\n    }\r\n\r\n    function getExchangeRate(uint amount) public constant returns (uint) {\r\n        return tokenExchangeRate * amount / 1 ether;\r\n    }\r\n\r\n    function investment() public inState(State.Fundraising) accountNotFrozen minInvestment payable returns (uint)  {\r\n        uint amount = msg.value;\r\n        if (amount == 0) throw;\r\n\r\n        balanceOf[msg.sender] += amount;\r\n        currentBalance += amount;\r\n\r\n        uint tokenAmount = getExchangeRate(amount);\r\n        exchangeToken.generateTokens(msg.sender, tokenAmount);\r\n        tokensIssued += tokenAmount;\r\n\r\n        FundTransfer(msg.sender, amount, true);\r\n        LogFundingReceived(msg.sender, tokenAmount, tokensIssued);\r\n\r\n        checkIfFundingCompleteOrExpired();\r\n\r\n        return balanceOf[msg.sender];\r\n    }\r\n\r\n    function checkIfFundingCompleteOrExpired() {\r\n        if (block.number > endBlockNumber || tokensIssued >= capTokenAmount) {\r\n            if (currentBalance >= minFundingGoal) {\r\n                state = State.Successful;\r\n                payOut();\r\n\r\n                GoalReached(fundRecipient, currentBalance);\r\n            }\r\n            else {\r\n                state = State.ExpiredRefund; // backers can now collect refunds by calling getRefund()\r\n            }\r\n        }\r\n    }\r\n\r\n    function payOut() public inState(State.Successful) onlyController() {\r\n        var amount = currentBalance;\r\n        currentBalance = 0;\r\n        state = State.Closed;\r\n\r\n        fundRecipient.transfer(amount);\r\n\r\n        generateReserve();\r\n\r\n        exchangeToken.enableTransfers(true);\r\n        exchangeToken.changeReserveTeamRecepient(reserveTeamRecipient);\r\n        exchangeToken.changeController(controller);\r\n    }\r\n\r\n    function getRefund() public inState(State.ExpiredRefund) {\r\n        uint amountToRefund = balanceOf[msg.sender];\r\n        balanceOf[msg.sender] = 0;\r\n\r\n        msg.sender.transfer(amountToRefund);\r\n        currentBalance -= amountToRefund;\r\n\r\n        FundTransfer(msg.sender, amountToRefund, false);\r\n    }\r\n\r\n    function generateReserve() {\r\n        if (isReserveGenerated) {\r\n            throw;\r\n        }\r\n        else {\r\n            uint issued = tokensIssued;\r\n            uint percentTeam = 15;\r\n            uint percentBounty = 1;\r\n            uint reserveAmountTeam = div(mul(issued, percentTeam), 85);\r\n            uint reserveAmountBounty = div(mul(issued, percentBounty), 99);\r\n            exchangeToken.generateTokens(reserveTeamRecipient, reserveAmountTeam);\r\n            exchangeToken.generateTokens(reserveBountyRecipient, reserveAmountBounty);\r\n            isReserveGenerated = true;\r\n        }\r\n    }\r\n\r\n    function removeContract() public atEndOfFundraising onlyController() {\r\n        if (state != State.Closed) {\r\n            exchangeToken.changeController(controller);\r\n        }\r\n        selfdestruct(msg.sender);\r\n    }\r\n\r\n    /* default */\r\n    function() inState(State.Fundraising) accountNotFrozen payable {\r\n        investment();\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"creator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minFundingGoal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_reserveTeamRecipient\",\"type\":\"address\"}],\"name\":\"changeReserveTeamRecipient\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newController\",\"type\":\"address\"}],\"name\":\"changeController\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenExchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"investment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startBlockNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"capTokenAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getExchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserveBountyRecipient\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserveTeamRecipient\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensIssued\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"checkIfFundingCompleteOrExpired\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_reserveBountyRecipient\",\"type\":\"address\"}],\"name\":\"changeReserveBountyRecipient\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangeToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getRefund\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endBlockNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payOut\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"generateReserve\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundRecipient\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isReserveGenerated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"freeze\",\"type\":\"bool\"}],\"name\":\"freezeAccount\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"removeContract\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_fundRecipient\",\"type\":\"address\"},{\"name\":\"_reserveTeamRecipient\",\"type\":\"address\"},{\"name\":\"_reserveBountyRecipient\",\"type\":\"address\"},{\"name\":\"_addressOfExchangeToken\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fundRecipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountRaised\",\"type\":\"uint256\"}],\"name\":\"GoalReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"backer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"isContribution\",\"type\":\"bool\"}],\"name\":\"FundTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"FrozenFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"currentTotal\",\"type\":\"uint256\"}],\"name\":\"LogFundingReceived\",\"type\":\"event\"}]","ContractName":"ShineCrowdFunder","CompilerVersion":"v0.4.12-nightly.2017.5.19+commit.982f6613","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000005b75f35d7dfc3319fe2ecbaec8e26e7bb94d830c0000000000000000000000001492b7b58f3288d3f77fdca733fd77e4868299e3000000000000000000000000e9bfa4167083167f628755297948ccde55f082000000000000000000000000007be7a4b6deaa3dd9e522a633f6174e51b91c3b57","Library":"","SwarmSource":"bzzr://413ec1278c0b4a41f7cb34899aa3202c398532575cebc1a7446e84ec8d70d724"}]}