{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n\r\n/**\r\nMockup object \r\n*/\r\ncontract ElementhToken {\r\n    \r\n  bool public mintingFinished = false;\r\n    function mint(address _to, uint256 _amount) public returns (bool) {\r\n    if(_to != address(0)) mintingFinished = false;\r\n    if(_amount != 0) mintingFinished = false;\r\n    return true;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    mapping(address => bool)  internal owners;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    function Ownable() public{\r\n        owners[msg.sender] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owners[msg.sender] == true);\r\n        _;\r\n    }\r\n\r\n    function addOwner(address newAllowed) onlyOwner public {\r\n        owners[newAllowed] = true;\r\n    }\r\n\r\n    function removeOwner(address toRemove) onlyOwner public {\r\n        owners[toRemove] = false;\r\n    }\r\n\r\n    function isOwner() public view returns(bool){\r\n        return owners[msg.sender] == true;\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Crowdsale\r\n * @dev Crowdsale is a base contract for managing a token crowdsale.\r\n * Crowdsales have a start and end timestamps, where investors can make\r\n * token purchases and the crowdsale will assign them tokens based\r\n * on a token per ETH rate. Funds collected are forwarded to a wallet\r\n * as they arrive.\r\n */\r\ncontract Crowdsale {\r\n  using SafeMath for uint256;\r\n\r\n  // The token being sold\r\n  ElementhToken public token;\r\n\r\n  // start and end timestamps where investments are allowed (both inclusive)\r\n  uint256 public startTime;\r\n  uint256 public endTime;\r\n\r\n  // address where funds are collected\r\n  address public wallet;\r\n\r\n  // how many token units a buyer gets per wei\r\n  uint256 public rate;\r\n\r\n  // amount of raised money in wei\r\n  uint256 public weiRaised;\r\n\r\n  \r\n\r\n  /**\r\n   * event for token purchase logging\r\n   * @param purchaser who paid for the tokens\r\n   * @param beneficiary who got the tokens\r\n   * @param value weis paid for purchase\r\n   * @param amount amount of tokens purchased\r\n   */\r\n  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\r\n\r\n\r\n  function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet, ElementhToken _token) public {\r\n    require(_startTime >= now);\r\n    require(_endTime >= _startTime);\r\n    require(_rate > 0);\r\n    require(_wallet != address(0));\r\n    require(_token != address(0));\r\n\r\n    token = _token;\r\n    startTime = _startTime;\r\n    endTime = _endTime;\r\n    rate = _rate;\r\n    wallet = _wallet;\r\n  }\r\n\r\n\r\n  // @return true if the transaction can buy tokens\r\n  function validPurchase(bool isBtc) internal view returns (bool) {\r\n    bool withinPeriod = now >= startTime && now <= endTime;\r\n    bool nonZeroPurchase = msg.value != 0 || isBtc;\r\n    return withinPeriod && nonZeroPurchase;\r\n  }\r\n\r\n  // @return true if crowdsale event has ended\r\n  function hasEnded() public view returns (bool) {\r\n    return now > endTime;\r\n  }\r\n\r\n\r\n\r\n\r\n}\r\n\r\n/**\r\n * @title CappedCrowdsale\r\n * @dev Extension of Crowdsale with a max amount of funds raised\r\n */\r\ncontract CappedCrowdsale is Crowdsale {\r\n  using SafeMath for uint256;\r\n\r\n  uint256 public cap;\r\n\r\n  function CappedCrowdsale(uint256 _cap) public {\r\n    require(_cap > 0);\r\n    cap = _cap * 1 ether;\r\n  }\r\n\r\n  // overriding Crowdsale#validPurchase to add extra cap logic\r\n  // @return true if investors can buy at the moment\r\n  function validPurchase(bool isBtc) internal view returns (bool) {\r\n    bool withinCap = weiRaised.add(msg.value) <= cap;\r\n    return super.validPurchase(isBtc) && withinCap;\r\n  }\r\n\r\n  // overriding Crowdsale#hasEnded to add cap logic\r\n  // @return true if crowdsale event has ended\r\n  function hasEnded() public view returns (bool) {\r\n    bool capReached = weiRaised >= cap;\r\n    return super.hasEnded() || capReached;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title FinalizableCrowdsale\r\n * @dev Extension of Crowdsale where an owner can do extra work\r\n * after finishing.\r\n */\r\ncontract FinalizableCrowdsale is Crowdsale, Ownable {\r\n  using SafeMath for uint256;\r\n\r\n  bool public isFinalized = false;\r\n\r\n  event Finalized();\r\n\r\n  /**\r\n   * @dev Must be called after crowdsale ends, to do some extra finalization\r\n   * work. Calls the contract's finalization function.\r\n   */\r\n  function finalize() onlyOwner public {\r\n    require(!isFinalized);\r\n    require(hasEnded());\r\n\r\n    finalization();\r\n    Finalized();\r\n\r\n    isFinalized = true;\r\n  }\r\n\r\n  /**\r\n   * @dev Can be overridden to add finalization logic. The overriding function\r\n   * should call super.finalization() to ensure the chain of finalization is\r\n   * executed entirely.\r\n   */\r\n  function finalization() internal {\r\n      Finalized();\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title RefundableCrowdsale\r\n * @dev Extension of Crowdsale contract that adds a funding goal, and\r\n * the possibility of users getting a refund if goal is not met.\r\n * Uses a RefundVault as the crowdsale's vault.\r\n */\r\ncontract RefundableCrowdsale is FinalizableCrowdsale {\r\n  using SafeMath for uint256;\r\n\r\n  // minimum amount of funds to be raised in weis\r\n  uint256 public goal;\r\n\r\n  mapping (address => bool) refunded;\r\n  mapping (address => uint256) saleBalances;  \r\n  mapping (address => bool) claimed;\r\n\r\n  event Refunded(address indexed holder, uint256 amount);\r\n\r\n  function RefundableCrowdsale(uint256 _goal) public {\r\n    goal = _goal * 1 ether;\r\n  }\r\n\r\n  // if crowdsale is unsuccessful, investors can claim refunds here\r\n  function claimRefund() public {\r\n    require(isFinalized);\r\n    require(!goalReached());\r\n    require(!refunded[msg.sender]);\r\n    require(saleBalances[msg.sender] != 0);\r\n\r\n    uint refund = saleBalances[msg.sender];\r\n    require (msg.sender.send(refund));\r\n    refunded[msg.sender] = true;\r\n\r\n    Refunded(msg.sender, refund);\r\n  }\r\n\r\n  function goalReached() public view returns (bool) {\r\n    return weiRaised >= goal;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title SampleCrowdsale\r\n * @dev This is an example of a fully fledged crowdsale.\r\n * The way to add new features to a base crowdsale is by multiple inheritance.\r\n * In this example we are providing following extensions:\r\n * CappedCrowdsale - sets a max boundary for raised funds\r\n * RefundableCrowdsale - set a min goal to be reached and returns funds if it's not met\r\n *\r\n * After adding multiple features it's good practice to run integration tests\r\n * to ensure that subcontracts works together as intended.\r\n */\r\ncontract ElementhCrowdsale is CappedCrowdsale, RefundableCrowdsale {\r\n\r\n  struct BTCTransaction {\r\n    uint256 amount;\r\n    bytes16 hash;\r\n    address wallet;\r\n  }\r\n\r\n  // stage of ICO Crowdsale (1 - Closed PreSale, 2 - pre ICO)\r\n  uint8 public stage;\r\n\r\n\r\n  uint256 public bonusStage1;\r\n  uint256 public bonusStage2FirstDay;\r\n  uint256 public bonusStage2SecondDay;\r\n\r\n  mapping (bytes16 => BTCTransaction) public BTCTransactions;\r\n\r\n  // amount of raised money in satoshi\r\n  uint256 public satoshiRaised;\r\n  uint256 public BTCRate;\r\n\r\n\r\n  function ElementhCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, uint256 _capETH, uint256 _goalETH, address _wallet, uint256 _BTCRate, ElementhToken _token) public\r\n    CappedCrowdsale(_capETH)\r\n    FinalizableCrowdsale()\r\n    RefundableCrowdsale(_goalETH)\r\n    Crowdsale(_startTime, _endTime, _rate, _wallet, _token){\r\n      BTCRate = _BTCRate;\r\n      bonusStage1 = 50;\r\n      bonusStage2FirstDay = 30;\r\n      bonusStage2SecondDay = 15;\r\n      stage = 1;\r\n    }\r\n\r\n\r\n  function setStartTime(uint256 _startTime) public onlyOwner{\r\n    startTime = _startTime;\r\n  }\r\n\r\n  function setEndTime(uint256 _endTime) public onlyOwner{\r\n    endTime = _endTime;\r\n  }\r\n\r\n  function setRate(uint256 _rate) public onlyOwner{\r\n    rate = _rate;\r\n  }\r\n\r\n  function setGoalETH(uint256 _goalETH) public onlyOwner{\r\n    goal = _goalETH * 1 ether;\r\n  }\r\n\r\n  function setCapETH(uint256 _capETH) public onlyOwner{\r\n    cap = _capETH * 1 ether;\r\n  }\r\n\r\n  function setStage(uint8 _stage) public onlyOwner{\r\n    stage = _stage;\r\n  }\r\n\r\n  function setBTCRate(uint _BTCRate) public onlyOwner{\r\n    BTCRate = _BTCRate;\r\n  }\r\n\r\n  function setWallet(address _wallet) public onlyOwner{\r\n    wallet = _wallet;\r\n  }\r\n\r\n  function setBonuses(uint256 _bonusStage1, uint256 _bonusStage2FirstDay, uint256 _bonusStage2SecondDay) public onlyOwner{\r\n    bonusStage1 = _bonusStage1;\r\n    bonusStage2FirstDay = _bonusStage2FirstDay;\r\n    bonusStage2SecondDay = _bonusStage2SecondDay;\r\n  }\r\n\r\n  // fallback function can be used to buy tokens\r\n  function () external payable {\r\n    buyTokens(msg.sender);\r\n  }\r\n\r\n  // low level token purchase function\r\n  function buyTokens(address beneficiary) public payable {\r\n    require(beneficiary != address(0));\r\n    require(stage !=0);\r\n    require(validPurchase(false));\r\n    if(stage == 1) {\r\n      require(msg.value >= 10 ether);\r\n    }\r\n\r\n    if(stage == 2) {\r\n      require(msg.value >= 1 ether);\r\n    }\r\n    \r\n    uint256 weiAmount = msg.value;\r\n\r\n    uint256 tokens = getTokenAmount(weiAmount);\r\n\r\n    // update state\r\n    weiRaised = weiRaised.add(weiAmount);\r\n\r\n    token.mint(beneficiary, tokens);\r\n    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\r\n\r\n    forwardFunds();\r\n  }\r\n\r\n  // send ether to the fund collection wallet\r\n  // override to create custom fund forwarding mechanisms\r\n  function forwardFunds() internal {\r\n    wallet.transfer(msg.value);\r\n    saleBalances[msg.sender] = saleBalances[msg.sender].add(msg.value);\r\n  }\r\n\r\n\r\n  function addBTCTransaction(uint256 _amountSatoshi, bytes16 _hashTransaction, address _walletETH) public onlyOwner{\r\n    require(BTCTransactions[_hashTransaction].amount == 0);\r\n    require(_walletETH != address(0));\r\n    require(validPurchase(true));\r\n\r\n    BTCTransactions[_hashTransaction] = BTCTransaction(_amountSatoshi, _hashTransaction, _walletETH);\r\n\r\n    uint256 weiAmount = _amountSatoshi * BTCRate;\r\n    uint256 tokens = getTokenAmount(weiAmount);\r\n\r\n    // update state\r\n    weiRaised = weiRaised.add(weiAmount);\r\n    satoshiRaised = satoshiRaised.add(_amountSatoshi);\r\n\r\n    token.mint(_walletETH, tokens);\r\n    TokenPurchase(_walletETH, _walletETH, weiAmount, tokens);\r\n\r\n  }\r\n\r\n  function getTokenAmount(uint256 _weiAmount) public view returns (uint256){\r\n    // calculate token amount to be created + bonus\r\n    uint256 tokens = _weiAmount.mul(rate);\r\n\r\n    // bonuses\r\n    if(stage == 1){\r\n      tokens = tokens.mul(100 + bonusStage1).div(100);\r\n    }\r\n\r\n    if(stage == 2){\r\n      if(now - startTime < 1 days){\r\n        tokens = tokens.mul(100 + bonusStage2FirstDay).div(100);\r\n      }\r\n      if(now - startTime < 2 days && now - startTime > 1 days){\r\n        tokens = tokens.mul(100 + bonusStage2SecondDay).div(100);\r\n      }\r\n    }\r\n\r\n    return tokens;\r\n  }\r\n\r\n  function withdraw() public onlyOwner{\r\n    wallet.transfer(this.balance);\r\n  }\r\n\r\n  function deposit() public payable onlyOwner{\r\n\r\n  }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"BTCTransactions\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"hash\",\"type\":\"bytes16\"},{\"name\":\"wallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_BTCRate\",\"type\":\"uint256\"}],\"name\":\"setBTCRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_goalETH\",\"type\":\"uint256\"}],\"name\":\"setGoalETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusStage2FirstDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"satoshiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"toRemove\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bonusStage1\",\"type\":\"uint256\"},{\"name\":\"_bonusStage2FirstDay\",\"type\":\"uint256\"},{\"name\":\"_bonusStage2SecondDay\",\"type\":\"uint256\"}],\"name\":\"setBonuses\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"setRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startTime\",\"type\":\"uint256\"}],\"name\":\"setStartTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"goal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amountSatoshi\",\"type\":\"uint256\"},{\"name\":\"_hashTransaction\",\"type\":\"bytes16\"},{\"name\":\"_walletETH\",\"type\":\"address\"}],\"name\":\"addBTCTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_capETH\",\"type\":\"uint256\"}],\"name\":\"setCapETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAllowed\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"goalReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusStage1\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusStage2SecondDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_weiAmount\",\"type\":\"uint256\"}],\"name\":\"getTokenAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_endTime\",\"type\":\"uint256\"}],\"name\":\"setEndTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_stage\",\"type\":\"uint8\"}],\"name\":\"setStage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"setWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasEnded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BTCRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"},{\"name\":\"_rate\",\"type\":\"uint256\"},{\"name\":\"_capETH\",\"type\":\"uint256\"},{\"name\":\"_goalETH\",\"type\":\"uint256\"},{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_BTCRate\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Refunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Finalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"}]","ContractName":"ElementhCrowdsale","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000005a5bef00000000000000000000000000000000000000000000000000000000005a725880000000000000000000000000000000000000000000000000000000000000271000000000000000000000000000000000000000000000000000000000000005dc00000000000000000000000000000000000000000000000000000000000000640000000000000000000000004906a90b6a2240d54b477ffc800619708850519f0000000000000000000000000000000000000000000000000003a026b46a18ea00000000000000000000000015f917e4f828671a0bcda6e961eb43e945bb2b42","Library":"","SwarmSource":"bzzr://6fe0cbbaece3b4e13cdcb909b464dde1dce8ff3d74bfd35e980b532856ca8f50"}]}