{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^ 0.4.17;\r\n\r\n\r\nlibrary SafeMath {\r\n    function mul(uint a, uint b) pure internal returns(uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function sub(uint a, uint b) pure internal returns(uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint a, uint b) pure internal returns(uint) {\r\n        uint c = a + b;\r\n        assert(c >= a && c >= b);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n* @title Ownable\r\n* @dev The Ownable contract has an owner address, and provides basic authorization control\r\n* functions, this simplifies the implementation of \"user permissions\".\r\n*/\r\ncontract Ownable {\r\n    address public owner;\r\n    \r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n    * account.\r\n    */\r\n    function Ownable() public {\t\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address newOwner) onlyOwner public {\r\n        require(newOwner != address(0));\r\n        OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\n\r\ncontract Pausable is Ownable {\r\n    bool public stopped;\r\n\r\n    modifier stopInEmergency {\r\n        if (stopped) {\r\n            revert();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlyInEmergency {\r\n        if (!stopped) {\r\n            revert();\r\n        }\r\n        _;\r\n    }\r\n\r\n    // @notice Called by the owner in emergency, triggers stopped state\r\n    function emergencyStop() external onlyOwner {\r\n        stopped = true;\r\n    }\r\n\r\n    /// @notice Called by the owner to end of emergency, returns to normal state\r\n    function release() external onlyOwner onlyInEmergency {\r\n        stopped = false;\r\n    }\r\n}\r\n\r\n\r\ncontract ERC20 {\r\n    uint public totalSupply;\r\n\r\n    function balanceOf(address who) public view returns(uint);\r\n\r\n    function allowance(address owner, address spender) public view returns(uint);\r\n\r\n    function transfer(address to, uint value) public returns(bool ok);\r\n\r\n    function transferFrom(address from, address to, uint value) public returns(bool ok);\r\n\r\n    function approve(address spender, uint value) public returns(bool ok);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n\r\n// @notice Migration Agent interface\r\n\r\ncontract MigrationAgent {\r\n    function migrateFrom(address _from, uint256 _value) public;\r\n}\r\n\r\n\r\n// @notice  Whitelist interface which will hold whitelisted users\r\ncontract WhiteList is Ownable {\r\n\r\n    function isWhiteListed(address _user) external view returns (bool);        \r\n}\r\n\r\n// @notice contract to control vesting schedule for company and team tokens\r\ncontract Vesting is Ownable {\r\n\r\n    using SafeMath for uint;\r\n\r\n    uint public teamTokensInitial = 2e25;      // max tokens amount for the team 20,000,000\r\n    uint public teamTokensCurrent = 0;         // to keep record of distributed tokens so far to the team\r\n    uint public companyTokensInitial = 30e24;  // max tokens amount for the company 30,000,000\r\n    uint public companyTokensCurrent = 0;      // to keep record of distributed tokens so far to the company\r\n    Token public token;                        // token contract\r\n    uint public dateICOEnded;                  // date when ICO ended updated from the finalizeSale() function\r\n    uint public dateProductCompleted;          // date when product has been completed\r\n\r\n\r\n    event LogTeamTokensTransferred(address indexed receipient, uint amouontOfTokens);\r\n    event LogCompanyTokensTransferred(address indexed receipient, uint amouontOfTokens);\r\n\r\n\r\n    // @notice set the handle of the token contract\r\n    // @param _token  {Token} address of the token contract\r\n    // @return  {bool} true if successful\r\n    function setToken(Token _token) public onlyOwner() returns(bool) {\r\n        require (token == address(0));  \r\n        token = _token;\r\n        return true;\r\n    }\r\n\r\n    // @notice set the product completion date for release of dev tokens\r\n    function setProductCompletionDate() external onlyOwner() {\r\n        dateProductCompleted = now;\r\n    }\r\n\r\n    // @notice  to release tokens of the team according to vesting schedule\r\n    // @param _recipient {address} of the recipient of token transfer\r\n    // @param _tokensToTransfer {uint} amount of tokens to transfer\r\n    function transferTeamTokens(address _recipient, uint _tokensToTransfer) external onlyOwner() {\r\n\r\n        require(_recipient != 0);       \r\n        require(now >= 1533081600);  // before Aug 1, 2018 00:00 GMT don't allow on distribution tokens to the team.\r\n\r\n        require(dateProductCompleted > 0);\r\n        if (now < dateProductCompleted + 1 years)            // first year after product release\r\n            require(teamTokensCurrent.add(_tokensToTransfer) <= (teamTokensInitial * 30) / 100);\r\n        else if (now < dateProductCompleted + 2 years)       // second year after product release\r\n            require(teamTokensCurrent.add(_tokensToTransfer) <= (teamTokensInitial * 60) / 100);\r\n        else if (now < dateProductCompleted + 3 years)       // third year after product release\r\n            require(teamTokensCurrent.add(_tokensToTransfer) <= (teamTokensInitial * 80) / 100);\r\n        else                                                 // fourth year after product release\r\n            require(teamTokensCurrent.add(_tokensToTransfer) <= teamTokensInitial);\r\n\r\n        teamTokensCurrent = teamTokensCurrent.add(_tokensToTransfer);  // update released token amount\r\n        \r\n        if (!token.transfer(_recipient, _tokensToTransfer))\r\n                revert();\r\n\r\n        LogTeamTokensTransferred(_recipient, _tokensToTransfer);\r\n    }\r\n\r\n    // @notice  to release tokens of the company according to vesting schedule\r\n    // @param _recipient {address} of the recipient of token transfer\r\n    // @param _tokensToTransfer {uint} amount of tokens to transfer\r\n    function transferCompanyTokens(address _recipient, uint _tokensToTransfer) external onlyOwner() {\r\n\r\n        require(_recipient != 0);\r\n        require(dateICOEnded > 0);       \r\n\r\n        if (now < dateICOEnded + 1 years)   // first year\r\n            require(companyTokensCurrent.add(_tokensToTransfer) <= (companyTokensInitial * 50) / 100);\r\n        else if (now < dateICOEnded + 2 years) // second year\r\n            require(companyTokensCurrent.add(_tokensToTransfer) <= (companyTokensInitial * 75) / 100);\r\n        else                                    // third year                                                                                   \r\n            require(companyTokensCurrent.add(_tokensToTransfer) <= companyTokensInitial);\r\n\r\n        companyTokensCurrent = companyTokensCurrent.add(_tokensToTransfer);  // update released token amount\r\n\r\n        if (!token.transfer(_recipient, _tokensToTransfer))\r\n                revert();\r\n        LogCompanyTokensTransferred(_recipient, _tokensToTransfer);\r\n    }\r\n}\r\n\r\n// Presale Smart Contract\r\n// This smart contract collects ETH and in return sends tokens to the backers.\r\ncontract CrowdSale is  Pausable, Vesting {\r\n\r\n    using SafeMath for uint;\r\n\r\n    struct Backer {\r\n        uint weiReceivedOne; // amount of ETH contributed during first presale\r\n        uint weiReceivedTwo;  // amount of ETH contributed during second presale\r\n        uint weiReceivedMain; // amount of ETH contributed during main sale\r\n        uint tokensSent; // amount of tokens  sent\r\n        bool claimed;\r\n        bool refunded;\r\n    }\r\n\r\n    address public multisig; // Multisig contract that will receive the ETH\r\n    uint public ethReceivedPresaleOne; // Amount of ETH received in presale one\r\n    uint public ethReceivedPresaleTwo; // Amount of ETH received in presale two\r\n    uint public ethReceiveMainSale; // Amount of ETH received in main sale\r\n    uint public totalTokensSold; // Number of tokens sold to contributors in all campaigns\r\n    uint public startBlock; // Presale start block\r\n    uint public endBlock; // Presale end block\r\n\r\n    uint public minInvestment; // Minimum amount to invest    \r\n    WhiteList public whiteList; // whitelist contract\r\n    uint public dollarPerEtherRatio; // dollar to ether ratio set at the beginning of main sale\r\n    uint public returnPercentage;  // percentage to be returned from first presale in case campaign is cancelled\r\n    Step public currentStep;  // to move through campaigns and set default values\r\n    uint public minCapTokens;  // minimum amount of tokens to raise for campaign to be successful\r\n\r\n    mapping(address => Backer) public backers; //backer list\r\n    address[] public backersIndex;  // to be able to iterate through backer list\r\n    uint public maxCapEth;  // max cap eth\r\n    uint public maxCapTokens; // max cap tokens\r\n    uint public claimCount;  // number of contributors claiming tokens\r\n    uint public refundCount;  // number of contributors receiving refunds\r\n    uint public totalClaimed;  // total of tokens claimed\r\n    uint public totalRefunded;  // total of tokens refunded\r\n    mapping(address => uint) public claimed; // tokens claimed by contributors\r\n    mapping(address => uint) public refunded; // tokens refunded to contributors\r\n\r\n\r\n\r\n    // @notice to set and determine steps of crowdsale\r\n    enum Step {\r\n        FundingPresaleOne,  // presale 1 mode\r\n        FundingPresaleTwo,  // presale 2 mode\r\n        FundingMainSale,    // main ICO\r\n        Refunding           // refunding\r\n    }\r\n\r\n\r\n    // @notice to verify if action is not performed out of the campaign range\r\n    modifier respectTimeFrame() {\r\n        if ((block.number < startBlock) || (block.number > endBlock))\r\n            revert();\r\n        _;\r\n    }\r\n\r\n    // Events\r\n    event ReceivedETH(address indexed backer, Step indexed step, uint amount);\r\n    event TokensClaimed(address indexed backer, uint count);\r\n    event Refunded(address indexed backer, uint amount);\r\n\r\n\r\n\r\n    // CrowdFunding   {constructor}\r\n    // @notice fired when contract is crated. Initializes all needed variables for presale 1.\r\n    function CrowdSale(WhiteList _whiteList, address _multisig) public {\r\n\r\n        require(_whiteList != address(0x0));\r\n        multisig = _multisig;\r\n        minInvestment = 100 ether;  // 100 eth\r\n        maxCapEth = 30000 ether;\r\n        startBlock = 0; // Starting block of the campaign\r\n        endBlock = 0; // Ending block of the campaign\r\n        currentStep = Step.FundingPresaleOne;  // initialize to first presale\r\n        whiteList = _whiteList; // address of white list contract\r\n        minCapTokens = 7.5e24;  // 15% of maxCapTokens (50 million)\r\n    }\r\n\r\n\r\n    // @notice return number of  contributors for all campaigns\r\n    // @return {uint} number of contributors in each campaign and total number\r\n    function numberOfBackers() public view returns(uint, uint, uint, uint) {\r\n\r\n        uint numOfBackersOne;\r\n        uint numOfBackersTwo;\r\n        uint numOfBackersMain;\r\n\r\n        for (uint i = 0; i < backersIndex.length; i++) {\r\n            Backer storage backer = backers[backersIndex[i]];\r\n            if (backer.weiReceivedOne > 0)\r\n                numOfBackersOne ++;\r\n            if (backer.weiReceivedTwo > 0)\r\n                numOfBackersTwo ++;\r\n            if (backer.weiReceivedMain > 0)\r\n                numOfBackersMain ++;\r\n            }\r\n        return ( numOfBackersOne, numOfBackersTwo, numOfBackersMain, backersIndex.length);\r\n    }\r\n\r\n\r\n\r\n    // @notice advances the step of campaign to presale 2\r\n    // contract is deployed in presale 1 mode\r\n    function setPresaleTwo() public onlyOwner() {\r\n        currentStep = Step.FundingPresaleTwo;\r\n        minInvestment = 10 ether;  // 10 eth\r\n    }\r\n\r\n    // @notice advances step of campaign to main sale\r\n    // @param _ratio   - it will be amount of dollars for one ether with two decimals.\r\n    // two decimals will be passed as next sets of digits. eg. $300.25 will be passed as 30025\r\n    function setMainSale(uint _ratio) public onlyOwner() {\r\n\r\n        require(_ratio > 0);\r\n        currentStep = Step.FundingMainSale;\r\n        dollarPerEtherRatio = _ratio;\r\n        maxCapTokens = 50e24;\r\n        minInvestment = 1 ether / 10;  // 0.1 eth\r\n        totalTokensSold = (dollarPerEtherRatio * ethReceivedPresaleOne) / 48;  // determine amount of tokens to send from first presale\r\n        totalTokensSold += (dollarPerEtherRatio * ethReceivedPresaleTwo) / 55;  // determine amount of tokens to send from second presale and total it.\r\n    }\r\n\r\n\r\n    // @notice to populate website with status of the sale\r\n    function returnWebsiteData() external view returns(uint, uint, uint, uint, uint, uint, uint, uint,  bool) {\r\n\r\n        return (startBlock, endBlock, backersIndex.length, ethReceivedPresaleOne, ethReceivedPresaleTwo, ethReceiveMainSale, maxCapTokens,   minInvestment,  stopped);\r\n    }\r\n\r\n\r\n    // {fallback function}\r\n    // @notice It will call internal function which handles allocation of Ether and calculates tokens.\r\n    function () public payable {\r\n        contribute(msg.sender);\r\n    }\r\n\r\n    // @notice in case refunds are needed, money can be returned to the contract\r\n    // @param _returnPercentage {uint} percentage of return in respect to first presale. e.g 75% would be passed as 75\r\n    function fundContract(uint _returnPercentage) external payable onlyOwner() {\r\n\r\n        require(_returnPercentage > 0);\r\n        require(msg.value == (ethReceivedPresaleOne.mul(_returnPercentage) / 100) + ethReceivedPresaleTwo + ethReceiveMainSale);\r\n        returnPercentage = _returnPercentage;\r\n        currentStep = Step.Refunding;\r\n    }\r\n\r\n    // @notice It will be called by owner to start the sale\r\n    // block numbers will be calculated based on current block time average.    \r\n    function start() external onlyOwner() {\r\n        startBlock = block.number;\r\n        endBlock = startBlock + 563472; // 4.3*60*24*91 days\r\n    }\r\n\r\n    // @notice Due to changing average of block time\r\n    // this function will allow on adjusting duration of campaign closer to the end\r\n    // allow adjusting campaign length to 101 days, equivalent of 625392 blocks at 4.3 blocks per minute\r\n    // @param _block  number of blocks representing duration\r\n    function adjustDuration(uint _block) external onlyOwner() {\r\n        // we'll want to set this to a buffer beyond the end of the \"expected\" end date so that we can extend the sale if needed/desired.\r\n        require(_block <= 625392);  // 4.3×60×24×101 days\r\n        require(_block > block.number.sub(startBlock)); // ensure that endBlock is not set in the past\r\n        endBlock = startBlock.add(_block);\r\n    }\r\n\r\n\r\n    // @notice It will be called by fallback function whenever ether is sent to it\r\n    // @param  _contributor {address} address of contributor\r\n    // @return res {bool} true if transaction was successful\r\n\r\n    function contribute(address _contributor) internal stopInEmergency respectTimeFrame returns(bool res) {\r\n\r\n\r\n        require(whiteList.isWhiteListed(_contributor));  // ensure that user is whitelisted\r\n        Backer storage backer = backers[_contributor];\r\n        require (msg.value >= minInvestment);  // ensure that min contributions amount is met\r\n\r\n        if (backer.weiReceivedOne == 0 && backer.weiReceivedTwo == 0 && backer.weiReceivedMain == 0)\r\n            backersIndex.push(_contributor);\r\n\r\n        if (currentStep == Step.FundingPresaleOne) {          \r\n            backer.weiReceivedOne = backer.weiReceivedOne.add(msg.value);\r\n            ethReceivedPresaleOne = ethReceivedPresaleOne.add(msg.value); // Update the total Ether received in presale 1\r\n            require(ethReceivedPresaleOne <= maxCapEth);  // ensure that max cap hasn't been reached\r\n        }else if (currentStep == Step.FundingPresaleTwo) {           \r\n            backer.weiReceivedTwo = backer.weiReceivedTwo.add(msg.value);\r\n            ethReceivedPresaleTwo = ethReceivedPresaleTwo.add(msg.value);  // Update the total Ether received in presale 2\r\n            require(ethReceivedPresaleOne + ethReceivedPresaleTwo <= maxCapEth);  // ensure that max cap hasn't been reached\r\n        }else if (currentStep == Step.FundingMainSale) {\r\n            backer.weiReceivedMain = backer.weiReceivedMain.add(msg.value);\r\n            ethReceiveMainSale = ethReceiveMainSale.add(msg.value);  // Update the total Ether received in presale 2\r\n            uint tokensToSend = dollarPerEtherRatio.mul(msg.value) / 62;  // calculate amount of tokens to send for this user \r\n            totalTokensSold += tokensToSend;\r\n            require(totalTokensSold <= maxCapTokens);  // ensure that max cap hasn't been reached\r\n        }\r\n        multisig.transfer(msg.value);  // send money to multisignature wallet\r\n\r\n        ReceivedETH(_contributor, currentStep, msg.value); // Register event\r\n        return true;\r\n    }\r\n\r\n\r\n    // @notice This function will finalize the sale.\r\n    // It will only execute if predetermined sale time passed or all tokens were sold\r\n\r\n    function finalizeSale() external onlyOwner() {\r\n        require(dateICOEnded == 0);\r\n        require(currentStep == Step.FundingMainSale);\r\n        // purchasing precise number of tokens might be impractical, thus subtract 1000 tokens so finalization is possible\r\n        // near the end\r\n        require(block.number >= endBlock || totalTokensSold >= maxCapTokens.sub(1000));\r\n        require(totalTokensSold >= minCapTokens);\r\n        \r\n        companyTokensInitial += maxCapTokens - totalTokensSold; // allocate unsold tokens to the company        \r\n        dateICOEnded = now;\r\n        token.unlock();\r\n    }\r\n\r\n\r\n    // @notice this function can be used by owner to update contribution address in case of using address from exchange or incompatible wallet\r\n    // @param _contributorOld - old contributor address\r\n    // @param _contributorNew - new contributor address\r\n    function updateContributorAddress(address _contributorOld, address _contributorNew) public onlyOwner() {\r\n\r\n        Backer storage backerOld = backers[_contributorOld];\r\n        Backer storage backerNew = backers[_contributorNew];\r\n\r\n        require(backerOld.weiReceivedOne > 0 || backerOld.weiReceivedTwo > 0 || backerOld.weiReceivedMain > 0); // make sure that contribution has been made to the old address\r\n        require(backerNew.weiReceivedOne == 0 && backerNew.weiReceivedTwo == 0 && backerNew.weiReceivedMain == 0); // make sure that existing address is not used\r\n        require(backerOld.claimed == false && backerOld.refunded == false);  // ensure that contributor hasn't be refunded or claimed the tokens yet\r\n\r\n        // invalidate old address\r\n        backerOld.claimed = true;\r\n        backerOld.refunded = true;\r\n\r\n        // initialize new address\r\n        backerNew.weiReceivedOne = backerOld.weiReceivedOne;\r\n        backerNew.weiReceivedTwo = backerOld.weiReceivedTwo;\r\n        backerNew.weiReceivedMain = backerOld.weiReceivedMain;\r\n        backersIndex.push(_contributorNew);\r\n    }\r\n\r\n    // @notice called to send tokens to contributors after ICO.\r\n    // @param _backer {address} address of beneficiary\r\n    // @return true if successful\r\n    function claimTokensForUser(address _backer) internal returns(bool) {        \r\n\r\n        require(dateICOEnded > 0); // allow on claiming of tokens if ICO was successful             \r\n\r\n        Backer storage backer = backers[_backer];\r\n\r\n        require (!backer.refunded); // if refunded, don't allow to claim tokens\r\n        require (!backer.claimed); // if tokens claimed, don't allow to claim again\r\n        require (backer.weiReceivedOne > 0 || backer.weiReceivedTwo > 0 || backer.weiReceivedMain > 0);   // only continue if there is any contribution\r\n\r\n        claimCount++;\r\n        uint tokensToSend = (dollarPerEtherRatio * backer.weiReceivedOne) / 48;  // determine amount of tokens to send from first presale\r\n        tokensToSend = tokensToSend + (dollarPerEtherRatio * backer.weiReceivedTwo) / 55;  // determine amount of tokens to send from second presale\r\n        tokensToSend = tokensToSend + (dollarPerEtherRatio * backer.weiReceivedMain) / 62;  // determine amount of tokens to send from main sale\r\n\r\n        claimed[_backer] = tokensToSend;  // save claimed tokens\r\n        backer.claimed = true;\r\n        backer.tokensSent = tokensToSend;\r\n        totalClaimed += tokensToSend;\r\n\r\n        if (!token.transfer(_backer, tokensToSend))\r\n            revert(); // send claimed tokens to contributor account\r\n\r\n        TokensClaimed(_backer,tokensToSend);\r\n        return true;\r\n    }\r\n\r\n\r\n    // @notice contributors can claim tokens after public ICO is finished\r\n    // tokens are only claimable when token address is available.\r\n\r\n    function claimTokens() external {\r\n        claimTokensForUser(msg.sender);\r\n    }\r\n\r\n\r\n    // @notice this function can be called by admin to claim user's token in case of difficulties\r\n    // @param _backer {address} user address to claim tokens for\r\n    function adminClaimTokenForUser(address _backer) external onlyOwner() {\r\n        claimTokensForUser(_backer);\r\n    }\r\n\r\n    // @notice allow refund when ICO failed\r\n    // In such a case contract will need to be funded.\r\n    // Until contract is funded this function will throw\r\n\r\n    function refund() external {\r\n\r\n        require(currentStep == Step.Refunding);                                                          \r\n        require(totalTokensSold < maxCapTokens/2); // ensure that refund is impossible when more than half of the tokens are sold\r\n\r\n        Backer storage backer = backers[msg.sender];\r\n\r\n        require (!backer.claimed); // check if tokens have been allocated already\r\n        require (!backer.refunded); // check if user has been already refunded\r\n\r\n        uint totalEtherReceived = ((backer.weiReceivedOne * returnPercentage) / 100) + backer.weiReceivedTwo + backer.weiReceivedMain;  // return only e.g. 75% from presale one.\r\n        assert(totalEtherReceived > 0);\r\n\r\n        backer.refunded = true; // mark contributor as refunded.\r\n        totalRefunded += totalEtherReceived;\r\n        refundCount ++;\r\n        refunded[msg.sender] = totalRefunded;\r\n\r\n        msg.sender.transfer(totalEtherReceived);  // refund contribution\r\n        Refunded(msg.sender, totalEtherReceived); // log event\r\n    }\r\n\r\n\r\n\r\n    // @notice refund non compliant member \r\n    // @param _contributor {address} of refunded contributor\r\n    function refundNonCompliant(address _contributor) payable external onlyOwner() {\r\n    \r\n        Backer storage backer = backers[_contributor];\r\n\r\n        require (!backer.claimed); // check if tokens have been allocated already\r\n        require (!backer.refunded); // check if user has been already refunded\r\n        backer.refunded = true; // mark contributor as refunded.            \r\n\r\n        uint totalEtherReceived = backer.weiReceivedOne + backer.weiReceivedTwo + backer.weiReceivedMain;\r\n\r\n        require(msg.value == totalEtherReceived); // ensure that exact amount is sent\r\n        assert(totalEtherReceived > 0);\r\n\r\n        //adjust amounts received\r\n        ethReceivedPresaleOne -= backer.weiReceivedOne;\r\n        ethReceivedPresaleTwo -= backer.weiReceivedTwo;\r\n        ethReceiveMainSale -= backer.weiReceivedMain;\r\n        \r\n        totalRefunded += totalEtherReceived;\r\n        refundCount ++;\r\n        refunded[_contributor] = totalRefunded;      \r\n\r\n        uint tokensToSend = (dollarPerEtherRatio * backer.weiReceivedOne) / 48;  // determine amount of tokens to send from first presale\r\n        tokensToSend = tokensToSend + (dollarPerEtherRatio * backer.weiReceivedTwo) / 55;  // determine amount of tokens to send from second presale\r\n        tokensToSend = tokensToSend + (dollarPerEtherRatio * backer.weiReceivedMain) / 62;  // determine amount of tokens to send from main sale\r\n\r\n        if(dateICOEnded == 0) {\r\n            totalTokensSold -= tokensToSend;\r\n        } else {\r\n            companyTokensInitial += tokensToSend;\r\n        }\r\n\r\n        _contributor.transfer(totalEtherReceived);  // refund contribution\r\n        Refunded(_contributor, totalEtherReceived); // log event\r\n    }\r\n\r\n    // @notice Failsafe drain to individual wallet\r\n    function drain() external onlyOwner() {\r\n        multisig.transfer(this.balance);\r\n\r\n    }\r\n\r\n    // @notice Failsafe token transfer\r\n    function tokenDrain() external onlyOwner() {\r\n    if (block.number > endBlock) {\r\n        if (!token.transfer(multisig, token.balanceOf(this)))\r\n                revert();\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n// @notice The token contract\r\ncontract Token is ERC20,  Ownable {\r\n\r\n    using SafeMath for uint;\r\n    // Public variables of the token\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals; // How many decimals to show.\r\n    string public version = \"v0.1\";\r\n    uint public totalSupply;\r\n    uint public initialSupply;\r\n    bool public locked;\r\n    address public crowdSaleAddress;\r\n    address public migrationMaster;\r\n    address public migrationAgent;\r\n    uint256 public totalMigrated;\r\n    address public authorized;\r\n\r\n\r\n    mapping(address => uint) public balances;\r\n    mapping(address => mapping(address => uint)) public allowed;\r\n\r\n    // @notice tokens are locked during the ICO. Allow transfer of tokens after ICO.\r\n    modifier onlyUnlocked() {\r\n        if (msg.sender != crowdSaleAddress && locked)\r\n            revert();\r\n        _;\r\n    }\r\n\r\n\r\n    // @Notice allow minting of tokens only by authorized users\r\n    modifier onlyAuthorized() {\r\n        if (msg.sender != owner && msg.sender != authorized )\r\n            revert();\r\n        _;\r\n    }\r\n\r\n\r\n    // @notice The Token constructor\r\n    // @param _crowdSaleAddress {address} address of crowdsale contract\r\n    // @param _migrationMaster {address} address of authorized migration person\r\n    function Token(address _crowdSaleAddress) public {\r\n\r\n        require(_crowdSaleAddress != 0);\r\n\r\n        locked = true;  // Lock the transfer function during the crowdsale\r\n        initialSupply = 1e26;\r\n        totalSupply = initialSupply;\r\n        name = \"Narrative\"; // Set the name for display purposes\r\n        symbol = \"NRV\"; // Set the symbol for display purposes\r\n        decimals = 18; // Amount of decimals for display purposes\r\n        crowdSaleAddress = _crowdSaleAddress;\r\n        balances[crowdSaleAddress] = initialSupply;\r\n        migrationMaster = owner;\r\n        authorized = _crowdSaleAddress;\r\n    }\r\n\r\n    // @notice unlock tokens for trading\r\n    function unlock() public onlyAuthorized {\r\n        locked = false;\r\n    }\r\n\r\n    // @notice lock tokens in case of problems\r\n    function lock() public onlyAuthorized {\r\n        locked = true;\r\n    }\r\n\r\n    // @notice set authorized party\r\n    // @param _authorized {address} of an individual to get authorization\r\n    function setAuthorized(address _authorized) public onlyOwner {\r\n\r\n        authorized = _authorized;\r\n    }\r\n\r\n\r\n    // Token migration support: as implemented by Golem\r\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n    /// @notice Migrate tokens to the new token contract.\r\n    /// @dev Required state: Operational Migration\r\n    /// @param _value The amount of token to be migrated\r\n    function migrate(uint256 _value)  external {\r\n        // Abort if not in Operational Migration state.\r\n\r\n        require (migrationAgent != 0);\r\n        require(_value > 0);\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        totalSupply = totalSupply.sub(_value);\r\n        totalMigrated = totalMigrated.add(_value);\r\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\r\n        Migrate(msg.sender, migrationAgent, _value);\r\n    }\r\n\r\n    /// @notice Set address of migration target contract and enable migration\r\n    /// process.\r\n    /// @dev Required state: Operational Normal\r\n    /// @dev State transition: -> Operational Migration\r\n    /// @param _agent The address of the MigrationAgent contract\r\n    function setMigrationAgent(address _agent)  external {\r\n        // Abort if not in Operational Normal state.\r\n\r\n        require(migrationAgent == 0);\r\n        require(msg.sender == migrationMaster);\r\n        migrationAgent = _agent;\r\n    }\r\n\r\n    function setMigrationMaster(address _master) external {\r\n        require(msg.sender == migrationMaster);\r\n        require(_master != 0);\r\n        migrationMaster = _master;\r\n    }\r\n\r\n    // @notice mint new tokens with max of 197.5 millions\r\n    // @param _target {address} of receipt\r\n    // @param _mintedAmount {uint} amount of tokens to be minted\r\n    // @return  {bool} true if successful\r\n    function mint(address _target, uint256 _mintedAmount) public onlyAuthorized() returns(bool) {\r\n        assert(totalSupply.add(_mintedAmount) <= 1975e23);  // ensure that max amount ever minted should not exceed 197.5 million tokens with 18 decimals\r\n        balances[_target] = balances[_target].add(_mintedAmount);\r\n        totalSupply = totalSupply.add(_mintedAmount);\r\n        Transfer(0, _target, _mintedAmount);\r\n        return true;\r\n    }\r\n\r\n    // @notice transfer tokens to given address\r\n    // @param _to {address} address or recipient\r\n    // @param _value {uint} amount to transfer\r\n    // @return  {bool} true if successful\r\n    function transfer(address _to, uint _value) public onlyUnlocked returns(bool) {\r\n\r\n        require(_to != address(0));\r\n        require(balances[msg.sender] >= _value);\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n    // @notice transfer tokens from given address to another address\r\n    // @param _from {address} from whom tokens are transferred\r\n    // @param _to {address} to whom tokens are transferred\r\n    // @param _value {uint} amount of tokens to transfer\r\n    // @return  {bool} true if successful\r\n    function transferFrom(address _from, address _to, uint256 _value) public onlyUnlocked returns(bool success) {\r\n\r\n        require(_to != address(0));\r\n        require(balances[_from] >= _value); // Check if the sender has enough\r\n        require(_value <= allowed[_from][msg.sender]); // Check if allowed is greater or equal\r\n        balances[_from] -= _value; // Subtract from the sender\r\n        balances[_to] += _value; // Add the same to the recipient\r\n        allowed[_from][msg.sender] -= _value;  // adjust allowed\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    // @notice to query balance of account\r\n    // @return _owner {address} address of user to query balance\r\n    function balanceOf(address _owner) public view returns(uint balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n    *\r\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _value The amount of tokens to be spent.\r\n    */\r\n    function approve(address _spender, uint _value) public returns(bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n    // @notice to query of allowance of one user to the other\r\n    // @param _owner {address} of the owner of the account\r\n    // @param _spender {address} of the spender of the account\r\n    // @return remaining {uint} amount of remaining allowance\r\n    function allowance(address _owner, address _spender) public view returns(uint remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n    * approve should be called when allowed[_spender] == 0. To increment\r\n    * allowed value is better to use this function to avoid 2 calls (and wait until\r\n    * the first transaction is mined)\r\n    * From MonolithDAO Token.sol\r\n    */\r\n    function increaseApproval (address _spender, uint _addedValue) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {\r\n        uint oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"endBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"refundCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfBackers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"returnWebsiteData\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethReceiveMainSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contributor\",\"type\":\"address\"}],\"name\":\"refundNonCompliant\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"companyTokensCurrent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_returnPercentage\",\"type\":\"uint256\"}],\"name\":\"fundContract\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whiteList\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dollarPerEtherRatio\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multisig\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dateProductCompleted\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalizeSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentStep\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ratio\",\"type\":\"uint256\"}],\"name\":\"setMainSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"tokenDrain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"emergencyStop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethReceivedPresaleTwo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setProductCompletionDate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stopped\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"release\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minInvestment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_backer\",\"type\":\"address\"}],\"name\":\"adminClaimTokenForUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"claimCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_tokensToTransfer\",\"type\":\"uint256\"}],\"name\":\"transferCompanyTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"adjustDuration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setPresaleTwo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"companyTokensInitial\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"drain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contributorOld\",\"type\":\"address\"},{\"name\":\"_contributorNew\",\"type\":\"address\"}],\"name\":\"updateContributorAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"returnPercentage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"backers\",\"outputs\":[{\"name\":\"weiReceivedOne\",\"type\":\"uint256\"},{\"name\":\"weiReceivedTwo\",\"type\":\"uint256\"},{\"name\":\"weiReceivedMain\",\"type\":\"uint256\"},{\"name\":\"tokensSent\",\"type\":\"uint256\"},{\"name\":\"claimed\",\"type\":\"bool\"},{\"name\":\"refunded\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxCapTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"start\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethReceivedPresaleOne\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"refunded\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxCapEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dateICOEnded\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalClaimed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalRefunded\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamTokensInitial\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamTokensCurrent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_tokensToTransfer\",\"type\":\"uint256\"}],\"name\":\"transferTeamTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minCapTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"backersIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_whiteList\",\"type\":\"address\"},{\"name\":\"_multisig\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"backer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"step\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReceivedETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"backer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"TokensClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"backer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Refunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"receipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amouontOfTokens\",\"type\":\"uint256\"}],\"name\":\"LogTeamTokensTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"receipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amouontOfTokens\",\"type\":\"uint256\"}],\"name\":\"LogCompanyTokensTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"CrowdSale","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000156f9176717422089b49c90d9aa20af2841d582c000000000000000000000000BDA6dd717A8e9B9a59aA5E93A9a8f411FCcCF322","Library":"","SwarmSource":"bzzr://06f2ed8eb91a90efc34ea4beeaba176c61346dcbf2cf2e15c01db247e8025360"}]}