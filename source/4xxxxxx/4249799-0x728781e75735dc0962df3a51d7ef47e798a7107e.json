{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.16;\r\n\r\n// SafeMath Taken From FirstBlood\r\ncontract SafeMath {\r\n    function safeMul(uint a, uint b) internal returns (uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function safeDiv(uint a, uint b) internal returns (uint) {\r\n        assert(b > 0);\r\n        uint c = a / b;\r\n        assert(a == b * c + a % b);\r\n        return c;\r\n    }\r\n\r\n    function safeSub(uint a, uint b) internal returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function safeAdd(uint a, uint b) internal returns (uint) {\r\n        uint c = a + b;\r\n        assert(c>=a && c>=b);\r\n        return c;\r\n    }\r\n}\r\n\r\n// Ownership\r\ncontract Owned {\r\n\r\n    address public owner;\r\n    address public newOwner;\r\n    modifier onlyOwner { assert(msg.sender == owner); _; }\r\n\r\n    event OwnerUpdate(address _prevOwner, address _newOwner);\r\n\r\n    function Owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != owner);\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = 0x0;\r\n    }\r\n}\r\n\r\n// ERC20 Interface\r\ncontract ERC20 {\r\n    function totalSupply() constant returns (uint _totalSupply);\r\n    function balanceOf(address _owner) constant returns (uint balance);\r\n    function transfer(address _to, uint _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool success);\r\n    function approve(address _spender, uint _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\n// ERC20Token\r\ncontract ERC20Token is ERC20, SafeMath {\r\n\r\n    mapping(address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalTokens; \r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n            balances[_to] = safeAdd(balances[_to], _value);\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        var _allowance = allowed[_from][msg.sender];\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] = safeAdd(balances[_to], _value);\r\n            balances[_from] = safeSub(balances[_from], _value);\r\n            allowed[_from][msg.sender] = safeSub(_allowance, _value);\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function totalSupply() constant returns (uint256) {\r\n        return totalTokens;\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n}\r\n\r\ncontract Wolk is ERC20Token, Owned {\r\n\r\n    // TOKEN INFO\r\n    string  public constant name = \"Wolk Protocol Token\";\r\n    string  public constant symbol = \"WOLK\";\r\n    uint256 public constant decimals = 18;\r\n\r\n    // RESERVE\r\n    uint256 public reserveBalance = 0; \r\n    uint8  public constant percentageETHReserve = 15;\r\n\r\n    // CONTRACT OWNER\r\n    address public multisigWallet;\r\n\r\n\r\n    // WOLK SETTLERS\r\n    mapping (address => bool) settlers;\r\n    modifier onlySettler { assert(settlers[msg.sender] == true); _; }\r\n\r\n    // TOKEN GENERATION CONTROL\r\n    address public wolkSale;\r\n    bool    public allSaleCompleted = false;\r\n    bool    public openSaleCompleted = false;\r\n    modifier isTransferable { require(allSaleCompleted); _; }\r\n    modifier onlyWolk { assert(msg.sender == wolkSale); _; }\r\n\r\n    // TOKEN GENERATION EVENTLOG\r\n    event WolkCreated(address indexed _to, uint256 _tokenCreated);\r\n    event WolkDestroyed(address indexed _from, uint256 _tokenDestroyed);\r\n    event LogRefund(address indexed _to, uint256 _value);\r\n}\r\n\r\ncontract WolkTGE is Wolk {\r\n\r\n    // TOKEN GENERATION EVENT\r\n    mapping (address => uint256) contribution;\r\n    mapping (address => uint256) presaleLimit;\r\n    mapping (address => bool) presaleContributor;\r\n    uint256 public constant tokenGenerationMin = 50 * 10**6 * 10**decimals;\r\n    uint256 public constant tokenGenerationMax = 150 * 10**6 * 10**decimals;\r\n    uint256 public presale_start_block; \r\n    uint256 public start_block;\r\n    uint256 public end_block;\r\n\r\n    // @param _presaleStartBlock\r\n    // @param _startBlock\r\n    // @param _endBlock\r\n    // @param _wolkWallet\r\n    // @param _wolkSale\r\n    // @return success\r\n    // @dev Wolk Genesis Event [only accessible by Contract Owner]\r\n    function wolkGenesis(uint256 _presaleStartBlock, uint256 _startBlock, uint256 _endBlock, address _wolkWallet, address _wolkSale) onlyOwner returns (bool success){\r\n        require((totalTokens < 1) && (block.number <= _startBlock) && (_endBlock > _startBlock) && (_startBlock > _presaleStartBlock));\r\n        presale_start_block = _presaleStartBlock;\r\n        start_block = _startBlock;\r\n        end_block = _endBlock;\r\n        multisigWallet = _wolkWallet;\r\n        wolkSale = _wolkSale;\r\n        settlers[msg.sender] = true;\r\n        return true;\r\n    }\r\n\r\n    // @param _presaleParticipants\r\n    // @return success\r\n    // @dev Adds addresses that are allowed to take part in presale [only accessible by current Contract Owner]\r\n    function addParticipant(address[] _presaleParticipants, uint256[] _contributionLimits) onlyOwner returns (bool success) {\r\n        require(_presaleParticipants.length == _contributionLimits.length);         \r\n        for (uint cnt = 0; cnt < _presaleParticipants.length; cnt++){           \r\n            presaleContributor[_presaleParticipants[cnt]] = true;\r\n            presaleLimit[_presaleParticipants[cnt]] =  safeMul(_contributionLimits[cnt], 10**decimals);       \r\n        }\r\n        return true;\r\n    } \r\n\r\n    // @param _presaleParticipants\r\n    // @return success\r\n    // @dev Revoke designated presale contributors [only accessible by current Contract Owner]\r\n    function removeParticipant(address[] _presaleParticipants) onlyOwner returns (bool success){         \r\n        for (uint cnt = 0; cnt < _presaleParticipants.length; cnt++){           \r\n            presaleContributor[_presaleParticipants[cnt]] = false;\r\n            presaleLimit[_presaleParticipants[cnt]] = 0;      \r\n        }\r\n        return true;\r\n    }\r\n\r\n    // @param _participant\r\n    // @return remainingAllocation\r\n    // @dev return PresaleLimit allocated to given address\r\n    function participantBalance(address _participant) constant returns (uint256 remainingAllocation) {\r\n        return presaleLimit[_participant];\r\n    }\r\n    \r\n\r\n    // @param _participant\r\n    // @dev use tokenGenerationEvent to handle Pre-sale and Open-sale\r\n    function tokenGenerationEvent(address _participant) payable external {\r\n        require( presaleContributor[_participant] && !openSaleCompleted && !allSaleCompleted && (block.number <= end_block) && msg.value > 0);\r\n\r\n        /* Early Participation Discount (rounded to the nearest integer)\r\n        ---------------------------------\r\n        | Token Issued | Rate | Discount|\r\n        ---------------------------------\r\n        |   0  -  50MM | 1177 |  15.0%  |\r\n        | 50MM -  60MM | 1143 |  12.5%  |\r\n        | 60MM -  70MM | 1111 |  10.0%  |\r\n        | 70MM -  80MM | 1081 |   7.5%  |\r\n        | 80MM -  90MM | 1053 |   5.0%  |         \r\n        | 90MM - 100MM | 1026 |   2.5%  |\r\n        |    100MM+    | 1000 |   0.0%  |\r\n        ---------------------------------\r\n        */\r\n\r\n        uint256 rate = 1000;  // Default Rate\r\n\r\n        if ( totalTokens < (50 * 10**6 * 10**decimals) ) {  \r\n            rate = 1177;\r\n        } else if ( totalTokens < (60 * 10**6 * 10**decimals) ) {  \r\n            rate = 1143;\r\n        } else if ( totalTokens < (70 * 10**6 * 10**decimals) ) {  \r\n            rate = 1111;\r\n        } else if ( totalTokens < (80 * 10**6 * 10**decimals) ) {  \r\n            rate = 1081;\r\n        } else if ( totalTokens < (90 * 10**6 * 10**decimals) ) {  \r\n            rate = 1053;\r\n        } else if ( totalTokens < (100 * 10**6 * 10**decimals) ) {  \r\n            rate = 1026;\r\n        }else{\r\n            rate = 1000;\r\n        }\r\n\r\n        if ((block.number < start_block) && (block.number >= presale_start_block))  { \r\n            require(presaleLimit[_participant] >= msg.value);\r\n            presaleLimit[_participant] = safeSub(presaleLimit[_participant], msg.value);\r\n        } else {\r\n            require(block.number >= start_block) ;\r\n        }\r\n\r\n        uint256 tokens = safeMul(msg.value, rate);\r\n        uint256 checkedSupply = safeAdd(totalTokens, tokens);\r\n        require(checkedSupply <= tokenGenerationMax);\r\n\r\n        totalTokens = checkedSupply;\r\n        Transfer(address(this), _participant, tokens);\r\n        balances[_participant] = safeAdd(balances[_participant], tokens);\r\n        contribution[_participant] = safeAdd(contribution[_participant], msg.value);\r\n        WolkCreated(_participant, tokens); // logs token creation\r\n    }\r\n\r\n\r\n    // @dev If Token Generation Minimum is Not Met, TGE Participants can call this func and request for refund\r\n    function refund() external {\r\n        require((contribution[msg.sender] > 0) && (!allSaleCompleted) && (totalTokens < tokenGenerationMin) && (block.number > end_block));\r\n        uint256 tokenBalance = balances[msg.sender];\r\n        uint256 refundBalance = contribution[msg.sender];\r\n        balances[msg.sender] = 0;\r\n        contribution[msg.sender] = 0;\r\n        totalTokens = safeSub(totalTokens, tokenBalance);\r\n        WolkDestroyed(msg.sender, tokenBalance);\r\n        LogRefund(msg.sender, refundBalance);\r\n        msg.sender.transfer(refundBalance); \r\n    }\r\n\r\n    // @dev Finalizing the Open-Sale for Token Generation Event. 15% of Eth will be kept in contract to provide liquidity\r\n    function finalizeOpenSale() onlyOwner {\r\n        require((!openSaleCompleted) && (totalTokens >= tokenGenerationMin));\r\n        openSaleCompleted = true;\r\n        end_block = block.number;\r\n        reserveBalance = safeDiv(safeMul(totalTokens, percentageETHReserve), 100000);\r\n        var withdrawalBalance = safeSub(this.balance, reserveBalance);\r\n        msg.sender.transfer(withdrawalBalance);\r\n    }\r\n\r\n    // @dev Finalizing the Private-Sale. Entire Eth will be kept in contract to provide liquidity. This func will conclude the entire sale.\r\n    function finalize() onlyWolk payable external {\r\n        require((openSaleCompleted) && (!allSaleCompleted));                                                                                                    \r\n        uint256 privateSaleTokens =  safeDiv(safeMul(msg.value, 100000), percentageETHReserve);\r\n        uint256 checkedSupply = safeAdd(totalTokens, privateSaleTokens);                                                                                                \r\n        totalTokens = checkedSupply;                                                                                                                         \r\n        reserveBalance = safeAdd(reserveBalance, msg.value);                                                                                                 \r\n        Transfer(address(this), wolkSale, privateSaleTokens);                                                                                                              \r\n        balances[wolkSale] = safeAdd(balances[wolkSale], privateSaleTokens);                                                                                                  \r\n        WolkCreated(wolkSale, privateSaleTokens); // logs token creation for Presale events                                                                                                 \r\n        allSaleCompleted = true;                                                                                                                                \r\n    }\r\n}\r\n\r\ncontract IBurnFormula {\r\n    function calculateWolkToBurn(uint256 _value) public constant returns (uint256);\r\n}\r\n\r\ncontract IFeeFormula {\r\n    function calculateProviderFee(uint256 _value) public constant returns (uint256);\r\n}\r\n\r\ncontract WolkProtocol is Wolk {\r\n\r\n    // WOLK NETWORK PROTOCOL\r\n    address public burnFormula;\r\n    bool    public settlementIsRunning = true;\r\n    uint256 public burnBasisPoints = 500;  // Burn rate (in BP) when Service Provider withdraws from data buyers' accounts\r\n    mapping (address => mapping (address => bool)) authorized; // holds which accounts have approved which Service Providers\r\n    mapping (address => uint256) feeBasisPoints;   // Fee (in BP) earned by Service Provider when depositing to data seller\r\n    mapping (address => address) feeFormulas;      // Provider's customizable Fee mormula\r\n    modifier isSettleable { require(settlementIsRunning); _; }\r\n\r\n\r\n    // WOLK PROTOCOL Events:\r\n    event AuthorizeServiceProvider(address indexed _owner, address _serviceProvider);\r\n    event DeauthorizeServiceProvider(address indexed _owner, address _serviceProvider);\r\n    event SetServiceProviderFee(address indexed _serviceProvider, uint256 _feeBasisPoints);\r\n    event BurnTokens(address indexed _from, address indexed _serviceProvider, uint256 _value);\r\n\r\n    // @param  _burnBasisPoints\r\n    // @return success\r\n    // @dev Set BurnRate on Wolk Protocol -- only Wolk can set this, affects Service Provider settleBuyer\r\n    function setBurnRate(uint256 _burnBasisPoints) onlyOwner returns (bool success) {\r\n        require((_burnBasisPoints > 0) && (_burnBasisPoints <= 1000));\r\n        burnBasisPoints = _burnBasisPoints;\r\n        return true;\r\n    }\r\n    \r\n    // @param  _newBurnFormula\r\n    // @return success\r\n    // @dev Set the formula to use for burning -- only Wolk  can set this\r\n    function setBurnFormula(address _newBurnFormula) onlyOwner returns (bool success){\r\n        uint256 testBurning = estWolkToBurn(_newBurnFormula, 10 ** 18);\r\n        require(testBurning > (5 * 10 ** 13));\r\n        burnFormula = _newBurnFormula;\r\n        return true;\r\n    }\r\n    \r\n    // @param  _newFeeFormula\r\n    // @return success\r\n    // @dev Set the formula to use for settlement -- settler can customize its fee  \r\n    function setFeeFormula(address _newFeeFormula) onlySettler returns (bool success){\r\n        uint256 testSettling = estProviderFee(_newFeeFormula, 10 ** 18);\r\n        require(testSettling > (5 * 10 ** 13));\r\n        feeFormulas[msg.sender] = _newFeeFormula;\r\n        return true;\r\n    }\r\n    \r\n    // @param  _isRunning\r\n    // @return success\r\n    // @dev upating settlement status -- only Wolk can set this\r\n    function updateSettlementStatus(bool _isRunning) onlyOwner returns (bool success){\r\n        settlementIsRunning = _isRunning;\r\n        return true;\r\n    }\r\n    \r\n    // @param  _serviceProvider\r\n    // @param  _feeBasisPoints\r\n    // @return success\r\n    // @dev Set Service Provider fee -- only Contract Owner can do this, affects Service Provider settleSeller\r\n    function setServiceFee(address _serviceProvider, uint256 _feeBasisPoints) onlyOwner returns (bool success) {\r\n        if (_feeBasisPoints <= 0 || _feeBasisPoints > 4000){\r\n            // revoke Settler privilege\r\n            settlers[_serviceProvider] = false;\r\n            feeBasisPoints[_serviceProvider] = 0;\r\n            return false;\r\n        }else{\r\n            feeBasisPoints[_serviceProvider] = _feeBasisPoints;\r\n            settlers[_serviceProvider] = true;\r\n            SetServiceProviderFee(_serviceProvider, _feeBasisPoints);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    // @param  _serviceProvider\r\n    // @return _feeBasisPoints\r\n    // @dev Check service Fee (in BP) for a given provider\r\n    function checkServiceFee(address _serviceProvider) constant returns (uint256 _feeBasisPoints) {\r\n        return feeBasisPoints[_serviceProvider];\r\n    }\r\n\r\n    // @param _serviceProvider\r\n    // @return _formulaAddress\r\n    // @dev Returns the contract address of the Service Provider's fee formula\r\n    function checkFeeSchedule(address _serviceProvider) constant returns (address _formulaAddress) {\r\n        return feeFormulas[_serviceProvider];\r\n    }\r\n    \r\n    // @param _value\r\n    // @return wolkBurnt\r\n    // @dev Returns estimate of Wolk to burn \r\n    function estWolkToBurn(address _burnFormula, uint256 _value) constant internal returns (uint256){\r\n        if(_burnFormula != 0x0){\r\n            uint256 wolkBurnt = IBurnFormula(_burnFormula).calculateWolkToBurn(_value);\r\n            return wolkBurnt;    \r\n        }else{\r\n            return 0; \r\n        }\r\n    }\r\n    \r\n    // @param _value\r\n    // @param _serviceProvider\r\n    // @return estFee\r\n    // @dev Returns estimate of Service Provider's fee \r\n    function estProviderFee(address _serviceProvider, uint256 _value) constant internal returns (uint256){\r\n        address ProviderFeeFormula = feeFormulas[_serviceProvider];\r\n        if (ProviderFeeFormula != 0x0){\r\n            uint256 estFee = IFeeFormula(ProviderFeeFormula).calculateProviderFee(_value);\r\n            return estFee;      \r\n        }else{\r\n            return 0;  \r\n        }\r\n    }\r\n    \r\n    // @param  _buyer\r\n    // @param  _value\r\n    // @return success\r\n    // @dev Service Provider Settlement with Buyer: a small percent is burnt (set in setBurnRate, stored in burnBasisPoints) when funds are transferred from buyer to Service Provider [only accessible by settlers]\r\n    function settleBuyer(address _buyer, uint256 _value) onlySettler isSettleable returns (bool success) {\r\n        require((burnBasisPoints > 0) && (burnBasisPoints <= 1000) && authorized[_buyer][msg.sender]); // Buyer must authorize Service Provider \r\n        require(balances[_buyer] >= _value && _value > 0);\r\n        var WolkToBurn = estWolkToBurn(burnFormula, _value);\r\n        var burnCap = safeDiv(safeMul(_value, burnBasisPoints), 10000); //can not burn more than this\r\n\r\n        // If burn formula not found, use default burn rate. If Est to burn exceeds BurnCap, cut back to the cap\r\n        if (WolkToBurn < 1) WolkToBurn = burnCap;\r\n        if (WolkToBurn > burnCap) WolkToBurn = burnCap;\r\n            \r\n        var transferredToServiceProvider = safeSub(_value, WolkToBurn);\r\n        balances[_buyer] = safeSub(balances[_buyer], _value);\r\n        balances[msg.sender] = safeAdd(balances[msg.sender], transferredToServiceProvider);\r\n        totalTokens = safeSub(totalTokens, WolkToBurn);\r\n        Transfer(_buyer, msg.sender, transferredToServiceProvider);\r\n        Transfer(_buyer, 0x00000000000000000000, WolkToBurn);\r\n        BurnTokens(_buyer, msg.sender, WolkToBurn);\r\n        return true;\r\n    } \r\n\r\n    // @param  _seller\r\n    // @param  _value\r\n    // @return success\r\n    // @dev Service Provider Settlement with Seller: a small percent is kept by Service Provider (set in setServiceFee, stored in feeBasisPoints) when funds are transferred from Service Provider to seller [only accessible by settlers]\r\n    function settleSeller(address _seller, uint256 _value) onlySettler isSettleable returns (bool success) {\r\n        // Service Providers have a % max fee (e.g. 20%)\r\n        var serviceProviderBP = feeBasisPoints[msg.sender];\r\n        require((serviceProviderBP > 0) && (serviceProviderBP <= 4000) && (_value > 0));\r\n        var seviceFee = estProviderFee(msg.sender, _value);\r\n        var Maximumfee = safeDiv(safeMul(_value, serviceProviderBP), 10000);\r\n        \r\n        // If provider's fee formula not set, use default burn rate. If Est fee exceeds Maximumfee, cut back to the fee\r\n        if (seviceFee < 1) seviceFee = Maximumfee;  \r\n        if (seviceFee > Maximumfee) seviceFee = Maximumfee;\r\n        var transferredToSeller = safeSub(_value, seviceFee);\r\n        require(balances[msg.sender] >= transferredToSeller );\r\n        balances[_seller] = safeAdd(balances[_seller], transferredToSeller);\r\n        Transfer(msg.sender, _seller, transferredToSeller);\r\n        return true;\r\n    }\r\n\r\n    // @param _providerToAdd\r\n    // @return success\r\n    // @dev Buyer authorizes the Service Provider (to call settleBuyer). For security reason, _providerToAdd needs to be whitelisted by Wolk Inc first\r\n    function authorizeProvider(address _providerToAdd) returns (bool success) {\r\n        require(settlers[_providerToAdd]);\r\n        authorized[msg.sender][_providerToAdd] = true;\r\n        AuthorizeServiceProvider(msg.sender, _providerToAdd);\r\n        return true;\r\n    }\r\n\r\n    // @param _providerToRemove\r\n    // @return success\r\n    // @dev Buyer deauthorizes the Service Provider (from calling settleBuyer)\r\n    function deauthorizeProvider(address _providerToRemove) returns (bool success) {\r\n        authorized[msg.sender][_providerToRemove] = false;\r\n        DeauthorizeServiceProvider(msg.sender, _providerToRemove);\r\n        return true;\r\n    }\r\n\r\n    // @param _owner\r\n    // @param _serviceProvider\r\n    // @return authorizationStatus\r\n    // @dev Check authorization between account and Service Provider\r\n    function checkAuthorization(address _owner, address _serviceProvider) constant returns (bool authorizationStatus) {\r\n        return authorized[_owner][_serviceProvider];\r\n    }\r\n\r\n    // @param _owner\r\n    // @param _providerToAdd\r\n    // @return authorizationStatus\r\n    // @dev Grant authorization between account and Service Provider on buyers' behalf [only accessible by Contract Owner]\r\n    // @note Explicit permission from balance owner MUST be obtained beforehand\r\n    function grantService(address _owner, address _providerToAdd) onlyOwner returns (bool authorizationStatus) {\r\n        var isPreauthorized = authorized[_owner][msg.sender];\r\n        if (isPreauthorized && settlers[_providerToAdd]) {\r\n            authorized[_owner][_providerToAdd] = true;\r\n            AuthorizeServiceProvider(msg.sender, _providerToAdd);\r\n            return true;\r\n        }else{\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // @param _owner\r\n    // @param _providerToRemove\r\n    // @return authorization_status\r\n    // @dev Revoke authorization between account and Service Provider on buyers' behalf [only accessible by Contract Owner]\r\n    // @note Explicit permission from balance owner are NOT required for disabling ill-intent Service Provider\r\n    function removeService(address _owner, address _providerToRemove) onlyOwner returns (bool authorizationStatus) {\r\n        authorized[_owner][_providerToRemove] = false;\r\n        DeauthorizeServiceProvider(_owner, _providerToRemove);\r\n        return true;\r\n    }\r\n}\r\n\r\n// Taken from https://github.com/bancorprotocol/contracts/blob/master/solidity/contracts/BancorFormula.sol\r\ncontract IBancorFormula {\r\n    function calculatePurchaseReturn(uint256 _supply, uint256 _reserveBalance, uint8 _reserveRatio, uint256 _depositAmount) public constant returns (uint256);\r\n    function calculateSaleReturn(uint256 _supply, uint256 _reserveBalance, uint8 _reserveRatio, uint256 _sellAmount) public constant returns (uint256);\r\n}\r\n\r\ncontract WolkExchange is WolkProtocol, WolkTGE {\r\n\r\n    uint256 public maxPerExchangeBP = 50;\r\n    address public exchangeFormula;\r\n    bool    public exchangeIsRunning = false;\r\n    modifier isExchangable { require(exchangeIsRunning && allSaleCompleted); _; }\r\n    \r\n    // @param  _newExchangeformula\r\n    // @return success\r\n    // @dev Set the bancor formula to use -- only Wolk Inc can set this\r\n    function setExchangeFormula(address _newExchangeformula) onlyOwner returns (bool success){\r\n        require(sellWolkEstimate(10**decimals, _newExchangeformula) > 0);\r\n        require(purchaseWolkEstimate(10**decimals, _newExchangeformula) > 0);\r\n        exchangeIsRunning = false;\r\n        exchangeFormula = _newExchangeformula;\r\n        return true;\r\n    }\r\n    \r\n    // @param  _isRunning\r\n    // @return success\r\n    // @dev upating exchange status -- only Wolk Inc can set this\r\n    function updateExchangeStatus(bool _isRunning) onlyOwner returns (bool success){\r\n        if (_isRunning){\r\n            require(sellWolkEstimate(10**decimals, exchangeFormula) > 0);\r\n            require(purchaseWolkEstimate(10**decimals, exchangeFormula) > 0);   \r\n        }\r\n        exchangeIsRunning = _isRunning;\r\n        return true;\r\n    }\r\n    \r\n    // @param  _maxPerExchange\r\n    // @return success\r\n    // @dev Set max sell token amount per transaction -- only Wolk Inc can set this\r\n    function setMaxPerExchange(uint256 _maxPerExchange) onlyOwner returns (bool success) {\r\n        require((_maxPerExchange >= 10) && (_maxPerExchange <= 100));\r\n        maxPerExchangeBP = _maxPerExchange;\r\n        return true;\r\n    }\r\n\r\n    // @return Estimated Liquidation Cap\r\n    // @dev Liquidation Cap per transaction is used to ensure proper price discovery for Wolk Exchange \r\n    function estLiquidationCap() public constant returns (uint256) {\r\n        if (openSaleCompleted){\r\n            var liquidationMax  = safeDiv(safeMul(totalTokens, maxPerExchangeBP), 10000);\r\n            if (liquidationMax < 100 * 10**decimals){ \r\n                liquidationMax = 100 * 10**decimals;\r\n            }\r\n            return liquidationMax;   \r\n        }else{\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function sellWolkEstimate(uint256 _wolkAmountest, address _formula) internal returns(uint256) {\r\n        uint256 ethReceivable =  IBancorFormula(_formula).calculateSaleReturn(totalTokens, reserveBalance, percentageETHReserve, _wolkAmountest);\r\n        return ethReceivable;\r\n    }\r\n    \r\n    function purchaseWolkEstimate(uint256 _ethAmountest, address _formula) internal returns(uint256) {\r\n        uint256 wolkReceivable = IBancorFormula(_formula).calculatePurchaseReturn(totalTokens, reserveBalance, percentageETHReserve, _ethAmountest);\r\n        return wolkReceivable;\r\n    }\r\n    \r\n    // @param _wolkAmount\r\n    // @return ethReceivable\r\n    // @dev send Wolk into contract in exchange for eth, at an exchange rate based on the Bancor Protocol derivation and decrease totalSupply accordingly\r\n    function sellWolk(uint256 _wolkAmount) isExchangable() returns(uint256) {\r\n        uint256 sellCap = estLiquidationCap();\r\n        require((balances[msg.sender] >= _wolkAmount));\r\n        require(sellCap >= _wolkAmount);\r\n        uint256 ethReceivable = sellWolkEstimate(_wolkAmount,exchangeFormula);\r\n        require(this.balance > ethReceivable);\r\n        balances[msg.sender] = safeSub(balances[msg.sender], _wolkAmount);\r\n        totalTokens = safeSub(totalTokens, _wolkAmount);\r\n        reserveBalance = safeSub(this.balance, ethReceivable);\r\n        WolkDestroyed(msg.sender, _wolkAmount);\r\n        Transfer(msg.sender, 0x00000000000000000000, _wolkAmount);\r\n        msg.sender.transfer(ethReceivable);\r\n        return ethReceivable;     \r\n    }\r\n\r\n    // @return wolkReceivable    \r\n    // @dev send eth into contract in exchange for Wolk tokens, at an exchange rate based on the Bancor Protocol derivation and increase totalSupply accordingly\r\n    function purchaseWolk(address _buyer) isExchangable() payable returns(uint256){\r\n        require(msg.value > 0);\r\n        uint256 wolkReceivable = purchaseWolkEstimate(msg.value, exchangeFormula);\r\n        require(wolkReceivable > 0);\r\n        totalTokens = safeAdd(totalTokens, wolkReceivable);\r\n        balances[_buyer] = safeAdd(balances[_buyer], wolkReceivable);\r\n        reserveBalance = safeAdd(reserveBalance, msg.value);\r\n        WolkCreated(_buyer, wolkReceivable);\r\n        Transfer(address(this),_buyer,wolkReceivable);\r\n        return wolkReceivable;\r\n    }\r\n\r\n    // @dev  fallback function for purchase\r\n    // @note Automatically fallback to tokenGenerationEvent before sale is completed. After the token generation event, fallback to purchaseWolk. Liquidity exchange will be enabled through updateExchangeStatus  \r\n    function () payable {\r\n        require(msg.value > 0);\r\n        if(!openSaleCompleted){\r\n            this.tokenGenerationEvent.value(msg.value)(msg.sender);\r\n        }else if (block.number >= end_block){\r\n            this.purchaseWolk.value(msg.value)(msg.sender);\r\n        }else{\r\n            revert();\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_wolkAmount\",\"type\":\"uint256\"}],\"name\":\"sellWolk\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_presaleParticipants\",\"type\":\"address[]\"},{\"name\":\"_contributionLimits\",\"type\":\"uint256[]\"}],\"name\":\"addParticipant\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_providerToAdd\",\"type\":\"address\"}],\"name\":\"authorizeProvider\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_burnBasisPoints\",\"type\":\"uint256\"}],\"name\":\"setBurnRate\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newExchangeformula\",\"type\":\"address\"}],\"name\":\"setExchangeFormula\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangeFormula\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangeIsRunning\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_isRunning\",\"type\":\"bool\"}],\"name\":\"updateExchangeStatus\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_buyer\",\"type\":\"address\"}],\"name\":\"purchaseWolk\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalizeOpenSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"settleBuyer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"end_block\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"settleSeller\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenGenerationMin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_providerToRemove\",\"type\":\"address\"}],\"name\":\"deauthorizeProvider\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_serviceProvider\",\"type\":\"address\"}],\"name\":\"checkAuthorization\",\"outputs\":[{\"name\":\"authorizationStatus\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_serviceProvider\",\"type\":\"address\"}],\"name\":\"checkServiceFee\",\"outputs\":[{\"name\":\"_feeBasisPoints\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxPerExchangeBP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_providerToAdd\",\"type\":\"address\"}],\"name\":\"grantService\",\"outputs\":[{\"name\":\"authorizationStatus\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"burnFormula\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_participant\",\"type\":\"address\"}],\"name\":\"participantBalance\",\"outputs\":[{\"name\":\"remainingAllocation\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"percentageETHReserve\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_providerToRemove\",\"type\":\"address\"}],\"name\":\"removeService\",\"outputs\":[{\"name\":\"authorizationStatus\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multisigWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"estLiquidationCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"burnBasisPoints\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserveBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxPerExchange\",\"type\":\"uint256\"}],\"name\":\"setMaxPerExchange\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_presaleStartBlock\",\"type\":\"uint256\"},{\"name\":\"_startBlock\",\"type\":\"uint256\"},{\"name\":\"_endBlock\",\"type\":\"uint256\"},{\"name\":\"_wolkWallet\",\"type\":\"address\"},{\"name\":\"_wolkSale\",\"type\":\"address\"}],\"name\":\"wolkGenesis\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"settlementIsRunning\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenGenerationMax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"start_block\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"openSaleCompleted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_isRunning\",\"type\":\"bool\"}],\"name\":\"updateSettlementStatus\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presale_start_block\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allSaleCompleted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_presaleParticipants\",\"type\":\"address[]\"}],\"name\":\"removeParticipant\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_serviceProvider\",\"type\":\"address\"},{\"name\":\"_feeBasisPoints\",\"type\":\"uint256\"}],\"name\":\"setServiceFee\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wolkSale\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newBurnFormula\",\"type\":\"address\"}],\"name\":\"setBurnFormula\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newFeeFormula\",\"type\":\"address\"}],\"name\":\"setFeeFormula\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_participant\",\"type\":\"address\"}],\"name\":\"tokenGenerationEvent\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_serviceProvider\",\"type\":\"address\"}],\"name\":\"checkFeeSchedule\",\"outputs\":[{\"name\":\"_formulaAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_serviceProvider\",\"type\":\"address\"}],\"name\":\"AuthorizeServiceProvider\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_serviceProvider\",\"type\":\"address\"}],\"name\":\"DeauthorizeServiceProvider\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_serviceProvider\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_feeBasisPoints\",\"type\":\"uint256\"}],\"name\":\"SetServiceProviderFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_serviceProvider\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"BurnTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenCreated\",\"type\":\"uint256\"}],\"name\":\"WolkCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenDestroyed\",\"type\":\"uint256\"}],\"name\":\"WolkDestroyed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"LogRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_prevOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"WolkExchange","CompilerVersion":"v0.4.16+commit.d7661dd9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://5a8993ccb2a082e5b161703ffa8714e1167abf59d33bf7d082dd1ff418d292fb"}]}