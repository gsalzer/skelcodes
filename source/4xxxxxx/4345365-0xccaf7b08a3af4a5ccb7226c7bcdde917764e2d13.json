{"status":"1","message":"OK","result":[{"SourceCode":"//! FeeRegistrar contract.\r\n//! By Parity Technologies, 2017.\r\n//! Released under the Apache Licence 2.\r\n\r\npragma solidity ^0.4.16;\r\n\r\n// From Owned.sol\r\ncontract Owned {\r\n  /// STORAGE\r\n  address public owner = msg.sender;\r\n\r\n  /// EVENTS\r\n  event NewOwner(address indexed old, address indexed current);\r\n\r\n  /// MODIFIERS\r\n  modifier only_owner { require (msg.sender == owner); _; }\r\n\r\n  /// RESTRICTED PUBLIC METHODS\r\n  function setOwner(address _new) public only_owner { NewOwner(owner, _new); owner = _new; }\r\n}\r\n\r\n/// @title Delegated Contract\r\n/// @notice This contract can be used to have a a system of delegates\r\n/// who can be authorized to execute certain methods. A (super-)owner\r\n/// is set, who can modify the delegates.\r\ncontract Delegated is Owned {\r\n  /// STORAGE\r\n  mapping (address => bool) delegates;\r\n\r\n  /// MODIFIERS\r\n  modifier only_delegate { require (msg.sender == owner || delegates[msg.sender]); _; }\r\n\r\n  /// PUBLIC METHODS\r\n  function delegate(address who) public constant returns (bool) { return who == owner || delegates[who]; }\r\n\r\n  /// RESTRICTED PUBLIC METHODS\r\n  function addDelegate(address _new) public only_owner { delegates[_new] = true; }\r\n  function removeDelegate(address _old) public only_owner { delete delegates[_old]; }\r\n}\r\n\r\n/// @title Fee Registrar\r\n/// @author Nicolas Gotchac <nicolas@parity.io>\r\n/// @notice This contract records fee payments. The address who deploys the contract\r\n/// is set as the `owner` of the contract (which can be later modified). The `fee`\r\n/// which users will have to pay must be specified, as well as the address of the treasury\r\n/// to which the fee will be forwarded to.\r\n/// A payment is a transaction with the value set as the `fee` value, and an address is\r\n/// given as an argument. The given address will be marked as _paid for_, and the number\r\n/// of times it was paid for will be recorded. We also record who is at the origin of the\r\n/// payment.\r\n/// For example, Alice can pay for Bob, and Eve can pay for Bob as well. This contract\r\n/// will record that Bob is marked as paid, 2 times, by Alice and Eve.\r\n/// A payment can be revoked by specified delegates, and the fund should be restored to\r\n/// the payer of the fee.\r\ncontract FeeRegistrar is Delegated {\r\n  /// STORAGE\r\n  address public treasury;\r\n  uint public fee;\r\n\r\n  // a mapping of addresses to the origin of payments struct\r\n  mapping(address => address[]) s_paid;\r\n\r\n\r\n  /// EVENTS\r\n  event Paid (address who, address payer);\r\n\r\n\r\n  /// CONSTRUCTOR\r\n\r\n  /// @notice Contructor method of the contract, which\r\n  /// will set the `treasury` where payments will be send to,\r\n  /// and the `fee` users have to pay\r\n  /// @param _treasury The address to which the payments will be forwarded\r\n  /// @param _fee The fee users have to pay, in wei\r\n  function FeeRegistrar (address _treasury, uint _fee) public {\r\n    owner = msg.sender;\r\n    treasury = _treasury;\r\n    fee = _fee;\r\n  }\r\n\r\n\r\n  /// PUBLIC CONSTANT METHODS\r\n\r\n  /// @notice Returns for the given address the number of times\r\n  /// it was paid for, and an array of addresses who actually paid for the fee\r\n  /// (as one might pay the fee for another address)\r\n  /// @param who The address of the payer whose info we check\r\n  /// @return The count (number of payments) and the origins (the senders of the\r\n  /// payment)\r\n  function payer (address who) public constant returns (uint count, address[] origins) {\r\n    address[] memory m_origins = s_paid[who];\r\n\r\n    return (m_origins.length, m_origins);\r\n  }\r\n\r\n  /// @notice Returns whether the given address paid or not\r\n  /// @param who The address whose payment status we check\r\n  /// @ return Whether the address is marked as paid or not\r\n  function paid (address who) public constant returns (bool) {\r\n    return s_paid[who].length > 0;\r\n  }\r\n\r\n\r\n  /// PUBLIC METHODS\r\n\r\n  /// @notice This method is used to pay for the fee. You can pay\r\n  /// the fee for one address (then marked as paid), from another\r\n  /// address. The origin of the transaction, the\r\n  /// fee payer (`msg.sender`) is stored in an array.\r\n  /// The value of the transaction must\r\n  /// match the fee that was set in the contructor.\r\n  /// The only restriction is that you can't pay for the null\r\n  /// address.\r\n  /// You also can't pay more than 10 times for the same address\r\n  /// The value that is received is directly transfered to the\r\n  /// `treasury`.\r\n  /// @param who The address which should be marked as paid.\r\n  function pay (address who) external payable {\r\n    // We first check that the given address is not the null address\r\n    require(who != 0x0);\r\n    // Then check that the value matches with the fee\r\n    require(msg.value == fee);\r\n    // Maximum 10 payments per address\r\n    require(s_paid[who].length < 10);\r\n\r\n    s_paid[who].push(msg.sender);\r\n\r\n    // Send the paid event\r\n    Paid(who, msg.sender);\r\n\r\n    // Send the message value to the treasury\r\n    treasury.transfer(msg.value);\r\n  }\r\n\r\n\r\n  /// RESTRICTED (owner or delegate only) PUBLIC METHODS\r\n\r\n  /// @notice This method can only be called by the contract\r\n  /// owner, and can be used to virtually create a new payment,\r\n  /// by `origin` for `who`.\r\n  /// @param who The address that `origin` paid for\r\n  /// @param origin The virtual sender of the payment\r\n  function inject (address who, address origin) external only_owner {\r\n    // Add the origin address to the list of payers\r\n    s_paid[who].push(origin);\r\n    // Emit the `Paid` event\r\n    Paid(who, origin);\r\n  }\r\n\r\n  /// @notice This method can be called by authorized persons only,\r\n  /// and can issue a refund of the fee to the `origin` address who\r\n  /// paid the fee for `who`.\r\n  /// @param who The address that `origin` paid for\r\n  /// @param origin The sender of the payment, to which we shall\r\n  /// send the refund\r\n  function revoke (address who, address origin) payable external only_delegate {\r\n    // The value must match the current fee, so we can refund\r\n    // the payer, since the contract doesn't hold anything.\r\n    require(msg.value == fee);\r\n    bool found;\r\n\r\n    // Go through the list of payers to find\r\n    // the remove the right one\r\n    // NB : this list is limited to 10 items,\r\n    //      @see the `pay` method\r\n    for (uint i = 0; i < s_paid[who].length; i++) {\r\n      if (s_paid[who][i] != origin) {\r\n        continue;\r\n      }\r\n\r\n      // If the origin payer is found\r\n      found = true;\r\n\r\n      uint last = s_paid[who].length - 1;\r\n\r\n      // Switch the last element of the array\r\n      // with the one to remove\r\n      s_paid[who][i] = s_paid[who][last];\r\n\r\n      // Remove the last element of the array\r\n      delete s_paid[who][last];\r\n      s_paid[who].length -= 1;\r\n\r\n      break;\r\n    }\r\n\r\n    // Ensure that the origin payer has been found\r\n    require(found);\r\n\r\n    // Refund the fee to the origin payer\r\n    origin.transfer(msg.value);\r\n  }\r\n\r\n  /// @notice Change the address of the treasury, the address to which\r\n  /// the payments are forwarded to. Only the owner of the contract\r\n  /// can execute this method.\r\n  /// @param _treasury The new treasury address\r\n  function setTreasury (address _treasury) external only_owner {\r\n    treasury = _treasury;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"pay\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"delegate\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_old\",\"type\":\"address\"}],\"name\":\"removeDelegate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"},{\"name\":\"origin\",\"type\":\"address\"}],\"name\":\"inject\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"paid\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"},{\"name\":\"origin\",\"type\":\"address\"}],\"name\":\"revoke\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"payer\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"},{\"name\":\"origins\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"addDelegate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_treasury\",\"type\":\"address\"}],\"name\":\"setTreasury\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_treasury\",\"type\":\"address\"},{\"name\":\"_fee\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"payer\",\"type\":\"address\"}],\"name\":\"Paid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"old\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"current\",\"type\":\"address\"}],\"name\":\"NewOwner\",\"type\":\"event\"}]","ContractName":"FeeRegistrar","CompilerVersion":"v0.4.17+commit.bdeb9e52","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000024f1e02ebcb004dd7671186ec439e3804a5cc000000000000000000000000000000000000000000000000000470de4df820000","Library":"","SwarmSource":"bzzr://69371c81d4974edd3133dd9d0edab1a8cc0ae6694747c2febc59b00cfe017cb2"}]}