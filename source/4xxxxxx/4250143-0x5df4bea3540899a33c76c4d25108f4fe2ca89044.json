{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\ncontract RPS {\r\n    enum State { Unrealized, Created, Joined, Ended }\r\n    enum Result { Unfinished, Draw, Win, Loss, Forfeit } // From the perspective of player 1\r\n    struct Game {\r\n        address player1;\r\n        address player2;\r\n        uint value;\r\n        bytes32 hiddenMove1;\r\n        uint8 move1; // 0 = not set, 1 = Rock, 2 = Paper, 3 = Scissors\r\n        uint8 move2;\r\n        uint gameStart;\r\n        State state;\r\n        Result result;\r\n    }\r\n    \r\n    address public owner1;\r\n    address public owner2;\r\n    uint8 constant feeDivisor = 100;\r\n    uint constant revealTime = 7 days; // TODO: dynamic reveal times?\r\n    bool paused;\r\n    bool expired;\r\n    uint gameIdCounter;\r\n    \r\n    uint constant minimumNameLength = 1;\r\n    uint constant maximumNameLength = 25;\r\n    \r\n    event NewName(address indexed player, string name);\r\n    event Donate(address indexed player, uint amount);\r\n    event Deposit(address indexed player, uint amount);\r\n    event Withdraw(address indexed player, uint amount);\r\n    event GameCreated(address indexed player1, address indexed player2, uint indexed gameId, uint value, bytes32 hiddenMove1);\r\n    event GameJoined(address indexed player1, address indexed player2, uint indexed gameId, uint value, uint8 move2, uint gameStart);\r\n    event GameEnded(address indexed player1, address indexed player2, uint indexed gameId, uint value, Result result);\r\n    \r\n    mapping(address => uint) public balances;\r\n    mapping(address => uint) public totalWon;\r\n    mapping(address => uint) public totalLost;\r\n    \r\n    Game [] public games;\r\n    mapping(address => string) public playerNames;\r\n    mapping(uint => bool) public nameTaken;\r\n    mapping(bytes32 => bool) public secretTaken;\r\n    \r\n    modifier onlyOwner { require(msg.sender == owner1 || msg.sender == owner2); _; }\r\n    modifier notPaused { require(!paused); _; }\r\n    modifier notExpired { require(!expired); _; }\r\n    \r\n\r\n    function RPS(address otherOwner) {\r\n        owner1 = msg.sender;\r\n        owner2 = otherOwner;\r\n        paused = true;\r\n    }\r\n    \r\n    // UTILIY FUNCTIONS\r\n    //\r\n    // FOR DOING BORING REPETITIVE TASKS\r\n    \r\n    function getGames() constant internal returns (Game []) {\r\n        return games;\r\n    }\r\n    \r\n    function totalProfit(address player) constant returns (int) {\r\n        if (totalLost[player] > totalWon[player]) {\r\n            return -int(totalLost[player] - totalWon[player]);\r\n        }\r\n        else {\r\n            return int(totalWon[player] - totalLost[player]);\r\n        }\r\n    }\r\n    // Fuzzy hash and name validation taken from King of the Ether Throne\r\n    // https://github.com/kieranelby/KingOfTheEtherThrone/blob/v1.0/contracts/KingOfTheEtherThrone.sol\r\n    \r\n    function computeNameFuzzyHash(string _name) constant internal\r\n    returns (uint fuzzyHash) {\r\n        bytes memory nameBytes = bytes(_name);\r\n        uint h = 0;\r\n        uint len = nameBytes.length;\r\n        if (len > maximumNameLength) {\r\n            len = maximumNameLength;\r\n        }\r\n        for (uint i = 0; i < len; i++) {\r\n            uint mul = 128;\r\n            byte b = nameBytes[i];\r\n            uint ub = uint(b);\r\n            if (b >= 48 && b <= 57) {\r\n                // 0-9\r\n                h = h * mul + ub;\r\n            } else if (b >= 65 && b <= 90) {\r\n                // A-Z\r\n                h = h * mul + ub;\r\n            } else if (b >= 97 && b <= 122) {\r\n                // fold a-z to A-Z\r\n                uint upper = ub - 32;\r\n                h = h * mul + upper;\r\n            } else {\r\n                // ignore others\r\n            }\r\n        }\r\n        return h;\r\n    }\r\n    /// @return True if-and-only-if `_name_` meets the criteria\r\n    /// below, or false otherwise:\r\n    ///   - no fewer than 1 character\r\n    ///   - no more than 25 characters\r\n    ///   - no characters other than:\r\n    ///     - \"roman\" alphabet letters (A-Z and a-z)\r\n    ///     - western digits (0-9)\r\n    ///     - \"safe\" punctuation: ! ( ) - . _ SPACE\r\n    ///   - at least one non-punctuation character\r\n    /// Note that we deliberately exclude characters which may cause\r\n    /// security problems for websites and databases if escaping is\r\n    /// not performed correctly, such as < > \" and '.\r\n    /// Apologies for the lack of non-English language support.\r\n    function validateNameInternal(string _name) constant internal\r\n    returns (bool allowed) {\r\n        bytes memory nameBytes = bytes(_name);\r\n        uint lengthBytes = nameBytes.length;\r\n        if (lengthBytes < minimumNameLength ||\r\n            lengthBytes > maximumNameLength) {\r\n            return false;\r\n        }\r\n        bool foundNonPunctuation = false;\r\n        for (uint i = 0; i < lengthBytes; i++) {\r\n            byte b = nameBytes[i];\r\n            if (\r\n                (b >= 48 && b <= 57) || // 0 - 9\r\n                (b >= 65 && b <= 90) || // A - Z\r\n                (b >= 97 && b <= 122)   // a - z\r\n            ) {\r\n                foundNonPunctuation = true;\r\n                continue;\r\n            }\r\n            if (\r\n                b == 32 || // space\r\n                b == 33 || // !\r\n                b == 40 || // (\r\n                b == 41 || // )\r\n                b == 45 || // -\r\n                b == 46 || // .\r\n                b == 95    // _\r\n            ) {\r\n                continue;\r\n            }\r\n            return false;\r\n        }\r\n        return foundNonPunctuation;\r\n    }\r\n    \r\n    \r\n    /// if you want to donate, please use the donate function\r\n    function() { require(false); }\r\n    \r\n    // PLAYER FUNCTIONS\r\n    //\r\n    // FOR PLAYERS\r\n    \r\n    /// Name must only include upper and lowercase English letters,\r\n    /// numbers, and certain characters: ! ( ) - . _ SPACE\r\n    /// Function will return false if the name is not valid\r\n    /// or if it's too similar to a name that's already taken.\r\n    function setName(string name) returns (bool success) {\r\n        require (validateNameInternal(name));\r\n        uint fuzzyHash = computeNameFuzzyHash(name);\r\n        uint oldFuzzyHash;\r\n        string storage oldName = playerNames[msg.sender];\r\n        bool oldNameEmpty = bytes(oldName).length == 0;\r\n        if (nameTaken[fuzzyHash]) {\r\n            require(!oldNameEmpty);\r\n            oldFuzzyHash = computeNameFuzzyHash(oldName);\r\n            require(fuzzyHash == oldFuzzyHash);\r\n        }\r\n        else {\r\n            if (!oldNameEmpty) {\r\n                oldFuzzyHash = computeNameFuzzyHash(oldName);\r\n                nameTaken[oldFuzzyHash] = false;\r\n            }\r\n            nameTaken[fuzzyHash] = true;\r\n        }\r\n        playerNames[msg.sender] = name;\r\n\r\n        NewName(msg.sender, name);\r\n        return true;\r\n    }\r\n    \r\n    //{\r\n    /// Create a game that may be joined only by the address provided.\r\n    /// If no address is provided, the game is open to anyone.\r\n    /// Your bet is equal to the value sent together\r\n    /// with this transaction. If the game is a draw,\r\n    /// your bet will be available for withdrawal.\r\n    /// If you win, both bets minus the fee will be send to you.\r\n    /// The first argument should be the number\r\n    /// of your move (rock: 1, paper: 2, scissors: 3)\r\n    /// encrypted with keccak256(uint move, string secret) and\r\n    /// save the secret so you can reveal your move\r\n    /// after your game is joined.\r\n    /// It's very easy to mess up the padding and stuff,\r\n    /// so you should just use the website.\r\n    //}\r\n    function createGame(bytes32 move, uint val, address player2)\r\n    payable notPaused notExpired returns (uint gameId) {\r\n        deposit();\r\n        require(balances[msg.sender] >= val);\r\n        require(!secretTaken[move]);\r\n        secretTaken[move] = true;\r\n        balances[msg.sender] -= val;\r\n        gameId = gameIdCounter;\r\n        games.push(Game(msg.sender, player2, val, move, 0, 0, 0, State.Created, Result(0)));\r\n\r\n        GameCreated(msg.sender, player2, gameId, val, move);\r\n        gameIdCounter++;\r\n    }\r\n    \r\n    function abortGame(uint gameId) notPaused returns (bool success) {\r\n        Game storage thisGame = games[gameId];\r\n        require(thisGame.player1 == msg.sender);\r\n        require(thisGame.state == State.Created);\r\n        thisGame.state = State.Ended;\r\n\r\n        GameEnded(thisGame.player1, thisGame.player2, gameId, thisGame.value, Result(0));\r\n\r\n        msg.sender.transfer(thisGame.value);\r\n        return true;\r\n    }\r\n    \r\n    function joinGame(uint gameId, uint8 move) payable notPaused returns (bool success) {\r\n        Game storage thisGame = games[gameId];\r\n        require(thisGame.state == State.Created);\r\n        require(move > 0 && move <= 3);\r\n        if (thisGame.player2 == 0x0) {\r\n            thisGame.player2 = msg.sender;\r\n        }\r\n        else {\r\n            require(thisGame.player2 == msg.sender);\r\n        }\r\n        require(thisGame.value == msg.value);\r\n        thisGame.gameStart = now;\r\n        thisGame.state = State.Joined;\r\n        thisGame.move2 = move;\r\n\r\n        GameJoined(thisGame.player1, thisGame.player2, gameId, thisGame.value, thisGame.move2, thisGame.gameStart);\r\n        return true;\r\n    }\r\n    \r\n    function revealMove(uint gameId, uint8 move, string secret) notPaused returns (Result result) {\r\n        Game storage thisGame = games[gameId];\r\n        require(thisGame.state == State.Joined);\r\n        require(thisGame.player1 == msg.sender);\r\n        require(thisGame.gameStart + revealTime >= now); // It's not too late to reveal\r\n        require(thisGame.hiddenMove1 == keccak256(uint(move), secret));\r\n        thisGame.move1 = move;\r\n        if (move > 0 && move <= 3) {\r\n            result = Result(((3 + move - thisGame.move2) % 3) + 1); // It works trust me (it's 'cause of math)\r\n        }\r\n        else { // Player 1 submitted invalid move\r\n            result = Result.Loss;\r\n        }\r\n        thisGame.state = State.Ended;\r\n        address winner;\r\n        if (result == Result.Draw) {\r\n            balances[thisGame.player1] += thisGame.value;\r\n            balances[thisGame.player2] += thisGame.value;\r\n        }\r\n        else {\r\n            if (result == Result.Win) {\r\n                winner = thisGame.player1;\r\n                totalLost[thisGame.player2] += thisGame.value;\r\n            }\r\n            else {\r\n                winner = thisGame.player2;\r\n                totalLost[thisGame.player1] += thisGame.value;\r\n            }\r\n            uint fee = (thisGame.value) / feeDivisor; // 0.5% fee taken once for each owner\r\n            balances[owner1] += fee;\r\n            balances[owner2] += fee;\r\n            totalWon[winner] += thisGame.value - fee*2;\r\n            // No re-entrancy attack is possible because\r\n            // the state has already been set to State.Ended\r\n            winner.transfer((thisGame.value*2) - fee*2);\r\n        }\r\n        thisGame.result = result;\r\n\r\n        GameEnded(thisGame.player1, thisGame.player2, gameId, thisGame.value, result);\r\n    }\r\n    \r\n    /// Use this when you know you've lost as player 1 and\r\n    /// you don't want to bother with revealing your move.\r\n    function forfeitGame(uint gameId) notPaused returns (bool success) {\r\n        Game storage thisGame = games[gameId];\r\n        require(thisGame.state == State.Joined);\r\n        require(thisGame.player1 == msg.sender);\r\n        \r\n        uint fee = (thisGame.value) / feeDivisor; // 0.5% fee taken once for each owner\r\n        balances[owner1] += fee;\r\n        balances[owner2] += fee;\r\n        totalLost[thisGame.player1] += thisGame.value;\r\n        totalWon[thisGame.player2] += thisGame.value - fee*2;\r\n        thisGame.state = State.Ended;\r\n        thisGame.result = Result.Forfeit; // Loss for player 1\r\n\r\n        GameEnded(thisGame.player1, thisGame.player2, gameId, thisGame.value, thisGame.result);\r\n        \r\n        thisGame.player2.transfer((thisGame.value*2) - fee*2);\r\n        return true;\r\n    }\r\n    \r\n    function claimGame(uint gameId) notPaused returns (bool success) {\r\n        Game storage thisGame = games[gameId];\r\n        require(thisGame.state == State.Joined);\r\n        require(thisGame.player2 == msg.sender);\r\n        require(thisGame.gameStart + revealTime < now); // Player 1 has failed to reveal in time\r\n        \r\n        uint fee = (thisGame.value) / feeDivisor; // 0.5% fee taken once for each owner\r\n        balances[owner1] += fee;\r\n        balances[owner2] += fee;\r\n        totalLost[thisGame.player1] += thisGame.value;\r\n        totalWon[thisGame.player2] += thisGame.value - fee*2;\r\n        thisGame.state = State.Ended;\r\n        thisGame.result = Result.Forfeit; // Loss for player 1\r\n        \r\n        GameEnded(thisGame.player1, thisGame.player2, gameId, thisGame.value, thisGame.result);\r\n\r\n        thisGame.player2.transfer((thisGame.value*2) - fee*2);\r\n        return true;\r\n    }\r\n    \r\n    // FUNDING FUNCTIONS\r\n    //\r\n    // FOR FUNDING\r\n    function donate() payable returns (bool success) {\r\n        require(msg.value != 0);\r\n        balances[owner1] += msg.value/2;\r\n        balances[owner2] += msg.value - msg.value/2;\r\n\r\n        Donate(msg.sender, msg.value);\r\n        return true;\r\n    }\r\n    function deposit() payable returns (bool success) {\r\n        require(msg.value != 0);\r\n        balances[msg.sender] += msg.value;\r\n\r\n        Deposit(msg.sender, msg.value);\r\n        return true;\r\n    }\r\n    function withdraw() returns (bool success) {\r\n        uint amount = balances[msg.sender];\r\n        if (amount == 0) return false;\r\n        balances[msg.sender] = 0;\r\n        msg.sender.transfer(amount);\r\n\r\n        Withdraw(msg.sender, amount);\r\n        return true;\r\n    }\r\n    \r\n    // ADMIN FUNCTIONS\r\n    //\r\n    // FOR ADMINISTRATING\r\n    \r\n    // Pause all gameplay\r\n    function pause(bool pause) onlyOwner {\r\n        paused = pause;\r\n    }\r\n    \r\n    // Prevent new games from being created\r\n    // To be used when switching to a new contract\r\n    function expire(bool expire) onlyOwner {\r\n        expired = expire;\r\n    }\r\n    \r\n    function setOwner1(address newOwner) {\r\n        require(msg.sender == owner1);\r\n        owner1 = newOwner;\r\n    }\r\n    \r\n    function setOwner2(address newOwner) {\r\n        require(msg.sender == owner2);\r\n        owner2 = newOwner;\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"pause\",\"type\":\"bool\"}],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"games\",\"outputs\":[{\"name\":\"player1\",\"type\":\"address\"},{\"name\":\"player2\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"hiddenMove1\",\"type\":\"bytes32\"},{\"name\":\"move1\",\"type\":\"uint8\"},{\"name\":\"move2\",\"type\":\"uint8\"},{\"name\":\"gameStart\",\"type\":\"uint256\"},{\"name\":\"state\",\"type\":\"uint8\"},{\"name\":\"result\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner1\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gameId\",\"type\":\"uint256\"}],\"name\":\"claimGame\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"playerNames\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalLost\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner2\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner2\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nameTaken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner1\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"expire\",\"type\":\"bool\"}],\"name\":\"expire\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"move\",\"type\":\"bytes32\"},{\"name\":\"val\",\"type\":\"uint256\"},{\"name\":\"player2\",\"type\":\"address\"}],\"name\":\"createGame\",\"outputs\":[{\"name\":\"gameId\",\"type\":\"uint256\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gameId\",\"type\":\"uint256\"}],\"name\":\"forfeitGame\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gameId\",\"type\":\"uint256\"}],\"name\":\"abortGame\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"totalProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"secretTaken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gameId\",\"type\":\"uint256\"},{\"name\":\"move\",\"type\":\"uint8\"},{\"name\":\"secret\",\"type\":\"string\"}],\"name\":\"revealMove\",\"outputs\":[{\"name\":\"result\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"}],\"name\":\"setName\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gameId\",\"type\":\"uint256\"},{\"name\":\"move\",\"type\":\"uint8\"}],\"name\":\"joinGame\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"donate\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalWon\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"otherOwner\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":false,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"}],\"name\":\"NewName\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Donate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player1\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"player2\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"gameId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"hiddenMove1\",\"type\":\"bytes32\"}],\"name\":\"GameCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player1\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"player2\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"gameId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"move2\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"gameStart\",\"type\":\"uint256\"}],\"name\":\"GameJoined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player1\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"player2\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"gameId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"result\",\"type\":\"uint8\"}],\"name\":\"GameEnded\",\"type\":\"event\"}]","ContractName":"RPS","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000001337f2f751dd3d33717890b905665db457b90771","Library":"","SwarmSource":"bzzr://6efdff4f2b8d471875b9932830f1cb8516e742dab2186d5ff8f6b7412b67b75e"}]}