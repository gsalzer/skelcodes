{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    require(newOwner != address(0));\r\n    owner = newOwner;\r\n  }\r\n}\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\r\n    assert(token.transfer(to, value));\r\n  }\r\n  function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\r\n    assert(token.transferFrom(from, to, value));\r\n  }\r\n  function safeApprove(ERC20 token, address spender, uint256 value) internal {\r\n    assert(token.approve(spender, value));\r\n  }\r\n}\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\ncontract SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n}\r\n/**\r\n * @title KYC\r\n * @dev KYC contract handles the white list for ASTCrowdsale contract\r\n * Only accounts registered in KYC contract can buy AST token.\r\n * Admins can register account, and the reason why\r\n */\r\ncontract KYC is Ownable {\r\n  // check the address is registered for token sale\r\n  mapping (address => bool) public registeredAddress;\r\n  // check the address is admin of kyc contract\r\n  mapping (address => bool) public admin;\r\n  event Registered(address indexed _addr);\r\n  event Unregistered(address indexed _addr);\r\n  event NewAdmin(address indexed _addr);\r\n  event ClaimedTokens(address _token, address owner, uint256 balance);\r\n  /**\r\n   * @dev check whether the address is registered for token sale or not.\r\n   * @param _addr address\r\n   */\r\n  modifier onlyRegistered(address _addr) {\r\n    require(registeredAddress[_addr]);\r\n    _;\r\n  }\r\n  /**\r\n   * @dev check whether the msg.sender is admin or not\r\n   */\r\n  modifier onlyAdmin() {\r\n    require(admin[msg.sender]);\r\n    _;\r\n  }\r\n  function KYC() {\r\n    admin[msg.sender] = true;\r\n  }\r\n  /**\r\n   * @dev set new admin as admin of KYC contract\r\n   * @param _addr address The address to set as admin of KYC contract\r\n   */\r\n  function setAdmin(address _addr)\r\n    public\r\n    onlyOwner\r\n  {\r\n    require(_addr != address(0) && admin[_addr] == false);\r\n    admin[_addr] = true;\r\n    NewAdmin(_addr);\r\n  }\r\n  /**\r\n   * @dev register the address for token sale\r\n   * @param _addr address The address to register for token sale\r\n   */\r\n  function register(address _addr)\r\n    public\r\n    onlyAdmin\r\n  {\r\n    require(_addr != address(0) && registeredAddress[_addr] == false);\r\n    registeredAddress[_addr] = true;\r\n    Registered(_addr);\r\n  }\r\n  /**\r\n   * @dev register the addresses for token sale\r\n   * @param _addrs address[] The addresses to register for token sale\r\n   */\r\n  function registerByList(address[] _addrs)\r\n    public\r\n    onlyAdmin\r\n  {\r\n    for(uint256 i = 0; i < _addrs.length; i++) {\r\n      require(_addrs[i] != address(0) && registeredAddress[_addrs[i]] == false);\r\n      registeredAddress[_addrs[i]] = true;\r\n      Registered(_addrs[i]);\r\n    }\r\n  }\r\n  /**\r\n   * @dev unregister the registered address\r\n   * @param _addr address The address to unregister for token sale\r\n   */\r\n  function unregister(address _addr)\r\n    public\r\n    onlyAdmin\r\n    onlyRegistered(_addr)\r\n  {\r\n    registeredAddress[_addr] = false;\r\n    Unregistered(_addr);\r\n  }\r\n  /**\r\n   * @dev unregister the registered addresses\r\n   * @param _addrs address[] The addresses to unregister for token sale\r\n   */\r\n  function unregisterByList(address[] _addrs)\r\n    public\r\n    onlyAdmin\r\n  {\r\n    for(uint256 i = 0; i < _addrs.length; i++) {\r\n      require(registeredAddress[_addrs[i]]);\r\n      registeredAddress[_addrs[i]] = false;\r\n      Unregistered(_addrs[i]);\r\n    }\r\n  }\r\n  function claimTokens(address _token) public onlyOwner {\r\n    if (_token == 0x0) {\r\n        owner.transfer(this.balance);\r\n        return;\r\n    }\r\n    ERC20Basic token = ERC20Basic(_token);\r\n    uint256 balance = token.balanceOf(this);\r\n    token.transfer(owner, balance);\r\n    ClaimedTokens(_token, owner, balance);\r\n  }\r\n}\r\n/*\r\n    Copyright 2016, Jordi Baylina\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\n/// @title MiniMeToken Contract\r\n/// @author Jordi Baylina\r\n/// @dev This token contract's goal is to make it easy for anyone to clone this\r\n///  token using the token distribution at a given block, this will allow DAO's\r\n///  and DApps to upgrade their features in a decentralized manner without\r\n///  affecting the original token\r\n/// @dev It is ERC20 compliant, but still needs to under go further testing.\r\ncontract Controlled {\r\n    /// @notice The address of the controller is the only address that can call\r\n    ///  a function with this modifier\r\n    modifier onlyController { require(msg.sender == controller); _; }\r\n    address public controller;\r\n    function Controlled() public { controller = msg.sender;}\r\n    /// @notice Changes the controller of the contract\r\n    /// @param _newController The new controller of the contract\r\n    function changeController(address _newController) public onlyController {\r\n        controller = _newController;\r\n    }\r\n}\r\n/// @dev The token controller contract must implement these functions\r\ncontract TokenController {\r\n    /// @notice Called when `_owner` sends ether to the MiniMe Token contract\r\n    /// @param _owner The address that sent the ether to create tokens\r\n    /// @return True if the ether is accepted, false if it throws\r\n    function proxyPayment(address _owner) public payable returns(bool);\r\n    /// @notice Notifies the controller about a token transfer allowing the\r\n    ///  controller to react if desired\r\n    /// @param _from The origin of the transfer\r\n    /// @param _to The destination of the transfer\r\n    /// @param _amount The amount of the transfer\r\n    /// @return False if the controller does not authorize the transfer\r\n    function onTransfer(address _from, address _to, uint _amount) public returns(bool);\r\n    /// @notice Notifies the controller about an approval allowing the\r\n    ///  controller to react if desired\r\n    /// @param _owner The address that calls `approve()`\r\n    /// @param _spender The spender in the `approve()` call\r\n    /// @param _amount The amount in the `approve()` call\r\n    /// @return False if the controller does not authorize the approval\r\n    function onApprove(address _owner, address _spender, uint _amount) public\r\n        returns(bool);\r\n}\r\ncontract ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 _amount, address _token, bytes _data) public;\r\n}\r\n/// @dev The actual token contract, the default controller is the msg.sender\r\n///  that deploys the contract, so usually this token will be deployed by a\r\n///  token controller contract, which Giveth will call a \"Campaign\"\r\ncontract MiniMeToken is Controlled {\r\n    string public name;                //The Token's name: e.g. DigixDAO Tokens\r\n    uint8 public decimals;             //Number of decimals of the smallest unit\r\n    string public symbol;              //An identifier: e.g. REP\r\n    string public version = 'MMT_0.2'; //An arbitrary versioning scheme\r\n    /// @dev `Checkpoint` is the structure that attaches a block number to a\r\n    ///  given value, the block number attached is the one that last changed the\r\n    ///  value\r\n    struct  Checkpoint {\r\n        // `fromBlock` is the block number that the value was generated from\r\n        uint128 fromBlock;\r\n        // `value` is the amount of tokens at a specific block number\r\n        uint128 value;\r\n    }\r\n    // `parentToken` is the Token address that was cloned to produce this token;\r\n    //  it will be 0x0 for a token that was not cloned\r\n    MiniMeToken public parentToken;\r\n    // `parentSnapShotBlock` is the block number from the Parent Token that was\r\n    //  used to determine the initial distribution of the Clone Token\r\n    uint public parentSnapShotBlock;\r\n    // `creationBlock` is the block number that the Clone Token was created\r\n    uint public creationBlock;\r\n    // `balances` is the map that tracks the balance of each address, in this\r\n    //  contract when the balance changes the block number that the change\r\n    //  occurred is also included in the map\r\n    mapping (address => Checkpoint[]) balances;\r\n    // `allowed` tracks any extra transfer rights as in all ERC20 tokens\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    // Tracks the history of the `totalSupply` of the token\r\n    Checkpoint[] totalSupplyHistory;\r\n    // Flag that determines if the token is transferable or not.\r\n    bool public transfersEnabled;\r\n    // The factory used to create new clone tokens\r\n    MiniMeTokenFactory public tokenFactory;\r\n////////////////\r\n// Constructor\r\n////////////////\r\n    /// @notice Constructor to create a MiniMeToken\r\n    /// @param _tokenFactory The address of the MiniMeTokenFactory contract that\r\n    ///  will create the Clone token contracts, the token factory needs to be\r\n    ///  deployed first\r\n    /// @param _parentToken Address of the parent token, set to 0x0 if it is a\r\n    ///  new token\r\n    /// @param _parentSnapShotBlock Block of the parent token that will\r\n    ///  determine the initial distribution of the clone token, set to 0 if it\r\n    ///  is a new token\r\n    /// @param _tokenName Name of the new token\r\n    /// @param _decimalUnits Number of decimals of the new token\r\n    /// @param _tokenSymbol Token Symbol for the new token\r\n    /// @param _transfersEnabled If true, tokens will be able to be transferred\r\n    function MiniMeToken(\r\n        address _tokenFactory,\r\n        address _parentToken,\r\n        uint _parentSnapShotBlock,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol,\r\n        bool _transfersEnabled\r\n    ) public {\r\n        tokenFactory = MiniMeTokenFactory(_tokenFactory);\r\n        name = _tokenName;                                 // Set the name\r\n        decimals = _decimalUnits;                          // Set the decimals\r\n        symbol = _tokenSymbol;                             // Set the symbol\r\n        parentToken = MiniMeToken(_parentToken);\r\n        parentSnapShotBlock = _parentSnapShotBlock;\r\n        transfersEnabled = _transfersEnabled;\r\n        creationBlock = block.number;\r\n    }\r\n///////////////////\r\n// ERC20 Methods\r\n///////////////////\r\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The amount of tokens to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _amount) public returns (bool success) {\r\n        require(transfersEnabled);\r\n        return doTransfer(msg.sender, _to, _amount);\r\n    }\r\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\r\n    ///  is approved by `_from`\r\n    /// @param _from The address holding the tokens being transferred\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The amount of tokens to be transferred\r\n    /// @return True if the transfer was successful\r\n    function transferFrom(address _from, address _to, uint256 _amount\r\n    ) public returns (bool success) {\r\n        // The controller of this contract can move tokens around at will,\r\n        //  this is important to recognize! Confirm that you trust the\r\n        //  controller of this contract, which in most situations should be\r\n        //  another open source smart contract or 0x0\r\n        if (msg.sender != controller) {\r\n            require(transfersEnabled);\r\n            // The standard ERC 20 transferFrom functionality\r\n            if (allowed[_from][msg.sender] < _amount) return false;\r\n            allowed[_from][msg.sender] -= _amount;\r\n        }\r\n        return doTransfer(_from, _to, _amount);\r\n    }\r\n    /// @dev This is the actual transfer function in the token contract, it can\r\n    ///  only be called by other functions in this contract.\r\n    /// @param _from The address holding the tokens being transferred\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The amount of tokens to be transferred\r\n    /// @return True if the transfer was successful\r\n    function doTransfer(address _from, address _to, uint _amount\r\n    ) internal returns(bool) {\r\n           if (_amount == 0) {\r\n               return true;\r\n           }\r\n           require(parentSnapShotBlock < block.number);\r\n           // Do not allow transfer to 0x0 or the token contract itself\r\n           require((_to != 0) && (_to != address(this)));\r\n           // If the amount being transfered is more than the balance of the\r\n           //  account the transfer returns false\r\n           var previousBalanceFrom = balanceOfAt(_from, block.number);\r\n           if (previousBalanceFrom < _amount) {\r\n               return false;\r\n           }\r\n           // Alerts the token controller of the transfer\r\n           if (isContract(controller)) {\r\n               require(TokenController(controller).onTransfer(_from, _to, _amount));\r\n           }\r\n           // First update the balance array with the new value for the address\r\n           //  sending the tokens\r\n           updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\r\n           // Then update the balance array with the new value for the address\r\n           //  receiving the tokens\r\n           var previousBalanceTo = balanceOfAt(_to, block.number);\r\n           require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\r\n           updateValueAtNow(balances[_to], previousBalanceTo + _amount);\r\n           // An event to make the transfer easy to find on the blockchain\r\n           Transfer(_from, _to, _amount);\r\n           return true;\r\n    }\r\n    /// @param _owner The address that's balance is being requested\r\n    /// @return The balance of `_owner` at the current block\r\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n        return balanceOfAt(_owner, block.number);\r\n    }\r\n    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\r\n    ///  its behalf. This is a modified version of the ERC20 approve function\r\n    ///  to be a little bit safer\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _amount The amount of tokens to be approved for transfer\r\n    /// @return True if the approval was successful\r\n    function approve(address _spender, uint256 _amount) public returns (bool success) {\r\n        require(transfersEnabled);\r\n        // To change the approve amount you first have to reduce the addresses`\r\n        //  allowance to zero by calling `approve(_spender,0)` if it is not\r\n        //  already 0 to mitigate the race condition described here:\r\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\r\n        // Alerts the token controller of the approve function call\r\n        if (isContract(controller)) {\r\n            require(TokenController(controller).onApprove(msg.sender, _spender, _amount));\r\n        }\r\n        allowed[msg.sender][_spender] = _amount;\r\n        Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n    /// @dev This function makes it easy to read the `allowed[]` map\r\n    /// @param _owner The address of the account that owns the token\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens of _owner that _spender is allowed\r\n    ///  to spend\r\n    function allowance(address _owner, address _spender\r\n    ) public constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n    /// @notice `msg.sender` approves `_spender` to send `_amount` tokens on\r\n    ///  its behalf, and then a function is triggered in the contract that is\r\n    ///  being approved, `_spender`. This allows users to use their tokens to\r\n    ///  interact with contracts in one function call instead of two\r\n    /// @param _spender The address of the contract able to transfer the tokens\r\n    /// @param _amount The amount of tokens to be approved for transfer\r\n    /// @return True if the function call was successful\r\n    function approveAndCall(address _spender, uint256 _amount, bytes _extraData\r\n    ) public returns (bool success) {\r\n        require(approve(_spender, _amount));\r\n        ApproveAndCallFallBack(_spender).receiveApproval(\r\n            msg.sender,\r\n            _amount,\r\n            this,\r\n            _extraData\r\n        );\r\n        return true;\r\n    }\r\n    /// @dev This function makes it easy to get the total number of tokens\r\n    /// @return The total number of tokens\r\n    function totalSupply() public constant returns (uint) {\r\n        return totalSupplyAt(block.number);\r\n    }\r\n////////////////\r\n// Query balance and totalSupply in History\r\n////////////////\r\n    /// @dev Queries the balance of `_owner` at a specific `_blockNumber`\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @param _blockNumber The block number when the balance is queried\r\n    /// @return The balance at `_blockNumber`\r\n    function balanceOfAt(address _owner, uint _blockNumber) public constant\r\n        returns (uint) {\r\n        // These next few lines are used when the balance of the token is\r\n        //  requested before a check point was ever created for this token, it\r\n        //  requires that the `parentToken.balanceOfAt` be queried at the\r\n        //  genesis block for that token as this contains initial balance of\r\n        //  this token\r\n        if ((balances[_owner].length == 0)\r\n            || (balances[_owner][0].fromBlock > _blockNumber)) {\r\n            if (address(parentToken) != 0) {\r\n                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\r\n            } else {\r\n                // Has no parent\r\n                return 0;\r\n            }\r\n        // This will return the expected balance during normal situations\r\n        } else {\r\n            return getValueAt(balances[_owner], _blockNumber);\r\n        }\r\n    }\r\n    /// @notice Total amount of tokens at a specific `_blockNumber`.\r\n    /// @param _blockNumber The block number when the totalSupply is queried\r\n    /// @return The total amount of tokens at `_blockNumber`\r\n    function totalSupplyAt(uint _blockNumber) public constant returns(uint) {\r\n        // These next few lines are used when the totalSupply of the token is\r\n        //  requested before a check point was ever created for this token, it\r\n        //  requires that the `parentToken.totalSupplyAt` be queried at the\r\n        //  genesis block for this token as that contains totalSupply of this\r\n        //  token at this block number.\r\n        if ((totalSupplyHistory.length == 0)\r\n            || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\r\n            if (address(parentToken) != 0) {\r\n                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\r\n            } else {\r\n                return 0;\r\n            }\r\n        // This will return the expected totalSupply during normal situations\r\n        } else {\r\n            return getValueAt(totalSupplyHistory, _blockNumber);\r\n        }\r\n    }\r\n////////////////\r\n// Clone Token Method\r\n////////////////\r\n    /// @notice Creates a new clone token with the initial distribution being\r\n    ///  this token at `_snapshotBlock`\r\n    /// @param _cloneTokenName Name of the clone token\r\n    /// @param _cloneDecimalUnits Number of decimals of the smallest unit\r\n    /// @param _cloneTokenSymbol Symbol of the clone token\r\n    /// @param _snapshotBlock Block when the distribution of the parent token is\r\n    ///  copied to set the initial distribution of the new clone token;\r\n    ///  if the block is zero than the actual block, the current block is used\r\n    /// @param _transfersEnabled True if transfers are allowed in the clone\r\n    /// @return The address of the new MiniMeToken Contract\r\n    function createCloneToken(\r\n        string _cloneTokenName,\r\n        uint8 _cloneDecimalUnits,\r\n        string _cloneTokenSymbol,\r\n        uint _snapshotBlock,\r\n        bool _transfersEnabled\r\n        ) public returns(address) {\r\n        if (_snapshotBlock == 0) _snapshotBlock = block.number;\r\n        MiniMeToken cloneToken = tokenFactory.createCloneToken(\r\n            this,\r\n            _snapshotBlock,\r\n            _cloneTokenName,\r\n            _cloneDecimalUnits,\r\n            _cloneTokenSymbol,\r\n            _transfersEnabled\r\n            );\r\n        cloneToken.changeController(msg.sender);\r\n        // An event to make the token easy to find on the blockchain\r\n        NewCloneToken(address(cloneToken), _snapshotBlock);\r\n        return address(cloneToken);\r\n    }\r\n////////////////\r\n// Generate and destroy tokens\r\n////////////////\r\n    /// @notice Generates `_amount` tokens that are assigned to `_owner`\r\n    /// @param _owner The address that will be assigned the new tokens\r\n    /// @param _amount The quantity of tokens generated\r\n    /// @return True if the tokens are generated correctly\r\n    function generateTokens(address _owner, uint _amount\r\n    ) public onlyController returns (bool) {\r\n        uint curTotalSupply = totalSupply();\r\n        require(curTotalSupply + _amount >= curTotalSupply); // Check for overflow\r\n        uint previousBalanceTo = balanceOf(_owner);\r\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\r\n        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\r\n        updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\r\n        Transfer(0, _owner, _amount);\r\n        return true;\r\n    }\r\n    /// @notice Burns `_amount` tokens from `_owner`\r\n    /// @param _owner The address that will lose the tokens\r\n    /// @param _amount The quantity of tokens to burn\r\n    /// @return True if the tokens are burned correctly\r\n    function destroyTokens(address _owner, uint _amount\r\n    ) onlyController public returns (bool) {\r\n        uint curTotalSupply = totalSupply();\r\n        require(curTotalSupply >= _amount);\r\n        uint previousBalanceFrom = balanceOf(_owner);\r\n        require(previousBalanceFrom >= _amount);\r\n        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\r\n        updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\r\n        Transfer(_owner, 0, _amount);\r\n        return true;\r\n    }\r\n////////////////\r\n// Enable tokens transfers\r\n////////////////\r\n    /// @notice Enables token holders to transfer their tokens freely if true\r\n    /// @param _transfersEnabled True if transfers are allowed in the clone\r\n    function enableTransfers(bool _transfersEnabled) public onlyController {\r\n        transfersEnabled = _transfersEnabled;\r\n    }\r\n////////////////\r\n// Internal helper functions to query and set a value in a snapshot array\r\n////////////////\r\n    /// @dev `getValueAt` retrieves the number of tokens at a given block number\r\n    /// @param checkpoints The history of values being queried\r\n    /// @param _block The block number to retrieve the value at\r\n    /// @return The number of tokens being queried\r\n    function getValueAt(Checkpoint[] storage checkpoints, uint _block\r\n    ) constant internal returns (uint) {\r\n        if (checkpoints.length == 0) return 0;\r\n        // Shortcut for the actual value\r\n        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\r\n            return checkpoints[checkpoints.length-1].value;\r\n        if (_block < checkpoints[0].fromBlock) return 0;\r\n        // Binary search of the value in the array\r\n        uint min = 0;\r\n        uint max = checkpoints.length-1;\r\n        while (max > min) {\r\n            uint mid = (max + min + 1)/ 2;\r\n            if (checkpoints[mid].fromBlock<=_block) {\r\n                min = mid;\r\n            } else {\r\n                max = mid-1;\r\n            }\r\n        }\r\n        return checkpoints[min].value;\r\n    }\r\n    /// @dev `updateValueAtNow` used to update the `balances` map and the\r\n    ///  `totalSupplyHistory`\r\n    /// @param checkpoints The history of data being updated\r\n    /// @param _value The new number of tokens\r\n    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value\r\n    ) internal  {\r\n        if ((checkpoints.length == 0)\r\n        || (checkpoints[checkpoints.length -1].fromBlock < block.number)) {\r\n               Checkpoint storage newCheckPoint = checkpoints[ checkpoints.length++ ];\r\n               newCheckPoint.fromBlock =  uint128(block.number);\r\n               newCheckPoint.value = uint128(_value);\r\n           } else {\r\n               Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length-1];\r\n               oldCheckPoint.value = uint128(_value);\r\n           }\r\n    }\r\n    /// @dev Internal function to determine if an address is a contract\r\n    /// @param _addr The address being queried\r\n    /// @return True if `_addr` is a contract\r\n    function isContract(address _addr) constant internal returns(bool) {\r\n        uint size;\r\n        if (_addr == 0) return false;\r\n        assembly {\r\n            size := extcodesize(_addr)\r\n        }\r\n        return size>0;\r\n    }\r\n    /// @dev Helper function to return a min betwen the two uints\r\n    function min(uint a, uint b) pure internal returns (uint) {\r\n        return a < b ? a : b;\r\n    }\r\n    /// @notice The fallback function: If the contract's controller has not been\r\n    ///  set to 0, then the `proxyPayment` method is called which relays the\r\n    ///  ether and creates tokens as described in the token controller contract\r\n    function () public payable {\r\n        require(isContract(controller));\r\n        require(TokenController(controller).proxyPayment.value(msg.value)(msg.sender));\r\n    }\r\n//////////\r\n// Safety Methods\r\n//////////\r\n    /// @notice This method can be used by the controller to extract mistakenly\r\n    ///  sent tokens to this contract.\r\n    /// @param _token The address of the token contract that you want to recover\r\n    ///  set to 0 in case you want to extract ether.\r\n    function claimTokens(address _token) public onlyController {\r\n        if (_token == 0x0) {\r\n            controller.transfer(this.balance);\r\n            return;\r\n        }\r\n        MiniMeToken token = MiniMeToken(_token);\r\n        uint balance = token.balanceOf(this);\r\n        token.transfer(controller, balance);\r\n        ClaimedTokens(_token, controller, balance);\r\n    }\r\n////////////////\r\n// Events\r\n////////////////\r\n    event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\r\n    event NewCloneToken(address indexed _cloneToken, uint _snapshotBlock);\r\n    event Approval(\r\n        address indexed _owner,\r\n        address indexed _spender,\r\n        uint256 _amount\r\n        );\r\n}\r\n////////////////\r\n// MiniMeTokenFactory\r\n////////////////\r\n/// @dev This contract is used to generate clone contracts from a contract.\r\n///  In solidity this is the way to create a contract from a contract of the\r\n///  same class\r\ncontract MiniMeTokenFactory {\r\n    /// @notice Update the DApp by creating a new token with new functionalities\r\n    ///  the msg.sender becomes the controller of this clone token\r\n    /// @param _parentToken Address of the token being cloned\r\n    /// @param _snapshotBlock Block of the parent token that will\r\n    ///  determine the initial distribution of the clone token\r\n    /// @param _tokenName Name of the new token\r\n    /// @param _decimalUnits Number of decimals of the new token\r\n    /// @param _tokenSymbol Token Symbol for the new token\r\n    /// @param _transfersEnabled If true, tokens will be able to be transferred\r\n    /// @return The address of the new token contract\r\n    function createCloneToken(\r\n        address _parentToken,\r\n        uint _snapshotBlock,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol,\r\n        bool _transfersEnabled\r\n    ) public returns (MiniMeToken) {\r\n        MiniMeToken newToken = new MiniMeToken(\r\n            this,\r\n            _parentToken,\r\n            _snapshotBlock,\r\n            _tokenName,\r\n            _decimalUnits,\r\n            _tokenSymbol,\r\n            _transfersEnabled\r\n            );\r\n        newToken.changeController(msg.sender);\r\n        return newToken;\r\n    }\r\n}\r\ncontract ATC is MiniMeToken {\r\n  mapping (address => bool) public blacklisted;\r\n  bool public generateFinished;\r\n  // @dev ATC constructor just parametrizes the MiniMeToken constructor\r\n  function ATC(address _tokenFactory)\r\n          MiniMeToken(\r\n              _tokenFactory,\r\n              0x0,                     // no parent token\r\n              0,                       // no snapshot block number from parent\r\n              \"Aston Token\",  // Token name\r\n              18,                      // Decimals\r\n              \"ATC\",                   // Symbol\r\n              false                     // Enable transfers\r\n          ) {}\r\n  function generateTokens(address _owner, uint _amount\r\n      ) public onlyController returns (bool) {\r\n        require(generateFinished == false);\r\n        //check msg.sender (controller ??)\r\n        return super.generateTokens(_owner, _amount);\r\n      }\r\n  function doTransfer(address _from, address _to, uint _amount\r\n      ) internal returns(bool) {\r\n        require(blacklisted[_from] == false);\r\n        return super.doTransfer(_from, _to, _amount);\r\n      }\r\n  function finishGenerating() public onlyController returns (bool success) {\r\n    generateFinished = true;\r\n    return true;\r\n  }\r\n  function blacklistAccount(address tokenOwner) public onlyController returns (bool success) {\r\n    blacklisted[tokenOwner] = true;\r\n    return true;\r\n  }\r\n  function unBlacklistAccount(address tokenOwner) public onlyController returns (bool success) {\r\n    blacklisted[tokenOwner] = false;\r\n    return true;\r\n  }\r\n}\r\n/**\r\n * @title RefundVault\r\n * @dev This contract is used for storing funds while a crowdsale\r\n * is in progress. Supports refunding the money if crowdsale fails,\r\n * and forwarding it if crowdsale is successful.\r\n */\r\ncontract RefundVault is Ownable, SafeMath{\r\n  enum State { Active, Refunding, Closed }\r\n  mapping (address => uint256) public deposited;\r\n  mapping (address => uint256) public refunded;\r\n  State public state;\r\n  address[] public reserveWallet;\r\n  event Closed();\r\n  event RefundsEnabled();\r\n  event Refunded(address indexed beneficiary, uint256 weiAmount);\r\n  /**\r\n   * @dev This constructor sets the addresses of\r\n   * 10 reserve wallets.\r\n   * and forwarding it if crowdsale is successful.\r\n   * @param _reserveWallet address[5] The addresses of reserve wallet.\r\n   */\r\n  function RefundVault(address[] _reserveWallet) {\r\n    state = State.Active;\r\n    reserveWallet = _reserveWallet;\r\n  }\r\n  /**\r\n   * @dev This function is called when user buy tokens. Only RefundVault\r\n   * contract stores the Ether user sent which forwarded from crowdsale\r\n   * contract.\r\n   * @param investor address The address who buy the token from crowdsale.\r\n   */\r\n  function deposit(address investor) onlyOwner payable {\r\n    require(state == State.Active);\r\n    deposited[investor] = add(deposited[investor], msg.value);\r\n  }\r\n  event Transferred(address _to, uint _value);\r\n  /**\r\n   * @dev This function is called when crowdsale is successfully finalized.\r\n   */\r\n  function close() onlyOwner {\r\n    require(state == State.Active);\r\n    state = State.Closed;\r\n    uint256 balance = this.balance;\r\n    uint256 reserveAmountForEach = div(balance, reserveWallet.length);\r\n    for(uint8 i = 0; i < reserveWallet.length; i++){\r\n      reserveWallet[i].transfer(reserveAmountForEach);\r\n      Transferred(reserveWallet[i], reserveAmountForEach);\r\n    }\r\n    Closed();\r\n  }\r\n  /**\r\n   * @dev This function is called when crowdsale is unsuccessfully finalized\r\n   * and refund is required.\r\n   */\r\n  function enableRefunds() onlyOwner {\r\n    require(state == State.Active);\r\n    state = State.Refunding;\r\n    RefundsEnabled();\r\n  }\r\n  /**\r\n   * @dev This function allows for user to refund Ether.\r\n   */\r\n  function refund(address investor) returns (bool) {\r\n    require(state == State.Refunding);\r\n    if (refunded[investor] > 0) {\r\n      return false;\r\n    }\r\n    uint256 depositedValue = deposited[investor];\r\n    deposited[investor] = 0;\r\n    refunded[investor] = depositedValue;\r\n    investor.transfer(depositedValue);\r\n    Refunded(investor, depositedValue);\r\n    return true;\r\n  }\r\n}\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n  bool public paused = false;\r\n  /**\r\n   * @dev modifier to allow actions only when the contract IS paused\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n  /**\r\n   * @dev modifier to allow actions only when the contract IS NOT paused\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n}\r\n/**\r\n * @title TokenTimelock\r\n * @dev TokenTimelock is a token holder contract that will allow a\r\n * beneficiary to extract the tokens after a given release time\r\n */\r\ncontract ReserveLocker is SafeMath{\r\n  using SafeERC20 for ERC20Basic;\r\n  ERC20Basic public token;\r\n  ATCCrowdSale public crowdsale;\r\n  address public beneficiary;\r\n  function ReserveLocker(address _token, address _crowdsale, address _beneficiary) {\r\n    require(_token != 0x00);\r\n    require(_crowdsale != 0x00);\r\n    require(_beneficiary != 0x00);\r\n    token = ERC20Basic(_token);\r\n    crowdsale = ATCCrowdSale(_crowdsale);\r\n    beneficiary = _beneficiary;\r\n  }\r\n  /**\r\n   * @notice Transfers tokens held by timelock to beneficiary.\r\n   */\r\n   function release() public {\r\n     uint256 finalizedTime = crowdsale.finalizedTime();\r\n     require(finalizedTime > 0 && now > add(finalizedTime, 2 years));\r\n     uint256 amount = token.balanceOf(this);\r\n     require(amount > 0);\r\n     token.safeTransfer(beneficiary, amount);\r\n   }\r\n  function setToken(address newToken) public {\r\n    require(msg.sender == beneficiary);\r\n    require(newToken != 0x00);\r\n    token = ERC20Basic(newToken);\r\n  }\r\n}\r\n/**\r\n * @title TokenTimelock\r\n * @dev TokenTimelock is a token holder contract that will allow a\r\n * beneficiary to extract the tokens after a given release time\r\n */\r\ncontract TeamLocker is SafeMath{\r\n  using SafeERC20 for ERC20Basic;\r\n  ERC20Basic public token;\r\n  ATCCrowdSale public crowdsale;\r\n  address[] public beneficiaries;\r\n  uint256 public collectedTokens;\r\n  function TeamLocker(address _token, address _crowdsale, address[] _beneficiaries) {\r\n    require(_token != 0x00);\r\n    require(_crowdsale != 0x00);\r\n    for (uint i = 0; i < _beneficiaries.length; i++) {\r\n      require(_beneficiaries[i] != 0x00);\r\n    }\r\n    token = ERC20Basic(_token);\r\n    crowdsale = ATCCrowdSale(_crowdsale);\r\n    beneficiaries = _beneficiaries;\r\n  }\r\n  /**\r\n   * @notice Transfers tokens held by timelock to beneficiary.\r\n   */\r\n  function release() public {\r\n    uint256 balance = token.balanceOf(address(this));\r\n    uint256 total = add(balance, collectedTokens);\r\n    uint256 finalizedTime = crowdsale.finalizedTime();\r\n    require(finalizedTime > 0);\r\n    uint256 lockTime1 = add(finalizedTime, 183 days); // 6 months\r\n    uint256 lockTime2 = add(finalizedTime, 1 years); // 1 year\r\n    uint256 currentRatio = 20;\r\n    if (now >= lockTime1) {\r\n      currentRatio = 50;\r\n    }\r\n    if (now >= lockTime2) {\r\n      currentRatio = 100;\r\n    }\r\n    uint256 releasedAmount = div(mul(total, currentRatio), 100);\r\n    uint256 grantAmount = sub(releasedAmount, collectedTokens);\r\n    require(grantAmount > 0);\r\n    collectedTokens = add(collectedTokens, grantAmount);\r\n    uint256 grantAmountForEach = div(grantAmount, 3);\r\n    for (uint i = 0; i < beneficiaries.length; i++) {\r\n        token.safeTransfer(beneficiaries[i], grantAmountForEach);\r\n    }\r\n  }\r\n  function setToken(address newToken) public {\r\n    require(newToken != 0x00);\r\n    bool isBeneficiary;\r\n    for (uint i = 0; i < beneficiaries.length; i++) {\r\n      if (msg.sender == beneficiaries[i]) {\r\n        isBeneficiary = true;\r\n      }\r\n    }\r\n    require(isBeneficiary);\r\n    token = ERC20Basic(newToken);\r\n  }\r\n}\r\ncontract ATCCrowdSale is Ownable, SafeMath, Pausable {\r\n  KYC public kyc;\r\n  ATC public token;\r\n  RefundVault public vault;\r\n  address public presale;\r\n  address public bountyAddress; //5% for bounty\r\n  address public partnersAddress; //15% for community groups & partners\r\n  address public ATCReserveLocker; //15% with 2 years lock\r\n  address public teamLocker; // 15% with 2 years vesting\r\n  struct Period {\r\n    uint256 startTime;\r\n    uint256 endTime;\r\n    uint256 bonus; // used to calculate rate with bonus. ragne 0 ~ 15 (0% ~ 15%)\r\n  }\r\n  uint256 public baseRate; // 1 ETH = 1500 ATC\r\n  uint256[] public additionalBonusAmounts;\r\n  Period[] public periods;\r\n  uint8 constant public MAX_PERIOD_COUNT = 8;\r\n  uint256 public weiRaised;\r\n  uint256 public maxEtherCap;\r\n  uint256 public minEtherCap;\r\n  mapping (address => uint256) public beneficiaryFunded;\r\n  address[] investorList;\r\n  mapping (address => bool) inInvestorList;\r\n  address public ATCController;\r\n  bool public isFinalized;\r\n  uint256 public refundCompleted;\r\n  bool public presaleFallBackCalled;\r\n  uint256 public finalizedTime;\r\n  bool public initialized;\r\n  event CrowdSaleTokenPurchase(address indexed _investor, address indexed _beneficiary, uint256 _toFund, uint256 _tokens);\r\n  event StartPeriod(uint256 _startTime, uint256 _endTime, uint256 _bonus);\r\n  event Finalized();\r\n  event PresaleFallBack(uint256 _presaleWeiRaised);\r\n  event PushInvestorList(address _investor);\r\n  event RefundAll(uint256 _numToRefund);\r\n  event ClaimedTokens(address _claimToken, address owner, uint256 balance);\r\n  event Initialize();\r\n  function initialize (\r\n    address _kyc,\r\n    address _token,\r\n    address _vault,\r\n    address _presale,\r\n    address _bountyAddress,\r\n    address _partnersAddress,\r\n    address _ATCReserveLocker,\r\n    address _teamLocker,\r\n    address _tokenController,\r\n    uint256 _maxEtherCap,\r\n    uint256 _minEtherCap,\r\n    uint256 _baseRate,\r\n    uint256[] _additionalBonusAmounts\r\n    ) onlyOwner {\r\n      require(!initialized);\r\n      require(_kyc != 0x00 && _token != 0x00 && _vault != 0x00 && _presale != 0x00);\r\n      require(_bountyAddress != 0x00 && _partnersAddress != 0x00);\r\n      require(_ATCReserveLocker != 0x00 && _teamLocker != 0x00);\r\n      require(_tokenController != 0x00);\r\n      require(0 < _minEtherCap && _minEtherCap < _maxEtherCap);\r\n      require(_baseRate > 0);\r\n      require(_additionalBonusAmounts[0] > 0);\r\n      for (uint i = 0; i < _additionalBonusAmounts.length - 1; i++) {\r\n        require(_additionalBonusAmounts[i] < _additionalBonusAmounts[i + 1]);\r\n      }\r\n      kyc = KYC(_kyc);\r\n      token = ATC(_token);\r\n      vault = RefundVault(_vault);\r\n      presale = _presale;\r\n      bountyAddress = _bountyAddress;\r\n      partnersAddress = _partnersAddress;\r\n      ATCReserveLocker = _ATCReserveLocker;\r\n      teamLocker = _teamLocker;\r\n      ATCController = _tokenController;\r\n      maxEtherCap = _maxEtherCap;\r\n      minEtherCap = _minEtherCap;\r\n      baseRate = _baseRate;\r\n      additionalBonusAmounts = _additionalBonusAmounts;\r\n      initialized = true;\r\n      Initialize();\r\n    }\r\n  function () public payable {\r\n    buy(msg.sender);\r\n  }\r\n  function presaleFallBack(uint256 _presaleWeiRaised) public returns (bool) {\r\n    require(!presaleFallBackCalled);\r\n    require(msg.sender == presale);\r\n    weiRaised = _presaleWeiRaised;\r\n    presaleFallBackCalled = true;\r\n    PresaleFallBack(_presaleWeiRaised);\r\n    return true;\r\n  }\r\n  function buy(address beneficiary)\r\n    public\r\n    payable\r\n    whenNotPaused\r\n  {\r\n      // check validity\r\n      require(presaleFallBackCalled);\r\n      require(beneficiary != 0x00);\r\n      require(kyc.registeredAddress(beneficiary));\r\n      require(onSale());\r\n      require(validPurchase());\r\n      require(!isFinalized);\r\n      // calculate eth amount\r\n      uint256 weiAmount = msg.value;\r\n      uint256 toFund;\r\n      uint256 postWeiRaised = add(weiRaised, weiAmount);\r\n      if (postWeiRaised > maxEtherCap) {\r\n        toFund = sub(maxEtherCap, weiRaised);\r\n      } else {\r\n        toFund = weiAmount;\r\n      }\r\n      require(toFund > 0);\r\n      require(weiAmount >= toFund);\r\n      uint256 rate = calculateRate(toFund);\r\n      uint256 tokens = mul(toFund, rate);\r\n      uint256 toReturn = sub(weiAmount, toFund);\r\n      pushInvestorList(msg.sender);\r\n      weiRaised = add(weiRaised, toFund);\r\n      beneficiaryFunded[beneficiary] = add(beneficiaryFunded[beneficiary], toFund);\r\n      token.generateTokens(beneficiary, tokens);\r\n      if (toReturn > 0) {\r\n        msg.sender.transfer(toReturn);\r\n      }\r\n      forwardFunds(toFund);\r\n      CrowdSaleTokenPurchase(msg.sender, beneficiary, toFund, tokens);\r\n  }\r\n  function pushInvestorList(address investor) internal {\r\n    if (!inInvestorList[investor]) {\r\n      inInvestorList[investor] = true;\r\n      investorList.push(investor);\r\n      PushInvestorList(investor);\r\n    }\r\n  }\r\n  function validPurchase() internal view returns (bool) {\r\n    bool nonZeroPurchase = msg.value != 0;\r\n    return nonZeroPurchase && !maxReached();\r\n  }\r\n  function forwardFunds(uint256 toFund) internal {\r\n    vault.deposit.value(toFund)(msg.sender);\r\n  }\r\n  /**\r\n   * @dev Checks whether minEtherCap is reached\r\n   * @return true if min ether cap is reaced\r\n   */\r\n  function minReached() public view returns (bool) {\r\n    return weiRaised >= minEtherCap;\r\n  }\r\n  /**\r\n   * @dev Checks whether maxEtherCap is reached\r\n   * @return true if max ether cap is reaced\r\n   */\r\n  function maxReached() public view returns (bool) {\r\n    return weiRaised == maxEtherCap;\r\n  }\r\n  function getPeriodBonus() public view returns (uint256) {\r\n    bool nowOnSale;\r\n    uint256 currentPeriod;\r\n    for (uint i = 0; i < periods.length; i++) {\r\n      if (periods[i].startTime <= now && now <= periods[i].endTime) {\r\n        nowOnSale = true;\r\n        currentPeriod = i;\r\n        break;\r\n      }\r\n    }\r\n    require(nowOnSale);\r\n    return periods[currentPeriod].bonus;\r\n  }\r\n  /**\r\n   * @dev rate = baseRate * (100 + bonus) / 100\r\n   */\r\n  function calculateRate(uint256 toFund) public view returns (uint256)  {\r\n    uint bonus = getPeriodBonus();\r\n    // bonus for eth amount\r\n    if (additionalBonusAmounts[0] <= toFund) {\r\n      bonus = add(bonus, 5); // 5% amount bonus for more than 300 ETH\r\n    }\r\n    if (additionalBonusAmounts[1] <= toFund) {\r\n      bonus = add(bonus, 5); // 10% amount bonus for more than 6000 ETH\r\n    }\r\n    if (additionalBonusAmounts[2] <= toFund) {\r\n      bonus = 25; // final 25% amount bonus for more than 8000 ETH\r\n    }\r\n    if (additionalBonusAmounts[3] <= toFund) {\r\n      bonus = 30; // final 30% amount bonus for more than 10000 ETH\r\n    }\r\n    return div(mul(baseRate, add(bonus, 100)), 100);\r\n  }\r\n  function startPeriod(uint256 _startTime, uint256 _endTime) public onlyOwner returns (bool) {\r\n    require(periods.length < MAX_PERIOD_COUNT);\r\n    require(now < _startTime && _startTime < _endTime);\r\n    if (periods.length != 0) {\r\n      require(sub(_endTime, _startTime) <= 7 days);\r\n      require(periods[periods.length - 1].endTime < _startTime);\r\n    }\r\n    // 15% -> 10% -> 5% -> 0%\r\n    Period memory newPeriod;\r\n    newPeriod.startTime = _startTime;\r\n    newPeriod.endTime = _endTime;\r\n    if(periods.length < 3) {\r\n      newPeriod.bonus = sub(15, mul(5, periods.length));\r\n    } else {\r\n      newPeriod.bonus = 0;\r\n    }\r\n    periods.push(newPeriod);\r\n    StartPeriod(_startTime, _endTime, newPeriod.bonus);\r\n    return true;\r\n  }\r\n  function onSale() public returns (bool) {\r\n    bool nowOnSale;\r\n    for (uint i = 0; i < periods.length; i++) {\r\n      if (periods[i].startTime <= now && now <= periods[i].endTime) {\r\n        nowOnSale = true;\r\n        break;\r\n      }\r\n    }\r\n    return nowOnSale;\r\n  }\r\n  /**\r\n   * @dev should be called after crowdsale ends, to do\r\n   */\r\n  function finalize() onlyOwner {\r\n    require(!isFinalized);\r\n    require(!onSale() || maxReached());\r\n    finalizedTime = now;\r\n    finalization();\r\n    Finalized();\r\n    isFinalized = true;\r\n  }\r\n  /**\r\n   * @dev end token minting on finalization, mint tokens for dev team and reserve wallets\r\n   */\r\n  function finalization() internal {\r\n    if (minReached()) {\r\n      vault.close();\r\n      uint256 totalToken = token.totalSupply();\r\n      // token distribution : 50% for sale, 5% for bounty, 15% for partners, 15% for reserve, 15% for team\r\n      uint256 bountyAmount = div(mul(totalToken, 5), 50);\r\n      uint256 partnersAmount = div(mul(totalToken, 15), 50);\r\n      uint256 reserveAmount = div(mul(totalToken, 15), 50);\r\n      uint256 teamAmount = div(mul(totalToken, 15), 50);\r\n      distributeToken(bountyAmount, partnersAmount, reserveAmount, teamAmount);\r\n      token.enableTransfers(true);\r\n    } else {\r\n      vault.enableRefunds();\r\n    }\r\n    token.finishGenerating();\r\n    token.changeController(ATCController);\r\n  }\r\n  function distributeToken(uint256 bountyAmount, uint256 partnersAmount, uint256 reserveAmount, uint256 teamAmount) internal {\r\n    require(bountyAddress != 0x00 && partnersAddress != 0x00);\r\n    require(ATCReserveLocker != 0x00 && teamLocker != 0x00);\r\n    token.generateTokens(bountyAddress, bountyAmount);\r\n    token.generateTokens(partnersAddress, partnersAmount);\r\n    token.generateTokens(ATCReserveLocker, reserveAmount);\r\n    token.generateTokens(teamLocker, teamAmount);\r\n  }\r\n  /**\r\n   * @dev refund a lot of investors at a time checking onlyOwner\r\n   * @param numToRefund uint256 The number of investors to refund\r\n   */\r\n  function refundAll(uint256 numToRefund) onlyOwner {\r\n    require(isFinalized);\r\n    require(!minReached());\r\n    require(numToRefund > 0);\r\n    uint256 limit = refundCompleted + numToRefund;\r\n    if (limit > investorList.length) {\r\n      limit = investorList.length;\r\n    }\r\n    for(uint256 i = refundCompleted; i < limit; i++) {\r\n      vault.refund(investorList[i]);\r\n    }\r\n    refundCompleted = limit;\r\n    RefundAll(numToRefund);\r\n  }\r\n  /**\r\n   * @dev if crowdsale is unsuccessful, investors can claim refunds here\r\n   * @param investor address The account to be refunded\r\n   */\r\n  function claimRefund(address investor) returns (bool) {\r\n    require(isFinalized);\r\n    require(!minReached());\r\n    return vault.refund(investor);\r\n  }\r\n  function claimTokens(address _claimToken) public onlyOwner {\r\n    if (token.controller() == address(this)) {\r\n         token.claimTokens(_claimToken);\r\n    }\r\n    if (_claimToken == 0x0) {\r\n        owner.transfer(this.balance);\r\n        return;\r\n    }\r\n    ERC20Basic claimToken = ERC20Basic(_claimToken);\r\n    uint256 balance = claimToken.balanceOf(this);\r\n    claimToken.transfer(owner, balance);\r\n    ClaimedTokens(_claimToken, owner, balance);\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"newToken\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"collectedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"release\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsale\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"beneficiaries\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_crowdsale\",\"type\":\"address\"},{\"name\":\"_beneficiaries\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"TeamLocker","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000024a585b4f3db4b852ce8810524401591c408ef82000000000000000000000000951f614f81da09c90e6187a14b759f98ed9e74900000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000300000000000000000000000080049bf695833d1d465623dc1774c8b3e99ca2a7000000000000000000000000e863985909e518be7b1d2d7a24d9e4100c9a4820000000000000000000000000db09e4762bd2c7227207871dc80cff86d090fe92","Library":"","SwarmSource":"bzzr://eff790ec2b5c917dc360bb18d780005b51cd511ae889225104b2b48f16769eb8"}]}