{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.15;\r\n\r\ncontract Token {\r\n    \r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (uint256 => address) public addresses;\r\n    mapping (address => bool) public addressExists;\r\n    mapping (address => uint256) public addressIndex;\r\n    mapping(address => mapping (address => uint256)) allowed;\r\n    uint256 public numberOfAddress = 0;\r\n    \r\n    string public physicalString;\r\n    string public cryptoString;\r\n    \r\n    bool public isSecured;\r\n    string public name;\r\n    string public symbol;\r\n    uint256 public totalSupply;\r\n    bool public canMintBurn;\r\n    uint256 public txnTax;\r\n    uint256 public holdingTax;\r\n    //In Weeks, on Fridays\r\n    uint256 public holdingTaxInterval;\r\n    uint256 public lastHoldingTax;\r\n    uint256 public holdingTaxDecimals = 2;\r\n    bool public isPrivate;\r\n    \r\n    address public owner;\r\n    \r\n    function Token(string n, string a, uint256 totalSupplyToUse, bool isSecured, bool cMB, string physical, string crypto, uint256 txnTaxToUse, uint256 holdingTaxToUse, uint256 holdingTaxIntervalToUse, bool isPrivateToUse) {\r\n        name = n;\r\n        symbol = a;\r\n        totalSupply = totalSupplyToUse;\r\n        balanceOf[msg.sender] = totalSupplyToUse;\r\n        isSecured = isSecured;\r\n        physicalString = physical;\r\n        cryptoString = crypto;\r\n        canMintBurn = cMB;\r\n        owner = msg.sender;\r\n        txnTax = txnTaxToUse;\r\n        holdingTax = holdingTaxToUse;\r\n        holdingTaxInterval = holdingTaxIntervalToUse;\r\n        if(holdingTaxInterval!=0) {\r\n            lastHoldingTax = now;\r\n            while(getHour(lastHoldingTax)!=21) {\r\n                lastHoldingTax -= 1 hours;\r\n            }\r\n            while(getWeekday(lastHoldingTax)!=5) {\r\n                lastHoldingTax -= 1 days;\r\n            }\r\n            lastHoldingTax -= getMinute(lastHoldingTax) * (1 minutes) + getSecond(lastHoldingTax) * (1 seconds);\r\n        }\r\n        isPrivate = isPrivateToUse;\r\n        \r\n        addAddress(owner);\r\n    }\r\n    \r\n    function transfer(address _to, uint256 _value) payable returns (bool success) {\r\n        chargeHoldingTax();\r\n        if (balanceOf[msg.sender] < _value) return false;\r\n        if (balanceOf[_to] + _value < balanceOf[_to]) return false;\r\n        if (msg.sender != owner && _to != owner && txnTax != 0) {\r\n            if(!owner.send(txnTax)) {\r\n                return false;\r\n            }\r\n        }\r\n        if(isPrivate && msg.sender != owner && !addressExists[_to]) {\r\n            return false;\r\n        }\r\n        balanceOf[msg.sender] -= _value;\r\n        balanceOf[_to] += _value;\r\n        addAddress(_to);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n    \r\n    function transferFrom(\r\n         address _from,\r\n         address _to,\r\n         uint256 _amount\r\n     ) payable returns (bool success) {\r\n        if (_from != owner && _to != owner && txnTax != 0) {\r\n            if(!owner.send(txnTax)) {\r\n                return false;\r\n            }\r\n        }\r\n        if(isPrivate && _from != owner && !addressExists[_to]) {\r\n            return false;\r\n        }\r\n        if (balanceOf[_from] >= _amount\r\n            && allowed[_from][msg.sender] >= _amount\r\n            && _amount > 0\r\n            && balanceOf[_to] + _amount > balanceOf[_to]) {\r\n            balanceOf[_from] -= _amount;\r\n            allowed[_from][msg.sender] -= _amount;\r\n            balanceOf[_to] += _amount;\r\n            Transfer(_from, _to, _amount);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n     \r\n    function approve(address _spender, uint256 _amount) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _amount;\r\n        Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n    \r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n    \r\n    function changeTxnTax(uint256 _newValue) {\r\n        if(msg.sender != owner) throw;\r\n        txnTax = _newValue;\r\n    }\r\n    \r\n    function mint(uint256 _value) {\r\n        if(canMintBurn && msg.sender == owner) {\r\n            if (balanceOf[msg.sender] + _value < balanceOf[msg.sender]) throw;\r\n            balanceOf[msg.sender] += _value;\r\n            totalSupply += _value;\r\n            Transfer(0, msg.sender, _value);\r\n        }\r\n    }\r\n    \r\n    function burn(uint256 _value) {\r\n        if(canMintBurn && msg.sender == owner) {\r\n            if (balanceOf[msg.sender] < _value) throw;\r\n            balanceOf[msg.sender] -= _value;\r\n            totalSupply -= _value;\r\n            Transfer(msg.sender, 0, _value);\r\n        }\r\n    }\r\n    \r\n    function chargeHoldingTax() {\r\n        if(holdingTaxInterval!=0) {\r\n            uint256 dateDif = now - lastHoldingTax;\r\n            bool changed = false;\r\n            while(dateDif >= holdingTaxInterval * (1 weeks)) {\r\n                changed=true;\r\n                dateDif -= holdingTaxInterval * (1 weeks);\r\n                for(uint256 i = 0;i<numberOfAddress;i++) {\r\n                    if(addresses[i]!=owner) {\r\n                        uint256 amtOfTaxToPay = ((balanceOf[addresses[i]]) * holdingTax)  / (10**holdingTaxDecimals)/ (10**holdingTaxDecimals);\r\n                        balanceOf[addresses[i]] -= amtOfTaxToPay;\r\n                        balanceOf[owner] += amtOfTaxToPay;\r\n                    }\r\n                }\r\n            }\r\n            if(changed) {\r\n                lastHoldingTax = now;\r\n                while(getHour(lastHoldingTax)!=21) {\r\n                    lastHoldingTax -= 1 hours;\r\n                }\r\n                while(getWeekday(lastHoldingTax)!=5) {\r\n                    lastHoldingTax -= 1 days;\r\n                }\r\n                lastHoldingTax -= getMinute(lastHoldingTax) * (1 minutes) + getSecond(lastHoldingTax) * (1 seconds);\r\n            }\r\n        }\r\n    }\r\n    \r\n    function changeHoldingTax(uint256 _newValue) {\r\n        if(msg.sender != owner) throw;\r\n        holdingTax = _newValue;\r\n    }\r\n    \r\n    function changeHoldingTaxInterval(uint256 _newValue) {\r\n        if(msg.sender != owner) throw;\r\n        holdingTaxInterval = _newValue;\r\n    }\r\n    \r\n    function addAddress (address addr) private {\r\n        if(!addressExists[addr]) {\r\n            addressIndex[addr] = numberOfAddress;\r\n            addresses[numberOfAddress++] = addr;\r\n            addressExists[addr] = true;\r\n        }\r\n    }\r\n    \r\n    function addAddressManual (address addr) {\r\n        if(msg.sender == owner && isPrivate) {\r\n            addAddress(addr);\r\n        } else {\r\n            throw;\r\n        }\r\n    }\r\n    \r\n    function removeAddress (address addr) private {\r\n        if(addressExists[addr]) {\r\n            numberOfAddress--;\r\n            addresses[addressIndex[addr]] = 0x0;\r\n            addressExists[addr] = false;\r\n        }\r\n    }\r\n    \r\n    function removeAddressManual (address addr) {\r\n        if(msg.sender == owner && isPrivate) {\r\n            removeAddress(addr);\r\n        } else {\r\n            throw;\r\n        }\r\n    }\r\n    \r\n    function getWeekday(uint timestamp) returns (uint8) {\r\n            return uint8((timestamp / 86400 + 4) % 7);\r\n    }\r\n    \r\n    function getHour(uint timestamp) returns (uint8) {\r\n            return uint8((timestamp / 60 / 60) % 24);\r\n    }\r\n\r\n    function getMinute(uint timestamp) returns (uint8) {\r\n            return uint8((timestamp / 60) % 60);\r\n    }\r\n\r\n    function getSecond(uint timestamp) returns (uint8) {\r\n            return uint8(timestamp % 60);\r\n    }\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract Transfer {\r\n    \r\n    address tokenAddress = 0x8c9B7335d4b776D6C630A9D9b1E57Ae0550cc3a9;\r\n    Token t = Token(tokenAddress);\r\n    \r\n    address[] public aa;\r\n    uint256[] public bb;\r\n    uint256 public l;\r\n        \r\n    function Transfer(address[] a, uint256[] b, uint256 length) {\r\n        aa = a;\r\n        bb = b;\r\n        l = length;\r\n    }\r\n    \r\n    function setThings(address[] a, uint256[] b, uint256 length) {\r\n        aa = a;\r\n        bb = b;\r\n        l = length;\r\n    }\r\n    \r\n    function transfer() {\r\n        for(uint256 i = 0;i<l;i++) {\r\n            t.transfer(aa[i],bb[i]);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"address[]\"},{\"name\":\"b\",\"type\":\"uint256[]\"},{\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"setThings\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bb\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"aa\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"l\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"a\",\"type\":\"address[]\"},{\"name\":\"b\",\"type\":\"uint256[]\"},{\"name\":\"length\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"constructor\"}]","ContractName":"Transfer","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000001c0000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000004031dfddaf163ac762eb449b32c365e98f97271a000000000000000000000000416a0d612c99b7943e6f39950c0626f673ca48210000000000000000000000004f7e8219f2ca71939dcaaf294237082fad5fd13600000000000000000000000055e2334a145c612e6ed2a41a2a3ed310df36275d0000000000000000000000005c0cc3e1c96e6d3a81fbe342ab798786f5acb6a10000000000000000000000005c768cd8d2bbc26086c2a159c3e5afe60ed72f230000000000000000000000006435d84fed60f0ea57ab0f337b4d766f10b30a820000000000000000000000006cadf6d49c79b99b45f170a5a1e1c136b3e5517a00000000000000000000000071100c6854a4a3113911bfdf30dabd49bae6e0b10000000000000000000000007404807a93374807facc5c51ad4bed6cf11ef5bc000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000009626600000000000000000000000000000000000000000000000000000000000005c20000000000000000000000000000000000000000000000000000000000934703000000000000000000000000000000000000000000000000000000000017aab70000000000000000000000000000000000000000000000000000000000048a8700000000000000000000000000000000000000000000000000000000000493e000000000000000000000000000000000000000000000000000000000000db65700000000000000000000000000000000000000000000000000000000000108340000000000000000000000000000000000000000000000000000000000014d65000000000000000000000000000000000000000000000000000000000010e7a4","Library":"","SwarmSource":"bzzr://91523cd0570479c622431d64a9b0ad3215c8b6d1b70acb82b9a6caa76c811b33"}]}