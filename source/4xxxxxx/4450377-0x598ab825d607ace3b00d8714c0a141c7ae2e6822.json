{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.6;\r\n\r\n/// @title Vault Contract\r\n/// @author Jordi Baylina\r\n/// @notice This contract holds funds for Campaigns and automates payments, it\r\n///  intends to be a safe place to store funds equipped with optional variable\r\n///  time delays to allow for an optional escape hatch\r\n\r\n/// @dev `Owned` is a base level contract that assigns an `owner` that can be\r\n///  later changed\r\ncontract Owned {\r\n    /// @dev `owner` is the only address that can call a function with this\r\n    /// modifier\r\n    modifier onlyOwner { if (msg.sender != owner) throw; _; }\r\n\r\n    address public owner;\r\n\r\n    /// @notice The Constructor assigns the message sender to be `owner`\r\n    function Owned() { owner = msg.sender;}\r\n\r\n    /// @notice `owner` can step down and assign some other address to this role\r\n    /// @param _newOwner The address of the new owner. 0x0 can be used to create\r\n    ///  an unowned neutral vault, however that cannot be undone\r\n    function changeOwner(address _newOwner) onlyOwner {\r\n        owner = _newOwner;\r\n        NewOwner(msg.sender, _newOwner);\r\n    }\r\n\r\n    event NewOwner(address indexed oldOwner, address indexed newOwner);\r\n}\r\n\r\n/// @dev `Escapable` is a base level contract built off of the `Owned`\r\n///  contract that creates an escape hatch function to send its ether to\r\n///  `escapeHatchDestination` when called by the `escapeHatchCaller` in the case that\r\n///  something unexpected happens\r\ncontract Escapable is Owned {\r\n    address public escapeHatchCaller;\r\n    address public escapeHatchDestination;\r\n\r\n    /// @notice The Constructor assigns the `escapeHatchDestination` and the\r\n    ///  `escapeHatchCaller`\r\n    /// @param _escapeHatchDestination The address of a safe location (usu a\r\n    ///  Multisig) to send the ether held in this contract\r\n    /// @param _escapeHatchCaller The address of a trusted account or contract to\r\n    ///  call `escapeHatch()` to send the ether in this contract to the\r\n    ///  `escapeHatchDestination` it would be ideal that `escapeHatchCaller` cannot move\r\n    ///  funds out of `escapeHatchDestination`\r\n    function Escapable(address _escapeHatchCaller, address _escapeHatchDestination) {\r\n        escapeHatchCaller = _escapeHatchCaller;\r\n        escapeHatchDestination = _escapeHatchDestination;\r\n    }\r\n\r\n    /// @dev The addresses preassigned the `escapeHatchCaller` role\r\n    ///  is the only addresses that can call a function with this modifier\r\n    modifier onlyEscapeHatchCallerOrOwner {\r\n        if ((msg.sender != escapeHatchCaller)&&(msg.sender != owner))\r\n            throw;\r\n        _;\r\n    }\r\n\r\n    /// @notice The `escapeHatch()` should only be called as a last resort if a\r\n    /// security issue is uncovered or something unexpected happened\r\n    function escapeHatch() onlyEscapeHatchCallerOrOwner {\r\n        uint total = this.balance;\r\n        // Send the total balance of this contract to the `escapeHatchDestination`\r\n        if (!escapeHatchDestination.send(total)) {\r\n            throw;\r\n        }\r\n        EscapeHatchCalled(total);\r\n    }\r\n    /// @notice Changes the address assigned to call `escapeHatch()`\r\n    /// @param _newEscapeHatchCaller The address of a trusted account or contract to\r\n    ///  call `escapeHatch()` to send the ether in this contract to the\r\n    ///  `escapeHatchDestination` it would be ideal that `escapeHatchCaller` cannot\r\n    ///  move funds out of `escapeHatchDestination`\r\n    function changeEscapeCaller(address _newEscapeHatchCaller) onlyEscapeHatchCallerOrOwner {\r\n        escapeHatchCaller = _newEscapeHatchCaller;\r\n    }\r\n\r\n    event EscapeHatchCalled(uint amount);\r\n}\r\n\r\n/// @dev `Vault` is a higher level contract built off of the `Escapable`\r\n///  contract that holds funds for Campaigns and automates payments.\r\ncontract Vault is Escapable {\r\n\r\n    /// @dev `Payment` is a public structure that describes the details of\r\n    ///  each payment making it easy to track the movement of funds\r\n    ///  transparently\r\n    struct Payment {\r\n        string name;     // What is the purpose of this payment\r\n        bytes32 reference;  // Reference of the payment.\r\n        address spender;        // Who is sending the funds\r\n        uint earliestPayTime;   // The earliest a payment can be made (Unix Time)\r\n        bool canceled;         // If True then the payment has been canceled\r\n        bool paid;              // If True then the payment has been paid\r\n        address recipient;      // Who is receiving the funds\r\n        uint amount;            // The amount of wei sent in the payment\r\n        uint securityGuardDelay;// The seconds `securityGuard` can delay payment\r\n    }\r\n\r\n    Payment[] public authorizedPayments;\r\n\r\n    address public securityGuard;\r\n    uint public absoluteMinTimeLock;\r\n    uint public timeLock;\r\n    uint public maxSecurityGuardDelay;\r\n\r\n    /// @dev The white list of approved addresses allowed to set up && receive\r\n    ///  payments from this vault\r\n    mapping (address => bool) public allowedSpenders;\r\n\r\n    /// @dev The address assigned the role of `securityGuard` is the only\r\n    ///  addresses that can call a function with this modifier\r\n    modifier onlySecurityGuard { if (msg.sender != securityGuard) throw; _; }\r\n\r\n    // @dev Events to make the payment movements easy to find on the blockchain\r\n    event PaymentAuthorized(uint indexed idPayment, address indexed recipient, uint amount);\r\n    event PaymentExecuted(uint indexed idPayment, address indexed recipient, uint amount);\r\n    event PaymentCanceled(uint indexed idPayment);\r\n    event EtherReceived(address indexed from, uint amount);\r\n    event SpenderAuthorization(address indexed spender, bool authorized);\r\n\r\n/////////\r\n// Constructor\r\n/////////\r\n\r\n    /// @notice The Constructor creates the Vault on the blockchain\r\n    /// @param _escapeHatchCaller The address of a trusted account or contract to\r\n    ///  call `escapeHatch()` to send the ether in this contract to the\r\n    ///  `escapeHatchDestination` it would be ideal if `escapeHatchCaller` cannot move\r\n    ///  funds out of `escapeHatchDestination`\r\n    /// @param _escapeHatchDestination The address of a safe location (usu a\r\n    ///  Multisig) to send the ether held in this contract in an emergency\r\n    /// @param _absoluteMinTimeLock The minimum number of seconds `timelock` can\r\n    ///  be set to, if set to 0 the `owner` can remove the `timeLock` completely\r\n    /// @param _timeLock Initial number of seconds that payments are delayed\r\n    ///  after they are authorized (a security precaution)\r\n    /// @param _securityGuard Address that will be able to delay the payments\r\n    ///  beyond the initial timelock requirements; can be set to 0x0 to remove\r\n    ///  the `securityGuard` functionality\r\n    /// @param _maxSecurityGuardDelay The maximum number of seconds in total\r\n    ///   that `securityGuard` can delay a payment so that the owner can cancel\r\n    ///   the payment if needed\r\n    function Vault(\r\n        address _escapeHatchCaller,\r\n        address _escapeHatchDestination,\r\n        uint _absoluteMinTimeLock,\r\n        uint _timeLock,\r\n        address _securityGuard,\r\n        uint _maxSecurityGuardDelay) Escapable(_escapeHatchCaller, _escapeHatchDestination)\r\n    {\r\n        absoluteMinTimeLock = _absoluteMinTimeLock;\r\n        timeLock = _timeLock;\r\n        securityGuard = _securityGuard;\r\n        maxSecurityGuardDelay = _maxSecurityGuardDelay;\r\n    }\r\n\r\n/////////\r\n// Helper functions\r\n/////////\r\n\r\n    /// @notice States the total number of authorized payments in this contract\r\n    /// @return The number of payments ever authorized even if they were canceled\r\n    function numberOfAuthorizedPayments() constant returns (uint) {\r\n        return authorizedPayments.length;\r\n    }\r\n\r\n//////\r\n// Receive Ether\r\n//////\r\n\r\n    /// @notice Called anytime ether is sent to the contract && creates an event\r\n    /// to more easily track the incoming transactions\r\n    function receiveEther() payable {\r\n        EtherReceived(msg.sender, msg.value);\r\n    }\r\n\r\n    /// @notice The fall back function is called whenever ether is sent to this\r\n    ///  contract\r\n    function () payable {\r\n        receiveEther();\r\n    }\r\n\r\n////////\r\n// Spender Interface\r\n////////\r\n\r\n    /// @notice only `allowedSpenders[]` Creates a new `Payment`\r\n    /// @param _name Brief description of the payment that is authorized\r\n    /// @param _reference External reference of the payment\r\n    /// @param _recipient Destination of the payment\r\n    /// @param _amount Amount to be paid in wei\r\n    /// @param _paymentDelay Number of seconds the payment is to be delayed, if\r\n    ///  this value is below `timeLock` then the `timeLock` determines the delay\r\n    /// @return The Payment ID number for the new authorized payment\r\n    function authorizePayment(\r\n        string _name,\r\n        bytes32 _reference,\r\n        address _recipient,\r\n        uint _amount,\r\n        uint _paymentDelay\r\n    ) returns(uint) {\r\n\r\n        // Fail if you arent on the `allowedSpenders` white list\r\n        if (!allowedSpenders[msg.sender] ) throw;\r\n        uint idPayment = authorizedPayments.length;       // Unique Payment ID\r\n        authorizedPayments.length++;\r\n\r\n        // The following lines fill out the payment struct\r\n        Payment p = authorizedPayments[idPayment];\r\n        p.spender = msg.sender;\r\n\r\n        // Overflow protection\r\n        if (_paymentDelay > 10**18) throw;\r\n\r\n        // Determines the earliest the recipient can receive payment (Unix time)\r\n        p.earliestPayTime = _paymentDelay >= timeLock ?\r\n                                now + _paymentDelay :\r\n                                now + timeLock;\r\n        p.recipient = _recipient;\r\n        p.amount = _amount;\r\n        p.name = _name;\r\n        p.reference = _reference;\r\n        PaymentAuthorized(idPayment, p.recipient, p.amount);\r\n        return idPayment;\r\n    }\r\n\r\n    /// @notice only `allowedSpenders[]` The recipient of a payment calls this\r\n    ///  function to send themselves the ether after the `earliestPayTime` has\r\n    ///  expired\r\n    /// @param _idPayment The payment ID to be executed\r\n    function collectAuthorizedPayment(uint _idPayment) {\r\n\r\n        // Check that the `_idPayment` has been added to the payments struct\r\n        if (_idPayment >= authorizedPayments.length) throw;\r\n\r\n        Payment p = authorizedPayments[_idPayment];\r\n\r\n        // Checking for reasons not to execute the payment\r\n        if (msg.sender != p.recipient) throw;\r\n        if (!allowedSpenders[p.spender]) throw;\r\n        if (now < p.earliestPayTime) throw;\r\n        if (p.canceled) throw;\r\n        if (p.paid) throw;\r\n        if (this.balance < p.amount) throw;\r\n\r\n        p.paid = true; // Set the payment to being paid\r\n        if (!p.recipient.send(p.amount)) {  // Make the payment\r\n            throw;\r\n        }\r\n        PaymentExecuted(_idPayment, p.recipient, p.amount);\r\n     }\r\n\r\n/////////\r\n// SecurityGuard Interface\r\n/////////\r\n\r\n    /// @notice `onlySecurityGuard` Delays a payment for a set number of seconds\r\n    /// @param _idPayment ID of the payment to be delayed\r\n    /// @param _delay The number of seconds to delay the payment\r\n    function delayPayment(uint _idPayment, uint _delay) onlySecurityGuard {\r\n        if (_idPayment >= authorizedPayments.length) throw;\r\n\r\n        // Overflow test\r\n        if (_delay > 10**18) throw;\r\n\r\n        Payment p = authorizedPayments[_idPayment];\r\n\r\n        if ((p.securityGuardDelay + _delay > maxSecurityGuardDelay) ||\r\n            (p.paid) ||\r\n            (p.canceled))\r\n            throw;\r\n\r\n        p.securityGuardDelay += _delay;\r\n        p.earliestPayTime += _delay;\r\n    }\r\n\r\n////////\r\n// Owner Interface\r\n///////\r\n\r\n    /// @notice `onlyOwner` Cancel a payment all together\r\n    /// @param _idPayment ID of the payment to be canceled.\r\n    function cancelPayment(uint _idPayment) onlyOwner {\r\n        if (_idPayment >= authorizedPayments.length) throw;\r\n\r\n        Payment p = authorizedPayments[_idPayment];\r\n\r\n\r\n        if (p.canceled) throw;\r\n        if (p.paid) throw;\r\n\r\n        p.canceled = true;\r\n        PaymentCanceled(_idPayment);\r\n    }\r\n\r\n    /// @notice `onlyOwner` Adds a spender to the `allowedSpenders[]` white list\r\n    /// @param _spender The address of the contract being authorized/unauthorized\r\n    /// @param _authorize `true` if authorizing and `false` if unauthorizing\r\n    function authorizeSpender(address _spender, bool _authorize) onlyOwner {\r\n        allowedSpenders[_spender] = _authorize;\r\n        SpenderAuthorization(_spender, _authorize);\r\n    }\r\n\r\n    /// @notice `onlyOwner` Sets the address of `securityGuard`\r\n    /// @param _newSecurityGuard Address of the new security guard\r\n    function setSecurityGuard(address _newSecurityGuard) onlyOwner {\r\n        securityGuard = _newSecurityGuard;\r\n    }\r\n\r\n    /// @notice `onlyOwner` Changes `timeLock`; the new `timeLock` cannot be\r\n    ///  lower than `absoluteMinTimeLock`\r\n    /// @param _newTimeLock Sets the new minimum default `timeLock` in seconds;\r\n    ///  pending payments maintain their `earliestPayTime`\r\n    function setTimelock(uint _newTimeLock) onlyOwner {\r\n        if (_newTimeLock < absoluteMinTimeLock) throw;\r\n        timeLock = _newTimeLock;\r\n    }\r\n\r\n    /// @notice `onlyOwner` Changes the maximum number of seconds\r\n    /// `securityGuard` can delay a payment\r\n    /// @param _maxSecurityGuardDelay The new maximum delay in seconds that\r\n    ///  `securityGuard` can delay the payment's execution in total\r\n    function setMaxSecurityGuardDelay(uint _maxSecurityGuardDelay) onlyOwner {\r\n        maxSecurityGuardDelay = _maxSecurityGuardDelay;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"maxSecurityGuardDelay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"escapeHatch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newTimeLock\",\"type\":\"uint256\"}],\"name\":\"setTimelock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"escapeHatchCaller\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_reference\",\"type\":\"bytes32\"},{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_paymentDelay\",\"type\":\"uint256\"}],\"name\":\"authorizePayment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newEscapeHatchCaller\",\"type\":\"address\"}],\"name\":\"changeEscapeCaller\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfAuthorizedPayments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_authorize\",\"type\":\"bool\"}],\"name\":\"authorizeSpender\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_idPayment\",\"type\":\"uint256\"}],\"name\":\"cancelPayment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_idPayment\",\"type\":\"uint256\"},{\"name\":\"_delay\",\"type\":\"uint256\"}],\"name\":\"delayPayment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_idPayment\",\"type\":\"uint256\"}],\"name\":\"collectAuthorizedPayment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"authorizedPayments\",\"outputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"reference\",\"type\":\"bytes32\"},{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"earliestPayTime\",\"type\":\"uint256\"},{\"name\":\"canceled\",\"type\":\"bool\"},{\"name\":\"paid\",\"type\":\"bool\"},{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"securityGuardDelay\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"receiveEther\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"securityGuard\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newSecurityGuard\",\"type\":\"address\"}],\"name\":\"setSecurityGuard\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timeLock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowedSpenders\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxSecurityGuardDelay\",\"type\":\"uint256\"}],\"name\":\"setMaxSecurityGuardDelay\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"absoluteMinTimeLock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"escapeHatchDestination\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_escapeHatchCaller\",\"type\":\"address\"},{\"name\":\"_escapeHatchDestination\",\"type\":\"address\"},{\"name\":\"_absoluteMinTimeLock\",\"type\":\"uint256\"},{\"name\":\"_timeLock\",\"type\":\"uint256\"},{\"name\":\"_securityGuard\",\"type\":\"address\"},{\"name\":\"_maxSecurityGuardDelay\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"idPayment\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PaymentAuthorized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"idPayment\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PaymentExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"idPayment\",\"type\":\"uint256\"}],\"name\":\"PaymentCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EtherReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"authorized\",\"type\":\"bool\"}],\"name\":\"SpenderAuthorization\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EscapeHatchCalled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"NewOwner\",\"type\":\"event\"}]","ContractName":"Vault","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000dda882a62600c452419145781e45052fdc06382c00000000000000000000000097b47fe3ed8d68ee4b930b27598d08097f8ea9c60000000000000000000000000000000000000000000000000000000000000e100000000000000000000000000000000000000000000000000000000000015180000000000000000000000000839395e20bbb182fa440d08f850e6c7a8f6f07800000000000000000000000000000000000000000000000000000000000127500","Library":"","SwarmSource":"bzzr://68cd6154297c049e19a780d0ef661705ad3182cbc26e6886b7998f84aa4cfa7b"}]}