{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.15;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Contracts that should not own Ether\r\n * @author Remco Bloemen <remco@2Ï€.com>\r\n * @dev This tries to block incoming ether to prevent accidental loss of Ether. Should Ether end up\r\n * in the contract, it will allow the owner to reclaim this ether.\r\n * @notice Ether can still be send to this contract by:\r\n * calling functions labeled `payable`\r\n * `selfdestruct(contract_address)`\r\n * mining directly to the contract address\r\n*/\r\ncontract HasNoEther is Ownable {\r\n\r\n  /**\r\n  * @dev Constructor that rejects incoming Ether\r\n  * @dev The `payable` flag is added so we can access `msg.value` without compiler warning. If we\r\n  * leave out payable, then Solidity will allow inheriting contracts to implement a payable\r\n  * constructor. By doing it this way we prevent a payable constructor from working. Alternatively\r\n  * we could use assembly to access msg.value.\r\n  */\r\n  function HasNoEther() payable {\r\n    require(msg.value == 0);\r\n  }\r\n\r\n  /**\r\n   * @dev Disallows direct send by settings a default function without the `payable` flag.\r\n   */\r\n  function() external {\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer all Ether held by the contract to the owner.\r\n   */\r\n  function reclaimEther() external onlyOwner {\r\n    assert(owner.send(this.balance));\r\n  }\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract IRntToken {\r\n    uint256 public decimals = 18;\r\n\r\n    uint256 public totalSupply = 1000000000 * (10 ** 18);\r\n\r\n    string public name = \"RNT Token\";\r\n\r\n    string public code = \"RNT\";\r\n\r\n\r\n    function balanceOf() public constant returns (uint256 balance);\r\n\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n}\r\n\r\ncontract RntTokenVault is HasNoEther, Pausable {\r\n    using SafeMath for uint256;\r\n\r\n    IRntToken public rntToken;\r\n\r\n    uint256 public accountsCount = 0;\r\n\r\n    uint256 public tokens = 0;\r\n\r\n    mapping (bytes16 => bool) public accountsStatuses;\r\n\r\n    mapping (bytes16 => uint256) public balances;\r\n\r\n    mapping (address => bool) public allowedAddresses;\r\n\r\n    mapping (address => bytes16) public tokenTransfers;\r\n\r\n\r\n    function RntTokenVault(address _rntTokenAddress){\r\n        rntToken = IRntToken(_rntTokenAddress);\r\n    }\r\n\r\n    /**\r\n    @notice Modifier that prevent calling function from not allowed address.\r\n    @dev Owner always allowed address.\r\n    */\r\n    modifier onlyAllowedAddresses {\r\n        require(msg.sender == owner || allowedAddresses[msg.sender] == true);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    @notice Modifier that prevent calling function if account not registered.\r\n    */\r\n    modifier onlyRegisteredAccount(bytes16 _uuid) {\r\n        require(accountsStatuses[_uuid] == true);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    @notice Get current amount of tokens on Vault address.\r\n    @return { amount of tokens }\r\n    */\r\n    function getVaultBalance() onlyAllowedAddresses public constant returns (uint256) {\r\n        return rntToken.balanceOf();\r\n    }\r\n\r\n    /**\r\n    @notice Get uuid of account taht transfer tokens to specified address.\r\n    @param  _address Transfer address.\r\n    @return { uuid that wsa transfer tokens }\r\n    */\r\n    function getTokenTransferUuid(address _address) onlyAllowedAddresses public constant returns (bytes16) {\r\n        return tokenTransfers[_address];\r\n    }\r\n\r\n    /**\r\n    @notice Check that address is allowed to interact with functions.\r\n    @return { true if allowed, false if not }\r\n    */\r\n    function isAllowedAddress(address _address) onlyAllowedAddresses public constant returns (bool) {\r\n        return allowedAddresses[_address];\r\n    }\r\n\r\n    /**\r\n    @notice Check that address is registered.\r\n    @return { true if registered, false if not }\r\n    */\r\n    function isRegisteredAccount(address _address) onlyAllowedAddresses public constant returns (bool) {\r\n        return allowedAddresses[_address];\r\n    }\r\n\r\n    /**\r\n     @notice Register account.\r\n     @dev It used for accounts counting.\r\n     */\r\n    function registerAccount(bytes16 _uuid) public {\r\n        accountsStatuses[_uuid] = true;\r\n        accountsCount = accountsCount.add(1);\r\n    }\r\n\r\n    /**\r\n     @notice Set allowance for address to interact with contract.\r\n     @param _address Address to allow or disallow.\r\n     @param _allow True to allow address to interact with function, false to disallow.\r\n    */\r\n    function allowAddress(address _address, bool _allow) onlyOwner {\r\n        allowedAddresses[_address] = _allow;\r\n    }\r\n\r\n    /**\r\n    @notice Function for adding tokens to specified account.\r\n    @dev Account will be registered if it wasn't. Tokens will not be added to Vault address.\r\n    @param _uuid Uuid of account.\r\n    @param _tokensCount Number of tokens for adding to account.\r\n    @return { true if added, false if not }\r\n    */\r\n    function addTokensToAccount(bytes16 _uuid, uint256 _tokensCount) onlyAllowedAddresses whenNotPaused public returns (bool) {\r\n        registerAccount(_uuid);\r\n        balances[_uuid] = balances[_uuid].add(_tokensCount);\r\n        tokens = tokens.add(_tokensCount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    @notice Function for removing tokens from specified account.\r\n    @dev Function throw exception if account wasn't registered. Tokens will not be returned to owner address.\r\n    @param _uuid Uuid of account.\r\n    @param _tokensCount Number of tokens for adding to account.\r\n    @return { true if added, false if not }\r\n    */\r\n    function removeTokensFromAccount(bytes16 _uuid, uint256 _tokensCount) onlyAllowedAddresses\r\n            onlyRegisteredAccount(_uuid) whenNotPaused internal returns (bool) {\r\n        balances[_uuid] = balances[_uuid].sub(_tokensCount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    @notice Function for transfering tokens from one account to another.\r\n    @param _from Account from which tokens will be transfered.\r\n    @param _to Account to which tokens will be transfered.\r\n    @param _tokensCount Number of tokens that will be transfered.\r\n    @return { true if transfered successful, false if not }\r\n    */\r\n    function transferTokensToAccount(bytes16 _from, bytes16 _to, uint256 _tokensCount) onlyAllowedAddresses\r\n            onlyRegisteredAccount(_from) whenNotPaused public returns (bool) {\r\n        registerAccount(_to);\r\n        balances[_from] = balances[_from].sub(_tokensCount);\r\n        balances[_to] = balances[_to].add(_tokensCount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    @notice Function for withdrawal all tokens from Vault account to address.\r\n    @dev Will transfer tokens from Vault address to specified address.\r\n    @param _uuid Account from which tokens will be transfered.\r\n    @param _address Address on which tokens will be transfered.\r\n    @return { true if withdrawal successful, false if not }\r\n    */\r\n    function moveAllTokensToAddress(bytes16 _uuid, address _address) onlyAllowedAddresses\r\n            onlyRegisteredAccount(_uuid) whenNotPaused public returns (bool) {\r\n        uint256 accountBalance = balances[_uuid];\r\n        removeTokensFromAccount(_uuid, accountBalance);\r\n        rntToken.transfer(_address, accountBalance);\r\n        tokens = tokens.sub(accountBalance);\r\n        tokenTransfers[_address] = _uuid;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    @notice Function for withdrawal tokens from Vault account to address.\r\n    @dev Will transfer tokens from Vault address to specified address.\r\n    @param _uuid Account from which tokens will be transfered.\r\n    @param _address Address on which tokens will be transfered.\r\n    @param _tokensCount Number of tokens that will be transfered.\r\n    @return { true if transfered successful, false if not }\r\n    */\r\n    function moveTokensToAddress(bytes16 _uuid, address _address, uint256 _tokensCount) onlyAllowedAddresses\r\n            onlyRegisteredAccount(_uuid) whenNotPaused public returns (bool) {\r\n        removeTokensFromAccount(_uuid, _tokensCount);\r\n        rntToken.transfer(_address, _tokensCount);\r\n        tokens = tokens.sub(_tokensCount);\r\n        tokenTransfers[_address] = _uuid;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    @notice Function for withdrawal tokens from Vault to specified address.\r\n    @dev Will transfer tokens from Vault address to specified address.\r\n    @param _to Address on which tokens will be transfered.\r\n    @param _tokensCount Number of tokens that will be transfered.\r\n    @return { true if transfered successful, false if not }\r\n    */\r\n    function transferTokensFromVault(address _to, uint256 _tokensCount) onlyOwner public returns (bool) {\r\n        rntToken.transfer(_to, _tokensCount);\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Destructible\r\n * @dev Base contract that can be destroyed by owner. All funds in contract will be sent to the owner.\r\n */\r\ncontract Destructible is Ownable {\r\n\r\n  function Destructible() payable { }\r\n\r\n  /**\r\n   * @dev Transfers the current balance to the owner and terminates the contract.\r\n   */\r\n  function destroy() onlyOwner public {\r\n    selfdestruct(owner);\r\n  }\r\n\r\n  function destroyAndSend(address _recipient) onlyOwner public {\r\n    selfdestruct(_recipient);\r\n  }\r\n}\r\n\r\ncontract ICrowdsale {\r\n    function allocateTokens(address _receiver, bytes16 _customerUuid, uint256 _weiAmount) public;\r\n}\r\n\r\ncontract RntTokenProxy is Destructible, Pausable, HasNoEther {\r\n    IRntToken public rntToken;\r\n\r\n    ICrowdsale public crowdsale;\r\n\r\n    RntTokenVault public rntTokenVault;\r\n\r\n    mapping (address => bool) public allowedAddresses;\r\n\r\n    function RntTokenProxy(address _tokenAddress, address _vaultAddress, address _defaultAllowed, address _crowdsaleAddress) {\r\n        rntToken = IRntToken(_tokenAddress);\r\n        rntTokenVault = RntTokenVault(_vaultAddress);\r\n        crowdsale = ICrowdsale(_crowdsaleAddress);\r\n        allowedAddresses[_defaultAllowed] = true;\r\n    }\r\n\r\n    /**\r\n      @notice Modifier that prevent calling function from not allowed address.\r\n      @dev Owner always allowed address.\r\n     */\r\n    modifier onlyAllowedAddresses {\r\n        require(msg.sender == owner || allowedAddresses[msg.sender] == true);\r\n        _;\r\n    }\r\n\r\n    /**\r\n      @notice Set allowance for address to interact with contract.\r\n      @param _address Address to allow or disallow.\r\n      @param _allow True to allow address to interact with function, false to disallow.\r\n     */\r\n    function allowAddress(address _address, bool _allow) onlyOwner external {\r\n        allowedAddresses[_address] = _allow;\r\n    }\r\n\r\n    /**\r\n      @notice Function for adding tokens to account.\r\n      @dev If account wasn't created, it will be created and tokens will be added. Also this function transfer tokens to address of Valut.\r\n      @param _uuid Account uuid.\r\n      @param _tokensCount Number of tokens that will be added to account.\r\n     */\r\n    function addTokens(bytes16 _uuid, uint256 _tokensCount) onlyAllowedAddresses whenNotPaused external {\r\n        rntTokenVault.addTokensToAccount(_uuid, _tokensCount);\r\n        rntToken.transferFrom(owner, address(rntTokenVault), _tokensCount);\r\n    }\r\n\r\n    /**\r\n      @notice Function for transfering tokens from account to specified address.\r\n      @dev It will transfer tokens from Vault address to specified address.\r\n      @param _to Address, on wich tokens will be added.\r\n      @param _uuid Account, from wich token will be taken.\r\n      @param _tokensCount Number of tokens for transfering.\r\n     */\r\n    function moveTokens(address _to, bytes16 _uuid, uint256 _tokensCount) onlyAllowedAddresses whenNotPaused external {\r\n        rntTokenVault.moveTokensToAddress(_uuid, _to, _tokensCount);\r\n    }\r\n\r\n    /**\r\n      @notice Function for transfering all tokens from account to specified address.\r\n      @dev It will transfer all account allowed tokens from Vault address to specified address.\r\n      @param _to Address, on wich tokens will be added.\r\n      @param _uuid Account, from wich token will be taken.\r\n     */\r\n    function moveAllTokens(address _to, bytes16 _uuid) onlyAllowedAddresses whenNotPaused external {\r\n        rntTokenVault.moveAllTokensToAddress(_uuid, _to);\r\n    }\r\n\r\n    /**\r\n      @notice Add tokens to specified address, tokens amount depends of wei amount.\r\n      @dev Tokens acount calculated using token price that specified in Prixing Strategy. This function should be used when tokens was buyed outside ethereum.\r\n      @param _receiver Address, on wich tokens will be added.\r\n      @param _customerUuid Uuid of account that was bought tokens.\r\n      @param _weiAmount Wei that account was invest.\r\n     */\r\n    function allocate(address _receiver, bytes16 _customerUuid, uint256 _weiAmount) onlyAllowedAddresses whenNotPaused external {\r\n        crowdsale.allocateTokens(_receiver, _customerUuid, _weiAmount);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"rntTokenVault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rntToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowedAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_uuid\",\"type\":\"bytes16\"},{\"name\":\"_tokensCount\",\"type\":\"uint256\"}],\"name\":\"moveTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_uuid\",\"type\":\"bytes16\"}],\"name\":\"moveAllTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_allow\",\"type\":\"bool\"}],\"name\":\"allowAddress\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_customerUuid\",\"type\":\"bytes16\"},{\"name\":\"_weiAmount\",\"type\":\"uint256\"}],\"name\":\"allocate\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_uuid\",\"type\":\"bytes16\"},{\"name\":\"_tokensCount\",\"type\":\"uint256\"}],\"name\":\"addTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsale\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reclaimEther\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"destroyAndSend\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_vaultAddress\",\"type\":\"address\"},{\"name\":\"_defaultAllowed\",\"type\":\"address\"},{\"name\":\"_crowdsaleAddress\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":false,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"RntTokenProxy","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000066eee2be6388f8c19983185906ed89724c7b4cd0000000000000000000000007a21b92ed57027a8f32d4e1b91dfcf32110268c400000000000000000000000000973f9469337c2f52029d0dae8d8f9fb3af97be000000000000000000000000ce0589450422ce360215c6c50f9809e753e3829b","Library":"","SwarmSource":"bzzr://a01db930afe7d4e193eabf5bc869174b6cda1a1d2929f86f1b63fbb33b1361d9"}]}