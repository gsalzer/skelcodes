{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Destructible\r\n * @dev Base contract that can be destroyed by owner. All funds in contract will be sent to the owner.\r\n */\r\ncontract Destructible is Ownable {\r\n\r\n    function Destructible() public payable { }\r\n\r\n    /**\r\n     * @dev Transfers the current balance to the owner and terminates the contract.\r\n     */\r\n    function destroy() onlyOwner public {\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    function destroyAndSend(address _recipient) onlyOwner public {\r\n        selfdestruct(_recipient);\r\n    }\r\n}\r\n\r\n/**\r\n * @title PullPayment\r\n * @dev Base contract supporting async send for pull payments. Inherit from this\r\n * contract and use asyncSend instead of send.\r\n */\r\ncontract PullPayment {\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => uint256) public payments;\r\n    uint256 public totalPayments;\r\n\r\n    /**\r\n     * @dev Called by the payer to store the sent amount as credit to be pulled.\r\n     * @param dest The destination address of the funds.\r\n     * @param amount The amount to transfer.\r\n     */\r\n    function asyncSend(address dest, uint256 amount) internal {\r\n        payments[dest] = payments[dest].add(amount);\r\n        totalPayments = totalPayments.add(amount);\r\n    }\r\n\r\n    /**\r\n     * @dev withdraw accumulated balance, called by payee.\r\n     */\r\n    function withdrawPayments() public {\r\n        address payee = msg.sender;\r\n        uint256 payment = payments[payee];\r\n\r\n        require(payment != 0);\r\n        require(this.balance >= payment);\r\n\r\n        totalPayments = totalPayments.sub(payment);\r\n        payments[payee] = 0;\r\n\r\n        assert(payee.send(payment));\r\n    }\r\n}\r\n\r\n/**\r\n * @title Bounty\r\n * @dev This bounty will pay out to a researcher if they break invariant logic of the contract.\r\n */\r\ncontract Bounty is PullPayment, Destructible {\r\n    bool public claimed;\r\n    mapping(address => address) public researchers;\r\n\r\n    event TargetCreated(address createdAddress);\r\n\r\n    /**\r\n     * @dev Fallback function allowing the contract to receive funds, if they haven't already been claimed.\r\n     */\r\n    function() external payable {\r\n        require(!claimed);\r\n    }\r\n\r\n    /**\r\n     * @dev Create and deploy the target contract (extension of Target contract), and sets the\r\n     * msg.sender as a researcher\r\n     * @return A target contract\r\n     */\r\n    function createTarget() public returns(Target) {\r\n        Target target = Target(deployContract());\r\n        researchers[target] = msg.sender;\r\n        TargetCreated(target);\r\n        return target;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to deploy the target contract.\r\n     * @return A target contract address\r\n     */\r\n    function deployContract() internal returns(address);\r\n\r\n    /**\r\n     * @dev Sends the contract funds to the researcher that proved the contract is broken.\r\n     * @param target contract\r\n     */\r\n    function claim(Target target) public {\r\n        address researcher = researchers[target];\r\n        require(researcher != 0);\r\n        // Check Target contract invariants\r\n        require(!target.checkInvariant());\r\n        asyncSend(researcher, this.balance);\r\n        claimed = true;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Target\r\n * @dev Your main contract should inherit from this class and implement the checkInvariant method.\r\n */\r\ncontract Target {\r\n    /**\r\n     * @dev Checks all values a contract assumes to be true all the time. If this function returns\r\n     * false, the contract is broken in some way and is in an inconsistent state.\r\n     * In order to win the bounty, security researchers will try to cause this broken state.\r\n     * @return True if all invariant values are correct, false otherwise.\r\n     */\r\n    function checkInvariant() public returns(bool);\r\n}\r\n\r\n/*\r\n*  @title PricingStrategy\r\n*  An abstract class for all Pricing Strategy contracts.\r\n*/\r\ncontract PricingStrategy is Ownable {\r\n    /*\r\n    * @dev Number sold tokens for current strategy\r\n    */\r\n    uint256 public totalSoldTokens = 0;\r\n    uint256 public weiRaised = 0;\r\n    /*\r\n    * @dev Count number of tokens with bonuses\r\n    * @param _value uint256 Value in ether from investor\r\n    * @return uint256 Return number of tokens for investor\r\n    */\r\n    function countTokens(uint256 _value) internal returns (uint256 tokensAndBonus);\r\n\r\n    /*\r\n    * @dev Summing sold of tokens\r\n    * @param _tokensAndBonus uint256 Number tokens for current sale in a tranche\r\n    */\r\n    function soldInTranche(uint256 _tokensAndBonus) internal;\r\n\r\n    /*\r\n    * @dev Check required of tokens in the tranche\r\n    * @param _requiredTokens uint256 Number required of tokens\r\n    * @return boolean Return true if count of tokens is available\r\n    */\r\n    function getFreeTokensInTranche(uint256 _requiredTokens) internal constant returns (bool);\r\n\r\n    function isNoEmptyTranches() public constant returns(bool);\r\n}\r\n\r\ncontract  TranchePricingStrategy is PricingStrategy, Target {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public tokensCap;\r\n    uint256 public capInWei;\r\n\r\n    /*\r\n    * Define bonus schedule of tranches.\r\n    */\r\n    struct BonusSchedule {\r\n        uint256 bonus; // Bonus rate for current tranche\r\n        uint valueForTranche; // Amount of tokens available for the current period\r\n        uint rate; // How much tokens for one ether\r\n    }\r\n\r\n    //event for testing\r\n    event TokenForInvestor(uint256 _token, uint256 _tokenAndBonus, uint256 indexOfperiod);\r\n\r\n    uint tranchesCount = 0;\r\n    uint MAX_TRANCHES = 50;\r\n\r\n    //Store BonusStrategy in a fixed array, so that it can be seen in a blockchain explorer\r\n    BonusSchedule[] public tranches;\r\n\r\n    /*\r\n    * @dev Constructor\r\n    * @param _bonuses uint256[] Bonuses in tranches\r\n    * @param _valueForTranches uint[] Value of tokens in tranches\r\n    * @params _rates uint[] Rates for tranches\r\n    */\r\n    function TranchePricingStrategy(uint256[] _bonuses, uint[] _valueForTranches, uint[] _rates,\r\n        uint256 _capInWei, uint256 _tokensCap) public {\r\n\r\n        tokensCap = _tokensCap;\r\n        capInWei = _capInWei;\r\n        require(_bonuses.length == _valueForTranches.length && _valueForTranches.length == _rates.length);\r\n        require(_bonuses.length <= MAX_TRANCHES);\r\n\r\n        tranchesCount = _bonuses.length;\r\n\r\n        for (uint i = 0; i < _bonuses.length; i++) {\r\n                tranches.push(BonusSchedule({\r\n                bonus: _bonuses[i],\r\n                valueForTranche: _valueForTranches[i],\r\n                rate: _rates[i]\r\n            }));\r\n        }\r\n    }\r\n\r\n    /*\r\n    * @dev Count number of tokens with bonuses\r\n    * @param _value uint256 Value in ether\r\n    * @return uint256 Return number of tokens for an investor\r\n    */\r\n    function countTokens(uint256 _value) internal returns (uint256 tokensAndBonus) {\r\n        uint256 indexOfTranche = defineTranchePeriod();\r\n\r\n        require(indexOfTranche != MAX_TRANCHES + 1);\r\n\r\n        BonusSchedule currentTranche = tranches[indexOfTranche];\r\n        uint256 etherInWei = 1e18;\r\n\r\n        uint256 bonusRate = currentTranche.bonus;\r\n        uint val = msg.value * etherInWei;\r\n        uint256 oneTokenInWei = etherInWei/currentTranche.rate;\r\n        uint tokens = val / oneTokenInWei;\r\n        uint256 bonusToken = tokens.mul(bonusRate).div(100);\r\n        tokensAndBonus = tokens.add(bonusToken);\r\n\r\n        soldInTranche(tokensAndBonus);\r\n        weiRaised += _value;\r\n        TokenForInvestor(tokens, tokensAndBonus, indexOfTranche);\r\n        return tokensAndBonus;\r\n    }\r\n\r\n    /*\r\n    * @dev Check required of tokens in the tranche\r\n    * @param _requiredTokens uint256 Number of tokens\r\n    * @return boolean Return true if count of tokens is available\r\n    */\r\n    function getFreeTokensInTranche(uint256 _requiredTokens) internal constant returns (bool) {\r\n        bool hasTokens = false;\r\n        uint256 indexOfTranche = defineTranchePeriod();\r\n        hasTokens = tranches[indexOfTranche].valueForTranche > _requiredTokens;\r\n\r\n        return hasTokens;\r\n    }\r\n\r\n    /*\r\n    * @dev Summing sold of tokens\r\n    * @param _tokensAndBonus uint256 Number tokens for current sale\r\n    */\r\n    function soldInTranche(uint256 _tokensAndBonus) internal {\r\n        uint256 indexOfTranche = defineTranchePeriod();\r\n        require(tranches[indexOfTranche].valueForTranche >= _tokensAndBonus);\r\n        tranches[indexOfTranche].valueForTranche = tranches[indexOfTranche].valueForTranche.sub(_tokensAndBonus);\r\n        totalSoldTokens = totalSoldTokens.add(_tokensAndBonus);\r\n    }\r\n\r\n    /*\r\n    * @dev Check sum of the tokens for sale in the tranches in the crowdsale time\r\n    */\r\n    function isNoEmptyTranches() public constant returns(bool) {\r\n        uint256 sumFreeTokens = 0;\r\n        for (uint i = 0; i < tranches.length; i++) {\r\n            sumFreeTokens = sumFreeTokens.add(tranches[i].valueForTranche);\r\n        }\r\n        bool isValid = sumFreeTokens > 0;\r\n        return isValid;\r\n    }\r\n\r\n    /*\r\n    * @dev get index of tranche\r\n    * @return uint256 number of current tranche in array tranches\r\n    */\r\n    function defineTranchePeriod() internal constant returns (uint256) {\r\n        for (uint256 i = 0; i < tranches.length; i++) {\r\n            if (tranches[i].valueForTranche > 0) {\r\n                return i;\r\n            }\r\n        }\r\n        return MAX_TRANCHES + 1;\r\n    }\r\n\r\n    /* Now we have the Bounty code, as the contract is Bounty.\r\n    * @dev Function to check if the contract has been compromised.\r\n    */\r\n    function checkInvariant() public returns(bool) {\r\n\r\n        uint256 tranchePeriod = defineTranchePeriod();\r\n        bool isTranchesDone = tranchePeriod == MAX_TRANCHES + 1;\r\n        bool isTokensCapReached = tokensCap == totalSoldTokens;\r\n        bool isWeiCapReached = weiRaised == capInWei;\r\n\r\n        bool isNoCapReached = isTranchesDone &&\r\n            (!isTokensCapReached || !isWeiCapReached);\r\n\r\n        bool isExceededCap = !isTranchesDone &&\r\n            (isTokensCapReached || isWeiCapReached);\r\n\r\n        // Check the compromised flag.\r\n        if (isNoCapReached || isExceededCap) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function payContract() payable {\r\n        countTokens(msg.value);\r\n    }\r\n}\r\n\r\ncontract MowjowBounty is Bounty {\r\n\r\n    uint256[] public rates;\r\n    uint256[] public bonuses;\r\n    uint256[] public valueForTranches;\r\n    uint256 capInWei;\r\n    uint256 capInTokens;\r\n\r\n    function MowjowBounty (uint256[] _bonuses, uint256[] _valueForTranches,\r\n        uint256[] _rates, uint256 _capInWei, uint256 _capInTokens) public {\r\n\r\n        bonuses = _bonuses;\r\n        valueForTranches = _valueForTranches;\r\n        rates = _rates;\r\n        capInWei = _capInWei;\r\n        capInTokens = _capInTokens;\r\n    }\r\n\r\n    function deployContract() internal returns(address) {\r\n        return new TranchePricingStrategy(bonuses, valueForTranches, rates, capInWei, capInTokens);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"totalPayments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"researchers\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"}],\"name\":\"claim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"valueForTranches\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawPayments\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bonuses\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"createTarget\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rates\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"payments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"claimed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"destroyAndSend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_bonuses\",\"type\":\"uint256[]\"},{\"name\":\"_valueForTranches\",\"type\":\"uint256[]\"},{\"name\":\"_rates\",\"type\":\"uint256[]\"},{\"name\":\"_capInWei\",\"type\":\"uint256\"},{\"name\":\"_capInTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"createdAddress\",\"type\":\"address\"}],\"name\":\"TargetCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"MowjowBounty","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000001550f7dca70000000000000000000000000000000000000000000000000000a688906bd8b00000000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000064000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000003782dace9d9000000000000000000000000000000000000000000000000000003782dace9d9000000000000000000000000000000000000000000000000000003782dace9d900000000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000003e800000000000000000000000000000000000000000000000000000000000003e800000000000000000000000000000000000000000000000000000000000003e8","Library":"","SwarmSource":"bzzr://0a277a4e1ba4fe15a03315af925fc614d7b85589ab6ff927e5c95fe1225c7a6d"}]}