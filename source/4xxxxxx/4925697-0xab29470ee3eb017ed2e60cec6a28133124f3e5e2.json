{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\n/*\r\n* LooksCoin token sale contract\r\n*\r\n* Refer to https://lookscoin.com for more information.\r\n* \r\n* Developer: LookRev\r\n*\r\n*/\r\n\r\n/*\r\n * ERC20 Token Standard\r\n */\r\ncontract ERC20 {\r\nevent Transfer(address indexed _from, address indexed _to, uint256 _value);\r\nevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\nuint256 public totalSupply;\r\nfunction balanceOf(address _owner) constant public returns (uint256 balance);\r\nfunction transfer(address _to, uint256 _value) public returns (bool success);\r\nfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\nfunction approve(address _spender, uint256 _value) public returns (bool success);\r\nfunction allowance(address _owner, address _spender) constant public returns (uint256 remaining);\r\n}\r\n\r\n/**\r\n* Provides methods to safely add, subtract and multiply uint256 numbers.\r\n*/\r\nlibrary SafeMath {\r\n    /**\r\n     * Add two uint256 values, revert in case of overflow.\r\n     *\r\n     * @param a first value to add\r\n     * @param b second value to add\r\n     * @return a + b\r\n     */\r\n    function add(uint256 a, uint256 b) internal returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * Subtract one uint256 value from another, throw in case of underflow.\r\n     *\r\n     * @param a value to subtract from\r\n     * @param b value to subtract\r\n     * @return a - b\r\n     */\r\n    function sub(uint256 a, uint256 b) internal returns (uint256) {\r\n        assert(a >= b);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * Multiply two uint256 values, throw in case of overflow.\r\n     *\r\n     * @param a first value to multiply\r\n     * @param b second value to multiply\r\n     * @return a * b\r\n     */\r\n    function mul(uint256 a, uint256 b) internal returns (uint256) {\r\n        if (a == 0 || b == 0) return 0;\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * Divid uint256 values, throw in case of overflow.\r\n     *\r\n     * @param a first value numerator\r\n     * @param b second value denominator\r\n     * @return a / b\r\n     */\r\n    function div(uint256 a, uint256 b) internal returns (uint256) {\r\n        assert(b != 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n}\r\n\r\n/*\r\n    Provides support and utilities for contract ownership\r\n*/\r\ncontract Ownable {\r\n    address owner;\r\n    address newOwner;\r\n\r\n    function Ownable() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * Allows execution by the owner only.\r\n     */\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Transferring the contract ownership to the new owner.\r\n     *\r\n     * @param _newOwner new contractor owner\r\n     */\r\n    function transferOwnership(address _newOwner) onlyOwner {\r\n        if (_newOwner != 0x0) {\r\n          newOwner = _newOwner;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Accept the contract ownership by the new owner.\r\n     */\r\n    function acceptOwnership() {\r\n        require(msg.sender == newOwner);\r\n        owner = newOwner;\r\n        OwnershipTransferred(owner, newOwner);\r\n        newOwner = 0x0;\r\n    }\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n}\r\n\r\n/**\r\n* Standard Token Smart Contract\r\n*/\r\ncontract StandardToken is ERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * Mapping from addresses of token holders to the numbers of tokens belonging\r\n     * to these token holders.\r\n     */\r\n    mapping (address => uint256) balances;\r\n\r\n    /**\r\n     * Mapping from addresses of token holders to the mapping of addresses of\r\n     * spenders to the allowances set by these token holders to these spenders.\r\n     */\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n    /**\r\n     * Mapping from addresses of token holders to the mapping of token amount spent.\r\n     * Use by the token holders to spend their utility tokens.\r\n     */\r\n    mapping (address => mapping (address => uint256)) spentamount;\r\n\r\n    /**\r\n     * Mapping of the addition of patrons.\r\n     */\r\n    mapping (address => bool) patronAppended;\r\n\r\n    /**\r\n     * Mapping of the addresses of patrons.\r\n     */\r\n    address[] patrons;\r\n\r\n    /**\r\n     * Mapping of the addresses of VIP token holders.\r\n     */\r\n    address[] vips;\r\n\r\n    /**\r\n    * Mapping for VIP rank for qualified token holders\r\n    * Higher VIP rank (with earlier timestamp) has higher bidding priority when\r\n    * competing for the same product or service on platform.\r\n    */\r\n    mapping (address => uint256) viprank;\r\n\r\n    /**\r\n     * Get number of tokens currently belonging to given owner.\r\n     *\r\n     * @param _owner address to get number of tokens currently belonging to its owner\r\n     *\r\n     * @return number of tokens currently belonging to the owner of given address\r\n     */\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    /**\r\n     * Transfer given number of tokens from message sender to given recipient.\r\n     *\r\n     * @param _to address to transfer tokens to the owner of\r\n     * @param _value number of tokens to transfer to the owner of given address\r\n     * @return true if tokens were transferred successfully, false otherwise\r\n     */\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        require(_to != 0x0);\r\n        if (balances[msg.sender] < _value) return false;\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Transfer given number of tokens from given owner to given recipient.\r\n     *\r\n     * @param _from address to transfer tokens from the owner of\r\n     * @param _to address to transfer tokens to the owner of\r\n     * @param _value number of tokens to transfer from given owner to given\r\n     *        recipient\r\n     * @return true if tokens were transferred successfully, false otherwise\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) \r\n        returns (bool success) {\r\n        require(_to != 0x0);\r\n        if(_from == _to) return false;\r\n        if (balances[_from] < _value) return false;\r\n        if (_value > allowed[_from][msg.sender]) return false;\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Allow given spender to transfer given number of tokens from message sender.\r\n     *\r\n     * @param _spender address to allow the owner of to transfer tokens from\r\n     *        message sender\r\n     * @param _value number of tokens to allow to transfer\r\n     * @return true if token transfer was successfully approved, false otherwise\r\n     */\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n\r\n        // To change the approve amount you first have to reduce the addresses`\r\n        //  allowance to zero by calling approve(_spender, 0) if it is not\r\n        //  already 0 to mitigate the race condition described here:\r\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) {\r\n           return false;\r\n        }\r\n        if (balances[msg.sender] < _value) {\r\n            return false;\r\n        }\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n     }\r\n\r\n    /**\r\n     * Tell how many tokens given spender is currently allowed to transfer from\r\n     * given owner.\r\n     *\r\n     * @param _owner address to get number of tokens allowed to be transferred\r\n     *        from the owner of\r\n     * @param _spender address to get number of tokens allowed to be transferred\r\n     *        by the owner of\r\n     * @return number of tokens given spender is currently allowed to transfer\r\n     *         from given owner\r\n     */\r\n     function allowance(address _owner, address _spender) constant \r\n        returns (uint256 remaining) {\r\n       return allowed[_owner][_spender];\r\n     }\r\n}\r\n\r\n/**\r\n * LooksCoin Token\r\n *\r\n * LooksCoin Token is an utility token that can be purchased through crowdsale or earned on\r\n * the LookRev platform. It can be spent to purchase creative products and services on\r\n * LookRev platform.\r\n *\r\n * VIP rank is used to calculate priority when competing with other bids\r\n * for the same product or service on the platform. \r\n * Higher VIP rank (with earlier timestamp) has higher priority.\r\n * Higher VIP rank wallet address owner can outbid other lower ranking owners only once\r\n * per selling window or promotion period.\r\n * VIP rank is recorded at the time when the wallet address first reach VIP LooksCoin \r\n * holding level for a token purchaser.\r\n * VIP rank is valid for the lifetime of a wallet address on the platform, as long as it \r\n * meets the VIP holding level.\r\n\r\n * Usage of the LooksCoin, VIP rank and token utilities are described on the website\r\n * https://lookscoin.com.\r\n *\r\n */\r\ncontract LooksCoin is StandardToken, Ownable {\r\n\r\n    /**\r\n     * Number of decimals of the smallest unit\r\n     */\r\n    uint256 public constant decimals = 18;\r\n\r\n    /**\r\n     * VIP Holding Level. Minimium token holding amount to record a VIP rank.\r\n     * Token holding address needs have at least 24000 LooksCoin to be ranked as VIP\r\n     * VIP rank can only be set through purchasing tokens\r\n     */\r\n    uint256 public constant VIP_MINIMUM = 24000e18;\r\n\r\n    /**\r\n     * Initial number of tokens.\r\n     */\r\n    uint256 constant INITIAL_TOKENS_COUNT = 100000000e18;\r\n\r\n    /**\r\n     * Crowdsale contract address.\r\n     */\r\n    address public tokenSaleContract = 0x0;\r\n\r\n    /**\r\n     * Init Placeholder\r\n     */\r\n    address coinmaster = address(0xd3c79e4AD654436d59AfD61363Bc2B927d2fb680);\r\n\r\n    /**\r\n     * Create new LooksCoin token smart contract.\r\n     */\r\n    function LooksCoin() {\r\n        owner = coinmaster;\r\n        balances[owner] = INITIAL_TOKENS_COUNT;\r\n        totalSupply = INITIAL_TOKENS_COUNT;\r\n    }\r\n\r\n    /**\r\n     * Get name of this token.\r\n     *\r\n     * @return name of this token\r\n     */\r\n    function name() constant returns (string name) {\r\n      return \"LooksCoin\";\r\n    }\r\n\r\n    /**\r\n     * Get symbol of this token.\r\n     *\r\n     * @return symbol of this token\r\n     */\r\n    function symbol() constant returns (string symbol) {\r\n      return \"LOOKS\";\r\n    }\r\n\r\n    /**\r\n     * @dev Set new token sale contract.\r\n     * May only be called by owner.\r\n     *\r\n     * @param _newTokenSaleContract new token sale manage contract.\r\n     */\r\n    function setTokenSaleContract(address _newTokenSaleContract) {\r\n        require(msg.sender == owner);\r\n        assert(_newTokenSaleContract != 0x0);\r\n        tokenSaleContract = _newTokenSaleContract;\r\n    }\r\n\r\n    /**\r\n     * Get VIP rank of a given owner.\r\n     * VIP rank is valid for the lifetime of a token wallet address, \r\n     * as long as it meets VIP holding level.\r\n     *\r\n     * @param _to participant address to get the vip rank\r\n     * @return vip rank of the owner of given address\r\n     */\r\n    function getVIPRank(address _to) constant public returns (uint256 rank) {\r\n        if (balances[_to] < VIP_MINIMUM) {\r\n            return 0;\r\n        }\r\n        return viprank[_to];\r\n    }\r\n\r\n    /**\r\n     * Check and update VIP rank of a given token buyer.\r\n     * Contribution timestamp is recorded for VIP rank.\r\n     * Recorded timestamp for VIP rank should always be earlier than the current time.\r\n     *\r\n     * @param _to address to check the vip rank.\r\n     * @return rank vip rank of the owner of given address if any\r\n     */\r\n    function updateVIPRank(address _to) returns (uint256 rank) {\r\n        // Contribution timestamp is recorded for VIP rank\r\n        // Recorded timestamp for VIP rank should always be earlier than current time\r\n        if (balances[_to] >= VIP_MINIMUM && viprank[_to] == 0) {\r\n            viprank[_to] = now;\r\n            vips.push(_to);\r\n        }\r\n        return viprank[_to];\r\n    }\r\n\r\n    event TokenRewardsAdded(address indexed participant, uint256 balance);\r\n    /**\r\n     * Reward participant the tokens they purchased or earned\r\n     *\r\n     * @param _to address to credit tokens to the \r\n     * @param _value number of tokens to transfer to given recipient\r\n     *\r\n     * @return true if tokens were transferred successfully, false otherwise\r\n     */\r\n    function rewardTokens(address _to, uint256 _value) {\r\n        require(msg.sender == tokenSaleContract || msg.sender == owner);\r\n        assert(_to != 0x0);\r\n        require(_value > 0);\r\n\r\n        balances[_to] = balances[_to].add(_value);\r\n        totalSupply = totalSupply.add(_value);\r\n        updateVIPRank(_to);\r\n        TokenRewardsAdded(_to, _value);\r\n    }\r\n\r\n    event SpentTokens(address indexed participant, address indexed recipient, uint256 amount);\r\n    /**\r\n     * Spend given number of tokens for a usage.\r\n     *\r\n     * @param _to address to spend utility tokens at\r\n     * @param _value number of tokens to spend\r\n     * @return true on success, false on error\r\n     */\r\n    function spend(address _to, uint256 _value) public returns (bool success) {\r\n        require(_value > 0);\r\n        assert(_to != 0x0);\r\n        if (balances[msg.sender] < _value) return false;\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        spentamount[msg.sender][_to] = spentamount[msg.sender][_to].add(_value);\r\n\r\n        SpentTokens(msg.sender, _to, _value);\r\n        if(!patronAppended[msg.sender]) {\r\n            patronAppended[msg.sender] = true;\r\n            patrons.push(msg.sender);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    event Burn(address indexed burner, uint256 value);\r\n    /**\r\n     * Burn given number of tokens belonging to message sender.\r\n     * It can be applied by account with address this.tokensaleContract\r\n     *\r\n     * @param _value number of tokens to burn\r\n     * @return true on success, false on error\r\n     */\r\n    function burnTokens(address burner, uint256 _value) public returns (bool success) {\r\n        require(msg.sender == burner || msg.sender == owner);\r\n        assert(burner != 0x0);\r\n        if (_value > totalSupply) return false;\r\n        if (_value > balances[burner]) return false;\r\n        \r\n        balances[burner] = balances[burner].sub(_value);\r\n        totalSupply = totalSupply.sub(_value);\r\n        Burn(burner, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Get the VIP owner at the index.\r\n     *\r\n     * @param index of the VIP owner on the VIP list\r\n     * @return address of the VIP owner\r\n     */\r\n    function getVIPOwner(uint256 index) constant returns (address vipowner) {\r\n        return (vips[index]);\r\n    }\r\n\r\n    /**\r\n     * Get the count of VIP owners.\r\n     *\r\n     * @return count of VIP owners list.\r\n     */\r\n    function getVIPCount() constant returns (uint256 count) {\r\n        return vips.length;\r\n    }\r\n\r\n    /**\r\n     * Get the patron at the index.\r\n     *\r\n     * @param index of the patron on the patron list\r\n     * @return address of the patron\r\n     */\r\n    function getPatron(uint256 index) constant returns (address patron) {\r\n        return (patrons[index]);\r\n    }\r\n\r\n    /**\r\n     * Get the count of patrons.\r\n     *\r\n     * @return number of patrons.\r\n     */\r\n    function getPatronsCount() constant returns (uint256 count) {\r\n        return patrons.length;\r\n    }\r\n}\r\n\r\n/**\r\n * LooksCoin CrowdSale Contract\r\n *\r\n * The token sale controller, allows contributing ether in exchange for LooksCoin.\r\n * The price (exchange rate with ETH) is 2400 LooksCoin per ETH at crowdsale.\r\n *\r\n * VIP rank is used to calculate priority when competing with other bids\r\n * for the same product or service on the platform. \r\n * Higher VIP rank (with earlier timestamp) has higher priority.\r\n * Higher VIP rank wallet address owner can outbid other lower ranking owners only once\r\n * per selling window or promotion period.\r\n * VIP rank is recorded at the time when the wallet address first reach VIP LooksCoin \r\n * holding level for a token purchaser.\r\n * VIP rank is valid for the lifetime of a wallet address on the platform, as long as it \r\n * meets the VIP holding level.\r\n *\r\n *\r\n * LooksCoin CrowdSale Bonus\r\n *******************************************************************************************************************\r\n * First Ten (1st to 10th) VIP owners get 20% bonus LooksCoin in their VIP wallet addresses\r\n * Eleven (11th) to Fifty (50th) VIP owners get 10% bonus of the LooksCoin in their VIP wallet addresses\r\n * Fifty One (51th) to One Hundred (100th) VIP owners get 5% bonus of the LooksCoin in their VIP wallet addresses\r\n *******************************************************************************************************************\r\n *\r\n * Bonus LooksCoin will be distributed by coin master when LooksCoin has 100 VIP wallet addresses\r\n * Bonus is calculated as:\r\n *   Percentage of Bonus * Amount of LooksCoin at the wallet address at the time recorded on the VIP rank timestamp\r\n * \r\n */\r\ncontract LooksCoinCrowdSale {\r\n    LooksCoin public looksCoin;\r\n    ERC20 public preSaleToken;\r\n\r\n    // initial price in wei (numerator)\r\n    uint256 public constant TOKEN_PRICE_N = 1;\r\n    // initial price in wei (denominator)\r\n    uint256 public constant TOKEN_PRICE_D = 2400;\r\n    // 1 ETH = 2,400 LOOKS tokens\r\n\r\n    address public saleController = 0x0;\r\n\r\n    // Amount of imported tokens from preSale\r\n    uint256 public importedTokens = 0;\r\n\r\n    // Amount of tokens sold\r\n    uint256 public tokensSold = 0;\r\n\r\n    /**\r\n     * Address of the owner of this smart contract.\r\n     */\r\n    address fundstorage = 0x0;\r\n\r\n    /**\r\n     * States of the crowdsale contract.\r\n     */\r\n    enum State{\r\n        Pause,\r\n        Init,\r\n        Running,\r\n        Stopped,\r\n        Migrated\r\n    }\r\n\r\n    State public currentState = State.Running;    \r\n\r\n    /**\r\n     * Modifier.\r\n     */\r\n    modifier onCrowdSaleRunning() {\r\n        // Checks, if CrowdSale is running and has not been paused\r\n        require(currentState == State.Running);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Create new crowdsale smart contract, make message sender to be the\r\n     * owner of smart contract.\r\n     */\r\n    function LooksCoinCrowdSale() {\r\n        saleController = msg.sender;\r\n        fundstorage = msg.sender;\r\n\r\n        preSaleToken = ERC20(0x253C7dd074f4BaCb305387F922225A4f737C08bd);\r\n    }\r\n\r\n    /**\r\n    * @dev Set new state\r\n    * @param _newState Value of new state\r\n    */\r\n    function setState(State _newState)\r\n    {\r\n        require(msg.sender == saleController);\r\n        currentState = _newState;\r\n    }\r\n\r\n    /**\r\n    * @dev Set token contract address\r\n    * @param _tokenContract address of LooksCoin token contract\r\n    */\r\n    function setTokenContract(address _tokenContract)\r\n    {\r\n        require(msg.sender == saleController);\r\n        assert(_tokenContract != 0x0);\r\n        looksCoin = LooksCoin(_tokenContract);\r\n    }\r\n\r\n    /**\r\n    * @dev Set token contract address for migration\r\n    * @param _prevTokenContract address of token contract for migration\r\n    */\r\n    function setMigrateTokenContract(address _prevTokenContract)\r\n    {\r\n        require(msg.sender == saleController);\r\n        assert(_prevTokenContract != 0x0);\r\n        preSaleToken = ERC20(_prevTokenContract);\r\n    }\r\n\r\n    /**\r\n     * @dev Set new token sale controller.\r\n     * May only be called by sale controller.\r\n     *\r\n     * @param _newSaleController new token sale controller.\r\n     */\r\n    function setSaleController(address _newSaleController) {\r\n        require(msg.sender == saleController);\r\n        assert(_newSaleController != 0x0);\r\n        saleController = _newSaleController;\r\n    }\r\n\r\n    /**\r\n     * Set new wallet address for the smart contract.\r\n     * May only be called by smart contract owner.\r\n     *\r\n     * @param _fundstorage new wallet address of the smart contract.\r\n     */\r\n    function setWallet(address _fundstorage) {\r\n        require(msg.sender == saleController);\r\n        assert(_fundstorage != 0x0);\r\n        fundstorage = _fundstorage;\r\n    }\r\n\r\n    /**\r\n    * saves info if account's tokens were imported from previous sale.\r\n    */\r\n    mapping (address => bool) private importedFromPreSale;\r\n\r\n    event TokensImport(address indexed participant, uint256 tokens, uint256 totalImport);\r\n    /**\r\n    * Imports account's tokens from previous sale\r\n    * It can be done only by account owner or sale controller\r\n    * @param _account Address of account which tokens will be imported\r\n    */\r\n    function importTokens(address _account) returns (bool success) {\r\n        // only token holder or sale controller can do import\r\n        require(currentState == State.Running);\r\n        require(msg.sender == saleController || msg.sender == _account);\r\n        require(!importedFromPreSale[_account]);\r\n\r\n        uint256 preSaleBalance = preSaleToken.balanceOf(_account);\r\n\r\n        if (preSaleBalance == 0) return false;\r\n\r\n        looksCoin.rewardTokens(_account, preSaleBalance);\r\n        importedTokens = importedTokens + preSaleBalance;\r\n        importedFromPreSale[_account] = true;\r\n        TokensImport(_account, preSaleBalance, importedTokens);\r\n        return true;\r\n    }\r\n\r\n    // fallback\r\n    function() public payable {\r\n        buyTokens();\r\n    }\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event TokensBought(address indexed buyer, uint256 ethers, uint256 tokens, uint256 tokensSold);\r\n    /**\r\n     * Accept ethers to buy tokens during the token sale\r\n     * Minimium holdings to receive a VIP rank is 24000 LooksCoin\r\n     */\r\n    function buyTokens() payable returns (uint256 amount)\r\n    {\r\n        require(currentState == State.Running);\r\n        assert(msg.sender != 0x0);\r\n        require(msg.value > 0);\r\n\r\n        // Calculate number of tokens for contributed wei\r\n        uint256 tokens = msg.value * TOKEN_PRICE_D / TOKEN_PRICE_N;\r\n        if (tokens == 0) return 0;\r\n\r\n        looksCoin.rewardTokens(msg.sender, tokens);\r\n        tokensSold = tokensSold + tokens;\r\n\r\n        // Log the tokens purchased \r\n        Transfer(0x0, msg.sender, tokens);\r\n        TokensBought(msg.sender, msg.value, tokens, tokensSold);\r\n\r\n        assert(fundstorage.send(msg.value));\r\n        return tokens;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"currentState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"importedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_PRICE_D\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleController\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_PRICE_N\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newState\",\"type\":\"uint8\"}],\"name\":\"setState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"preSaleToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_prevTokenContract\",\"type\":\"address\"}],\"name\":\"setMigrateTokenContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"}],\"name\":\"setTokenContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"looksCoin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyTokens\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fundstorage\",\"type\":\"address\"}],\"name\":\"setWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"importTokens\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newSaleController\",\"type\":\"address\"}],\"name\":\"setSaleController\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"participant\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalImport\",\"type\":\"uint256\"}],\"name\":\"TokensImport\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethers\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensSold\",\"type\":\"uint256\"}],\"name\":\"TokensBought\",\"type\":\"event\"}]","ContractName":"LooksCoinCrowdSale","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://79e42c89276a4c85e4d0c733167ce7d89a208a480f261691f184d30a8ef8b2a1"}]}