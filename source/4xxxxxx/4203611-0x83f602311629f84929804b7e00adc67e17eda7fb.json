{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^ 0.4.15;\r\n\r\n/**\r\n*library name : SafeMath\r\n*purpose : be the library for the smart contract for the swap between the godz and ether\r\n*goal : to achieve the secure basic math operations\r\n*/\r\nlibrary SafeMath {\r\n\r\n  /*function name : mul*/\r\n  /*purpose : be the funcion for safe multiplicate*/\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    /*assert(a == 0 || c / a == b);*/\r\n    return c;\r\n  }\r\n\r\n  /*function name : div*/\r\n  /*purpose : be the funcion for safe division*/\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n\r\n  /*function name : sub*/\r\n  /*purpose : be the funcion for safe substract*/\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    /*assert(b <= a);*/\r\n    return a - b;\r\n  }\r\n\r\n  /*function name : add*/\r\n  /*purpose : be the funcion for safe sum*/\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    /*assert(c >= a);*/\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n*contract name : ReentryProtected\r\n*/\r\ncontract ReentryProtected{\r\n    /*The reentry protection state mutex.*/\r\n    bool __reMutex;\r\n\r\n    /**\r\n    *This modifier can be used on functions with external calls to\r\n    *prevent reentry attacks.\r\n    *Constraints:\r\n    *Protected functions must have only one point of exit.\r\n    *Protected functions cannot use the `return` keyword\r\n    *Protected functions return values must be through return parameters.\r\n    */\r\n    modifier preventReentry() {\r\n        require(!__reMutex);\r\n        __reMutex = true;\r\n        _;\r\n        delete __reMutex;\r\n        return;\r\n    }\r\n\r\n    /**\r\n    *This modifier can be applied to public access state mutation functions\r\n    *to protect against reentry if a `preventReentry` function has already\r\n    *set the mutex. This prevents the contract from being reenter under a\r\n    *different memory context which can break state variable integrity.\r\n    */\r\n    modifier noReentry() {\r\n        require(!__reMutex);\r\n        _;\r\n    }\r\n}\r\n\r\n/**\r\n*contract name : GodzSwapGodzEtherCompliance\r\n*purpose : be the smart contract for compliance of the greater than usd5000\r\n*/\r\ncontract GodzSwapGodzEtherCompliance{\r\n    //address of the owner of the contract\r\n    address public owner;\r\n    \r\n    /*structure for store the sale*/\r\n    struct GodzBuyAccounts\r\n    {\r\n        uint256 amount;/*amount sent*/\r\n        address account;/*account that sent*/\r\n        uint sendGodz;/*if send the godz back*/\r\n    }\r\n\r\n    /*mapping of the acounts that send more than usd5000*/\r\n    mapping(uint=>GodzBuyAccounts) public accountsHolding;\r\n    \r\n    /*index of the account information*/\r\n    uint public indexAccount = 0;\r\n\r\n    /*account information*/\r\n    address public swapContract;/*address of the swap contract*/\r\n\r\n\r\n    /*function name : GodzSwapGodzEtherCompliance*/\r\n    /*purpose : be the constructor and the setter of the owner*/\r\n    /*goal : to set the owner of the contract*/    \r\n    function GodzSwapGodzEtherCompliance()\r\n    {\r\n        /*sets the owner of the contract than compliance with the greater than usd5000 maximiun*/\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /*function name : setHolderInformation*/\r\n    /*purpose : be the setter of the swap contract and wallet holder*/\r\n    /*goal : to set de swap contract address and the wallet holder address*/    \r\n    function setHolderInformation(address _swapContract)\r\n    {    \r\n        /*if the owner is setting the information of the holder and the swap*/\r\n        if (msg.sender==owner)\r\n        {\r\n            /*address of the swap contract*/\r\n            swapContract = _swapContract;\r\n        }\r\n    }\r\n\r\n    /*function name : SaveAccountBuyingGodz*/\r\n    /*purpose : be the safe function that map the account that send it*/\r\n    /*goal : to store the account information*/\r\n    function SaveAccountBuyingGodz(address account, uint256 amount) public returns (bool success) \r\n    {\r\n        /*if the sender is the swapContract*/\r\n        if (msg.sender==swapContract)\r\n        {\r\n            /*increment the index*/\r\n            indexAccount += 1;\r\n            /*store the account informacion*/\r\n            accountsHolding[indexAccount].account = account;\r\n            accountsHolding[indexAccount].amount = amount;\r\n            accountsHolding[indexAccount].sendGodz = 0;\r\n            /*transfer the ether to the wallet holder*/\r\n            /*account save was completed*/\r\n            return true;\r\n        }\r\n        else\r\n        {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /*function name : setSendGodz*/\r\n    /*purpose : be the flag update for the compliance account*/\r\n    /*goal : to get the flag on the account*/\r\n    function setSendGodz(uint index) public \r\n    {\r\n        if (owner == msg.sender)\r\n        {\r\n            accountsHolding[index].sendGodz = 1;\r\n        }\r\n    }\r\n\r\n    /*function name : getAccountInformation*/\r\n    /*purpose : be the getter of the information of the account*/\r\n    /*goal : to get the amount and the acount of a compliance account*/\r\n    function getAccountInformation(uint index) public returns (address account, uint256 amount, uint sendGodz)\r\n    {\r\n        /*return the account of a compliance*/\r\n        return (accountsHolding[index].account, accountsHolding[index].amount, accountsHolding[index].sendGodz);\r\n    }\r\n}\r\n\r\n/**\r\n*contract name : GodzSwapGodzEther\r\n*purpose : be the smart contract for the swap between the godz and ether\r\n*goal : to achieve the swap transfers\r\n*/\r\ncontract GodzSwapGodzEther  is ReentryProtected{\r\n    address public seller;/*address of the owner of the contract creation*/\r\n    address public tokenContract;/*address of the erc20 token smart contract for the swap*/\r\n    address public complianceContract;/*compliance contract*/\r\n    address public complianceWallet;/*compliance wallet address*/\r\n    uint256 public sellPrice;/*value price of the swap*/\r\n    uint256 public sellQuantity;/*quantity value of the swap*/\r\n\r\n    /*function name : GodzSwapGodzEther*/\r\n    /*purpose : be the constructor of the swap smart contract*/\r\n    /*goal : register the basic information of the swap smart contract*/\r\n    function GodzSwapGodzEther(\r\n    address token,\r\n    address complianceC,\r\n    address complianceW\r\n    ){\r\n        tokenContract = token;\r\n        /*owner of the quantity of supply of the erc20 token*/\r\n        seller = msg.sender;\r\n        /*swap price of the token supply*/\r\n        sellPrice = 0.00625 * 1 ether;\r\n        /*total quantity to swap*/\r\n        sellQuantity = SafeMath.mul(210000000, 1 ether);\r\n        /*compliance contract store accounts*/\r\n        complianceContract = complianceC;\r\n        /*compliance wallet holder*/\r\n        complianceWallet = complianceW;\r\n    }\r\n\r\n    /*function name : () payable*/\r\n    /*purpose : be the swap executor*/\r\n    /*goal : to transfer the godz to the investor and the ether to the owner of the godz*/\r\n    function() payable preventReentry\r\n    {\r\n        /*address of the buyer*/\r\n        address buyer = msg.sender;\r\n\r\n        /*value paid and receive on the swap call*/\r\n        uint256 valuePaid = msg.value;\r\n\r\n        /*set the quantity of godz on behalf of the ether that is send to this function*/\r\n  \t\t  uint256 buyQuantity = SafeMath.mul((SafeMath.div(valuePaid, sellPrice)), 1 ether);\r\n\r\n        /*gets the balance of the owner of the godz*/\r\n        uint256 balanceSeller = Token(tokenContract).balanceOf(seller);\r\n\r\n        /*get the allowance of the owner of the godz*/\r\n  \t\tuint256 balanceAllowed = Token(tokenContract).allowance(seller,this);\r\n\r\n        if (seller!=buyer) /*if the seller of godz on swap is different than the investor buying*/\r\n        {\r\n            /*if the balance and the allowance match a valid quantity swap*/\r\n      \t\tif ((balanceAllowed >= buyQuantity) && (balanceSeller >= buyQuantity))\r\n            {\r\n                /*if the msg.value(ether sent) is greater than compliance, store it and sent to the wallet holder*/\r\n                if (valuePaid>(20 * 1 ether))\r\n                {\r\n                    /*transfer the value(ether) to the compliance holder wallet*/\r\n                    complianceWallet.transfer(valuePaid);\r\n                    /*save the account information*/\r\n                    require(GodzSwapGodzEtherCompliance(complianceContract).SaveAccountBuyingGodz(buyer, valuePaid));\r\n                }\r\n                else\r\n                {\r\n                    /*transfer the ether inside to the seller of the godz*/\r\n                    seller.transfer(valuePaid);\r\n                    /*call the transferfrom function of the erc20 token smart contract*/\r\n                    require(Token(tokenContract).transferFrom(seller, buyer, buyQuantity));\r\n                }\r\n            }\r\n            else/*if not a valid match between allowance and balance of the owner of godz, return the ether*/\r\n            {\r\n                /*send back the ether received*/\r\n                buyer.transfer(valuePaid);\r\n            }\r\n        }\r\n    }\r\n\r\n    /*function name : safeWithdrawal*/\r\n    /*purpose : be the safe withrow function in case of the contract keep ether inside*/\r\n    /*goal : to transfer the ether to the owner of the swap contract*/\r\n    function safeWithdrawal()\r\n    {\r\n        /*requires that the contract call is the owner of the swap contract*/\r\n        /*require(seller == msg.sender);*/\r\n        /*if the seller of the godz is the call contract address*/\r\n        if (seller == msg.sender)\r\n        {\r\n            /*transfer the ether inside to the seller of the godz*/\r\n            seller.transfer(this.balance);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n*contract name : tokenRecipient\r\n*/\r\ncontract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\r\n\r\n/**\r\n*contract name : Token\r\n*/\r\ncontract Token {\r\n    /*using the secure math library for basic math operations*/\r\n    using SafeMath for uint256;\r\n\r\n    /* Public variables of the token */\r\n    string public standard = 'DSCS.GODZ.TOKEN';\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    uint256 public totalSupply;\r\n\r\n    /* This creates an array with all balances */\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n    /* This generates a public event on the blockchain that will notify clients */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /* Initializes contract with initial supply tokens to the creator of the contract */\r\n    function Token(\r\n        uint256 initialSupply,\r\n        string tokenName,\r\n        uint8 decimalUnits,\r\n        string tokenSymbol\r\n        ) {\r\n        balanceOf[msg.sender] = initialSupply;                  /* Give the creator all initial tokens*/\r\n        totalSupply = initialSupply;                            /* Update total supply*/\r\n        name = tokenName;                                       /* Set the name for display purposes*/\r\n        symbol = tokenSymbol;                                   /* Set the symbol for display purposes*/\r\n        decimals = decimalUnits;                                /* Amount of decimals for display purposes*/\r\n    }\r\n\r\n    /* Send coins */\r\n    function transfer(address _to, uint256 _value) {\r\n        if (_to == 0x0) revert();                               /* Prevent transfer to 0x0 address. Use burn() instead*/\r\n        if (balanceOf[msg.sender] < _value) revert();           /* Check if the sender has enough*/\r\n        if (balanceOf[_to] + _value < balanceOf[_to]) revert(); /* Check for overflows*/\r\n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);                        /* Subtract from the sender*/\r\n        balanceOf[_to] = balanceOf[_to].add(_value);                               /* Add the same to the recipient*/\r\n        Transfer(msg.sender, _to, _value);                      /* Notify anyone listening that this transfer took place*/\r\n    }\r\n\r\n    /* Allow another contract to spend some tokens in your behalf */\r\n    function approve(address _spender, uint256 _value)\r\n        returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        return true;\r\n    }\r\n\r\n    /* Approve and then communicate the approved contract in a single tx */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\r\n        returns (bool success) {\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /* A contract attempts to get the coins but transfer from the origin*/\r\n    function transferFromOrigin(address _to, uint256 _value)  returns (bool success) {\r\n        address origin = tx.origin;\r\n        if (origin == 0x0) revert();\r\n        if (_to == 0x0) revert();                                /* Prevent transfer to 0x0 address.*/\r\n        if (balanceOf[origin] < _value) revert();                /* Check if the sender has enough*/\r\n        if (balanceOf[_to] + _value < balanceOf[_to]) revert();  /* Check for overflows*/\r\n        balanceOf[origin] = balanceOf[origin].sub(_value);       /* Subtract from the sender*/\r\n        balanceOf[_to] = balanceOf[_to].add(_value);             /* Add the same to the recipient*/\r\n        return true;\r\n    }\r\n\r\n    /* A contract attempts to get the coins */\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        if (_to == 0x0) revert();                                /* Prevent transfer to 0x0 address.*/\r\n        if (balanceOf[_from] < _value) revert();                 /* Check if the sender has enough*/\r\n        if (balanceOf[_to] + _value < balanceOf[_to]) revert();  /* Check for overflows*/\r\n        if (_value > allowance[_from][msg.sender]) revert();     /* Check allowance*/\r\n        balanceOf[_from] = balanceOf[_from].sub(_value);                              /* Subtract from the sender*/\r\n        balanceOf[_to] = balanceOf[_to].add(_value);                                /* Add the same to the recipient*/\r\n        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"seller\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellQuantity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"complianceWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"complianceContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"safeWithdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"complianceC\",\"type\":\"address\"},{\"name\":\"complianceW\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"GodzSwapGodzEther","CompilerVersion":"v0.4.16+commit.d7661dd9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000061d0407edb149dc453c47fe31139fae9c1472da60000000000000000000000003fff7a8bfacfe01c901980b894f716987446364d00000000000000000000000088915327bf46a835de49362aded040bc15119d62","Library":"","SwarmSource":"bzzr://2430a99ee58b142a82eb90d89cced71476756ff9a8f543d7144ec37d141fa87b"}]}