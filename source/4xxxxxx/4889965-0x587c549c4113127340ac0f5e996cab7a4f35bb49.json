{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.17;\r\n\r\n\r\nlibrary SafeMath {\r\n    function mul(uint a, uint b) internal pure  returns(uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function sub(uint a, uint b) internal pure  returns(uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint a, uint b) internal pure  returns(uint) {\r\n        uint c = a + b;\r\n        assert(c >= a && c >= b);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract ERC20 {\r\n    uint public totalSupply;\r\n\r\n    function balanceOf(address who) public view returns(uint);\r\n\r\n    function allowance(address owner, address spender) public view returns(uint);\r\n\r\n    function transfer(address to, uint value) public returns(bool ok);\r\n\r\n    function transferFrom(address from, address to, uint value) public returns(bool ok);\r\n\r\n    function approve(address spender, uint value) public returns(bool ok);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n\r\n    address public owner;\r\n    \r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n    * account.\r\n    */\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address newOwner) onlyOwner public {\r\n        require(newOwner != address(0));\r\n        OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool public paused = false;\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n    modifier whenPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n    function pause() public onlyOwner whenNotPaused {\r\n        paused = true;\r\n        Pause();\r\n    }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n    function unpause() public onlyOwner whenPaused {\r\n        paused = false;\r\n        Unpause();\r\n    }\r\n}\r\n\r\n\r\n/// @title Migration Agent interface\r\ncontract MigrationAgent {\r\n\r\n    function migrateFrom(address _from, uint256 _value) public;\r\n}\r\n\r\n\r\n// Crowdsale Smart Contract\r\n// This smart contract collects ETH and in return sends tokens to the Backers\r\ncontract Crowdsale is Pausable {\r\n\r\n    using SafeMath for uint;\r\n\r\n    struct Backer {\r\n        uint weiReceived; // amount of ETH contributed\r\n        uint tokensSent; // amount of tokens  sent  \r\n        bool refunded; // true if user has been refunded       \r\n    }\r\n\r\n    Token public token; // Token contract reference   \r\n    address public multisig; // Multisig contract that will receive the ETH    \r\n    address public team; // Address to which the team tokens will be sent   \r\n    address public zen; // Address to which zen team tokens will be sent\r\n    uint public ethReceived; // Number of ETH received\r\n    uint public totalTokensSent; // Number of tokens sent to ETH contributors\r\n    uint public startBlock; // Crowdsale start block\r\n    uint public endBlock; // Crowdsale end block\r\n    uint public maxCap; // Maximum number of tokens to sell\r\n    uint public minCap; // Minimum number of tokens to sell    \r\n    bool public crowdsaleClosed; // Is crowdsale still in progress\r\n    uint public refundCount;  // number of refunds\r\n    uint public totalRefunded; // total amount of refunds in wei\r\n    uint public tokenPriceWei; // tokn price in wei\r\n    uint public minInvestETH; // Minimum amount to invest\r\n    uint public presaleTokens;\r\n    uint public totalWhiteListed; \r\n    uint public claimCount;\r\n    uint public totalClaimed;\r\n    uint public numOfBlocksInMinute; // number of blocks in one minute * 100. eg. \r\n                                     // if one block takes 13.34 seconds, the number will be 60/13.34* 100= 449\r\n\r\n    mapping(address => Backer) public backers; //backer list\r\n    address[] public backersIndex; // to be able to itarate through backers for verification.  \r\n    mapping(address => bool) public whiteList;\r\n\r\n    // @notice to verify if action is not performed out of the campaing range\r\n    modifier respectTimeFrame() {\r\n\r\n        require(block.number >= startBlock && block.number <= endBlock);           \r\n        _;\r\n    }\r\n\r\n    // Events\r\n    event LogReceivedETH(address backer, uint amount, uint tokenAmount);\r\n    event LogRefundETH(address backer, uint amount);\r\n    event LogWhiteListed(address user, uint whiteListedNum);\r\n    event LogWhiteListedMultiple(uint whiteListedNum);   \r\n\r\n    // Crowdsale  {constructor}\r\n    // @notice fired when contract is crated. Initilizes all constant and initial variables.\r\n    function Crowdsale() public {\r\n\r\n        multisig = 0xE804Ad72e60503eD47d267351Bdd3441aC1ccb03; \r\n        team = 0x86Ab6dB9932332e3350141c1D2E343C478157d04; \r\n        zen = 0x3334f1fBf78e4f0CFE0f5025410326Fe0262ede9; \r\n        presaleTokens = 4692000e8;      //TODO: ensure that this is correct amount\r\n        totalTokensSent = presaleTokens;  \r\n        minInvestETH = 1 ether/10; // 0.1 eth\r\n        startBlock = 0; // ICO start block\r\n        endBlock = 0; // ICO end block                    \r\n        maxCap = 42000000e8; // takes into consideration zen team tokens and team tokens.   \r\n        minCap = 8442000e8;        \r\n        tokenPriceWei = 80000000000000;  // Price is 0.00008 eth    \r\n        numOfBlocksInMinute = 400;  //  TODO: updte this value before deploying. E.g. 4.00 block/per minute wold be entered as 400           \r\n    }\r\n\r\n     // @notice to populate website with status of the sale \r\n    function returnWebsiteData() external view returns(uint, uint, uint, uint, uint, uint, uint, uint, bool, bool) {\r\n    \r\n        return (startBlock, endBlock, numberOfBackers(), ethReceived, maxCap, minCap, totalTokensSent, tokenPriceWei, paused, crowdsaleClosed);\r\n    }\r\n\r\n    // @notice in case refunds are needed, money can be returned to the contract\r\n    function fundContract() external payable onlyOwner() returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    function addToWhiteList(address _user) external onlyOwner() returns (bool) {\r\n\r\n        if (whiteList[_user] != true) {\r\n            whiteList[_user] = true;\r\n            totalWhiteListed++;\r\n            LogWhiteListed(_user, totalWhiteListed);            \r\n        }\r\n        return true;\r\n    }\r\n\r\n    function addToWhiteListMultiple(address[] _users) external onlyOwner()  returns (bool) {\r\n\r\n        for (uint i = 0; i < _users.length; ++i) {\r\n\r\n            if (whiteList[_users[i]] != true) {\r\n                whiteList[_users[i]] = true;\r\n                totalWhiteListed++;                          \r\n            }           \r\n        }\r\n        LogWhiteListedMultiple(totalWhiteListed); \r\n        return true;\r\n    }\r\n\r\n    // @notice Move funds from pre ICO sale if needed. \r\n    function transferPreICOFunds() external payable onlyOwner() returns (bool) {\r\n        ethReceived = ethReceived.add(msg.value);\r\n        return true;\r\n    }\r\n\r\n    // @notice Specify address of token contract\r\n    // @param _tokenAddress {address} address of the token contract\r\n    // @return res {bool}\r\n    function updateTokenAddress(Token _tokenAddress) external onlyOwner() returns(bool res) {\r\n        token = _tokenAddress;\r\n        return true;\r\n    }\r\n\r\n    // {fallback function}\r\n    // @notice It will call internal function which handels allocation of Ether and calculates amout of tokens.\r\n    function () external payable {           \r\n        contribute(msg.sender);\r\n    }\r\n\r\n    // @notice It will be called by owner to start the sale    \r\n    function start(uint _block) external onlyOwner() {   \r\n\r\n        require(_block < (numOfBlocksInMinute * 60 * 24 * 60)/100);  // allow max 60 days for campaign\r\n                                                         \r\n        startBlock = block.number;\r\n        endBlock = startBlock.add(_block); \r\n    }\r\n\r\n    // @notice Due to changing average of block time\r\n    // this function will allow on adjusting duration of campaign closer to the end \r\n    function adjustDuration(uint _block) external onlyOwner() {\r\n\r\n        require(_block < (numOfBlocksInMinute * 60 * 24 * 80)/100); // allow for max of 80 days for campaign\r\n        require(_block > block.number.sub(startBlock)); // ensure that endBlock is not set in the past\r\n        endBlock = startBlock.add(_block); \r\n    }\r\n    \r\n    // @notice This function will finalize the sale.\r\n    // It will only execute if predetermined sale time passed or all tokens are sold.\r\n    function finalize() external onlyOwner() {\r\n\r\n        require(!crowdsaleClosed);        \r\n        // purchasing precise number of tokens might be impractical, \r\n        //thus subtract 1000 tokens so finalizition is possible near the end \r\n        require(block.number > endBlock || totalTokensSent >= maxCap - 1000); \r\n        require(totalTokensSent >= minCap);  // ensure that campaign was successful         \r\n        crowdsaleClosed = true; \r\n\r\n        if (!token.transfer(team, 45000000e8 + presaleTokens))\r\n            revert();\r\n        if (!token.transfer(zen, 3000000e8)) \r\n            revert();\r\n        token.unlock();                       \r\n    }\r\n\r\n    // @notice\r\n    // This function will allow to transfer unsold tokens to a new\r\n    // contract/wallet address to start new ICO in the future\r\n    function transferRemainingTokens(address _newAddress) external onlyOwner() returns (bool) {\r\n\r\n        require(_newAddress != address(0));\r\n        // 180 days after ICO ends   \r\n        assert(block.number > endBlock + (numOfBlocksInMinute * 60 * 24 * 180)/100);         \r\n        if (!token.transfer(_newAddress, token.balanceOf(this))) \r\n            revert(); // transfer tokens to admin account or multisig wallet\r\n        return true;\r\n    }\r\n\r\n    // @notice Failsafe drain\r\n    function drain() external onlyOwner() {\r\n        multisig.transfer(this.balance);      \r\n    }\r\n\r\n    // @notice it will allow contributors to get refund in case campaign failed\r\n    function refund()  external whenNotPaused returns (bool) {\r\n\r\n\r\n        require(block.number > endBlock); // ensure that campaign is over\r\n        require(totalTokensSent < minCap); // ensure that campaign failed\r\n        require(this.balance > 0);  // contract will hold 0 ether at the end of the campaign.                                  \r\n                                    // contract needs to be funded through fundContract() for this action\r\n\r\n        Backer storage backer = backers[msg.sender];\r\n\r\n        require(backer.weiReceived > 0);           \r\n        require(!backer.refunded);      \r\n\r\n        backer.refunded = true;      \r\n        refundCount++;\r\n        totalRefunded = totalRefunded + backer.weiReceived;\r\n\r\n        if (!token.burn(msg.sender, backer.tokensSent))\r\n            revert();\r\n        msg.sender.transfer(backer.weiReceived);\r\n        LogRefundETH(msg.sender, backer.weiReceived);\r\n        return true;\r\n    }\r\n   \r\n\r\n    // @notice return number of contributors\r\n    // @return  {uint} number of contributors\r\n    function numberOfBackers() public view returns(uint) {\r\n        return backersIndex.length;\r\n    }\r\n\r\n    // @notice It will be called by fallback function whenever ether is sent to it\r\n    // @param  _backer {address} address of beneficiary\r\n    // @return res {bool} true if transaction was successful\r\n    function contribute(address _backer) internal whenNotPaused respectTimeFrame returns(bool res) {\r\n\r\n        require(msg.value >= minInvestETH);   // stop when required minimum is not sent\r\n        require(whiteList[_backer]);\r\n        uint tokensToSend = calculateNoOfTokensToSend();\r\n        require(totalTokensSent.add(tokensToSend) <= maxCap);  // Ensure that max cap hasn't been reached\r\n           \r\n        Backer storage backer = backers[_backer];\r\n\r\n        if (backer.weiReceived == 0)\r\n            backersIndex.push(_backer);\r\n        \r\n        backer.tokensSent = backer.tokensSent.add(tokensToSend);\r\n        backer.weiReceived = backer.weiReceived.add(msg.value);\r\n        ethReceived = ethReceived.add(msg.value); // Update the total Ether recived\r\n        totalTokensSent = totalTokensSent.add(tokensToSend);\r\n\r\n        if (!token.transfer(_backer, tokensToSend)) \r\n            revert(); // Transfer SOCX tokens\r\n\r\n        multisig.transfer(msg.value);  // send money to multisignature wallet\r\n        LogReceivedETH(_backer, msg.value, tokensToSend); // Register event\r\n        return true;\r\n    }\r\n\r\n    // @notice This function will return number of tokens based on time intervals in the campaign\r\n    function calculateNoOfTokensToSend() internal constant  returns (uint) {\r\n\r\n        uint tokenAmount = msg.value.mul(1e8) / tokenPriceWei;        \r\n\r\n        if (block.number <= startBlock + (numOfBlocksInMinute * 60) / 100)  // less then one hour\r\n            return  tokenAmount + (tokenAmount * 50) / 100;\r\n        else if (block.number <= startBlock + (numOfBlocksInMinute * 60 * 24) / 100)  // less than one day\r\n            return  tokenAmount + (tokenAmount * 25) / 100; \r\n        else if (block.number <= startBlock + (numOfBlocksInMinute * 60 * 24 * 2) / 100)  // less than two days\r\n            return  tokenAmount + (tokenAmount * 10) / 100; \r\n        else if (block.number <= startBlock + (numOfBlocksInMinute * 60 * 24 * 3) / 100)  // less than three days\r\n            return  tokenAmount + (tokenAmount * 5) / 100;\r\n        else                                                                // after 3 days\r\n            return  tokenAmount;     \r\n    }\r\n}\r\n\r\n\r\n\r\n// The SOCX token\r\ncontract Token is ERC20, Ownable {\r\n    \r\n    using SafeMath for uint;\r\n    \r\n    // Public variables of the token\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals; // How many decimals to show.\r\n    string public version = \"v0.1\";\r\n    uint public initialSupply;\r\n    uint public totalSupply;\r\n    bool public locked;           \r\n    mapping(address => uint) balances;\r\n    mapping(address => mapping(address => uint)) allowed;\r\n    address public migrationMaster;\r\n    address public migrationAgent;\r\n    address public crowdSaleAddress;\r\n    uint256 public totalMigrated;\r\n\r\n    // Lock transfer for contributors during the ICO \r\n    modifier onlyUnlocked() {\r\n        if (msg.sender != crowdSaleAddress && locked) \r\n            revert();\r\n        _;\r\n    }\r\n\r\n    modifier onlyAuthorized() {\r\n        if (msg.sender != owner && msg.sender != crowdSaleAddress) \r\n            revert();\r\n        _;\r\n    }\r\n\r\n    // The SOCX Token created with the time at which the crowdsale ends\r\n    function Token(address _crowdSaleAddress, address _migrationMaster) public {\r\n        // Lock the transfCrowdsaleer function during the crowdsale\r\n        locked = true; // Lock the transfer of tokens during the crowdsale\r\n        initialSupply = 90000000e8;\r\n        totalSupply = initialSupply;\r\n        name = \"SocialX\"; // Set the name for display purposes\r\n        symbol = \"SOCX\"; // Set the symbol for display purposes\r\n        decimals = 8; // Amount of decimals for display purposes\r\n        crowdSaleAddress = _crowdSaleAddress;              \r\n        balances[crowdSaleAddress] = totalSupply;\r\n        migrationMaster = _migrationMaster;\r\n    }\r\n\r\n    function unlock() public onlyAuthorized {\r\n        locked = false;\r\n    }\r\n\r\n    function lock() public onlyAuthorized {\r\n        locked = true;\r\n    }\r\n\r\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n    // Token migration support:\r\n\r\n    /// @notice Migrate tokens to the new token contract.\r\n    /// @dev Required state: Operational Migration\r\n    /// @param _value The amount of token to be migrated\r\n    function migrate(uint256 _value) external onlyUnlocked() {\r\n        // Abort if not in Operational Migration state.\r\n        \r\n        if (migrationAgent == 0) \r\n            revert();\r\n        \r\n        // Validate input value.\r\n        if (_value == 0) \r\n            revert();\r\n        if (_value > balances[msg.sender]) \r\n            revert();\r\n\r\n        balances[msg.sender] -= _value;\r\n        totalSupply -= _value;\r\n        totalMigrated += _value;\r\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\r\n        Migrate(msg.sender, migrationAgent, _value);\r\n    }\r\n\r\n    /// @notice Set address of migration target contract and enable migration\r\n    /// process.\r\n    /// @dev Required state: Operational Normal\r\n    /// @dev State transition: -> Operational Migration\r\n    /// @param _agent The address of the MigrationAgent contract\r\n    function setMigrationAgent(address _agent) external onlyUnlocked() {\r\n        // Abort if not in Operational Normal state.\r\n        \r\n        require(migrationAgent == 0);\r\n        require(msg.sender == migrationMaster);\r\n        migrationAgent = _agent;\r\n    }\r\n\r\n    function resetCrowdSaleAddress(address _newCrowdSaleAddress) external onlyAuthorized() {\r\n        crowdSaleAddress = _newCrowdSaleAddress;\r\n    }\r\n    \r\n    function setMigrationMaster(address _master) external {       \r\n        require(msg.sender == migrationMaster);\r\n        require(_master != 0);\r\n        migrationMaster = _master;\r\n    }\r\n\r\n   // @notice burn tokens in case campaign failed\r\n    // @param _member {address} of member\r\n    // @param _value {uint} amount of tokens to burn\r\n    // @return  {bool} true if successful\r\n    function burn( address _member, uint256 _value) public onlyAuthorized returns(bool) {\r\n        balances[_member] = balances[_member].sub(_value);\r\n        totalSupply = totalSupply.sub(_value);\r\n        Transfer(_member, 0x0, _value);\r\n        return true;\r\n    }\r\n\r\n    // @notice transfer tokens to given address \r\n    // @param _to {address} address or recipient\r\n    // @param _value {uint} amount to transfer\r\n    // @return  {bool} true if successful  \r\n    function transfer(address _to, uint _value) public onlyUnlocked returns(bool) {\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    // @notice transfer tokens from given address to another address\r\n    // @param _from {address} from whom tokens are transferred \r\n    // @param _to {address} to whom tokens are transferred\r\n    // @parm _value {uint} amount of tokens to transfer\r\n    // @return  {bool} true if successful   \r\n    function transferFrom(address _from, address _to, uint256 _value) public onlyUnlocked returns(bool success) {\r\n        require(balances[_from] >= _value); // Check if the sender has enough                            \r\n        require(_value <= allowed[_from][msg.sender]); // Check if allowed is greater or equal        \r\n        balances[_from] = balances[_from].sub(_value); // Subtract from the sender\r\n        balances[_to] = balances[_to].add(_value); // Add the same to the recipient\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    // @notice to query balance of account\r\n    // @return _owner {address} address of user to query balance \r\n    function balanceOf(address _owner) public view returns(uint balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    /**\r\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n    *\r\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _value The amount of tokens to be spent.\r\n    */\r\n    function approve(address _spender, uint _value) public returns(bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    // @notice to query of allowance of one user to the other\r\n    // @param _owner {address} of the owner of the account\r\n    // @param _spender {address} of the spender of the account\r\n    // @return remaining {uint} amount of remaining allowance\r\n    function allowance(address _owner, address _spender) public view returns(uint remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n    * approve should be called when allowed[_spender] == 0. To increment\r\n    * allowed value is better to use this function to avoid 2 calls (and wait until\r\n    * the first transaction is mined)\r\n    * From MonolithDAO Token.sol\r\n    */\r\n    function increaseApproval (address _spender, uint _addedValue) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {\r\n        uint oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"crowdSaleAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_master\",\"type\":\"address\"}],\"name\":\"setMigrationMaster\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"migrate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCrowdSaleAddress\",\"type\":\"address\"}],\"name\":\"resetCrowdSaleAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"migrationMaster\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_agent\",\"type\":\"address\"}],\"name\":\"setMigrationAgent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"migrationAgent\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalMigrated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_member\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"locked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_crowdSaleAddress\",\"type\":\"address\"},{\"name\":\"_migrationMaster\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Migrate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"Token","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000bd59ed7c40f4df71d4638ea192411edc2c925a1b000000000000000000000000ca764d267f93b74bfb50dad271fab9f797c77656","Library":"","SwarmSource":"bzzr://239d0bc09be53a3fe74b7bcd6936352aa95102774eb91efab802cbb383613979"}]}