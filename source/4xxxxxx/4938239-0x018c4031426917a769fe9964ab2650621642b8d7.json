{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.17;\r\n\r\n//Slightly modified SafeMath library - includes a min function\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function min(uint a, uint b) internal pure returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n}\r\n\r\n\r\n//The DRCT_Token is an ERC20 compliant token representing the payout of the swap contract specified in the Factory contract\r\n//Each Factory contract is specified one DRCT Token and the token address can contain many different swap contracts that are standardized at the Factory level\r\ncontract DRCT_Token {\r\n\r\n  using SafeMath for uint256;\r\n\r\n  /*Structs */\r\n  //Keeps track of balance amounts in the balances array\r\n  struct Balance {\r\n    address owner;\r\n    uint amount;\r\n  }\r\n\r\n  //This is the factory contract that the token is standardized at\r\n  address public master_contract;\r\n  //Total supply of outstanding tokens in the contract\r\n  uint public total_supply;\r\n\r\n  //Mapping from: swap address -> user balance struct (index for a particular user's balance can be found in swap_balances_index)\r\n  mapping(address => Balance[]) swap_balances;\r\n  //Mapping from: swap address -> user -> swap_balances index\r\n  mapping(address => mapping(address => uint)) swap_balances_index;\r\n  //Mapping from: user -> dynamic array of swap addresses (index for a particular swap can be found in user_swaps_index)\r\n  mapping(address => address[]) user_swaps;\r\n  //Mapping from: user -> swap address -> user_swaps index\r\n  mapping(address => mapping(address => uint)) user_swaps_index;\r\n\r\n  //Mapping from: user -> total balance accross all entered swaps\r\n  mapping(address => uint) user_total_balances;\r\n  //Mapping from: owner -> spender -> amount allowed\r\n  mapping(address => mapping(address => uint)) allowed;\r\n\r\n  //events for transfer and approvals\r\n  event Transfer(address indexed _from, address indexed _to, uint _value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n\r\n  modifier onlyMaster() {\r\n    require(msg.sender == master_contract);\r\n    _;\r\n  }\r\n\r\n  /*Functions*/\r\n  //Constructor\r\n  function DRCT_Token(address _factory) public {\r\n    //Sets values for token name and token supply, as well as the master_contract, the swap.\r\n    master_contract = _factory;\r\n  }\r\n  //Token Creator - This function is called by the factory contract and creates new tokens for the user\r\n  function createToken(uint _supply, address _owner, address _swap) public onlyMaster() {\r\n    //Update total supply of DRCT Tokens\r\n    total_supply = total_supply.add(_supply);\r\n    //Update the total balance of the owner\r\n    user_total_balances[_owner] = user_total_balances[_owner].add(_supply);\r\n    //If the user has not entered any swaps already, push a zeroed address to their user_swaps mapping to prevent default value conflicts in user_swaps_index\r\n    if (user_swaps[_owner].length == 0)\r\n      user_swaps[_owner].push(address(0x0));\r\n    //Add a new swap index for the owner\r\n    user_swaps_index[_owner][_swap] = user_swaps[_owner].length;\r\n    //Push a new swap address to the owner's swaps\r\n    user_swaps[_owner].push(_swap);\r\n    //Push a zeroed Balance struct to the swap balances mapping to prevent default value conflicts in swap_balances_index\r\n    swap_balances[_swap].push(Balance({\r\n      owner: 0,\r\n      amount: 0\r\n    }));\r\n    //Add a new owner balance index for the swap\r\n    swap_balances_index[_swap][_owner] = 1;\r\n    //Push the owner's balance to the swap\r\n    swap_balances[_swap].push(Balance({\r\n      owner: _owner,\r\n      amount: _supply\r\n    }));\r\n  }\r\n\r\n  //Called by the factory contract, and pays out to a _party\r\n  function pay(address _party, address _swap) public onlyMaster() {\r\n    uint party_balance_index = swap_balances_index[_swap][_party];\r\n    uint party_swap_balance = swap_balances[_swap][party_balance_index].amount;\r\n    //reduces the users totals balance by the amount in that swap\r\n    user_total_balances[_party] = user_total_balances[_party].sub(party_swap_balance);\r\n    //reduces the total supply by the amount of that users in that swap\r\n    total_supply = total_supply.sub(party_swap_balance);\r\n    //sets the partys balance to zero for that specific swaps party balances\r\n    swap_balances[_swap][party_balance_index].amount = 0;\r\n  }\r\n\r\n  //Returns the users total balance (sum of tokens in all swaps the user has tokens in)\r\n  function balanceOf(address _owner) public constant returns (uint balance) { return user_total_balances[_owner]; }\r\n\r\n  //Getter for the total_supply of tokens in the contract\r\n  function totalSupply() public constant returns (uint _total_supply) { return total_supply; }\r\n\r\n  //Checks whether an address is in a specified swap. If they are, the user_swaps_index for that user and swap will be non-zero\r\n  function addressInSwap(address _swap, address _owner) public view returns (bool) {\r\n    return user_swaps_index[_owner][_swap] != 0;\r\n  }\r\n\r\n  //Removes the address from the swap balances for a swap, and moves the last address in the swap into their place\r\n  function removeFromSwapBalances(address _remove, address _swap) internal {\r\n    uint last_address_index = swap_balances[_swap].length.sub(1);\r\n    address last_address = swap_balances[_swap][last_address_index].owner;\r\n    //If the address we want to remove is the final address in the swap\r\n    if (last_address != _remove) {\r\n      uint remove_index = swap_balances_index[_swap][_remove];\r\n      //Update the swap's balance index of the last address to that of the removed address index\r\n      swap_balances_index[_swap][last_address] = remove_index;\r\n      //Set the swap's Balance struct at the removed index to the Balance struct of the last address\r\n      swap_balances[_swap][remove_index] = swap_balances[_swap][last_address_index];\r\n    }\r\n    //Remove the swap_balances index for this address\r\n    delete swap_balances_index[_swap][_remove];\r\n    //Finally, decrement the swap balances length\r\n    swap_balances[_swap].length = swap_balances[_swap].length.sub(1);\r\n  }\r\n\r\n  // This is the main function to update the mappings when a transfer happens\r\n  function transferHelper(address _from, address _to, uint _amount) internal {\r\n    //Get memory copies of the swap arrays for the sender and reciever\r\n    address[] memory from_swaps = user_swaps[_from];\r\n\r\n    //Iterate over sender's swaps in reverse order until enough tokens have been transferred\r\n    for (uint i = from_swaps.length.sub(1); i > 0; i--) {\r\n      //Get the index of the sender's balance for the current swap\r\n      uint from_swap_user_index = swap_balances_index[from_swaps[i]][_from];\r\n      Balance memory from_user_bal = swap_balances[from_swaps[i]][from_swap_user_index];\r\n      //If the current swap will be entirely depleted - we remove all references to it for the sender\r\n      if (_amount >= from_user_bal.amount) {\r\n        _amount -= from_user_bal.amount;\r\n        //If this swap is to be removed, we know it is the (current) last swap in the user's user_swaps list, so we can simply decrement the length to remove it\r\n        user_swaps[_from].length = user_swaps[_from].length.sub(1);\r\n        //Remove the user swap index for this swap\r\n        delete user_swaps_index[_from][from_swaps[i]];\r\n\r\n        //If the _to address already holds tokens from this swap\r\n        if (addressInSwap(from_swaps[i], _to)) {\r\n          //Get the index of the _to balance in this swap\r\n          uint to_balance_index = swap_balances_index[from_swaps[i]][_to];\r\n          assert(to_balance_index != 0);\r\n          //Add the _from tokens to _to\r\n          swap_balances[from_swaps[i]][to_balance_index].amount = swap_balances[from_swaps[i]][to_balance_index].amount.add(from_user_bal.amount);\r\n          //Remove the _from address from this swap's balance array\r\n          removeFromSwapBalances(_from, from_swaps[i]);\r\n        } else {\r\n          //Prepare to add a new swap by assigning the swap an index for _to\r\n          if (user_swaps[_to].length == 0)\r\n            user_swaps_index[_to][from_swaps[i]] = 1;\r\n          else\r\n            user_swaps_index[_to][from_swaps[i]] = user_swaps[_to].length;\r\n          //Add the new swap to _to\r\n          user_swaps[_to].push(from_swaps[i]);\r\n          //Give the reciever the sender's balance for this swap\r\n          swap_balances[from_swaps[i]][from_swap_user_index].owner = _to;\r\n          //Give the reciever the sender's swap balance index for this swap\r\n          swap_balances_index[from_swaps[i]][_to] = swap_balances_index[from_swaps[i]][_from];\r\n          //Remove the swap balance index from the sending party\r\n          delete swap_balances_index[from_swaps[i]][_from];\r\n        }\r\n        //If there is no more remaining to be removed, we break out of the loop\r\n        if (_amount == 0)\r\n          break;\r\n      } else {\r\n        //The amount in this swap is more than the amount we still need to transfer\r\n        uint to_swap_balance_index = swap_balances_index[from_swaps[i]][_to];\r\n        //If the _to address already holds tokens from this swap\r\n        if (addressInSwap(from_swaps[i], _to)) {\r\n          //Because both addresses are in this swap, and neither will be removed, we simply update both swap balances\r\n          swap_balances[from_swaps[i]][to_swap_balance_index].amount = swap_balances[from_swaps[i]][to_swap_balance_index].amount.add(_amount);\r\n        } else {\r\n          //Prepare to add a new swap by assigning the swap an index for _to\r\n          if (user_swaps[_to].length == 0)\r\n            user_swaps_index[_to][from_swaps[i]] = 1;\r\n          else\r\n            user_swaps_index[_to][from_swaps[i]] = user_swaps[_to].length;\r\n          //And push the new swap\r\n          user_swaps[_to].push(from_swaps[i]);\r\n          //_to is not in this swap, so we give this swap a new balance index for _to\r\n          swap_balances_index[from_swaps[i]][_to] = swap_balances[from_swaps[i]].length;\r\n          //And push a new balance for _to\r\n          swap_balances[from_swaps[i]].push(Balance({\r\n            owner: _to,\r\n            amount: _amount\r\n          }));\r\n        }\r\n        //Finally, update the _from user's swap balance\r\n        swap_balances[from_swaps[i]][from_swap_user_index].amount = swap_balances[from_swaps[i]][from_swap_user_index].amount.sub(_amount);\r\n        //Because we have transferred the last of the amount to the reciever, we break;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  /*\r\n    ERC20 compliant transfer function\r\n    @param - _to: Address to send funds to\r\n    @param - _amount: Amount of token to send\r\n    returns true for successful\r\n  */\r\n  function transfer(address _to, uint _amount) public returns (bool success) {\r\n    uint balance_owner = user_total_balances[msg.sender];\r\n\r\n    if (\r\n      _to == msg.sender ||\r\n      _to == address(0) ||\r\n      _amount == 0 ||\r\n      balance_owner < _amount\r\n    ) return false;\r\n\r\n    transferHelper(msg.sender, _to, _amount);\r\n    user_total_balances[msg.sender] = user_total_balances[msg.sender].sub(_amount);\r\n    user_total_balances[_to] = user_total_balances[_to].add(_amount);\r\n    Transfer(msg.sender, _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  /*\r\n    ERC20 compliant transferFrom function\r\n    @param - _from: Address to send funds from (must be allowed, see approve function)\r\n    @param - _to: Address to send funds to\r\n    @param - _amount: Amount of token to send\r\n    returns true for successful\r\n  */\r\n  function transferFrom(address _from, address _to, uint _amount) public returns (bool success) {\r\n    uint balance_owner = user_total_balances[_from];\r\n    uint sender_allowed = allowed[_from][msg.sender];\r\n\r\n    if (\r\n      _to == _from ||\r\n      _to == address(0) ||\r\n      _amount == 0 ||\r\n      balance_owner < _amount ||\r\n      sender_allowed < _amount\r\n    ) return false;\r\n\r\n    transferHelper(_from, _to, _amount);\r\n    user_total_balances[_from] = user_total_balances[_from].sub(_amount);\r\n    user_total_balances[_to] = user_total_balances[_to].add(_amount);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\r\n    Transfer(_from, _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  /*\r\n    ERC20 compliant approve function\r\n    @param - _spender: Party that msg.sender approves for transferring funds\r\n    @param - _amount: Amount of token to approve for sending\r\n    returns true for successful\r\n  */\r\n  function approve(address _spender, uint _amount) public returns (bool success) {\r\n    allowed[msg.sender][_spender] = _amount;\r\n    Approval(msg.sender, _spender, _amount);\r\n    return true;\r\n  }\r\n\r\n  //Returns the length of the balances array for a swap\r\n  function addressCount(address _swap) public constant returns (uint count) { return swap_balances[_swap].length; }\r\n\r\n  //Returns the address associated with a particular index in a particular swap\r\n  function getHolderByIndex(uint _ind, address _swap) public constant returns (address holder) { return swap_balances[_swap][_ind].owner; }\r\n\r\n  //Returns the balance associated with a particular index in a particular swap\r\n  function getBalanceByIndex(uint _ind, address _swap) public constant returns (uint bal) { return swap_balances[_swap][_ind].amount; }\r\n\r\n  //Returns the index associated with the _owner address in a particular swap\r\n  function getIndexByAddress(address _owner, address _swap) public constant returns (uint index) { return swap_balances_index[_swap][_owner]; }\r\n\r\n  //Returns the allowed amount _spender can spend of _owner's balance\r\n  function allowance(address _owner, address _spender) public constant returns (uint amount) { return allowed[_owner][_spender]; }\r\n}\r\n\r\n\r\n//Swap Deployer Contract-- purpose is to save gas for deployment of Factory contract\r\ncontract Tokendeployer {\r\n  address owner;\r\n  address public factory;\r\n\r\n  function Tokendeployer(address _factory) public {\r\n    factory = _factory;\r\n    owner = msg.sender;\r\n  }\r\n\r\n  function newToken() public returns (address created) {\r\n    require(msg.sender == factory);\r\n    address new_token = new DRCT_Token(factory);\r\n    return new_token;\r\n  }\r\n\r\n   function setVars(address _factory, address _owner) public {\r\n    require (msg.sender == owner);\r\n    factory = _factory;\r\n    owner = _owner;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"newToken\",\"outputs\":[{\"name\":\"created\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_factory\",\"type\":\"address\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setVars\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_factory\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"Tokendeployer","CompilerVersion":"v0.4.17+commit.bdeb9e52","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000af7d69fc8a14eb37ae07ddef4b209d157cbe4738","Library":"","SwarmSource":"bzzr://1caa3b8ee9426aad4376762de60ca52e4fecec6b40ff3a1bff0b0df57a4c86c0"}]}