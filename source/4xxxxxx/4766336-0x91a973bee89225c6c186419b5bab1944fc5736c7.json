{"status":"1","message":"OK","result":[{"SourceCode":"//File: node_modules/giveth-common-contracts/contracts/Owned.sol\r\npragma solidity ^0.4.15;\r\n\r\n\r\n/// @title Owned\r\n/// @author Adrià Massanet <adria@codecontext.io>\r\n/// @notice The Owned contract has an owner address, and provides basic \r\n///  authorization control functions, this simplifies & the implementation of\r\n///  user permissions; this contract has three work flows for a change in\r\n///  ownership, the first requires the new owner to validate that they have the\r\n///  ability to accept ownership, the second allows the ownership to be\r\n///  directly transfered without requiring acceptance, and the third allows for\r\n///  the ownership to be removed to allow for decentralization \r\ncontract Owned {\r\n\r\n    address public owner;\r\n    address public newOwnerCandidate;\r\n\r\n    event OwnershipRequested(address indexed by, address indexed to);\r\n    event OwnershipTransferred(address indexed from, address indexed to);\r\n    event OwnershipRemoved();\r\n\r\n    /// @dev The constructor sets the `msg.sender` as the`owner` of the contract\r\n    function Owned() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /// @dev `owner` is the only address that can call a function with this\r\n    /// modifier\r\n    modifier onlyOwner() {\r\n        require (msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    /// @dev In this 1st option for ownership transfer `proposeOwnership()` must\r\n    ///  be called first by the current `owner` then `acceptOwnership()` must be\r\n    ///  called by the `newOwnerCandidate`\r\n    /// @notice `onlyOwner` Proposes to transfer control of the contract to a\r\n    ///  new owner\r\n    /// @param _newOwnerCandidate The address being proposed as the new owner\r\n    function proposeOwnership(address _newOwnerCandidate) public onlyOwner {\r\n        newOwnerCandidate = _newOwnerCandidate;\r\n        OwnershipRequested(msg.sender, newOwnerCandidate);\r\n    }\r\n\r\n    /// @notice Can only be called by the `newOwnerCandidate`, accepts the\r\n    ///  transfer of ownership\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwnerCandidate);\r\n\r\n        address oldOwner = owner;\r\n        owner = newOwnerCandidate;\r\n        newOwnerCandidate = 0x0;\r\n\r\n        OwnershipTransferred(oldOwner, owner);\r\n    }\r\n\r\n    /// @dev In this 2nd option for ownership transfer `changeOwnership()` can\r\n    ///  be called and it will immediately assign ownership to the `newOwner`\r\n    /// @notice `owner` can step down and assign some other address to this role\r\n    /// @param _newOwner The address of the new owner\r\n    function changeOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != 0x0);\r\n\r\n        address oldOwner = owner;\r\n        owner = _newOwner;\r\n        newOwnerCandidate = 0x0;\r\n\r\n        OwnershipTransferred(oldOwner, owner);\r\n    }\r\n\r\n    /// @dev In this 3rd option for ownership transfer `removeOwnership()` can\r\n    ///  be called and it will immediately assign ownership to the 0x0 address;\r\n    ///  it requires a 0xdece be input as a parameter to prevent accidental use\r\n    /// @notice Decentralizes the contract, this operation cannot be undone \r\n    /// @param _dac `0xdac` has to be entered for this function to work\r\n    function removeOwnership(address _dac) public onlyOwner {\r\n        require(_dac == 0xdac);\r\n        owner = 0x0;\r\n        newOwnerCandidate = 0x0;\r\n        OwnershipRemoved();     \r\n    }\r\n} \r\n\r\n//File: node_modules/giveth-common-contracts/contracts/ERC20.sol\r\npragma solidity ^0.4.15;\r\n\r\n\r\n/**\r\n * @title ERC20\r\n * @dev A standard interface for tokens.\r\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n */\r\ncontract ERC20 {\r\n  \r\n    /// @dev Returns the total token supply\r\n    function totalSupply() public constant returns (uint256 supply);\r\n\r\n    /// @dev Returns the account balance of the account with address _owner\r\n    function balanceOf(address _owner) public constant returns (uint256 balance);\r\n\r\n    /// @dev Transfers _value number of tokens to address _to\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @dev Transfers _value number of tokens from address _from to address _to\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @dev Allows _spender to withdraw from the msg.sender's account up to the _value amount\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n    /// @dev Returns the amount which _spender is still allowed to withdraw from _owner\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n}\r\n\r\n//File: node_modules/giveth-common-contracts/contracts/Escapable.sol\r\npragma solidity ^0.4.15;\r\n/*\r\n    Copyright 2016, Jordi Baylina\r\n    Contributor: Adrià Massanet <adria@codecontext.io>\r\n\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n/// @dev `Escapable` is a base level contract built off of the `Owned`\r\n///  contract; it creates an escape hatch function that can be called in an\r\n///  emergency that will allow designated addresses to send any ether or tokens\r\n///  held in the contract to an `escapeHatchDestination` as long as they were\r\n///  not blacklisted\r\ncontract Escapable is Owned {\r\n    address public escapeHatchCaller;\r\n    address public escapeHatchDestination;\r\n    mapping (address=>bool) private escapeBlacklist; // Token contract addresses\r\n\r\n    /// @notice The Constructor assigns the `escapeHatchDestination` and the\r\n    ///  `escapeHatchCaller`\r\n    /// @param _escapeHatchCaller The address of a trusted account or contract\r\n    ///  to call `escapeHatch()` to send the ether in this contract to the\r\n    ///  `escapeHatchDestination` it would be ideal that `escapeHatchCaller`\r\n    ///  cannot move funds out of `escapeHatchDestination`\r\n    /// @param _escapeHatchDestination The address of a safe location (usu a\r\n    ///  Multisig) to send the ether held in this contract; if a neutral address\r\n    ///  is required, the WHG Multisig is an option:\r\n    ///  0x8Ff920020c8AD673661c8117f2855C384758C572 \r\n    function Escapable(address _escapeHatchCaller, address _escapeHatchDestination) public {\r\n        escapeHatchCaller = _escapeHatchCaller;\r\n        escapeHatchDestination = _escapeHatchDestination;\r\n    }\r\n\r\n    /// @dev The addresses preassigned as `escapeHatchCaller` or `owner`\r\n    ///  are the only addresses that can call a function with this modifier\r\n    modifier onlyEscapeHatchCallerOrOwner {\r\n        require ((msg.sender == escapeHatchCaller)||(msg.sender == owner));\r\n        _;\r\n    }\r\n\r\n    /// @notice Creates the blacklist of tokens that are not able to be taken\r\n    ///  out of the contract; can only be done at the deployment, and the logic\r\n    ///  to add to the blacklist will be in the constructor of a child contract\r\n    /// @param _token the token contract address that is to be blacklisted \r\n    function blacklistEscapeToken(address _token) internal {\r\n        escapeBlacklist[_token] = true;\r\n        EscapeHatchBlackistedToken(_token);\r\n    }\r\n\r\n    /// @notice Checks to see if `_token` is in the blacklist of tokens\r\n    /// @param _token the token address being queried\r\n    /// @return False if `_token` is in the blacklist and can't be taken out of\r\n    ///  the contract via the `escapeHatch()`\r\n    function isTokenEscapable(address _token) constant public returns (bool) {\r\n        return !escapeBlacklist[_token];\r\n    }\r\n\r\n    /// @notice The `escapeHatch()` should only be called as a last resort if a\r\n    /// security issue is uncovered or something unexpected happened\r\n    /// @param _token to transfer, use 0x0 for ether\r\n    function escapeHatch(address _token) public onlyEscapeHatchCallerOrOwner {   \r\n        require(escapeBlacklist[_token]==false);\r\n\r\n        uint256 balance;\r\n\r\n        /// @dev Logic for ether\r\n        if (_token == 0x0) {\r\n            balance = this.balance;\r\n            escapeHatchDestination.transfer(balance);\r\n            EscapeHatchCalled(_token, balance);\r\n            return;\r\n        }\r\n        /// @dev Logic for tokens\r\n        ERC20 token = ERC20(_token);\r\n        balance = token.balanceOf(this);\r\n        require(token.transfer(escapeHatchDestination, balance));\r\n        EscapeHatchCalled(_token, balance);\r\n    }\r\n\r\n    /// @notice Changes the address assigned to call `escapeHatch()`\r\n    /// @param _newEscapeHatchCaller The address of a trusted account or\r\n    ///  contract to call `escapeHatch()` to send the value in this contract to\r\n    ///  the `escapeHatchDestination`; it would be ideal that `escapeHatchCaller`\r\n    ///  cannot move funds out of `escapeHatchDestination`\r\n    function changeHatchEscapeCaller(address _newEscapeHatchCaller) public onlyEscapeHatchCallerOrOwner {\r\n        escapeHatchCaller = _newEscapeHatchCaller;\r\n    }\r\n\r\n    event EscapeHatchBlackistedToken(address token);\r\n    event EscapeHatchCalled(address token, uint amount);\r\n}\r\n\r\n//File: contracts/LPVault.sol\r\npragma solidity ^0.4.11;\r\n\r\n/*\r\n    Copyright 2017, Jordi Baylina\r\n    Contributors: RJ Ewing, Griff Green, Arthur Lunn\r\n\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n/// @title LPVault\r\n/// @author Jordi Baylina\r\n\r\n/// @dev This contract holds ether securely for liquid pledging systems; for\r\n///  this iteration the funds will come often be escaped to the Giveth Multisig\r\n///  (safety precaution), but once fully tested and optimized this contract will\r\n///  be a safe place to store funds equipped with optional variable time delays\r\n///  to allow for an optional escapeHatch to be implemented in case of issues;\r\n///  future versions of this contract will be enabled for tokens\r\n\r\n\r\n/// @dev `LiquidPledging` is a basic interface to allow the `LPVault` contract\r\n///  to confirm and cancel payments in the `LiquidPledging` contract.\r\ncontract LiquidPledging {\r\n    function confirmPayment(uint64 idPledge, uint amount) public;\r\n    function cancelPayment(uint64 idPledge, uint amount) public;\r\n}\r\n\r\n\r\n/// @dev `LPVault` is a higher level contract built off of the `Escapable`\r\n///  contract that holds funds for the liquid pledging system.\r\ncontract LPVault is Escapable {\r\n\r\n    LiquidPledging public liquidPledging; // LiquidPledging contract's address\r\n    bool public autoPay; // If false, payments will take 2 txs to be completed\r\n\r\n    enum PaymentStatus {\r\n        Pending, // When the payment is awaiting confirmation\r\n        Paid,    // When the payment has been sent\r\n        Canceled // When the payment will never be sent\r\n    }\r\n    /// @dev `Payment` is a public structure that describes the details of\r\n    ///  each payment the `ref` param makes it easy to track the movements of\r\n    ///  funds transparently by its connection to other `Payment` structs\r\n    struct Payment {\r\n        PaymentStatus state; // Pending, Paid or Canceled\r\n        bytes32 ref; // an input that references details from other contracts\r\n        address dest; // recipient of the ETH\r\n        uint amount; // amount of ETH (in wei) to be sent\r\n    }\r\n\r\n    // @dev An array that contains all the payments for this LPVault\r\n    Payment[] public payments;\r\n\r\n    function LPVault(address _escapeHatchCaller, address _escapeHatchDestination)\r\n        Escapable(_escapeHatchCaller, _escapeHatchDestination) public\r\n    {\r\n    }\r\n\r\n    /// @dev The attached `LiquidPledging` contract is the only address that can\r\n    ///  call a function with this modifier\r\n    modifier onlyLiquidPledging() {\r\n        require(msg.sender == address(liquidPledging));\r\n        _;\r\n    }\r\n\r\n    /// @dev The fall back function allows ETH to be deposited into the LPVault\r\n    ///  through a simple send\r\n    function () public payable {}\r\n\r\n    /// @notice `onlyOwner` used to attach a specific liquidPledging instance\r\n    ///  to this LPvault; keep in mind that once a liquidPledging contract is \r\n    ///  attached it cannot be undone, this vault will be forever connected\r\n    /// @param _newLiquidPledging A full liquid pledging contract\r\n    function setLiquidPledging(address _newLiquidPledging) public onlyOwner {\r\n        require(address(liquidPledging) == 0x0);\r\n        liquidPledging = LiquidPledging(_newLiquidPledging);\r\n    }\r\n\r\n    /// @notice Used to decentralize, toggles whether the LPVault will\r\n    ///  automatically confirm a payment after the payment has been authorized\r\n    /// @param _automatic If true, payments will confirm instantly, if false\r\n    ///  the training wheels are put on and the owner must manually approve \r\n    ///  every payment\r\n    function setAutopay(bool _automatic) public onlyOwner {\r\n        autoPay = _automatic;\r\n        AutoPaySet();\r\n    }\r\n\r\n    /// @notice `onlyLiquidPledging` authorizes payments from this contract, if \r\n    ///  `autoPay == true` the transfer happens automatically `else` the `owner`\r\n    ///  must call `confirmPayment()` for a transfer to occur (training wheels);\r\n    ///  either way, a new payment is added to `payments[]` \r\n    /// @param _ref References the payment will normally be the pledgeID\r\n    /// @param _dest The address that payments will be sent to\r\n    /// @param _amount The amount that the payment is being authorized for\r\n    /// @return idPayment The id of the payment (needed by the owner to confirm)\r\n    function authorizePayment(\r\n        bytes32 _ref,\r\n        address _dest,\r\n        uint _amount\r\n    ) public onlyLiquidPledging returns (uint)\r\n    {\r\n        uint idPayment = payments.length;\r\n        payments.length ++;\r\n        payments[idPayment].state = PaymentStatus.Pending;\r\n        payments[idPayment].ref = _ref;\r\n        payments[idPayment].dest = _dest;\r\n        payments[idPayment].amount = _amount;\r\n\r\n        AuthorizePayment(idPayment, _ref, _dest, _amount);\r\n\r\n        if (autoPay) {\r\n            doConfirmPayment(idPayment);\r\n        }\r\n\r\n        return idPayment;\r\n    }\r\n\r\n    /// @notice Allows the owner to confirm payments;  since \r\n    ///  `authorizePayment` is the only way to populate the `payments[]` array\r\n    ///  this is generally used when `autopay` is `false` after a payment has\r\n    ///  has been authorized\r\n    /// @param _idPayment Array lookup for the payment.\r\n    function confirmPayment(uint _idPayment) public onlyOwner {\r\n        doConfirmPayment(_idPayment);\r\n    }\r\n\r\n    /// @notice Transfers ETH according to the data held within the specified\r\n    ///  payment id (internal function)\r\n    /// @param _idPayment id number for the payment about to be fulfilled \r\n    function doConfirmPayment(uint _idPayment) internal {\r\n        require(_idPayment < payments.length);\r\n        Payment storage p = payments[_idPayment];\r\n        require(p.state == PaymentStatus.Pending);\r\n\r\n        p.state = PaymentStatus.Paid;\r\n        liquidPledging.confirmPayment(uint64(p.ref), p.amount);\r\n\r\n        p.dest.transfer(p.amount);  // Transfers ETH denominated in wei\r\n\r\n        ConfirmPayment(_idPayment, p.ref);\r\n    }\r\n\r\n    /// @notice When `autopay` is `false` and after a payment has been authorized\r\n    ///  to allow the owner to cancel a payment instead of confirming it.\r\n    /// @param _idPayment Array lookup for the payment.\r\n    function cancelPayment(uint _idPayment) public onlyOwner {\r\n        doCancelPayment(_idPayment);\r\n    }\r\n\r\n    /// @notice Cancels a pending payment (internal function)\r\n    /// @param _idPayment id number for the payment    \r\n    function doCancelPayment(uint _idPayment) internal {\r\n        require(_idPayment < payments.length);\r\n        Payment storage p = payments[_idPayment];\r\n        require(p.state == PaymentStatus.Pending);\r\n\r\n        p.state = PaymentStatus.Canceled;\r\n\r\n        liquidPledging.cancelPayment(uint64(p.ref), p.amount);\r\n\r\n        CancelPayment(_idPayment, p.ref);\r\n\r\n    }\r\n\r\n    /// @notice `onlyOwner` An efficient way to confirm multiple payments\r\n    /// @param _idPayments An array of multiple payment ids\r\n    function multiConfirm(uint[] _idPayments) public onlyOwner {\r\n        for (uint i = 0; i < _idPayments.length; i++) {\r\n            doConfirmPayment(_idPayments[i]);\r\n        }\r\n    }\r\n\r\n    /// @notice `onlyOwner` An efficient way to cancel multiple payments\r\n    /// @param _idPayments An array of multiple payment ids\r\n    function multiCancel(uint[] _idPayments) public onlyOwner {\r\n        for (uint i = 0; i < _idPayments.length; i++) {\r\n            doCancelPayment(_idPayments[i]);\r\n        }\r\n    }\r\n\r\n    /// @return The total number of payments that have ever been authorized\r\n    function nPayments() constant public returns (uint) {\r\n        return payments.length;\r\n    }\r\n\r\n    /// Transfer eth or tokens to the escapeHatchDestination.\r\n    /// Used as a safety mechanism to prevent the vault from holding too much value\r\n    /// before being thoroughly battle-tested.\r\n    /// @param _token to transfer, use 0x0 for ether\r\n    /// @param _amount to transfer\r\n    function escapeFunds(address _token, uint _amount) public onlyOwner {\r\n        /// @dev Logic for ether\r\n        if (_token == 0x0) {\r\n            require(this.balance >= _amount);\r\n            escapeHatchDestination.transfer(_amount);\r\n            EscapeHatchCalled(_token, _amount);\r\n            return;\r\n        }\r\n        /// @dev Logic for tokens\r\n        ERC20 token = ERC20(_token);\r\n        uint balance = token.balanceOf(this);\r\n        require(balance >= _amount);\r\n        require(token.transfer(escapeHatchDestination, _amount));\r\n        EscapeFundsCalled(_token, _amount);\r\n    }\r\n\r\n    event AutoPaySet();\r\n    event EscapeFundsCalled(address token, uint amount);\r\n    event ConfirmPayment(uint indexed idPayment, bytes32 indexed ref);\r\n    event CancelPayment(uint indexed idPayment, bytes32 indexed ref);\r\n    event AuthorizePayment(\r\n        uint indexed idPayment,\r\n        bytes32 indexed ref,\r\n        address indexed dest,\r\n        uint amount\r\n        );\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"escapeFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"escapeHatchCaller\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nPayments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dac\",\"type\":\"address\"}],\"name\":\"removeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwnerCandidate\",\"type\":\"address\"}],\"name\":\"proposeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"liquidPledging\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_idPayment\",\"type\":\"uint256\"}],\"name\":\"cancelPayment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_idPayment\",\"type\":\"uint256\"}],\"name\":\"confirmPayment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"payments\",\"outputs\":[{\"name\":\"state\",\"type\":\"uint8\"},{\"name\":\"ref\",\"type\":\"bytes32\"},{\"name\":\"dest\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"isTokenEscapable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"escapeHatch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_automatic\",\"type\":\"bool\"}],\"name\":\"setAutopay\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_idPayments\",\"type\":\"uint256[]\"}],\"name\":\"multiCancel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ref\",\"type\":\"bytes32\"},{\"name\":\"_dest\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"authorizePayment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"autoPay\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwnerCandidate\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newEscapeHatchCaller\",\"type\":\"address\"}],\"name\":\"changeHatchEscapeCaller\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLiquidPledging\",\"type\":\"address\"}],\"name\":\"setLiquidPledging\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"escapeHatchDestination\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_idPayments\",\"type\":\"uint256[]\"}],\"name\":\"multiConfirm\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_escapeHatchCaller\",\"type\":\"address\"},{\"name\":\"_escapeHatchDestination\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"AutoPaySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EscapeFundsCalled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"idPayment\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"ref\",\"type\":\"bytes32\"}],\"name\":\"ConfirmPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"idPayment\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"ref\",\"type\":\"bytes32\"}],\"name\":\"CancelPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"idPayment\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"ref\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"dest\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AuthorizePayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"}],\"name\":\"EscapeHatchBlackistedToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EscapeHatchCalled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"by\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"OwnershipRemoved\",\"type\":\"event\"}]","ContractName":"LPVault","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000001e9f6746147e937e8e1c29180e15af0bd5fd64bb0000000000000000000000008f951903c9360345b4e1b536c7f5ae8f88a64e79","Library":"","SwarmSource":"bzzr://dca55f9125a298d502ce87d4948f7dc75984cb1bcb57f47bb385e7ae1397ecb3"}]}