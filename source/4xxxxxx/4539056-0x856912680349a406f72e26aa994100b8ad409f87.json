{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.15;\r\n\r\ncontract Token {\r\n\r\n    /* Total amount of tokens */\r\n    uint256 public totalSupply;\r\n\r\n    /*\r\n     * Events\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n\r\n    /*\r\n     * Public functions\r\n     */\r\n\r\n    /// @notice send `value` token to `to` from `msg.sender`\r\n    /// @param to The address of the recipient\r\n    /// @param value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address to, uint value) public returns (bool);\r\n\r\n    /// @notice send `value` token to `to` from `from` on the condition it is approved by `from`\r\n    /// @param from The address of the sender\r\n    /// @param to The address of the recipient\r\n    /// @param value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address from, address to, uint value) public returns (bool);\r\n\r\n    /// @notice `msg.sender` approves `spender` to spend `value` tokens\r\n    /// @param spender The address of the account able to transfer the tokens\r\n    /// @param value The amount of tokens to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address spender, uint value) public returns (bool);\r\n\r\n    /// @param owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address owner) public constant returns (uint);\r\n\r\n    /// @param owner The address of the account owning tokens\r\n    /// @param spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address owner, address spender) public constant returns (uint);\r\n}\r\n\r\ncontract StandardToken is Token {\r\n    /*\r\n     *  Storage\r\n    */\r\n    mapping (address => uint) balances;\r\n    mapping (address => mapping (address => uint)) allowances;\r\n\r\n    /*\r\n     *  Public functions\r\n    */\r\n\r\n    function transfer(address to, uint value) public returns (bool) {\r\n        // Do not allow transfer to 0x0 or the token contract itself\r\n        require((to != 0x0) && (to != address(this)));\r\n        if (balances[msg.sender] < value)\r\n        revert();  // Balance too low\r\n        balances[msg.sender] -= value;\r\n        balances[to] += value;\r\n        Transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint value) public returns (bool) {\r\n        // Do not allow transfer to 0x0 or the token contract itself\r\n        require((to != 0x0) && (to != address(this)));\r\n        if (balances[from] < value || allowances[from][msg.sender] < value)\r\n        revert(); // Balance or allowance too low\r\n        balances[to] += value;\r\n        balances[from] -= value;\r\n        allowances[from][msg.sender] -= value;\r\n        Transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint value) public returns (bool) {\r\n        allowances[msg.sender][spender] = value;\r\n        Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public constant returns (uint) {\r\n        return allowances[owner][spender];\r\n    }\r\n\r\n    function balanceOf(address owner) public constant returns (uint) {\r\n        return balances[owner];\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        assert(a == b * c + a % b);\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract EtherSport is StandardToken {\r\n    using SafeMath for uint256;\r\n\r\n    /*\r\n     *  Metadata\r\n     */\r\n    string public constant name = \"Ether Sport\";\r\n    string public constant symbol = \"ESC\";\r\n    uint8 public constant decimals = 18;\r\n    uint256 public constant tokenUnit = 10 ** uint256(decimals);\r\n\r\n    /*\r\n     *  Contract owner (Ethersport)\r\n     */\r\n    address public owner;\r\n\r\n    /*\r\n     *  Hardware wallets\r\n     */\r\n    address public ethFundAddress;  // Address for ETH owned by Ethersport\r\n    address public escFundAddress;  // Address for ESC allocated to Ethersport\r\n\r\n    /*\r\n        *  List of token purchases per address\r\n        *  Same as balances[], except used for individual cap calculations,\r\n        *  because users can transfer tokens out during sale and reset token count in balances.\r\n        */\r\n    mapping (address => uint256) public purchases;\r\n    mapping (uint => address) public allocationsIndex;\r\n    mapping (address => uint256) public allocations;\r\n    uint public allocationsLength;\r\n    mapping (string => mapping (string => uint256)) cd; //crowdsaleData;\r\n\r\n    /*\r\n    *  Crowdsale parameters\r\n    */\r\n    bool public isFinalized;\r\n    bool public isStopped;\r\n    uint256 public startBlock;  // Block number when sale period begins\r\n    uint256 public endBlock;  // Block number when sale period ends\r\n    uint256 public assignedSupply;  // Total ESC tokens currently assigned\r\n    uint256 public constant minimumPayment = 5 * (10**14); // 0.0005 ETH\r\n    uint256 public constant escFund = 40 * (10**6) * tokenUnit;  // 40M ESC reserved for development and user growth fund\r\n\r\n    /*\r\n    *  Events\r\n    */\r\n    event ClaimESC(address indexed _to, uint256 _value);\r\n\r\n    modifier onlyBy(address _account){\r\n        require(msg.sender == _account);\r\n        _;\r\n    }\r\n\r\n    function changeOwner(address _newOwner) onlyBy(owner) external {\r\n        owner = _newOwner;\r\n    }\r\n\r\n    modifier respectTimeFrame() {\r\n        require(block.number >= startBlock);\r\n        require(block.number < endBlock);\r\n        _;\r\n    }\r\n\r\n    modifier salePeriodCompleted() {\r\n        require(block.number >= endBlock || assignedSupply.add(escFund).add(minimumPayment) > totalSupply);\r\n        _;\r\n    }\r\n\r\n    modifier isValidState() {\r\n        require(!isFinalized && !isStopped);\r\n        _;\r\n    }\r\n\r\n    function allocate(address _escAddress, uint token) internal {\r\n        allocationsIndex[allocationsLength] = _escAddress;\r\n        allocations[_escAddress] = token;\r\n        allocationsLength = allocationsLength + 1;\r\n    }\r\n    /*\r\n     *  Constructor\r\n     */\r\n    function EtherSport(\r\n    address _ethFundAddress,\r\n    uint256 _startBlock,\r\n    uint256 _preIcoHeight,\r\n    uint256 _stage1Height,\r\n    uint256 _stage2Height,\r\n    uint256 _stage3Height,\r\n    uint256 _stage4Height,\r\n    uint256 _endBlockHeight\r\n    )\r\n    public\r\n    {\r\n        require(_ethFundAddress != 0x0);\r\n        require(_startBlock > block.number);\r\n\r\n        owner = msg.sender; // Creator of contract is owner\r\n        isFinalized = false; // Controls pre-sale state through crowdsale state\r\n        isStopped   = false; // Circuit breaker (only to be used by contract owner in case of emergency)\r\n        ethFundAddress = _ethFundAddress;\r\n        totalSupply    = 100 * (10**6) * tokenUnit;  // 100M total ESC tokens\r\n        assignedSupply = 0;  // Set starting assigned supply to 0\r\n        //  Stages  |Duration| Start date           | End date             | Amount of       | Price per    | Amount of tokens | Minimum     |\r\n        //          |        |                      |                      | tokens for sale | token in ETH | per 1 ETH        | payment ETH |\r\n        //  --------|--------|----------------------|----------------------|-----------------|--------------|------------------|-------------|\r\n        //  Pre ICO | 1 week | 13.11.2017 12:00 UTC | 19.11.2017 12:00 UTC | 10,000,000      | 0.00050      | 2000.00          | 0.0005      |\r\n        //  1 stage | 1 hour | 21.11.2017 12:00 UTC | 21.11.2017 13:00 UTC | 10,000,000      | 0.00100      | 1000.00          | 0.0005      |\r\n        //  2 stage | 1 day  | 22.11.2017 13:00 UTC | 29.11.2017 13:00 UTC | 15,000,000      | 0.00130      | 769.23           | 0.0005      |\r\n        //  3 stage | 1 week | 22.11.2017 13:00 UTC | 29.11.2017 13:00 UTC | 15,000,000      | 0.00170      | 588.24           | 0.0005      |\r\n        //  4 stage | 3 weeks| 29.11.2017 13:00 UTC | 20.12.2017 13:00 UTC | 20,000,000      | 0.00200      | 500.00           | 0.0005      |\r\n        //  --------|--------|----------------------|----------------------|-----------------|--------------|------------------|-------------|\r\n        //                                                                 | 70,000,000      |\r\n        cd['preIco']['startBlock'] = _startBlock;                 cd['preIco']['endBlock'] = _startBlock + _preIcoHeight;     cd['preIco']['cap'] = 10 * 10**6 * 10**18; cd['preIco']['exRate'] = 200000;\r\n        cd['stage1']['startBlock'] = _startBlock + _stage1Height; cd['stage1']['endBlock'] = _startBlock + _stage2Height - 1; cd['stage1']['cap'] = 10 * 10**6 * 10**18; cd['stage1']['exRate'] = 100000;\r\n        cd['stage2']['startBlock'] = _startBlock + _stage2Height; cd['stage2']['endBlock'] = _startBlock + _stage3Height - 1; cd['stage2']['cap'] = 15 * 10**6 * 10**18; cd['stage2']['exRate'] = 76923;\r\n        cd['stage3']['startBlock'] = _startBlock + _stage3Height; cd['stage3']['endBlock'] = _startBlock + _stage4Height - 1; cd['stage3']['cap'] = 15 * 10**6 * 10**18; cd['stage3']['exRate'] = 58824;\r\n        cd['stage4']['startBlock'] = _startBlock + _stage4Height; cd['stage4']['endBlock'] = _startBlock + _endBlockHeight;   cd['stage4']['cap'] = 20 * 10**6 * 10**18; cd['stage4']['exRate'] = 50000;\r\n        startBlock = _startBlock;\r\n        endBlock   = _startBlock +_endBlockHeight;\r\n\r\n        escFundAddress = 0xfA29D004fD4139B04bda5fa2633bd7324d6f6c76;\r\n        allocationsLength = 0;\r\n        //• 13% (13’000’000 ESC) will remain at EtherSport for supporting the game process;\r\n        allocate(escFundAddress, 0); // will remain at EtherSport for supporting the game process (remaining unassigned supply);\r\n        allocate(0x610a20536e7b7A361D6c919529DBc1E037E1BEcB, 5 * 10**6 * 10**18); // will remain at EtherSport for supporting the game process;\r\n        allocate(0x198bd6be0D747111BEBd5bD053a594FD63F3e87d, 4 * 10**6 * 10**18); // will remain at EtherSport for supporting the game process;\r\n        allocate(0x02401E5B98202a579F0067781d66FBd4F2700Cb6, 4 * 10**6 * 10**18); // will remain at EtherSport for supporting the game process;\r\n        //• 5% (5’000’000 ESC) will be allocated for the bounty campaign;\r\n        allocate(0x778ACEcf52520266675b09b8F5272098D8679f43, 3 * 10**6 * 10**18); // will be allocated for the bounty campaign;\r\n        allocate(0xdE96fdaFf4f865A1E27085426956748c5D4b8e24, 2 * 10**6 * 10**18); // will be allocated for the bounty campaign;\r\n        //• 5% (5’000’000 ESC) will be paid to the project founders and the team;\r\n        allocate(0x4E10125fc934FCADB7a30b97F9b4b642d4804e3d, 2 * 10**6 * 10**18); // will be paid to the project founders and the team;\r\n        allocate(0xF391B5b62Fd43401751c65aF5D1D02D850Ab6b7c, 2 * 10**6 * 10**18); // will be paid to the project founders and the team;\r\n        allocate(0x08474BcC5F8BB9EEe6cAc7CBA9b6fb1d20eF5AA4, 1 * 10**6 * 10**18); // will be paid to the project founders and the team;\r\n        //• 5% (5’000’000 ESC) will be paid to the Angel investors;\r\n        allocate(0x9F5818196E45ceC2d57DFc0fc0e3D7388e5de48d, 2 * 10**6 * 10**18); // will be paid to the Angel investors.\r\n        allocate(0x9e43667D1e3Fb460f1f2432D0FF3203364a3d284, 2 * 10**6 * 10**18); // will be paid to the Angel investors.\r\n        allocate(0x809040D6226FE73f245a0a16Dd685b5641540B74,  500 * 10**3 * 10**18); // will be paid to the Angel investors.\r\n        allocate(0xaE2542d16cc3D6d487fe87Fc0C03ad0D41e46AFf,  500 * 10**3 * 10**18); // will be paid to the Angel investors.\r\n        //• 1% (1’000’000 ESC) will be left in the system for building the first jackpot;\r\n        allocate(0xbC82DE22610c51ACe45d3BCf03b9b3cd179731b2, 1 * 10**6 * 10**18); // will be left in the system for building the first jackpot;\r\n        //• 1% (1’000’000 ESC) will be distributed among advisors;\r\n        allocate(0x302Cd6D41866ec03edF421a0CD4f4cbDFB0B67b0,  800 * 10**3 * 10**18); // will be distributed among advisors;\r\n        allocate(0xe190CCb2f92A0dCAc30bb4a4a92863879e5ff751,   50 * 10**3 * 10**18); // will be distributed among advisors;\r\n        allocate(0xfC7cf20f29f5690dF508Dd0FB99bFCB4a7d23073,  100 * 10**3 * 10**18); // will be distributed among advisors;\r\n        allocate(0x1DC97D37eCbf7D255BF4d461075936df2BdFd742,   50 * 10**3 * 10**18); // will be distributed among advisors;\r\n    }\r\n\r\n    /// @notice Stop sale in case of emergency (i.e. circuit breaker)\r\n    /// @dev Only allowed to be called by the owner\r\n    function stopSale() onlyBy(owner) external {\r\n        isStopped = true;\r\n    }\r\n\r\n    /// @notice Restart sale in case of an emergency stop\r\n    /// @dev Only allowed to be called by the owner\r\n    function restartSale() onlyBy(owner) external {\r\n        isStopped = false;\r\n    }\r\n\r\n    /// @dev Fallback function can be used to buy tokens\r\n    function () payable public {\r\n        claimTokens();\r\n    }\r\n\r\n    /// @notice Calculate rate based on block number\r\n    function calculateTokenExchangeRate() internal returns (uint256) {\r\n        if (cd['preIco']['startBlock'] <= block.number && block.number <= cd['preIco']['endBlock']) { return cd['preIco']['exRate']; }\r\n        if (cd['stage1']['startBlock'] <= block.number && block.number <= cd['stage1']['endBlock']) { return cd['stage1']['exRate']; }\r\n        if (cd['stage2']['startBlock'] <= block.number && block.number <= cd['stage2']['endBlock']) { return cd['stage2']['exRate']; }\r\n        if (cd['stage3']['startBlock'] <= block.number && block.number <= cd['stage3']['endBlock']) { return cd['stage3']['exRate']; }\r\n        if (cd['stage4']['startBlock'] <= block.number && block.number <= cd['stage4']['endBlock']) { return cd['stage4']['exRate']; }\r\n        // in case between Pre-ICO and ICO\r\n        return 0;\r\n    }\r\n\r\n    function maximumTokensToBuy() constant internal returns (uint256) {\r\n        uint256 maximum = 0;\r\n        if (cd['preIco']['startBlock'] <= block.number) { maximum = maximum.add(cd['preIco']['cap']); }\r\n        if (cd['stage1']['startBlock'] <= block.number) { maximum = maximum.add(cd['stage1']['cap']); }\r\n        if (cd['stage2']['startBlock'] <= block.number) { maximum = maximum.add(cd['stage2']['cap']); }\r\n        if (cd['stage3']['startBlock'] <= block.number) { maximum = maximum.add(cd['stage3']['cap']); }\r\n        if (cd['stage4']['startBlock'] <= block.number) { maximum = maximum.add(cd['stage4']['cap']); }\r\n        return maximum.sub(assignedSupply);\r\n    }\r\n\r\n    /// @notice Create `msg.value` ETH worth of ESC\r\n    /// @dev Only allowed to be called within the timeframe of the sale period\r\n    function claimTokens() respectTimeFrame isValidState payable public {\r\n        require(msg.value >= minimumPayment);\r\n\r\n        uint256 tokenExchangeRate = calculateTokenExchangeRate();\r\n        // tokenExchangeRate == 0 mean that now not valid time to take part in crowdsale event\r\n        require(tokenExchangeRate > 0);\r\n\r\n        uint256 tokens = msg.value.mul(tokenExchangeRate).div(100);\r\n\r\n        // Check that we can sell this amount of tokens in the moment\r\n        require(tokens <= maximumTokensToBuy());\r\n\r\n        // Check that we're not over totals\r\n        uint256 checkedSupply = assignedSupply.add(tokens);\r\n\r\n        // Return money if we're over total token supply\r\n        require(checkedSupply.add(escFund) <= totalSupply);\r\n\r\n        balances[msg.sender] = balances[msg.sender].add(tokens);\r\n        purchases[msg.sender] = purchases[msg.sender].add(tokens);\r\n\r\n        assignedSupply = checkedSupply;\r\n        ClaimESC(msg.sender, tokens);  // Logs token creation for UI purposes\r\n        // As per ERC20 spec, a token contract which creates new tokens SHOULD trigger a Transfer event with the _from address\r\n        // set to 0x0 when tokens are created (https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md)\r\n        Transfer(0x0, msg.sender, tokens);\r\n    }\r\n\r\n    /// @notice Sends the ETH to ETH fund wallet and finalizes the token sale\r\n    function finalize() salePeriodCompleted isValidState onlyBy(owner) external {\r\n        // Upon successful completion of sale, send tokens to ESC fund\r\n        balances[escFundAddress] = balances[escFundAddress].add(escFund);\r\n        assignedSupply = assignedSupply.add(escFund);\r\n        ClaimESC(escFundAddress, escFund);   // Log tokens claimed by Ethersport ESC fund\r\n        Transfer(0x0, escFundAddress, escFund);\r\n\r\n\r\n        for(uint i=0;i<allocationsLength;i++)\r\n        {\r\n            balances[allocationsIndex[i]] = balances[allocationsIndex[i]].add(allocations[allocationsIndex[i]]);\r\n            ClaimESC(allocationsIndex[i], allocations[allocationsIndex[i]]);  // Log tokens claimed by Ethersport ESC fund\r\n            Transfer(0x0, allocationsIndex[i], allocations[allocationsIndex[i]]);\r\n        }\r\n\r\n        // In the case where not all 70M ESC allocated to crowdfund participants\r\n        // is sold, send the remaining unassigned supply to ESC fund address,\r\n        // which will then be used to fund the user growth pool.\r\n        if (assignedSupply < totalSupply) {\r\n            uint256 unassignedSupply = totalSupply.sub(assignedSupply);\r\n            balances[escFundAddress] = balances[escFundAddress].add(unassignedSupply);\r\n            assignedSupply = assignedSupply.add(unassignedSupply);\r\n\r\n            ClaimESC(escFundAddress, unassignedSupply);  // Log tokens claimed by Ethersport ESC fund\r\n            Transfer(0x0, escFundAddress, unassignedSupply);\r\n        }\r\n\r\n        ethFundAddress.transfer(this.balance);\r\n\r\n        isFinalized = true; // Finalize sale\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethFundAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"escFund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isStopped\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allocationsIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimTokens\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allocations\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"restartSale\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"purchases\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumPayment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"assignedSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stopSale\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenUnit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"escFundAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allocationsLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_ethFundAddress\",\"type\":\"address\"},{\"name\":\"_startBlock\",\"type\":\"uint256\"},{\"name\":\"_preIcoHeight\",\"type\":\"uint256\"},{\"name\":\"_stage1Height\",\"type\":\"uint256\"},{\"name\":\"_stage2Height\",\"type\":\"uint256\"},{\"name\":\"_stage3Height\",\"type\":\"uint256\"},{\"name\":\"_stage4Height\",\"type\":\"uint256\"},{\"name\":\"_endBlockHeight\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"ClaimESC\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"EtherSport","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000052eac68beafb8ffbde44c14e71be31a9f4161d440000000000000000000000000000000000000000000000000000000000455a11000000000000000000000000000000000000000000000000000000000000af00000000000000000000000000000000000000000000000000000000000000e0db000000000000000000000000000000000000000000000000000000000000e20b000000000000000000000000000000000000000000000000000000000000fb0b000000000000000000000000000000000000000000000000000000000001a99a000000000000000000000000000000000000000000000000000000000003b54a","Library":"","SwarmSource":"bzzr://e6b7539816c3fcee2379cd7994e658050446aca8b308e3b7e9484c5e66375a22"}]}