{"status":"1","message":"OK","result":[{"SourceCode":"// Bitcoin transaction parsing library\r\n\r\n// Copyright 2016 rain <https://keybase.io/rain>\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n// https://en.bitcoin.it/wiki/Protocol_documentation#tx\r\n//\r\n// Raw Bitcoin transaction structure:\r\n//\r\n// field     | size | type     | description\r\n// version   | 4    | int32    | transaction version number\r\n// n_tx_in   | 1-9  | var_int  | number of transaction inputs\r\n// tx_in     | 41+  | tx_in[]  | list of transaction inputs\r\n// n_tx_out  | 1-9  | var_int  | number of transaction outputs\r\n// tx_out    | 9+   | tx_out[] | list of transaction outputs\r\n// lock_time | 4    | uint32   | block number / timestamp at which tx locked\r\n//\r\n// Transaction input (tx_in) structure:\r\n//\r\n// field      | size | type     | description\r\n// previous   | 36   | outpoint | Previous output transaction reference\r\n// script_len | 1-9  | var_int  | Length of the signature script\r\n// sig_script | ?    | uchar[]  | Script for confirming transaction authorization\r\n// sequence   | 4    | uint32   | Sender transaction version\r\n//\r\n// OutPoint structure:\r\n//\r\n// field      | size | type     | description\r\n// hash       | 32   | char[32] | The hash of the referenced transaction\r\n// index      | 4    | uint32   | The index of this output in the referenced transaction\r\n//\r\n// Transaction output (tx_out) structure:\r\n//\r\n// field         | size | type     | description\r\n// value         | 8    | int64    | Transaction value (Satoshis)\r\n// pk_script_len | 1-9  | var_int  | Length of the public key script\r\n// pk_script     | ?    | uchar[]  | Public key as a Bitcoin script.\r\n//\r\n// Variable integers (var_int) can be encoded differently depending\r\n// on the represented value, to save space. Variable integers always\r\n// precede an array of a variable length data type (e.g. tx_in).\r\n//\r\n// Variable integer encodings as a function of represented value:\r\n//\r\n// value           | bytes  | format\r\n// <0xFD (253)     | 1      | uint8\r\n// <=0xFFFF (65535)| 3      | 0xFD followed by length as uint16\r\n// <=0xFFFF FFFF   | 5      | 0xFE followed by length as uint32\r\n// -               | 9      | 0xFF followed by length as uint64\r\n//\r\n// Public key scripts `pk_script` are set on the output and can\r\n// take a number of forms. The regular transaction script is\r\n// called 'pay-to-pubkey-hash' (P2PKH):\r\n//\r\n// OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG\r\n//\r\n// OP_x are Bitcoin script opcodes. The bytes representation (including\r\n// the 0x14 20-byte stack push) is:\r\n//\r\n// 0x76 0xA9 0x14 <pubKeyHash> 0x88 0xAC\r\n//\r\n// The <pubKeyHash> is the ripemd160 hash of the sha256 hash of\r\n// the public key, preceded by a network version byte. (21 bytes total)\r\n//\r\n// Network version bytes: 0x00 (mainnet); 0x6f (testnet); 0x34 (namecoin)\r\n//\r\n// The Bitcoin address is derived from the pubKeyHash. The binary form is the\r\n// pubKeyHash, plus a checksum at the end.  The checksum is the first 4 bytes\r\n// of the (32 byte) double sha256 of the pubKeyHash. (25 bytes total)\r\n// This is converted to base58 to form the publicly used Bitcoin address.\r\n// Mainnet P2PKH transaction scripts are to addresses beginning with '1'.\r\n//\r\n// P2SH ('pay to script hash') scripts only supply a script hash. The spender\r\n// must then provide the script that would allow them to redeem this output.\r\n// This allows for arbitrarily complex scripts to be funded using only a\r\n// hash of the script, and moves the onus on providing the script from\r\n// the spender to the redeemer.\r\n//\r\n// The P2SH script format is simple:\r\n//\r\n// OP_HASH160 <scriptHash> OP_EQUAL\r\n//\r\n// 0xA9 0x14 <scriptHash> 0x87\r\n//\r\n// The <scriptHash> is the ripemd160 hash of the sha256 hash of the\r\n// redeem script. The P2SH address is derived from the scriptHash.\r\n// Addresses are the scriptHash with a version prefix of 5, encoded as\r\n// Base58check. These addresses begin with a '3'.\r\n\r\npragma solidity ^0.4.11;\r\n\r\n// parse a raw bitcoin transaction byte array\r\nlibrary BTC {\r\n    // Convert a variable integer into something useful and return it and\r\n    // the index to after it.\r\n    function parseVarInt(bytes txBytes, uint pos) returns (uint, uint) {\r\n        // the first byte tells us how big the integer is\r\n        var ibit = uint8(txBytes[pos]);\r\n        pos += 1;  // skip ibit\r\n\r\n        if (ibit < 0xfd) {\r\n            return (ibit, pos);\r\n        } else if (ibit == 0xfd) {\r\n            return (getBytesLE(txBytes, pos, 16), pos + 2);\r\n        } else if (ibit == 0xfe) {\r\n            return (getBytesLE(txBytes, pos, 32), pos + 4);\r\n        } else if (ibit == 0xff) {\r\n            return (getBytesLE(txBytes, pos, 64), pos + 8);\r\n        }\r\n    }\r\n    // convert little endian bytes to uint\r\n    function getBytesLE(bytes data, uint pos, uint bits) returns (uint) {\r\n        if (bits == 8) {\r\n            return uint8(data[pos]);\r\n        } else if (bits == 16) {\r\n            return uint16(data[pos])\r\n                 + uint16(data[pos + 1]) * 2 ** 8;\r\n        } else if (bits == 32) {\r\n            return uint32(data[pos])\r\n                 + uint32(data[pos + 1]) * 2 ** 8\r\n                 + uint32(data[pos + 2]) * 2 ** 16\r\n                 + uint32(data[pos + 3]) * 2 ** 24;\r\n        } else if (bits == 64) {\r\n            return uint64(data[pos])\r\n                 + uint64(data[pos + 1]) * 2 ** 8\r\n                 + uint64(data[pos + 2]) * 2 ** 16\r\n                 + uint64(data[pos + 3]) * 2 ** 24\r\n                 + uint64(data[pos + 4]) * 2 ** 32\r\n                 + uint64(data[pos + 5]) * 2 ** 40\r\n                 + uint64(data[pos + 6]) * 2 ** 48\r\n                 + uint64(data[pos + 7]) * 2 ** 56;\r\n        }\r\n    }\r\n    // scan the full transaction bytes and return the first two output\r\n    // values (in satoshis) and addresses (in binary)\r\n    function getFirstTwoOutputs(bytes txBytes)\r\n             returns (uint, bytes20, uint, bytes20)\r\n    {\r\n        uint pos;\r\n        uint[] memory input_script_lens = new uint[](2);\r\n        uint[] memory output_script_lens = new uint[](2);\r\n        uint[] memory script_starts = new uint[](2);\r\n        uint[] memory output_values = new uint[](2);\r\n        bytes20[] memory output_addresses = new bytes20[](2);\r\n\r\n        pos = 4;  // skip version\r\n\r\n        (input_script_lens, pos) = scanInputs(txBytes, pos, 0);\r\n\r\n        (output_values, script_starts, output_script_lens, pos) = scanOutputs(txBytes, pos, 2);\r\n\r\n        for (uint i = 0; i < 2; i++) {\r\n            var pkhash = parseOutputScript(txBytes, script_starts[i], output_script_lens[i]);\r\n            output_addresses[i] = pkhash;\r\n        }\r\n\r\n        return (output_values[0], output_addresses[0],\r\n                output_values[1], output_addresses[1]);\r\n    }\r\n    // Check whether `btcAddress` is in the transaction outputs *and*\r\n    // whether *at least* `value` has been sent to it.\r\n        // Check whether `btcAddress` is in the transaction outputs *and*\r\n    // whether *at least* `value` has been sent to it.\r\n    function checkValueSent(bytes txBytes, bytes20 btcAddress, uint value)\r\n             returns (bool,uint)\r\n    {\r\n        uint pos = 4;  // skip version\r\n        (, pos) = scanInputs(txBytes, pos, 0);  // find end of inputs\r\n\r\n        // scan *all* the outputs and find where they are\r\n        var (output_values, script_starts, output_script_lens,) = scanOutputs(txBytes, pos, 0);\r\n\r\n        // look at each output and check whether it at least value to btcAddress\r\n        for (uint i = 0; i < output_values.length; i++) {\r\n            var pkhash = parseOutputScript(txBytes, script_starts[i], output_script_lens[i]);\r\n            if (pkhash == btcAddress && output_values[i] >= value) {\r\n                return (true,output_values[i]);\r\n            }\r\n        }\r\n    }\r\n    // scan the inputs and find the script lengths.\r\n    // return an array of script lengths and the end position\r\n    // of the inputs.\r\n    // takes a 'stop' argument which sets the maximum number of\r\n    // outputs to scan through. stop=0 => scan all.\r\n    function scanInputs(bytes txBytes, uint pos, uint stop)\r\n             returns (uint[], uint)\r\n    {\r\n        uint n_inputs;\r\n        uint halt;\r\n        uint script_len;\r\n\r\n        (n_inputs, pos) = parseVarInt(txBytes, pos);\r\n\r\n        if (stop == 0 || stop > n_inputs) {\r\n            halt = n_inputs;\r\n        } else {\r\n            halt = stop;\r\n        }\r\n\r\n        uint[] memory script_lens = new uint[](halt);\r\n\r\n        for (var i = 0; i < halt; i++) {\r\n            pos += 36;  // skip outpoint\r\n            (script_len, pos) = parseVarInt(txBytes, pos);\r\n            script_lens[i] = script_len;\r\n            pos += script_len + 4;  // skip sig_script, seq\r\n        }\r\n\r\n        return (script_lens, pos);\r\n    }\r\n    // scan the outputs and find the values and script lengths.\r\n    // return array of values, array of script lengths and the\r\n    // end position of the outputs.\r\n    // takes a 'stop' argument which sets the maximum number of\r\n    // outputs to scan through. stop=0 => scan all.\r\n    function scanOutputs(bytes txBytes, uint pos, uint stop)\r\n             returns (uint[], uint[], uint[], uint)\r\n    {\r\n        uint n_outputs;\r\n        uint halt;\r\n        uint script_len;\r\n\r\n        (n_outputs, pos) = parseVarInt(txBytes, pos);\r\n\r\n        if (stop == 0 || stop > n_outputs) {\r\n            halt = n_outputs;\r\n        } else {\r\n            halt = stop;\r\n        }\r\n\r\n        uint[] memory script_starts = new uint[](halt);\r\n        uint[] memory script_lens = new uint[](halt);\r\n        uint[] memory output_values = new uint[](halt);\r\n\r\n        for (var i = 0; i < halt; i++) {\r\n            output_values[i] = getBytesLE(txBytes, pos, 64);\r\n            pos += 8;\r\n\r\n            (script_len, pos) = parseVarInt(txBytes, pos);\r\n            script_starts[i] = pos;\r\n            script_lens[i] = script_len;\r\n            pos += script_len;\r\n        }\r\n\r\n        return (output_values, script_starts, script_lens, pos);\r\n    }\r\n    // Slice 20 contiguous bytes from bytes `data`, starting at `start`\r\n    function sliceBytes20(bytes data, uint start) returns (bytes20) {\r\n        uint160 slice = 0;\r\n        for (uint160 i = 0; i < 20; i++) {\r\n            slice += uint160(data[i + start]) << (8 * (19 - i));\r\n        }\r\n        return bytes20(slice);\r\n    }\r\n    // returns true if the bytes located in txBytes by pos and\r\n    // script_len represent a P2PKH script\r\n    function isP2PKH(bytes txBytes, uint pos, uint script_len) returns (bool) {\r\n        return (script_len == 25)           // 20 byte pubkeyhash + 5 bytes of script\r\n            && (txBytes[pos] == 0x76)       // OP_DUP\r\n            && (txBytes[pos + 1] == 0xa9)   // OP_HASH160\r\n            && (txBytes[pos + 2] == 0x14)   // bytes to push\r\n            && (txBytes[pos + 23] == 0x88)  // OP_EQUALVERIFY\r\n            && (txBytes[pos + 24] == 0xac); // OP_CHECKSIG\r\n    }\r\n    // returns true if the bytes located in txBytes by pos and\r\n    // script_len represent a P2SH script\r\n    function isP2SH(bytes txBytes, uint pos, uint script_len) returns (bool) {\r\n        return (script_len == 23)           // 20 byte scripthash + 3 bytes of script\r\n            && (txBytes[pos + 0] == 0xa9)   // OP_HASH160\r\n            && (txBytes[pos + 1] == 0x14)   // bytes to push\r\n            && (txBytes[pos + 22] == 0x87); // OP_EQUAL\r\n    }\r\n    // Get the pubkeyhash / scripthash from an output script. Assumes\r\n    // pay-to-pubkey-hash (P2PKH) or pay-to-script-hash (P2SH) outputs.\r\n    // Returns the pubkeyhash/ scripthash, or zero if unknown output.\r\n    function parseOutputScript(bytes txBytes, uint pos, uint script_len)\r\n             returns (bytes20)\r\n    {\r\n        if (isP2PKH(txBytes, pos, script_len)) {\r\n            return sliceBytes20(txBytes, pos + 3);\r\n        } else if (isP2SH(txBytes, pos, script_len)) {\r\n            return sliceBytes20(txBytes, pos + 2);\r\n        } else {\r\n            return;\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"txBytes\",\"type\":\"bytes\"},{\"name\":\"pos\",\"type\":\"uint256\"},{\"name\":\"script_len\",\"type\":\"uint256\"}],\"name\":\"parseOutputScript\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes20\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"txBytes\",\"type\":\"bytes\"},{\"name\":\"pos\",\"type\":\"uint256\"}],\"name\":\"parseVarInt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"txBytes\",\"type\":\"bytes\"},{\"name\":\"pos\",\"type\":\"uint256\"},{\"name\":\"script_len\",\"type\":\"uint256\"}],\"name\":\"isP2PKH\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"txBytes\",\"type\":\"bytes\"},{\"name\":\"pos\",\"type\":\"uint256\"},{\"name\":\"stop\",\"type\":\"uint256\"}],\"name\":\"scanOutputs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"start\",\"type\":\"uint256\"}],\"name\":\"sliceBytes20\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes20\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"txBytes\",\"type\":\"bytes\"},{\"name\":\"pos\",\"type\":\"uint256\"},{\"name\":\"script_len\",\"type\":\"uint256\"}],\"name\":\"isP2SH\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"pos\",\"type\":\"uint256\"},{\"name\":\"bits\",\"type\":\"uint256\"}],\"name\":\"getBytesLE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"txBytes\",\"type\":\"bytes\"}],\"name\":\"getFirstTwoOutputs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes20\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes20\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"txBytes\",\"type\":\"bytes\"},{\"name\":\"pos\",\"type\":\"uint256\"},{\"name\":\"stop\",\"type\":\"uint256\"}],\"name\":\"scanInputs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"txBytes\",\"type\":\"bytes\"},{\"name\":\"btcAddress\",\"type\":\"bytes20\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"checkValueSent\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"BTC","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://16cc90c22162d45068f73936e81b8d571a2f6a5d597e51c4a335b9205de6beac"}]}