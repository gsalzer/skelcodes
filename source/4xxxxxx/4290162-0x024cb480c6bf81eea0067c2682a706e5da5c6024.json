{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n/**\r\n * @title Owned contract with safe ownership pass.\r\n *\r\n * Note: all the non constant functions return false instead of throwing in case if state change\r\n * didn't happen yet.\r\n */\r\ncontract Owned {\r\n    /**\r\n     * Contract owner address\r\n     */\r\n    address public contractOwner;\r\n\r\n    /**\r\n     * Contract owner address\r\n     */\r\n    address public pendingContractOwner;\r\n\r\n    function Owned() {\r\n        contractOwner = msg.sender;\r\n    }\r\n\r\n    /**\r\n    * @dev Owner check modifier\r\n    */\r\n    modifier onlyContractOwner() {\r\n        if (contractOwner == msg.sender) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Destroy contract and scrub a data\r\n     * @notice Only owner can call it\r\n     */\r\n    function destroy() onlyContractOwner {\r\n        suicide(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * Prepares ownership pass.\r\n     *\r\n     * Can only be called by current owner.\r\n     *\r\n     * @param _to address of the next owner. 0x0 is not allowed.\r\n     *\r\n     * @return success.\r\n     */\r\n    function changeContractOwnership(address _to) onlyContractOwner() returns(bool) {\r\n        if (_to  == 0x0) {\r\n            return false;\r\n        }\r\n\r\n        pendingContractOwner = _to;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Finalize ownership pass.\r\n     *\r\n     * Can only be called by pending owner.\r\n     *\r\n     * @return success.\r\n     */\r\n    function claimContractOwnership() returns(bool) {\r\n        if (pendingContractOwner != msg.sender) {\r\n            return false;\r\n        }\r\n\r\n        contractOwner = pendingContractOwner;\r\n        delete pendingContractOwner;\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\ncontract ERC20Interface {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed from, address indexed spender, uint256 value);\r\n    string public symbol;\r\n\r\n    function totalSupply() constant returns (uint256 supply);\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n}\r\n\r\n/**\r\n * @title Generic owned destroyable contract\r\n */\r\ncontract Object is Owned {\r\n    /**\r\n    *  Common result code. Means everything is fine.\r\n    */\r\n    uint constant OK = 1;\r\n    uint constant OWNED_ACCESS_DENIED_ONLY_CONTRACT_OWNER = 8;\r\n\r\n    function withdrawnTokens(address[] tokens, address _to) onlyContractOwner returns(uint) {\r\n        for(uint i=0;i<tokens.length;i++) {\r\n            address token = tokens[i];\r\n            uint balance = ERC20Interface(token).balanceOf(this);\r\n            if(balance != 0)\r\n                ERC20Interface(token).transfer(_to,balance);\r\n        }\r\n        return OK;\r\n    }\r\n\r\n    function checkOnlyContractOwner() internal constant returns(uint) {\r\n        if (contractOwner == msg.sender) {\r\n            return OK;\r\n        }\r\n\r\n        return OWNED_ACCESS_DENIED_ONLY_CONTRACT_OWNER;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title General MultiEventsHistory user.\r\n *\r\n */\r\ncontract MultiEventsHistoryAdapter {\r\n\r\n    /**\r\n    *   @dev It is address of MultiEventsHistory caller assuming we are inside of delegate call.\r\n    */\r\n    function _self() constant internal returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\ncontract DelayedPaymentsEmitter is MultiEventsHistoryAdapter {\r\n    event Error(bytes32 message);\r\n\r\n    function emitError(bytes32 _message) {\r\n        Error(_message);\r\n    }\r\n}\r\n\r\ncontract DelayedPayments is Object {\r\n   \r\n    uint constant DELAYED_PAYMENTS_SCOPE = 52000;\r\n    uint constant DELAYED_PAYMENTS_INVALID_INVOCATION = DELAYED_PAYMENTS_SCOPE + 17;\r\n\r\n    /// @dev `Payment` is a public structure that describes the details of\r\n    ///  each payment making it easy to track the movement of funds\r\n    ///  transparently\r\n    struct Payment {\r\n        address spender;        // Who is sending the funds\r\n        uint earliestPayTime;   // The earliest a payment can be made (Unix Time)\r\n        bool canceled;         // If True then the payment has been canceled\r\n        bool paid;              // If True then the payment has been paid\r\n        address recipient;      // Who is receiving the funds\r\n        uint amount;            // The amount of wei sent in the payment\r\n        uint securityGuardDelay;// The seconds `securityGuard` can delay payment\r\n    }\r\n\r\n    Payment[] public authorizedPayments;\r\n\r\n    address public securityGuard;\r\n    uint public absoluteMinTimeLock;\r\n    uint public timeLock;\r\n    uint public maxSecurityGuardDelay;\r\n\r\n    // Should use interface of the emitter, but address of events history.\r\n    address public eventsHistory;\r\n\r\n    /// @dev The white list of approved addresses allowed to set up && receive\r\n    ///  payments from this vault\r\n    mapping (address => bool) public allowedSpenders;\r\n\r\n    /// @dev The address assigned the role of `securityGuard` is the only\r\n    ///  addresses that can call a function with this modifier\r\n    modifier onlySecurityGuard { if (msg.sender != securityGuard) throw; _; }\r\n\r\n    // @dev Events to make the payment movements easy to find on the blockchain\r\n    event PaymentAuthorized(uint indexed idPayment, address indexed recipient, uint amount);\r\n    event PaymentExecuted(uint indexed idPayment, address indexed recipient, uint amount);\r\n    event PaymentCanceled(uint indexed idPayment);\r\n    event EtherReceived(address indexed from, uint amount);\r\n    event SpenderAuthorization(address indexed spender, bool authorized);\r\n\r\n/////////\r\n// Constructor\r\n/////////\r\n\r\n    /// @notice The Constructor creates the Vault on the blockchain\r\n    /// @param _absoluteMinTimeLock The minimum number of seconds `timelock` can\r\n    ///  be set to, if set to 0 the `owner` can remove the `timeLock` completely\r\n    /// @param _timeLock Initial number of seconds that payments are delayed\r\n    ///  after they are authorized (a security precaution)\r\n    /// @param _maxSecurityGuardDelay The maximum number of seconds in total\r\n    ///   that `securityGuard` can delay a payment so that the owner can cancel\r\n    ///   the payment if needed\r\n    function DelayedPayments(\r\n        uint _absoluteMinTimeLock,\r\n        uint _timeLock,\r\n        uint _maxSecurityGuardDelay) \r\n    {\r\n        absoluteMinTimeLock = _absoluteMinTimeLock;\r\n        timeLock = _timeLock;\r\n        securityGuard = msg.sender;\r\n        maxSecurityGuardDelay = _maxSecurityGuardDelay;\r\n    }\r\n\r\n    /**\r\n     * Emits Error event with specified error message.\r\n     *\r\n     * Should only be used if no state changes happened.\r\n     *\r\n     * @param _errorCode code of an error\r\n     * @param _message error message.\r\n     */\r\n    function _error(uint _errorCode, bytes32 _message) internal returns(uint) {\r\n        DelayedPaymentsEmitter(eventsHistory).emitError(_message);\r\n        return _errorCode;\r\n    }\r\n\r\n    /**\r\n     * Sets EventsHstory contract address.\r\n     *\r\n     * Can be set only once, and only by contract owner.\r\n     *\r\n     * @param _eventsHistory MultiEventsHistory contract address.\r\n     *\r\n     * @return success.\r\n     */\r\n    function setupEventsHistory(address _eventsHistory) returns(uint errorCode) {\r\n        errorCode = checkOnlyContractOwner();\r\n        if (errorCode != OK) {\r\n            return errorCode;\r\n        }\r\n        if (eventsHistory != 0x0 && eventsHistory != _eventsHistory) {\r\n            return DELAYED_PAYMENTS_INVALID_INVOCATION;\r\n        }\r\n        eventsHistory = _eventsHistory;\r\n        return OK;\r\n    }\r\n\r\n/////////\r\n// Helper functions\r\n/////////\r\n\r\n    /// @notice States the total number of authorized payments in this contract\r\n    /// @return The number of payments ever authorized even if they were canceled\r\n    function numberOfAuthorizedPayments() constant returns (uint) {\r\n        return authorizedPayments.length;\r\n    }\r\n\r\n//////\r\n// Receive Ether\r\n//////\r\n\r\n    /// @notice Called anytime ether is sent to the contract && creates an event\r\n    /// to more easily track the incoming transactions\r\n    function receiveEther() payable {\r\n        EtherReceived(msg.sender, msg.value);\r\n    }\r\n\r\n    /// @notice The fall back function is called whenever ether is sent to this\r\n    ///  contract\r\n    function () payable {\r\n        receiveEther();\r\n    }\r\n\r\n////////\r\n// Spender Interface\r\n////////\r\n\r\n    /// @notice only `allowedSpenders[]` Creates a new `Payment`\r\n    /// @param _recipient Destination of the payment\r\n    /// @param _amount Amount to be paid in wei\r\n    /// @param _paymentDelay Number of seconds the payment is to be delayed, if\r\n    ///  this value is below `timeLock` then the `timeLock` determines the delay\r\n    /// @return The Payment ID number for the new authorized payment\r\n    function authorizePayment(\r\n        address _recipient,\r\n        uint _amount,\r\n        uint _paymentDelay\r\n    ) returns(uint) {\r\n\r\n        // Fail if you arent on the `allowedSpenders` white list\r\n        if (!allowedSpenders[msg.sender]) throw;\r\n        uint idPayment = authorizedPayments.length;       // Unique Payment ID\r\n        authorizedPayments.length++;\r\n\r\n        // The following lines fill out the payment struct\r\n        Payment p = authorizedPayments[idPayment];\r\n        p.spender = msg.sender;\r\n\r\n        // Overflow protection\r\n        if (_paymentDelay > 10**18) throw;\r\n\r\n        // Determines the earliest the recipient can receive payment (Unix time)\r\n        p.earliestPayTime = _paymentDelay >= timeLock ?\r\n                                now + _paymentDelay :\r\n                                now + timeLock;\r\n        p.recipient = _recipient;\r\n        p.amount = _amount;\r\n        PaymentAuthorized(idPayment, p.recipient, p.amount);\r\n        return idPayment;\r\n    }\r\n\r\n    /// @notice only `allowedSpenders[]` The recipient of a payment calls this\r\n    ///  function to send themselves the ether after the `earliestPayTime` has\r\n    ///  expired\r\n    /// @param _idPayment The payment ID to be executed\r\n    function collectAuthorizedPayment(uint _idPayment) {\r\n\r\n        // Check that the `_idPayment` has been added to the payments struct\r\n        if (_idPayment >= authorizedPayments.length) return;\r\n\r\n        Payment p = authorizedPayments[_idPayment];\r\n\r\n        // Checking for reasons not to execute the payment\r\n        if (msg.sender != p.recipient) return;\r\n        if (now < p.earliestPayTime) return;\r\n        if (p.canceled) return;\r\n        if (p.paid) return;\r\n        if (this.balance < p.amount) return;\r\n\r\n        p.paid = true; // Set the payment to being paid\r\n        if (!p.recipient.send(p.amount)) {  // Make the payment\r\n            return;\r\n        }\r\n        PaymentExecuted(_idPayment, p.recipient, p.amount);\r\n     }\r\n\r\n/////////\r\n// SecurityGuard Interface\r\n/////////\r\n\r\n    /// @notice `onlySecurityGuard` Delays a payment for a set number of seconds\r\n    /// @param _idPayment ID of the payment to be delayed\r\n    /// @param _delay The number of seconds to delay the payment\r\n    function delayPayment(uint _idPayment, uint _delay) onlySecurityGuard {\r\n        if (_idPayment >= authorizedPayments.length) throw;\r\n\r\n        // Overflow test\r\n        if (_delay > 10**18) throw;\r\n\r\n        Payment p = authorizedPayments[_idPayment];\r\n\r\n        if ((p.securityGuardDelay + _delay > maxSecurityGuardDelay) ||\r\n            (p.paid) ||\r\n            (p.canceled))\r\n            throw;\r\n\r\n        p.securityGuardDelay += _delay;\r\n        p.earliestPayTime += _delay;\r\n    }\r\n\r\n////////\r\n// Owner Interface\r\n///////\r\n\r\n    /// @notice `onlyOwner` Cancel a payment all together\r\n    /// @param _idPayment ID of the payment to be canceled.\r\n    function cancelPayment(uint _idPayment) onlyContractOwner {\r\n        if (_idPayment >= authorizedPayments.length) throw;\r\n\r\n        Payment p = authorizedPayments[_idPayment];\r\n\r\n\r\n        if (p.canceled) throw;\r\n        if (p.paid) throw;\r\n\r\n        p.canceled = true;\r\n        PaymentCanceled(_idPayment);\r\n    }\r\n\r\n    /// @notice `onlyOwner` Adds a spender to the `allowedSpenders[]` white list\r\n    /// @param _spender The address of the contract being authorized/unauthorized\r\n    /// @param _authorize `true` if authorizing and `false` if unauthorizing\r\n    function authorizeSpender(address _spender, bool _authorize) onlyContractOwner {\r\n        allowedSpenders[_spender] = _authorize;\r\n        SpenderAuthorization(_spender, _authorize);\r\n    }\r\n\r\n    /// @notice `onlyOwner` Sets the address of `securityGuard`\r\n    /// @param _newSecurityGuard Address of the new security guard\r\n    function setSecurityGuard(address _newSecurityGuard) onlyContractOwner {\r\n        securityGuard = _newSecurityGuard;\r\n    }\r\n\r\n    /// @notice `onlyOwner` Changes `timeLock`; the new `timeLock` cannot be\r\n    ///  lower than `absoluteMinTimeLock`\r\n    /// @param _newTimeLock Sets the new minimum default `timeLock` in seconds;\r\n    ///  pending payments maintain their `earliestPayTime`\r\n    function setTimelock(uint _newTimeLock) onlyContractOwner {\r\n        if (_newTimeLock < absoluteMinTimeLock) throw;\r\n        timeLock = _newTimeLock;\r\n    }\r\n\r\n    /// @notice `onlyOwner` Changes the maximum number of seconds\r\n    /// `securityGuard` can delay a payment\r\n    /// @param _maxSecurityGuardDelay The new maximum delay in seconds that\r\n    ///  `securityGuard` can delay the payment's execution in total\r\n    function setMaxSecurityGuardDelay(uint _maxSecurityGuardDelay) onlyContractOwner {\r\n        maxSecurityGuardDelay = _maxSecurityGuardDelay;\r\n    }\r\n}\r\n\r\n\r\ncontract Asset {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed from, address indexed spender, uint256 value);\r\n    string public symbol;\r\n\r\n    function totalSupply() constant returns (uint256 supply);\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n}\r\n\r\ncontract BuyBackEmitter {\r\n    function emitError(uint errorCode);\r\n    function emitPricesUpdated(uint buyPrice, uint sellPrice);\r\n    function emitActiveChanged(bool isActive);\r\n}\r\n\r\n\r\ncontract BuyBack is Object {\r\n\r\n    uint constant ERROR_EXCHANGE_INVALID_PARAMETER = 6000;\r\n    uint constant ERROR_EXCHANGE_INVALID_INVOCATION = 6001;\r\n    uint constant ERROR_EXCHANGE_INVALID_FEE_PERCENT = 6002;\r\n    uint constant ERROR_EXCHANGE_INVALID_PRICE = 6003;\r\n    uint constant ERROR_EXCHANGE_MAINTENANCE_MODE = 6004;\r\n    uint constant ERROR_EXCHANGE_TOO_HIGH_PRICE = 6005;\r\n    uint constant ERROR_EXCHANGE_TOO_LOW_PRICE = 6006;\r\n    uint constant ERROR_EXCHANGE_INSUFFICIENT_BALANCE = 6007;\r\n    uint constant ERROR_EXCHANGE_INSUFFICIENT_ETHER_SUPPLY = 6008;\r\n    uint constant ERROR_EXCHANGE_PAYMENT_FAILED = 6009;\r\n    uint constant ERROR_EXCHANGE_TRANSFER_FAILED = 6010;\r\n    uint constant ERROR_EXCHANGE_FEE_TRANSFER_FAILED = 6011;\r\n    uint constant ERROR_EXCHANGE_DELAYEDPAYMENTS_ACCESS = 6012;\r\n\r\n    // Assigned ERC20 token.\r\n    Asset public asset;\r\n    DelayedPayments public delayedPayments;\r\n    //Switch for turn on and off the exchange operations\r\n    bool public isActive;\r\n    // Price in wei at which exchange buys tokens.\r\n    uint public buyPrice = 1;\r\n    // Price in wei at which exchange sells tokens.\r\n    uint public sellPrice = 2570735391000000; // 80% from ETH/USD=311.1950\r\n    uint public minAmount;\r\n    uint public maxAmount;\r\n    // User sold tokens and received wei.\r\n    event Sell(address indexed who, uint token, uint eth);\r\n    // User bought tokens and payed wei.\r\n    event Buy(address indexed who, uint token, uint eth);\r\n    event WithdrawTokens(address indexed recipient, uint amount);\r\n    event WithdrawEth(address indexed recipient, uint amount);\r\n    event PricesUpdated(address indexed self, uint buyPrice, uint sellPrice);\r\n    event ActiveChanged(address indexed self, bool isActive);\r\n    event Error(uint errorCode);\r\n\r\n    /**\r\n     * @dev On received ethers\r\n     * @param sender Ether sender\r\n     * @param amount Ether value\r\n     */\r\n    event ReceivedEther(address indexed sender, uint256 indexed amount);\r\n\r\n    // Should use interface of the emitter, but address of events history.\r\n    BuyBackEmitter public eventsHistory;\r\n\r\n    /**\r\n     * Emits Error event with specified error message.\r\n     *\r\n     * Should only be used if no state changes happened.\r\n     *\r\n     * @param error error from Errors library.\r\n     */\r\n    function _error(uint error) internal returns (uint) {\r\n        getEventsHistory().emitError(error);\r\n        return error;\r\n    }\r\n\r\n    function _emitPricesUpdated(uint buyPrice, uint sellPrice) internal {\r\n        getEventsHistory().emitPricesUpdated(buyPrice, sellPrice);\r\n    }\r\n\r\n    function _emitActiveChanged(bool isActive) internal {\r\n        getEventsHistory().emitActiveChanged(isActive);\r\n    }\r\n\r\n    /**\r\n     * Sets EventsHstory contract address.\r\n     *\r\n     * Can be set only once, and only by contract owner.\r\n     *\r\n     * @param _eventsHistory MultiEventsHistory contract address.\r\n     *\r\n     * @return success.\r\n     */\r\n    function setupEventsHistory(address _eventsHistory) onlyContractOwner returns (uint) {\r\n        if (address(eventsHistory) != 0x0) {\r\n            return _error(ERROR_EXCHANGE_INVALID_INVOCATION);\r\n        }\r\n\r\n        eventsHistory = BuyBackEmitter(_eventsHistory);\r\n        return OK;\r\n    }\r\n\r\n    /**\r\n     * Assigns ERC20 token for exchange.\r\n     *\r\n     * Can be set only once, and only by contract owner.\r\n     *\r\n     * @param _asset ERC20 token address.\r\n     *\r\n     * @return success.\r\n     */\r\n    function init(Asset _asset, DelayedPayments _delayedPayments) onlyContractOwner returns (uint errorCode) {\r\n        if (address(asset) != 0x0 || address(delayedPayments) != 0x0) {\r\n            return _error(ERROR_EXCHANGE_INVALID_INVOCATION);\r\n        }\r\n\r\n        asset = _asset;\r\n        delayedPayments = _delayedPayments;\r\n        isActive = true;\r\n        return OK;\r\n    }\r\n\r\n    function setActive(bool _active) onlyContractOwner returns (uint) {\r\n        if (isActive != _active) {\r\n            _emitActiveChanged(_active);\r\n        }\r\n\r\n        isActive = _active;\r\n        return OK;\r\n    }\r\n\r\n    /**\r\n     * Set exchange operation prices.\r\n     * Sell price cannot be less than buy price.\r\n     *\r\n     * Can be set only by contract owner.\r\n     *\r\n     * @param _buyPrice price in wei at which exchange buys tokens.\r\n     * @param _sellPrice price in wei at which exchange sells tokens.\r\n     *\r\n     * @return success.\r\n     */\r\n    function setPrices(uint _buyPrice, uint _sellPrice) onlyContractOwner returns (uint) {\r\n        if (_sellPrice < _buyPrice) {\r\n            return _error(ERROR_EXCHANGE_INVALID_PRICE);\r\n        }\r\n\r\n        buyPrice = _buyPrice;\r\n        sellPrice = _sellPrice;\r\n        _emitPricesUpdated(_buyPrice, _sellPrice);\r\n\r\n        return OK;\r\n    }\r\n\r\n    /**\r\n     * Returns assigned token address balance.\r\n     *\r\n     * @param _address address to get balance.\r\n     *\r\n     * @return token balance.\r\n     */\r\n    function _balanceOf(address _address) constant internal returns (uint) {\r\n        return asset.balanceOf(_address);\r\n    }\r\n\r\n    /**\r\n     * Sell tokens for ether at specified price. Tokens are taken from caller\r\n     * though an allowance logic.\r\n     * Amount should be less than or equal to current allowance value.\r\n     * Price should be less than or equal to current exchange buyPrice.\r\n     *\r\n     * @param _amount amount of tokens to sell.\r\n     * @param _price price in wei at which sell will happen.\r\n     *\r\n     * @return success.\r\n     */\r\n    function sell(uint _amount, uint _price) returns (uint) {\r\n        if (!isActive) {\r\n            return _error(ERROR_EXCHANGE_MAINTENANCE_MODE);\r\n        }\r\n\r\n        if (_price > buyPrice) {\r\n            return _error(ERROR_EXCHANGE_TOO_HIGH_PRICE);\r\n        }\r\n\r\n        if (_balanceOf(msg.sender) < _amount) {\r\n            return _error(ERROR_EXCHANGE_INSUFFICIENT_BALANCE);\r\n        }\r\n\r\n        uint total = _mul(_amount, _price);\r\n        if (this.balance < total) {\r\n            return _error(ERROR_EXCHANGE_INSUFFICIENT_ETHER_SUPPLY);\r\n        }\r\n\r\n        if (!asset.transferFrom(msg.sender, this, _amount)) {\r\n            return _error(ERROR_EXCHANGE_PAYMENT_FAILED);\r\n        }\r\n\r\n        if (!delayedPayments.send(total)) {\r\n            throw;\r\n        }\r\n        if (!delayedPayments.allowedSpenders(this)) {\r\n            throw;\r\n        }\r\n        delayedPayments.authorizePayment(msg.sender,total,1 hours); \r\n        Sell(msg.sender, _amount, total);\r\n\r\n        return OK;\r\n    }\r\n\r\n    /**\r\n     * Transfer specified amount of tokens from exchange to specified address.\r\n     *\r\n     * Can be called only by contract owner.\r\n     *\r\n     * @param _recipient address to transfer tokens to.\r\n     * @param _amount amount of tokens to transfer.\r\n     *\r\n     * @return success.\r\n     */\r\n    function withdrawTokens(address _recipient, uint _amount) onlyContractOwner returns (uint) {\r\n        if (_balanceOf(this) < _amount) {\r\n            return _error(ERROR_EXCHANGE_INSUFFICIENT_BALANCE);\r\n        }\r\n\r\n        if (!asset.transfer(_recipient, _amount)) {\r\n            return _error(ERROR_EXCHANGE_TRANSFER_FAILED);\r\n        }\r\n\r\n        WithdrawTokens(_recipient, _amount);\r\n\r\n        return OK;\r\n    }\r\n\r\n    /**\r\n     * Transfer all tokens from exchange to specified address.\r\n     *\r\n     * Can be called only by contract owner.\r\n     *\r\n     * @param _recipient address to transfer tokens to.\r\n     *\r\n     * @return success.\r\n     */\r\n    function withdrawAllTokens(address _recipient) onlyContractOwner returns (uint) {\r\n        return withdrawTokens(_recipient, _balanceOf(this));\r\n    }\r\n\r\n    /**\r\n     * Transfer specified amount of wei from exchange to specified address.\r\n     *\r\n     * Can be called only by contract owner.\r\n     *\r\n     * @param _recipient address to transfer wei to.\r\n     * @param _amount amount of wei to transfer.\r\n     *\r\n     * @return success.\r\n     */\r\n    function withdrawEth(address _recipient, uint _amount) onlyContractOwner returns (uint) {\r\n        if (this.balance < _amount) {\r\n            return _error(ERROR_EXCHANGE_INSUFFICIENT_ETHER_SUPPLY);\r\n        }\r\n\r\n        if (!_recipient.send(_amount)) {\r\n            return _error(ERROR_EXCHANGE_TRANSFER_FAILED);\r\n        }\r\n\r\n        WithdrawEth(_recipient, _amount);\r\n\r\n        return OK;\r\n    }\r\n\r\n    /**\r\n     * Transfer all wei from exchange to specified address.\r\n     *\r\n     * Can be called only by contract owner.\r\n     *\r\n     * @param _recipient address to transfer wei to.\r\n     *\r\n     * @return success.\r\n     */\r\n    function withdrawAllEth(address _recipient) onlyContractOwner() returns (uint) {\r\n        return withdrawEth(_recipient, this.balance);\r\n    }\r\n\r\n    /**\r\n     * Transfer all tokens and wei from exchange to specified address.\r\n     *\r\n     * Can be called only by contract owner.\r\n     *\r\n     * @param _recipient address to transfer tokens and wei to.\r\n     *\r\n     * @return success.\r\n     */\r\n    function withdrawAll(address _recipient) onlyContractOwner returns (uint) {\r\n        uint withdrawAllTokensResult = withdrawAllTokens(_recipient);\r\n        if (withdrawAllTokensResult != OK) {\r\n            return withdrawAllTokensResult;\r\n        }\r\n\r\n        uint withdrawAllEthResult = withdrawAllEth(_recipient);\r\n        if (withdrawAllEthResult != OK) {\r\n            return withdrawAllEthResult;\r\n        }\r\n\r\n        return OK;\r\n    }\r\n\r\n    function emitError(uint errorCode) {\r\n        Error(errorCode);\r\n    }\r\n\r\n    function emitPricesUpdated(uint buyPrice, uint sellPrice) {\r\n        PricesUpdated(msg.sender, buyPrice, sellPrice);\r\n    }\r\n\r\n    function emitActiveChanged(bool isActive) {\r\n        ActiveChanged(msg.sender, isActive);\r\n    }\r\n\r\n    function getEventsHistory() constant returns (BuyBackEmitter) {\r\n        return address(eventsHistory) != 0x0 ? eventsHistory : BuyBackEmitter(this);\r\n    }\r\n    /**\r\n     * Overflow-safe multiplication.\r\n     *\r\n     * Throws in case of value overflow.\r\n     *\r\n     * @param _a first operand.\r\n     * @param _b second operand.\r\n     *\r\n     * @return multiplication result.\r\n     */\r\n    function _mul(uint _a, uint _b) internal constant returns (uint) {\r\n        uint result = _a * _b;\r\n        if (_a != 0 && result / _a != _b) {\r\n            throw;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Accept all ether to maintain exchange supply.\r\n     */\r\n    function() payable {\r\n        if (msg.value != 0) {\r\n            ReceivedEther(msg.sender, msg.value);\r\n        } else {\r\n            throw;\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_eventsHistory\",\"type\":\"address\"}],\"name\":\"setupEventsHistory\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_buyPrice\",\"type\":\"uint256\"},{\"name\":\"_sellPrice\",\"type\":\"uint256\"}],\"name\":\"setPrices\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"asset\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimContractOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeContractOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingContractOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"isActive\",\"type\":\"bool\"}],\"name\":\"emitActiveChanged\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"buyPrice\",\"type\":\"uint256\"},{\"name\":\"sellPrice\",\"type\":\"uint256\"}],\"name\":\"emitPricesUpdated\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"withdrawAllTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_active\",\"type\":\"bool\"}],\"name\":\"setActive\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"withdrawAllEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"address[]\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdrawnTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"delayedPayments\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"errorCode\",\"type\":\"uint256\"}],\"name\":\"emitError\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"eventsHistory\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_asset\",\"type\":\"address\"},{\"name\":\"_delayedPayments\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[{\"name\":\"errorCode\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"withdrawAll\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEventsHistory\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"eth\",\"type\":\"uint256\"}],\"name\":\"Sell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"eth\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawEth\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"self\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"buyPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sellPrice\",\"type\":\"uint256\"}],\"name\":\"PricesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"self\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"isActive\",\"type\":\"bool\"}],\"name\":\"ActiveChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"errorCode\",\"type\":\"uint256\"}],\"name\":\"Error\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReceivedEther\",\"type\":\"event\"}]","ContractName":"BuyBack","CompilerVersion":"v0.4.16+commit.d7661dd9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://d14f2b738b451add72300931539549a9950097f01a985df477e5acf1b8ea0ca6"}]}