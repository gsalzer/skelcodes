{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.15;\r\n\r\ncontract Addresses {\r\n\r\n    //2%\r\n    address public bounty;\r\n    \r\n    //5%\r\n    address public successFee;\r\n\r\n    //93%\r\n    address public addr1;\r\n\r\n    //93%\r\n    address public addr2;\r\n\r\n    //93%\r\n    address public addr3;\r\n\r\n    //93%\r\n    address public addr4;\r\n\r\n\r\n  function Addresses() {\r\n\r\n      //2%       //ORIGINAL\r\n      bounty = 0x0064952457905eBFB9c0292200A74B1d7414F081;\r\n                 //TEST\r\n   //   bounty = 0x1626079328312cdb1e731a934a547c6d81b3ee2c;\r\n      \r\n      //5%       //ORIGINAL\r\n      successFee = 0xdA39e0Ce2adf93129D04F53176c7Bfaaae8B051a;\r\n                 //TEST\r\n    //  successFee = 0xf280dacf47f33f442cf5fa9d20abaef4b6e9ca12;\r\n\r\n    //93%       //ORIGINAL\r\n      addr1 = 0x300b848558DC06E32658fFB8D59C859D0812CA6C;\r\n\r\n      //93%       //ORIGINAL\r\n      addr2 = 0x4388AD192b0DaaDBBaa86Be0AE7499b8D44C5f75;\r\n\r\n      //93%       //ORIGINAL\r\n      addr3 = 0x40C9E2D0807289b4c24B0e2c34277BDd7FaCfd87;\r\n\r\n      //93%       //ORIGINAL\r\n      addr4 = 0x4E3B219684b9570D0d81Cc13E5c0aAcafe2323B1;\r\n      \r\n\r\n     /* //93%       //TEST\r\n      addr1 = 0x1626079328312cdb1e731a934a547c6d81b3ee2c;\r\n\r\n      //93%       //TEST\r\n      addr2 = 0x1626079328312cdb1e731a934a547c6d81b3ee2c;\r\n\r\n      //93%       //TEST\r\n      addr3 = 0x1626079328312cdb1e731a934a547c6d81b3ee2c;\r\n\r\n      //93%       //TEST\r\n      addr4 = 0x1626079328312cdb1e731a934a547c6d81b3ee2c;*/\r\n  }\r\n\r\n}\r\n\r\nlibrary SafeMath {\r\n    \r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n \r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n \r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n \r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function mod(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a % b;\r\n    return c;\r\n  }\r\n  \r\n}\r\n\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) constant returns (uint256);\r\n  function transfer(address to, uint256 value) returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) returns (bool);\r\n  function approve(address spender, uint256 value) returns (bool);\r\n  function approve(address _owner, address _spender, uint256 _value) returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract Migrations {\r\n  address public owner;\r\n  uint public last_completed_migration;\r\n\r\n  modifier restricted() {\r\n    if (msg.sender == owner) _;\r\n  }\r\n\r\n  function Migrations() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  function setCompleted(uint completed) restricted {\r\n    last_completed_migration = completed;\r\n  }\r\n\r\n  function upgrade(address new_address) restricted {\r\n    Migrations upgraded = Migrations(new_address);\r\n    upgraded.setCompleted(last_completed_migration);\r\n  }\r\n}\r\n\r\ncontract Ownable {\r\n    \r\n  address public owner;\r\n \r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    require(newOwner != address(0));      \r\n    owner = newOwner;\r\n  }\r\n \r\n}\r\n\r\ncontract BasicToken is ERC20Basic {\r\n    \r\n  using SafeMath for uint256;\r\n \r\n  mapping(address => uint256) balances;\r\n\r\n  //18.10.2017 23:59 UTC\r\n  uint256 ico_finish = 1508284740;\r\n\r\n  modifier isFreeze() {\r\n    if(now < ico_finish) {\r\n      revert();\r\n    }\r\n    _;\r\n  }\r\n\r\n  function transfer(address _to, uint256 _value) isFreeze returns (bool) {\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n \r\n  function balanceOf(address _owner) constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n \r\n}\r\n\r\ncontract StandardToken is ERC20, BasicToken {\r\n \r\n  mapping (address => mapping (address => uint256)) allowed;\r\n\r\n  //14.10.2017 23:59 UTC\r\n  uint256 ico_finish = 1508025540;\r\n\r\n  modifier isFreeze() {\r\n    if(now < ico_finish) {\r\n      revert();\r\n    }\r\n    _;\r\n  }\r\n \r\n  function transferFrom(address _from, address _to, uint256 _value) isFreeze returns (bool) {\r\n    var _allowance = allowed[_from][msg.sender];\r\n \r\n    balances[_to] = balances[_to].add(_value);\r\n    balances[_from] = balances[_from].sub(_value);\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function approve(address _spender, uint256 _value) returns (bool) {\r\n \r\n    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n \r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  function approve(address _owner, address _spender, uint256 _value) returns (bool) {\r\n \r\n    allowed[_owner][_spender] = _value;\r\n    Approval(_owner, _spender, _value);\r\n    return true;\r\n  }\r\n \r\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n \r\n}\r\n\r\ncontract MintableToken is StandardToken, Ownable {\r\n\r\n  using SafeMath for uint256;\r\n\r\n  bool mintingFinished = false;\r\n\r\n  uint256 mintedTokens = 0;\r\n\r\n  event Mint(address indexed to, uint256 amount);\r\n\r\n  event MintFinished();\r\n\r\n  event ShowInfo(uint256 _info, string _message);\r\n\r\n  function setTotalSupply(uint256 _amount) public onlyOwner returns(uint256) {\r\n    totalSupply = _amount;\r\n    return totalSupply;\r\n  }\r\n\r\n  function getTotalTokenCount() public constant returns(uint256) {\r\n    return totalSupply;\r\n  }\r\n\r\n  modifier canMint() {\r\n    require(!mintingFinished);\r\n    _;\r\n  }\r\n\r\n  function finishMinting() public onlyOwner {\r\n    mintingFinished = true;\r\n  }\r\n  \r\n  function mint(address _address, uint256 _tokens) canMint onlyOwner public {\r\n\r\n    require(mintedTokens < totalSupply);\r\n\r\n    Mint(_address, _tokens);\r\n\r\n    balances[_address] = balances[_address].add(_tokens);\r\n\r\n    mintedTokens = mintedTokens.add(_tokens);\r\n  }\r\n\r\n  function burnTokens(address _address) onlyOwner public {\r\n    balances[_address] = 0;\r\n    totalSupply = 0;\r\n    mintedTokens = 0;\r\n  }\r\n\r\n  function burnFinish() onlyOwner public {\r\n    totalSupply = mintedTokens;\r\n  }\r\n\r\n}\r\n\r\ncontract SingleTokenCoin is MintableToken {\r\n    \r\n    string public constant name = \"Start mining\";\r\n    \r\n    string public constant symbol = \"STM\";\r\n    \r\n    uint32 public constant decimals = 2;\r\n    \r\n}\r\n\r\ncontract WrapperOraclize {\r\n    function update(string datasource, string arg) payable;\r\n    function update(uint timestamp, string datasource, string arg) payable;\r\n    function getWrapperBalance() constant returns(uint256);\r\n    function getWrapperData() constant returns(bytes32);\r\n    function getPrice(string datasource) constant returns(uint256);\r\n    function() external payable;\r\n}\r\n\r\ncontract Crowdsale is Ownable {\r\n\r\n  string public ETHUSD;\r\n\r\n  event ShowPrice(string price);\r\n\r\n    using SafeMath for uint256;\r\n\r\n    SingleTokenCoin public token = new SingleTokenCoin();\r\n\r\n    Addresses private addresses = new Addresses();\r\n\r\n    WrapperOraclize private wrapper = WrapperOraclize(0xfC484c66daE464CC6055d7a4782Ec8761dc9842F);\r\n\r\n    uint256 private ico_start;\r\n    uint256 private ico_finish;\r\n\r\n    uint256 private rate;\r\n\r\n    uint256 private decimals;\r\n\r\n    uint256 private tax;\r\n\r\n    //Time-based Bonus Program\r\n    uint256 private firstBonusPhase;\r\n    uint256 private firstExtraBonus;\r\n\r\n    uint256 private secondBonusPhase;\r\n    uint256 private secondExtraBonus;\r\n\r\n    uint256 private thirdBonusPhase;\r\n    uint256 private thirdExtraBonus;\r\n\r\n    uint256 private fourBonusPhase;\r\n    uint256 private fourExtraBonus;\r\n\r\n    //Withdrow Phases\r\n    bool private firstWithdrowPhase;\r\n    bool private secondWithdrowPhase;\r\n    bool private thirdWithdrowPhase;\r\n    bool private fourWithdrowPhase;\r\n\r\n    uint256 private firstWithdrowAmount;\r\n    uint256 private secondWithdrowAmount;\r\n    uint256 private thirdWithdrowAmount;\r\n    uint256 private fourWithdrowAmount;\r\n\r\n    uint256 private totalETH;\r\n\r\n    uint256 private totalAmount;\r\n\r\n    bool private initialize = false;\r\n    \r\n    bool public mintingFinished = false;\r\n\r\n    //Storage for ICO Buyers ETH\r\n    mapping(address => uint256) private ico_buyers_eth;\r\n\r\n    //Storage for ICO Buyers Token\r\n    mapping(address => uint256) private ico_buyers_token;\r\n\r\n    address[] private investors;\r\n\r\n    mapping(address => bytes32) private privilegedWallets;\r\n    mapping(address => uint256) private manualAddresses;\r\n\r\n    address[] private manualAddressesCount;\r\n\r\n    address[] private privilegedWalletsCount;\r\n\r\n    bytes32 private g = \"granted\";\r\n\r\n    bytes32 private r = \"revorked\";\r\n\r\n    uint256 private soldTokens;\r\n    uint256 private mincup;\r\n\r\n    uint256 private minPrice;\r\n\r\n    event ShowInfo(uint256 _info);\r\n    event ShowInfoStr(string _info);\r\n    event ShowInfoBool(bool _info);\r\n\r\n    function Crowdsale() {\r\n\r\n      //set calculate rate from USD\r\n      rate = 3546099290780141; //0.0003 ETH //temp\r\n\r\n      decimals = 35460992907801; // 0.0000003 ETH // 2 decimals\r\n\r\n      tax = 36000000000000000; //tax && minimum price ~10$\r\n\r\n      //minPrice = decimals + tax; // ~10$\r\n\r\n      //18.09.2017 15:00 UTC (1505746800)\r\n      ico_start = 1505746800;\r\n\r\n      //17.10.2017 23:59 UTC (1508284740)\r\n      ico_finish = 1508284740;\r\n\r\n      totalAmount = 1020000000;\r\n\r\n      // 500 000 STM with 2 decimals\r\n      mincup = 50000000;\r\n      \r\n      mintingFinished = false;\r\n\r\n      setTotalSupply();\r\n\r\n      //Time-Based Bonus Phase\r\n      firstBonusPhase = ico_start.add(24 hours);\r\n      firstExtraBonus = 25;\r\n\r\n      secondBonusPhase = ico_start.add(168 hours);\r\n      secondExtraBonus = 15;\r\n\r\n      thirdBonusPhase = ico_start.add(336 hours);\r\n      thirdExtraBonus = 10;\r\n\r\n      fourBonusPhase = ico_start.add(480 hours);\r\n      fourExtraBonus = 5;\r\n\r\n      //Withdrow Phases\r\n      firstWithdrowPhase = false;\r\n      secondWithdrowPhase = false;\r\n      thirdWithdrowPhase = false;\r\n      fourWithdrowPhase = false;\r\n\r\n      firstWithdrowAmount = 50000000;\r\n      secondWithdrowAmount = 200000000;\r\n      thirdWithdrowAmount = 500000000;\r\n      fourWithdrowAmount = 1020000000;\r\n\r\n      totalETH = 0;\r\n\r\n      soldTokens = 0;\r\n\r\n      privilegedWalletsCount.push(msg.sender);\r\n      privilegedWallets[msg.sender] = g;\r\n\r\n    }\r\n\r\n      modifier canMint() {\r\n        require(!mintingFinished);\r\n        _;\r\n      }\r\n\r\n    function() external payable {\r\n      mint();\r\n    }\r\n\r\n  function bytesToUInt(bytes32 v) constant returns (uint ret) {\r\n        if (v == 0x0) {\r\n            revert();\r\n        }\r\n\r\n        uint digit;\r\n\r\n        for (uint i = 0; i < 32; i++) {\r\n            digit = uint((uint(v) / (2 ** (8 * (31 - i)))) & 0xff);\r\n            if (digit == 0 || digit == 46) {\r\n                break;\r\n            }\r\n            else if (digit < 48 || digit > 57) {\r\n                revert();\r\n            }\r\n            ret *= 10;\r\n            ret += (digit - 48);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n  function calculateRate() public payable returns(uint256) {\r\n    bytes32 result = getWrapperData();\r\n    uint256 usd = bytesToUInt(result);\r\n\r\n    uint256 price = 1 ether / usd; //price for 1 STM\r\n\r\n    return price;\r\n  }\r\n\r\n    function calculateWithdrow() private {\r\n      if (!firstWithdrowPhase && soldTokens >= firstWithdrowAmount && soldTokens < secondWithdrowAmount) {\r\n        sendToOwners(this.balance);\r\n      } else {\r\n        if (!secondWithdrowPhase && soldTokens >= secondWithdrowAmount && soldTokens < thirdWithdrowAmount) {\r\n          sendToOwners(this.balance);\r\n        } else {\r\n          if (!thirdWithdrowPhase && soldTokens >= thirdWithdrowAmount && soldTokens < fourWithdrowAmount) {\r\n            sendToOwners(this.balance);\r\n          } else {\r\n            if (!fourWithdrowPhase && soldTokens >= fourWithdrowAmount) {\r\n              sendToOwners(this.balance);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    modifier isInitialize() {\r\n      require(!initialize);\r\n      _;\r\n    }\r\n\r\n    function setTotalSupply() private isInitialize onlyOwner returns(uint256) {\r\n      initialize = true;\r\n      return token.setTotalSupply(totalAmount);\r\n    }\r\n\r\n    function sendToAddress(address _address, uint256 _tokens) canMint public {\r\n\r\n      if (grantedWallets(msg.sender) == false) {\r\n        revert();      \r\n      }\r\n\r\n      ShowInfo(_tokens);\r\n\r\n      uint256 currentTokens = _tokens;\r\n\r\n      uint256 timeBonus = calculateBonusForHours(currentTokens);\r\n\r\n      uint256 allTokens = currentTokens.add(timeBonus);   \r\n\r\n      token.approve(_address, this, allTokens);      \r\n\r\n      saveInfoAboutInvestors(_address, 0, allTokens, true);         \r\n\r\n      token.mint(_address, allTokens);\r\n\r\n      soldTokens = soldTokens + allTokens;\r\n      calculateWithdrow();\r\n    }\r\n\r\n    modifier isRefund() {\r\n      if (msg.value < tax) {\r\n        refund(msg.value);\r\n        revert();\r\n      }\r\n      _;\r\n    }\r\n\r\n    function grantedWallets(address _address) private returns(bool) {\r\n      if (privilegedWallets[_address] == g) {\r\n        return true;\r\n      }\r\n      return false;\r\n    }\r\n\r\n    modifier isICOFinished() {\r\n      if (now > ico_finish) {\r\n        finishMinting();\r\n        refund(msg.value);\r\n        revert();\r\n      }\r\n      _;\r\n    }\r\n\r\n    function getTokens() public constant returns(uint256) {\r\n      token.getTotalTokenCount();\r\n    }\r\n\r\n    function setPrivelegedWallet(address _address) public onlyOwner returns(bool) {\r\n      if (privilegedWalletsCount.length == 2) {\r\n        revert();\r\n      }\r\n\r\n      if (privilegedWallets[_address] != g && privilegedWallets[_address] != r) {\r\n        privilegedWalletsCount.push(_address);\r\n      }\r\n\r\n      privilegedWallets[_address] = g;\r\n\r\n      return true;\r\n    }\r\n\r\n    function setTransferOwnership(address _address) public onlyOwner {\r\n\r\n      removePrivelegedWallet(msg.sender);\r\n      setPrivelegedWallet(_address);\r\n\r\n      transferOwnership(_address);\r\n    }\r\n\r\n    function removePrivelegedWallet(address _address) public onlyOwner {\r\n      if (privilegedWallets[_address] == g) {\r\n        privilegedWallets[_address] = r;\r\n        delete privilegedWalletsCount[0];\r\n      } else {\r\n        revert();\r\n      }\r\n    }\r\n\r\n    //only for demonstrate Test Version\r\n    function setICODate(uint256 _time) public onlyOwner {\r\n      ico_start = _time;\r\n      ShowInfo(_time);\r\n    }\r\n\r\n    function getICODate() public constant returns(uint256) {\r\n      return ico_start;\r\n    }\r\n\r\n    function mint() public isRefund canMint isICOFinished payable {\r\n\r\n      rate = calculateRate();\r\n\r\n      decimals = rate / 100; //price for 0.01 STM\r\n\r\n      uint256 remainder = msg.value.mod(decimals);\r\n\r\n      uint256 eth = msg.value.sub(remainder);\r\n\r\n      if (remainder != 0) {\r\n        refund(remainder);\r\n      }\r\n\r\n      totalETH = totalETH + eth;\r\n\r\n      uint currentRate = rate / 100; //2 decimals\r\n\r\n      uint256 tokens = eth.div(currentRate);\r\n      uint256 timeBonus = calculateBonusForHours(tokens);\r\n\r\n      uint256 allTokens = tokens.add(timeBonus) + 100; // +100 - oraclize Tax\r\n\r\n      saveInfoAboutInvestors(msg.sender, eth, allTokens, false);\r\n\r\n      token.mint(msg.sender, allTokens);\r\n\r\n      soldTokens = soldTokens + allTokens;\r\n      calculateWithdrow();\r\n    }\r\n\r\n    function saveInfoAboutInvestors(address _address, uint256 _amount, uint256 _tokens, bool _isManual) private {\r\n\r\n      if (!_isManual) {\r\n        if (ico_buyers_token[_address] == 0) {\r\n          investors.push(_address);\r\n        }\r\n\r\n        // Store ETH of Investor\r\n        ico_buyers_eth[_address] = ico_buyers_eth[_address].add(_amount);\r\n\r\n        // Store Token of Investor\r\n        ico_buyers_token[_address] = ico_buyers_token[_address].add(_tokens);\r\n      \r\n      } else {\r\n        if(manualAddresses[_address] == 0) {\r\n          manualAddressesCount.push(_address);\r\n        }\r\n\r\n        manualAddresses[_address] = manualAddresses[_address].add(_tokens);\r\n      }\r\n    }\r\n\r\n    function getManualByAddress(address _address) public constant returns(uint256) {\r\n      return manualAddresses[_address];\r\n    }\r\n\r\n    function getManualInvestorsCount() public constant returns(uint256) {\r\n      return manualAddressesCount.length;\r\n    }\r\n\r\n    function getManualAddress(uint _index) public constant returns(address) {\r\n      return manualAddressesCount[_index];\r\n    }\r\n\r\n    function finishMinting() public onlyOwner {\r\n      if(mintingFinished) {\r\n        revert();\r\n      }\r\n\r\n      token.finishMinting();\r\n\r\n\r\n      ShowInfoBool(mintingFinished);\r\n      mintingFinished = true;\r\n      ShowInfoBool(mintingFinished);\r\n      \r\n      if (soldTokens < mincup) {\r\n        if(investors.length != 0) {\r\n          for (uint256 i=0; i < investors.length; i++) {\r\n            address addr = investors[i];  \r\n            token.burnTokens(addr);\r\n          }\r\n        }\r\n        \r\n        if(manualAddressesCount.length != 0) {\r\n          for (uint256 j=0; j < manualAddressesCount.length; j++) {\r\n            address manualAddr = manualAddressesCount[j];\r\n            token.burnTokens(manualAddr);\r\n          }\r\n        }\r\n      }\r\n\r\n      token.burnFinish();\r\n    }\r\n\r\n    function getFinishStatus() public constant returns(bool) {\r\n      return mintingFinished;\r\n    }\r\n\r\n    function manualRefund() public {\r\n      if (mintingFinished) {\r\n        if(ico_buyers_eth[msg.sender] != 0) {\r\n          uint256 amount = ico_buyers_eth[msg.sender];\r\n          msg.sender.transfer(amount);\r\n          ico_buyers_eth[msg.sender] = 0;\r\n        } else {\r\n          revert();\r\n        }\r\n      } else {\r\n        revert();\r\n      }\r\n      \r\n    }\r\n\r\n    function refund(uint256 _amount) private {\r\n      msg.sender.transfer(_amount);\r\n    }\r\n\r\n    function refund(address _address, uint256 _amount) private {\r\n      _address.transfer(_amount);\r\n    }\r\n\r\n    function getTokensManual(address _address) public constant returns(uint256) {\r\n      return manualAddresses[_address];\r\n    }\r\n\r\n    function calculateBonusForHours(uint256 _tokens) private returns(uint256) {\r\n\r\n      //Calculate for first bonus program\r\n      if (now >= ico_start && now <= firstBonusPhase ) {\r\n        return _tokens.mul(firstExtraBonus).div(100);\r\n      }\r\n\r\n      //Calculate for second bonus program\r\n      if (now > firstBonusPhase && now <= secondBonusPhase ) {\r\n        return _tokens.mul(secondExtraBonus).div(100);\r\n      }\r\n\r\n      //Calculate for third bonus program\r\n      if (now > secondBonusPhase && now <= thirdBonusPhase ) {\r\n        return _tokens.mul(thirdExtraBonus).div(100);\r\n      }\r\n\r\n      //Calculate for four bonus program\r\n      if (now > thirdBonusPhase && now <= fourBonusPhase ) {\r\n        return _tokens.mul(fourExtraBonus).div(100);\r\n      }\r\n\r\n      return 0;\r\n    }\r\n\r\n    function sendToOwners(uint256 _amount) private {\r\n      uint256 twoPercent = _amount.mul(2).div(100);\r\n      uint256 fivePercent = _amount.mul(5).div(100);\r\n      uint256 nineThreePercent = _amount.mul(93).div(100);\r\n\r\n// ----------ADDRESSES FOR PRODUCTION-------------\r\n\r\n      //NineThree Percent\r\n      addresses.addr1().transfer(nineThreePercent);\r\n      addresses.addr2().transfer(nineThreePercent);\r\n      addresses.addr3().transfer(nineThreePercent);\r\n      addresses.addr4().transfer(nineThreePercent);\r\n\r\n      if (!firstWithdrowPhase) {\r\n        addresses.addr1().transfer(nineThreePercent);\r\n        firstWithdrowPhase = true;\r\n      } else {\r\n        if (!secondWithdrowPhase) {\r\n          addresses.addr2().transfer(nineThreePercent);   \r\n          secondWithdrowPhase = true;       \r\n        } else {\r\n          if (!thirdWithdrowPhase) {\r\n            addresses.addr3().transfer(nineThreePercent);\r\n            thirdWithdrowPhase = true;                \r\n          } else {\r\n            if (!fourWithdrowPhase) {\r\n              addresses.addr4().transfer(nineThreePercent);\r\n              fourWithdrowPhase = true;                      \r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n\r\n      //Five Percent\r\n      addresses.successFee().transfer(fivePercent);\r\n      \r\n      //Two Percent\r\n      addresses.bounty().transfer(twoPercent);\r\n      \r\n    }\r\n\r\n    function getBalanceContract() public constant returns(uint256) {\r\n      return this.balance;\r\n    }\r\n\r\n    function getSoldToken() public constant returns(uint256) {\r\n      return soldTokens;\r\n    }\r\n\r\n    function getInvestorsTokens(address _address) public constant returns(uint256) {\r\n      return ico_buyers_token[_address];\r\n    }\r\n\r\n    function getInvestorsETH(address _address) public constant returns(uint256) {\r\n      return ico_buyers_eth[_address];\r\n    }\r\n\r\n    function getInvestors() public constant returns(uint256) {\r\n      return investors.length;\r\n    }\r\n\r\n    function getInvestorByValue(address _address) public constant returns(uint256) {\r\n      return ico_buyers_eth[_address];\r\n    }\r\n\r\n    //only for test version\r\n    function transfer(address _from, address _to, uint256 _amount) public returns(bool) {\r\n      return token.transferFrom(_from, _to, _amount);\r\n    }\r\n\r\n    function getInvestorByIndex(uint256 _index) public constant returns(address) {\r\n      return investors[_index];\r\n    }\r\n\r\n    function getLeftToken() public constant returns(uint256) {\r\n      if(token.totalSupply() != 0) {\r\n        return token.totalSupply() - soldTokens;\r\n      } else {\r\n        return soldTokens;\r\n      }\r\n    }\r\n\r\n    function getTotalToken() public constant returns(uint256) {\r\n      return token.totalSupply();\r\n    }\r\n\r\n    function getTotalETH() public constant returns(uint256) {\r\n      return totalETH;\r\n    }\r\n\r\n    function getCurrentPrice() public constant returns(uint256) {\r\n      \r\n      uint256 secondDiscount = calculateBonusForHours(rate);\r\n\r\n      uint256 investorDiscount = rate.sub(secondDiscount);\r\n\r\n      return investorDiscount * 10; //minimum 10$ //~10STM\r\n    }\r\n\r\n    function getContractAddress() public constant returns(address) {\r\n      return this;\r\n    }\r\n\r\n    function getOwner() public constant returns(address) {\r\n      return owner;\r\n    }\r\n\r\n    function sendOracleData() public payable {\r\n        if (msg.value != 0) {\r\n            wrapper.transfer(msg.value);\r\n        }\r\n      \r\n      wrapper.update(\"URL\", \"json(https://api.kraken.com/0/public/Ticker?pair=ETHUSD).result.XETHZUSD.c.0\");\r\n    }\r\n\r\n    function getQueryPrice(string datasource) constant returns(uint256) {\r\n      return wrapper.getPrice(datasource);\r\n    }\r\n\r\n    function checkWrapperBalance() public constant returns(uint256) {\r\n      return wrapper.getWrapperBalance();\r\n    }\r\n\r\n    function getWrapperData() constant returns(bytes32) {\r\n      return wrapper.getWrapperData();\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"mintingFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getInvestorsETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"mint\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getManualByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"manualRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getManualAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"removePrivelegedWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"setICODate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getContractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWrapperData\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"sendToAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLeftToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getTokensManual\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBalanceContract\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETHUSD\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishMinting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"v\",\"type\":\"bytes32\"}],\"name\":\"bytesToUInt\",\"outputs\":[{\"name\":\"ret\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFinishStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getICODate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"calculateRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sendOracleData\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"datasource\",\"type\":\"string\"}],\"name\":\"getQueryPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getInvestorByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInvestors\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getInvestorByValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getManualInvestorsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setTransferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setPrivelegedWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkWrapperBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getInvestorsTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSoldToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"price\",\"type\":\"string\"}],\"name\":\"ShowPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_info\",\"type\":\"uint256\"}],\"name\":\"ShowInfo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_info\",\"type\":\"string\"}],\"name\":\"ShowInfoStr\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_info\",\"type\":\"bool\"}],\"name\":\"ShowInfoBool\",\"type\":\"event\"}]","ContractName":"Crowdsale","CompilerVersion":"v0.4.16+commit.d7661dd9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://fd36cb305039d0d8522160adba88be79e4d2680b6d19cac14d421f7323e74429"}]}