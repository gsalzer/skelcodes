{"status":"1","message":"OK","result":[{"SourceCode":"//--------------------------------------------------------------//\r\n//---------------------BLOCKLANCER TOKEN -----------------------//\r\n//--------------------------------------------------------------//\r\n\r\npragma solidity ^0.4.8;\r\n\r\n/// Migration Agent\r\n/// allows us to migrate to a new contract should it be needed\r\n/// makes blocklancer future proof\r\ncontract MigrationAgent {\r\n    function migrateFrom(address _from, uint256 _value);\r\n}\r\n\r\ncontract ERC20Interface {\r\n     // Get the total token supply\r\n     function totalSupply() constant returns (uint256 totalSupply);\r\n  \r\n     // Get the account balance of another account with address _owner\r\n     function balanceOf(address _owner) constant returns (uint256 balance);\r\n  \r\n     // Send _value amount of tokens to address _to\r\n     function transfer(address _to, uint256 _value) returns (bool success);\r\n  \r\n     // Send _value amount of tokens from address _from to address _to\r\n     function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n  \r\n     // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\r\n     // If this function is called again it overwrites the current allowance with _value.\r\n     // this function is required for some DEX functionality\r\n     function approve(address _spender, uint256 _value) returns (bool success);\r\n  \r\n     // Returns the amount which _spender is still allowed to withdraw from _owner\r\n     function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n  \r\n     // Triggered when tokens are transferred.\r\n     event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  \r\n     // Triggered whenever approve(address _spender, uint256 _value) is called.\r\n     event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n/// Blocklancer Token (LNC) - crowdfunding code for Blocklancer Project\r\ncontract BlocklancerToken is ERC20Interface {\r\n    string public constant name = \"Lancer Token\";\r\n    string public constant symbol = \"LNC\";\r\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\r\n\r\n    // The funding cap in weis.\r\n    uint256 public constant tokenCreationCap = 1000000000* 10**18;\r\n    uint256 public constant tokenCreationMin = 150000000* 10**18;\r\n    \r\n    mapping(address => mapping (address => uint256)) allowed;\r\n\r\n    uint public fundingStart;\r\n    uint public fundingEnd;\r\n\r\n    // The flag indicates if the LNC contract is in Funding state.\r\n    bool public funding = true;\r\n\r\n    // Receives ETH and its own LNC endowment.\r\n    address public master;\r\n\r\n    // The current total token supply.\r\n    uint256 totalTokens;\r\n    \r\n    //needed to calculate the price after the power day\r\n    //the price increases by 1 % for every 10 million LNC sold after power day\r\n    uint256 soldAfterPowerHour;\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => uint) lastTransferred;\r\n    \r\n    //needed to refund everyone should the ICO fail\r\n    // needed because the price per LNC isn't linear\r\n    mapping (address => uint256) balancesEther;\r\n\r\n    //address of the contract that manages the migration\r\n    //can only be changed by the creator\r\n    address public migrationAgent;\r\n    \r\n    //total amount of token migrated\r\n    //allows everyone to see the progress of the migration\r\n    uint256 public totalMigrated;\r\n\r\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\r\n    event Refund(address indexed _from, uint256 _value);\r\n    \r\n    //total amount of participants in the ICO\r\n    uint totalParticipants;\r\n\r\n    function BlocklancerToken() {\r\n        master = msg.sender;\r\n        fundingStart = 1501977600;\r\n        //change first number!\r\n        fundingEnd = fundingStart + 31 * 1 days;//now + 1000 * 1 minutes;\r\n    }\r\n    \r\n    //returns the total amount of participants in the ICO\r\n    function getAmountofTotalParticipants() constant returns (uint){\r\n        return totalParticipants;\r\n    }\r\n    \r\n    //set\r\n    function getAmountSoldAfterPowerDay() constant external returns(uint256){\r\n        return soldAfterPowerHour;\r\n    }\r\n\r\n    /// allows to transfer token to another address\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        // Don't allow in funding state\r\n        if(funding) throw;\r\n\r\n        var senderBalance = balances[msg.sender];\r\n        //only allow if the balance of the sender is more than he want's to send\r\n        if (senderBalance >= _value && _value > 0) {\r\n            //reduce the sender balance by the amount he sends\r\n            senderBalance -= _value;\r\n            balances[msg.sender] = senderBalance;\r\n            \r\n            //increase the balance of the receiver by the amount we reduced the balance of the sender\r\n            balances[_to] += _value;\r\n            \r\n            //saves the last time someone sent LNc from this address\r\n            //is needed for our Token Holder Tribunal\r\n            //this ensures that everyone can only vote one time\r\n            //otherwise it would be possible to send the LNC around and everyone votes again and again\r\n            lastTransferred[msg.sender]=block.timestamp;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        }\r\n        //transfer failed\r\n        return false;\r\n    }\r\n\r\n    //returns the total amount of LNC in circulation\r\n    //get displayed on the website whilst the crowd funding\r\n    function totalSupply() constant returns (uint256 totalSupply) {\r\n        return totalTokens;\r\n    }\r\n    \r\n    //retruns the balance of the owner address\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n    \r\n    //returns the amount anyone pledged into this contract\r\n    function EtherBalanceOf(address _owner) constant returns (uint256) {\r\n        return balancesEther[_owner];\r\n    }\r\n    \r\n    //time left before the crodsale ends\r\n    function TimeLeft() external constant returns (uint256) {\r\n        if(fundingEnd>block.timestamp)\r\n            return fundingEnd-block.timestamp;\r\n        else\r\n            return 0;\r\n    }\r\n    \r\n    //time left before the crodsale begins\r\n    function TimeLeftBeforeCrowdsale() external constant returns (uint256) {\r\n        if(fundingStart>block.timestamp)\r\n            return fundingStart-block.timestamp;\r\n        else\r\n            return 0;\r\n    }\r\n\r\n    // allows us to migrate to anew contract\r\n    function migrate(uint256 _value) external {\r\n        // can only be called if the funding ended\r\n        if(funding) throw;\r\n        \r\n        //the migration agent address needs to be set\r\n        if(migrationAgent == 0) throw;\r\n\r\n        // must migrate more than nothing\r\n        if(_value == 0) throw;\r\n        \r\n        //if the value is higher than the sender owns abort\r\n        if(_value > balances[msg.sender]) throw;\r\n\r\n        //reduce the balance of the owner\r\n        balances[msg.sender] -= _value;\r\n        \r\n        //reduce the token left in the old contract\r\n        totalTokens -= _value;\r\n        totalMigrated += _value;\r\n        \r\n        //call the migration agent to complete the migration\r\n        //credits the same amount of LNC in the new contract\r\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\r\n        Migrate(msg.sender, migrationAgent, _value);\r\n    }\r\n\r\n    //sets the address of the migration agent\r\n    function setMigrationAgent(address _agent) external {\r\n        //not possible in funding mode\r\n        if(funding) throw;\r\n        \r\n        //only allow to set this once\r\n        if(migrationAgent != 0) throw;\r\n        \r\n        //anly the owner can call this function\r\n        if(msg.sender != master) throw;\r\n        \r\n        //set the migration agent\r\n        migrationAgent = _agent;\r\n    }\r\n    \r\n    //return the current exchange rate -> LNC per Ether\r\n    function getExchangeRate() constant returns(uint){\r\n        //15000 LNC at power day\r\n        if(fundingStart + 1 * 1 days > block.timestamp){\r\n            return 15000;\r\n        }\r\n        //otherwise reduce by 1 % every 10 million LNC sold\r\n        else{\r\n            uint256 decrease=100-(soldAfterPowerHour/10000000/1000000000000000000);\r\n            if(decrease<70){\r\n                decrease=70;\r\n            }\r\n            return 10000*decrease/100;\r\n        }\r\n    }\r\n    \r\n    //returns if the crowd sale is still open\r\n    function ICOopen() constant returns(bool){\r\n        if(!funding) return false;\r\n        else if(block.timestamp < fundingStart) return false;\r\n        else if(block.timestamp > fundingEnd) return false;\r\n        else if(tokenCreationCap <= totalTokens) return false;\r\n        else return true;\r\n    }\r\n\r\n    // Crowdfunding:\r\n\r\n    //when someone send ether to this contract\r\n    function() payable external {\r\n        //not possible if the funding has ended\r\n        if(!funding) throw;\r\n        \r\n        //not possible before the funding started\r\n        if(block.timestamp < fundingStart) throw;\r\n        \r\n        //not possible after the funding ended\r\n        if(block.timestamp > fundingEnd) throw;\r\n\r\n        // Do not allow creating 0 or more than the cap tokens.\r\n        if(msg.value == 0) throw;\r\n        \r\n        //don't allow to create more token than the maximum cap\r\n        if((msg.value  * getExchangeRate()) > (tokenCreationCap - totalTokens)) throw;\r\n\r\n        //calculate the amount of LNC the sender receives\r\n        var numTokens = msg.value * getExchangeRate();\r\n        totalTokens += numTokens;\r\n        \r\n        //increase the amount of token sold after power day\r\n        //allows us to calculate the 1 % price increase per 10 million LNC sold\r\n        if(getExchangeRate()!=15000){\r\n            soldAfterPowerHour += numTokens;\r\n        }\r\n\r\n        // increase the amount of token the sender holds\r\n        balances[msg.sender] += numTokens;\r\n        \r\n        //increase the amount of ether the sender pledged into the contract\r\n        balancesEther[msg.sender] += msg.value;\r\n        \r\n        //icrease the amount of people that sent ether to this contract\r\n        totalParticipants+=1;\r\n\r\n        // Log token creation\r\n        Transfer(0, msg.sender, numTokens);\r\n    }\r\n\r\n    //called after the crodsale ended\r\n    //needed to allow everyone to send their LNC around\r\n    function finalize() external {\r\n        // not possible if the funding already ended\r\n        if(!funding) throw;\r\n        \r\n        //only possible if funding ended and the minimum cap is reached - or\r\n        //the total amount of token is the same as the maximum cap\r\n        if((block.timestamp <= fundingEnd ||\r\n             totalTokens < tokenCreationMin) &&\r\n            (totalTokens+5000000000000000000000) < tokenCreationCap) throw;\r\n\r\n        // allows to tranfer token to another address\r\n        // disables buying LNC\r\n        funding = false;\r\n\r\n        //send 12% of the token to the devs\r\n        //10 % for the devs\r\n        //2 % for the bounty participants\r\n        uint256 percentOfTotal = 12;\r\n        uint256 additionalTokens = totalTokens * percentOfTotal / (100 - percentOfTotal);\r\n        totalTokens += additionalTokens;\r\n        balances[master] += additionalTokens;\r\n        Transfer(0, master, additionalTokens);\r\n\r\n        // Transfer ETH to the Blocklancer address.\r\n        if (!master.send(this.balance)) throw;\r\n    }\r\n\r\n    //everyone needs to call this function should the minimum cap not be reached\r\n    //refunds the sender\r\n    function refund() external {\r\n        // not possible after the ICO was finished\r\n        if(!funding) throw;\r\n        \r\n        //not possible before the ICO ended\r\n        if(block.timestamp <= fundingEnd) throw;\r\n        \r\n        //not possible if more token were created than the minimum\r\n        if(totalTokens >= tokenCreationMin) throw;\r\n\r\n        var lncValue = balances[msg.sender];\r\n        var ethValue = balancesEther[msg.sender];\r\n        if (lncValue == 0) throw;\r\n        \r\n        //set the amount of token the sender has to 0\r\n        balances[msg.sender] = 0;\r\n        \r\n        //set the amount of ether the sender owns to 0\r\n        balancesEther[msg.sender] = 0;\r\n        totalTokens -= lncValue;\r\n\r\n        Refund(msg.sender, ethValue);\r\n        if (!msg.sender.send(ethValue)) throw;\r\n    }\r\n\t\r\n    // Send _value amount of tokens from address _from to address _to\r\n    // The transferFrom method is used for a withdraw workflow, allowing contracts to send\r\n     // tokens on your behalf, for example to \"deposit\" to a contract address and/or to charge\r\n     // fees in sub-currencies; the command should fail unless the _from account has\r\n     // deliberately authorized the sender of the message via some mechanism; we propose\r\n     // these standardized APIs for approval:\r\n     function transferFrom(address _from,address _to,uint256 _amount) returns (bool success) {\r\n         if(funding) throw;\r\n         if (balances[_from] >= _amount\r\n             && allowed[_from][msg.sender] >= _amount\r\n             && _amount > 0\r\n             && balances[_to] + _amount > balances[_to]) {\r\n             balances[_from] -= _amount;\r\n             allowed[_from][msg.sender] -= _amount;\r\n             balances[_to] += _amount;\r\n             Transfer(_from, _to, _amount);\r\n             return true;\r\n         } else {\r\n             return false;\r\n         }\r\n     }\r\n  \r\n     // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\r\n     // If this function is called again it overwrites the current allowance with _value.\r\n     function approve(address _spender, uint256 _amount) returns (bool success) {\r\n         if(funding) throw;\r\n         allowed[msg.sender][_spender] = _amount;\r\n         Approval(msg.sender, _spender, _amount);\r\n         return true;\r\n     }\r\n  \r\n     function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n         return allowed[_owner][_spender];\r\n     }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"ICOopen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"EtherBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAmountSoldAfterPowerDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"migrate\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenCreationCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_agent\",\"type\":\"address\"}],\"name\":\"setMigrationAgent\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"migrationAgent\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TimeLeftBeforeCrowdsale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalMigrated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingStart\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenCreationMin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"funding\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAmountofTotalParticipants\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TimeLeft\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getExchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"master\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Migrate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"BlocklancerToken","CompilerVersion":"v0.4.8+commit.60cc1668","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://6d15509ea3baeccddcddd849517c9b8e338dbb9c5b9fa96f2ef970c9eb560975"}]}