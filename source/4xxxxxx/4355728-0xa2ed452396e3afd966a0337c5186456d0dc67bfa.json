{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.15;\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n\r\n/*\r\n * @title This is proxy for analytics. Target contract can be found at field m_analytics (see \"read contract\").\r\n * @author Eenae\r\n\r\n * FIXME after fix of truffle issue #560: refactor to a separate contract file which uses InvestmentAnalytics interface\r\n */\r\ncontract AnalyticProxy {\r\n\r\n    function AnalyticProxy() {\r\n        m_analytics = InvestmentAnalytics(msg.sender);\r\n    }\r\n\r\n    /// @notice forward payment to analytics-capable contract\r\n    function() payable {\r\n        m_analytics.iaInvestedBy.value(msg.value)(msg.sender);\r\n    }\r\n\r\n    InvestmentAnalytics public m_analytics;\r\n}\r\n\r\n\r\n/*\r\n * @title Mixin contract which supports different payment channels and provides analytical per-channel data.\r\n * @author Eenae\r\n */\r\ncontract InvestmentAnalytics {\r\n    using SafeMath for uint256;\r\n\r\n    function InvestmentAnalytics(){\r\n    }\r\n\r\n    /// @dev creates more payment channels, up to the limit but not exceeding gas stipend\r\n    function createMorePaymentChannelsInternal(uint limit) internal returns (uint) {\r\n        uint paymentChannelsCreated;\r\n        for (uint i = 0; i < limit; i++) {\r\n            uint startingGas = msg.gas;\r\n            /*\r\n             * ~170k of gas per paymentChannel,\r\n             * using gas price = 4Gwei 2k paymentChannels will cost ~1.4 ETH.\r\n             */\r\n\r\n            address paymentChannel = new AnalyticProxy();\r\n            m_validPaymentChannels[paymentChannel] = true;\r\n            m_paymentChannels.push(paymentChannel);\r\n            paymentChannelsCreated++;\r\n\r\n            // cost of creating one channel\r\n            uint gasPerChannel = startingGas.sub(msg.gas);\r\n            if (gasPerChannel.add(50000) > msg.gas)\r\n                break;  // enough proxies for this call\r\n        }\r\n        return paymentChannelsCreated;\r\n    }\r\n\r\n\r\n    /// @dev process payments - record analytics and pass control to iaOnInvested callback\r\n    function iaInvestedBy(address investor) external payable {\r\n        address paymentChannel = msg.sender;\r\n        if (m_validPaymentChannels[paymentChannel]) {\r\n            // payment received by one of our channels\r\n            uint value = msg.value;\r\n            m_investmentsByPaymentChannel[paymentChannel] = m_investmentsByPaymentChannel[paymentChannel].add(value);\r\n            // We know for sure that investment came from specified investor (see AnalyticProxy).\r\n            iaOnInvested(investor, value, true);\r\n        } else {\r\n            // Looks like some user has paid to this method, this payment is not included in the analytics,\r\n            // but, of course, processed.\r\n            iaOnInvested(msg.sender, msg.value, false);\r\n        }\r\n    }\r\n\r\n    /// @dev callback\r\n    function iaOnInvested(address investor, uint payment, bool usingPaymentChannel) internal {\r\n    }\r\n\r\n\r\n    function paymentChannelsCount() external constant returns (uint) {\r\n        return m_paymentChannels.length;\r\n    }\r\n\r\n    function readAnalyticsMap() external constant returns (address[], uint[]) {\r\n        address[] memory keys = new address[](m_paymentChannels.length);\r\n        uint[] memory values = new uint[](m_paymentChannels.length);\r\n\r\n        for (uint i = 0; i < m_paymentChannels.length; i++) {\r\n            address key = m_paymentChannels[i];\r\n            keys[i] = key;\r\n            values[i] = m_investmentsByPaymentChannel[key];\r\n        }\r\n\r\n        return (keys, values);\r\n    }\r\n\r\n    function readPaymentChannels() external constant returns (address[]) {\r\n        return m_paymentChannels;\r\n    }\r\n\r\n\r\n    mapping(address => uint256) public m_investmentsByPaymentChannel;\r\n    mapping(address => bool) m_validPaymentChannels;\r\n\r\n    address[] public m_paymentChannels;\r\n}\r\n\r\n/**\r\n * @title Helps contracts guard agains rentrancy attacks.\r\n * @author Remco Bloemen <remco@2Ï€.com>\r\n * @notice If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n\r\n  /**\r\n   * @dev We use a single lock for the whole contract.\r\n   */\r\n  bool private rentrancy_lock = false;\r\n\r\n  /**\r\n   * @dev Prevents a contract from calling itself, directly or indirectly.\r\n   * @notice If you mark a function `nonReentrant`, you should also\r\n   * mark it `external`. Calling one nonReentrant function from\r\n   * another is not supported. Instead, you can implement a\r\n   * `private` function doing the actual work, and a `external`\r\n   * wrapper marked as `nonReentrant`.\r\n   */\r\n  modifier nonReentrant() {\r\n    require(!rentrancy_lock);\r\n    rentrancy_lock = true;\r\n    _;\r\n    rentrancy_lock = false;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n    }\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract STQToken {\r\n    function mint(address _to, uint256 _amount) external;\r\n}\r\n\r\n/// @title Storiqa pre-ICO contract\r\ncontract STQPreICO is Ownable, ReentrancyGuard, InvestmentAnalytics {\r\n    using SafeMath for uint256;\r\n\r\n    event FundTransfer(address backer, uint amount, bool isContribution);\r\n\r\n    function STQPreICO(address token, address funds) {\r\n        require(address(0) != address(token) && address(0) != address(funds));\r\n\r\n        m_token = STQToken(token);\r\n        m_funds = funds;\r\n    }\r\n\r\n\r\n    // PUBLIC interface: payments\r\n\r\n    // fallback function as a shortcut\r\n    function() payable {\r\n        require(0 == msg.data.length);\r\n        buy();  // only internal call here!\r\n    }\r\n\r\n    /// @notice ICO participation\r\n    function buy() public payable {     // dont mark as external!\r\n        iaOnInvested(msg.sender, msg.value, false);\r\n    }\r\n\r\n\r\n    // PUBLIC interface: maintenance\r\n\r\n    function createMorePaymentChannels(uint limit) external onlyOwner returns (uint) {\r\n        return createMorePaymentChannelsInternal(limit);\r\n    }\r\n\r\n    /// @notice Tests ownership of the current caller.\r\n    /// @return true if it's an owner\r\n    // It's advisable to call it by new owner to make sure that the same erroneous address is not copy-pasted to\r\n    // addOwner/changeOwner and to isOwner.\r\n    function amIOwner() external constant onlyOwner returns (bool) {\r\n        return true;\r\n    }\r\n\r\n\r\n    // INTERNAL\r\n\r\n    /// @dev payment callback\r\n    function iaOnInvested(address investor, uint payment, bool usingPaymentChannel)\r\n        internal\r\n        nonReentrant\r\n    {\r\n        require(payment >= c_MinInvestment);\r\n        require(getCurrentTime() >= c_startTime && getCurrentTime() < c_endTime || msg.sender == owner);\r\n\r\n        uint startingInvariant = this.balance.add(m_funds.balance);\r\n\r\n        // return or update payment if needed\r\n        uint paymentAllowed = getMaximumFunds().sub(m_totalInvested);\r\n        if (0 == paymentAllowed) {\r\n            investor.transfer(payment);\r\n            return;\r\n        }\r\n        uint change;\r\n        if (paymentAllowed < payment) {\r\n            change = payment.sub(paymentAllowed);\r\n            payment = paymentAllowed;\r\n        }\r\n\r\n        // calculate rate\r\n        uint bonusPercent = c_preICOBonusPercent;\r\n        bonusPercent += getLargePaymentBonus(payment);\r\n        if (usingPaymentChannel)\r\n            bonusPercent += c_paymentChannelBonusPercent;\r\n\r\n        uint rate = c_STQperETH.mul(100 + bonusPercent).div(100);\r\n\r\n        // issue tokens\r\n        uint stq = payment.mul(rate);\r\n        m_token.mint(investor, stq);\r\n\r\n        // record payment\r\n        m_funds.transfer(payment);\r\n        m_totalInvested = m_totalInvested.add(payment);\r\n        assert(m_totalInvested <= getMaximumFunds());\r\n        FundTransfer(investor, payment, true);\r\n\r\n        if (change > 0)\r\n            investor.transfer(change);\r\n\r\n        assert(startingInvariant == this.balance.add(m_funds.balance).add(change));\r\n    }\r\n\r\n    function getLargePaymentBonus(uint payment) private constant returns (uint) {\r\n        if (payment > 1000 ether) return 10;\r\n        if (payment > 800 ether) return 8;\r\n        if (payment > 500 ether) return 5;\r\n        if (payment > 200 ether) return 2;\r\n        return 0;\r\n    }\r\n\r\n    /// @dev to be overridden in tests\r\n    function getCurrentTime() internal constant returns (uint) {\r\n        return now;\r\n    }\r\n\r\n    /// @dev to be overridden in tests\r\n    function getMaximumFunds() internal constant returns (uint) {\r\n        return c_MaximumFunds;\r\n    }\r\n\r\n\r\n    // FIELDS\r\n\r\n    /// @notice start time of the pre-ICO\r\n    uint public constant c_startTime = 1507766400;\r\n\r\n    /// @notice end time of the pre-ICO\r\n    uint public constant c_endTime = c_startTime + (1 days);\r\n\r\n    /// @notice minimum investment\r\n    uint public constant c_MinInvestment = 10 finney;\r\n\r\n    /// @notice maximum investments to be accepted during pre-ICO\r\n    uint public constant c_MaximumFunds = 3500 ether;\r\n\r\n\r\n    /// @notice starting exchange rate of STQ\r\n    uint public constant c_STQperETH = 100000;\r\n\r\n    /// @notice pre-ICO bonus\r\n    uint public constant c_preICOBonusPercent = 40;\r\n\r\n    /// @notice authorised payment bonus\r\n    uint public constant c_paymentChannelBonusPercent = 2;\r\n\r\n\r\n    /// @dev total investments amount\r\n    uint public m_totalInvested;\r\n\r\n    /// @dev contract responsible for token accounting\r\n    STQToken public m_token;\r\n\r\n    /// @dev address responsible for investments accounting\r\n    address public m_funds;\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"m_totalInvested\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"createMorePaymentChannels\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"readAnalyticsMap\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"c_MaximumFunds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amIOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"c_preICOBonusPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"m_paymentChannels\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_funds\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"c_STQperETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"iaInvestedBy\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"c_paymentChannelBonusPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"m_investmentsByPaymentChannel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paymentChannelsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"c_startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"c_endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"readPaymentChannels\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"c_MinInvestment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"funds\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"backer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"isContribution\",\"type\":\"bool\"}],\"name\":\"FundTransfer\",\"type\":\"event\"}]","ContractName":"STQPreICO","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000005c3a228510d246b78a3765c20221cbf3082b44a40000000000000000000000000eed5de3487aec55ba585212daedf35104c27baf","Library":"","SwarmSource":"bzzr://5ecf3b7d2ca60236030b82dc0b975bb4edbe7e3459b30d5c4e9667fb52953243"}]}