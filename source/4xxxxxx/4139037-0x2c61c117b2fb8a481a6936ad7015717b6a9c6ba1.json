{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\n/**\r\n * @title Array16 Library\r\n * @author Majoolr.io\r\n *\r\n * version 1.0.0\r\n * Copyright (c) 2017 Majoolr, LLC\r\n * The MIT License (MIT)\r\n * https://github.com/Majoolr/ethereum-libraries/blob/master/LICENSE\r\n *\r\n * The Array16 Library provides a few utility functions to work with\r\n * storage uint16[] types in place. Majoolr works on open source projects in\r\n * the Ethereum community with the purpose of testing, documenting, and deploying\r\n * reusable code onto the blockchain to improve security and usability of smart\r\n * contracts. Majoolr also strives to educate non-profits, schools, and other\r\n * community members about the application of blockchain technology.\r\n * For further information: majoolr.io\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\nlibrary Array16Lib {\r\n\r\n  /// @dev Sum vector\r\n  /// @param self Storage array containing uint256 type variables\r\n  /// @return sum The sum of all elements, does not check for overflow\r\n  function sumElements(uint16[] storage self) constant returns(uint16 sum) {\r\n    uint256 term;\r\n    assembly {\r\n      mstore(0x60,self_slot)\r\n\r\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\r\n        term := sload(add(sha3(0x60,0x20),div(i,16)))\r\n\r\n        switch mod(i,16)\r\n        case 1 {\r\n          for { let j := 0 } lt(j, 1) { j := add(j, 1) } {\r\n            term := div(term,65536)\r\n          }\r\n        }\r\n        case 2 {\r\n          for { let j := 0 } lt(j, 2) { j := add(j, 1) } {\r\n            term := div(term,65536)\r\n          }\r\n        }\r\n        case 3 {\r\n          for { let j := 0 } lt(j, 3) { j := add(j, 1) } {\r\n            term := div(term,65536)\r\n          }\r\n        }\r\n        case 4 {\r\n          for { let j := 0 } lt(j, 4) { j := add(j, 1) } {\r\n            term := div(term,65536)\r\n          }\r\n        }\r\n        case 5 {\r\n          for { let j := 0 } lt(j, 5) { j := add(j, 1) } {\r\n            term := div(term,65536)\r\n          }\r\n        }\r\n        case 6 {\r\n          for { let j := 0 } lt(j, 6) { j := add(j, 1) } {\r\n            term := div(term,65536)\r\n          }\r\n        }\r\n        case 7 {\r\n          for { let j := 0 } lt(j, 7) { j := add(j, 1) } {\r\n            term := div(term,65536)\r\n          }\r\n        }\r\n        case 8 {\r\n          for { let j := 0 } lt(j, 8) { j := add(j, 1) } {\r\n            term := div(term,65536)\r\n          }\r\n        }\r\n        case 9 {\r\n          for { let j := 0 } lt(j, 9) { j := add(j, 1) } {\r\n            term := div(term,65536)\r\n          }\r\n        }\r\n        case 10 {\r\n          for { let j := 0 } lt(j, 10) { j := add(j, 1) } {\r\n            term := div(term,65536)\r\n          }\r\n        }\r\n        case 11 {\r\n          for { let j := 0 } lt(j, 11) { j := add(j, 1) } {\r\n            term := div(term,65536)\r\n          }\r\n        }\r\n        case 12 {\r\n          for { let j := 0 } lt(j, 12) { j := add(j, 1) } {\r\n            term := div(term,65536)\r\n          }\r\n        }\r\n        case 13 {\r\n          for { let j := 0 } lt(j, 13) { j := add(j, 1) } {\r\n            term := div(term,65536)\r\n          }\r\n        }\r\n        case 14 {\r\n          for { let j := 0 } lt(j, 14) { j := add(j, 1) } {\r\n            term := div(term,65536)\r\n          }\r\n        }\r\n        case 15 {\r\n          for { let j := 0 } lt(j, 15) { j := add(j, 1) } {\r\n            term := div(term,65536)\r\n          }\r\n        }\r\n\r\n        term := and(0x000000000000000000000000000000000000000000000000000000000000ffff,term)\r\n        sum := add(term,sum)\r\n\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @dev Returns the max value in an array.\r\n  /// @param self Storage array containing uint256 type variables\r\n  /// @return maxValue The highest value in the array\r\n  function getMax(uint16[] storage self) constant returns(uint16 maxValue) {\r\n    uint256 term;\r\n    assembly {\r\n      mstore(0x60,self_slot)\r\n      maxValue := 0\r\n\r\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\r\n        term := sload(add(sha3(0x60,0x20),div(i,16)))\r\n\r\n        switch mod(i,16)\r\n        case 1 {\r\n          for { let j := 0 } lt(j, 1) { j := add(j, 1) } {\r\n            term := div(term,65536)\r\n          }\r\n        }\r\n        case 2 {\r\n          for { let j := 0 } lt(j, 2) { j := add(j, 1) } {\r\n            term := div(term,65536)\r\n          }\r\n        }\r\n        case 3 {\r\n          for { let j := 0 } lt(j, 3) { j := add(j, 1) } {\r\n            term := div(term,65536)\r\n          }\r\n        }\r\n        case 4 {\r\n          for { let j := 0 } lt(j, 4) { j := add(j, 1) } {\r\n            term := div(term,65536)\r\n          }\r\n        }\r\n        case 5 {\r\n          for { let j := 0 } lt(j, 5) { j := add(j, 1) } {\r\n            term := div(term,65536)\r\n          }\r\n        }\r\n        case 6 {\r\n          for { let j := 0 } lt(j, 6) { j := add(j, 1) } {\r\n            term := div(term,65536)\r\n          }\r\n        }\r\n        case 7 {\r\n          for { let j := 0 } lt(j, 7) { j := add(j, 1) } {\r\n            term := div(term,65536)\r\n          }\r\n        }\r\n        case 8 {\r\n          for { let j := 0 } lt(j, 8) { j := add(j, 1) } {\r\n            term := div(term,65536)\r\n          }\r\n        }\r\n        case 9 {\r\n          for { let j := 0 } lt(j, 9) { j := add(j, 1) } {\r\n            term := div(term,65536)\r\n          }\r\n        }\r\n        case 10 {\r\n          for { let j := 0 } lt(j, 10) { j := add(j, 1) } {\r\n            term := div(term,65536)\r\n          }\r\n        }\r\n        case 11 {\r\n          for { let j := 0 } lt(j, 11) { j := add(j, 1) } {\r\n            term := div(term,65536)\r\n          }\r\n        }\r\n        case 12 {\r\n          for { let j := 0 } lt(j, 12) { j := add(j, 1) } {\r\n            term := div(term,65536)\r\n          }\r\n        }\r\n        case 13 {\r\n          for { let j := 0 } lt(j, 13) { j := add(j, 1) } {\r\n            term := div(term,65536)\r\n          }\r\n        }\r\n        case 14 {\r\n          for { let j := 0 } lt(j, 14) { j := add(j, 1) } {\r\n            term := div(term,65536)\r\n          }\r\n        }\r\n        case 15 {\r\n          for { let j := 0 } lt(j, 15) { j := add(j, 1) } {\r\n            term := div(term,65536)\r\n          }\r\n        }\r\n\r\n        term := and(0x000000000000000000000000000000000000000000000000000000000000ffff,term)\r\n        switch lt(maxValue, term)\r\n        case 1 {\r\n          maxValue := term\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @dev Returns the minimum value in an array.\r\n  /// @param self Storage array containing uint256 type variables\r\n  /// @return minValue The highest value in the array\r\n  function getMin(uint16[] storage self) constant returns(uint16 minValue) {\r\n    uint256 term;\r\n    assembly {\r\n      mstore(0x60,self_slot)\r\n\r\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\r\n        term := sload(add(sha3(0x60,0x20),div(i,16)))\r\n\r\n        switch mod(i,16)\r\n        case 1 {\r\n          for { let j := 0 } lt(j, 1) { j := add(j, 1) } {\r\n            term := div(term,65536)\r\n          }\r\n        }\r\n        case 2 {\r\n          for { let j := 0 } lt(j, 2) { j := add(j, 1) } {\r\n            term := div(term,65536)\r\n          }\r\n        }\r\n        case 3 {\r\n          for { let j := 0 } lt(j, 3) { j := add(j, 1) } {\r\n            term := div(term,65536)\r\n          }\r\n        }\r\n        case 4 {\r\n          for { let j := 0 } lt(j, 4) { j := add(j, 1) } {\r\n            term := div(term,65536)\r\n          }\r\n        }\r\n        case 5 {\r\n          for { let j := 0 } lt(j, 5) { j := add(j, 1) } {\r\n            term := div(term,65536)\r\n          }\r\n        }\r\n        case 6 {\r\n          for { let j := 0 } lt(j, 6) { j := add(j, 1) } {\r\n            term := div(term,65536)\r\n          }\r\n        }\r\n        case 7 {\r\n          for { let j := 0 } lt(j, 7) { j := add(j, 1) } {\r\n            term := div(term,65536)\r\n          }\r\n        }\r\n        case 8 {\r\n          for { let j := 0 } lt(j, 8) { j := add(j, 1) } {\r\n            term := div(term,65536)\r\n          }\r\n        }\r\n        case 9 {\r\n          for { let j := 0 } lt(j, 9) { j := add(j, 1) } {\r\n            term := div(term,65536)\r\n          }\r\n        }\r\n        case 10 {\r\n          for { let j := 0 } lt(j, 10) { j := add(j, 1) } {\r\n            term := div(term,65536)\r\n          }\r\n        }\r\n        case 11 {\r\n          for { let j := 0 } lt(j, 11) { j := add(j, 1) } {\r\n            term := div(term,65536)\r\n          }\r\n        }\r\n        case 12 {\r\n          for { let j := 0 } lt(j, 12) { j := add(j, 1) } {\r\n            term := div(term,65536)\r\n          }\r\n        }\r\n        case 13 {\r\n          for { let j := 0 } lt(j, 13) { j := add(j, 1) } {\r\n            term := div(term,65536)\r\n          }\r\n        }\r\n        case 14 {\r\n          for { let j := 0 } lt(j, 14) { j := add(j, 1) } {\r\n            term := div(term,65536)\r\n          }\r\n        }\r\n        case 15 {\r\n          for { let j := 0 } lt(j, 15) { j := add(j, 1) } {\r\n            term := div(term,65536)\r\n          }\r\n        }\r\n\r\n        term := and(0x000000000000000000000000000000000000000000000000000000000000ffff,term)\r\n\r\n        switch eq(i,0)\r\n        case 1 {\r\n          minValue := term\r\n        }\r\n        switch gt(minValue, term)\r\n        case 1 {\r\n          minValue := term\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @dev Finds the index of a given value in an array\r\n  /// @param self Storage array containing uint256 type variables\r\n  /// @param value The value to search for\r\n  /// @param isSorted True if the array is sorted, false otherwise\r\n  /// @return found True if the value was found, false otherwise\r\n  /// @return index The index of the given value, returns 0 if found is false\r\n  function indexOf(uint16[] storage self, uint16 value, bool isSorted) constant\r\n           returns(bool found, uint256 index) {\r\n    if (isSorted) {\r\n        uint256 high = self.length - 1;\r\n        uint256 mid = 0;\r\n        uint256 low = 0;\r\n        while (low <= high) {\r\n          mid = (low+high)/2;\r\n          if (self[mid] == value) {\r\n            found = true;\r\n            index = mid;\r\n            low = high + 1;\r\n          } else if (self[mid] < value) {\r\n            low = mid + 1;\r\n          } else {\r\n            high = mid - 1;\r\n          }\r\n        }\r\n    } else {\r\n      for (uint256 i = 0; i<self.length; i++) {\r\n        if (self[i] == value) {\r\n          found = true;\r\n          index = i;\r\n          i = self.length;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @dev Utility function for heapSort\r\n  /// @param index The index of child node\r\n  /// @return pI The parent node index\r\n  function getParentI(uint256 index) constant private returns (uint256 pI) {\r\n    uint256 i = index - 1;\r\n    pI = i/2;\r\n  }\r\n\r\n  /// @dev Utility function for heapSort\r\n  /// @param index The index of parent node\r\n  /// @return lcI The index of left child\r\n  function getLeftChildI(uint256 index) constant private returns (uint256 lcI) {\r\n    uint256 i = index * 2;\r\n    lcI = i + 1;\r\n  }\r\n\r\n  /// @dev Sorts given array in place\r\n  /// @param self Storage array containing uint256 type variables\r\n  function heapSort(uint16[] storage self) {\r\n    uint256 end = self.length - 1;\r\n    uint256 start = getParentI(end);\r\n    uint256 root = start;\r\n    uint256 lChild;\r\n    uint256 rChild;\r\n    uint256 swap;\r\n    uint16 temp;\r\n    while(start >= 0){\r\n      root = start;\r\n      lChild = getLeftChildI(start);\r\n      while(lChild <= end){\r\n        rChild = lChild + 1;\r\n        swap = root;\r\n        if(self[swap] < self[lChild])\r\n          swap = lChild;\r\n        if((rChild <= end) && (self[swap]<self[rChild]))\r\n          swap = rChild;\r\n        if(swap == root)\r\n          lChild = end+1;\r\n        else {\r\n          temp = self[swap];\r\n          self[swap] = self[root];\r\n          self[root] = temp;\r\n          root = swap;\r\n          lChild = getLeftChildI(root);\r\n        }\r\n      }\r\n      if(start == 0)\r\n        break;\r\n      else\r\n        start = start - 1;\r\n    }\r\n    while(end > 0){\r\n      temp = self[end];\r\n      self[end] = self[0];\r\n      self[0] = temp;\r\n      end = end - 1;\r\n      root = 0;\r\n      lChild = getLeftChildI(0);\r\n      while(lChild <= end){\r\n        rChild = lChild + 1;\r\n        swap = root;\r\n        if(self[swap] < self[lChild])\r\n          swap = lChild;\r\n        if((rChild <= end) && (self[swap]<self[rChild]))\r\n          swap = rChild;\r\n        if(swap == root)\r\n          lChild = end + 1;\r\n        else {\r\n          temp = self[swap];\r\n          self[swap] = self[root];\r\n          self[root] = temp;\r\n          root = swap;\r\n          lChild = getLeftChildI(root);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"uint16[] storage\"}],\"name\":\"heapSort\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"self\",\"type\":\"uint16[] storage\"}],\"name\":\"sumElements\",\"outputs\":[{\"name\":\"sum\",\"type\":\"uint16\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"self\",\"type\":\"uint16[] storage\"},{\"name\":\"value\",\"type\":\"uint16\"},{\"name\":\"isSorted\",\"type\":\"bool\"}],\"name\":\"indexOf\",\"outputs\":[{\"name\":\"found\",\"type\":\"bool\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"self\",\"type\":\"uint16[] storage\"}],\"name\":\"getMax\",\"outputs\":[{\"name\":\"maxValue\",\"type\":\"uint16\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"self\",\"type\":\"uint16[] storage\"}],\"name\":\"getMin\",\"outputs\":[{\"name\":\"minValue\",\"type\":\"uint16\"}],\"payable\":false,\"type\":\"function\"}]","ContractName":"Array16Lib","CompilerVersion":"v0.4.13+commit.fb4cb1a","OptimizationUsed":"1","Runs":"0","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://c8ca2b7e444c81d16d062b9bdf2229f4c24c2008a295f855b6df1663d548d62f"}]}