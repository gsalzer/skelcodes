{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\nThis file is part of the PROOF Contract.\r\n\r\nThe PROOF Contract is free software: you can redistribute it and/or\r\nmodify it under the terms of the GNU lesser General Public License as published\r\nby the Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nThe PROOF Contract is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\nGNU lesser General Public License for more details.\r\n\r\nYou should have received a copy of the GNU lesser General Public License\r\nalong with the PROOF Contract. If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\npragma solidity ^0.4.0;\r\n\r\ncontract owned {\r\n\r\n    address public owner;\r\n\r\n    function owned() payable {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    modifier onlyOwner {\r\n        require(owner == msg.sender);\r\n        _;\r\n    }\r\n\r\n    function changeOwner(address _owner) onlyOwner public {\r\n        require(_owner != 0);\r\n        owner = _owner;\r\n    }\r\n}\r\n\r\ncontract Crowdsale is owned {\r\n    \r\n    uint256 public totalSupply;\r\n    mapping (address => uint256) public balanceOf;\r\n\r\n    uint    public etherPrice;\r\n    address public crowdsaleOwner;\r\n    uint    public totalLimitUSD;\r\n    uint    public minimalSuccessUSD;\r\n    uint    public collectedUSD;\r\n\r\n    enum State { Disabled, PreICO, CompletePreICO, Crowdsale, Enabled, Migration }\r\n    event NewState(State state);\r\n    State   public state = State.Disabled;\r\n    uint    public crowdsaleStartTime;\r\n    uint    public crowdsaleFinishTime;\r\n\r\n    modifier enabledState {\r\n        require(state == State.Enabled);\r\n        _;\r\n    }\r\n\r\n    modifier enabledOrMigrationState {\r\n        require(state == State.Enabled || state == State.Migration);\r\n        _;\r\n    }\r\n\r\n    struct Investor {\r\n        uint256 amountTokens;\r\n        uint    amountWei;\r\n    }\r\n    mapping (address => Investor) public investors;\r\n    mapping (uint => address)     public investorsIter;\r\n    uint                          public numberOfInvestors;\r\n    \r\n    function () payable {\r\n        require(state == State.PreICO || state == State.Crowdsale);\r\n        uint256 tokensPerUSD = 0;\r\n        if (state == State.PreICO) {\r\n            tokensPerUSD = 125;\r\n        } else if (state == State.Crowdsale) {\r\n            if (now < crowdsaleStartTime + 1 days) {\r\n                tokensPerUSD = 115;\r\n            } else if (now < crowdsaleStartTime + 1 weeks) {\r\n                tokensPerUSD = 110;\r\n            } else {\r\n                tokensPerUSD = 100;\r\n            }\r\n        }\r\n        if (tokensPerUSD > 0) {\r\n            uint valueWei = msg.value;\r\n            uint valueUSD = valueWei * etherPrice / 1000000000000000000;\r\n            if (collectedUSD + valueUSD > totalLimitUSD) { // don't need so much ether\r\n                valueUSD = totalLimitUSD - collectedUSD;\r\n                valueWei = valueUSD * 1000000000000000000 / etherPrice;\r\n                msg.sender.transfer(msg.value - valueWei);\r\n                collectedUSD = totalLimitUSD; // to be sure!\r\n            } else {\r\n                collectedUSD += valueUSD;\r\n            }\r\n            uint256 tokens = tokensPerUSD * valueUSD;\r\n            require(balanceOf[msg.sender] + tokens > balanceOf[msg.sender]); // overflow\r\n            require(tokens > 0);\r\n            \r\n            Investor storage inv = investors[msg.sender];\r\n            if (inv.amountWei == 0) { // new investor\r\n                investorsIter[numberOfInvestors++] = msg.sender;\r\n            }\r\n            inv.amountTokens += tokens;\r\n            inv.amountWei += valueWei;\r\n            balanceOf[msg.sender] += tokens;\r\n            totalSupply += tokens;\r\n        }\r\n    }\r\n    \r\n    function startTokensSale(address _crowdsaleOwner, uint _etherPrice) public onlyOwner {\r\n        require(state == State.Disabled || state == State.CompletePreICO);\r\n        crowdsaleStartTime = now;\r\n        crowdsaleOwner = _crowdsaleOwner;\r\n        etherPrice = _etherPrice;\r\n        delete numberOfInvestors;\r\n        delete collectedUSD;\r\n        if (state == State.Disabled) {\r\n            crowdsaleFinishTime = now + 14 days;\r\n            state = State.PreICO;\r\n            totalLimitUSD = 300000;\r\n            minimalSuccessUSD = 300000;\r\n        } else {\r\n            crowdsaleFinishTime = now + 30 days;\r\n            state = State.Crowdsale;\r\n            totalLimitUSD = 5200000;\r\n            minimalSuccessUSD = 3600000;\r\n        }\r\n        NewState(state);\r\n    }\r\n    \r\n    function timeToFinishTokensSale() public constant returns(uint t) {\r\n        require(state == State.PreICO || state == State.Crowdsale);\r\n        if (now > crowdsaleFinishTime) {\r\n            t = 0;\r\n        } else {\r\n            t = crowdsaleFinishTime - now;\r\n        }\r\n    }\r\n    \r\n    function finishTokensSale(uint _investorsToProcess) public {\r\n        require(state == State.PreICO || state == State.Crowdsale);\r\n        require(now >= crowdsaleFinishTime || collectedUSD == totalLimitUSD);\r\n        if (collectedUSD < minimalSuccessUSD) {\r\n            // Investors can get their ether calling withdrawBack() function\r\n            while (_investorsToProcess > 0 && numberOfInvestors > 0) {\r\n                address addr = investorsIter[--numberOfInvestors];\r\n                Investor memory inv = investors[addr];\r\n                balanceOf[addr] -= inv.amountTokens;\r\n                totalSupply -= inv.amountTokens;\r\n                --_investorsToProcess;\r\n                delete investorsIter[numberOfInvestors];\r\n            }\r\n            if (numberOfInvestors > 0) {\r\n                return;\r\n            }\r\n            if (state == State.PreICO) {\r\n                state = State.Disabled;\r\n            } else {\r\n                state = State.CompletePreICO;\r\n            }\r\n        } else {\r\n            while (_investorsToProcess > 0 && numberOfInvestors > 0) {\r\n                --numberOfInvestors;\r\n                --_investorsToProcess;\r\n                delete investors[investorsIter[numberOfInvestors]];\r\n                delete investorsIter[numberOfInvestors];\r\n            }\r\n            if (numberOfInvestors > 0) {\r\n                return;\r\n            }\r\n            if (state == State.PreICO) {\r\n                if (!crowdsaleOwner.send(this.balance)) throw;\r\n                state = State.CompletePreICO;\r\n            } else {\r\n                if (!crowdsaleOwner.send(1500000 * 1000000000000000000 / etherPrice)) throw;\r\n                // Create additional tokens for owner (28% of complete totalSupply)\r\n                balanceOf[owner] = totalSupply * 28 / 72;\r\n                totalSupply += totalSupply * 28 / 72;\r\n                state = State.Enabled;\r\n            }\r\n        }\r\n        NewState(state);\r\n    }\r\n    \r\n    // This function must be called by token holder in case of crowdsale failed\r\n    function withdrawBack() public {\r\n        require(state == State.Disabled || state == State.CompletePreICO);\r\n        uint value = investors[msg.sender].amountWei;\r\n        if (value > 0) {\r\n            delete investors[msg.sender];\r\n            msg.sender.transfer(value);\r\n        }\r\n    }\r\n}\r\n\r\ncontract Token is Crowdsale {\r\n    \r\n    string  public standard    = 'Token 0.1';\r\n    string  public name        = 'PROOF';\r\n    string  public symbol      = \"PF\";\r\n    uint8   public decimals    = 0;\r\n\r\n    modifier onlyTokenHolders {\r\n        require(balanceOf[msg.sender] != 0);\r\n        _;\r\n    }\r\n\r\n    mapping (address => mapping (address => uint256)) public allowed;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    function Token() payable Crowdsale() {}\r\n\r\n    function transfer(address _to, uint256 _value) public enabledState {\r\n        require(balanceOf[msg.sender] >= _value);\r\n        require(balanceOf[_to] + _value >= balanceOf[_to]); // overflow\r\n        balanceOf[msg.sender] -= _value;\r\n        balanceOf[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n    }\r\n    \r\n    function transferFrom(address _from, address _to, uint256 _value) public enabledState {\r\n        require(balanceOf[_from] >= _value);\r\n        require(balanceOf[_to] + _value >= balanceOf[_to]); // overflow\r\n        require(allowed[_from][msg.sender] >= _value);\r\n        balanceOf[_from] -= _value;\r\n        balanceOf[_to] += _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public enabledState {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public constant enabledState\r\n        returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n}\r\n\r\ncontract MigrationAgent {\r\n    function migrateFrom(address _from, uint256 _value);\r\n}\r\n\r\ncontract TokenMigration is Token {\r\n    \r\n    address public migrationAgent;\r\n    uint256 public totalMigrated;\r\n\r\n    event Migrate(address indexed from, address indexed to, uint256 value);\r\n\r\n    function TokenMigration() payable Token() {}\r\n\r\n    // Migrate _value of tokens to the new token contract\r\n    function migrate(uint256 _value) external {\r\n        require(state == State.Migration);\r\n        require(migrationAgent != 0);\r\n        require(_value != 0);\r\n        require(_value <= balanceOf[msg.sender]);\r\n        balanceOf[msg.sender] -= _value;\r\n        totalSupply -= _value;\r\n        totalMigrated += _value;\r\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\r\n        Migrate(msg.sender, migrationAgent, _value);\r\n    }\r\n\r\n    function setMigrationAgent(address _agent) external onlyOwner {\r\n        require(migrationAgent == 0);\r\n        migrationAgent = _agent;\r\n        state = State.Migration;\r\n    }\r\n}\r\n\r\ncontract ProofTeamVote is TokenMigration {\r\n\r\n    function ProofTeamVote() payable TokenMigration() {}\r\n\r\n    event VotingStarted(uint weiReqFund);\r\n    event Voted(address indexed voter, bool inSupport);\r\n    event VotingFinished(bool inSupport);\r\n\r\n    struct Vote {\r\n        bool inSupport;\r\n        bool voted;\r\n    }\r\n\r\n    uint public weiReqFund;\r\n    uint public votingDeadline;\r\n    uint public numberOfVotes;\r\n    uint public yea;\r\n    uint public nay;\r\n    mapping (address => Vote) public votes;\r\n    mapping (uint => address) public votesIter;\r\n\r\n    function startVoting(uint _weiReqFund) public enabledOrMigrationState onlyOwner {\r\n        require(weiReqFund == 0 && _weiReqFund > 0 && _weiReqFund <= this.balance);\r\n        weiReqFund = _weiReqFund;\r\n        votingDeadline = now + 7 days;\r\n        delete yea;\r\n        delete nay;\r\n        VotingStarted(_weiReqFund);\r\n    }\r\n    \r\n    function votingInfo() public constant enabledOrMigrationState\r\n        returns(uint _weiReqFund, uint _timeToFinish) {\r\n        _weiReqFund = weiReqFund;\r\n        if (votingDeadline <= now) {\r\n            _timeToFinish = 0;\r\n        } else {\r\n            _timeToFinish = votingDeadline - now;\r\n        }\r\n    }\r\n\r\n    function vote(bool _inSupport) public onlyTokenHolders enabledOrMigrationState\r\n        returns (uint voteId) {\r\n        require(votes[msg.sender].voted != true);\r\n        require(votingDeadline > now);\r\n        voteId = numberOfVotes++;\r\n        votesIter[voteId] = msg.sender;\r\n        votes[msg.sender] = Vote({inSupport: _inSupport, voted: true});\r\n        Voted(msg.sender, _inSupport);\r\n        return voteId;\r\n    }\r\n\r\n    function finishVoting(uint _votesToProcess) public enabledOrMigrationState\r\n        returns (bool _inSupport) {\r\n        require(now >= votingDeadline);\r\n\r\n        while (_votesToProcess > 0 && numberOfVotes > 0) {\r\n            address voter = votesIter[--numberOfVotes];\r\n            Vote memory v = votes[voter];\r\n            uint voteWeight = balanceOf[voter];\r\n            if (v.inSupport) {\r\n                yea += voteWeight;\r\n            } else {\r\n                nay += voteWeight;\r\n            }\r\n            delete votes[voter];\r\n            delete votesIter[numberOfVotes];\r\n            --_votesToProcess;\r\n        }\r\n        if (numberOfVotes > 0) {\r\n            _inSupport = false;\r\n            return;\r\n        }\r\n\r\n        _inSupport = (yea > nay);\r\n        uint weiForSend = weiReqFund;\r\n        delete weiReqFund;\r\n        delete votingDeadline;\r\n        delete numberOfVotes;\r\n\r\n        if (_inSupport) {\r\n            if (migrationAgent == 0) {\r\n                if (!owner.send(weiForSend)) throw;\r\n            } else {\r\n                if (!migrationAgent.send(this.balance)) throw;\r\n            }\r\n        }\r\n\r\n        VotingFinished(_inSupport);\r\n    }\r\n}\r\n\r\ncontract ProofPublicVote is ProofTeamVote {\r\n\r\n    function ProofPublicVote() payable ProofTeamVote() {}\r\n\r\n    event Deployed(address indexed projectOwner, uint proofReqFund, string urlInfo);\r\n    event Voted(address indexed projectOwner, address indexed voter, bool inSupport);\r\n    event VotingFinished(address indexed projectOwner, bool inSupport);\r\n\r\n    struct Project {\r\n        uint   proofReqFund;\r\n        string urlInfo;\r\n        uint   votingDeadline;\r\n        uint   numberOfVotes;\r\n        uint   yea;\r\n        uint   nay;\r\n        mapping (address => Vote) votes;\r\n        mapping (uint => address) votesIter;\r\n    }\r\n    mapping (address => Project) public projects;\r\n\r\n    function deployProject(uint _proofReqFund, string _urlInfo) public\r\n        onlyTokenHolders enabledOrMigrationState {\r\n        require(_proofReqFund > 0 && _proofReqFund <= balanceOf[this]);\r\n        require(_proofReqFund <= balanceOf[msg.sender] * 1000);\r\n        require(projects[msg.sender].proofReqFund == 0);\r\n        projects[msg.sender].proofReqFund = _proofReqFund;\r\n        projects[msg.sender].urlInfo = _urlInfo;\r\n        projects[msg.sender].votingDeadline = now + 7 days;\r\n        Deployed(msg.sender, _proofReqFund, _urlInfo);\r\n    }\r\n    \r\n    function projectInfo(address _projectOwner) enabledOrMigrationState constant public \r\n        returns(uint _proofReqFund, string _urlInfo, uint _timeToFinish) {\r\n        _proofReqFund = projects[_projectOwner].proofReqFund;\r\n        _urlInfo = projects[_projectOwner].urlInfo;\r\n        if (projects[_projectOwner].votingDeadline <= now) {\r\n            _timeToFinish = 0;\r\n        } else {\r\n            _timeToFinish = projects[_projectOwner].votingDeadline - now;\r\n        }\r\n    }\r\n\r\n    function vote(address _projectOwner, bool _inSupport) public\r\n        onlyTokenHolders enabledOrMigrationState returns (uint voteId) {\r\n        Project storage p = projects[_projectOwner];\r\n        require(p.proofReqFund > 0);\r\n        require(p.votes[msg.sender].voted != true);\r\n        require(p.votingDeadline > now);\r\n        voteId = p.numberOfVotes++;\r\n        p.votesIter[voteId] = msg.sender;\r\n        p.votes[msg.sender] = Vote({inSupport: _inSupport, voted: true});\r\n        Voted(_projectOwner, msg.sender, _inSupport); \r\n        return voteId;\r\n    }\r\n\r\n    function finishVoting(address _projectOwner, uint _votesToProcess) public\r\n        enabledOrMigrationState returns (bool _inSupport) {\r\n        Project storage p = projects[_projectOwner];\r\n        require(p.proofReqFund > 0);\r\n        require(now >= p.votingDeadline && p.proofReqFund <= balanceOf[this]);\r\n\r\n        while (_votesToProcess > 0 && p.numberOfVotes > 0) {\r\n            address voter = p.votesIter[--p.numberOfVotes];\r\n            Vote memory v = p.votes[voter];\r\n            uint voteWeight = balanceOf[voter];\r\n            if (v.inSupport) {\r\n                p.yea += voteWeight;\r\n            } else {\r\n                p.nay += voteWeight;\r\n            }\r\n            delete p.votesIter[p.numberOfVotes];\r\n            delete p.votes[voter];\r\n            --_votesToProcess;\r\n        }\r\n        if (p.numberOfVotes > 0) {\r\n            _inSupport = false;\r\n            return;\r\n        }\r\n\r\n        _inSupport = (p.yea > p.nay);\r\n\r\n        uint proofReqFund = p.proofReqFund;\r\n        delete projects[_projectOwner];\r\n\r\n        if (_inSupport) {\r\n            require(balanceOf[_projectOwner] + proofReqFund >= balanceOf[_projectOwner]); // overflow\r\n            balanceOf[this] -= proofReqFund;\r\n            balanceOf[_projectOwner] += proofReqFund;\r\n            Transfer(this, _projectOwner, proofReqFund);\r\n        }\r\n\r\n        VotingFinished(_projectOwner, _inSupport);\r\n    }\r\n}\r\n\r\ncontract Proof is ProofPublicVote {\r\n\r\n    struct Swype {\r\n        uint16  swype;\r\n        uint    timestampSwype;\r\n    }\r\n    \r\n    struct Video {\r\n        uint16  swype;\r\n        uint    timestampSwype;\r\n        uint    timestampHash;\r\n        address owner;\r\n    }\r\n\r\n    mapping (address => Swype) public swypes;\r\n    mapping (bytes32 => Video) public videos;\r\n\r\n    uint priceInTokens;\r\n    uint teamFee;\r\n\r\n    function Proof() payable ProofPublicVote() {}\r\n\r\n    function setPrice(uint _priceInTokens) public onlyOwner {\r\n        require(_priceInTokens >= 2);\r\n        teamFee = _priceInTokens / 10;\r\n        if (teamFee == 0) {\r\n            teamFee = 1;\r\n        }\r\n        priceInTokens = _priceInTokens - teamFee;\r\n    }\r\n\r\n    function swypeCode() public enabledState returns (uint16 _swype) {\r\n        bytes32 blockHash = block.blockhash(block.number - 1);\r\n        bytes32 shaTemp = sha3(msg.sender, blockHash);\r\n        _swype = uint16(uint256(shaTemp) % 65536);\r\n        swypes[msg.sender] = Swype({swype: _swype, timestampSwype: now});\r\n    }\r\n    \r\n    function setHash(uint16 _swype, bytes32 _hash) public enabledState {\r\n        require(swypes[msg.sender].timestampSwype != 0);\r\n        require(swypes[msg.sender].swype == _swype);\r\n        transfer(owner, teamFee);\r\n        transfer(this, priceInTokens);\r\n        videos[_hash] = Video({swype: _swype, timestampSwype:swypes[msg.sender].timestampSwype, \r\n            timestampHash: now, owner: msg.sender});\r\n        delete swypes[msg.sender];\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"votingDeadline\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"investorsIter\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBack\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfVotes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimalSuccessUSD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"yea\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"votingInfo\",\"outputs\":[{\"name\":\"_weiReqFund\",\"type\":\"uint256\"},{\"name\":\"_timeToFinish\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfInvestors\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"collectedUSD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiReqFund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_weiReqFund\",\"type\":\"uint256\"}],\"name\":\"startVoting\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_projectOwner\",\"type\":\"address\"},{\"name\":\"_votesToProcess\",\"type\":\"uint256\"}],\"name\":\"finishVoting\",\"outputs\":[{\"name\":\"_inSupport\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"migrate\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"swypeCode\",\"outputs\":[{\"name\":\"_swype\",\"type\":\"uint16\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investorsToProcess\",\"type\":\"uint256\"}],\"name\":\"finishTokensSale\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_inSupport\",\"type\":\"bool\"}],\"name\":\"vote\",\"outputs\":[{\"name\":\"voteId\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"standard\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"swypes\",\"outputs\":[{\"name\":\"swype\",\"type\":\"uint16\"},{\"name\":\"timestampSwype\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"investors\",\"outputs\":[{\"name\":\"amountTokens\",\"type\":\"uint256\"},{\"name\":\"amountWei\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_agent\",\"type\":\"address\"}],\"name\":\"setMigrationAgent\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timeToFinishTokensSale\",\"outputs\":[{\"name\":\"t\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalLimitUSD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"migrationAgent\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"projects\",\"outputs\":[{\"name\":\"proofReqFund\",\"type\":\"uint256\"},{\"name\":\"urlInfo\",\"type\":\"string\"},{\"name\":\"votingDeadline\",\"type\":\"uint256\"},{\"name\":\"numberOfVotes\",\"type\":\"uint256\"},{\"name\":\"yea\",\"type\":\"uint256\"},{\"name\":\"nay\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_priceInTokens\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalMigrated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleFinishTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"etherPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"videos\",\"outputs\":[{\"name\":\"swype\",\"type\":\"uint16\"},{\"name\":\"timestampSwype\",\"type\":\"uint256\"},{\"name\":\"timestampHash\",\"type\":\"uint256\"},{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_projectOwner\",\"type\":\"address\"}],\"name\":\"projectInfo\",\"outputs\":[{\"name\":\"_proofReqFund\",\"type\":\"uint256\"},{\"name\":\"_urlInfo\",\"type\":\"string\"},{\"name\":\"_timeToFinish\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_votesToProcess\",\"type\":\"uint256\"}],\"name\":\"finishVoting\",\"outputs\":[{\"name\":\"_inSupport\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proofReqFund\",\"type\":\"uint256\"},{\"name\":\"_urlInfo\",\"type\":\"string\"}],\"name\":\"deployProject\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_crowdsaleOwner\",\"type\":\"address\"},{\"name\":\"_etherPrice\",\"type\":\"uint256\"}],\"name\":\"startTokensSale\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_projectOwner\",\"type\":\"address\"},{\"name\":\"_inSupport\",\"type\":\"bool\"}],\"name\":\"vote\",\"outputs\":[{\"name\":\"voteId\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_swype\",\"type\":\"uint16\"},{\"name\":\"_hash\",\"type\":\"bytes32\"}],\"name\":\"setHash\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"votes\",\"outputs\":[{\"name\":\"inSupport\",\"type\":\"bool\"},{\"name\":\"voted\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"votesIter\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":true,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"projectOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"proofReqFund\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"urlInfo\",\"type\":\"string\"}],\"name\":\"Deployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"projectOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"inSupport\",\"type\":\"bool\"}],\"name\":\"Voted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"projectOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"inSupport\",\"type\":\"bool\"}],\"name\":\"VotingFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"weiReqFund\",\"type\":\"uint256\"}],\"name\":\"VotingStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Migrate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"state\",\"type\":\"uint8\"}],\"name\":\"NewState\",\"type\":\"event\"}]","ContractName":"Proof","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://6ef4e8e523104f4c27fbd1761689f727c734cb9bfd4072eabd2736571a82a3a1"}]}