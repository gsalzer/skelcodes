{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n}\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n  bool public paused = false;\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n}\r\n/**\r\n * The QuantstampSale smart contract is used for selling QuantstampToken\r\n * tokens (QSP). It does so by converting ETH received into a quantity of\r\n * tokens that are transferred to the contributor via the ERC20-compatible\r\n * transferFrom() function.\r\n */\r\ncontract QuantstampSale is Pausable {\r\n    using SafeMath for uint256;\r\n    // The beneficiary is the future recipient of the funds\r\n    address public beneficiary;\r\n    // The crowdsale has a funding goal, cap, deadline, and minimum contribution\r\n    uint public fundingCap;\r\n    uint public minContribution;\r\n    bool public fundingCapReached = false;\r\n    bool public saleClosed = false;\r\n    // Whitelist data\r\n    mapping(address => bool) public registry;\r\n    // For each user, specifies the cap (in wei) that can be contributed for each tier\r\n    // Tiers are filled in the order 3, 2, 1, 4\r\n    mapping(address => uint256) public cap1;        // 100% bonus\r\n    mapping(address => uint256) public cap2;        // 40% bonus\r\n    mapping(address => uint256) public cap3;        // 20% bonus\r\n    mapping(address => uint256) public cap4;        // 0% bonus\r\n    // Stores the amount contributed for each tier for a given address\r\n    mapping(address => uint256) public contributed1;\r\n    mapping(address => uint256) public contributed2;\r\n    mapping(address => uint256) public contributed3;\r\n    mapping(address => uint256) public contributed4;\r\n    // Conversion rate by tier (QSP : ETHER)\r\n    uint public rate1 = 10000;\r\n    uint public rate2 = 7000;\r\n    uint public rate3 = 6000;\r\n    uint public rate4 = 5000;\r\n    // Time period of sale (UNIX timestamps)\r\n    uint public startTime;\r\n    uint public endTime;\r\n    // Keeps track of the amount of wei raised\r\n    uint public amountRaised;\r\n    // prevent certain functions from being recursively called\r\n    bool private rentrancy_lock = false;\r\n    // The token being sold\r\n    // QuantstampToken public tokenReward;\r\n    // A map that tracks the amount of wei contributed by address\r\n    mapping(address => uint256) public balanceOf;\r\n    // A map that tracks the amount of QSP tokens that should be allocated to each address\r\n    mapping(address => uint256) public tokenBalanceOf;\r\n    // Events\r\n    event CapReached(address _beneficiary, uint _amountRaised);\r\n    event FundTransfer(address _backer, uint _amount, bool _isContribution);\r\n    event RegistrationStatusChanged(address target, bool isRegistered, uint c1, uint c2, uint c3, uint c4);\r\n    // Modifiers\r\n    modifier beforeDeadline()   { require (currentTime() < endTime); _; }\r\n    // modifier afterDeadline()    { require (currentTime() >= endTime); _; } no longer used without fundingGoal\r\n    modifier afterStartTime()    { require (currentTime() >= startTime); _; }\r\n    modifier saleNotClosed()    { require (!saleClosed); _; }\r\n    modifier nonReentrant() {\r\n        require(!rentrancy_lock);\r\n        rentrancy_lock = true;\r\n        _;\r\n        rentrancy_lock = false;\r\n    }\r\n    /**\r\n     * Constructor for a crowdsale of QuantstampToken tokens.\r\n     *\r\n     * @param ifSuccessfulSendTo            the beneficiary of the fund\r\n     * @param fundingCapInEthers            the cap (maximum) size of the fund\r\n     * @param minimumContributionInWei      minimum contribution (in wei)\r\n     * @param start                         the start time (UNIX timestamp)\r\n     * @param durationInMinutes             the duration of the crowdsale in minutes\r\n     */\r\n    function QuantstampSale(\r\n        address ifSuccessfulSendTo,\r\n        uint fundingCapInEthers,\r\n        uint minimumContributionInWei,\r\n        uint start,\r\n        uint durationInMinutes\r\n        // address addressOfTokenUsedAsReward\r\n    ) {\r\n        require(ifSuccessfulSendTo != address(0) && ifSuccessfulSendTo != address(this));\r\n        //require(addressOfTokenUsedAsReward != address(0) && addressOfTokenUsedAsReward != address(this));\r\n        require(durationInMinutes > 0);\r\n        beneficiary = ifSuccessfulSendTo;\r\n        fundingCap = fundingCapInEthers * 1 ether;\r\n        minContribution = minimumContributionInWei;\r\n        startTime = start;\r\n        endTime = start + (durationInMinutes * 1 minutes);\r\n        // tokenReward = QuantstampToken(addressOfTokenUsedAsReward);\r\n    }\r\n    /**\r\n     * This function is called whenever Ether is sent to the\r\n     * smart contract. It can only be executed when the crowdsale is\r\n     * not paused, not closed, and before the deadline has been reached.\r\n     *\r\n     * This function will update state variables for whether or not the\r\n     * funding goal or cap have been reached. It also ensures that the\r\n     * tokens are transferred to the sender, and that the correct\r\n     * number of tokens are sent according to the current rate.\r\n     */\r\n    function () payable {\r\n        buy();\r\n    }\r\n    function buy ()\r\n        payable public\r\n        whenNotPaused\r\n        beforeDeadline\r\n        afterStartTime\r\n        saleNotClosed\r\n        nonReentrant\r\n    {\r\n        require(msg.value >= minContribution);\r\n        uint amount = msg.value;\r\n        // ensure that the user adheres to whitelist restrictions\r\n        require(registry[msg.sender]);\r\n        uint numTokens = computeTokenAmount(msg.sender, amount);\r\n        assert(numTokens > 0);\r\n        // update the total amount raised\r\n        amountRaised = amountRaised.add(amount);\r\n        require(amountRaised <= fundingCap);\r\n        // update the sender's balance of wei contributed\r\n        balanceOf[msg.sender] = balanceOf[msg.sender].add(amount);\r\n        // add to the token balance of the sender\r\n        tokenBalanceOf[msg.sender] = tokenBalanceOf[msg.sender].add(numTokens);\r\n        FundTransfer(msg.sender, amount, true);\r\n        updateFundingCap();\r\n    }\r\n    /**\r\n    * Computes the amount of QSP that should be issued for the given transaction.\r\n    * Contribution tiers are filled up in the order 3, 2, 1, 4.\r\n    * @param addr      The wallet address of the contributor\r\n    * @param amount    Amount of wei for payment\r\n    */\r\n    function computeTokenAmount(address addr, uint amount) internal\r\n        returns (uint){\r\n        require(amount > 0);\r\n        uint r3 = cap3[addr].sub(contributed3[addr]);\r\n        uint r2 = cap2[addr].sub(contributed2[addr]);\r\n        uint r1 = cap1[addr].sub(contributed1[addr]);\r\n        uint r4 = cap4[addr].sub(contributed4[addr]);\r\n        uint numTokens = 0;\r\n        // cannot contribute more than the remaining sum\r\n        assert(amount <= r3.add(r2).add(r1).add(r4));\r\n        // Compute tokens for tier 3\r\n        if(r3 > 0){\r\n            if(amount <= r3){\r\n                contributed3[addr] = contributed3[addr].add(amount);\r\n                return rate3.mul(amount);\r\n            }\r\n            else{\r\n                numTokens = rate3.mul(r3);\r\n                amount = amount.sub(r3);\r\n                contributed3[addr] = cap3[addr];\r\n            }\r\n        }\r\n        // Compute tokens for tier 2\r\n        if(r2 > 0){\r\n            if(amount <= r2){\r\n                contributed2[addr] = contributed2[addr].add(amount);\r\n                return numTokens.add(rate2.mul(amount));\r\n            }\r\n            else{\r\n                numTokens = numTokens.add(rate2.mul(r2));\r\n                amount = amount.sub(r2);\r\n                contributed2[addr] = cap2[addr];\r\n            }\r\n        }\r\n        // Compute tokens for tier 1\r\n        if(r1 > 0){\r\n            if(amount <= r1){\r\n                contributed1[addr] = contributed1[addr].add(amount);\r\n                return numTokens.add(rate1.mul(amount));\r\n            }\r\n            else{\r\n                numTokens = numTokens.add(rate1.mul(r1));\r\n                amount = amount.sub(r1);\r\n                contributed1[addr] = cap1[addr];\r\n            }\r\n        }\r\n        // Compute tokens for tier 4 (overflow)\r\n        contributed4[addr] = contributed4[addr].add(amount);\r\n        return numTokens.add(rate4.mul(amount));\r\n    }\r\n    /**\r\n     * @dev Check if a contributor was at any point registered.\r\n     *\r\n     * @param contributor Address that will be checked.\r\n     */\r\n    function hasPreviouslyRegistered(address contributor)\r\n        internal\r\n        constant\r\n        onlyOwner returns (bool)\r\n    {\r\n        // if caps for this customer exist, then the customer has previously been registered\r\n        return (cap1[contributor].add(cap2[contributor]).add(cap3[contributor]).add(cap4[contributor])) > 0;\r\n    }\r\n    /*\r\n    * If the user was already registered, ensure that the new caps do not conflict previous contributions\r\n    *\r\n    * NOTE: cannot use SafeMath here, because it exceeds the local variable stack limit.\r\n    * Should be ok since it is onlyOwner, and conditionals should guard the subtractions from underflow.\r\n    */\r\n    function validateUpdatedRegistration(address addr, uint c1, uint c2, uint c3, uint c4)\r\n        internal\r\n        constant\r\n        onlyOwner returns(bool)\r\n    {\r\n        return (contributed3[addr] <= c3) && (contributed2[addr] <= c2)\r\n            && (contributed1[addr] <= c1) && (contributed4[addr] <= c4);\r\n    }\r\n    /**\r\n     * @dev Sets registration status of an address for participation.\r\n     *\r\n     * @param contributor Address that will be registered/deregistered.\r\n     * @param c1 The maximum amount of wei that the user can contribute in tier 1.\r\n     * @param c2 The maximum amount of wei that the user can contribute in tier 2.\r\n     * @param c3 The maximum amount of wei that the user can contribute in tier 3.\r\n     * @param c4 The maximum amount of wei that the user can contribute in tier 4.\r\n     */\r\n    function registerUser(address contributor, uint c1, uint c2, uint c3, uint c4)\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(contributor != address(0));\r\n        // if the user was already registered ensure that the new caps do not contradict their current contributions\r\n        if(hasPreviouslyRegistered(contributor)){\r\n            require(validateUpdatedRegistration(contributor, c1, c2, c3, c4));\r\n        }\r\n        require(c1.add(c2).add(c3).add(c4) >= minContribution);\r\n        registry[contributor] = true;\r\n        cap1[contributor] = c1;\r\n        cap2[contributor] = c2;\r\n        cap3[contributor] = c3;\r\n        cap4[contributor] = c4;\r\n        RegistrationStatusChanged(contributor, true, c1, c2, c3, c4);\r\n    }\r\n     /**\r\n     * @dev Remove registration status of an address for participation.\r\n     *\r\n     * NOTE: if the user made initial contributions to the crowdsale,\r\n     *       this will not return the previously allotted tokens.\r\n     *\r\n     * @param contributor Address to be unregistered.\r\n     */\r\n    function deactivate(address contributor)\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(registry[contributor]);\r\n        registry[contributor] = false;\r\n        RegistrationStatusChanged(contributor, false, cap1[contributor], cap2[contributor], cap3[contributor], cap4[contributor]);\r\n    }\r\n    /**\r\n     * @dev Re-registers an already existing contributor\r\n     *\r\n     * @param contributor Address to be unregistered.\r\n     */\r\n    function reactivate(address contributor)\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(hasPreviouslyRegistered(contributor));\r\n        registry[contributor] = true;\r\n        RegistrationStatusChanged(contributor, true, cap1[contributor], cap2[contributor], cap3[contributor], cap4[contributor]);\r\n    }\r\n    /**\r\n     * @dev Sets registration statuses of addresses for participation.\r\n     * @param contributors Addresses that will be registered/deregistered.\r\n     * @param caps1 The maximum amount of wei that each user can contribute to cap1, in the same order as the addresses.\r\n     * @param caps2 The maximum amount of wei that each user can contribute to cap2, in the same order as the addresses.\r\n     * @param caps3 The maximum amount of wei that each user can contribute to cap3, in the same order as the addresses.\r\n     * @param caps4 The maximum amount of wei that each user can contribute to cap4, in the same order as the addresses.\r\n     */\r\n    function registerUsers(address[] contributors,\r\n                           uint[] caps1,\r\n                           uint[] caps2,\r\n                           uint[] caps3,\r\n                           uint[] caps4)\r\n        external\r\n        onlyOwner\r\n    {\r\n        // check that all arrays have the same length\r\n        require(contributors.length == caps1.length);\r\n        require(contributors.length == caps2.length);\r\n        require(contributors.length == caps3.length);\r\n        require(contributors.length == caps4.length);\r\n        for (uint i = 0; i < contributors.length; i++) {\r\n            registerUser(contributors[i], caps1[i], caps2[i], caps3[i], caps4[i]);\r\n        }\r\n    }\r\n    /**\r\n     * The owner can terminate the crowdsale at any time.\r\n     */\r\n    function terminate() external onlyOwner {\r\n        saleClosed = true;\r\n    }\r\n    /**\r\n     * The owner can allocate the specified amount of tokens from the\r\n     * crowdsale allowance to the recipient addresses.\r\n     *\r\n     * NOTE: be extremely careful to get the amounts correct, which\r\n     * are in units of wei and mini-QSP. Every digit counts.\r\n     *\r\n     * @param addrs          the recipient addresses\r\n     * @param weiAmounts     the amounts contributed in wei\r\n     * @param miniQspAmounts the amounts of tokens transferred in mini-QSP\r\n     */\r\n    function ownerAllocateTokensForList(address[] addrs, uint[] weiAmounts, uint[] miniQspAmounts)\r\n            external onlyOwner\r\n    {\r\n        require(addrs.length == weiAmounts.length);\r\n        require(addrs.length == miniQspAmounts.length);\r\n        for(uint i = 0; i < addrs.length; i++){\r\n            ownerAllocateTokens(addrs[i], weiAmounts[i], miniQspAmounts[i]);\r\n        }\r\n    }\r\n    /**\r\n     *\r\n     * The owner can allocate the specified amount of tokens from the\r\n     * crowdsale allowance to the recipient (_to).\r\n     *\r\n     *\r\n     *\r\n     * NOTE: be extremely careful to get the amounts correct, which\r\n     * are in units of wei and mini-QSP. Every digit counts.\r\n     *\r\n     * @param _to            the recipient of the tokens\r\n     * @param amountWei     the amount contributed in wei\r\n     * @param amountMiniQsp the amount of tokens transferred in mini-QSP\r\n     */\r\n    function ownerAllocateTokens(address _to, uint amountWei, uint amountMiniQsp)\r\n            onlyOwner nonReentrant\r\n    {\r\n        // don't allocate tokens for the admin\r\n        // require(tokenReward.adminAddr() != _to);\r\n        amountRaised = amountRaised.add(amountWei);\r\n        require(amountRaised <= fundingCap);\r\n        tokenBalanceOf[_to] = tokenBalanceOf[_to].add(amountMiniQsp);\r\n        balanceOf[_to] = balanceOf[_to].add(amountWei);\r\n        FundTransfer(_to, amountWei, true);\r\n        updateFundingCap();\r\n    }\r\n    /**\r\n     * The owner can call this function to withdraw the funds that\r\n     * have been sent to this contract for the crowdsale subject to\r\n     * the funding goal having been reached. The funds will be sent\r\n     * to the beneficiary specified when the crowdsale was created.\r\n     */\r\n    function ownerSafeWithdrawal() external onlyOwner nonReentrant {\r\n        uint balanceToSend = this.balance;\r\n        beneficiary.transfer(balanceToSend);\r\n        FundTransfer(beneficiary, balanceToSend, false);\r\n    }\r\n    /**\r\n     * Checks if the funding cap has been reached. If it has, then\r\n     * the CapReached event is triggered.\r\n     */\r\n    function updateFundingCap() internal {\r\n        assert (amountRaised <= fundingCap);\r\n        if (amountRaised == fundingCap) {\r\n            // Check if the funding cap has been reached\r\n            fundingCapReached = true;\r\n            saleClosed = true;\r\n            CapReached(beneficiary, amountRaised);\r\n        }\r\n    }\r\n    /**\r\n     * Returns the current time.\r\n     * Useful to abstract calls to \"now\" for tests.\r\n    */\r\n    function currentTime() constant returns (uint _currentTime) {\r\n        return now;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"registry\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"terminate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"cap1\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"contributed3\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"amountWei\",\"type\":\"uint256\"},{\"name\":\"amountMiniQsp\",\"type\":\"uint256\"}],\"name\":\"ownerAllocateTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"contributed2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contributor\",\"type\":\"address\"}],\"name\":\"deactivate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contributor\",\"type\":\"address\"},{\"name\":\"c1\",\"type\":\"uint256\"},{\"name\":\"c2\",\"type\":\"uint256\"},{\"name\":\"c3\",\"type\":\"uint256\"},{\"name\":\"c4\",\"type\":\"uint256\"}],\"name\":\"registerUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate4\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"ownerSafeWithdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amountRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingCapReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"cap4\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contributors\",\"type\":\"address[]\"},{\"name\":\"caps1\",\"type\":\"uint256[]\"},{\"name\":\"caps2\",\"type\":\"uint256[]\"},{\"name\":\"caps3\",\"type\":\"uint256[]\"},{\"name\":\"caps4\",\"type\":\"uint256[]\"}],\"name\":\"registerUsers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"cap3\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minContribution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate3\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"contributed4\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"contributed1\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleClosed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate1\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentTime\",\"outputs\":[{\"name\":\"_currentTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[]\"},{\"name\":\"weiAmounts\",\"type\":\"uint256[]\"},{\"name\":\"miniQspAmounts\",\"type\":\"uint256[]\"}],\"name\":\"ownerAllocateTokensForList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"cap2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contributor\",\"type\":\"address\"}],\"name\":\"reactivate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"ifSuccessfulSendTo\",\"type\":\"address\"},{\"name\":\"fundingCapInEthers\",\"type\":\"uint256\"},{\"name\":\"minimumContributionInWei\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"durationInMinutes\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amountRaised\",\"type\":\"uint256\"}],\"name\":\"CapReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_backer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_isContribution\",\"type\":\"bool\"}],\"name\":\"FundTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"isRegistered\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"c1\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"c2\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"c3\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"c4\",\"type\":\"uint256\"}],\"name\":\"RegistrationStatusChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"QuantstampSale","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000022e9c5643d6db3aa4163ae80fca9241315214a370000000000000000000000000000000000000000000000000000000000015e14000000000000000000000000000000000000000000000000016345785d8a0000000000000000000000000000000000000000000000000000000000005a01bc6000000000000000000000000000000000000000000000000000000000000010e0","Library":"","SwarmSource":"bzzr://53e60d0cdc0b947f88f7cf04b69b1c958b0e117e4bbbfdd9b56062cf4818a7ea"}]}