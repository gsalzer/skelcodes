{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.15;\r\n\r\ncontract Token {\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n}\r\n\r\ncontract Versionable {\r\n    string public versionCode;\r\n\r\n    function getVersionByte(uint index) constant returns (bytes1) { \r\n        return bytes(versionCode)[index];\r\n    }\r\n\r\n    function getVersionLength() constant returns (uint256) {\r\n        return bytes(versionCode).length;\r\n    }\r\n}\r\n\r\ncontract ContractCatalog {\r\n    uint256 public constant VERSION = 1;\r\n    string public constant SEPARATOR = \"-\";\r\n\r\n    Token public token;\r\n    address public owner;\r\n    \r\n    event RegisteredPrefix(string _prefix, address _owner);\r\n    event TransferredPrefix(string _prefix, address _from, address _to);\r\n    event UnregisteredPrefix(string _prefix, address _from);\r\n    event NewPrefixPrice(uint256 _length, uint256 _price);\r\n    event RegisteredContract(string _version, address _by);\r\n    \r\n    struct ContractType {\r\n        string code;\r\n        bytes bytecode;\r\n    }\r\n\r\n    function ContractCatalog() {\r\n        token = Token(address(0xF970b8E36e23F7fC3FD752EeA86f8Be8D83375A6));\r\n        owner = address(0xA1091481AEde4adDe00C1a26992AE49a7e0E1FB0);\r\n\r\n        // Set up all forgived chars\r\n        addForgivedChar(\" \");\r\n        addForgivedChar(\"‐\");\r\n        addForgivedChar(\"‑\");\r\n        addForgivedChar(\"‒\");\r\n        addForgivedChar(\"–\");\r\n        addForgivedChar(\"﹘\");\r\n        addForgivedChar(\"۔\");\r\n        addForgivedChar(\"⁃\");\r\n        addForgivedChar(\"˗\");\r\n        addForgivedChar(\"−\");\r\n        addForgivedChar(\"➖\");\r\n        addForgivedChar(\"Ⲻ\");\r\n    }\r\n\r\n    mapping(string => ContractType) types;\r\n    mapping(string => address) prefixes;\r\n    mapping(uint256 => uint256) prefixesPrices;\r\n\r\n    string[] private forgivedChars;\r\n\r\n    function transfer(address to) {\r\n        require(to != address(0));\r\n        require(msg.sender == owner);\r\n        owner = to;\r\n    }\r\n\r\n    function replaceToken(Token _token) {\r\n        require(_token != address(0));\r\n        require(msg.sender == owner);\r\n        token = _token;\r\n    }\r\n\r\n    function setPrefixPrice(uint256 lenght, uint256 price) {\r\n        require(msg.sender == owner);\r\n        require(lenght != 0);\r\n        prefixesPrices[lenght] = price;\r\n        NewPrefixPrice(lenght, price);\r\n    }\r\n\r\n    function loadVersion(Versionable from) constant returns (string) {\r\n        uint size = from.getVersionLength();\r\n        bytes memory out = new bytes(size);\r\n        for (uint i = 0; i < size; i++) {\r\n            out[i] = from.getVersionByte(i);\r\n        }\r\n        return string(out);\r\n    }\r\n\r\n    function getContractOwner(string code) constant returns (address) {\r\n        string memory prefix = splitFirst(code, \"-\");\r\n        return prefixes[prefix];\r\n    }\r\n\r\n    function getContractBytecode(string code) constant returns (bytes) {\r\n        return types[code].bytecode;\r\n    }\r\n\r\n    function hasForgivedChar(string s) constant returns (bool) {\r\n        for (uint i = 0; i < forgivedChars.length; i++) {\r\n            if (stringContains(s, forgivedChars[i]))\r\n                return true;\r\n        }\r\n    }\r\n\r\n    function addForgivedChar(string c) {\r\n        require(msg.sender == owner || msg.sender == address(this));\r\n        if (!hasForgivedChar(c)) {\r\n            forgivedChars.push(c);\r\n        }\r\n    }\r\n\r\n    function removeForgivedChar(uint256 index, string char) {\r\n        require(msg.sender == owner);\r\n        require(stringEquals(char, forgivedChars[index]));\r\n        string storage lastChar = forgivedChars[forgivedChars.length - 1];\r\n        delete forgivedChars[forgivedChars.length - 1];\r\n        forgivedChars[index] = lastChar;\r\n    }\r\n\r\n    function registerPrefix(string prefix) returns (bool) {\r\n        require(!stringContains(prefix, SEPARATOR));\r\n        require(!hasForgivedChar(prefix));\r\n        require(prefixes[prefix] == address(0));\r\n        if (msg.sender == owner) {\r\n            prefixes[prefix] = owner;\r\n            return true;\r\n        } else {\r\n            uint256 price = prefixesPrices[stringLen(prefix)];\r\n            require(price != 0);\r\n            require(token.transferFrom(msg.sender, owner, price));\r\n            prefixes[prefix] = owner;\r\n            return true;\r\n        }\r\n        RegisteredPrefix(prefix, msg.sender);\r\n    }\r\n\r\n    function transferPrefix(string prefix, address to) {\r\n        require(to != address(0));\r\n        require(prefixes[prefix] == msg.sender);\r\n        prefixes[prefix] = to;\r\n        TransferredPrefix(prefix, msg.sender, to);\r\n    }\r\n\r\n    function unregisterPrefix(string prefix) {\r\n        require(prefixes[prefix] == msg.sender);\r\n        prefixes[prefix] == address(0);\r\n        UnregisteredPrefix(prefix, msg.sender);\r\n    }\r\n\r\n    function registerContract(string code, bytes bytecode) {\r\n        var prefix = splitFirst(code, SEPARATOR);\r\n        require(prefixes[prefix] == msg.sender);\r\n        require(types[code].bytecode.length == 0);\r\n        require(bytecode.length != 0);\r\n        types[code] = ContractType(code, bytecode);\r\n        RegisteredContract(code, msg.sender);\r\n    }\r\n\r\n    function validateContract(Versionable target) constant returns (bool) {\r\n        return validateContractWithCode(target, loadVersion(target));\r\n    }\r\n\r\n    function validateContractWithCode(address target, string code) constant returns (bool) {\r\n        require(stringEquals(types[code].code, code)); // Sanity check\r\n        bytes memory expected = types[code].bytecode;\r\n        bytes memory bytecode = getContractCode(target);\r\n        if (bytecode.length != expected.length) return false;\r\n        for (uint i = 0; i < expected.length; i++) {\r\n            if (bytecode[i] != expected[i]) return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function getContractCode(address _addr) constant returns (bytes o_code) {\r\n        assembly {\r\n          let size := extcodesize(_addr)\r\n          o_code := mload(0x40)\r\n          mstore(0x40, add(o_code, and(add(add(size, 0x20), 0x1f), not(0x1f))))\r\n          mstore(o_code, size)\r\n          extcodecopy(_addr, add(o_code, 0x20), 0, size)\r\n        }\r\n    }\r\n\r\n    // @dev Returns the first slice of a split\r\n    function splitFirst(string source, string point) constant returns (string) {\r\n        bytes memory s = bytes(source);\r\n        if (s.length == 0) {\r\n            return \"\";\r\n        } else {\r\n            int index = stringIndexOf(source, point);\r\n            if (index == - 1) {\r\n                return \"\";\r\n            } else {\r\n                bytes memory output = new bytes(uint(index));\r\n                for (int i = 0; i < index; i++) {\r\n                    output[uint(i)] = s[uint(i)];\r\n                }\r\n                return string(output);\r\n            }\r\n        }\r\n    }\r\n\r\n    function stringToBytes32(string memory source) returns (bytes32 result) {\r\n        assembly {\r\n            result := mload(add(source, 32))\r\n        }\r\n    }\r\n\r\n        /*\r\n     * @dev Returns the length of a null-terminated bytes32 string.\r\n     * @param self The value to find the length of.\r\n     * @return The length of the string, from 0 to 32.\r\n     */\r\n    function stringLen(string s) internal returns (uint) {\r\n        var self = stringToBytes32(s);\r\n        uint ret;\r\n        if (self == 0)\r\n            return 0;\r\n        if (self & 0xffffffffffffffffffffffffffffffff == 0) {\r\n            ret += 16;\r\n            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\r\n        }\r\n        if (self & 0xffffffffffffffff == 0) {\r\n            ret += 8;\r\n            self = bytes32(uint(self) / 0x10000000000000000);\r\n        }\r\n        if (self & 0xffffffff == 0) {\r\n            ret += 4;\r\n            self = bytes32(uint(self) / 0x100000000);\r\n        }\r\n        if (self & 0xffff == 0) {\r\n            ret += 2;\r\n            self = bytes32(uint(self) / 0x10000);\r\n        }\r\n        if (self & 0xff == 0) {\r\n            ret += 1;\r\n        }\r\n        return 32 - ret;\r\n    }\r\n\r\n    /// @dev Finds the index of the first occurrence of _needle in _haystack\r\n    function stringIndexOf(string _haystack, string _needle) returns (int) {\r\n    \tbytes memory h = bytes(_haystack);\r\n    \tbytes memory n = bytes(_needle);\r\n    \tif (h.length < 1 || n.length < 1 || (n.length > h.length)) {\r\n    \t\treturn -1;\r\n    \t} else if (h.length > (2**128 - 1)) { // since we have to be able to return -1 (if the char isn't found or input error), this function must return an \"int\" type with a max length of (2^128 - 1)\r\n    \t\treturn -1;\t\t\t\t\t\t\t\t\t\r\n    \t} else {\r\n    \t\tuint subindex = 0;\r\n    \t\tfor (uint i = 0; i < h.length; i ++) {\r\n    \t\t\tif (h[i] == n[0]) { // found the first char of b\r\n    \t\t\t\tsubindex = 1;\r\n    \t\t\t\twhile (subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex]) { // search until the chars don't match or until we reach the end of a or b\r\n    \t\t\t\t\tsubindex++;\r\n    \t\t\t\t}\t\r\n    \t\t\t\tif (subindex == n.length)\r\n    \t\t\t\t\treturn int(i);\r\n    \t\t\t}\r\n    \t\t}\r\n    \t\treturn -1;\r\n    \t}\t\r\n    }\r\n\r\n    function stringEquals(string _a, string _b) returns (bool) {\r\n    \tbytes memory a = bytes(_a);\r\n    \tbytes memory b = bytes(_b);\r\n        if (a.length != b.length) return false;\r\n        for (uint i = 0; i < a.length; i++) {\r\n            if (a[i] != b[i]) return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function stringContains(string self, string needle) returns (bool) {\r\n        return stringIndexOf(self, needle) != int(-1);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"char\",\"type\":\"string\"}],\"name\":\"removeForgivedChar\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"code\",\"type\":\"string\"}],\"name\":\"validateContractWithCode\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"s\",\"type\":\"string\"}],\"name\":\"hasForgivedChar\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getContractCode\",\"outputs\":[{\"name\":\"o_code\",\"type\":\"bytes\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"}],\"name\":\"loadVersion\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"}],\"name\":\"validateContract\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SEPARATOR\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"code\",\"type\":\"string\"},{\"name\":\"bytecode\",\"type\":\"bytes\"}],\"name\":\"registerContract\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"c\",\"type\":\"string\"}],\"name\":\"addForgivedChar\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"code\",\"type\":\"string\"}],\"name\":\"getContractBytecode\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"prefix\",\"type\":\"string\"}],\"name\":\"unregisterPrefix\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"prefix\",\"type\":\"string\"},{\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferPrefix\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"source\",\"type\":\"string\"},{\"name\":\"point\",\"type\":\"string\"}],\"name\":\"splitFirst\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"lenght\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"setPrefixPrice\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"prefix\",\"type\":\"string\"}],\"name\":\"registerPrefix\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"code\",\"type\":\"string\"}],\"name\":\"getContractOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_haystack\",\"type\":\"string\"},{\"name\":\"_needle\",\"type\":\"string\"}],\"name\":\"stringIndexOf\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"replaceToken\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"source\",\"type\":\"string\"}],\"name\":\"stringToBytes32\",\"outputs\":[{\"name\":\"result\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"string\"},{\"name\":\"needle\",\"type\":\"string\"}],\"name\":\"stringContains\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_a\",\"type\":\"string\"},{\"name\":\"_b\",\"type\":\"string\"}],\"name\":\"stringEquals\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_prefix\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"RegisteredPrefix\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_prefix\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"TransferredPrefix\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_prefix\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"UnregisteredPrefix\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_length\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"NewPrefixPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_version\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_by\",\"type\":\"address\"}],\"name\":\"RegisteredContract\",\"type\":\"event\"}]","ContractName":"ContractCatalog","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://7e9739c4fa3c769a5d2ccd517587c49db8023ee6d111e96d8b53b296043750a6"}]}