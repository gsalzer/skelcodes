{"status":"1","message":"OK","result":[{"SourceCode":"//A BurnableOpenPayment is instantiated with a specified payer and a serviceDeposit.\r\n//The worker is not set when the contract is instantiated.\r\n\r\n//The constructor is payable, so the contract can be instantiated with initial funds.\r\n//In addition, anyone can add more funds to the Payment by calling addFunds.\r\n\r\n//All behavior of the contract is directed by the payer, but\r\n//the payer can never directly recover the payment,\r\n//unless he calls the recover() function before anyone else commit()s.\r\n\r\n//If the BOP is in the Open state,\r\n//anyone can become the worker by contributing the serviceDeposit with commit().\r\n//This changes the state from Open to Committed. The BOP will never return to the Open state.\r\n//The worker will never be changed once it's been set via commit().\r\n\r\n//In the committed state,\r\n//the payer can at any time choose to burn or release to the worker any amount of funds.\r\n\r\npragma solidity ^ 0.4.10;\r\ncontract BurnableOpenPaymentFactory {\r\n\tevent NewBOP(address indexed newBOPAddress, address payer, uint serviceDeposit, uint autoreleaseTime, string title, string initialStatement);\r\n\r\n\t//contract address array\r\n\taddress[]public BOPs;\r\n\r\n\tfunction getBOPCount()\r\n\tpublic\r\n\tconstant\r\n\treturns(uint) {\r\n\t\treturn BOPs.length;\r\n\t}\r\n\r\n\tfunction newBurnableOpenPayment(address payer, uint serviceDeposit, uint autoreleaseInterval, string title, string initialStatement)\r\n\tpublic\r\n\tpayable\r\n\treturns(address) {\r\n\t\t//pass along any ether to the constructor\r\n\t\taddress newBOPAddr = (new BurnableOpenPayment).value(msg.value)(payer, serviceDeposit, autoreleaseInterval, title, initialStatement);\r\n\t\tNewBOP(newBOPAddr, payer, serviceDeposit, autoreleaseInterval, title, initialStatement);\r\n\r\n\t\t//save created BOPs in contract array\r\n\t\tBOPs.push(newBOPAddr);\r\n\r\n\t\treturn newBOPAddr;\r\n\t}\r\n}\r\n\r\ncontract BurnableOpenPayment {\r\n    //title will never change\r\n    string public title;\r\n    \r\n\t//BOP will start with a payer but no worker (worker==0x0)\r\n\taddress public payer;\r\n\taddress public worker;\r\n\taddress constant burnAddress = 0x0;\r\n\t\r\n\t//Set to true if fundsRecovered is called\r\n\tbool recovered = false;\r\n\r\n\t//Note that these will track, but not influence the BOP logic.\r\n\tuint public amountDeposited;\r\n\tuint public amountBurned;\r\n\tuint public amountReleased;\r\n\r\n\t//Amount of ether a prospective worker must pay to permanently become the worker. See commit().\r\n\tuint public serviceDeposit;\r\n\r\n\t//How long should we wait before allowing the default release to be called?\r\n\tuint public autoreleaseInterval;\r\n\r\n\t//Calculated from autoreleaseInterval in commit(),\r\n\t//and recaluclated whenever the payer (or possibly the worker) calls delayhasDefaultRelease()\r\n\t//After this time, auto-release can be called by the Worker.\r\n\tuint public autoreleaseTime;\r\n\r\n\t//Most action happens in the Committed state.\r\n\tenum State {\r\n\t\tOpen,\r\n\t\tCommitted,\r\n\t\tClosed\r\n\t}\r\n\tState public state;\r\n\t//Note that a BOP cannot go from Committed back to Open, but it can go from Closed back to Committed\r\n\t//(this would retain the committed worker). Search for Closed and Unclosed events to see how this works.\r\n\r\n\tmodifier inState(State s) {\r\n\t\trequire(s == state);\r\n\t\t_;\r\n\t}\r\n\tmodifier onlyPayer() {\r\n\t\trequire(msg.sender == payer);\r\n\t\t_;\r\n\t}\r\n\tmodifier onlyWorker() {\r\n\t\trequire(msg.sender == worker);\r\n\t\t_;\r\n\t}\r\n\tmodifier onlyPayerOrWorker() {\r\n\t\trequire((msg.sender == payer) || (msg.sender == worker));\r\n\t\t_;\r\n\t}\r\n\r\n\tevent Created(address indexed contractAddress, address payer, uint serviceDeposit, uint autoreleaseInterval, string title);\r\n\tevent FundsAdded(address from, uint amount); //The payer has added funds to the BOP.\r\n\tevent PayerStatement(string statement);\r\n\tevent WorkerStatement(string statement);\r\n\tevent FundsRecovered();\r\n\tevent Committed(address worker);\r\n\tevent FundsBurned(uint amount);\r\n\tevent FundsReleased(uint amount);\r\n\tevent Closed();\r\n\tevent Unclosed();\r\n\tevent AutoreleaseDelayed();\r\n\tevent AutoreleaseTriggered();\r\n\r\n\tfunction BurnableOpenPayment(address _payer, uint _serviceDeposit, uint _autoreleaseInterval, string _title, string initialStatement)\r\n\tpublic\r\n\tpayable {\r\n\t\tCreated(this, _payer, _serviceDeposit, _autoreleaseInterval, _title);\r\n\r\n\t\tif (msg.value > 0) {\r\n\t\t    //Here we use tx.origin instead of msg.sender (msg.sender is just the factory contract)\r\n\t\t\tFundsAdded(tx.origin, msg.value);\r\n\t\t\tamountDeposited += msg.value;\r\n\t\t}\r\n\t\t\r\n\t\ttitle = _title;\r\n\r\n\t\tstate = State.Open;\r\n\t\tpayer = _payer;\r\n\r\n\t\tserviceDeposit = _serviceDeposit;\r\n\r\n\t\tautoreleaseInterval = _autoreleaseInterval;\r\n\r\n\t\tif (bytes(initialStatement).length > 0)\r\n\t\t    PayerStatement(initialStatement);\r\n\t}\r\n\r\n\tfunction getFullState()\r\n\tpublic\r\n\tconstant\r\n\treturns(address, string, State, address, uint, uint, uint, uint, uint, uint, uint) {\r\n\t\treturn (payer, title, state, worker, this.balance, serviceDeposit, amountDeposited, amountBurned, amountReleased, autoreleaseInterval, autoreleaseTime);\r\n\t}\r\n\r\n\tfunction addFunds()\r\n\tpublic\r\n\tpayable {\r\n\t\trequire(msg.value > 0);\r\n\r\n\t\tFundsAdded(msg.sender, msg.value);\r\n\t\tamountDeposited += msg.value;\r\n\t\tif (state == State.Closed) {\r\n\t\t\tstate = State.Committed;\r\n\t\t\tUnclosed();\r\n\t\t}\r\n\t}\r\n\r\n\tfunction recoverFunds()\r\n\tpublic\r\n\tonlyPayer()\r\n\tinState(State.Open) {\r\n\t    recovered = true;\r\n\t\tFundsRecovered();\r\n\t\tselfdestruct(payer);\r\n\t}\r\n\r\n\tfunction commit()\r\n\tpublic\r\n\tinState(State.Open)\r\n\tpayable{\r\n\t\trequire(msg.value == serviceDeposit);\r\n\r\n\t\tif (msg.value > 0) {\r\n\t\t\tFundsAdded(msg.sender, msg.value);\r\n\t\t\tamountDeposited += msg.value;\r\n\t\t}\r\n\r\n\t\tworker = msg.sender;\r\n\t\tstate = State.Committed;\r\n\t\tCommitted(worker);\r\n\r\n\t\tautoreleaseTime = now + autoreleaseInterval;\r\n\t}\r\n\r\n\tfunction internalBurn(uint amount)\r\n\tprivate\r\n\tinState(State.Committed) {\r\n\t\tburnAddress.transfer(amount);\r\n\r\n\t\tamountBurned += amount;\r\n\t\tFundsBurned(amount);\r\n\r\n\t\tif (this.balance == 0) {\r\n\t\t\tstate = State.Closed;\r\n\t\t\tClosed();\r\n\t\t}\r\n\t}\r\n\r\n\tfunction burn(uint amount)\r\n\tpublic\r\n\tinState(State.Committed)\r\n\tonlyPayer() {\r\n\t\tinternalBurn(amount);\r\n\t}\r\n\r\n\tfunction internalRelease(uint amount)\r\n\tprivate\r\n\tinState(State.Committed) {\r\n\t\tworker.transfer(amount);\r\n\r\n\t\tamountReleased += amount;\r\n\t\tFundsReleased(amount);\r\n\r\n\t\tif (this.balance == 0) {\r\n\t\t\tstate = State.Closed;\r\n\t\t\tClosed();\r\n\t\t}\r\n\t}\r\n\r\n\tfunction release(uint amount)\r\n\tpublic\r\n\tinState(State.Committed)\r\n\tonlyPayer() {\r\n\t\tinternalRelease(amount);\r\n\t}\r\n\r\n\tfunction logPayerStatement(string statement)\r\n\tpublic\r\n\tonlyPayer() {\r\n\t    PayerStatement(statement);\r\n\t}\r\n\r\n\tfunction logWorkerStatement(string statement)\r\n\tpublic\r\n\tonlyWorker() {\r\n\t\tWorkerStatement(statement);\r\n\t}\r\n\r\n\tfunction delayAutorelease()\r\n\tpublic\r\n\tonlyPayer()\r\n\tinState(State.Committed) {\r\n\t\tautoreleaseTime = now + autoreleaseInterval;\r\n\t\tAutoreleaseDelayed();\r\n\t}\r\n\r\n\tfunction triggerAutorelease()\r\n\tpublic\r\n\tonlyWorker()\r\n\tinState(State.Committed) {\r\n\t\trequire(now >= autoreleaseTime);\r\n\r\n        AutoreleaseTriggered();\r\n\t\tinternalRelease(this.balance);\r\n\t}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"BOPs\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBOPCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"payer\",\"type\":\"address\"},{\"name\":\"serviceDeposit\",\"type\":\"uint256\"},{\"name\":\"autoreleaseInterval\",\"type\":\"uint256\"},{\"name\":\"title\",\"type\":\"string\"},{\"name\":\"initialStatement\",\"type\":\"string\"}],\"name\":\"newBurnableOpenPayment\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newBOPAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"payer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"serviceDeposit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"autoreleaseTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"title\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"initialStatement\",\"type\":\"string\"}],\"name\":\"NewBOP\",\"type\":\"event\"}]","ContractName":"BurnableOpenPaymentFactory","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://2b07e6c269575f7eed6e2631b6a96ea392825c6df1d91e604316b0dd32f5dae9"}]}