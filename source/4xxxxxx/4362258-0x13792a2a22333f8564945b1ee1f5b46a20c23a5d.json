{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n/**\r\n * Eloplay Crowdsale Token Contract\r\n * @author Eloplay team (2017)\r\n * The MIT Licence\r\n */\r\n\r\n\r\n/**\r\n * Safe maths, borrowed from OpenZeppelin\r\n * https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n     * Add a number to another number, checking for overflows\r\n     *\r\n     * @param a           first number\r\n     * @param b           second number\r\n     * @return            sum of a + b\r\n     */\r\n     function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n     }\r\n\r\n    /**\r\n     * Subtract a number from another number, checking for underflows\r\n     *\r\n     * @param a           first number\r\n     * @param b           second number\r\n     * @return            a - b\r\n     */\r\n    function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * Owned contract gives ownership checking\r\n */\r\ncontract Owned {\r\n\r\n    /**\r\n     * Current contract owner\r\n     */\r\n    address public owner;\r\n    /**\r\n     * New owner / pretender\r\n     */\r\n    address public newOwner;\r\n\r\n    /**\r\n     * Event fires when ownership is transferred and accepted\r\n     *\r\n     * @param _from         initial owner\r\n     * @param _to           new owner\r\n     */\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    /**\r\n     * Owned contract constructor\r\n     */\r\n    function Owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * Modifier - used to check actions allowed only for contract owner\r\n     */\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Request to change ownership (called by current owner)\r\n     *\r\n     * @param _newOwner         address to transfer ownership to\r\n     */\r\n    function transferOwnership(address _newOwner) onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    /**\r\n     * Accept ownership request, works only if called by new owner\r\n     */\r\n    function acceptOwnership() {\r\n        // Avoid multiple events triggering in case of several calls from owner\r\n        if (msg.sender == newOwner && owner != newOwner) {\r\n            OwnershipTransferred(owner, newOwner);\r\n            owner = newOwner;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * ERC20 Token, with the addition of symbol, name and decimals\r\n * https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20Token {\r\n    /**\r\n     * Use SafeMath to check over/underflows\r\n     */\r\n    using SafeMath for uint;\r\n\r\n    /**\r\n     * Total Supply\r\n     */\r\n    uint256 public totalSupply = 0;\r\n\r\n    /**\r\n     * Balances for each account\r\n     */\r\n    mapping(address => uint256) public balanceOf;\r\n\r\n    /**\r\n     * Owner of account approves the transfer of an amount to another account\r\n     */\r\n    mapping(address => mapping (address => uint256)) public allowance;\r\n\r\n    /**\r\n     * Event fires when tokens are transferred\r\n     *\r\n     * @param _from         spender address\r\n     * @param _to           target address\r\n     * @param _value        amount of tokens\r\n     */\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n    /**\r\n     * Event fires when spending of tokens are approved\r\n     *\r\n     * @param _owner        owner address\r\n     * @param _spender      spender address\r\n     * @param _value        amount of allowed tokens\r\n     */\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    /**\r\n     * Transfer the balance from owner's account to another account\r\n     *\r\n     * @param _to         target address\r\n     * @param _amount     amount of tokens\r\n     * @return            true on success\r\n     */\r\n    function transfer(address _to, uint256 _amount) returns (bool success) {\r\n        if (balanceOf[msg.sender] >= _amount                // User has balance\r\n            && _amount > 0                                 // Non-zero transfer\r\n            && balanceOf[_to] + _amount > balanceOf[_to]     // Overflow check\r\n        ) {\r\n            balanceOf[msg.sender] -= _amount;\r\n            balanceOf[_to] += _amount;\r\n            Transfer(msg.sender, _to, _amount);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Allow _spender to withdraw from your account, multiple times, up to the\r\n     * _value amount. If this function is called again it overwrites the\r\n     * current allowance with _value.\r\n     *\r\n     * @param _spender    spender address\r\n     * @param _amount     amount of tokens\r\n     * @return            true on success\r\n     */\r\n    function approve(address _spender, uint256 _amount) returns (bool success) {\r\n        allowance[msg.sender][_spender] = _amount;\r\n        Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Spender of tokens transfer an amount of tokens from the token owner's\r\n     * balance to the spender's account. The owner of the tokens must already\r\n     * have approve(...)-d this transfer\r\n     *\r\n     * @param _from       spender address\r\n     * @param _to         target address\r\n     * @param _amount     amount of tokens\r\n     * @return            true on success\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _amount) returns (bool success) {\r\n        if (balanceOf[_from] >= _amount                  // From a/c has balance\r\n            && allowance[_from][msg.sender] >= _amount    // Transfer approved\r\n            && _amount > 0                              // Non-zero transfer\r\n            && balanceOf[_to] + _amount > balanceOf[_to]  // Overflow check\r\n        ) {\r\n            balanceOf[_from] -= _amount;\r\n            allowance[_from][msg.sender] -= _amount;\r\n            balanceOf[_to] += _amount;\r\n            Transfer(_from, _to, _amount);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract EloPlayToken is ERC20Token, Owned {\r\n\r\n    /**\r\n     * Token data\r\n     */\r\n    string public constant symbol = \"ELT\";\r\n    string public constant name = \"EloPlayToken\";\r\n    uint8 public constant decimals = 18;\r\n\r\n    /**\r\n     * Wallet where invested Ethers will be sent\r\n     */\r\n    address public TARGET_ADDRESS;\r\n\r\n    /**\r\n     * Wallet where bonus tokens will be sent\r\n     */\r\n    address public TARGET_TOKENS_ADDRESS;\r\n\r\n    /**\r\n     * Start/end timestamp (unix)\r\n     */\r\n    uint256 public START_TS;\r\n    uint256 public END_TS;\r\n\r\n    /**\r\n     * CAP in ether - may be changed before crowdsale starts to match actual ETH/USD rate\r\n     */\r\n    uint256 public CAP;\r\n\r\n    /**\r\n     * Usd/eth rate at start of ICO. Used for raised funds calculations\r\n     */\r\n    uint256 public USDETHRATE;\r\n\r\n    /**\r\n     * Is contract halted (in case of emergency)\r\n     * Default value will be false (not halted)\r\n     */\r\n    bool public halted;\r\n\r\n    /**\r\n     * Total Ethers invested\r\n     */\r\n    uint256 public totalEthers;\r\n\r\n    /**\r\n     * Event fires when tokens are bought\r\n     *\r\n     * @param buyer                     tokens buyer\r\n     * @param ethers                    total Ethers invested (in wei)\r\n     * @param new_ether_balance         new Ethers balance (in wei)\r\n     * @param tokens                    tokens bought for transaction\r\n     * @param target_address_tokens     additional tokens generated for multisignature wallet\r\n     * @param new_total_supply          total tokens bought\r\n     * @param buy_price                 tokens/ETH rate for transaction\r\n     */\r\n    event TokensBought(address indexed buyer, uint256 ethers,\r\n        uint256 new_ether_balance, uint256 tokens, uint256 target_address_tokens,\r\n        uint256 new_total_supply, uint256 buy_price);\r\n\r\n    /**\r\n     * EloPlayToken contract constructor\r\n     *\r\n     * @param _start_ts         crowdsale start timestamp (unix)\r\n     * @param _end_ts           crowdsale end timestamp (unix)\r\n     * @param _cap              crowdsale upper cap (in wei)\r\n     * @param _target_address   multisignature wallet where Ethers will be sent to\r\n     * @param _target_tokens_address   account where 30% of tokens will be sent to\r\n     * @param _usdethrate       USD to ETH rate\r\n     */\r\n    function EloPlayToken(uint256 _start_ts, uint256 _end_ts, uint256 _cap, address _target_address,  address _target_tokens_address, uint256 _usdethrate) {\r\n        START_TS        = _start_ts;\r\n        END_TS          = _end_ts;\r\n        CAP             = _cap;\r\n        USDETHRATE      = _usdethrate;\r\n        TARGET_ADDRESS  = _target_address;\r\n        TARGET_TOKENS_ADDRESS  = _target_tokens_address;\r\n    }\r\n\r\n    /**\r\n     * Update cap before crowdsale starts\r\n     *\r\n     * @param _cap          new crowdsale upper cap (in wei)\r\n     * @param _usdethrate   USD to ETH rate\r\n     */\r\n    function updateCap(uint256 _cap, uint256 _usdethrate) onlyOwner {\r\n        // Don't process if halted\r\n        require(!halted);\r\n        // Make sure crowdsale isnt started yet\r\n        require(now < START_TS);\r\n        CAP = _cap;\r\n        USDETHRATE = _usdethrate;\r\n    }\r\n\r\n    /**\r\n     * Get raised USD based on USDETHRATE\r\n     *\r\n     * @return            USD raised value\r\n     */\r\n    function totalUSD() constant returns (uint256) {\r\n        return totalEthers * USDETHRATE;\r\n    }\r\n\r\n    /**\r\n     * Get tokens per ETH for current date/time\r\n     *\r\n     * @return            current tokens/ETH rate\r\n     */\r\n    function buyPrice() constant returns (uint256) {\r\n        return buyPriceAt(now);\r\n    }\r\n\r\n    /**\r\n     * Get tokens per ETH for given date/time\r\n     *\r\n     * @param _at         timestamp (unix)\r\n     * @return            tokens/ETH rate for given timestamp\r\n     */\r\n    function buyPriceAt(uint256 _at) constant returns (uint256) {\r\n        if (_at < START_TS) {\r\n            return 0;\r\n        } else if (_at < START_TS + 3600) {\r\n            // 1st hour = 10000 + 20% = 12000\r\n            return 12000;\r\n        } else if (_at < START_TS + 3600 * 24) {\r\n            // 1st day = 10000 + 15% = 11500\r\n            return 11500;\r\n        } else if (_at < START_TS + 3600 * 24 * 7) {\r\n            // 1st week = 10000 + 10% = 11000\r\n            return 11000;\r\n        } else if (_at < START_TS + 3600 * 24 * 7 * 2) {\r\n            // 2nd week = 10000 + 5% = 10500\r\n            return 10500;\r\n        } else if (_at <= END_TS) {\r\n            // More than 2 weeks = 10000\r\n            return 10000;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Halt transactions in case of emergency\r\n     */\r\n    function halt() onlyOwner {\r\n        require(!halted);\r\n        halted = true;\r\n    }\r\n\r\n    /**\r\n     * Unhalt halted contract\r\n     */\r\n    function unhalt() onlyOwner {\r\n        require(halted);\r\n        halted = false;\r\n    }\r\n\r\n    /**\r\n     * Owner to add precommitment funding token balance before the crowdsale commences\r\n     * Used for pre-sale commitments, added manually\r\n     *\r\n     * @param _participant         address that will receive tokens\r\n     * @param _balance             number of tokens\r\n     * @param _ethers         Ethers value (needed for stats)\r\n     *\r\n     */\r\n    function addPrecommitment(address _participant, uint256 _balance, uint256 _ethers) onlyOwner {\r\n        require(now < START_TS);\r\n        // Minimum value = 1ELT\r\n        // Since we are using 18 decimals for token\r\n        require(_balance >= 1 ether);\r\n\r\n        // To avoid overflow, first divide then multiply (to clearly show 70%+30%, result wasn't precalculated)\r\n        uint additional_tokens = _balance / 70 * 30;\r\n\r\n        balanceOf[_participant] = balanceOf[_participant].add(_balance);\r\n        balanceOf[TARGET_TOKENS_ADDRESS] = balanceOf[TARGET_TOKENS_ADDRESS].add(additional_tokens);\r\n\r\n        totalSupply = totalSupply.add(_balance);\r\n        totalSupply = totalSupply.add(additional_tokens);\r\n\r\n        // Add ETH raised to total\r\n        totalEthers = totalEthers.add(_ethers);\r\n\r\n        Transfer(0x0, _participant, _balance);\r\n        Transfer(0x0, TARGET_TOKENS_ADDRESS, additional_tokens);\r\n    }\r\n\r\n    /**\r\n     * Buy tokens from the contract\r\n     */\r\n    function () payable {\r\n        proxyPayment(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * Exchanges can buy on behalf of participant\r\n     *\r\n     * @param _participant         address that will receive tokens\r\n     */\r\n    function proxyPayment(address _participant) payable {\r\n        // Don't process if halted\r\n        require(!halted);\r\n        // No contributions before the start of the crowdsale\r\n        require(now >= START_TS);\r\n        // No contributions after the end of the crowdsale\r\n        require(now <= END_TS);\r\n        // No contributions after CAP is reached\r\n        require(totalEthers < CAP);\r\n        // Require 0.1 eth minimum\r\n        require(msg.value >= 0.1 ether);\r\n\r\n        // Add ETH raised to total\r\n        totalEthers = totalEthers.add(msg.value);\r\n        // Cannot exceed cap more than 0.1 ETH (to be able to finish ICO if CAP - totalEthers < 0.1)\r\n        require(totalEthers < CAP + 0.1 ether);\r\n\r\n        // What is the ELT to ETH rate\r\n        uint256 _buyPrice = buyPrice();\r\n\r\n        // Calculate #ELT - this is safe as _buyPrice is known\r\n        // and msg.value is restricted to valid values\r\n        uint tokens = msg.value * _buyPrice;\r\n\r\n        // Check tokens > 0\r\n        require(tokens > 0);\r\n        // Compute tokens for foundation; user tokens = 70%; TARGET_ADDRESS = 30%\r\n        // Number of tokens restricted so maths is safe\r\n        // To clearly show 70%+30%, result wasn't precalculated\r\n        uint additional_tokens = tokens * 30 / 70;\r\n\r\n        // Add to total supply\r\n        totalSupply = totalSupply.add(tokens);\r\n        totalSupply = totalSupply.add(additional_tokens);\r\n\r\n        // Add to balances\r\n        balanceOf[_participant] = balanceOf[_participant].add(tokens);\r\n        balanceOf[TARGET_TOKENS_ADDRESS] = balanceOf[TARGET_TOKENS_ADDRESS].add(additional_tokens);\r\n\r\n        // Log events\r\n        TokensBought(_participant, msg.value, totalEthers, tokens, additional_tokens,\r\n            totalSupply, _buyPrice);\r\n        Transfer(0x0, _participant, tokens);\r\n        Transfer(0x0, TARGET_TOKENS_ADDRESS, additional_tokens);\r\n\r\n        // Move the funds to a safe wallet\r\n        TARGET_ADDRESS.transfer(msg.value);\r\n    }\r\n\r\n    /**\r\n     * Transfer the balance from owner's account to another account, with a\r\n     * check that the crowdsale is finalized\r\n     *\r\n     * @param _to                tokens receiver\r\n     * @param _amount            tokens amount\r\n     * @return                   true on success\r\n     */\r\n    function transfer(address _to, uint _amount) returns (bool success) {\r\n        // Cannot transfer before crowdsale ends or cap reached\r\n        require(now > END_TS || totalEthers >= CAP);\r\n        // Standard transfer\r\n        return super.transfer(_to, _amount);\r\n    }\r\n\r\n    /**\r\n     * Spender of tokens transfer an amount of tokens from the token owner's\r\n     * balance to another account, with a check that the crowdsale is\r\n     * finalized\r\n     *\r\n     * @param _from              tokens sender\r\n     * @param _to                tokens receiver\r\n     * @param _amount            tokens amount\r\n     * @return                   true on success\r\n     */\r\n    function transferFrom(address _from, address _to, uint _amount)\r\n            returns (bool success) {\r\n        // Cannot transfer before crowdsale ends or cap reached\r\n        require(now > END_TS || totalEthers >= CAP);\r\n        // Standard transferFrom\r\n        return super.transferFrom(_from, _to, _amount);\r\n    }\r\n\r\n    /**\r\n     * Owner can transfer out any accidentally sent ERC20 tokens\r\n     *\r\n     * @param _tokenAddress       tokens address\r\n     * @param _amount             tokens amount\r\n     * @return                   true on success\r\n     */\r\n    function transferAnyERC20Token(address _tokenAddress, uint _amount)\r\n      onlyOwner returns (bool success) {\r\n        return ERC20Token(_tokenAddress).transfer(owner, _amount);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEthers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_at\",\"type\":\"uint256\"}],\"name\":\"buyPriceAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cap\",\"type\":\"uint256\"},{\"name\":\"_usdethrate\",\"type\":\"uint256\"}],\"name\":\"updateCap\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"halt\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"USDETHRATE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_participant\",\"type\":\"address\"},{\"name\":\"_balance\",\"type\":\"uint256\"},{\"name\":\"_ethers\",\"type\":\"uint256\"}],\"name\":\"addPrecommitment\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TARGET_TOKENS_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"END_TS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalUSD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"START_TS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"halted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unhalt\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferAnyERC20Token\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CAP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TARGET_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_participant\",\"type\":\"address\"}],\"name\":\"proxyPayment\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_start_ts\",\"type\":\"uint256\"},{\"name\":\"_end_ts\",\"type\":\"uint256\"},{\"name\":\"_cap\",\"type\":\"uint256\"},{\"name\":\"_target_address\",\"type\":\"address\"},{\"name\":\"_target_tokens_address\",\"type\":\"address\"},{\"name\":\"_usdethrate\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethers\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"new_ether_balance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"target_address_tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"new_total_supply\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"buy_price\",\"type\":\"uint256\"}],\"name\":\"TokensBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"EloPlayToken","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000059e49f40000000000000000000000000000000000000000000000000000000005a0c2c40000000000000000000000000000000000000000000000878678326eac9000000000000000000000000000000660cdee72302d2941a43db1275eded7827023baa000000000000000000000000660cdee72302d2941a43db1275eded7827023baa000000000000000000000000000000000000000000000000000000000000012c","Library":"","SwarmSource":"bzzr://c2ad5a20aafb360b98929c679d30ccc6550291f29c69a2242b614029c36418b5"}]}