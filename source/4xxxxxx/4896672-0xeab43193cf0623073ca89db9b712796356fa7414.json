{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.17;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  //uint256 public totalSupply;\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20 \r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract GoldFees is Ownable {\r\n    using SafeMath for uint256;\r\n    \r\n    // e.g. if rate = 0.0054\r\n    //uint rateN = 9999452055;\r\n    uint rateN = 9999452054794520548;\r\n    uint rateD = 19;\r\n    uint public maxDays;\r\n    uint public maxRate;\r\n\r\n    \r\n    function GoldFees() public {\r\n        calcMax();\r\n    }\r\n\r\n    function calcMax() internal {\r\n        maxDays = 1;\r\n        maxRate = rateN;\r\n        \r\n        \r\n        uint pow = 2;\r\n        do {\r\n            uint newN = rateN ** pow;\r\n            if (newN / maxRate != maxRate) {\r\n                maxDays = pow / 2;\r\n                break;\r\n            }\r\n            maxRate = newN;\r\n            pow *= 2;\r\n        } while (pow < 2000);\r\n        \r\n    }\r\n\r\n    function updateRate(uint256 _n, uint256 _d) public onlyOwner {\r\n        rateN = _n;\r\n        rateD = _d;\r\n        calcMax();\r\n    }\r\n    \r\n    function rateForDays(uint256 numDays) public view returns (uint256 rate) {\r\n        if (numDays <= maxDays) {\r\n            uint r = rateN ** numDays;\r\n            uint d = rateD * numDays;\r\n            if (d > 18) {\r\n                uint div = 10 ** (d-18);\r\n                rate = r / div;\r\n            } else {\r\n                div = 10 ** (18 - d);\r\n                rate = r * div;\r\n            }\r\n        } else {\r\n            uint256 md1 = numDays / 2;\r\n            uint256 md2 = numDays - md1;\r\n             uint256 r2;\r\n\r\n            uint256 r1 = rateForDays(md1);\r\n            if (md1 == md2) {\r\n                r2 = r1;\r\n            } else {\r\n                r2 = rateForDays(md2);\r\n            }\r\n           \r\n\r\n            //uint256 r1 = rateForDays(maxDays);\r\n            //uint256 r2 = rateForDays(numDays-maxDays);\r\n            rate = r1.mul(r2)/(10**18);\r\n        }\r\n        return; \r\n        \r\n    }\r\n\r\n    uint256 constant public UTC2MYT = 1483200000;\r\n\r\n    function wotDay(uint256 time) public pure returns (uint256) {\r\n        return (time - UTC2MYT) / (1 days);\r\n    }\r\n\r\n    // minimum fee is 1 unless same day\r\n    function calcFees(uint256 start, uint256 end, uint256 startAmount) public view returns (uint256 amount, uint256 fee) {\r\n        if (startAmount == 0) \r\n            return;\r\n        uint256 numberOfDays = wotDay(end) - wotDay(start);\r\n        if (numberOfDays == 0) {\r\n            amount = startAmount;\r\n            return;\r\n        }\r\n        amount = (rateForDays(numberOfDays) * startAmount) / (1 ether);\r\n        if ((fee == 0) && (amount != 0)) \r\n            amount--;\r\n        fee = startAmount.sub(amount);\r\n    }\r\n}\r\n\r\n\r\ncontract Reclaimable is Ownable {\r\n\tERC20Basic constant internal RECLAIM_ETHER = ERC20Basic(0x0);\r\n\r\n\tfunction reclaim(ERC20Basic token)\r\n        public\r\n        onlyOwner\r\n    {\r\n        address reclaimer = msg.sender;\r\n        if (token == RECLAIM_ETHER) {\r\n            reclaimer.transfer(this.balance);\r\n        } else {\r\n            uint256 balance = token.balanceOf(this);\r\n            require(token.transfer(reclaimer, balance));\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// This is primarity used for the migration. Use in the GBT contract is for convenience\r\ncontract GBTBasic {\r\n\r\n    struct Balance {\r\n        uint256 amount;                 // amount through update or transfer\r\n        uint256 lastUpdated;            // DATE last updated\r\n        uint256 nextAllocationIndex;    // which allocationsOverTime record contains next update\r\n        uint256 allocationShare;        // the share of allocationPool that this holder gets (means they hold HGT)\r\n\t}\r\n\r\n\t/*Creates an array with all balances*/\r\n\tmapping (address => Balance) public balances;\r\n\t\r\n    struct Allocation { \r\n        uint256     amount;\r\n        uint256     date;\r\n    }\r\n\t\r\n\tAllocation[]   public allocationsOverTime;\r\n\tAllocation[]   public currentAllocations;\r\n\r\n\tfunction currentAllocationLength() view public returns (uint256) {\r\n\t\treturn currentAllocations.length;\r\n\t}\r\n\r\n\tfunction aotLength() view public returns (uint256) {\r\n\t\treturn allocationsOverTime.length;\r\n\t}\r\n}\r\n\r\n\r\ncontract GoldBackedToken is Ownable, ERC20, Pausable, GBTBasic, Reclaimable {\r\n\tusing SafeMath for uint;\r\n\r\n\tfunction GoldBackedToken(GoldFees feeCalc, GBTBasic _oldToken) public {\r\n\t\tuint delta = 3799997201200178500814753;\r\n\t\tfeeCalculator = feeCalc;\r\n        oldToken = _oldToken;\r\n\t\t// now migrate the non balance stuff\r\n\t\tuint x;\r\n\t\tfor (x = 0; x < oldToken.aotLength(); x++) {\r\n\t\t\tAllocation memory al;\r\n\t\t\t(al.amount, al.date) = oldToken.allocationsOverTime(x);\r\n\t\t\tallocationsOverTime.push(al);\r\n\t\t}\r\n\t\tallocationsOverTime[3].amount = allocationsOverTime[3].amount.sub(delta);\r\n\t\tfor (x = 0; x < oldToken.currentAllocationLength(); x++) {\r\n\t\t\t(al.amount, al.date) = oldToken.currentAllocations(x);\r\n\t\t\tal.amount = al.amount.sub(delta);\r\n\t\t\tcurrentAllocations.push(al);\r\n\t\t}\r\n\r\n\t\t// 1st Minting : TxHash 0x8ba9175d77ed5d3bbf0ddb3666df496d3789da5aa41e46228df91357d9eae8bd\r\n\t\t// amount = 528359800000000000000;\r\n\t\t// date = 1512646845;\r\n\t\t\r\n\t\t// 2nd Minting : TxHash 0xb3ec483dc8cf7dbbe29f4b86bd371702dd0fdaccd91d1b2d57d5e9a18b23d022\r\n\t\t// date = 1513855345;\r\n\t\t// amount = 1003203581831868623088;\r\n\r\n\t\t// Get values of first minting at second minting date\r\n\t\t// feeCalc(1512646845,1513855345,528359800000000000000) => (527954627221032516031,405172778967483969)\r\n\r\n\t\tmintedGBT.date = 1515700247;\r\n\t\tmintedGBT.amount = 1529313490861692541644;\r\n\t}\r\n\r\n  function totalSupply() view public returns (uint256) {\r\n\t  uint256 minted;\r\n\t  uint256 mFees;\r\n\t  uint256 uminted;\r\n\t  uint256 umFees;\r\n\t  uint256 allocated;\r\n\t  uint256 aFees;\r\n\t  (minted,mFees) = calcFees(mintedGBT.date,now,mintedGBT.amount);\r\n\t  (uminted,umFees) = calcFees(unmintedGBT.date,now,unmintedGBT.amount);\r\n\t  (allocated,aFees) = calcFees(currentAllocations[0].date,now,currentAllocations[0].amount);\r\n\t  if (minted+allocated>uminted) {\r\n\t  \treturn minted.add(allocated).sub(uminted);\r\n\t  } else {\r\n\t\treturn 0;\r\n\t  }\r\n  }\r\n\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n  event DeductFees(address indexed owner,uint256 amount);\r\n\r\n  event TokenMinted(address destination, uint256 amount);\r\n  event TokenBurned(address source, uint256 amount);\r\n  \r\n\tstring public name = \"GOLDX\";\r\n\tstring public symbol = \"GOLDX\";\r\n\tuint256 constant public  decimals = 18;  // same as ETH\r\n\tuint256 constant public  hgtDecimals = 8;\r\n\t\t\r\n\tuint256 constant public allocationPool = 1 * 10**9 * 10**hgtDecimals;      // total HGT holdings\r\n\tuint256\t         public\tmaxAllocation  = 38 * 10**5 * 10**decimals;\t\t\t// max GBT that can ever ever be given out\r\n\tuint256\t         public\ttotAllocation;\t\t\t// amount of GBT so far\r\n\t\r\n\tGoldFees\t\t public feeCalculator;\r\n\taddress\t\t     public HGT;\t\t\t\t\t// HGT contract address\r\n\r\n\tfunction updateMaxAllocation(uint256 newMax) public onlyOwner {\r\n\t\trequire(newMax > 38 * 10**5 * 10**decimals);\r\n\t\tmaxAllocation = newMax;\r\n\t}\r\n\r\n\tfunction setFeeCalculator(GoldFees newFC) public onlyOwner {\r\n\t\tfeeCalculator = newFC;\r\n\t}\r\n\r\n\t\r\n\t// GoldFees needs to take care of Domain Offset - do not do here\r\n\r\n\tfunction calcFees(uint256 from, uint256 to, uint256 amount) view public returns (uint256 val, uint256 fee) {\r\n\t\treturn feeCalculator.calcFees(from,to,amount);\r\n\t}\r\n\r\n\t\r\n\tmapping (address => mapping (address => uint)) public allowance;\r\n    mapping (address => bool) updated;\r\n\r\n    GBTBasic oldToken;\r\n\r\n\tfunction migrateBalance(address where) public {\r\n\t\tif (!updated[where]) {\r\n            uint256 am;\r\n            uint256 lu;\r\n            uint256 ne;\r\n            uint256 al;\r\n            (am,lu,ne,al) = oldToken.balances(where);\r\n            balances[where] = Balance(am,lu,ne,al);\r\n            updated[where] = true;\r\n        }\r\n\r\n\t}\r\n\t\r\n\tfunction update(address where) internal {\r\n        uint256 pos;\r\n\t\tuint256 fees;\r\n\t\tuint256 val;\r\n\t\tmigrateBalance(where);\r\n        (val,fees,pos) = updatedBalance(where);\r\n\t    balances[where].nextAllocationIndex = pos;\r\n\t    balances[where].amount = val;\r\n        balances[where].lastUpdated = now;\r\n\t}\r\n\t\r\n\tfunction updatedBalance(address where) view public returns (uint val, uint fees, uint pos) {\r\n\t\tuint256 cVal;\r\n\t\tuint256 cFees;\r\n\t\tuint256 cAmount;\r\n\r\n        uint256 am;\r\n        uint256 lu;\r\n        uint256 ne;\r\n        uint256 al;\r\n\t\tBalance memory bb;\r\n\r\n\t\t// calculate update of balance in account\r\n        if (updated[where]) {\r\n            bb = balances[where];\r\n            am = bb.amount;\r\n            lu = bb.lastUpdated;\r\n            ne = bb.nextAllocationIndex;\r\n            al = bb.allocationShare;\r\n        } else {\r\n            (am,lu,ne,al) = oldToken.balances(where);\r\n        }\r\n\t\t(val,fees) = calcFees(lu,now,am);\r\n\t\t// calculate update based on accrued disbursals\r\n\t    pos = ne;\r\n\t\tif ((pos < currentAllocations.length) && (al != 0)) {\r\n\t\t\tcAmount = currentAllocations[ne].amount.mul(al).div( allocationPool);\r\n\t\t\t(cVal,cFees) = calcFees(currentAllocations[ne].date,now,cAmount);\r\n\t\t} \r\n\t    val = val.add(cVal);\r\n\t\tfees = fees.add(cFees);\r\n\t\tpos = currentAllocations.length;\r\n\t}\r\n\r\n    function balanceOf(address where) view public returns (uint256 val) {\r\n        uint256 fees;\r\n\t\tuint256 pos;\r\n        (val,fees,pos) = updatedBalance(where);\r\n        return ;\r\n    }\r\n\r\n\tevent GoldAllocation(uint256 amount, uint256 date);\r\n\tevent FeeOnAllocation(uint256 fees, uint256 date);\r\n\r\n\tevent PartComplete();\r\n\tevent StillToGo(uint numLeft);\r\n\tuint256 public partPos;\r\n\tuint256 public partFees;\r\n\tuint256 partL;\r\n\tAllocation[]   public partAllocations;\r\n\r\n\tfunction partAllocationLength() view public returns (uint) {\r\n\t\treturn partAllocations.length;\r\n\t}\r\n\r\n\tfunction addAllocationPartOne(uint newAllocation,uint numSteps) \r\n\t\tpublic \r\n\t\tonlyMinter \r\n\t{\r\n\t\trequire(partPos == 0);\r\n\t\tuint256 thisAllocation = newAllocation;\r\n\r\n\t\trequire(totAllocation < maxAllocation);\t\t// cannot allocate more than this;\r\n\r\n\t\tif (currentAllocations.length > partAllocations.length) {\r\n\t\t\tpartAllocations = currentAllocations;\r\n\t\t}\r\n\r\n\t\tif (totAllocation + thisAllocation > maxAllocation) {\r\n\t\t\tthisAllocation = maxAllocation.sub(totAllocation);\r\n\t\t\tlog0(\"max alloc reached\");\r\n\t\t}\r\n\t\ttotAllocation = totAllocation.add(thisAllocation);\r\n\r\n\t\tGoldAllocation(thisAllocation,now);\r\n\r\n        Allocation memory newDiv;\r\n        newDiv.amount = thisAllocation;\r\n        newDiv.date = now;\r\n\t\t// store into history\r\n\t    allocationsOverTime.push(newDiv);\r\n\t\t// add this record to the end of currentAllocations\r\n\t\tpartL = partAllocations.push(newDiv);\r\n\t\t// update all other records with calcs from last record\r\n\t\tif (partAllocations.length < 2) { // no fees to consider\r\n\t\t\tPartComplete();\r\n\t\t\tcurrentAllocations = partAllocations;\r\n\t\t\tFeeOnAllocation(0,now);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t//\r\n\t\t// The only fees that need to be collected are the fees on location zero.\r\n\t\t// Since they are the last calculated = they come out with the break\r\n\t\t//\r\n\t\tfor (partPos = partAllocations.length - 2; partPos >= 0; partPos-- ) {\r\n\t\t\t(partAllocations[partPos].amount,partFees) = calcFees(partAllocations[partPos].date,now,partAllocations[partPos].amount);\r\n\r\n\t\t\tpartAllocations[partPos].amount = partAllocations[partPos].amount.add(partAllocations[partL - 1].amount);\r\n\t\t\tpartAllocations[partPos].date = now;\r\n\t\t\tif ((partPos == 0) || (partPos == partAllocations.length-numSteps)) {\r\n\t\t\t\tbreak; \r\n\t\t\t}\r\n\t\t}\r\n\t\tif (partPos != 0) {\r\n\t\t\tStillToGo(partPos);\r\n\t\t\treturn; // not done yet\r\n\t\t}\r\n\t\tPartComplete();\r\n\t\tFeeOnAllocation(partFees,now);\r\n\t\tcurrentAllocations = partAllocations;\r\n\t}\r\n\r\n\tfunction addAllocationPartTwo(uint numSteps) \r\n\t\tpublic \r\n\t\tonlyMinter \r\n\t{\r\n\t\trequire(numSteps > 0);\r\n\t\trequire(partPos > 0);\r\n\t\tfor (uint i = 0; i < numSteps; i++ ) {\r\n\t\t\tpartPos--;\r\n\t\t\t(partAllocations[partPos].amount,partFees) = calcFees(partAllocations[partPos].date,now,partAllocations[partPos].amount);\r\n\t\t\tpartAllocations[partPos].amount = partAllocations[partPos].amount.add(partAllocations[partL - 1].amount);\r\n\t\t\tpartAllocations[partPos].date = now;\r\n\t\t\tif (partPos == 0) {\r\n\t\t\t\tbreak; \r\n\t\t\t}\r\n\t\t}\r\n\t\tif (partPos != 0) {\r\n\t\t\tStillToGo(partPos);\r\n\t\t\treturn; // not done yet\r\n\t\t}\r\n\t\tPartComplete();\r\n\t\tFeeOnAllocation(partFees,now);\r\n\t\tcurrentAllocations = partAllocations;\r\n\t}\r\n\r\n\tfunction setHGT(address _hgt) public onlyOwner {\r\n\t\tHGT = _hgt;\r\n\t}\r\n\r\n\tfunction parentFees(address where) public whenNotPaused {\r\n\t\trequire(msg.sender == HGT);\r\n\t    update(where);\t\t\r\n\t}\r\n\t\r\n\tfunction parentChange(address where, uint newValue) public whenNotPaused { // called when HGT balance changes\r\n\t\trequire(msg.sender == HGT);\r\n\t    balances[where].allocationShare = newValue;\r\n\t}\r\n\t\r\n\t/* send GBT */\r\n\tfunction transfer(address _to, uint256 _value) public whenNotPaused returns (bool ok) {\r\n\t\trequire(_to != address(0));\r\n\t    update(msg.sender);              // Do this to ensure sender has enough funds.\r\n\t\tupdate(_to); \r\n\r\n        balances[msg.sender].amount = balances[msg.sender].amount.sub(_value);\r\n        balances[_to].amount = balances[_to].amount.add(_value);\r\n\t\tTransfer(msg.sender, _to, _value); //Notify anyone listening that this transfer took place\r\n        return true;\r\n\t}\r\n\r\n\tfunction transferFrom(address _from, address _to, uint _value) public whenNotPaused returns (bool success) {\r\n\t\trequire(_to != address(0));\r\n\t\tvar _allowance = allowance[_from][msg.sender];\r\n\r\n\t    update(_from);              // Do this to ensure sender has enough funds.\r\n\t\tupdate(_to); \r\n\r\n\t\tbalances[_to].amount = balances[_to].amount.add(_value);\r\n\t\tbalances[_from].amount = balances[_from].amount.sub(_value);\r\n\t\tallowance[_from][msg.sender] = _allowance.sub(_value);\r\n\t\tTransfer(_from, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n  \tfunction approve(address _spender, uint _value) public whenNotPaused returns (bool success) {\r\n\t\trequire((_value == 0) || (allowance[msg.sender][_spender] == 0));\r\n    \tallowance[msg.sender][_spender] = _value;\r\n    \tApproval(msg.sender, _spender, _value);\r\n    \treturn true;\r\n  \t}\r\n\r\n  /**\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   */\r\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n    allowance[msg.sender][_spender] = allowance[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowance[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n    uint oldValue = allowance[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowance[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowance[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowance[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  \tfunction allowance(address _owner, address _spender) public view returns (uint remaining) {\r\n    \treturn allowance[_owner][_spender];\r\n  \t}\r\n\r\n\t// Minting Functions \r\n\taddress public authorisedMinter;\r\n\r\n\tfunction setMinter(address minter) public onlyOwner {\r\n\t\tauthorisedMinter = minter;\r\n\t}\r\n\r\n\tmodifier onlyMinter() {\r\n\t\trequire(msg.sender == authorisedMinter);\r\n\t\t_;\r\n\t}\r\n\r\n\tAllocation public mintedGBT;\t\t// minting adds to this one\r\n\tAllocation public unmintedGBT;\t\t// allocating adds here, burning takes from here if minted is empty\r\n\t\r\n\tfunction mintTokens(address destination, uint256 amount) \r\n\t\tonlyMinter\r\n\t\tpublic \r\n\t{\r\n\t\trequire(msg.sender == authorisedMinter);\r\n\t\tupdate(destination);\r\n\t\tbalances[destination].amount = balances[destination].amount.add(amount);\r\n\t\tTokenMinted(destination,amount);\r\n\t\tTransfer(0x0,destination,amount); // ERC20 compliance\r\n\t\t//\r\n\t\t// TotalAllocation stuff\r\n\t\t//\r\n\t\tuint256 fees;\r\n\t\t(mintedGBT.amount,fees) = calcFees(mintedGBT.date,now,mintedGBT.amount);\r\n\t\tmintedGBT.amount = mintedGBT.amount.add(amount);\r\n\t\tmintedGBT.date = now;\r\n\t}\r\n\r\n\tfunction burnTokens(address source, uint256 amount) \r\n\t\tonlyMinter\r\n\t\tpublic \r\n\t{\r\n\t\tupdate(source);\r\n\t\tbalances[source].amount = balances[source].amount.sub(amount);\r\n\t\tTokenBurned(source,amount);\r\n\t\tTransfer(source,0x0,amount); // ERC20 compliance\r\n\t\t//\r\n\t\t// TotalAllocation stuff\r\n\t\t//\r\n\t\tuint256 fees;\r\n\t\t(unmintedGBT.amount,fees) = calcFees(unmintedGBT.date,now,unmintedGBT.amount);\r\n\t\tunmintedGBT.date = now;\r\n\t\tunmintedGBT.amount = unmintedGBT.amount.add(amount);\r\n\t}\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"currentAllocations\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"date\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"source\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMax\",\"type\":\"uint256\"}],\"name\":\"updateMaxAllocation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"lastUpdated\",\"type\":\"uint256\"},{\"name\":\"nextAllocationIndex\",\"type\":\"uint256\"},{\"name\":\"allocationShare\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"where\",\"type\":\"address\"}],\"name\":\"migrateBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totAllocation\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"where\",\"type\":\"address\"}],\"name\":\"parentFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentAllocationLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintedGBT\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"date\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"where\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"val\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"where\",\"type\":\"address\"}],\"name\":\"updatedBalance\",\"outputs\":[{\"name\":\"val\",\"type\":\"uint256\"},{\"name\":\"fees\",\"type\":\"uint256\"},{\"name\":\"pos\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allocationsOverTime\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"date\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"authorisedMinter\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"partAllocationLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newFC\",\"type\":\"address\"}],\"name\":\"setFeeCalculator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxAllocation\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allocationPool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeCalculator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"numSteps\",\"type\":\"uint256\"}],\"name\":\"addAllocationPartTwo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"partAllocations\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"date\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hgt\",\"type\":\"address\"}],\"name\":\"setHGT\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"aotLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"from\",\"type\":\"uint256\"},{\"name\":\"to\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"calcFees\",\"outputs\":[{\"name\":\"val\",\"type\":\"uint256\"},{\"name\":\"fee\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAllocation\",\"type\":\"uint256\"},{\"name\":\"numSteps\",\"type\":\"uint256\"}],\"name\":\"addAllocationPartOne\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"partFees\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unmintedGBT\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"date\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"where\",\"type\":\"address\"},{\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"parentChange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"HGT\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"destination\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mintTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"partPos\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"reclaim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"minter\",\"type\":\"address\"}],\"name\":\"setMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hgtDecimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"feeCalc\",\"type\":\"address\"},{\"name\":\"_oldToken\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DeductFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"destination\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"source\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenBurned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"date\",\"type\":\"uint256\"}],\"name\":\"GoldAllocation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fees\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"date\",\"type\":\"uint256\"}],\"name\":\"FeeOnAllocation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"PartComplete\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"numLeft\",\"type\":\"uint256\"}],\"name\":\"StillToGo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"GoldBackedToken","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000d56ed0dae33a546d063e60a214dd76538a1ba5ab0000000000000000000000007585f835ae2d522722d2684323a0ba83401f32f5","Library":"","SwarmSource":"bzzr://e73ca8a5b339e27414e8f0263555347fb1c452f32550226b36f547e4d2635cba"}]}