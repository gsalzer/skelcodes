{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/ConvertLib.sol\r\n\r\npragma solidity ^0.4.2;\r\n\r\nlibrary ConvertLib{\r\n\tfunction convert(uint amount,uint conversionRate) returns (uint convertedAmount)\r\n\t{\r\n\t\treturn amount * conversionRate;\r\n\t}\r\n}\r\n\r\n// File: contracts/DigitalArtCollectible.sol\r\n\r\npragma solidity ^0.4.13;\r\n\r\n/**\r\n * This contract handles the actions for every collectible on MisfitArt...\r\n */\r\n\r\ncontract DigitalArtCollectible {\r\n\r\n  // MisfitArt's account\r\n  address owner;\r\n\r\n\r\n  // starts turned off to prepare the drawings before going public\r\n  bool isExecutionAllowed = false;\r\n\r\n  // ERC20 token standard attributes\r\n  string public name;\r\n  string public symbol;\r\n  uint8 public decimals;\r\n  uint256 public totalSupply;\r\n\r\n  struct Offer {\r\n      bool isForSale;\r\n      uint drawingId;\r\n      uint printIndex;\r\n      address seller; \r\n      uint minValue;          // in ether\r\n      address onlySellTo;     // specify to sell only to a specific person\r\n      uint lastSellValue;\r\n  }\r\n\r\n  struct Bid {\r\n      bool hasBid;\r\n      uint drawingId;\r\n      uint printIndex;\r\n      address bidder;\r\n      uint value;\r\n  }\r\n\r\n  struct Collectible{\r\n    uint drawingId;\r\n    string checkSum; // digest of the drawing, created using  SHA2\r\n    uint totalSupply;\r\n    uint initialPrice;\r\n    uint initialPrintIndex;\r\n    uint collectionId;\r\n    uint authorUId; // drawing creator id \r\n  }    \r\n  // key: printIndex\r\n  // the value is the user who owns that specific print\r\n  mapping (uint => address) public DrawingPrintToAddress;\r\n  \r\n  // A record of collectibles that are offered for sale at a specific minimum value, \r\n  // and perhaps to a specific person, the key to access and offer is the printIndex.\r\n  // since every single offer inside the Collectible struct will be tied to the main\r\n  // drawingId that identifies that collectible.\r\n  mapping (uint => Offer) public OfferedForSale;\r\n\r\n  // A record of the highest collectible bid, the key to access a bid is the printIndex\r\n  mapping (uint => Bid) public Bids;\r\n\r\n\r\n  // \"Hash\" list of the different Collectibles available in the market place\r\n  mapping (uint => Collectible) public drawingIdToCollectibles;\r\n\r\n  mapping (address => uint) public pendingWithdrawals;\r\n\r\n  mapping (address => uint256) public balances;\r\n\r\n  // returns the balance of a particular account\r\n  function balanceOf(address _owner) constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  } \r\n\r\n  // Events\r\n  event Assigned(address indexed to, uint256 collectibleIndex, uint256 printIndex);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event CollectibleTransfer(address indexed from, address indexed to, uint256 collectibleIndex, uint256 printIndex);\r\n  event CollectibleOffered(uint indexed collectibleIndex, uint indexed printIndex, uint minValue, address indexed toAddress, uint lastSellValue);\r\n  event CollectibleBidEntered(uint indexed collectibleIndex, uint indexed printIndex, uint value, address indexed fromAddress);\r\n  event CollectibleBidWithdrawn(uint indexed collectibleIndex, uint indexed printIndex, uint value, address indexed fromAddress);\r\n  event CollectibleBought(uint indexed collectibleIndex, uint printIndex, uint value, address indexed fromAddress, address indexed toAddress);\r\n  event CollectibleNoLongerForSale(uint indexed collectibleIndex, uint indexed printIndex);\r\n\r\n  // The constructor is executed only when the contract is created in the blockchain.\r\n  function DigitalArtCollectible () { \r\n    // assigns the address of the account creating the contract as the \r\n    // \"owner\" of the contract. Since the contract doesn't have \r\n    // a \"set\" function for the owner attribute this value will be immutable. \r\n    owner = msg.sender;\r\n\r\n    // Update total supply\r\n    totalSupply = 16600;\r\n    // Give to owner all initial drawings\r\n    balances[owner] = totalSupply;\r\n\r\n    // Set the name for display purposes\r\n    name = \"Digital Art Collectible\";\r\n    // Set the symbol for display purposes\r\n    symbol = \"Æ‰\";\r\n    // Amount of decimals for display purposes\r\n    decimals = 0;\r\n  }\r\n\r\n  // main business logic functions\r\n  \r\n  // buyer's functions\r\n  function buyCollectible(uint drawingId, uint printIndex) payable {\r\n    require(isExecutionAllowed);\r\n    // requires the drawing id to actually exist\r\n    require(drawingIdToCollectibles[drawingId].drawingId != 0);\r\n    Collectible storage collectible = drawingIdToCollectibles[drawingId];\r\n    require((printIndex < (collectible.totalSupply+collectible.initialPrintIndex)) &&  (printIndex >= collectible.initialPrintIndex));\r\n    Offer storage offer = OfferedForSale[printIndex];\r\n    require(offer.drawingId != 0);\r\n    require(offer.isForSale); // drawing actually for sale\r\n    require(offer.onlySellTo == 0x0 || offer.onlySellTo == msg.sender);  // drawing can be sold to this user\r\n    require(msg.value >= offer.minValue); // Didn't send enough ETH\r\n    require(offer.seller == DrawingPrintToAddress[printIndex]); // Seller still owner of the drawing\r\n    require(DrawingPrintToAddress[printIndex] != msg.sender);\r\n\r\n    address seller = offer.seller;\r\n    address buyer = msg.sender;\r\n\r\n    DrawingPrintToAddress[printIndex] = buyer; // \"gives\" the print to the buyer\r\n\r\n    // decrease by one the amount of prints the seller has of this particullar drawing\r\n    balances[seller]--;\r\n    // increase by one the amount of prints the buyer has of this particullar drawing\r\n    balances[buyer]++;\r\n\r\n    // launch the Transfered event\r\n    Transfer(seller, buyer, 1);\r\n\r\n    // transfer ETH to the seller\r\n    // profit delta must be equal or greater than 1e-16 to be able to divide it\r\n    // between the involved entities (art creator -> 30%, seller -> 60% and MisfitArt -> 10%)\r\n    // profit percentages can't be lower than 1e-18 which is the lowest unit in ETH\r\n    // equivalent to 1 wei.\r\n    // if(offer.lastSellValue < msg.value && (msg.value - offer.lastSellValue) >= uint(0.0000000000000001) ){ commented because we're assuming values are expressed in  \"weis\", adjusting in relation to that\r\n    if(offer.lastSellValue < msg.value && (msg.value - offer.lastSellValue) >= 100 ){ // assuming 100 (weis) wich is equivalent to 1e-16\r\n      uint profit = msg.value - offer.lastSellValue;\r\n      // seller gets base value plus 90% of the profit\r\n      pendingWithdrawals[seller] += offer.lastSellValue + (profit*90/100); \r\n      // MisfitArt gets 10% of the profit\r\n      pendingWithdrawals[owner] += (profit*10/100);\r\n      // MisfitArt receives 30% of the profit to give to the artist\r\n      // pendingWithdrawals[owner] += (profit*30/100);\r\n      // going manual for artist and MisfitArt percentages (30 + 10)\r\n      // pendingWithdrawals[owner] += (profit*40/100);\r\n    }else{\r\n      // if the seller doesn't make a profit of the sell he gets the 100% of the traded\r\n      // value.\r\n      pendingWithdrawals[seller] += msg.value;\r\n    }\r\n    makeCollectibleUnavailableToSale(buyer, drawingId, printIndex, msg.value);\r\n\r\n    // launch the CollectibleBought event    \r\n    CollectibleBought(drawingId, printIndex, msg.value, seller, buyer);\r\n\r\n    // Check for the case where there is a bid from the new owner and refund it.\r\n    // Any other bid can stay in place.\r\n    Bid storage bid = Bids[printIndex];\r\n    if (bid.bidder == buyer) {\r\n      // Kill bid and refund value\r\n      pendingWithdrawals[buyer] += bid.value;\r\n      Bids[printIndex] = Bid(false, collectible.drawingId, printIndex, 0x0, 0);\r\n    }\r\n  }\r\n\r\n  function alt_buyCollectible(uint drawingId, uint printIndex) payable {\r\n    require(isExecutionAllowed);\r\n    // requires the drawing id to actually exist\r\n    require(drawingIdToCollectibles[drawingId].drawingId != 0);\r\n    Collectible storage collectible = drawingIdToCollectibles[drawingId];\r\n    require((printIndex < (collectible.totalSupply+collectible.initialPrintIndex)) &&  (printIndex >= collectible.initialPrintIndex));\r\n    Offer storage offer = OfferedForSale[printIndex];\r\n    require(offer.drawingId == 0);\r\n    \r\n    require(msg.value >= collectible.initialPrice); // Didn't send enough ETH\r\n    require(DrawingPrintToAddress[printIndex] == 0x0); // should be equal to a \"null\" address (0x0) since it shouldn't have an owner yet\r\n\r\n    address seller = owner;\r\n    address buyer = msg.sender;\r\n\r\n    DrawingPrintToAddress[printIndex] = buyer; // \"gives\" the print to the buyer\r\n\r\n    // decrease by one the amount of prints the seller has of this particullar drawing\r\n    // commented while we decide what to do with balances for MisfitArt\r\n    balances[seller]--;\r\n    // increase by one the amount of prints the buyer has of this particullar drawing\r\n    balances[buyer]++;\r\n\r\n    // launch the Transfered event\r\n    Transfer(seller, buyer, 1);\r\n\r\n    // transfer ETH to the seller\r\n    // profit delta must be equal or greater than 1e-16 to be able to divide it\r\n    // between the involved entities (art creator -> 30%, seller -> 60% and MisfitArt -> 10%)\r\n    // profit percentages can't be lower than 1e-18 which is the lowest unit in ETH\r\n    // equivalent to 1 wei.\r\n\r\n    pendingWithdrawals[owner] += msg.value;\r\n    \r\n    OfferedForSale[printIndex] = Offer(false, collectible.drawingId, printIndex, buyer, msg.value, 0x0, msg.value);\r\n\r\n    // launch the CollectibleBought event    \r\n    CollectibleBought(drawingId, printIndex, msg.value, seller, buyer);\r\n\r\n    // Check for the case where there is a bid from the new owner and refund it.\r\n    // Any other bid can stay in place.\r\n    Bid storage bid = Bids[printIndex];\r\n    if (bid.bidder == buyer) {\r\n      // Kill bid and refund value\r\n      pendingWithdrawals[buyer] += bid.value;\r\n      Bids[printIndex] = Bid(false, collectible.drawingId, printIndex, 0x0, 0);\r\n    }\r\n  }\r\n  \r\n  function enterBidForCollectible(uint drawingId, uint printIndex) payable {\r\n    require(isExecutionAllowed);\r\n    require(drawingIdToCollectibles[drawingId].drawingId != 0);\r\n    Collectible storage collectible = drawingIdToCollectibles[drawingId];\r\n    require(DrawingPrintToAddress[printIndex] != 0x0); // Print is owned by somebody\r\n    require(DrawingPrintToAddress[printIndex] != msg.sender); // Print is not owned by bidder\r\n    require((printIndex < (collectible.totalSupply+collectible.initialPrintIndex)) && (printIndex >= collectible.initialPrintIndex));\r\n\r\n    require(msg.value > 0); // Bid must be greater than 0\r\n    // get the current bid for that print if any\r\n    Bid storage existing = Bids[printIndex];\r\n    // Must outbid previous bid by at least 5%. Apparently is not possible to \r\n    // multiply by 1.05, that's why we do it manually.\r\n    require(msg.value >= existing.value+(existing.value*5/100));\r\n    if (existing.value > 0) {\r\n        // Refund the failing bid from the previous bidder\r\n        pendingWithdrawals[existing.bidder] += existing.value;\r\n    }\r\n    // add the new bid\r\n    Bids[printIndex] = Bid(true, collectible.drawingId, printIndex, msg.sender, msg.value);\r\n    CollectibleBidEntered(collectible.drawingId, printIndex, msg.value, msg.sender);\r\n  }\r\n\r\n  // used by a user who wants to cancell a bid placed by her/him\r\n  function withdrawBidForCollectible(uint drawingId, uint printIndex) {\r\n    require(isExecutionAllowed);\r\n    require(drawingIdToCollectibles[drawingId].drawingId != 0);\r\n    Collectible storage collectible = drawingIdToCollectibles[drawingId];\r\n    require((printIndex < (collectible.totalSupply+collectible.initialPrintIndex)) && (printIndex >= collectible.initialPrintIndex));\r\n    require(DrawingPrintToAddress[printIndex] != 0x0); // Print is owned by somebody\r\n    require(DrawingPrintToAddress[printIndex] != msg.sender); // Print is not owned by bidder\r\n    Bid storage bid = Bids[printIndex];\r\n    require(bid.bidder == msg.sender);\r\n    CollectibleBidWithdrawn(drawingId, printIndex, bid.value, msg.sender);\r\n\r\n    uint amount = bid.value;\r\n    Bids[printIndex] = Bid(false, collectible.drawingId, printIndex, 0x0, 0);\r\n    // Refund the bid money\r\n    msg.sender.transfer(amount);\r\n  }\r\n\r\n  // seller's functions\r\n  function offerCollectibleForSale(uint drawingId, uint printIndex, uint minSalePriceInWei) {\r\n    require(isExecutionAllowed);\r\n    require(drawingIdToCollectibles[drawingId].drawingId != 0);\r\n    Collectible storage collectible = drawingIdToCollectibles[drawingId];\r\n    require(DrawingPrintToAddress[printIndex] == msg.sender);\r\n    require((printIndex < (collectible.totalSupply+collectible.initialPrintIndex)) && (printIndex >= collectible.initialPrintIndex));\r\n    uint lastSellValue = OfferedForSale[printIndex].lastSellValue;\r\n    OfferedForSale[printIndex] = Offer(true, collectible.drawingId, printIndex, msg.sender, minSalePriceInWei, 0x0, lastSellValue);\r\n    CollectibleOffered(drawingId, printIndex, minSalePriceInWei, 0x0, lastSellValue);\r\n  }\r\n\r\n  function withdrawOfferForCollectible(uint drawingId, uint printIndex){\r\n    require(isExecutionAllowed);\r\n    require(drawingIdToCollectibles[drawingId].drawingId != 0);\r\n    Collectible storage collectible = drawingIdToCollectibles[drawingId];\r\n    require(DrawingPrintToAddress[printIndex] == msg.sender);\r\n    require((printIndex < (collectible.totalSupply+collectible.initialPrintIndex)) && (printIndex >= collectible.initialPrintIndex));\r\n\r\n    uint lastSellValue = OfferedForSale[printIndex].lastSellValue;\r\n\r\n    OfferedForSale[printIndex] = Offer(false, collectible.drawingId, printIndex, msg.sender, 0, 0x0, lastSellValue);\r\n    // launch the CollectibleNoLongerForSale event \r\n    CollectibleNoLongerForSale(collectible.drawingId, printIndex);\r\n\r\n  }\r\n\r\n  function offerCollectibleForSaleToAddress(uint drawingId, uint printIndex, uint minSalePriceInWei, address toAddress) {\r\n    require(isExecutionAllowed);\r\n    require(drawingIdToCollectibles[drawingId].drawingId != 0);\r\n    Collectible storage collectible = drawingIdToCollectibles[drawingId];\r\n    require(DrawingPrintToAddress[printIndex] == msg.sender);\r\n    require((printIndex < (collectible.totalSupply+collectible.initialPrintIndex)) && (printIndex >= collectible.initialPrintIndex));\r\n    uint lastSellValue = OfferedForSale[printIndex].lastSellValue;\r\n    OfferedForSale[printIndex] = Offer(true, collectible.drawingId, printIndex, msg.sender, minSalePriceInWei, toAddress, lastSellValue);\r\n    CollectibleOffered(drawingId, printIndex, minSalePriceInWei, toAddress, lastSellValue);\r\n  }\r\n\r\n  function acceptBidForCollectible(uint drawingId, uint minPrice, uint printIndex) {\r\n    require(isExecutionAllowed);\r\n    require(drawingIdToCollectibles[drawingId].drawingId != 0);\r\n    Collectible storage collectible = drawingIdToCollectibles[drawingId];\r\n    require((printIndex < (collectible.totalSupply+collectible.initialPrintIndex)) && (printIndex >= collectible.initialPrintIndex));\r\n    require(DrawingPrintToAddress[printIndex] == msg.sender);\r\n    address seller = msg.sender;\r\n\r\n    Bid storage bid = Bids[printIndex];\r\n    require(bid.value > 0); // Will be zero if there is no actual bid\r\n    require(bid.value >= minPrice); // Prevent a condition where a bid is withdrawn and replaced with a lower bid but seller doesn't know\r\n\r\n    DrawingPrintToAddress[printIndex] = bid.bidder;\r\n    balances[seller]--;\r\n    balances[bid.bidder]++;\r\n    Transfer(seller, bid.bidder, 1);\r\n    uint amount = bid.value;\r\n\r\n    Offer storage offer = OfferedForSale[printIndex];\r\n    // transfer ETH to the seller\r\n    // profit delta must be equal or greater than 1e-16 to be able to divide it\r\n    // between the involved entities (art creator -> 30%, seller -> 60% and MisfitArt -> 10%)\r\n    // profit percentages can't be lower than 1e-18 which is the lowest unit in ETH\r\n    // equivalent to 1 wei.\r\n    // if(offer.lastSellValue > msg.value && (msg.value - offer.lastSellValue) >= uint(0.0000000000000001) ){ commented because we're assuming values are expressed in  \"weis\", adjusting in relation to that\r\n    if(offer.lastSellValue < amount && (amount - offer.lastSellValue) >= 100 ){ // assuming 100 (weis) wich is equivalent to 1e-16\r\n      uint profit = amount - offer.lastSellValue;\r\n      // seller gets base value plus 90% of the profit\r\n      pendingWithdrawals[seller] += offer.lastSellValue + (profit*90/100); \r\n      // MisfitArt gets 10% of the profit\r\n      pendingWithdrawals[owner] += (profit*10/100);\r\n      // MisfitArt receives 30% of the profit to give to the artist\r\n      // pendingWithdrawals[owner] += (profit*30/100);\r\n      // pendingWithdrawals[owner] += (profit*40/100);\r\n\r\n    }else{\r\n      // if the seller doesn't make a profit of the sell he gets the 100% of the traded\r\n      // value.\r\n      pendingWithdrawals[seller] += amount;\r\n    }\r\n    // does the same as the function makeCollectibleUnavailableToSale\r\n    OfferedForSale[printIndex] = Offer(false, collectible.drawingId, printIndex, bid.bidder, 0, 0x0, amount);\r\n    CollectibleBought(collectible.drawingId, printIndex, bid.value, seller, bid.bidder);\r\n    Bids[printIndex] = Bid(false, collectible.drawingId, printIndex, 0x0, 0);\r\n\r\n  }\r\n\r\n  // used by a user who wants to cashout his money\r\n  function withdraw() {\r\n    require(isExecutionAllowed);\r\n    uint amount = pendingWithdrawals[msg.sender];\r\n    // Remember to zero the pending refund before\r\n    // sending to prevent re-entrancy attacks\r\n    pendingWithdrawals[msg.sender] = 0;\r\n    msg.sender.transfer(amount);\r\n  }\r\n\r\n  // Transfer ownership of a punk to another user without requiring payment\r\n  function transfer(address to, uint drawingId, uint printIndex) returns (bool success){\r\n    require(isExecutionAllowed);\r\n    require(drawingIdToCollectibles[drawingId].drawingId != 0);\r\n    Collectible storage collectible = drawingIdToCollectibles[drawingId];\r\n    // checks that the user making the transfer is the actual owner of the print\r\n    require(DrawingPrintToAddress[printIndex] == msg.sender);\r\n    require((printIndex < (collectible.totalSupply+collectible.initialPrintIndex)) && (printIndex >= collectible.initialPrintIndex));\r\n    makeCollectibleUnavailableToSale(to, drawingId, printIndex, OfferedForSale[printIndex].lastSellValue);\r\n    // sets the new owner of the print\r\n    DrawingPrintToAddress[printIndex] = to;\r\n    balances[msg.sender]--;\r\n    balances[to]++;\r\n    Transfer(msg.sender, to, 1);\r\n    CollectibleTransfer(msg.sender, to, drawingId, printIndex);\r\n    // Check for the case where there is a bid from the new owner and refund it.\r\n    // Any other bid can stay in place.\r\n    Bid storage bid = Bids[printIndex];\r\n    if (bid.bidder == to) {\r\n      // Kill bid and refund value\r\n      pendingWithdrawals[to] += bid.value;\r\n      Bids[printIndex] = Bid(false, drawingId, printIndex, 0x0, 0);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  // utility functions\r\n  function makeCollectibleUnavailableToSale(address to, uint drawingId, uint printIndex, uint lastSellValue) {\r\n    require(isExecutionAllowed);\r\n    require(drawingIdToCollectibles[drawingId].drawingId != 0);\r\n    Collectible storage collectible = drawingIdToCollectibles[drawingId];\r\n    require(DrawingPrintToAddress[printIndex] == msg.sender);\r\n    require((printIndex < (collectible.totalSupply+collectible.initialPrintIndex)) && (printIndex >= collectible.initialPrintIndex));\r\n    OfferedForSale[printIndex] = Offer(false, collectible.drawingId, printIndex, to, 0, 0x0, lastSellValue);\r\n    // launch the CollectibleNoLongerForSale event \r\n    CollectibleNoLongerForSale(collectible.drawingId, printIndex);\r\n  }\r\n\r\n  function newCollectible(uint drawingId, string checkSum, uint256 _totalSupply, uint initialPrice, uint initialPrintIndex, uint collectionId, uint authorUId){\r\n    // requires the sender to be the same address that compiled the contract,\r\n    // this is ensured by storing the sender address\r\n    // require(owner == msg.sender);\r\n    require(owner == msg.sender);\r\n    // requires the drawing to not exist already in the scope of the contract\r\n    require(drawingIdToCollectibles[drawingId].drawingId == 0);\r\n    drawingIdToCollectibles[drawingId] = Collectible(drawingId, checkSum, _totalSupply, initialPrice, initialPrintIndex, collectionId, authorUId);\r\n  }\r\n\r\n  function flipSwitchTo(bool state){\r\n    // require(owner == msg.sender);\r\n    require(owner == msg.sender);\r\n    isExecutionAllowed = state;\r\n  }\r\n\r\n  function mintNewDrawings(uint amount){\r\n    require(owner == msg.sender);\r\n    totalSupply = totalSupply + amount;\r\n    balances[owner] = balances[owner] + amount;\r\n\r\n    Transfer(0, owner, amount);\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/Migrations.sol\r\n\r\npragma solidity ^0.4.2;\r\n\r\ncontract Migrations {\r\n  address public owner;\r\n  uint public last_completed_migration;\r\n\r\n  modifier restricted() {\r\n    if (msg.sender == owner) _;\r\n  }\r\n\r\n  function Migrations() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  function setCompleted(uint completed) restricted {\r\n    last_completed_migration = completed;\r\n  }\r\n\r\n  function upgrade(address new_address) restricted {\r\n    Migrations upgraded = Migrations(new_address);\r\n    upgraded.setCompleted(last_completed_migration);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"flipSwitchTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"drawingId\",\"type\":\"uint256\"},{\"name\":\"printIndex\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"drawingId\",\"type\":\"uint256\"},{\"name\":\"printIndex\",\"type\":\"uint256\"}],\"name\":\"buyCollectible\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"drawingId\",\"type\":\"uint256\"},{\"name\":\"minPrice\",\"type\":\"uint256\"},{\"name\":\"printIndex\",\"type\":\"uint256\"}],\"name\":\"acceptBidForCollectible\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"drawingId\",\"type\":\"uint256\"},{\"name\":\"printIndex\",\"type\":\"uint256\"},{\"name\":\"lastSellValue\",\"type\":\"uint256\"}],\"name\":\"makeCollectibleUnavailableToSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"OfferedForSale\",\"outputs\":[{\"name\":\"isForSale\",\"type\":\"bool\"},{\"name\":\"drawingId\",\"type\":\"uint256\"},{\"name\":\"printIndex\",\"type\":\"uint256\"},{\"name\":\"seller\",\"type\":\"address\"},{\"name\":\"minValue\",\"type\":\"uint256\"},{\"name\":\"onlySellTo\",\"type\":\"address\"},{\"name\":\"lastSellValue\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"drawingId\",\"type\":\"uint256\"},{\"name\":\"printIndex\",\"type\":\"uint256\"},{\"name\":\"minSalePriceInWei\",\"type\":\"uint256\"},{\"name\":\"toAddress\",\"type\":\"address\"}],\"name\":\"offerCollectibleForSaleToAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"DrawingPrintToAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"drawingIdToCollectibles\",\"outputs\":[{\"name\":\"drawingId\",\"type\":\"uint256\"},{\"name\":\"checkSum\",\"type\":\"string\"},{\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"name\":\"initialPrice\",\"type\":\"uint256\"},{\"name\":\"initialPrintIndex\",\"type\":\"uint256\"},{\"name\":\"collectionId\",\"type\":\"uint256\"},{\"name\":\"authorUId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Bids\",\"outputs\":[{\"name\":\"hasBid\",\"type\":\"bool\"},{\"name\":\"drawingId\",\"type\":\"uint256\"},{\"name\":\"printIndex\",\"type\":\"uint256\"},{\"name\":\"bidder\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"drawingId\",\"type\":\"uint256\"},{\"name\":\"printIndex\",\"type\":\"uint256\"}],\"name\":\"enterBidForCollectible\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mintNewDrawings\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"drawingId\",\"type\":\"uint256\"},{\"name\":\"checkSum\",\"type\":\"string\"},{\"name\":\"_totalSupply\",\"type\":\"uint256\"},{\"name\":\"initialPrice\",\"type\":\"uint256\"},{\"name\":\"initialPrintIndex\",\"type\":\"uint256\"},{\"name\":\"collectionId\",\"type\":\"uint256\"},{\"name\":\"authorUId\",\"type\":\"uint256\"}],\"name\":\"newCollectible\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"drawingId\",\"type\":\"uint256\"},{\"name\":\"printIndex\",\"type\":\"uint256\"}],\"name\":\"alt_buyCollectible\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"drawingId\",\"type\":\"uint256\"},{\"name\":\"printIndex\",\"type\":\"uint256\"}],\"name\":\"withdrawOfferForCollectible\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"drawingId\",\"type\":\"uint256\"},{\"name\":\"printIndex\",\"type\":\"uint256\"},{\"name\":\"minSalePriceInWei\",\"type\":\"uint256\"}],\"name\":\"offerCollectibleForSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pendingWithdrawals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"drawingId\",\"type\":\"uint256\"},{\"name\":\"printIndex\",\"type\":\"uint256\"}],\"name\":\"withdrawBidForCollectible\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"collectibleIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"printIndex\",\"type\":\"uint256\"}],\"name\":\"Assigned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"collectibleIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"printIndex\",\"type\":\"uint256\"}],\"name\":\"CollectibleTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"collectibleIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"printIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"minValue\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"toAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"lastSellValue\",\"type\":\"uint256\"}],\"name\":\"CollectibleOffered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"collectibleIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"printIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"fromAddress\",\"type\":\"address\"}],\"name\":\"CollectibleBidEntered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"collectibleIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"printIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"fromAddress\",\"type\":\"address\"}],\"name\":\"CollectibleBidWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"collectibleIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"printIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"fromAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"toAddress\",\"type\":\"address\"}],\"name\":\"CollectibleBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"collectibleIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"printIndex\",\"type\":\"uint256\"}],\"name\":\"CollectibleNoLongerForSale\",\"type\":\"event\"}]","ContractName":"DigitalArtCollectible","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://0f87837be36cc6e30be7e5c172093b2e19a034f48c764ff6a40c1f041c00d56b"}]}