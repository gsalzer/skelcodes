{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.6;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract Owned {\r\n\r\n    // The address of the account that is the current owner\r\n    address public owner;\r\n\r\n    // The publiser is the inital owner\r\n    function Owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * Restricted access to the current owner\r\n     */\r\n    modifier onlyOwner() {\r\n        if (msg.sender != owner) throw;\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Transfer ownership to `_newOwner`\r\n     *\r\n     * @param _newOwner The address of the account that will become the new owner\r\n     */\r\n    function transferOwnership(address _newOwner) onlyOwner {\r\n        owner = _newOwner;\r\n    }\r\n}\r\n\r\n// Abstract contract for the full ERC 20 Token standard\r\n// https://github.com/ethereum/EIPs/issues/20\r\ncontract Token {\r\n    /* This is a slight change to the ERC20 base standard.\r\n    function totalSupply() constant returns (uint256 supply);\r\n    is replaced with:\r\n    uint256 public totalSupply;\r\n    This automatically creates a getter function for the totalSupply.\r\n    This is moved to the base contract since public getter functions are not\r\n    currently recognised as an implementation of the matching abstract\r\n    function by the compiler.\r\n    */\r\n    /// total amount of tokens\r\n    uint256 public totalSupply;\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of tokens to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n/**\r\n * @title RICH token\r\n *\r\n * Implements ERC 20 Token standard: https://github.com/ethereum/EIPs/issues/20 with the addition\r\n * of ownership, a lock and issuing.\r\n *\r\n * #created 05/03/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract RICHToken is Owned, Token {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    // Ethereum token standaard\r\n    string public standard = \"Token 0.1\";\r\n\r\n    // Full name\r\n    string public name = \"RICH\";\r\n\r\n    // Symbol\r\n    string public symbol = \"RICH\";\r\n\r\n    // No decimal points\r\n    uint8 public decimals = 8;\r\n\r\n    // Token starts if the locked state restricting transfers\r\n    bool public locked;\r\n\r\n    uint256 public crowdsaleStart; // Reference to time of first crowd sale\r\n    uint256 public icoPeriod = 10 days;\r\n    uint256 public noIcoPeriod = 10 days;\r\n    mapping (address => mapping (uint256 => uint256)) balancesPerIcoPeriod;\r\n\r\n    uint256 public burnPercentageDefault = 1; // 0.01%\r\n    uint256 public burnPercentage10m = 5; // 0.05%\r\n    uint256 public burnPercentage100m = 50; // 0.5%\r\n    uint256 public burnPercentage1000m = 100; // 1%\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    /**\r\n     * Get burning line. All investors that own less than burning line\r\n     * will lose some tokens if they don't invest each round 20% more tokens\r\n     *\r\n     * @return burnLine\r\n     */\r\n    function getBurnLine() returns (uint256 burnLine) {\r\n        if (totalSupply < 10**7 * 10**8) {\r\n            return totalSupply * burnPercentageDefault / 10000;\r\n        }\r\n\r\n        if (totalSupply < 10**8 * 10**8) {\r\n            return totalSupply * burnPercentage10m / 10000;\r\n        }\r\n\r\n        if (totalSupply < 10**9 * 10**8) {\r\n            return totalSupply * burnPercentage100m / 10000;\r\n        }\r\n\r\n        return totalSupply * burnPercentage1000m / 10000;\r\n    }\r\n\r\n    /**\r\n     * Return ICO number (PreIco has index 0)\r\n     *\r\n     * @return ICO number\r\n     */\r\n    function getCurrentIcoNumber() returns (uint256 icoNumber) {\r\n        uint256 timeBehind = now - crowdsaleStart;\r\n\r\n        if (now < crowdsaleStart) {\r\n            return 0;\r\n        }\r\n\r\n        return 1 + ((timeBehind - (timeBehind % (icoPeriod + noIcoPeriod))) / (icoPeriod + noIcoPeriod));\r\n    }\r\n\r\n    /**\r\n     * Get balance of `_owner`\r\n     *\r\n     * @param _owner The address from which the balance will be retrieved\r\n     * @return The balance\r\n     */\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    /**\r\n     * Start of the crowd sale can be set only once\r\n     *\r\n     * @param _start start of the crowd sale\r\n     */\r\n    function setCrowdSaleStart(uint256 _start) onlyOwner {\r\n        if (crowdsaleStart > 0) {\r\n            return;\r\n        }\r\n\r\n        crowdsaleStart = _start;\r\n    }\r\n\r\n    /**\r\n     * Send `_value` token to `_to` from `msg.sender`\r\n     *\r\n     * @param _to The address of the recipient\r\n     * @param _value The amount of token to be transferred\r\n     * @return Whether the transfer was successful or not\r\n     */\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n\r\n        // Unable to transfer while still locked\r\n        if (locked) {\r\n            throw;\r\n        }\r\n\r\n        // Check if the sender has enough tokens\r\n        if (balances[msg.sender] < _value) {\r\n            throw;\r\n        }\r\n\r\n        // Check for overflows\r\n        if (balances[_to] + _value < balances[_to])  {\r\n            throw;\r\n        }\r\n\r\n        // Transfer tokens\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n\r\n        // Notify listners\r\n        Transfer(msg.sender, _to, _value);\r\n\r\n        balancesPerIcoPeriod[_to][getCurrentIcoNumber()] = balances[_to];\r\n        balancesPerIcoPeriod[msg.sender][getCurrentIcoNumber()] = balances[msg.sender];\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n     *\r\n     * @param _from The address of the sender\r\n     * @param _to The address of the recipient\r\n     * @param _value The amount of token to be transferred\r\n     * @return Whether the transfer was successful or not\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n\r\n         // Unable to transfer while still locked\r\n        if (locked) {\r\n            throw;\r\n        }\r\n\r\n        // Check if the sender has enough\r\n        if (balances[_from] < _value) {\r\n            throw;\r\n        }\r\n\r\n        // Check for overflows\r\n        if (balances[_to] + _value < balances[_to]) {\r\n            throw;\r\n        }\r\n\r\n        // Check allowance\r\n        if (_value > allowed[_from][msg.sender]) {\r\n            throw;\r\n        }\r\n\r\n        // Transfer tokens\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n\r\n        // Update allowance\r\n        allowed[_from][msg.sender] -= _value;\r\n\r\n        // Notify listners\r\n        Transfer(_from, _to, _value);\r\n\r\n        balancesPerIcoPeriod[_to][getCurrentIcoNumber()] = balances[_to];\r\n        balancesPerIcoPeriod[_from][getCurrentIcoNumber()] = balances[_from];\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * `msg.sender` approves `_spender` to spend `_value` tokens\r\n     *\r\n     * @param _spender The address of the account able to transfer the tokens\r\n     * @param _value The amount of tokens to be approved for transfer\r\n     * @return Whether the approval was successful or not\r\n     */\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n\r\n        // Unable to approve while still locked\r\n        if (locked) {\r\n            throw;\r\n        }\r\n\r\n        // Update allowance\r\n        allowed[msg.sender][_spender] = _value;\r\n\r\n        // Notify listners\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     * Get the amount of remaining tokens that `_spender` is allowed to spend from `_owner`\r\n     *\r\n     * @param _owner The address of the account owning tokens\r\n     * @param _spender The address of the account able to transfer the tokens\r\n     * @return Amount of remaining tokens allowed to spent\r\n     */\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n     * Starts with a total supply of zero and the creator starts with\r\n     * zero tokens (just like everyone else)\r\n     */\r\n    function RICHToken() {\r\n        balances[msg.sender] = 0;\r\n        totalSupply = 0;\r\n        locked = false;\r\n    }\r\n\r\n\r\n    /**\r\n     * Unlocks the token irreversibly so that the transfering of value is enabled\r\n     *\r\n     * @return Whether the unlocking was successful or not\r\n     */\r\n    function unlock() onlyOwner returns (bool success)  {\r\n        locked = false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Restricted access to the current owner\r\n     */\r\n    modifier onlyOwner() {\r\n        if (msg.sender != owner) throw;\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Issues `_value` new tokens to `_recipient`\r\n     *\r\n     * @param _recipient The address to which the tokens will be issued\r\n     * @param _value The amount of new tokens to issue\r\n     * @return Whether the approval was successful or not\r\n     */\r\n    function issue(address _recipient, uint256 _value) onlyOwner returns (bool success) {\r\n\r\n        // Create tokens\r\n        balances[_recipient] += _value;\r\n        totalSupply += _value;\r\n\r\n        balancesPerIcoPeriod[_recipient][getCurrentIcoNumber()] = balances[_recipient];\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Check if investor has invested enough to avoid burning\r\n     *\r\n     * @param _investor Investor\r\n     * @return Whether investor has invested enough or not\r\n     */\r\n    function isIncreasedEnough(address _investor) returns (bool success) {\r\n        uint256 currentIcoNumber = getCurrentIcoNumber();\r\n\r\n        if (currentIcoNumber - 2 < 0) {\r\n            return true;\r\n        }\r\n\r\n        uint256 currentBalance = balances[_investor];\r\n        uint256 icosBefore = balancesPerIcoPeriod[_investor][currentIcoNumber - 2];\r\n\r\n        if (icosBefore == 0) {\r\n            for(uint i = currentIcoNumber; i >= 2; i--) {\r\n                icosBefore = balancesPerIcoPeriod[_investor][i-2];\r\n\r\n                if (icosBefore != 0) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (currentBalance < icosBefore) {\r\n            return false;\r\n        }\r\n\r\n        if (currentBalance - icosBefore > icosBefore * 12 / 10) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Function that everyone can call and burn for other tokens if they can\r\n     * be burned. In return, 10% of burned tokens go to executor of function\r\n     *\r\n     * @param _investor Address of investor which tokens are subject of burn\r\n     */\r\n    function burn(address _investor) public {\r\n\r\n        uint256 burnLine = getBurnLine();\r\n\r\n        if (balances[_investor] > burnLine || isIncreasedEnough(_investor)) {\r\n            return;\r\n        }\r\n\r\n        uint256 toBeBurned = burnLine - balances[_investor];\r\n        if (toBeBurned > balances[_investor]) {\r\n            toBeBurned = balances[_investor];\r\n        }\r\n\r\n        // 10% for executor\r\n        uint256 executorReward = toBeBurned / 10;\r\n\r\n        balances[msg.sender] = balances[msg.sender].add(executorReward);\r\n        balances[_investor] = balances[_investor].sub(toBeBurned);\r\n        totalSupply = totalSupply.sub(toBeBurned - executorReward);\r\n        Burn(_investor, toBeBurned);\r\n    }\r\n\r\n    event Burn(address indexed burner, uint indexed value);\r\n\r\n    /**\r\n     * Prevents accidental sending of ether\r\n     */\r\n    function () {\r\n        throw;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"burnPercentage1000m\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_start\",\"type\":\"uint256\"}],\"name\":\"setCrowdSaleStart\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getCurrentIcoNumber\",\"outputs\":[{\"name\":\"icoNumber\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"burnPercentageDefault\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"standard\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getBurnLine\",\"outputs\":[{\"name\":\"burnLine\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"issue\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"noIcoPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"burnPercentage100m\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unlock\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"isIncreasedEnough\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"burnPercentage10m\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleStart\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"locked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"RICHToken","CompilerVersion":"v0.4.16+commit.d7661dd9","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://b273009e7bb8a7472c76cf99ea1b012a787c87133978c55e8ea3f0afe0763e06"}]}