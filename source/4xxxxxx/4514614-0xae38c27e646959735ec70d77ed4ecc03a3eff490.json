{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.15;\r\n\r\n/// @title provides subject to role checking logic\r\ncontract IAccessPolicy {\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    /// @notice We don't make this function constant to allow for state-updating access controls such as rate limiting.\r\n    /// @dev checks if subject belongs to requested role for particular object\r\n    /// @param subject address to be checked against role, typically msg.sender\r\n    /// @param role identifier of required role\r\n    /// @param object contract instance context for role checking, typically contract requesting the check\r\n    /// @param verb additional data, in current AccessControll implementation msg.sig\r\n    /// @return if subject belongs to a role\r\n    function allowed(\r\n        address subject,\r\n        bytes32 role,\r\n        address object,\r\n        bytes4 verb\r\n    )\r\n        public\r\n        returns (bool);\r\n}\r\n\r\n/// @title enables access control in implementing contract\r\n/// @dev see AccessControlled for implementation\r\ncontract IAccessControlled {\r\n\r\n    ////////////////////////\r\n    // Events\r\n    ////////////////////////\r\n\r\n    /// @dev must log on access policy change\r\n    event LogAccessPolicyChanged(\r\n        address controller,\r\n        IAccessPolicy oldPolicy,\r\n        IAccessPolicy newPolicy\r\n    );\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    /// @dev allows to change access control mechanism for this contract\r\n    ///     this method must be itself access controlled, see AccessControlled implementation and notice below\r\n    /// @notice it is a huge issue for Solidity that modifiers are not part of function signature\r\n    ///     then interfaces could be used for example to control access semantics\r\n    /// @param newPolicy new access policy to controll this contract\r\n    /// @param newAccessController address of ROLE_ACCESS_CONTROLLER of new policy that can set access to this contract\r\n    function setAccessPolicy(IAccessPolicy newPolicy, address newAccessController)\r\n        public;\r\n\r\n    function accessPolicy()\r\n        public\r\n        constant\r\n        returns (IAccessPolicy);\r\n\r\n}\r\n\r\ncontract StandardRoles {\r\n\r\n    ////////////////////////\r\n    // Constants\r\n    ////////////////////////\r\n\r\n    // @notice Soldity somehow doesn't evaluate this compile time\r\n    // @dev role which has rights to change permissions and set new policy in contract, keccak256(\"AccessController\")\r\n    bytes32 internal constant ROLE_ACCESS_CONTROLLER = 0xac42f8beb17975ed062dcb80c63e6d203ef1c2c335ced149dc5664cc671cb7da;\r\n}\r\n\r\n/// @title Granular code execution permissions\r\n/// @notice Intended to replace existing Ownable pattern with more granular permissions set to execute smart contract functions\r\n///     for each function where 'only' modifier is applied, IAccessPolicy implementation is called to evaluate if msg.sender belongs to required role for contract being called.\r\n///     Access evaluation specific belong to IAccessPolicy implementation, see RoleBasedAccessPolicy for details.\r\n/// @dev Should be inherited by a contract requiring such permissions controll. IAccessPolicy must be provided in constructor. Access policy may be replaced to a different one\r\n///     by msg.sender with ROLE_ACCESS_CONTROLLER role\r\ncontract AccessControlled is IAccessControlled, StandardRoles {\r\n\r\n    ////////////////////////\r\n    // Mutable state\r\n    ////////////////////////\r\n\r\n    IAccessPolicy private _accessPolicy;\r\n\r\n    ////////////////////////\r\n    // Modifiers\r\n    ////////////////////////\r\n\r\n    /// @dev limits function execution only to senders assigned to required 'role'\r\n    modifier only(bytes32 role) {\r\n        require(_accessPolicy.allowed(msg.sender, role, this, msg.sig));\r\n        _;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Constructor\r\n    ////////////////////////\r\n\r\n    function AccessControlled(IAccessPolicy policy) internal {\r\n        require(address(policy) != 0x0);\r\n        _accessPolicy = policy;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    //\r\n    // Implements IAccessControlled\r\n    //\r\n\r\n    function setAccessPolicy(IAccessPolicy newPolicy, address newAccessController)\r\n        public\r\n        only(ROLE_ACCESS_CONTROLLER)\r\n    {\r\n        // ROLE_ACCESS_CONTROLLER must be present\r\n        // under the new policy. This provides some\r\n        // protection against locking yourself out.\r\n        require(newPolicy.allowed(newAccessController, ROLE_ACCESS_CONTROLLER, this, msg.sig));\r\n\r\n        // We can now safely set the new policy without foot shooting.\r\n        IAccessPolicy oldPolicy = _accessPolicy;\r\n        _accessPolicy = newPolicy;\r\n\r\n        // Log event\r\n        LogAccessPolicyChanged(msg.sender, oldPolicy, newPolicy);\r\n    }\r\n\r\n    function accessPolicy()\r\n        public\r\n        constant\r\n        returns (IAccessPolicy)\r\n    {\r\n        return _accessPolicy;\r\n    }\r\n}\r\n\r\ncontract AccessRoles {\r\n\r\n    ////////////////////////\r\n    // Constants\r\n    ////////////////////////\r\n\r\n    // NOTE: All roles are set to the keccak256 hash of the\r\n    // CamelCased role name, i.e.\r\n    // ROLE_LOCKED_ACCOUNT_ADMIN = keccak256(\"LockedAccountAdmin\")\r\n\r\n    // may setup LockedAccount, change disbursal mechanism and set migration\r\n    bytes32 internal constant ROLE_LOCKED_ACCOUNT_ADMIN = 0x4675da546d2d92c5b86c4f726a9e61010dce91cccc2491ce6019e78b09d2572e;\r\n\r\n    // may setup whitelists and abort whitelisting contract with curve rollback\r\n    bytes32 internal constant ROLE_WHITELIST_ADMIN = 0xaef456e7c864418e1d2a40d996ca4febf3a7e317fe3af5a7ea4dda59033bbe5c;\r\n\r\n    // May issue (generate) Neumarks\r\n    bytes32 internal constant ROLE_NEUMARK_ISSUER = 0x921c3afa1f1fff707a785f953a1e197bd28c9c50e300424e015953cbf120c06c;\r\n\r\n    // May burn Neumarks it owns\r\n    bytes32 internal constant ROLE_NEUMARK_BURNER = 0x19ce331285f41739cd3362a3ec176edffe014311c0f8075834fdd19d6718e69f;\r\n\r\n    // May create new snapshots on Neumark\r\n    bytes32 internal constant ROLE_SNAPSHOT_CREATOR = 0x08c1785afc57f933523bc52583a72ce9e19b2241354e04dd86f41f887e3d8174;\r\n\r\n    // May enable/disable transfers on Neumark\r\n    bytes32 internal constant ROLE_TRANSFER_ADMIN = 0xb6527e944caca3d151b1f94e49ac5e223142694860743e66164720e034ec9b19;\r\n\r\n    // may reclaim tokens/ether from contracts supporting IReclaimable interface\r\n    bytes32 internal constant ROLE_RECLAIMER = 0x0542bbd0c672578966dcc525b30aa16723bb042675554ac5b0362f86b6e97dc5;\r\n\r\n    // represents legally platform operator in case of forks and contracts with legal agreement attached. keccak256(\"PlatformOperatorRepresentative\")\r\n    bytes32 internal constant ROLE_PLATFORM_OPERATOR_REPRESENTATIVE = 0xb2b321377653f655206f71514ff9f150d0822d062a5abcf220d549e1da7999f0;\r\n\r\n    // allows to deposit EUR-T and allow addresses to send and receive EUR-T. keccak256(\"EurtDepositManager\")\r\n    bytes32 internal constant ROLE_EURT_DEPOSIT_MANAGER = 0x7c8ecdcba80ce87848d16ad77ef57cc196c208fc95c5638e4a48c681a34d4fe7;\r\n}\r\n\r\ncontract IBasicToken {\r\n\r\n    ////////////////////////\r\n    // Events\r\n    ////////////////////////\r\n\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 amount);\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    /// @dev This function makes it easy to get the total number of tokens\r\n    /// @return The total number of tokens\r\n    function totalSupply()\r\n        public\r\n        constant\r\n        returns (uint256);\r\n\r\n    /// @param owner The address that's balance is being requested\r\n    /// @return The balance of `owner` at the current block\r\n    function balanceOf(address owner)\r\n        public\r\n        constant\r\n        returns (uint256 balance);\r\n\r\n    /// @notice Send `amount` tokens to `to` from `msg.sender`\r\n    /// @param to The address of the recipient\r\n    /// @param amount The amount of tokens to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address to, uint256 amount)\r\n        public\r\n        returns (bool success);\r\n\r\n}\r\n\r\n/// @title allows deriving contract to recover any token or ether that it has balance of\r\n/// @notice note that this opens your contracts to claims from various people saying they lost tokens and they want them back\r\n///     be ready to handle such claims\r\n/// @dev use with care!\r\n///     1. ROLE_RECLAIMER is allowed to claim tokens, it's not returning tokens to original owner\r\n///     2. in derived contract that holds any token by design you must override `reclaim` and block such possibility.\r\n///         see LockedAccount as an example\r\ncontract Reclaimable is AccessControlled, AccessRoles {\r\n\r\n    ////////////////////////\r\n    // Constants\r\n    ////////////////////////\r\n\r\n    IBasicToken constant internal RECLAIM_ETHER = IBasicToken(0x0);\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    function reclaim(IBasicToken token)\r\n        public\r\n        only(ROLE_RECLAIMER)\r\n    {\r\n        address reclaimer = msg.sender;\r\n        if(token == RECLAIM_ETHER) {\r\n            reclaimer.transfer(this.balance);\r\n        } else {\r\n            uint256 balance = token.balanceOf(this);\r\n            require(token.transfer(reclaimer, balance));\r\n        }\r\n    }\r\n}\r\n\r\n/// @title access policy based on Access Control Lists concept\r\n/// @dev Allows to assign an address to a set of roles (n:n relation) and querying if such specific assignment exists.\r\n///     This assignment happens in two contexts:\r\n///         - contract context which allows to build a set of local permissions enforced for particular contract\r\n///         - global context which defines set of global permissions that apply to any contract using this RoleBasedAccessPolicy as Access Policy\r\n///     Permissions are cascading as follows\r\n///         - evaluate permission for given subject for given object (local context)\r\n///         - evaluate permission for given subject for all objects (global context)\r\n///         - evaluate permissions for any subject (everyone) for given object (everyone local context)\r\n///         - evaluate permissions for any subject (everyone) for all objects (everyone global context)\r\n///         - if still unset then disallow\r\n///     Permission is cascaded up only if it was evaluated as Unset at particular level. See EVERYONE and GLOBAL definitions for special values (they are 0x0 addresses)\r\n///     RoleBasedAccessPolicy is its own policy. When created, creator has ROLE_ACCESS_CONTROLLER role. Right pattern is to transfer this control to some other (non deployer) account and then destroy deployer private key.\r\n///     See IAccessControlled for definitions of subject, object and role\r\ncontract RoleBasedAccessPolicy is\r\n    IAccessPolicy,\r\n    AccessControlled,\r\n    Reclaimable\r\n{\r\n\r\n    ////////////////\r\n    // Types\r\n    ////////////////\r\n\r\n    // Łukasiewicz logic values\r\n    enum TriState {\r\n        Unset,\r\n        Allow,\r\n        Deny\r\n    }\r\n\r\n    ////////////////////////\r\n    // Constants\r\n    ////////////////////////\r\n\r\n    IAccessControlled private constant GLOBAL = IAccessControlled(0x0);\r\n\r\n    address private constant EVERYONE = 0x0;\r\n\r\n    ////////////////////////\r\n    // Mutable state\r\n    ////////////////////////\r\n\r\n    /// @dev subject → role → object → allowed\r\n    mapping (address =>\r\n        mapping(bytes32 =>\r\n            mapping(address => TriState))) private _access;\r\n\r\n    /// @notice used to enumerate all users assigned to given role in object context\r\n    /// @dev object → role → addresses\r\n    mapping (address =>\r\n        mapping(bytes32 => address[])) private _accessList;\r\n\r\n    ////////////////////////\r\n    // Events\r\n    ////////////////////////\r\n\r\n    /// @dev logs change of permissions, 'controller' is an address with ROLE_ACCESS_CONTROLLER\r\n    event LogAccessChanged(\r\n        address controller,\r\n        address indexed subject,\r\n        bytes32 role,\r\n        address indexed object,\r\n        TriState oldValue,\r\n        TriState newValue\r\n    );\r\n\r\n    event LogAccess(\r\n        address indexed subject,\r\n        bytes32 role,\r\n        address indexed object,\r\n        bytes4 verb,\r\n        bool granted\r\n    );\r\n\r\n    ////////////////////////\r\n    // Constructor\r\n    ////////////////////////\r\n\r\n    function RoleBasedAccessPolicy()\r\n        AccessControlled(this) // We are our own policy. This is immutable.\r\n        public\r\n    {\r\n        // Issue the local and global AccessContoler role to creator\r\n        _access[msg.sender][ROLE_ACCESS_CONTROLLER][this] = TriState.Allow;\r\n        _access[msg.sender][ROLE_ACCESS_CONTROLLER][GLOBAL] = TriState.Allow;\r\n        // Update enumerator accordingly so those permissions are visible as any other\r\n        updatePermissionEnumerator(msg.sender, ROLE_ACCESS_CONTROLLER, this, TriState.Unset, TriState.Allow);\r\n        updatePermissionEnumerator(msg.sender, ROLE_ACCESS_CONTROLLER, GLOBAL, TriState.Unset, TriState.Allow);\r\n    }\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    // Overrides `AccessControlled.setAccessPolicy(IAccessPolicy,address)`\r\n    function setAccessPolicy(IAccessPolicy, address)\r\n        public\r\n        only(ROLE_ACCESS_CONTROLLER)\r\n    {\r\n        // `RoleBasedAccessPolicy` always controls its\r\n        // own access. Disallow changing this by overriding\r\n        // the `AccessControlled.setAccessPolicy` function.\r\n        revert();\r\n    }\r\n\r\n    // Implements `IAccessPolicy.allowed(address, bytes32, address, bytes4)`\r\n    function allowed(\r\n        address subject,\r\n        bytes32 role,\r\n        address object,\r\n        bytes4 verb\r\n    )\r\n        public\r\n        // constant // NOTE: Solidity does not allow subtyping interfaces\r\n        returns (bool)\r\n    {\r\n        bool set = false;\r\n        bool allow = false;\r\n        TriState value = TriState.Unset;\r\n\r\n        // Cascade local, global, everyone local, everyone global\r\n        value = _access[subject][role][object];\r\n        set = value != TriState.Unset;\r\n        allow = value == TriState.Allow;\r\n        if (!set) {\r\n            value = _access[subject][role][GLOBAL];\r\n            set = value != TriState.Unset;\r\n            allow = value == TriState.Allow;\r\n        }\r\n        if (!set) {\r\n            value = _access[EVERYONE][role][object];\r\n            set = value != TriState.Unset;\r\n            allow = value == TriState.Allow;\r\n        }\r\n        if (!set) {\r\n            value = _access[EVERYONE][role][GLOBAL];\r\n            set = value != TriState.Unset;\r\n            allow = value == TriState.Allow;\r\n        }\r\n        // If none is set then disallow\r\n        if (!set) {\r\n            allow = false;\r\n        }\r\n\r\n        // Log and return\r\n        LogAccess(subject, role, object, verb, allow);\r\n        return allow;\r\n    }\r\n\r\n    // Assign a role to a user globally\r\n    function setUserRole(\r\n        address subject,\r\n        bytes32 role,\r\n        IAccessControlled object,\r\n        TriState newValue\r\n    )\r\n        public\r\n        only(ROLE_ACCESS_CONTROLLER)\r\n    {\r\n        setUserRolePrivate(subject, role, object, newValue);\r\n    }\r\n\r\n    // Atomically change a set of role assignments\r\n    function setUserRoles(\r\n        address[] subjects,\r\n        bytes32[] roles,\r\n        IAccessControlled[] objects,\r\n        TriState[] newValues\r\n    )\r\n        public\r\n        only(ROLE_ACCESS_CONTROLLER)\r\n    {\r\n        require(subjects.length == roles.length);\r\n        require(subjects.length == objects.length);\r\n        require(subjects.length == newValues.length);\r\n        for(uint256 i = 0; i < subjects.length; ++i) {\r\n            setUserRolePrivate(subjects[i], roles[i], objects[i], newValues[i]);\r\n        }\r\n    }\r\n\r\n    function getValue(\r\n        address subject,\r\n        bytes32 role,\r\n        IAccessControlled object\r\n    )\r\n        public\r\n        constant\r\n        returns (TriState)\r\n    {\r\n        return _access[subject][role][object];\r\n    }\r\n\r\n    function getUsers(\r\n        IAccessControlled object,\r\n        bytes32 role\r\n    )\r\n        public\r\n        constant\r\n        returns (address[])\r\n    {\r\n        return _accessList[object][role];\r\n    }\r\n\r\n    ////////////////////////\r\n    // Private functions\r\n    ////////////////////////\r\n\r\n    function setUserRolePrivate(\r\n        address subject,\r\n        bytes32 role,\r\n        IAccessControlled object,\r\n        TriState newValue\r\n    )\r\n        private\r\n    {\r\n        // An access controler is not allowed to revoke his own right on this\r\n        // contract. This prevents access controlers from locking themselves\r\n        // out. We also require the current contract to be its own policy for\r\n        // this to work. This is enforced elsewhere.\r\n        require(role != ROLE_ACCESS_CONTROLLER || subject != msg.sender || object != this);\r\n\r\n        // Fetch old value and short-circuit no-ops\r\n        TriState oldValue = _access[subject][role][object];\r\n        if(oldValue == newValue) {\r\n            return;\r\n        }\r\n\r\n        // Update the mapping\r\n        _access[subject][role][object] = newValue;\r\n\r\n        // Update permission in enumerator\r\n        updatePermissionEnumerator(subject, role, object, oldValue, newValue);\r\n\r\n        // Log\r\n        LogAccessChanged(msg.sender, subject, role, object, oldValue, newValue);\r\n    }\r\n\r\n    function updatePermissionEnumerator(\r\n        address subject,\r\n        bytes32 role,\r\n        IAccessControlled object,\r\n        TriState oldValue,\r\n        TriState newValue\r\n    )\r\n        private\r\n    {\r\n        // Update the list on add / remove\r\n        address[] storage list = _accessList[object][role];\r\n        // Add new subject only when going form Unset to Allow/Deny\r\n        if(oldValue == TriState.Unset && newValue != TriState.Unset) {\r\n            list.push(subject);\r\n        }\r\n        // Remove subject when unsetting Allow/Deny\r\n        if(oldValue != TriState.Unset && newValue == TriState.Unset) {\r\n            for(uint256 i = 0; i < list.length; ++i) {\r\n                if(list[i] == subject) {\r\n                    // replace unset address with last address in the list, cut list size\r\n                    list[i] = list[list.length - 1];\r\n                    delete list[list.length - 1];\r\n                    list.length -= 1;\r\n                    // there will be no more matches\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"subject\",\"type\":\"address\"},{\"name\":\"role\",\"type\":\"bytes32\"},{\"name\":\"object\",\"type\":\"address\"}],\"name\":\"getValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"object\",\"type\":\"address\"},{\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getUsers\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"setAccessPolicy\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"subject\",\"type\":\"address\"},{\"name\":\"role\",\"type\":\"bytes32\"},{\"name\":\"object\",\"type\":\"address\"},{\"name\":\"verb\",\"type\":\"bytes4\"}],\"name\":\"allowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"subject\",\"type\":\"address\"},{\"name\":\"role\",\"type\":\"bytes32\"},{\"name\":\"object\",\"type\":\"address\"},{\"name\":\"newValue\",\"type\":\"uint8\"}],\"name\":\"setUserRole\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"subjects\",\"type\":\"address[]\"},{\"name\":\"roles\",\"type\":\"bytes32[]\"},{\"name\":\"objects\",\"type\":\"address[]\"},{\"name\":\"newValues\",\"type\":\"uint8[]\"}],\"name\":\"setUserRoles\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"accessPolicy\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"reclaim\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"controller\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"subject\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"object\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"oldValue\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"newValue\",\"type\":\"uint8\"}],\"name\":\"LogAccessChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"subject\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"object\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"verb\",\"type\":\"bytes4\"},{\"indexed\":false,\"name\":\"granted\",\"type\":\"bool\"}],\"name\":\"LogAccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"controller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"oldPolicy\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newPolicy\",\"type\":\"address\"}],\"name\":\"LogAccessPolicyChanged\",\"type\":\"event\"}]","ContractName":"RoleBasedAccessPolicy","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://e7a9dcfedd0e78aabf9d840c8660e0b34fd29bbdc2fe767e5fc96c77260eed22"}]}