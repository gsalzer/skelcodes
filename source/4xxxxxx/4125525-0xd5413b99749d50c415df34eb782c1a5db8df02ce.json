{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\ncontract ERC20 {\r\n\r\n    function totalSupply() constant returns (uint totalSupply);\r\n\r\n    function balanceOf(address _owner) constant returns (uint balance);\r\n\r\n    function transfer(address _to, uint _value) returns (bool success);\r\n\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool success);\r\n\r\n    function approve(address _spender, uint _value) returns (bool success);\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n\r\n}\r\n\r\ncontract owned {\r\n    address public _owner;\r\n\r\n    function owned() {\r\n        _owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == _owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) onlyOwner {\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract mortal is owned {\r\n    function mortal() { \r\n    }\r\n\r\n    function kill() onlyOwner {\r\n        selfdestruct(_owner);\r\n    }\r\n}\r\n\r\ncontract hackethereumIco is mortal {\r\n    uint256 public _amountRaised;\r\n    uint256 public _deadline;\r\n\r\n    uint256 private _timeBetweenWithdrawCalls;\r\n    uint256 private _timeBetweenControlFlipCalls;\r\n\r\n    uint256 private _priceIncrease1;\r\n    uint256 private _priceIncrease2;\r\n\r\n    bool private _hackedTenuous;\r\n    bool private _hackedEducated;\r\n    bool private _hackedAdept;\r\n    bool private _whitehatActive;\r\n\r\n    bool private _initialised;\r\n    \r\n    address private _beneficiary;\r\n    address private _hackerTenuous;\r\n    address private _hackerEducated;\r\n    address private _hackerAdept;\r\n    address private _hackerDecisive;\r\n    address private _whitehat;\r\n\r\n    uint256 private _lastHack;\r\n    uint256 private _lastWhitehat;\r\n    uint256 private _lastControlFlip;\r\n\r\n    uint256 private _initialPrice;\r\n\r\n    uint256 private constant _participationThreshold =  50000000000000000;\r\n    uint256 private constant _participationMax       = 500000000000000000;\r\n\r\n    uint256 private constant _hackTokenThreshold     =  10000000000000000;\r\n\r\n    hackoin public _hackoinToken;\r\n    hackoin public _tenuousToken;\r\n    hackoin public _educatedToken;\r\n    hackoin public _adeptToken;\r\n\r\n    mapping(address => uint256) private _balanceOf;\r\n\r\n    event FundTransfer(address indexed backer, string indexed transferType, uint256 amount);\r\n\r\n    function hackethereumIco(\r\n        address ifSuccessfulSendTo,\r\n        address hackerTenuousAddress,\r\n        address hackerEducatedAddress,\r\n        address hackerAdeptAddress,\r\n        address hackerDecisiveAddress,\r\n        address whitehatAddress\r\n        // uint256 durationInMinutes,\r\n        // uint256 timeBetweenWithdrawMinutes,\r\n        // uint256 timeBetweenFlipMinutes\r\n        \r\n    ) {\r\n        _beneficiary = ifSuccessfulSendTo;\r\n        _hackerTenuous = hackerTenuousAddress;\r\n        _hackerEducated = hackerEducatedAddress;\r\n        _hackerAdept = hackerAdeptAddress;\r\n        _hackerDecisive = hackerDecisiveAddress;\r\n        _whitehat = whitehatAddress;\r\n    \r\n        _initialised = false;\r\n    }\r\n\r\n    function initialise() onlyOwner {\r\n        require(!_initialised);\r\n\r\n        _deadline = 1504301337; // Fri, 01 Sep 2017 21:28:57 // now + durationInMinutes * 1 minutes; //1504231337\r\n\r\n        _timeBetweenWithdrawCalls = 30 minutes;\r\n        _timeBetweenControlFlipCalls = 300 minutes;\r\n\r\n        _priceIncrease2 = _deadline - 4 days;\r\n        _priceIncrease1 = _priceIncrease2 - 6 days;\r\n\r\n        _lastHack = now;//_deadline + 1 days;\r\n        _lastWhitehat = now;//_deadline + 1 days;\r\n        _lastControlFlip = now;//_deadline + 1 days;\r\n\r\n        _initialPrice = 1;\r\n\r\n        address tokenContractAddress = new hackoin(\"Hackoin\", \"HK\");\r\n        _hackoinToken = hackoin(tokenContractAddress);\r\n\r\n        address tenuousTokenContractAddress = new hackoin(\"Hackoin_Tenuous\", \"HKT\");\r\n        address educatedTokenContractAddress = new hackoin(\"Hackoin_Educated\", \"HKE\");\r\n        address adeptTokenContractAddress = new hackoin(\"Hackoin_Adept\", \"HKA\");\r\n\r\n        _tenuousToken = hackoin(tenuousTokenContractAddress);\r\n        _educatedToken = hackoin(educatedTokenContractAddress);\r\n        _adeptToken = hackoin(adeptTokenContractAddress);\r\n\r\n        _hackoinToken.mintToken(msg.sender, _participationMax*2);\r\n        _tenuousToken.mintToken(msg.sender, _hackTokenThreshold*2);\r\n        _educatedToken.mintToken(msg.sender, _hackTokenThreshold*2);\r\n        _adeptToken.mintToken(msg.sender, _hackTokenThreshold*2);\r\n        _initialised = true;\r\n    }\r\n\r\n    function adjustTiming(uint256 timeBetweenWithdrawMinutes, uint256 timeBetweenFlipMinutes) onlyOwner {\r\n        _timeBetweenWithdrawCalls = timeBetweenWithdrawMinutes * 1 minutes;\r\n        _timeBetweenControlFlipCalls = timeBetweenFlipMinutes * 1 minutes;\r\n    }\r\n\r\n    function () payable {\r\n        require(now < _deadline);\r\n\r\n        uint256 amount = msg.value;\r\n\r\n        uint256 currentPrice;\r\n        if(now < _priceIncrease1)\r\n        {\r\n            currentPrice = _initialPrice;\r\n        }\r\n        else if (now < _priceIncrease2)\r\n        {\r\n            currentPrice = _initialPrice * 2;\r\n        }\r\n        else\r\n        {\r\n            currentPrice = _initialPrice * 4;\r\n        }\r\n\r\n        uint256 tokenAmount = amount / currentPrice;\r\n\r\n        require(tokenAmount > 0);\r\n        require(_balanceOf[msg.sender] + amount >= _balanceOf[msg.sender]);\r\n        require(this.balance + amount >= this.balance);\r\n\r\n        _balanceOf[msg.sender] += amount;\r\n        _amountRaised += amount;\r\n\r\n        _hackoinToken.mintToken(msg.sender, tokenAmount);\r\n        FundTransfer(msg.sender, \"Ticket Purchase\", amount);\r\n    }\r\n\r\n    modifier afterDeadline()\r\n    { \r\n        require (now >= _deadline); \r\n        _;\r\n    }\r\n\r\n    function withdrawFunds(uint256 amount) afterDeadline {\r\n        require(_beneficiary == msg.sender);\r\n\r\n        require(this.balance > 0);\r\n        require(amount <= this.balance);\r\n\r\n        if (_beneficiary.send(amount))\r\n        {\r\n            FundTransfer(_beneficiary, \"Withdrawal\", amount);\r\n        }\r\n    }\r\n\r\n    function hackDecisive(address targetAddress, uint256 amount) afterDeadline {\r\n        require(msg.data.length == 32*2+4);\r\n        require(_hackerDecisive == msg.sender);\r\n\r\n        require(_hackoinToken.balanceOf(targetAddress) >= _participationMax*2);\r\n\r\n        require(this.balance > 0);\r\n        require(amount <= this.balance);\r\n\r\n        if (targetAddress.send(amount))\r\n        {\r\n            FundTransfer(targetAddress, \"Decisive hack\", amount);\r\n        }\r\n    }\r\n\r\n    function whitehatRecover() afterDeadline {\r\n        require(_whitehat == msg.sender);\r\n        require(_whitehatActive);\r\n\r\n        require(_lastWhitehat + _timeBetweenWithdrawCalls < now);\r\n\r\n        require(this.balance > 0);\r\n\r\n        uint amount;\r\n        if(_amountRaised > 500 ether)\r\n        {\r\n            amount = _amountRaised / 50;\r\n        }\r\n        else if(_amountRaised > 100 ether)\r\n        {\r\n            amount = _amountRaised / 20;\r\n        }\r\n        else\r\n        {\r\n            amount = _amountRaised / 10;\r\n        }\r\n        \r\n        if(amount > this.balance)\r\n        {\r\n            amount = this.balance;\r\n        }\r\n\r\n        _lastWhitehat = now;\r\n\r\n        if (_whitehat.send(amount))\r\n        {\r\n            FundTransfer(_whitehat, \"Whitehat recovery\", amount);\r\n        }\r\n    }\r\n\r\n    function hack(address targetAddress) afterDeadline {\r\n        require(msg.data.length == 32+4);\r\n\r\n        require(_hackerTenuous == msg.sender || _hackerEducated == msg.sender || _hackerAdept == msg.sender);\r\n        require(_hackedTenuous);\r\n        require(_hackedEducated);\r\n        require(_hackedAdept);\r\n        require(!_whitehatActive);\r\n\r\n        require(_lastHack + _timeBetweenWithdrawCalls < now);\r\n\r\n        require(this.balance > 0);\r\n\r\n        require(_hackoinToken.balanceOf(targetAddress) >= _participationThreshold);\r\n\r\n        require(_tenuousToken.balanceOf(targetAddress) >= _hackTokenThreshold);\r\n        require(_educatedToken.balanceOf(targetAddress) >= _hackTokenThreshold);\r\n        require(_adeptToken.balanceOf(targetAddress) >= _hackTokenThreshold);\r\n\r\n        uint minAmount;\r\n        if(_amountRaised > 500 ether)\r\n        {\r\n            minAmount = _amountRaised / 500;\r\n        }\r\n        else if(_amountRaised > 100 ether)\r\n        {\r\n            minAmount = _amountRaised / 200;\r\n        }\r\n        else\r\n        {\r\n            minAmount = _amountRaised / 100;\r\n        }\r\n\r\n\r\n        uint256 participationAmount = _hackoinToken.balanceOf(targetAddress);\r\n        if(participationAmount > _participationMax)\r\n        {\r\n            participationAmount = _participationMax;\r\n        }\r\n\r\n        uint256 ratio = participationAmount / _participationThreshold;\r\n        uint256 amount = minAmount * ratio;\r\n        \r\n        if(amount > this.balance)\r\n        {\r\n            amount = this.balance;\r\n        }\r\n\r\n        _lastHack = now;\r\n\r\n        if (targetAddress.send(amount))\r\n        {\r\n            FundTransfer(targetAddress, \"Hack\", amount);\r\n        }\r\n    }\r\n\r\n    function hackTenuous(address targetAddress) afterDeadline {\r\n        require(msg.data.length == 32+4);\r\n        require(_hackerTenuous == msg.sender);\r\n\r\n        if(!_hackedTenuous) {\r\n            require(_lastControlFlip + _timeBetweenControlFlipCalls < now);\r\n        }\r\n\r\n        _hackedTenuous = true;\r\n\r\n        if(_tenuousToken.balanceOf(targetAddress) == 0) {\r\n            _tenuousToken.mintToken(targetAddress, _hackTokenThreshold);\r\n        }\r\n    }\r\n\r\n    function hackEducated(address targetAddress) afterDeadline {\r\n        require(msg.data.length == 32+4);\r\n        require(_hackerEducated == msg.sender);\r\n        require(_hackedTenuous);\r\n\r\n        if(!_hackedEducated) {\r\n            require(_lastControlFlip + _timeBetweenControlFlipCalls < now);\r\n        }\r\n\r\n        _hackedEducated = true;\r\n\r\n        if(_educatedToken.balanceOf(targetAddress) == 0) {\r\n            _educatedToken.mintToken(targetAddress, _hackTokenThreshold);\r\n        }\r\n    }\r\n\r\n    function hackAdept(address targetAddress) afterDeadline {\r\n        require(msg.data.length == 32+4);\r\n        require(_hackerAdept == msg.sender);\r\n        require(_hackedTenuous && _hackedEducated);\r\n\r\n        if(!_hackedAdept) {\r\n            require(_lastControlFlip + _timeBetweenControlFlipCalls < now);\r\n            _lastControlFlip = now;\r\n        }\r\n\r\n        _whitehatActive = false;\r\n        _hackedAdept = true;\r\n\r\n        if(_adeptToken.balanceOf(targetAddress) == 0) {\r\n            _adeptToken.mintToken(targetAddress, _hackTokenThreshold);\r\n        }\r\n    }\r\n\r\n    function whiteHat() afterDeadline {\r\n        require(_whitehat == msg.sender);\r\n        require(_lastControlFlip + _timeBetweenControlFlipCalls < now);\r\n        _hackedTenuous = false;\r\n        _hackedEducated = false;\r\n        _hackedAdept = false;\r\n\r\n        if(!_whitehatActive){\r\n            _lastControlFlip = now;\r\n        }\r\n\r\n        _whitehatActive = true;\r\n    }\r\n\r\n    function kill() onlyOwner {\r\n        _hackoinToken.kill();\r\n        _tenuousToken.kill();\r\n        _educatedToken.kill();\r\n        _adeptToken.kill();\r\n        mortal.kill();\r\n    }\r\n\r\n    // function transferHackoinTokenOwnership(address newOwner) onlyOwner afterDeadline {\r\n    //     require(msg.data.length == 32+4);\r\n    //     _hackoinToken.transferOwnership(newOwner);\r\n    // }\r\n\r\n    // function transferTenuousTokenOwnership(address newOwner) onlyOwner afterDeadline {\r\n    //     require(msg.data.length == 32+4);\r\n    //     _tenuousToken.transferOwnership(newOwner);\r\n    // }\r\n\r\n    // function transferEducatedTokenOwnership(address newOwner) onlyOwner afterDeadline {\r\n    //     require(msg.data.length == 32+4);\r\n    //     _educatedToken.transferOwnership(newOwner);\r\n    // }\r\n\r\n    // function transferAdeptTokenOwnership(address newOwner) onlyOwner afterDeadline {\r\n    //     require(msg.data.length == 32+4);\r\n    //     _adeptToken.transferOwnership(newOwner);\r\n    // }\r\n}\r\n\r\ncontract hackoin is ERC20, owned, mortal {\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public constant decimals = 16;\r\n\r\n    uint256 public _totalSupply;\r\n\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    function hackoin(string _name, string _symbol) {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        _totalSupply = 0;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        require(msg.data.length == 32*2+4);\r\n\r\n        require(balances[msg.sender] >= _value);\r\n        require(_value > 0);\r\n        require(balances[_to] + _value >= balances[_to]);\r\n\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _amount) returns (bool success) {\r\n        require(msg.data.length == 32*3+4);\r\n\r\n        require(balances[_from] >= _amount);\r\n        require(allowed[_from][msg.sender] >= _amount);\r\n        require(_amount > 0);\r\n        require(balances[_to] + _amount > balances[_to]);\r\n\r\n        balances[_from] -= _amount;\r\n        allowed[_from][msg.sender] -= _amount;\r\n        balances[_to] += _amount;\r\n        Transfer(_from, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    function mintToken(address target, uint256 mintedAmount) onlyOwner {\r\n        require(msg.data.length == 32*2+4);\r\n\r\n        balances[target] += mintedAmount;\r\n        _totalSupply += mintedAmount;\r\n        Transfer(0, _owner, mintedAmount);\r\n        Transfer(_owner, target, mintedAmount);\r\n    }\r\n\r\n    function totalSupply() constant returns (uint256 totalSupply) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        require(msg.data.length == 32+4);\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        require(msg.data.length == 32*2+4);\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        require(msg.data.length == 32*2+4);\r\n        return allowed[_owner][_spender];\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"targetAddress\",\"type\":\"address\"}],\"name\":\"hackAdept\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_adeptToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_deadline\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_tenuousToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"targetAddress\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"hackDecisive\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initialise\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"timeBetweenWithdrawMinutes\",\"type\":\"uint256\"},{\"name\":\"timeBetweenFlipMinutes\",\"type\":\"uint256\"}],\"name\":\"adjustTiming\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"targetAddress\",\"type\":\"address\"}],\"name\":\"hack\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_amountRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_hackoinToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"targetAddress\",\"type\":\"address\"}],\"name\":\"hackTenuous\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"whitehatRecover\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"whiteHat\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_educatedToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"targetAddress\",\"type\":\"address\"}],\"name\":\"hackEducated\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"ifSuccessfulSendTo\",\"type\":\"address\"},{\"name\":\"hackerTenuousAddress\",\"type\":\"address\"},{\"name\":\"hackerEducatedAddress\",\"type\":\"address\"},{\"name\":\"hackerAdeptAddress\",\"type\":\"address\"},{\"name\":\"hackerDecisiveAddress\",\"type\":\"address\"},{\"name\":\"whitehatAddress\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"backer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"transferType\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundTransfer\",\"type\":\"event\"}]","ContractName":"hackethereumIco","CompilerVersion":"v0.4.13+commit.fb4cb1a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000744b33eb98b848ff482a849798862e2d7a0be9000000000000000000000000000735b2668c4708ff5d3cbeab35c8481d3342df00000000000000000000000000e8c866b7adbd7cc17aad5f77cc643e77bf187a00000000000000000000000000f391537cef53f3b015a9a625824313178eb99800000000000000000000000000b8ff146a6fac5dd940760b2896240c7ac655fc00000000000000000000000000a350507513b2ae18af4614863daa9d23ee0b7b","Library":"","SwarmSource":"bzzr://4368e05a299d6aa4810e916dd10a13b1c4d6dce8fda46e30af5f3aa971f1862c"}]}