{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.15;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract OraclizeI {\r\n    address public cbAddress;\r\n    function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id);\r\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id);\r\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id);\r\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id);\r\n    function queryN(uint _timestamp, string _datasource, bytes _argN) payable returns (bytes32 _id);\r\n    function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) payable returns (bytes32 _id);\r\n    function getPrice(string _datasource) returns (uint _dsprice);\r\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\r\n    function useCoupon(string _coupon);\r\n    function setProofType(byte _proofType);\r\n    function setConfig(bytes32 _config);\r\n    function setCustomGasPrice(uint _gasPrice);\r\n    function randomDS_getSessionPubKeyHash() returns(bytes32);\r\n}\r\ncontract OraclizeAddrResolverI {\r\n    function getAddress() returns (address _addr);\r\n}\r\ncontract usingOraclize {\r\n    uint constant day = 60*60*24;\r\n    uint constant week = 60*60*24*7;\r\n    uint constant month = 60*60*24*30;\r\n    byte constant proofType_NONE = 0x00;\r\n    byte constant proofType_TLSNotary = 0x10;\r\n    byte constant proofType_Android = 0x20;\r\n    byte constant proofType_Ledger = 0x30;\r\n    byte constant proofType_Native = 0xF0;\r\n    byte constant proofStorage_IPFS = 0x01;\r\n    uint8 constant networkID_auto = 0;\r\n    uint8 constant networkID_mainnet = 1;\r\n    uint8 constant networkID_testnet = 2;\r\n    uint8 constant networkID_morden = 2;\r\n    uint8 constant networkID_consensys = 161;\r\n\r\n    OraclizeAddrResolverI OAR;\r\n\r\n    OraclizeI oraclize;\r\n    modifier oraclizeAPI {\r\n        if((address(OAR)==0)||(getCodeSize(address(OAR))==0)) oraclize_setNetwork(networkID_auto);\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        _;\r\n    }\r\n    modifier coupon(string code){\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        oraclize.useCoupon(code);\r\n        _;\r\n    }\r\n\r\n    function oraclize_setNetwork(uint8) internal returns(bool){\r\n//    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\r\n        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){ //mainnet\r\n            OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\r\n            oraclize_setNetworkName(\"eth_mainnet\");\r\n            return true;\r\n        }\r\n        if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){ //ropsten testnet\r\n            OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\r\n            oraclize_setNetworkName(\"eth_ropsten3\");\r\n            return true;\r\n        }\r\n        if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){ //kovan testnet\r\n            OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\r\n            oraclize_setNetworkName(\"eth_kovan\");\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){ //rinkeby testnet\r\n            OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\r\n            oraclize_setNetworkName(\"eth_rinkeby\");\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){ //ethereum-bridge\r\n            OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){ //ether.camp ide\r\n            OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){ //browser-solidity\r\n            OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function __callback(bytes32 myid, string result) {\r\n        __callback(myid, result, new bytes(0));\r\n    }\r\n    function __callback(bytes32, string, bytes) {\r\n//    function __callback(bytes32 myid, string result, bytes proof) {\r\n    }\r\n\r\n    function oraclize_useCoupon(string code) oraclizeAPI internal {\r\n        oraclize.useCoupon(code);\r\n    }\r\n\r\n    function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\r\n        return oraclize.getPrice(datasource);\r\n    }\r\n\r\n    function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\r\n        return oraclize.getPrice(datasource, gaslimit);\r\n    }\r\n\r\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(0, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(timestamp, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        bytes memory args = stra2cbor(argN);\r\n        return oraclize.queryN.value(price)(0, datasource, args);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        bytes memory args = stra2cbor(argN);\r\n        return oraclize.queryN.value(price)(timestamp, datasource, args);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        bytes memory args = stra2cbor(argN);\r\n        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        bytes memory args = stra2cbor(argN);\r\n        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](1);\r\n        dynargs[0] = args[0];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](1);\r\n        dynargs[0] = args[0];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](1);\r\n        dynargs[0] = args[0];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](1);\r\n        dynargs[0] = args[0];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n\r\n    function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](2);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](2);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](2);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](2);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](3);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](3);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](3);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](3);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n\r\n    function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](4);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](4);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](4);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](4);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](5);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        dynargs[4] = args[4];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](5);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        dynargs[4] = args[4];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](5);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        dynargs[4] = args[4];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](5);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        dynargs[4] = args[4];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        bytes memory args = ba2cbor(argN);\r\n        return oraclize.queryN.value(price)(0, datasource, args);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        bytes memory args = ba2cbor(argN);\r\n        return oraclize.queryN.value(price)(timestamp, datasource, args);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        bytes memory args = ba2cbor(argN);\r\n        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        bytes memory args = ba2cbor(argN);\r\n        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](1);\r\n        dynargs[0] = args[0];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](1);\r\n        dynargs[0] = args[0];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](1);\r\n        dynargs[0] = args[0];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](1);\r\n        dynargs[0] = args[0];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n\r\n    function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](2);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](2);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](2);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](2);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](3);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](3);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](3);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](3);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n\r\n    function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](4);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](4);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](4);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](4);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](5);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        dynargs[4] = args[4];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](5);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        dynargs[4] = args[4];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](5);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        dynargs[4] = args[4];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](5);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        dynargs[4] = args[4];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n\r\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\r\n        return oraclize.cbAddress();\r\n    }\r\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\r\n        return oraclize.setProofType(proofP);\r\n    }\r\n    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\r\n        return oraclize.setCustomGasPrice(gasPrice);\r\n    }\r\n    function oraclize_setConfig(bytes32 config) oraclizeAPI internal {\r\n        return oraclize.setConfig(config);\r\n    }\r\n\r\n    function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){\r\n        return oraclize.randomDS_getSessionPubKeyHash();\r\n    }\r\n\r\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\r\n        assembly {\r\n        _size := extcodesize(_addr)\r\n        }\r\n    }\r\n\r\n    function parseAddr(string _a) internal returns (address){\r\n        bytes memory tmp = bytes(_a);\r\n        uint160 iaddr = 0;\r\n        uint160 b1;\r\n        uint160 b2;\r\n        for (uint i=2; i<2+2*20; i+=2){\r\n            iaddr *= 256;\r\n            b1 = uint160(tmp[i]);\r\n            b2 = uint160(tmp[i+1]);\r\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\r\n            else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;\r\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\r\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\r\n            else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;\r\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\r\n            iaddr += (b1*16+b2);\r\n        }\r\n        return address(iaddr);\r\n    }\r\n\r\n    function strCompare(string _a, string _b) internal returns (int) {\r\n        bytes memory a = bytes(_a);\r\n        bytes memory b = bytes(_b);\r\n        uint minLength = a.length;\r\n        if (b.length < minLength) minLength = b.length;\r\n        for (uint i = 0; i < minLength; i ++)\r\n        if (a[i] < b[i])\r\n        return -1;\r\n        else if (a[i] > b[i])\r\n        return 1;\r\n        if (a.length < b.length)\r\n        return -1;\r\n        else if (a.length > b.length)\r\n        return 1;\r\n        else\r\n        return 0;\r\n    }\r\n\r\n    function indexOf(string _haystack, string _needle) internal returns (int) {\r\n        bytes memory h = bytes(_haystack);\r\n        bytes memory n = bytes(_needle);\r\n        if(h.length < 1 || n.length < 1 || (n.length > h.length))\r\n        return -1;\r\n        else if(h.length > (2**128 -1))\r\n        return -1;\r\n        else\r\n        {\r\n            uint subindex = 0;\r\n            for (uint i = 0; i < h.length; i ++)\r\n            {\r\n                if (h[i] == n[0])\r\n                {\r\n                    subindex = 1;\r\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\r\n                    {\r\n                        subindex++;\r\n                    }\r\n                    if(subindex == n.length)\r\n                    return int(i);\r\n                }\r\n            }\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string) {\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n        return string(babcde);\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b) internal returns (string) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n\r\n    // parseInt\r\n    function parseInt(string _a) internal returns (uint) {\r\n        return parseInt(_a, 0);\r\n    }\r\n\r\n    // parseInt(parseFloat*10^_b)\r\n    function parseInt(string _a, uint _b) internal returns (uint) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i=0; i<bresult.length; i++){\r\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\r\n                if (decimals){\r\n                    if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                mint *= 10;\r\n                mint += uint(bresult[i]) - 48;\r\n            } else if (bresult[i] == 46) decimals = true;\r\n        }\r\n        if (_b > 0) mint *= 10**_b;\r\n        return mint;\r\n    }\r\n\r\n    function uint2str(uint i) internal returns (string){\r\n        if (i == 0) return \"0\";\r\n        uint j = i;\r\n        uint len;\r\n        while (j != 0){\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (i != 0){\r\n            bstr[k--] = byte(48 + i % 10);\r\n            i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n    function stra2cbor(string[] arr) internal returns (bytes) {\r\n        uint arrlen = arr.length;\r\n\r\n        // get correct cbor output length\r\n        uint outputlen = 0;\r\n        bytes[] memory elemArray = new bytes[](arrlen);\r\n        for (uint i = 0; i < arrlen; i++) {\r\n            elemArray[i] = (bytes(arr[i]));\r\n            outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types\r\n        }\r\n        uint ctr = 0;\r\n        uint cborlen = arrlen + 0x80;\r\n        outputlen += byte(cborlen).length;\r\n        bytes memory res = new bytes(outputlen);\r\n\r\n        while (byte(cborlen).length > ctr) {\r\n            res[ctr] = byte(cborlen)[ctr];\r\n            ctr++;\r\n        }\r\n        for (i = 0; i < arrlen; i++) {\r\n            res[ctr] = 0x5F;\r\n            ctr++;\r\n            for (uint x = 0; x < elemArray[i].length; x++) {\r\n                // if there's a bug with larger strings, this may be the culprit\r\n                if (x % 23 == 0) {\r\n                    uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\r\n                    elemcborlen += 0x40;\r\n                    uint lctr = ctr;\r\n                    while (byte(elemcborlen).length > ctr - lctr) {\r\n                        res[ctr] = byte(elemcborlen)[ctr - lctr];\r\n                        ctr++;\r\n                    }\r\n                }\r\n                res[ctr] = elemArray[i][x];\r\n                ctr++;\r\n            }\r\n            res[ctr] = 0xFF;\r\n            ctr++;\r\n        }\r\n        return res;\r\n    }\r\n\r\n    function ba2cbor(bytes[] arr) internal returns (bytes) {\r\n        uint arrlen = arr.length;\r\n\r\n        // get correct cbor output length\r\n        uint outputlen = 0;\r\n        bytes[] memory elemArray = new bytes[](arrlen);\r\n        for (uint i = 0; i < arrlen; i++) {\r\n            elemArray[i] = (bytes(arr[i]));\r\n            outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types\r\n        }\r\n        uint ctr = 0;\r\n        uint cborlen = arrlen + 0x80;\r\n        outputlen += byte(cborlen).length;\r\n        bytes memory res = new bytes(outputlen);\r\n\r\n        while (byte(cborlen).length > ctr) {\r\n            res[ctr] = byte(cborlen)[ctr];\r\n            ctr++;\r\n        }\r\n        for (i = 0; i < arrlen; i++) {\r\n            res[ctr] = 0x5F;\r\n            ctr++;\r\n            for (uint x = 0; x < elemArray[i].length; x++) {\r\n                // if there's a bug with larger strings, this may be the culprit\r\n                if (x % 23 == 0) {\r\n                    uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\r\n                    elemcborlen += 0x40;\r\n                    uint lctr = ctr;\r\n                    while (byte(elemcborlen).length > ctr - lctr) {\r\n                        res[ctr] = byte(elemcborlen)[ctr - lctr];\r\n                        ctr++;\r\n                    }\r\n                }\r\n                res[ctr] = elemArray[i][x];\r\n                ctr++;\r\n            }\r\n            res[ctr] = 0xFF;\r\n            ctr++;\r\n        }\r\n        return res;\r\n    }\r\n\r\n\r\n    string oraclize_network_name;\r\n    function oraclize_setNetworkName(string _network_name) internal {\r\n        oraclize_network_name = _network_name;\r\n    }\r\n\r\n    function oraclize_getNetworkName() internal returns (string) {\r\n        return oraclize_network_name;\r\n    }\r\n\r\n    function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\r\n//        if ((_nbytes == 0)||(_nbytes > 32)) throw;\r\n        require(_nbytes != 0 && _nbytes < 32);\r\n        bytes memory nbytes = new bytes(1);\r\n        nbytes[0] = byte(_nbytes);\r\n        bytes memory unonce = new bytes(32);\r\n        bytes memory sessionKeyHash = new bytes(32);\r\n        bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\r\n        assembly {\r\n        mstore(unonce, 0x20)\r\n        mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\r\n        mstore(sessionKeyHash, 0x20)\r\n        mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\r\n        }\r\n        bytes[3] memory args = [unonce, nbytes, sessionKeyHash];\r\n        bytes32 queryId = oraclize_query(_delay, \"random\", args, _customGasLimit);\r\n        oraclize_randomDS_setCommitment(queryId, sha3(bytes8(_delay), args[1], sha256(args[0]), args[2]));\r\n        return queryId;\r\n    }\r\n\r\n    function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {\r\n        oraclize_randomDS_args[queryId] = commitment;\r\n    }\r\n\r\n    mapping(bytes32=>bytes32) oraclize_randomDS_args;\r\n    mapping(bytes32=>bool) oraclize_randomDS_sessionKeysHashVerified;\r\n\r\n    function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){\r\n        bool sigok;\r\n        address signer;\r\n\r\n        bytes32 sigr;\r\n        bytes32 sigs;\r\n\r\n        bytes memory sigr_ = new bytes(32);\r\n        uint offset = 4+(uint(dersig[3]) - 0x20);\r\n        sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);\r\n        bytes memory sigs_ = new bytes(32);\r\n        offset += 32 + 2;\r\n        sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);\r\n\r\n        assembly {\r\n        sigr := mload(add(sigr_, 32))\r\n        sigs := mload(add(sigs_, 32))\r\n        }\r\n\r\n\r\n        (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);\r\n        if (address(sha3(pubkey)) == signer) return true;\r\n        else {\r\n            (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);\r\n            return (address(sha3(pubkey)) == signer);\r\n        }\r\n    }\r\n\r\n    function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {\r\n        bool sigok;\r\n\r\n        // Step 6: verify the attestation signature, APPKEY1 must sign the sessionKey from the correct ledger app (CODEHASH)\r\n        bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);\r\n        copyBytes(proof, sig2offset, sig2.length, sig2, 0);\r\n\r\n        bytes memory appkey1_pubkey = new bytes(64);\r\n        copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);\r\n\r\n        bytes memory tosign2 = new bytes(1+65+32);\r\n//        tosign2[0] = 1; //role\r\n        tosign2[0] = 0x1; //role\r\n        copyBytes(proof, sig2offset-65, 65, tosign2, 1);\r\n        bytes memory CODEHASH = hex\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\";\r\n        copyBytes(CODEHASH, 0, 32, tosign2, 1+65);\r\n        sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);\r\n\r\n        if (sigok == false) return false;\r\n\r\n\r\n        // Step 7: verify the APPKEY1 provenance (must be signed by Ledger)\r\n        bytes memory LEDGERKEY = hex\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\";\r\n\r\n        bytes memory tosign3 = new bytes(1+65);\r\n        tosign3[0] = 0xFE;\r\n        copyBytes(proof, 3, 65, tosign3, 1);\r\n\r\n        bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);\r\n        copyBytes(proof, 3+65, sig3.length, sig3, 0);\r\n\r\n        sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);\r\n\r\n        return sigok;\r\n    }\r\n\r\n    modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {\r\n        // Step 1: the prefix has to match 'LP\\x01' (Ledger Proof version 1)\r\n//        if ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) throw;\r\n        require(_proof[0] == \"L\" && _proof[1] == \"P\" && _proof[2] == 1);\r\n\r\n        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\r\n//        if (proofVerified == false) throw;\r\n        require(proofVerified == true);\r\n\r\n        _;\r\n    }\r\n\r\n    function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){\r\n        // Step 1: the prefix has to match 'LP\\x01' (Ledger Proof version 1)\r\n        if ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) return 1;\r\n\r\n        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\r\n        if (proofVerified == false) return 2;\r\n\r\n        return 0;\r\n    }\r\n\r\n    function matchBytes32Prefix(bytes32 content, bytes prefix) internal returns (bool){\r\n        bool match_ = true;\r\n\r\n//        for (var i=0; i<prefix.length; i++){\r\n        for (var i=uint8(0); i<prefix.length; i++){\r\n            if (content[i] != prefix[i]) match_ = false;\r\n        }\r\n\r\n        return match_;\r\n    }\r\n\r\n    function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\r\n        bool checkok;\r\n\r\n\r\n        // Step 2: the unique keyhash has to match with the sha256 of (context name + queryId)\r\n        uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;\r\n        bytes memory keyhash = new bytes(32);\r\n        copyBytes(proof, ledgerProofLength, 32, keyhash, 0);\r\n        checkok = (sha3(keyhash) == sha3(sha256(context_name, queryId)));\r\n        if (checkok == false) return false;\r\n\r\n        bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);\r\n        copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);\r\n\r\n\r\n        // Step 3: we assume sig1 is valid (it will be verified during step 5) and we verify if 'result' is the prefix of sha256(sig1)\r\n        checkok = matchBytes32Prefix(sha256(sig1), result);\r\n        if (checkok == false) return false;\r\n\r\n\r\n        // Step 4: commitment match verification, sha3(delay, nbytes, unonce, sessionKeyHash) == commitment in storage.\r\n        // This is to verify that the computed args match with the ones specified in the query.\r\n        bytes memory commitmentSlice1 = new bytes(8+1+32);\r\n        copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);\r\n\r\n        bytes memory sessionPubkey = new bytes(64);\r\n        uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;\r\n        copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);\r\n\r\n        bytes32 sessionPubkeyHash = sha256(sessionPubkey);\r\n        if (oraclize_randomDS_args[queryId] == sha3(commitmentSlice1, sessionPubkeyHash)){ //unonce, nbytes and sessionKeyHash match\r\n            delete oraclize_randomDS_args[queryId];\r\n        } else return false;\r\n\r\n\r\n        // Step 5: validity verification for sig1 (keyhash and args signed with the sessionKey)\r\n        bytes memory tosign1 = new bytes(32+8+1+32);\r\n        copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);\r\n        checkok = verifySig(sha256(tosign1), sig1, sessionPubkey);\r\n        if (checkok == false) return false;\r\n\r\n        // verify if sessionPubkeyHash was verified already, if not.. let's do it!\r\n        if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){\r\n            oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);\r\n        }\r\n\r\n        return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];\r\n    }\r\n\r\n\r\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\r\n    function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal returns (bytes) {\r\n        uint minLength = length + toOffset;\r\n\r\n//        if (to.length < minLength) {\r\n            // Buffer too small\r\n//            throw; // Should be a better way?\r\n//        }\r\n        require(to.length > minLength);\r\n\r\n        // NOTE: the offset 32 is added to skip the `size` field of both bytes variables\r\n        uint i = 32 + fromOffset;\r\n        uint j = 32 + toOffset;\r\n\r\n        while (i < (32 + fromOffset + length)) {\r\n            assembly {\r\n            let tmp := mload(add(from, i))\r\n            mstore(add(to, j), tmp)\r\n            }\r\n            i += 32;\r\n            j += 32;\r\n        }\r\n\r\n        return to;\r\n    }\r\n\r\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\r\n    // Duplicate Solidity's ecrecover, but catching the CALL return value\r\n    function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\r\n        // We do our own memory management here. Solidity uses memory offset\r\n        // 0x40 to store the current end of memory. We write past it (as\r\n        // writes are memory extensions), but don't update the offset so\r\n        // Solidity will reuse it. The memory used here is only needed for\r\n        // this context.\r\n\r\n        // FIXME: inline assembly can't access return values\r\n        bool ret;\r\n        address addr;\r\n\r\n        assembly {\r\n        let size := mload(0x40)\r\n        mstore(size, hash)\r\n        mstore(add(size, 32), v)\r\n        mstore(add(size, 64), r)\r\n        mstore(add(size, 96), s)\r\n\r\n        // NOTE: we can reuse the request memory because we deal with\r\n        //       the return code\r\n        ret := call(3000, 1, 0, size, 128, size, 32)\r\n        addr := mload(size)\r\n        }\r\n\r\n        return (ret, addr);\r\n    }\r\n\r\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\r\n    function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        if (sig.length != 65)\r\n        return (false, 0);\r\n\r\n        // The signature format is a compact form of:\r\n        //   {bytes32 r}{bytes32 s}{uint8 v}\r\n        // Compact means, uint8 is not padded to 32 bytes.\r\n        assembly {\r\n        r := mload(add(sig, 32))\r\n        s := mload(add(sig, 64))\r\n\r\n        // Here we are loading the last 32 bytes. We exploit the fact that\r\n        // 'mload' will pad with zeroes if we overread.\r\n        // There is no 'mload8' to do this, but that would be nicer.\r\n        v := byte(0, mload(add(sig, 96)))\r\n\r\n        // Alternative solution:\r\n        // 'byte' is not working due to the Solidity parser, so lets\r\n        // use the second best option, 'and'\r\n        // v := and(mload(add(sig, 65)), 255)\r\n    }\r\n\r\n// albeit non-transactional signatures are not specified by the YP, one would expect it\r\n// to match the YP range of [27, 28]\r\n//\r\n// geth uses [0, 1] and some clients have followed. This might change, see:\r\n//  https://github.com/ethereum/go-ethereum/issues/2053\r\nif (v < 27)\r\nv += 27;\r\n\r\nif (v != 27 && v != 28)\r\nreturn (false, 0);\r\n\r\nreturn safer_ecrecover(hash, v, r, s);\r\n}\r\n\r\n}\r\n// </ORACLIZE_API>\r\n/* solhint-enable */\r\n\r\ncontract Ownable {\r\n    //Variables\r\n    address public owner;\r\n\r\n    address public newOwner;\r\n\r\n    //    Modifiers\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param _newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != address(0));\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() public {\r\n        if (msg.sender == newOwner) {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n}\r\n\r\ncontract TokenRecipient {\r\n    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public;\r\n}\r\n\r\n\r\ncontract ERC20 is Ownable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    /* Public variables of the token */\r\n    string public standard;\r\n\r\n    string public name;\r\n\r\n    string public symbol;\r\n\r\n    uint8 public decimals;\r\n\r\n    uint256 public initialSupply;\r\n\r\n    bool public locked;\r\n\r\n    uint256 public creationBlock;\r\n\r\n    mapping (address => uint256) public balances;\r\n\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n    /* This generates a public event on the blockchain that will notify clients */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n\r\n    modifier onlyPayloadSize(uint numwords) {\r\n        assert(msg.data.length == numwords.mul(32).add(4));\r\n        _;\r\n    }\r\n\r\n    /* Initializes contract with initial supply tokens to the creator of the contract */\r\n    function ERC20(\r\n        uint256 _initialSupply,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol,\r\n        bool _transferAllSupplyToOwner,\r\n        bool _locked\r\n    ) {\r\n        standard = \"ERC20 0.1\";\r\n\r\n        initialSupply = _initialSupply;\r\n\r\n        if (_transferAllSupplyToOwner) {\r\n            setBalance(msg.sender, initialSupply);\r\n        } else {\r\n            setBalance(this, initialSupply);\r\n        }\r\n\r\n        name = _tokenName;\r\n        // Set the name for display purposes\r\n        symbol = _tokenSymbol;\r\n        // Set the symbol for display purposes\r\n        decimals = _decimalUnits;\r\n        // Amount of decimals for display purposes\r\n        locked = _locked;\r\n        creationBlock = block.number;\r\n    }\r\n\r\n    /* public methods */\r\n    function totalSupply() public constant returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n\r\n    function balanceOf(address _address) public constant returns (uint256) {\r\n        return balances[_address];\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public onlyPayloadSize(2) returns (bool) {\r\n        require(locked == false);\r\n\r\n        bool status = transferInternal(msg.sender, _to, _value);\r\n\r\n        require(status == true);\r\n\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        if (locked) {\r\n            return false;\r\n        }\r\n\r\n        allowance[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\r\n        if (locked) {\r\n            return false;\r\n        }\r\n\r\n        TokenRecipient spender = TokenRecipient(_spender);\r\n\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        if (locked) {\r\n            return false;\r\n        }\r\n\r\n        if (allowance[_from][msg.sender] < _value) {\r\n            return false;\r\n        }\r\n\r\n        bool _success = transferInternal(_from, _to, _value);\r\n\r\n        if (_success) {\r\n            allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\r\n        }\r\n\r\n        return _success;\r\n    }\r\n\r\n    /* internal balances */\r\n    function setBalance(address _holder, uint256 _amount) internal {\r\n        balances[_holder] = _amount;\r\n    }\r\n\r\n    function transferInternal(address _from, address _to, uint256 _value) internal returns (bool success) {\r\n        if (_value == 0) {\r\n            Transfer(_from, _to, 0);\r\n            return true;\r\n        }\r\n\r\n        if (balances[_from] < _value) {\r\n            return false;\r\n        }\r\n\r\n        setBalance(_from, balances[_from].sub(_value));\r\n        setBalance(_to, balances[_to].add(_value));\r\n\r\n        Transfer(_from, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\ncontract MintingERC20 is ERC20 {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public maxSupply;\r\n\r\n    mapping (address => bool) public minters;\r\n\r\n    modifier onlyMinters () {\r\n        require(true == minters[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    function MintingERC20(\r\n        uint256 _initialSupply,\r\n        uint256 _maxSupply,\r\n        string _tokenName,\r\n        uint8 _decimals,\r\n        string _symbol,\r\n        bool _transferAllSupplyToOwner,\r\n        bool _locked\r\n    )\r\n        ERC20(_initialSupply, _tokenName, _decimals, _symbol, _transferAllSupplyToOwner, _locked)\r\n    {\r\n        minters[msg.sender] = true;\r\n        maxSupply = _maxSupply;\r\n    }\r\n\r\n    function addMinter(address _newMinter) public onlyOwner {\r\n        minters[_newMinter] = true;\r\n    }\r\n\r\n    function removeMinter(address _minter) public onlyOwner {\r\n        minters[_minter] = false;\r\n    }\r\n\r\n    function mint(address _addr, uint256 _amount) public onlyMinters returns (uint256) {\r\n        if (_amount == uint256(0)) {\r\n            return uint256(0);\r\n        }\r\n\r\n        if (totalSupply().add(_amount) > maxSupply) {\r\n            return uint256(0);\r\n        }\r\n\r\n        initialSupply = initialSupply.add(_amount);\r\n        balances[_addr] = balances[_addr].add(_amount);\r\n        Transfer(0, _addr, _amount);\r\n\r\n        return _amount;\r\n    }\r\n}\r\n\r\ncontract Node is MintingERC20 {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    NodePhases public nodePhases;\r\n\r\n    // Block token transfers till ICO end.\r\n    bool public transferFrozen = true;\r\n\r\n    function Node(\r\n        uint256 _maxSupply,\r\n        string _tokenName,\r\n        string _tokenSymbol,\r\n        uint8 _precision,\r\n        bool _locked\r\n    ) MintingERC20(0, _maxSupply, _tokenName, _precision, _tokenSymbol, false, _locked) {\r\n        standard = \"Node 0.1\";\r\n    }\r\n\r\n    function setLocked(bool _locked) public onlyOwner {\r\n        locked = _locked;\r\n    }\r\n\r\n    function setNodePhases(address _nodePhases) public onlyOwner {\r\n        nodePhases = NodePhases(_nodePhases);\r\n    }\r\n\r\n    function unfreeze() public onlyOwner {\r\n        if (nodePhases != address(0) && nodePhases.isFinished(1)) {\r\n            transferFrozen = false;\r\n        }\r\n    }\r\n\r\n    function buyBack(address _address) public onlyMinters returns (uint256) {\r\n        require(address(_address) != address(0));\r\n\r\n        uint256 balance = balanceOf(_address);\r\n        setBalance(_address, 0);\r\n        setBalance(this, balanceOf(this).add(balance));\r\n        Transfer(_address, this, balance);\r\n\r\n        return balance;\r\n    }\r\n\r\n    function transfer(address _to, uint _value) public returns (bool) {\r\n        require(!transferFrozen);\r\n\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\r\n        require(!transferFrozen);\r\n\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n}\r\n\r\ncontract NodeAllocation is Ownable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    PreICOAllocation[] public preIcoAllocation;\r\n\r\n    ICOAllocation[] public icoAllocation;\r\n\r\n    uint256[] public distributionThresholds;\r\n\r\n    address public bountyAddress;\r\n\r\n    struct PreICOAllocation {\r\n        uint8 percentage;\r\n        address destAddress;\r\n    }\r\n\r\n    struct ICOAllocation {\r\n        uint8 percentage;\r\n        address destAddress;\r\n    }\r\n\r\n    function NodeAllocation(\r\n        address _bountyAddress, //2%\r\n        address[] _preICOAddresses, //according - 3% and 97%\r\n        address[] _icoAddresses, //according - 3% 47% and 50%\r\n        uint256[] _distributionThresholds\r\n    ) {\r\n        require((address(_bountyAddress) != address(0)) && _distributionThresholds.length > 0);\r\n\r\n        bountyAddress = _bountyAddress;\r\n        distributionThresholds = _distributionThresholds;\r\n\r\n        require(setPreICOAllocation(_preICOAddresses) == true);\r\n        require(setICOAllocation(_icoAddresses) == true);\r\n    }\r\n\r\n    function getPreICOAddress(uint8 _id) public returns (address) {\r\n        PreICOAllocation storage allocation = preIcoAllocation[_id];\r\n\r\n        return allocation.destAddress;\r\n    }\r\n\r\n    function getPreICOPercentage(uint8 _id) public returns (uint8) {\r\n        PreICOAllocation storage allocation = preIcoAllocation[_id];\r\n\r\n        return allocation.percentage;\r\n    }\r\n\r\n    function getPreICOLength() public returns (uint8) {\r\n        return uint8(preIcoAllocation.length);\r\n    }\r\n\r\n    function getICOAddress(uint8 _id) public returns (address) {\r\n        ICOAllocation storage allocation = icoAllocation[_id];\r\n\r\n        return allocation.destAddress;\r\n    }\r\n\r\n    function getICOPercentage(uint8 _id) public returns (uint8) {\r\n        ICOAllocation storage allocation = icoAllocation[_id];\r\n\r\n        return allocation.percentage;\r\n    }\r\n\r\n    function getICOLength() public returns (uint8) {\r\n        return uint8(icoAllocation.length);\r\n    }\r\n\r\n    function getThreshold(uint8 _id) public returns (uint256) {\r\n        return uint256(distributionThresholds[_id]);\r\n    }\r\n\r\n    function getThresholdsLength() public returns (uint8) {\r\n        return uint8(distributionThresholds.length);\r\n    }\r\n\r\n    function setPreICOAllocation(address[] _addresses) internal returns (bool) {\r\n        if (_addresses.length < 2) {\r\n            return false;\r\n        }\r\n        preIcoAllocation.push(PreICOAllocation(3, _addresses[0]));\r\n        preIcoAllocation.push(PreICOAllocation(97, _addresses[1]));\r\n\r\n        return true;\r\n    }\r\n\r\n    function setICOAllocation(address[] _addresses) internal returns (bool) {\r\n        if (_addresses.length < 3) {\r\n            return false;\r\n        }\r\n        icoAllocation.push(ICOAllocation(3, _addresses[0]));\r\n        icoAllocation.push(ICOAllocation(47, _addresses[1]));\r\n        icoAllocation.push(ICOAllocation(50, _addresses[2]));\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract NodePhases is usingOraclize, Ownable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    Node public node;\r\n\r\n    NodeAllocation public nodeAllocation;\r\n\r\n    Phase[] public phases;\r\n\r\n    uint256 public constant HOUR = 3600;\r\n\r\n    uint256 public constant DAY = 86400;\r\n\r\n    uint256 public collectedEthers;\r\n\r\n    uint256 public soldTokens;\r\n\r\n    uint256 public priceUpdateAt;\r\n\r\n    uint256 public investorsCount;\r\n\r\n    uint256 public lastDistributedAmount;\r\n\r\n    mapping (address => uint256) public icoEtherBalances;\r\n\r\n    mapping (address => bool) private investors;\r\n\r\n    event NewOraclizeQuery(string description);\r\n\r\n    event NewNodePriceTicker(string price);\r\n\r\n    event Refund(address holder, uint256 ethers, uint256 tokens);\r\n\r\n    struct Phase {\r\n        uint256 price;\r\n        uint256 minInvest;\r\n        uint256 softCap;\r\n        uint256 hardCap;\r\n        uint256 since;\r\n        uint256 till;\r\n        bool isSucceed;\r\n    }\r\n\r\n    function NodePhases(\r\n        address _node,\r\n        uint256 _minInvest,\r\n        uint256 _tokenPrice, //0.0032835596 ethers\r\n        uint256 _preIcoMaxCap,\r\n        uint256 _preIcoSince,\r\n        uint256 _preIcoTill,\r\n        uint256 _icoMinCap,\r\n        uint256 _icoMaxCap,\r\n        uint256 _icoSince,\r\n        uint256 _icoTill\r\n    ) {\r\n        require(address(_node) != address(0));\r\n        node = Node(address(_node));\r\n\r\n        require((_preIcoSince < _preIcoTill) && (_icoSince < _icoTill) && (_preIcoTill <= _icoSince));\r\n\r\n        require((_preIcoMaxCap < _icoMaxCap) && (_icoMaxCap < node.maxSupply()));\r\n\r\n        phases.push(Phase(_tokenPrice, _minInvest, 0, _preIcoMaxCap, _preIcoSince, _preIcoTill, false));\r\n        phases.push(Phase(_tokenPrice, _minInvest, _icoMinCap, _icoMaxCap, _icoSince, _icoTill, false));\r\n\r\n        priceUpdateAt = now;\r\n\r\n        oraclize_setNetwork(networkID_auto);\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n    }\r\n\r\n    function() public payable {\r\n        require(buy(msg.sender, msg.value) == true);\r\n    }\r\n\r\n    function __callback(bytes32, string _result, bytes) public {\r\n        require(msg.sender == oraclize_cbAddress());\r\n\r\n        uint256 price = uint256(10 ** 23).div(parseInt(_result, 5));\r\n\r\n        require(price > 0);\r\n\r\n        for (uint i = 0; i < phases.length; i++) {\r\n            Phase storage phase = phases[i];\r\n            phase.price = price;\r\n        }\r\n\r\n        NewNodePriceTicker(_result);\r\n    }\r\n\r\n    function setCurrentRate(uint256 _rate) public onlyOwner {\r\n        require(_rate > 0);\r\n        for (uint i = 0; i < phases.length; i++) {\r\n            Phase storage phase = phases[i];\r\n            phase.price = _rate;\r\n        }\r\n        priceUpdateAt = now;\r\n    }\r\n\r\n    function setNode(address _node) public onlyOwner {\r\n        require(address(_node) != address(0));\r\n        node = Node(_node);\r\n    }\r\n\r\n    function setNodeAllocation(address _nodeAllocation) public onlyOwner {\r\n        require(address(_nodeAllocation) != address(0));\r\n        nodeAllocation = NodeAllocation(_nodeAllocation);\r\n    }\r\n\r\n    function setPhase(\r\n        uint8 _phaseId,\r\n        uint256 _since,\r\n        uint256 _till,\r\n        uint256 _price,\r\n        uint256 _softCap,\r\n        uint256 _hardCap\r\n    ) public onlyOwner returns (bool) {\r\n        require((phases.length > _phaseId) && (_price > 0));\r\n        require((_till > _since) && (_since > 0));\r\n        require((node.maxSupply() > _hardCap) && (_hardCap > _softCap) && (_softCap >= 0));\r\n\r\n        Phase storage phase = phases[_phaseId];\r\n\r\n        if (phase.isSucceed == true) {\r\n            return false;\r\n        }\r\n        phase.since = _since;\r\n        phase.till = _till;\r\n        phase.price = _price;\r\n        phase.softCap = _softCap;\r\n        phase.hardCap = _hardCap;\r\n\r\n        return true;\r\n    }\r\n\r\n    function sendToAddress(address _address, uint256 _tokens) public onlyOwner returns (bool) {\r\n        return sendToAddressWithTime(_address, _tokens, now);\r\n    }\r\n\r\n    function sendToAddressWithTime(\r\n        address _address,\r\n        uint256 _tokens,\r\n        uint256 _time\r\n    ) public onlyOwner returns (bool) {\r\n        if (_tokens == 0 || address(_address) == address(0) || _time == 0) {\r\n            return false;\r\n        }\r\n\r\n        uint256 totalAmount = _tokens.add(getBonusAmount(_tokens, _time));\r\n\r\n        require(totalAmount == node.mint(_address, totalAmount));\r\n\r\n        soldTokens = soldTokens.add(totalAmount);\r\n        increaseInvestorsCount(_address);\r\n\r\n        return true;\r\n    }\r\n\r\n    function sendToAddressWithBonus(\r\n        address _address,\r\n        uint256 _tokens,\r\n        uint256 _bonus\r\n    ) public onlyOwner returns (bool) {\r\n        if (_tokens == 0 || address(_address) == address(0) || _bonus == 0) {\r\n            return false;\r\n        }\r\n\r\n        uint256 totalAmount = _tokens.add(_bonus);\r\n\r\n        require(totalAmount == node.mint(_address, totalAmount));\r\n\r\n        soldTokens = soldTokens.add(totalAmount);\r\n        increaseInvestorsCount(_address);\r\n\r\n        return true;\r\n    }\r\n\r\n    function getTokens() public constant returns (uint256) {\r\n        return node.totalSupply();\r\n    }\r\n\r\n    function getSoldToken() public constant returns (uint256) {\r\n        return soldTokens;\r\n    }\r\n\r\n    function getAllInvestors() public constant returns (uint256) {\r\n        return investorsCount;\r\n    }\r\n\r\n    function getBalanceContract() public constant returns (uint256) {\r\n        return collectedEthers;\r\n    }\r\n\r\n    function isSucceed(uint8 phaseId) public returns (bool) {\r\n        if (phases.length < phaseId) {\r\n            return false;\r\n        }\r\n        Phase storage phase = phases[phaseId];\r\n        if (phase.isSucceed == true) {\r\n            return true;\r\n        }\r\n        if (phase.till > now) {\r\n            return false;\r\n        }\r\n        if (phase.softCap != 0 && phase.softCap > getTokens()) {\r\n            return false;\r\n        }\r\n        phase.isSucceed = true;\r\n        if (phaseId == 1) {\r\n            allocateBounty();\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function refund() public returns (bool) {\r\n        Phase storage icoPhase = phases[1];\r\n        if (icoPhase.till > now) {\r\n            return false;\r\n        }\r\n        if (icoPhase.softCap < getTokens()) {\r\n            return false;\r\n        }\r\n        if (icoEtherBalances[msg.sender] == 0) {\r\n            return false;\r\n        }\r\n\r\n        uint256 refundAmount = icoEtherBalances[msg.sender];\r\n        uint256 tokens = node.buyBack(msg.sender);\r\n        icoEtherBalances[msg.sender] = 0;\r\n        msg.sender.transfer(refundAmount);\r\n        Refund(msg.sender, refundAmount, tokens);\r\n\r\n        return true;\r\n    }\r\n\r\n    function isFinished(uint8 phaseId) public constant returns (bool) {\r\n        if (phases.length < phaseId) {\r\n            return false;\r\n        }\r\n        Phase storage phase = phases[phaseId];\r\n\r\n        return (phase.isSucceed || now > phase.till);\r\n    }\r\n\r\n    function getCurrentPhase(uint256 _time) public constant returns (uint8) {\r\n        if (_time == 0) {\r\n            return uint8(phases.length);\r\n        }\r\n        for (uint8 i = 0; i < phases.length; i++) {\r\n            Phase storage phase = phases[i];\r\n            if (phase.since > _time) {\r\n                continue;\r\n            }\r\n\r\n            if (phase.till < _time) {\r\n                continue;\r\n            }\r\n\r\n            return i;\r\n        }\r\n\r\n        return uint8(phases.length);\r\n    }\r\n\r\n    function update() internal {\r\n        if (oraclize_getPrice(\"URL\") > this.balance) {\r\n            NewOraclizeQuery(\"Oraclize query was NOT sent, please add some ETH to cover for the query fee\");\r\n        } else {\r\n            NewOraclizeQuery(\"Oraclize query was sent, standing by for the answer..\");\r\n            oraclize_query(\"URL\", \"json(https://api.kraken.com/0/public/Ticker?pair=ETHUSD).result.XETHZUSD.c.0\");\r\n        }\r\n    }\r\n\r\n    function buy(address _address, uint256 _value) internal returns (bool) {\r\n        if (_value == 0) {\r\n            return false;\r\n        }\r\n\r\n        uint8 currentPhase = getCurrentPhase(now);\r\n\r\n        if (phases.length < currentPhase) {\r\n            return false;\r\n        }\r\n\r\n        if (priceUpdateAt.add(HOUR) < now) {\r\n            update();\r\n            priceUpdateAt = now;\r\n        }\r\n\r\n        uint256 amount = getTokensAmount(_value, currentPhase);\r\n\r\n        if (amount == 0) {\r\n            return false;\r\n        }\r\n\r\n        amount = amount.add(getBonusAmount(amount, now));\r\n\r\n        require(amount == node.mint(_address, amount));\r\n\r\n        onSuccessfulBuy(_address, _value, amount, currentPhase);\r\n        allocate(currentPhase);\r\n\r\n        return true;\r\n    }\r\n\r\n    function onSuccessfulBuy(address _address, uint256 _value, uint256 _amount, uint8 _currentPhase) internal {\r\n        collectedEthers = collectedEthers.add(_value);\r\n        soldTokens = soldTokens.add(_amount);\r\n        increaseInvestorsCount(_address);\r\n\r\n        if (_currentPhase == 1) {\r\n            icoEtherBalances[_address] = icoEtherBalances[_address].add(_value);\r\n        }\r\n    }\r\n\r\n    function increaseInvestorsCount(address _address) internal {\r\n        if (address(_address) != address(0) && investors[_address] == false) {\r\n            investors[_address] = true;\r\n            investorsCount = investorsCount.add(1);\r\n        }\r\n    }\r\n\r\n    function getTokensAmount(uint256 _value, uint8 _currentPhase) internal returns (uint256) {\r\n        if (_value == 0 || phases.length < _currentPhase) {\r\n            return 0;\r\n        }\r\n\r\n        Phase storage phase = phases[_currentPhase];\r\n\r\n        uint256 amount = _value.mul(uint256(10) ** node.decimals()).div(phase.price);\r\n\r\n        if (amount < phase.minInvest) {\r\n            return 0;\r\n        }\r\n\r\n        if (getTokens().add(amount) > phase.hardCap) {\r\n            return 0;\r\n        }\r\n\r\n        return amount;\r\n    }\r\n\r\n    function getBonusAmount(uint256 _amount, uint256 _time) internal returns (uint256) {\r\n        uint8 currentPhase = getCurrentPhase(_time);\r\n        if (_amount == 0 || _time == 0 || phases.length < currentPhase) {\r\n            return 0;\r\n        }\r\n\r\n        if (currentPhase == 0) {\r\n            return _amount.mul(50).div(100);\r\n        }\r\n\r\n        if (currentPhase == 1) {\r\n            return getICOBonusAmount(_amount, _time);\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    function getICOBonusAmount(uint256 _amount, uint256 _time) internal returns (uint256) {\r\n        Phase storage ico = phases[1];\r\n        if (_time.sub(ico.since) < 11 * DAY) {// 11d since ico => reward 30%;\r\n            return _amount.mul(30).div(100);\r\n        }\r\n        if (_time.sub(ico.since) < 21 * DAY) {// 21d since ico => reward 20%\r\n            return _amount.mul(20).div(100);\r\n        }\r\n        if (_time.sub(ico.since) < 31 * DAY) {// 31d since ico => reward 15%\r\n            return _amount.mul(15).div(100);\r\n        }\r\n        if (_time.sub(ico.since) < 41 * DAY) {// 41d since ico => reward 10%\r\n            return _amount.mul(10).div(100);\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    function allocateICOEthers() internal returns (bool) {\r\n        uint8 length = nodeAllocation.getICOLength();\r\n        require(length > 0);\r\n\r\n        uint256 totalAmount = this.balance;\r\n        for (uint8 i = 0; i < length; i++) {\r\n            uint256 amount = totalAmount.mul(nodeAllocation.getICOPercentage(i)).div(100);\r\n            if ((i + 1) == length) {\r\n                amount = this.balance;\r\n            }\r\n            if (amount > 0) {\r\n                nodeAllocation.getICOAddress(i).transfer(amount);\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function allocatePreICOEthers() internal returns (bool) {\r\n        uint8 length = nodeAllocation.getPreICOLength();\r\n        require(length > 0);\r\n\r\n        uint256 totalAmount = this.balance;\r\n        for (uint8 i = 0; i < length; i++) {\r\n            uint256 amount = totalAmount.mul(nodeAllocation.getPreICOPercentage(i)).div(100);\r\n            if ((i + 1) == length) {\r\n                amount = this.balance;\r\n            }\r\n            if (amount > 0) {\r\n                nodeAllocation.getPreICOAddress(i).transfer(amount);\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function allocate(uint8 _currentPhase) internal {\r\n        if (_currentPhase == 0) {\r\n            allocatePreICOEthers();\r\n        }\r\n        if (_currentPhase == 1) {\r\n            uint8 length = nodeAllocation.getThresholdsLength();\r\n            require(uint8(length) > 0);\r\n\r\n            for (uint8 j = 0; j < length; j++) {\r\n                uint256 threshold = nodeAllocation.getThreshold(j);\r\n\r\n                if ((threshold > lastDistributedAmount) && (soldTokens >= threshold)) {\r\n                    allocateICOEthers();\r\n                    lastDistributedAmount = threshold;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function allocateBounty() internal {\r\n        if (isFinished(1)) {\r\n            allocateICOEthers();\r\n            uint256 amount = node.maxSupply().mul(2).div(100);\r\n            uint256 mintedAmount = node.mint(nodeAllocation.bountyAddress(), amount);\r\n            require(mintedAmount == amount);\r\n        }\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"creationBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_locked\",\"type\":\"bool\"}],\"name\":\"setLocked\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minter\",\"type\":\"address\"}],\"name\":\"removeMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nodePhases\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"standard\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nodePhases\",\"type\":\"address\"}],\"name\":\"setNodePhases\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unfreeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newMinter\",\"type\":\"address\"}],\"name\":\"addMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"buyBack\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferFrozen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"locked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"minters\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_maxSupply\",\"type\":\"uint256\"},{\"name\":\"_tokenName\",\"type\":\"string\"},{\"name\":\"_tokenSymbol\",\"type\":\"string\"},{\"name\":\"_precision\",\"type\":\"uint8\"},{\"name\":\"_locked\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"Node","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000003b9aca0000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044e4f44450000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044e4f444500000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://491093e52ad60b364ad36d9938bceec4eae4e8c9d94934e532a31d844767d5d2"}]}