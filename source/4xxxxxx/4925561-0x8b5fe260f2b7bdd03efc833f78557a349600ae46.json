{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\n/*\r\n* LooksCoin token sale contract\r\n*\r\n* Refer to https://lookscoin.com for more information.\r\n* \r\n* Developer: LookRev\r\n*\r\n*/\r\n\r\n/*\r\n * ERC20 Token Standard\r\n */\r\ncontract ERC20 {\r\nevent Transfer(address indexed _from, address indexed _to, uint256 _value);\r\nevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\nuint256 public totalSupply;\r\nfunction balanceOf(address _owner) constant public returns (uint256 balance);\r\nfunction transfer(address _to, uint256 _value) public returns (bool success);\r\nfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\nfunction approve(address _spender, uint256 _value) public returns (bool success);\r\nfunction allowance(address _owner, address _spender) constant public returns (uint256 remaining);\r\n}\r\n\r\n/**\r\n* Provides methods to safely add, subtract and multiply uint256 numbers.\r\n*/\r\nlibrary SafeMath {\r\n    /**\r\n     * Add two uint256 values, revert in case of overflow.\r\n     *\r\n     * @param a first value to add\r\n     * @param b second value to add\r\n     * @return a + b\r\n     */\r\n    function add(uint256 a, uint256 b) internal returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * Subtract one uint256 value from another, throw in case of underflow.\r\n     *\r\n     * @param a value to subtract from\r\n     * @param b value to subtract\r\n     * @return a - b\r\n     */\r\n    function sub(uint256 a, uint256 b) internal returns (uint256) {\r\n        assert(a >= b);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * Multiply two uint256 values, throw in case of overflow.\r\n     *\r\n     * @param a first value to multiply\r\n     * @param b second value to multiply\r\n     * @return a * b\r\n     */\r\n    function mul(uint256 a, uint256 b) internal returns (uint256) {\r\n        if (a == 0 || b == 0) return 0;\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * Divid uint256 values, throw in case of overflow.\r\n     *\r\n     * @param a first value numerator\r\n     * @param b second value denominator\r\n     * @return a / b\r\n     */\r\n    function div(uint256 a, uint256 b) internal returns (uint256) {\r\n        assert(b != 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n}\r\n\r\n/*\r\n    Provides support and utilities for contract ownership\r\n*/\r\ncontract Ownable {\r\n    address owner;\r\n    address newOwner;\r\n\r\n    function Ownable() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * Allows execution by the owner only.\r\n     */\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Transferring the contract ownership to the new owner.\r\n     *\r\n     * @param _newOwner new contractor owner\r\n     */\r\n    function transferOwnership(address _newOwner) onlyOwner {\r\n        if (_newOwner != 0x0) {\r\n          newOwner = _newOwner;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Accept the contract ownership by the new owner.\r\n     */\r\n    function acceptOwnership() {\r\n        require(msg.sender == newOwner);\r\n        owner = newOwner;\r\n        OwnershipTransferred(owner, newOwner);\r\n        newOwner = 0x0;\r\n    }\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n}\r\n\r\n/**\r\n* Standard Token Smart Contract\r\n*/\r\ncontract StandardToken is ERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * Mapping from addresses of token holders to the numbers of tokens belonging\r\n     * to these token holders.\r\n     */\r\n    mapping (address => uint256) balances;\r\n\r\n    /**\r\n     * Mapping from addresses of token holders to the mapping of addresses of\r\n     * spenders to the allowances set by these token holders to these spenders.\r\n     */\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n    /**\r\n     * Mapping from addresses of token holders to the mapping of token amount spent.\r\n     * Use by the token holders to spend their utility tokens.\r\n     */\r\n    mapping (address => mapping (address => uint256)) spentamount;\r\n\r\n    /**\r\n     * Mapping of the addition of patrons.\r\n     */\r\n    mapping (address => bool) patronAppended;\r\n\r\n    /**\r\n     * Mapping of the addresses of patrons.\r\n     */\r\n    address[] patrons;\r\n\r\n    /**\r\n     * Mapping of the addresses of VIP token holders.\r\n     */\r\n    address[] vips;\r\n\r\n    /**\r\n    * Mapping for VIP rank for qualified token holders\r\n    * Higher VIP rank (with earlier timestamp) has higher bidding priority when\r\n    * competing for the same product or service on platform.\r\n    */\r\n    mapping (address => uint256) viprank;\r\n\r\n    /**\r\n     * Get number of tokens currently belonging to given owner.\r\n     *\r\n     * @param _owner address to get number of tokens currently belonging to its owner\r\n     *\r\n     * @return number of tokens currently belonging to the owner of given address\r\n     */\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    /**\r\n     * Transfer given number of tokens from message sender to given recipient.\r\n     *\r\n     * @param _to address to transfer tokens to the owner of\r\n     * @param _value number of tokens to transfer to the owner of given address\r\n     * @return true if tokens were transferred successfully, false otherwise\r\n     */\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        require(_to != 0x0);\r\n        if (balances[msg.sender] < _value) return false;\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Transfer given number of tokens from given owner to given recipient.\r\n     *\r\n     * @param _from address to transfer tokens from the owner of\r\n     * @param _to address to transfer tokens to the owner of\r\n     * @param _value number of tokens to transfer from given owner to given\r\n     *        recipient\r\n     * @return true if tokens were transferred successfully, false otherwise\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) \r\n        returns (bool success) {\r\n        require(_to != 0x0);\r\n        if(_from == _to) return false;\r\n        if (balances[_from] < _value) return false;\r\n        if (_value > allowed[_from][msg.sender]) return false;\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Allow given spender to transfer given number of tokens from message sender.\r\n     *\r\n     * @param _spender address to allow the owner of to transfer tokens from\r\n     *        message sender\r\n     * @param _value number of tokens to allow to transfer\r\n     * @return true if token transfer was successfully approved, false otherwise\r\n     */\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n\r\n        // To change the approve amount you first have to reduce the addresses`\r\n        //  allowance to zero by calling approve(_spender, 0) if it is not\r\n        //  already 0 to mitigate the race condition described here:\r\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) {\r\n           return false;\r\n        }\r\n        if (balances[msg.sender] < _value) {\r\n            return false;\r\n        }\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n     }\r\n\r\n    /**\r\n     * Tell how many tokens given spender is currently allowed to transfer from\r\n     * given owner.\r\n     *\r\n     * @param _owner address to get number of tokens allowed to be transferred\r\n     *        from the owner of\r\n     * @param _spender address to get number of tokens allowed to be transferred\r\n     *        by the owner of\r\n     * @return number of tokens given spender is currently allowed to transfer\r\n     *         from given owner\r\n     */\r\n     function allowance(address _owner, address _spender) constant \r\n        returns (uint256 remaining) {\r\n       return allowed[_owner][_spender];\r\n     }\r\n}\r\n\r\n/**\r\n * LooksCoin Token\r\n *\r\n * LooksCoin Token is an utility token that can be purchased through crowdsale or earned on\r\n * the LookRev platform. It can be spent to purchase creative products and services on\r\n * LookRev platform.\r\n *\r\n * VIP rank is used to calculate priority when competing with other bids\r\n * for the same product or service on the platform. \r\n * Higher VIP rank (with earlier timestamp) has higher priority.\r\n * Higher VIP rank wallet address owner can outbid other lower ranking owners only once\r\n * per selling window or promotion period.\r\n * VIP rank is recorded at the time when the wallet address first reach VIP LooksCoin \r\n * holding level for a token purchaser.\r\n * VIP rank is valid for the lifetime of a wallet address on the platform, as long as it \r\n * meets the VIP holding level.\r\n\r\n * Usage of the LooksCoin, VIP rank and token utilities are described on the website\r\n * https://lookscoin.com.\r\n *\r\n */\r\ncontract LooksCoin is StandardToken, Ownable {\r\n\r\n    /**\r\n     * Number of decimals of the smallest unit\r\n     */\r\n    uint256 public constant decimals = 18;\r\n\r\n    /**\r\n     * VIP Holding Level. Minimium token holding amount to record a VIP rank.\r\n     * Token holding address needs have at least 24000 LooksCoin to be ranked as VIP\r\n     * VIP rank can only be set through purchasing tokens\r\n     */\r\n    uint256 public constant VIP_MINIMUM = 24000e18;\r\n\r\n    /**\r\n     * Initial number of tokens.\r\n     */\r\n    uint256 constant INITIAL_TOKENS_COUNT = 100000000e18;\r\n\r\n    /**\r\n     * Crowdsale contract address.\r\n     */\r\n    address public tokenSaleContract = 0x0;\r\n\r\n    /**\r\n     * Init Placeholder\r\n     */\r\n    address coinmaster = address(0xd3c79e4AD654436d59AfD61363Bc2B927d2fb680);\r\n\r\n    /**\r\n     * Create new LooksCoin token smart contract.\r\n     */\r\n    function LooksCoin() {\r\n        owner = coinmaster;\r\n        balances[owner] = INITIAL_TOKENS_COUNT;\r\n        totalSupply = INITIAL_TOKENS_COUNT;\r\n    }\r\n\r\n    /**\r\n     * Get name of this token.\r\n     *\r\n     * @return name of this token\r\n     */\r\n    function name() constant returns (string name) {\r\n      return \"LooksCoin\";\r\n    }\r\n\r\n    /**\r\n     * Get symbol of this token.\r\n     *\r\n     * @return symbol of this token\r\n     */\r\n    function symbol() constant returns (string symbol) {\r\n      return \"LOOKS\";\r\n    }\r\n\r\n    /**\r\n     * @dev Set new token sale contract.\r\n     * May only be called by owner.\r\n     *\r\n     * @param _newTokenSaleContract new token sale manage contract.\r\n     */\r\n    function setTokenSaleContract(address _newTokenSaleContract) {\r\n        require(msg.sender == owner);\r\n        assert(_newTokenSaleContract != 0x0);\r\n        tokenSaleContract = _newTokenSaleContract;\r\n    }\r\n\r\n    /**\r\n     * Get VIP rank of a given owner.\r\n     * VIP rank is valid for the lifetime of a token wallet address, \r\n     * as long as it meets VIP holding level.\r\n     *\r\n     * @param _to participant address to get the vip rank\r\n     * @return vip rank of the owner of given address\r\n     */\r\n    function getVIPRank(address _to) constant public returns (uint256 rank) {\r\n        if (balances[_to] < VIP_MINIMUM) {\r\n            return 0;\r\n        }\r\n        return viprank[_to];\r\n    }\r\n\r\n    /**\r\n     * Check and update VIP rank of a given token buyer.\r\n     * Contribution timestamp is recorded for VIP rank.\r\n     * Recorded timestamp for VIP rank should always be earlier than the current time.\r\n     *\r\n     * @param _to address to check the vip rank.\r\n     * @return rank vip rank of the owner of given address if any\r\n     */\r\n    function updateVIPRank(address _to) returns (uint256 rank) {\r\n        // Contribution timestamp is recorded for VIP rank\r\n        // Recorded timestamp for VIP rank should always be earlier than current time\r\n        if (balances[_to] >= VIP_MINIMUM && viprank[_to] == 0) {\r\n            viprank[_to] = now;\r\n            vips.push(_to);\r\n        }\r\n        return viprank[_to];\r\n    }\r\n\r\n    event TokenRewardsAdded(address indexed participant, uint256 balance);\r\n    /**\r\n     * Reward participant the tokens they purchased or earned\r\n     *\r\n     * @param _to address to credit tokens to the \r\n     * @param _value number of tokens to transfer to given recipient\r\n     *\r\n     * @return true if tokens were transferred successfully, false otherwise\r\n     */\r\n    function rewardTokens(address _to, uint256 _value) {\r\n        require(msg.sender == tokenSaleContract || msg.sender == owner);\r\n        assert(_to != 0x0);\r\n        require(_value > 0);\r\n\r\n        balances[_to] = balances[_to].add(_value);\r\n        totalSupply = totalSupply.add(_value);\r\n        updateVIPRank(_to);\r\n        TokenRewardsAdded(_to, _value);\r\n    }\r\n\r\n    event SpentTokens(address indexed participant, address indexed recipient, uint256 amount);\r\n    /**\r\n     * Spend given number of tokens for a usage.\r\n     *\r\n     * @param _to address to spend utility tokens at\r\n     * @param _value number of tokens to spend\r\n     * @return true on success, false on error\r\n     */\r\n    function spend(address _to, uint256 _value) public returns (bool success) {\r\n        require(_value > 0);\r\n        assert(_to != 0x0);\r\n        if (balances[msg.sender] < _value) return false;\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        spentamount[msg.sender][_to] = spentamount[msg.sender][_to].add(_value);\r\n\r\n        SpentTokens(msg.sender, _to, _value);\r\n        if(!patronAppended[msg.sender]) {\r\n            patronAppended[msg.sender] = true;\r\n            patrons.push(msg.sender);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    event Burn(address indexed burner, uint256 value);\r\n    /**\r\n     * Burn given number of tokens belonging to message sender.\r\n     * It can be applied by account with address this.tokensaleContract\r\n     *\r\n     * @param _value number of tokens to burn\r\n     * @return true on success, false on error\r\n     */\r\n    function burnTokens(address burner, uint256 _value) public returns (bool success) {\r\n        require(msg.sender == burner || msg.sender == owner);\r\n        assert(burner != 0x0);\r\n        if (_value > totalSupply) return false;\r\n        if (_value > balances[burner]) return false;\r\n        \r\n        balances[burner] = balances[burner].sub(_value);\r\n        totalSupply = totalSupply.sub(_value);\r\n        Burn(burner, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Get the VIP owner at the index.\r\n     *\r\n     * @param index of the VIP owner on the VIP list\r\n     * @return address of the VIP owner\r\n     */\r\n    function getVIPOwner(uint256 index) constant returns (address vipowner) {\r\n        return (vips[index]);\r\n    }\r\n\r\n    /**\r\n     * Get the count of VIP owners.\r\n     *\r\n     * @return count of VIP owners list.\r\n     */\r\n    function getVIPCount() constant returns (uint256 count) {\r\n        return vips.length;\r\n    }\r\n\r\n    /**\r\n     * Get the patron at the index.\r\n     *\r\n     * @param index of the patron on the patron list\r\n     * @return address of the patron\r\n     */\r\n    function getPatron(uint256 index) constant returns (address patron) {\r\n        return (patrons[index]);\r\n    }\r\n\r\n    /**\r\n     * Get the count of patrons.\r\n     *\r\n     * @return number of patrons.\r\n     */\r\n    function getPatronsCount() constant returns (uint256 count) {\r\n        return patrons.length;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"name\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"burner\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burnTokens\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VIP_MINIMUM\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newTokenSaleContract\",\"type\":\"address\"}],\"name\":\"setTokenSaleContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenSaleContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"rewardTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getVIPCount\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"getVIPRank\",\"outputs\":[{\"name\":\"rank\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"symbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"spend\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getPatron\",\"outputs\":[{\"name\":\"patron\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPatronsCount\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getVIPOwner\",\"outputs\":[{\"name\":\"vipowner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"updateVIPRank\",\"outputs\":[{\"name\":\"rank\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"participant\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"TokenRewardsAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"participant\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SpentTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"LooksCoin","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://1847d8585292a4904ecdc77b47532b3015691733fe001ec5b82796f0d075f8fc"}]}