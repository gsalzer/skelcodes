{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\ncontract ERC20Basic {\r\n\r\n  function balanceOf(address who) public constant returns (uint256);\r\n\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n\r\n  function allowance(address owner, address spender) public constant returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n}\r\n\r\ncontract ERC223 is ERC20 {\r\n\r\n\r\n\r\n    function name() constant returns (string _name);\r\n\r\n    function symbol() constant returns (string _symbol);\r\n\r\n    function decimals() constant returns (uint8 _decimals);\r\n\r\n\r\n\r\n    function transfer(address to, uint256 value, bytes data) returns (bool);\r\n\r\n\r\n\r\n}\r\n\r\ncontract ERC223ReceivingContract {\r\n\r\n    function tokenFallback(address _from, uint256 _value, bytes _data);\r\n\r\n}\r\n\r\ncontract KnowledgeTokenInterface is ERC223{\r\n\r\n    event Mint(address indexed to, uint256 amount);\r\n\r\n\r\n\r\n    function changeMinter(address newAddress) returns (bool);\r\n\r\n    function mint(address _to, uint256 _amount) returns (bool);\r\n\r\n}\r\n\r\ncontract Ownable {\r\n\r\n  address public owner;\r\n\r\n\r\n\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n\r\n\r\n\r\n  /**\r\n\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n\r\n   * account.\r\n\r\n   */\r\n\r\n  function Ownable() {\r\n\r\n    owner = msg.sender;\r\n\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n  /**\r\n\r\n   * @dev Throws if called by any account other than the owner.\r\n\r\n   */\r\n\r\n  modifier onlyOwner() {\r\n\r\n    require(msg.sender == owner);\r\n\r\n    _;\r\n\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n  /**\r\n\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n\r\n   * @param newOwner The address to transfer ownership to.\r\n\r\n   */\r\n\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n\r\n    require(newOwner != address(0));\r\n\r\n    OwnershipTransferred(owner, newOwner);\r\n\r\n    owner = newOwner;\r\n\r\n  }\r\n\r\n\r\n\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n\r\n    uint256 c = a * b;\r\n\r\n    assert(a == 0 || c / a == b);\r\n\r\n    return c;\r\n\r\n  }\r\n\r\n\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n\r\n    uint256 c = a / b;\r\n\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n\r\n  }\r\n\r\n\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n\r\n    assert(b <= a);\r\n\r\n    return a - b;\r\n\r\n  }\r\n\r\n\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n\r\n    uint256 c = a + b;\r\n\r\n    assert(c >= a);\r\n\r\n    return c;\r\n\r\n  }\r\n\r\n}\r\n\r\ncontract WitcoinCrowdsale is Ownable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n\r\n\r\n    // The token being sold\r\n\r\n    WitCoin public token;\r\n\r\n\r\n\r\n    // refund vault used to hold funds while crowdsale is running\r\n\r\n    RefundVault public vault;\r\n\r\n\r\n\r\n    // minimum amount of tokens to be issued\r\n\r\n    uint256 public goal;\r\n\r\n\r\n\r\n    // start and end timestamps where investments are allowed (both inclusive)\r\n\r\n    uint256 public startTime;\r\n\r\n    uint256 public startPresale;\r\n\r\n    uint256 public endTime;\r\n\r\n    uint256 public endRefundingingTime;\r\n\r\n\r\n\r\n    // address where funds are collected\r\n\r\n    address public wallet;\r\n\r\n\r\n\r\n    // how many token units a buyer gets per ether\r\n\r\n    uint256 public rate;\r\n\r\n\r\n\r\n    // amount of raised money in wei\r\n\r\n    uint256 public weiRaised;\r\n\r\n\r\n\r\n    // amount of tokens sold\r\n\r\n    uint256 public tokensSold;\r\n\r\n\r\n\r\n    // amount of tokens distributed\r\n\r\n    uint256 public tokensDistributed;\r\n\r\n\r\n\r\n    // token decimals\r\n\r\n    uint256 public decimals;\r\n\r\n\r\n\r\n    // total of tokens sold in the presale time\r\n\r\n    uint256 public totalTokensPresale;\r\n\r\n\r\n\r\n    // total of tokens sold in the sale time (includes presale)\r\n\r\n    uint256 public totalTokensSale;\r\n\r\n\r\n\r\n    // minimum amount of witcoins bought\r\n\r\n    uint256 public minimumWitcoins;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * event for token purchase logging\r\n\r\n     * @param purchaser who paid for the tokens\r\n\r\n     * @param beneficiary who got the tokens\r\n\r\n     * @param value weis paid for purchase\r\n\r\n     * @param amount amount of tokens purchased\r\n\r\n     */\r\n\r\n    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\r\n\r\n\r\n\r\n    function WitcoinCrowdsale(address witAddress, address receiver) {\r\n\r\n        token = WitCoin(witAddress);\r\n\r\n        decimals = token.decimals();\r\n\r\n        startTime = 1508137200; // 1508137200 = 2017-10-16 07:00:00 GMT\r\n\r\n        startPresale = 1507618800; // 1507618800 = 2017-10-10 07:00:00 GMT\r\n\r\n        endTime = 1509973200; // 2017-11-06 13:00:00 GMT\r\n\r\n        endRefundingingTime = 1527840776; // 01/06/2018\r\n\r\n        rate = 880; // 1 ether = 880 witcoins\r\n\r\n        wallet = receiver;\r\n\r\n        goal = 1000000 * (10 ** decimals); // 1M witcoins\r\n\r\n\r\n\r\n        totalTokensPresale = 1000000 * (10 ** decimals) * 65 / 100; // 65% of 1M witcoins\r\n\r\n        totalTokensSale = 8000000 * (10 ** decimals) * 65 / 100; // 65% of 8M witcoins\r\n\r\n        minimumWitcoins = 100 * (10 ** decimals); // 100 witcoins\r\n\r\n        tokensDistributed = 0;\r\n\r\n\r\n\r\n        vault = new RefundVault(wallet);\r\n\r\n    }\r\n\r\n\r\n\r\n    // fallback function to buy tokens\r\n\r\n    function () payable {\r\n\r\n        buyTokens(msg.sender);\r\n\r\n    }\r\n\r\n\r\n\r\n    // main token purchase function\r\n\r\n    function buyTokens(address beneficiary) public payable {\r\n\r\n        require(beneficiary != 0x0);\r\n\r\n\r\n\r\n        uint256 weiAmount = msg.value;\r\n\r\n\r\n\r\n        // calculate token amount to be created\r\n\r\n        uint256 tokens = weiAmount.mul(rate)/1000000000000000000;\r\n\r\n        tokens = tokens * (10 ** decimals);\r\n\r\n\r\n\r\n        // calculate bonus\r\n\r\n        tokens = calculateBonus(tokens);\r\n\r\n\r\n\r\n        require(validPurchase(tokens));\r\n\r\n\r\n\r\n        // update state\r\n\r\n        weiRaised = weiRaised.add(weiAmount);\r\n\r\n        tokensSold = tokensSold.add(tokens);\r\n\r\n\r\n\r\n        token.mint(beneficiary, tokens);\r\n\r\n        TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\r\n\r\n\r\n\r\n        forwardFunds();\r\n\r\n    }\r\n\r\n\r\n\r\n    // altercoin token purchase function\r\n\r\n    function buyTokensAltercoins(address beneficiary, uint256 tokens) onlyOwner public {\r\n\r\n        require(beneficiary != 0x0);\r\n\r\n\r\n\r\n        // calculate bonus\r\n\r\n        uint256 tokensBonused = calculateBonus(tokens);\r\n\r\n\r\n\r\n        require(validPurchase(tokensBonused));\r\n\r\n\r\n\r\n        // update state\r\n\r\n        tokensSold = tokensSold.add(tokensBonused);\r\n\r\n\r\n\r\n        token.mint(beneficiary, tokensBonused);\r\n\r\n        TokenPurchase(msg.sender, beneficiary, 0, tokensBonused);\r\n\r\n    }\r\n\r\n\r\n\r\n    // send the ether to the fund collection wallet\r\n\r\n    function forwardFunds() internal {\r\n\r\n        vault.deposit.value(msg.value)(msg.sender);\r\n\r\n    }\r\n\r\n\r\n\r\n    // number of tokens issued after applying presale and sale bonuses\r\n\r\n    function calculateBonus(uint256 tokens) internal returns (uint256) {\r\n\r\n        uint256 bonusedTokens = tokens;\r\n\r\n\r\n\r\n        // Pre-Sale Bonus\r\n\r\n        if (presale()) {\r\n\r\n            if (tokensSold <= 250000 * (10 ** decimals)) bonusedTokens = bonusedTokens.mul(130)/100;\r\n\r\n            else if (tokensSold <= 500000 * (10 ** decimals)) bonusedTokens = bonusedTokens.mul(125)/100;\r\n\r\n            else if (tokensSold <= 750000 * (10 ** decimals)) bonusedTokens = bonusedTokens.mul(120)/100;\r\n\r\n            else if (tokensSold <= 1000000 * (10 ** decimals)) bonusedTokens = bonusedTokens.mul(115)/100;\r\n\r\n        }\r\n\r\n\r\n\r\n        // Sale Bonus\r\n\r\n        if (sale()) {\r\n\r\n            if (bonusedTokens > 2500 * (10 ** decimals)) {\r\n\r\n                if (bonusedTokens <= 80000 * (10 ** decimals)) bonusedTokens = bonusedTokens.mul(105)/100;\r\n\r\n                else if (bonusedTokens <= 800000 * (10 ** decimals)) bonusedTokens = bonusedTokens.mul(110)/100;\r\n\r\n                else if (bonusedTokens > 800000 * (10 ** decimals)) bonusedTokens = bonusedTokens.mul(120)/100;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        return bonusedTokens;\r\n\r\n    }\r\n\r\n\r\n\r\n    // presale and sale constraints\r\n\r\n    function validPurchase(uint256 tokens) internal returns (bool) {\r\n\r\n        bool withinPeriod = presale() || sale();\r\n\r\n        bool underLimits = (presale() && tokensSold + tokens <= totalTokensPresale) || (sale() && tokensSold + tokens <= totalTokensSale);\r\n\r\n        bool overMinimum = tokens >= minimumWitcoins;\r\n\r\n        return withinPeriod && underLimits && overMinimum;\r\n\r\n    }\r\n\r\n\r\n\r\n    function validPurchaseBonus(uint256 tokens) public returns (bool) {\r\n\r\n        uint256 bonusedTokens = calculateBonus(tokens);\r\n\r\n        return validPurchase(bonusedTokens);\r\n\r\n    }\r\n\r\n\r\n\r\n    // is presale time?\r\n\r\n    function presale() public returns(bool) {\r\n\r\n        return now >= startPresale && now < startTime;\r\n\r\n    }\r\n\r\n\r\n\r\n    // is sale time?\r\n\r\n    function sale() public returns(bool) {\r\n\r\n        return now >= startTime && now <= endTime;\r\n\r\n    }\r\n\r\n\r\n\r\n    // finalize crowdsale\r\n\r\n    function finalize() onlyOwner public {\r\n\r\n        require(now > endTime);\r\n\r\n\r\n\r\n        if (tokensSold < goal) {\r\n\r\n            vault.enableRefunds();\r\n\r\n        } else {\r\n\r\n            vault.close();\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    function finalized() public returns(bool) {\r\n\r\n        return vault.finalized();\r\n\r\n    }\r\n\r\n\r\n\r\n    // if crowdsale is unsuccessful, investors can claim refunds here\r\n\r\n    function claimRefund() public returns(bool) {\r\n\r\n        vault.refund(msg.sender);\r\n\r\n    }\r\n\r\n\r\n\r\n    function finalizeRefunding() onlyOwner public {\r\n\r\n        require(now > endRefundingingTime);\r\n\r\n\r\n\r\n        vault.finalizeEnableRefunds();\r\n\r\n    }\r\n\r\n\r\n\r\n    // Distribute tokens, only when goal reached\r\n\r\n    // As written in https://witcoin.io:\r\n\r\n    //   1%  bounties\r\n\r\n    //   5%  nir-vana platform\r\n\r\n    //   10% Team\r\n\r\n    //   19% Witcoin.club\r\n\r\n    function distributeTokens() onlyOwner public {\r\n\r\n        require(tokensSold >= goal);\r\n\r\n        require(tokensSold - tokensDistributed > 100);\r\n\r\n\r\n\r\n        uint256 toDistribute = tokensSold - tokensDistributed;\r\n\r\n\r\n\r\n        address bounties = 0x057Afd5422524d5Ca20218d07048300832323360;\r\n\r\n        address nirvana = 0x094d57AdaBa2278de6D1f3e2F975f14248C3775F;\r\n\r\n        address team = 0x7eC9d37163F4F1D1fD7E92B79B73d910088Aa2e7;\r\n\r\n        address club = 0xb2c032aF1336A1482eB2FE1815Ef301A2ea4fE0A;\r\n\r\n\r\n\r\n        uint256 bTokens = toDistribute * 1 / 65;\r\n\r\n        uint256 nTokens = toDistribute * 5 / 65;\r\n\r\n        uint256 tTokens = toDistribute * 10 / 65;\r\n\r\n        uint256 cTokens = toDistribute * 19 / 65;\r\n\r\n\r\n\r\n        token.mint(bounties, bTokens);\r\n\r\n        token.mint(nirvana, nTokens);\r\n\r\n        token.mint(team, tTokens);\r\n\r\n        token.mint(club, cTokens);\r\n\r\n\r\n\r\n        tokensDistributed = tokensDistributed.add(toDistribute);\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\ncontract RefundVault is Ownable {\r\n\r\n  using SafeMath for uint256;\r\n\r\n\r\n\r\n  enum State { Active, Refunding, Closed }\r\n\r\n\r\n\r\n  mapping (address => uint256) public deposited;\r\n\r\n  address public wallet;\r\n\r\n  State public state;\r\n\r\n\r\n\r\n  event Closed();\r\n\r\n  event RefundsEnabled();\r\n\r\n  event Refunded(address indexed beneficiary, uint256 weiAmount);\r\n\r\n\r\n\r\n  function RefundVault(address _wallet) {\r\n\r\n    require(_wallet != 0x0);\r\n\r\n\r\n\r\n    wallet = _wallet;\r\n\r\n    state = State.Active;\r\n\r\n  }\r\n\r\n\r\n\r\n  function deposit(address investor) onlyOwner public payable {\r\n\r\n    require(state == State.Active);\r\n\r\n    deposited[investor] = deposited[investor].add(msg.value);\r\n\r\n  }\r\n\r\n\r\n\r\n  function close() onlyOwner public {\r\n\r\n    require(state == State.Active);\r\n\r\n\r\n\r\n    state = State.Closed;\r\n\r\n    Closed();\r\n\r\n    wallet.transfer(this.balance);\r\n\r\n  }\r\n\r\n\r\n\r\n  function enableRefunds() onlyOwner public {\r\n\r\n    require(state == State.Active);\r\n\r\n\r\n\r\n    state = State.Refunding;\r\n\r\n    RefundsEnabled();\r\n\r\n  }\r\n\r\n\r\n\r\n  function finalizeEnableRefunds() onlyOwner public {\r\n\r\n    require(state == State.Refunding);\r\n\r\n    state = State.Closed;\r\n\r\n    Closed();\r\n\r\n    wallet.transfer(this.balance);\r\n\r\n  }\r\n\r\n\r\n\r\n  function refund(address investor) onlyOwner public {\r\n\r\n    require(state == State.Refunding);\r\n\r\n\r\n\r\n    uint256 depositedValue = deposited[investor];\r\n\r\n    deposited[investor] = 0;\r\n\r\n    investor.transfer(depositedValue);\r\n\r\n    Refunded(investor, depositedValue);\r\n\r\n  }\r\n\r\n\r\n\r\n  function finalized() public returns(bool) {\r\n\r\n    return state != State.Active;\r\n\r\n  }\r\n\r\n}\r\n\r\ncontract ERC20BasicToken is ERC20Basic {\r\n\r\n  using SafeMath for uint256;\r\n\r\n\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  uint256 public totalSupply;\r\n\r\n\r\n\r\n  /**\r\n\r\n  * @dev transfer token for a specified address\r\n\r\n  * @param _to The address to transfer to.\r\n\r\n  * @param _value The amount to be transferred.\r\n\r\n  */\r\n\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n\r\n    require(_to != address(0));\r\n\r\n\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n\r\n    balances[_to] = balances[_to].add(_value);\r\n\r\n    Transfer(msg.sender, _to, _value);\r\n\r\n    return true;\r\n\r\n  }\r\n\r\n\r\n\r\n  /**\r\n\r\n  * @dev Gets the balance of the specified address.\r\n\r\n  * @param _owner The address to query the the balance of.\r\n\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n\r\n  */\r\n\r\n  function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n\r\n    return balances[_owner];\r\n\r\n  }\r\n\r\n\r\n\r\n  function totalSupply() constant returns (uint256 _totalSupply) {\r\n\r\n    return totalSupply;\r\n\r\n  }\r\n\r\n\r\n\r\n}\r\n\r\ncontract ERC20Token is ERC20, ERC20BasicToken {\r\n\r\n\r\n\r\n  mapping (address => mapping (address => uint256)) allowed;\r\n\r\n\r\n\r\n  /**\r\n\r\n   * @dev Transfer tokens from one address to another\r\n\r\n   * @param _from address The address which you want to send tokens from\r\n\r\n   * @param _to address The address which you want to transfer to\r\n\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n\r\n   */\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n\r\n    require(_to != address(0));\r\n\r\n\r\n\r\n    uint256 _allowance = allowed[_from][msg.sender];\r\n\r\n\r\n\r\n    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n\r\n    // require (_value <= _allowance);\r\n\r\n\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n\r\n    balances[_to] = balances[_to].add(_value);\r\n\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\n\r\n    Transfer(_from, _to, _value);\r\n\r\n    return true;\r\n\r\n  }\r\n\r\n\r\n\r\n  /**\r\n\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n\r\n   *\r\n\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n\r\n   * @param _spender The address which will spend the funds.\r\n\r\n   * @param _value The amount of tokens to be spent.\r\n\r\n   */\r\n\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n\r\n    Approval(msg.sender, _spender, _value);\r\n\r\n    return true;\r\n\r\n  }\r\n\r\n\r\n\r\n  /**\r\n\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n\r\n   * @param _owner address The address which owns the funds.\r\n\r\n   * @param _spender address The address which will spend the funds.\r\n\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n\r\n   */\r\n\r\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n\r\n    return allowed[_owner][_spender];\r\n\r\n  }\r\n\r\n\r\n\r\n  /**\r\n\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n\r\n   * the first transaction is mined)\r\n\r\n   * From MonolithDAO Token.sol\r\n\r\n   */\r\n\r\n  function increaseApproval (address _spender, uint _addedValue)\r\n\r\n    returns (bool success) {\r\n\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n\r\n    return true;\r\n\r\n  }\r\n\r\n\r\n\r\n  function decreaseApproval (address _spender, uint _subtractedValue)\r\n\r\n    returns (bool success) {\r\n\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n\r\n    if (_subtractedValue > oldValue) {\r\n\r\n      allowed[msg.sender][_spender] = 0;\r\n\r\n    } else {\r\n\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n\r\n    }\r\n\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n\r\n    return true;\r\n\r\n  }\r\n\r\n\r\n\r\n}\r\n\r\ncontract ERC223Token is ERC223, ERC20Token {\r\n\r\n    using SafeMath for uint256;\r\n\r\n\r\n\r\n    string public name;\r\n\r\n\r\n\r\n    string public symbol;\r\n\r\n\r\n\r\n    uint8 public decimals;\r\n\r\n\r\n\r\n\r\n\r\n    // Function to access name of token .\r\n\r\n    function name() constant returns (string _name) {\r\n\r\n        return name;\r\n\r\n    }\r\n\r\n    // Function to access symbol of token .\r\n\r\n    function symbol() constant returns (string _symbol) {\r\n\r\n        return symbol;\r\n\r\n    }\r\n\r\n    // Function to access decimals of token .\r\n\r\n    function decimals() constant returns (uint8 _decimals) {\r\n\r\n        return decimals;\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    // Function that is called when a user or another contract wants to transfer funds .\r\n\r\n    function transfer(address _to, uint256 _value, bytes _data) returns (bool success) {\r\n\r\n        if (isContract(_to)) {\r\n\r\n            ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\r\n\r\n            receiver.tokenFallback(msg.sender, _value, _data);\r\n\r\n        }\r\n\r\n        return super.transfer(_to, _value);\r\n\r\n    }\r\n\r\n\r\n\r\n    // Standard function transfer similar to ERC20 transfer with no _data .\r\n\r\n    // Added due to backwards compatibility reasons .\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n\r\n        if (isContract(_to)) {\r\n\r\n            bytes memory empty;\r\n\r\n            ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\r\n\r\n            receiver.tokenFallback(msg.sender, _value, empty);\r\n\r\n        }\r\n\r\n        return super.transfer(_to, _value);\r\n\r\n    }\r\n\r\n\r\n\r\n    //assemble the given address bytecode. If bytecode exists then the _addr is a contract.\r\n\r\n    function isContract(address _addr) private returns (bool is_contract) {\r\n\r\n        uint length;\r\n\r\n        assembly {\r\n\r\n            length := extcodesize(_addr)\r\n\r\n        }\r\n\r\n        return (length > 0);\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\ncontract KnowledgeToken is KnowledgeTokenInterface, Ownable, ERC223Token {\r\n\r\n\r\n\r\n    address public minter;\r\n\r\n\r\n\r\n    modifier onlyMinter() {\r\n\r\n        // Only minter is allowed to proceed.\r\n\r\n        require (msg.sender == minter);\r\n\r\n        _;\r\n\r\n    }\r\n\r\n\r\n\r\n    function mint(address _to, uint256 _amount) onlyMinter public returns (bool) {\r\n\r\n        totalSupply = totalSupply.add(_amount);\r\n\r\n        balances[_to] = balances[_to].add(_amount);\r\n\r\n        Transfer(0x0, _to, _amount);\r\n\r\n        Mint(_to, _amount);\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n\r\n\r\n    function changeMinter(address newAddress) public onlyOwner returns (bool)\r\n\r\n    {\r\n\r\n        minter = newAddress;\r\n\r\n    }\r\n\r\n}\r\n\r\ncontract WitCoin is KnowledgeToken{\r\n\r\n\r\n\r\n    function WitCoin() {\r\n\r\n        totalSupply = 0;\r\n\r\n        name = \"Witcoin\";\r\n\r\n        symbol = \"WIT\";\r\n\r\n        decimals = 8;\r\n\r\n    }\r\n\r\n\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"startPresale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumWitcoins\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensDistributed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"goal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sale\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalizeRefunding\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"distributeTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"buyTokensAltercoins\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimRefund\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"validPurchaseBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endRefundingingTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensPresale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"presale\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"witAddress\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"WitcoinCrowdsale","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000009e7e5b5651e826b301a9567a5bb950a42bb1790400000000000000000000000004cf6551a4e0810c32dedbd76228b715f2598a33","Library":"","SwarmSource":"bzzr://51369b87d7a7adabdddb980799bd7afe75b42c2b5493d449366666c2c29e04b4"}]}