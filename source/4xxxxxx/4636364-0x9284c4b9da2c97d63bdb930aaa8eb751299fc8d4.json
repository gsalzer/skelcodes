{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\ncontract EightStakes {\r\n\tstruct Player {\r\n\t\tuint dt;\r\n\t\taddress oAddress;\r\n\t\tint nSpent;\r\n\t\tint[] aResults;\r\n\t\tmapping (uint => uint) mGasByRoom;\r\n\t}\r\n\tstruct Room {\r\n\t\taddress[] aPlayers;\r\n\t\tuint[] aLosers;\r\n\t\tuint nBid;\r\n\t\tuint nStart;\r\n\t\tuint nLastPlayersBlockNumber;\r\n\t}\r\n    address private _oSesokaj;\r\n\t\r\n\tmapping (address => Player) private _mPlayers;\r\n\tmapping (address => uint8) private _mPlayerRooms;\r\n\taddress[] private _aPlayersBinds;\r\n\taddress[] private _aLosers;\r\n\r\n\tuint private _nRoomNextID;\r\n\tmapping (uint => Room) private _mRooms;\r\n\tuint[] private _aRoomsOpened;\r\n\tuint[] private _aRoomsClosed;\r\n\r\n\tuint private _nMaxArchiveLength;\r\n\t\r\n\tuint private _nRefundCurrent;\r\n\tuint private _nRefundLimit;\r\n\tuint private _nRefundIncrease;\r\n\taddress private _oRefundRecipient;\r\n\t\r\n\tuint private _nJackpot;\r\n\tuint private _nJackpotLast;\r\n\tuint private _nJackpotDiapason;\r\n\taddress private _oJackpotRecipient;\r\n\r\n\tfunction EightStakes() public {\r\n\t    _oSesokaj = msg.sender;\r\n\t\t_nMaxArchiveLength = 300;   \r\n\t\t_nJackpotDiapason = uint(-1)/(3.5 * 100000); \r\n\t\t_nRefundLimit = 8000000000000000000;  // 8eth\r\n\t\t_nRefundIncrease = 8000000000000000000;  // 8eth\r\n\t\t_aLosers.length = 10;\r\n\t}\r\n\r\n\t// PUBLIC\r\n\tfunction Bid(uint8 nRoomSize) public payable returns(bool) {\r\n\t\tuint8 nRoomType; //room type as a bit-flag value; size/bid: 0 for unused pair; 1 for 4/0.08, 2 for 4/0.8, 4 and 8 reserved, 16 for 8/0.08, 32 for 8/0.8, 64 for 8/8, 128 reserved\r\n\t\tint nRoomTypeIndx; //index from zero to four; size/bid: -1 for unused pair; 0 for 4/0.08, 1 for 4/0.8, 2 for 8/0.08, 3 for 8/0.8, 4 for 8/8\r\n\t\t(nRoomType, nRoomTypeIndx) = roomTypeGet(msg.value, nRoomSize);\r\n\t\tif (1 > nRoomType)\r\n\t\t\trevert();\r\n\t\t\r\n\t\tProcessRooms();\r\n\t\t//check for rebid\r\n\t\tif (0 != _mPlayerRooms[msg.sender] & nRoomType)\r\n\t\t\trevert();\r\n\t\t_mPlayerRooms[msg.sender] |= nRoomType;\r\n\t\tuint nRoom = roomGet(msg.value, nRoomSize);\r\n\t\tRoom memory oRoom = _mRooms[nRoom];\r\n\t\tuint nPlayer = 0;\r\n\t\tfor (; oRoom.aPlayers.length > nPlayer; nPlayer++) {\r\n\t\t    if (1 > oRoom.aPlayers[nPlayer])\r\n\t\t\t\tbreak;\r\n\t\t    if (oRoom.aPlayers[nPlayer] == msg.sender)  \r\n\t\t\t\trevert();\r\n\t\t}\r\n\t\tuint nGas = msg.gas*800000000;\r\n\t\tif (0 < _mPlayers[msg.sender].oAddress) {\r\n\t\t    _mPlayers[msg.sender].dt = now;\r\n\t\t\t_mPlayers[msg.sender].nSpent += int(nGas);\r\n\t\t\t_mPlayers[msg.sender].aResults[uint(nRoomTypeIndx)] = 0;\r\n\t\t} else {\r\n\t\t\t_mPlayers[msg.sender] = Player(now, msg.sender, int(nGas), new int[](5));\r\n\t\t\t_aPlayersBinds.push(msg.sender);\r\n\t\t}\r\n\t\t_mPlayers[msg.sender].mGasByRoom[nRoom] = nGas;\r\n\t\toRoom.aPlayers[nPlayer] = msg.sender;\r\n\t\tif (nPlayer + 1 == oRoom.aPlayers.length) {\r\n\t\t\toRoom.nStart = now;\r\n\t\t\toRoom.nLastPlayersBlockNumber = block.number;\r\n\t\t}\r\n\t\t_mRooms[nRoom] = oRoom;\r\n\t\treturn true;\r\n\t}\r\n\tfunction IsCheckNeeded(uint nNowDate, uint nMaxInterval) public constant returns(bool) {\r\n\t\tfor (uint n=0; n<_aRoomsOpened.length; n++) {\r\n\t\t\tif (0 < _mRooms[_aRoomsOpened[n]].nLastPlayersBlockNumber && \r\n\t\t\t\t\t_mRooms[_aRoomsOpened[n]].nStart + nMaxInterval < nNowDate && \r\n\t\t\t\t\t0 < uint(block.blockhash(_mRooms[_aRoomsOpened[n]].nLastPlayersBlockNumber)) ) { \r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\tfunction ProcessRooms() public {\r\n\t\tuint[] memory a = new uint[](_aRoomsOpened.length);\r\n\t\tuint n = 0;\r\n\t\tuint nCurrent = 0;\r\n\t\tuint nRoom;\r\n\t\tRoom memory oRoom;\r\n\t\tfor (; _aRoomsOpened.length > n; n++) {\r\n\t\t    oRoom = _mRooms[nRoom = _aRoomsOpened[n]];\r\n\t\t\tif (0 < oRoom.nLastPlayersBlockNumber && 0 < uint(block.blockhash(oRoom.nLastPlayersBlockNumber))) {\r\n\t\t\t\tresult(nRoom);\r\n\t\t\t\ta[nCurrent++] = n;\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (n = 0; nCurrent > n; n++)\r\n\t\t\troomClose(a[n]);\r\n\t\tdelete a;\r\n\t}\r\n\tfunction LastResult(address oPlayer, uint8 nSize, uint nBid) public constant returns (bool, int) {\r\n\t\tuint nPlayer = uint(-1);\r\n\t\tuint nDate = 0;\r\n\t\tuint nRoom = 0;\r\n\t\tuint nRoomCurrent;\r\n\t\tRoom memory oRoom;\r\n\t\tfor (uint n=0; _aRoomsClosed.length > n; n++) {\r\n\t\t    oRoom = _mRooms[nRoomCurrent = _aRoomsClosed[n]];\r\n\t\t\tif (oRoom.aPlayers.length != nSize || oRoom.nBid != nBid || uint(-1) == (nPlayer = playerGet(oRoom, oPlayer)))\r\n\t\t\t\tcontinue;\r\n\t\t\tif (oRoom.nStart > nDate) {\r\n\t\t\t\tnDate = oRoom.nStart;\r\n\t\t\t\tnRoom = nRoomCurrent;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (0 < nDate) {\r\n\t\t    oRoom = _mRooms[nRoom];\r\n\t\t    for (n=0; oRoom.aLosers.length > n; n++) {\r\n\t\t        if (oPlayer == oRoom.aPlayers[oRoom.aLosers[n]])\r\n    \t\t\t\treturn(false, int(-oRoom.nBid));\r\n\t\t\t}\r\n\t\t\treturn(true, int(prizeCalculate(oRoom)));\r\n\t\t}\r\n\t\treturn(false, 0);\r\n\t}\r\n\t//Plenum\r\n\t//returns a number of players for a room specified by a size and a bid\r\n\tfunction Plenum(uint8 nSize, uint nBid) public constant returns (uint8) {\r\n\t\tRoom memory oRoom;\r\n\t\tuint nLength;\r\n\t\tfor (uint n=0; _aRoomsOpened.length > n; n++) {\r\n\t\t\toRoom = _mRooms[_aRoomsOpened[n]];\r\n\t\t\tif (nBid == oRoom.nBid && nSize == (nLength = oRoom.aPlayers.length) && 1 > oRoom.aPlayers[--nLength]) {\r\n\t\t\t\tfor (; 0 <= nLength; nLength--) {\r\n\t\t\t\t\tif (0 < oRoom.aPlayers[nLength])\r\n\t\t\t\t\t\treturn uint8(nLength + 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn(0);\r\n\t}\r\n\tfunction State(address[] aTargets) public view returns(uint[4] aPerks, address[2] aPerksRecipients, address[] aLosersAddresses, int[] aLosersBalances, bool[5] aRooms, int[5] aResults) {\r\n\t\taLosersBalances = new int[](_aLosers.length);\r\n\t\tuint nLength = _aLosers.length;\r\n\t\tuint n = 0;\r\n\t\tfor (; nLength > n; n++)\r\n\t\t\taLosersBalances[n] = _mPlayers[_aLosers[n]].nSpent;\r\n\t\tfor (n = 0; aTargets.length > n; n++) {\r\n\t\t\tuint8 nValue = 1;\r\n\t\t\tfor (uint nIndx = 0; aRooms.length > nIndx; nIndx++) {\r\n\t\t\t\tif (0 < _mPlayerRooms[aTargets[n]]) {\r\n\t\t\t\t\taRooms[nIndx] = aRooms[nIndx] || (0 < (_mPlayerRooms[aTargets[n]] & nValue));\r\n\t\t\t\t\tif (2 == nValue)\r\n\t\t\t\t\t\tnValue <<= 3;\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tnValue <<= 1;\r\n\t\t\t\t}\r\n\t\t\t\tif (0 == aResults[nIndx] && 0 != _mPlayers[aTargets[n]].oAddress && 0 != _mPlayers[aTargets[n]].aResults[nIndx])\r\n\t\t\t\t\taResults[nIndx] += _mPlayers[aTargets[n]].aResults[nIndx];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn ([_nJackpot, _nJackpotLast, _nRefundLimit, _nRefundCurrent], [_oJackpotRecipient, _oRefundRecipient], _aLosers, aLosersBalances, aRooms, aResults);\r\n\t}\r\n    function Remove() public {\r\n        if (msg.sender == _oSesokaj)\r\n            selfdestruct(_oSesokaj);\r\n    }\r\n\r\n\t// PRIVATE\r\n\t//roomTypeGet\r\n\t//returns two values:\r\n\t//room type as a bit-flag value; size/bid: 0 for unused pair; 1 for 4/0.08, 2 for 4/0.8, 4 and 8 reserved, 16 for 8/0.08, 32 for 8/0.8, 64 for 8/8, 128 reserved\r\n\t//index from zero to four; size/bid: -1 for unused pair; 0 for 4/0.08, 1 for 4/0.8, 2 for 8/0.08, 3 for 8/0.8, 4 for 8/8\r\n\tfunction roomTypeGet(uint nBid, uint8 nSize) private pure returns(uint8, int) {\r\n\t\tif (80000000000000000 == nBid) { //0.08eth\r\n\t\t\tif (4 == nSize)\r\n\t\t\t\treturn (1, 0);\r\n\t\t\tif (8 == nSize)\r\n\t\t\t\treturn (16, 2);\r\n\t\t}\r\n\t\tif (800000000000000000 == nBid) { //0.8eth\r\n\t\t\tif (4 == nSize)\r\n\t\t\t\treturn (2, 1);\r\n\t\t\tif (8 == nSize)\r\n\t\t\t\treturn (32, 3);\r\n\t\t}\r\n\t\tif (8000000000000000000 == nBid && 8 == nSize) //8eth\r\n\t\t\t\treturn (64, 4);\r\n\t\treturn (0, -1);\r\n\t}\r\n\tfunction roomClose(uint nOpened) private{\r\n\t    uint n;\r\n\t\tif (_aRoomsClosed.length >= _nMaxArchiveLength) {\r\n    \t\tuint nClosed = 0;\r\n    \t\tuint nRoom = 0;\r\n    \t\tuint nDate = uint(-1);\r\n    \t\tuint nStart;\r\n    \t\tfor (n=0; _aRoomsClosed.length > n; n++) {\r\n    \t\t\tif ((nStart = _mRooms[_aRoomsClosed[n]].nStart) < nDate) {\r\n    \t\t\t\tnClosed = n;\r\n    \t\t\t\tnDate = nStart;\r\n    \t\t\t}\r\n    \t\t}\r\n    \t\tuint nLength = _mRooms[nRoom = _aRoomsClosed[nClosed]].aPlayers.length;\r\n\t\t\tfor (n=0; nLength > n; n++) {\r\n\t\t\t    delete _mPlayers[_mRooms[nRoom].aPlayers[n]].mGasByRoom[nRoom];\r\n\t\t\t\tdelete _mRooms[nRoom].aPlayers[n];\r\n\t\t\t}\r\n\t\t\tdelete _mRooms[nRoom];\r\n\t\t\t_aRoomsClosed[nClosed] = _aRoomsOpened[nOpened];\r\n\t\t} else\r\n\t\t\t_aRoomsClosed.push(_aRoomsOpened[nOpened]);\r\n\r\n\t\tif (nOpened < (n = _aRoomsOpened.length - 1))\r\n\t\t\t_aRoomsOpened[nOpened] = _aRoomsOpened[n];\r\n\t\t_aRoomsOpened.length--;\r\n\t}\r\n\tfunction roomGet(uint nBid, uint8 nSize) private returns(uint nRetVal) {\r\n\t    Room memory oRoom;\r\n\t    uint nLength;\r\n\t\tfor (uint n=0; _aRoomsOpened.length > n; n++) {\r\n\t\t    nRetVal = _aRoomsOpened[n];\r\n\t\t    oRoom = _mRooms[nRetVal];\r\n\t\t    nLength = oRoom.aPlayers.length;\r\n\t\t\tif (nBid == oRoom.nBid && nSize == nLength && 1 > oRoom.aPlayers[nLength - 1])\r\n\t\t\t\treturn;\r\n\t\t}\r\n\t\toRoom = Room(new address[](nSize), new uint[](0), nBid, 0, 0);\r\n\t\t_mRooms[nRetVal = _nRoomNextID] = oRoom;\r\n\t\t_aRoomsOpened[++_aRoomsOpened.length - 1] = _nRoomNextID;\r\n\t\t_nRoomNextID++;\r\n\t\treturn;\r\n\t}\r\n\tfunction playerGet(Room memory oRoom, address oPlayer) private pure returns(uint) {\r\n\t\tfor (uint8 n=0; oRoom.aPlayers.length > n; n++) {\r\n\t\t\tif (oPlayer == oRoom.aPlayers[n])\r\n\t\t\t\treturn n;\r\n\t\t}\r\n\t\treturn uint(-1); \r\n\t}\r\n\tfunction prizeCalculate(Room memory oRoom) private pure returns (uint) {\r\n\t\treturn (oRoom.nBid / 4);\r\n\t}\r\n\tfunction result(uint nRoom) private {\r\n\t    Room memory oRoom = _mRooms[nRoom];\r\n\t    if (0 < oRoom.aLosers.length)\r\n\t        revert();\r\n\t\tuint8 nSize = uint8(oRoom.aPlayers.length);\r\n\t\tbytes32[] memory aHashes;\r\n\t\tuint8 nIndx1;\r\n\t\tuint8 nIndx2;\r\n\r\n\t\t(aHashes, nIndx1, nIndx2) = gameCalculate(oRoom);\r\n\r\n\t    oRoom.aLosers = new uint[](nSize/4);\r\n\t\toRoom.aLosers[0] = nIndx1;\r\n\t\tif (8 == nSize)\r\n\t\t\toRoom.aLosers[1] = nIndx2;\r\n\r\n\t\tuint nValue = (oRoom.nBid * oRoom.aPlayers.length / 64);\r\n\t\t_nJackpot += nValue;\r\n\t\t_nRefundCurrent += nValue;\r\n\r\n\t\tnValue = prizeCalculate(oRoom);\r\n\t\tuint8 nRoomType;\r\n\t\tint nRoomTypeIndx;\r\n\t\tint nAmount;\r\n\t\t(nRoomType, nRoomTypeIndx) = roomTypeGet(oRoom.nBid, nSize);\r\n\t\tfor (uint n=0; nSize > n; n++) {\r\n\t\t\tif (nIndx1 == n || (8 == nSize && nIndx2 == n))\r\n\t\t\t\tnAmount = -int(oRoom.nBid);\r\n\t\t\telse if (!_mPlayers[oRoom.aPlayers[n]].oAddress.send(uint(nAmount = int(oRoom.nBid + nValue + _mPlayers[oRoom.aPlayers[n]].mGasByRoom[nRoom]))))\r\n\t\t\t\tnAmount = 0; //fuckup with sending\r\n\t\t\t_mPlayers[oRoom.aPlayers[n]].nSpent -= (_mPlayers[oRoom.aPlayers[n]].aResults[uint(nRoomTypeIndx)] = nAmount);\r\n\t\t\tif (0 == (_mPlayerRooms[oRoom.aPlayers[n]] &= ~nRoomType))\r\n\t\t\t\tdelete _mPlayerRooms[oRoom.aPlayers[n]]; //remove player from room map if it was his last room\r\n\t\t}\r\n\r\n\t\tuint nDiff = uint(aHashes[nIndx2]) - uint(aHashes[nIndx1]);\r\n\t\tif (nDiff > 0 && nDiff < _nJackpotDiapason) {\r\n\t\t\tif (oRoom.aPlayers[nIndx1].send(_nJackpot)) {\r\n\t\t\t\t_oJackpotRecipient = oRoom.aPlayers[nIndx1];\r\n\t\t\t\t_nJackpotLast = _nJackpot;\r\n\t\t\t\t_nJackpot = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t\t_mRooms[nRoom] = oRoom;\r\n\r\n\t\tif (_nRefundCurrent > _nRefundLimit && 0 != _aLosers[0]) {\r\n\t\t\tif (_aLosers[0].send(_nRefundCurrent)) {\r\n\t\t\t\t_oRefundRecipient = _aLosers[0];\r\n\t\t\t\t_nRefundLimit += _nRefundIncrease;\r\n\t\t\t\t_mPlayers[_aLosers[0]].nSpent -= int(_nRefundCurrent);\r\n\t\t\t\t_nRefundCurrent = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t\tlosers();\r\n\t}\r\n\tfunction losers() private {\r\n\t    Player[] memory aLosers = new Player[](_aLosers.length);\r\n\t\tPlayer memory oPlayer;\r\n\t\tPlayer memory oShift;\r\n\t\tuint nLoser;\r\n\t\tuint nLength = _aPlayersBinds.length;\r\n\t    for (uint nPlayer=0; nLength > nPlayer; nPlayer++) {\r\n\t\t\toPlayer = _mPlayers[_aPlayersBinds[nPlayer]];\r\n\t\t\tif (now - oPlayer.dt > 30 days) {\r\n\t\t\t\tdelete _mPlayers[_aPlayersBinds[nPlayer]];\r\n\t\t\t\t_aPlayersBinds[nPlayer] = _aPlayersBinds[nLength--];\r\n\t\t\t\tnPlayer--;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tfor (nLoser=0; aLosers.length > nLoser; nLoser++) {\r\n\t\t\t\tif (0 == aLosers[nLoser].oAddress) {\r\n\t\t\t\t\taLosers[nLoser] = oPlayer;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tif (oPlayer.nSpent > aLosers[nLoser].nSpent) {\r\n\t\t\t\t\toShift = aLosers[nLoser];\r\n\t\t\t\t\taLosers[nLoser] = oPlayer;\r\n\t\t\t\t\toPlayer = oShift;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t    }\r\n\t\tfor (nLoser=0; aLosers.length > nLoser; nLoser++)\r\n\t\t\t_aLosers[nLoser] = aLosers[nLoser].oAddress;\r\n\t}\r\n\tfunction gameCalculate(Room oRoom) private constant returns (bytes32[] memory aHashes, uint8 nIndx1, uint8 nIndx2) {\r\n\t\tbytes32 aBlockHash = block.blockhash(oRoom.nLastPlayersBlockNumber);\r\n\t    uint nSize = oRoom.aPlayers.length;\r\n\t\taHashes = new bytes32[](nSize);\r\n\t\tbytes32 nHash1 = bytes32(-1);\r\n\t\tbytes32 nHash2 = bytes32(-1);\r\n\r\n\t\tfor (uint8 n=0; nSize > n; n++) {\r\n\t\t\taHashes[n] = sha256(uint(oRoom.aPlayers[n]) + uint(aBlockHash));\r\n\t\t\tif (aHashes[n] <= nHash2 ) {\r\n\t\t\t\tif (aHashes[n] <= nHash1) {\r\n\t\t\t\t\tnHash2 = nHash1;\r\n\t\t\t\t\tnIndx2 = nIndx1;\r\n\t\t\t\t\tnHash1 = aHashes[n];\r\n\t\t\t\t\tnIndx1 = n;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tnHash2 = aHashes[n];\r\n\t\t\t\t\tnIndx2 = n;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (nIndx1 == nIndx2)\r\n\t\t\t(nIndx1, nIndx2) = (0, 0);\r\n\t\treturn;\r\n\t}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"nNowDate\",\"type\":\"uint256\"},{\"name\":\"nMaxInterval\",\"type\":\"uint256\"}],\"name\":\"IsCheckNeeded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"oPlayer\",\"type\":\"address\"},{\"name\":\"nSize\",\"type\":\"uint8\"},{\"name\":\"nBid\",\"type\":\"uint256\"}],\"name\":\"LastResult\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"aTargets\",\"type\":\"address[]\"}],\"name\":\"State\",\"outputs\":[{\"name\":\"aPerks\",\"type\":\"uint256[4]\"},{\"name\":\"aPerksRecipients\",\"type\":\"address[2]\"},{\"name\":\"aLosersAddresses\",\"type\":\"address[]\"},{\"name\":\"aLosersBalances\",\"type\":\"int256[]\"},{\"name\":\"aRooms\",\"type\":\"bool[5]\"},{\"name\":\"aResults\",\"type\":\"int256[5]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"Remove\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"ProcessRooms\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"nSize\",\"type\":\"uint8\"},{\"name\":\"nBid\",\"type\":\"uint256\"}],\"name\":\"Plenum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"nRoomSize\",\"type\":\"uint8\"}],\"name\":\"Bid\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"EightStakes","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://20473900e1e5c1da017d8f452bcd989b33ea6780f52ca6974a5f2d65fb0dfc59"}]}