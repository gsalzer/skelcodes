{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13; \r\n\r\n\r\n////////////////// >>>>> Wallet Contract <<<<< ///////////////////\r\n\r\n\r\n/// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution.\r\n/// @author Stefan George - <stefan.george@consensys.net>\r\ncontract MultiSigWallet {\r\n\r\n    uint constant public MAX_OWNER_COUNT = 50;\r\n\r\n    event Confirmation(address indexed sender, uint indexed transactionId);\r\n    event Revocation(address indexed sender, uint indexed transactionId);\r\n    event Submission(uint indexed transactionId);\r\n    event Execution(uint indexed transactionId);\r\n    event ExecutionFailure(uint indexed transactionId);\r\n    event Deposit(address indexed sender, uint value);\r\n    event OwnerAddition(address indexed owner);\r\n    event OwnerRemoval(address indexed owner);\r\n    event RequirementChange(uint required);\r\n\r\n    mapping (uint => Transaction) public transactions;\r\n    mapping (uint => mapping (address => bool)) public confirmations;\r\n    mapping (address => bool) public isOwner;\r\n    address[] public owners;\r\n    uint public required;\r\n    uint public transactionCount;\r\n\r\n    struct Transaction {\r\n        address destination;\r\n        uint value;\r\n        bytes data;\r\n        bool executed;\r\n    }\r\n\r\n    modifier onlyWallet() {\r\n        if (msg.sender != address(this))\r\n            throw;\r\n        _;\r\n    }\r\n\r\n    modifier ownerDoesNotExist(address owner) {\r\n        if (isOwner[owner])\r\n            throw;\r\n        _;\r\n    }\r\n\r\n    modifier ownerExists(address owner) {\r\n        if (!isOwner[owner])\r\n            throw;\r\n        _;\r\n    }\r\n\r\n    modifier transactionExists(uint transactionId) {\r\n        if (transactions[transactionId].destination == 0)\r\n            throw;\r\n        _;\r\n    }\r\n\r\n    modifier confirmed(uint transactionId, address owner) {\r\n        if (!confirmations[transactionId][owner])\r\n            throw;\r\n        _;\r\n    }\r\n\r\n    modifier notConfirmed(uint transactionId, address owner) {\r\n        if (confirmations[transactionId][owner])\r\n            throw;\r\n        _;\r\n    }\r\n\r\n    modifier notExecuted(uint transactionId) {\r\n        if (transactions[transactionId].executed)\r\n            throw;\r\n        _;\r\n    }\r\n\r\n    modifier notNull(address _address) {\r\n        if (_address == 0)\r\n            throw;\r\n        _;\r\n    }\r\n\r\n    modifier validRequirement(uint ownerCount, uint _required) {\r\n        if (   ownerCount > MAX_OWNER_COUNT\r\n            || _required > ownerCount\r\n            || _required == 0\r\n            || ownerCount == 0)\r\n            throw;\r\n        _;\r\n    }\r\n\r\n    /// @dev Fallback function allows to deposit ether.\r\n    function()\r\n        payable\r\n    {\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n\r\n    /*\r\n     * Public functions\r\n     */\r\n    /// @dev Contract constructor sets initial owners and required number of confirmations.\r\n    /// @param _owners List of initial owners.\r\n    /// @param _required Number of required confirmations.\r\n    function MultiSigWallet(address[] _owners, uint _required)\r\n        public\r\n        validRequirement(_owners.length, _required)\r\n    {\r\n        for (uint i=0; i<_owners.length; i++) {\r\n            if (isOwner[_owners[i]] || _owners[i] == 0)\r\n                throw;\r\n            isOwner[_owners[i]] = true;\r\n        }\r\n        owners = _owners;\r\n        required = _required;\r\n    }\r\n\r\n    /// @dev Allows to add a new owner. Transaction has to be sent by wallet.\r\n    /// @param owner Address of new owner.\r\n    function addOwner(address owner)\r\n        public\r\n        onlyWallet\r\n        ownerDoesNotExist(owner)\r\n        notNull(owner)\r\n        validRequirement(owners.length + 1, required)\r\n    {\r\n        isOwner[owner] = true;\r\n        owners.push(owner);\r\n        OwnerAddition(owner);\r\n    }\r\n\r\n    /// @dev Allows to remove an owner. Transaction has to be sent by wallet.\r\n    /// @param owner Address of owner.\r\n    function removeOwner(address owner)\r\n        public\r\n        onlyWallet\r\n        ownerExists(owner)\r\n    {\r\n        isOwner[owner] = false;\r\n        for (uint i=0; i<owners.length - 1; i++)\r\n            if (owners[i] == owner) {\r\n                owners[i] = owners[owners.length - 1];\r\n                break;\r\n            }\r\n        owners.length -= 1;\r\n        if (required > owners.length)\r\n            changeRequirement(owners.length);\r\n        OwnerRemoval(owner);\r\n    }\r\n\r\n    /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\r\n    /// @param owner Address of owner to be replaced.\r\n    /// @param owner Address of new owner.\r\n    function replaceOwner(address owner, address newOwner)\r\n        public\r\n        onlyWallet\r\n        ownerExists(owner)\r\n        ownerDoesNotExist(newOwner)\r\n    {\r\n        for (uint i=0; i<owners.length; i++)\r\n            if (owners[i] == owner) {\r\n                owners[i] = newOwner;\r\n                break;\r\n            }\r\n        isOwner[owner] = false;\r\n        isOwner[newOwner] = true;\r\n        OwnerRemoval(owner);\r\n        OwnerAddition(newOwner);\r\n    }\r\n\r\n    /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\r\n    /// @param _required Number of required confirmations.\r\n    function changeRequirement(uint _required)\r\n        public\r\n        onlyWallet\r\n        validRequirement(owners.length, _required)\r\n    {\r\n        required = _required;\r\n        RequirementChange(_required);\r\n    }\r\n\r\n    /// @dev Allows an owner to submit and confirm a transaction.\r\n    /// @param destination Transaction target address.\r\n    /// @param value Transaction ether value.\r\n    /// @param data Transaction data payload.\r\n    /// @return Returns transaction ID.\r\n    function submitTransaction(address destination, uint value, bytes data)\r\n        public\r\n        returns (uint transactionId)\r\n    {\r\n        transactionId = addTransaction(destination, value, data);\r\n        confirmTransaction(transactionId);\r\n    }\r\n\r\n    /// @dev Allows an owner to confirm a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function confirmTransaction(uint transactionId)\r\n        public\r\n        ownerExists(msg.sender)\r\n        transactionExists(transactionId)\r\n        notConfirmed(transactionId, msg.sender)\r\n    {\r\n        confirmations[transactionId][msg.sender] = true;\r\n        Confirmation(msg.sender, transactionId);\r\n        executeTransaction(transactionId);\r\n    }\r\n\r\n    /// @dev Allows an owner to revoke a confirmation for a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function revokeConfirmation(uint transactionId)\r\n        public\r\n        ownerExists(msg.sender)\r\n        confirmed(transactionId, msg.sender)\r\n        notExecuted(transactionId)\r\n    {\r\n        confirmations[transactionId][msg.sender] = false;\r\n        Revocation(msg.sender, transactionId);\r\n    }\r\n\r\n    /// @dev Allows anyone to execute a confirmed transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function executeTransaction(uint transactionId)\r\n        public\r\n        notExecuted(transactionId)\r\n    {\r\n        if (isConfirmed(transactionId)) {\r\n            Transaction tx = transactions[transactionId];\r\n            tx.executed = true;\r\n            if (tx.destination.call.value(tx.value)(tx.data))\r\n                Execution(transactionId);\r\n            else {\r\n                ExecutionFailure(transactionId);\r\n                tx.executed = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the confirmation status of a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Confirmation status.\r\n    function isConfirmed(uint transactionId)\r\n        public\r\n        constant\r\n        returns (bool)\r\n    {\r\n        uint count = 0;\r\n        for (uint i=0; i<owners.length; i++) {\r\n            if (confirmations[transactionId][owners[i]])\r\n                count += 1;\r\n            if (count == required)\r\n                return true;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Internal functions\r\n     */\r\n    /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\r\n    /// @param destination Transaction target address.\r\n    /// @param value Transaction ether value.\r\n    /// @param data Transaction data payload.\r\n    /// @return Returns transaction ID.\r\n    function addTransaction(address destination, uint value, bytes data)\r\n        internal\r\n        notNull(destination)\r\n        returns (uint transactionId)\r\n    {\r\n        transactionId = transactionCount;\r\n        transactions[transactionId] = Transaction({\r\n            destination: destination,\r\n            value: value,\r\n            data: data,\r\n            executed: false\r\n        });\r\n        transactionCount += 1;\r\n        Submission(transactionId);\r\n    }\r\n\r\n    /*\r\n     * Web3 call functions\r\n     */\r\n    /// @dev Returns number of confirmations of a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Number of confirmations.\r\n    function getConfirmationCount(uint transactionId)\r\n        public\r\n        constant\r\n        returns (uint count)\r\n    {\r\n        for (uint i=0; i<owners.length; i++)\r\n            if (confirmations[transactionId][owners[i]])\r\n                count += 1;\r\n    }\r\n\r\n    /// @dev Returns total number of transactions after filers are applied.\r\n    /// @param pending Include pending transactions.\r\n    /// @param executed Include executed transactions.\r\n    /// @return Total number of transactions after filters are applied.\r\n    function getTransactionCount(bool pending, bool executed)\r\n        public\r\n        constant\r\n        returns (uint count)\r\n    {\r\n        for (uint i=0; i<transactionCount; i++)\r\n            if (   pending && !transactions[i].executed\r\n                || executed && transactions[i].executed)\r\n                count += 1;\r\n    }\r\n\r\n    /// @dev Returns list of owners.\r\n    /// @return List of owner addresses.\r\n    function getOwners()\r\n        public\r\n        constant\r\n        returns (address[])\r\n    {\r\n        return owners;\r\n    }\r\n\r\n    /// @dev Returns array with owner addresses, which confirmed transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Returns array of owner addresses.\r\n    function getConfirmations(uint transactionId)\r\n        public\r\n        constant\r\n        returns (address[] _confirmations)\r\n    {\r\n        address[] memory confirmationsTemp = new address[](owners.length);\r\n        uint count = 0;\r\n        uint i;\r\n        for (i=0; i<owners.length; i++)\r\n            if (confirmations[transactionId][owners[i]]) {\r\n                confirmationsTemp[count] = owners[i];\r\n                count += 1;\r\n            }\r\n        _confirmations = new address[](count);\r\n        for (i=0; i<count; i++)\r\n            _confirmations[i] = confirmationsTemp[i];\r\n    }\r\n\r\n    /// @dev Returns list of transaction IDs in defined range.\r\n    /// @param from Index start position of transaction array.\r\n    /// @param to Index end position of transaction array.\r\n    /// @param pending Include pending transactions.\r\n    /// @param executed Include executed transactions.\r\n    /// @return Returns array of transaction IDs.\r\n    function getTransactionIds(uint from, uint to, bool pending, bool executed)\r\n        public\r\n        constant\r\n        returns (uint[] _transactionIds)\r\n    {\r\n        uint[] memory transactionIdsTemp = new uint[](transactionCount);\r\n        uint count = 0;\r\n        uint i;\r\n        for (i=0; i<transactionCount; i++)\r\n            if (   pending && !transactions[i].executed\r\n                || executed && transactions[i].executed)\r\n            {\r\n                transactionIdsTemp[count] = i;\r\n                count += 1;\r\n            }\r\n        _transactionIds = new uint[](to - from);\r\n        for (i=from; i<to; i++)\r\n            _transactionIds[i - from] = transactionIdsTemp[i];\r\n    }\r\n}\r\n\r\n\r\n////////////////// >>>>> Library Contracts <<<<< ///////////////////\r\n\r\n\r\ncontract SafeMathLib {\r\n  function safeMul(uint a, uint b) constant returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) constant returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) constant returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control \r\n * functions, this simplifies the implementation of \"user permissions\". \r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n  address public newOwner;\r\n  event OwnershipTransferred(address indexed _from, address indexed _to);\r\n  /** \r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner. \r\n   */\r\n  modifier onlyOwner {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to. \r\n   */\r\n  function transferOwnership(address _newOwner) onlyOwner {\r\n    newOwner = _newOwner;\r\n  }\r\n\r\n  function acceptOwnership() {\r\n    require(msg.sender == newOwner);\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n\r\n////////////////// >>>>> Token Contracts <<<<< ///////////////////\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20Basic {\r\n  uint public totalSupply;\r\n  function balanceOf(address _owner) constant returns (uint balance);\r\n  function transfer(address _to, uint _value) returns (bool success);\r\n  event Transfer(address indexed _from, address indexed _to, uint _value);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining);\r\n  function transferFrom(address _from, address _to, uint _value) returns (bool success);\r\n  function approve(address _spender, uint _value) returns (bool success);\r\n  event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\n\r\n\r\n/**\r\n * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation.\r\n *\r\n * Based on code by FirstBlood:\r\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, SafeMathLib {\r\n  /* Token supply got increased and a new owner received these tokens */\r\n  event Minted(address receiver, uint amount);\r\n\r\n  /* Actual balances of token holders */\r\n  mapping(address => uint) balances;\r\n\r\n  /* approve() allowances */\r\n  mapping (address => mapping (address => uint)) allowed;\r\n\r\n  function transfer(address _to, uint _value) returns (bool success) {\r\n    if (balances[msg.sender] >= _value \r\n        && _value > 0 \r\n        && balances[_to] + _value > balances[_to]\r\n        ) {\r\n      balances[msg.sender] = safeSub(balances[msg.sender],_value);\r\n      balances[_to] = safeAdd(balances[_to],_value);\r\n      Transfer(msg.sender, _to, _value);\r\n      return true;\r\n    }\r\n    else{\r\n      return false;\r\n    }\r\n    \r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value) returns (bool success) {\r\n    uint _allowance = allowed[_from][msg.sender];\r\n\r\n    if (balances[_from] >= _value   // From a/c has balance\r\n        && _allowance >= _value    // Transfer approved\r\n        && _value > 0              // Non-zero transfer\r\n        && balances[_to] + _value > balances[_to]  // Overflow check\r\n        ){\r\n    balances[_to] = safeAdd(balances[_to],_value);\r\n    balances[_from] = safeSub(balances[_from],_value);\r\n    allowed[_from][msg.sender] = safeSub(_allowance,_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n        }\r\n    else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function approve(address _spender, uint _value) returns (bool success) {\r\n\r\n    // To change the approve amount you first have to reduce the addresses`\r\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n    //  already 0 to mitigate the race condition described here:\r\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n}\r\n\r\n\r\n    \r\n\r\n/**\r\n * A token that can increase its supply by another contract.\r\n *\r\n * This allows uncapped crowdsale by dynamically increasing the supply when money pours in.\r\n * Only mint agents, contracts whitelisted by owner, can mint new tokens.\r\n *\r\n */\r\ncontract MintableToken is StandardToken, Ownable {\r\n\r\n  bool public mintingFinished = false;\r\n\r\n  /** List of agents that are allowed to create new tokens */\r\n  mapping (address => bool) public mintAgents;\r\n\r\n  event MintingAgentChanged(address addr, bool state  );\r\n\r\n  /**\r\n   * Create new tokens and allocate them to an address..\r\n   *\r\n   * Only callably by a crowdsale contract (mint agent).\r\n   */\r\n  function mint(address receiver, uint amount) onlyMintAgent canMint public {\r\n    totalSupply = safeAdd(totalSupply, amount);\r\n    balances[receiver] = safeAdd(balances[receiver], amount);\r\n    // This will make the mint transaction apper in EtherScan.io\r\n    // We can remove this after there is a standardized minting event\r\n    Transfer(0, receiver, amount);\r\n  }\r\n\r\n  /**\r\n   * Owner can allow a crowdsale contract to mint new tokens.\r\n   */\r\n  function setMintAgent(address addr, bool state) onlyOwner canMint public {\r\n    mintAgents[addr] = state;\r\n    MintingAgentChanged(addr, state);\r\n  }\r\n\r\n  modifier onlyMintAgent() {\r\n    // Only crowdsale contracts are allowed to mint new tokens\r\n    require(mintAgents[msg.sender]);\r\n    _;\r\n  }\r\n\r\n  /** Make sure we are not done yet. */\r\n  modifier canMint() {\r\n    require(!mintingFinished);\r\n    _;\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * Define interface for releasing the token transfer after a successful crowdsale.\r\n */\r\ncontract ReleasableToken is ERC20, Ownable {\r\n\r\n  /* The finalizer contract that allows unlift the transfer limits on this token */\r\n  address public releaseAgent;\r\n\r\n  /** A crowdsale contract can release us to the wild if ICO success. \r\n   * If false we are are in transfer lock up period.\r\n   */\r\n  bool public released = false;\r\n\r\n  /** Map of agents that are allowed to transfer tokens regardless of the lock down period. \r\n   * These are crowdsale contracts and possible the team multisig itself. \r\n   */\r\n  mapping (address => bool) public transferAgents;\r\n\r\n  /**\r\n   * Limit token transfer until the crowdsale is over.\r\n   */\r\n  modifier canTransfer(address _sender) {\r\n\r\n    if (!released) {\r\n        require(transferAgents[_sender]);\r\n    }\r\n\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * Set the contract that can call release and make the token transferable.\r\n   *\r\n   * Design choice. Allow reset the release agent to fix fat finger mistakes.\r\n   */\r\n  function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\r\n\r\n    // We don't do interface check here as we might want to a normal wallet address to act as a release agent\r\n    releaseAgent = addr;\r\n  }\r\n\r\n  /**\r\n   * Owner can allow a particular address (a crowdsale contract) to transfer tokens despite the lock up period.\r\n   */\r\n  function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\r\n    transferAgents[addr] = state;\r\n  }\r\n\r\n  /**\r\n   * One way function to release the tokens to the wild.\r\n   *\r\n   * Can be called only from the release agent that is the final ICO contract. \r\n   * It is only called if the crowdsale has been success (first milestone reached).\r\n   */\r\n  function releaseTokenTransfer() public onlyReleaseAgent {\r\n    released = true;\r\n  }\r\n\r\n  /** The function can be called only before or after the tokens have been releasesd */\r\n  modifier inReleaseState(bool releaseState) {\r\n    require(releaseState == released);\r\n    _;\r\n  }\r\n\r\n  /** The function can be called only by a whitelisted release agent. */\r\n  modifier onlyReleaseAgent() {\r\n    require(msg.sender == releaseAgent);\r\n    _;\r\n  }\r\n\r\n  function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {\r\n    // Call StandardToken.transfer()\r\n   return super.transfer(_to, _value);\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {\r\n    // Call StandardToken.transferForm()\r\n    return super.transferFrom(_from, _to, _value);\r\n  }\r\n\r\n}\r\n\r\n\r\n \r\n\r\n/**\r\n * Upgrade agent interface inspired by Lunyr.\r\n *\r\n * Upgrade agent transfers tokens to a new contract.\r\n * Upgrade agent itself can be the token contract, or just a middle man contract doing the heavy lifting.\r\n */\r\ncontract UpgradeAgent {\r\n  uint public originalSupply;\r\n  /** Interface marker */\r\n  function isUpgradeAgent() public constant returns (bool) {\r\n    return true;\r\n  }\r\n  function upgradeFrom(address _from, uint256 _value) public;\r\n}\r\n\r\n/**\r\n * A token upgrade mechanism where users can opt-in amount of tokens to the next smart contract revision.\r\n *\r\n * First envisioned by Golem and Lunyr projects.\r\n */\r\ncontract UpgradeableToken is StandardToken {\r\n\r\n  /** Contract / person who can set the upgrade path. \r\n   * This can be the same as team multisig wallet, as what it is with its default value. \r\n   */\r\n  address public upgradeMaster;\r\n\r\n  /** The next contract where the tokens will be migrated. */\r\n  UpgradeAgent public upgradeAgent;\r\n\r\n  /** How many tokens we have upgraded by now. */\r\n  uint256 public totalUpgraded;\r\n\r\n  /**\r\n   * Upgrade states.\r\n   *\r\n   * - NotAllowed: The child contract has not reached a condition where the upgrade can bgun\r\n   * - WaitingForAgent: Token allows upgrade, but we don't have a new agent yet\r\n   * - ReadyToUpgrade: The agent is set, but not a single token has been upgraded yet\r\n   * - Upgrading: Upgrade agent is set and the balance holders can upgrade their tokens\r\n   *\r\n   */\r\n  enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\r\n\r\n  /**\r\n   * Somebody has upgraded some of their tokens.\r\n   */\r\n  event Upgrade(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n  /**\r\n   * New upgrade agent available.\r\n   */\r\n  event UpgradeAgentSet(address agent);\r\n\r\n  /**\r\n   * Do not allow construction without upgrade master set.\r\n   */\r\n  function UpgradeableToken(address _upgradeMaster) {\r\n    upgradeMaster = _upgradeMaster;\r\n  }\r\n\r\n  /**\r\n   * Allow the token holder to upgrade some of their tokens to a new contract.\r\n   */\r\n  function upgrade(uint256 value) public {\r\n    UpgradeState state = getUpgradeState();\r\n    require((state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading));\r\n    // Validate input value.\r\n    require(value!=0);\r\n\r\n    balances[msg.sender] = safeSub(balances[msg.sender],value);\r\n\r\n    // Take tokens out from circulation\r\n    totalSupply = safeSub(totalSupply,value);\r\n    totalUpgraded = safeAdd(totalUpgraded,value);\r\n\r\n    // Upgrade agent reissues the tokens\r\n    upgradeAgent.upgradeFrom(msg.sender, value);\r\n    Upgrade(msg.sender, upgradeAgent, value);\r\n  }\r\n\r\n  /**\r\n   * Set an upgrade agent that handles\r\n   */\r\n  function setUpgradeAgent(address agent) external {\r\n    require(canUpgrade());\r\n    require(agent != 0x0);\r\n    // Only a master can designate the next agent\r\n    require(msg.sender == upgradeMaster);\r\n    // Upgrade has already begun for an agent\r\n    require(getUpgradeState() != UpgradeState.Upgrading);\r\n\r\n    upgradeAgent = UpgradeAgent(agent);\r\n\r\n    // Bad interface\r\n    require(upgradeAgent.isUpgradeAgent());\r\n    // Make sure that token supplies match in source and target\r\n    require(upgradeAgent.originalSupply() == totalSupply);\r\n\r\n    UpgradeAgentSet(upgradeAgent);\r\n  }\r\n\r\n  /**\r\n   * Get the state of the token upgrade.\r\n   */\r\n  function getUpgradeState() public constant returns(UpgradeState) {\r\n    if (!canUpgrade()) return UpgradeState.NotAllowed;\r\n    else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;\r\n    else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;\r\n    else return UpgradeState.Upgrading;\r\n  }\r\n\r\n  /**\r\n   * Change the upgrade master.\r\n   *\r\n   * This allows us to set a new owner for the upgrade mechanism.\r\n   */\r\n  function setUpgradeMaster(address master) public {\r\n    require(master != 0x0);\r\n    require(msg.sender == upgradeMaster);\r\n    upgradeMaster = master;\r\n  }\r\n\r\n  /**\r\n   * Child contract can enable to provide the condition when the upgrade can begun.\r\n   */\r\n  function canUpgrade() public constant returns(bool) {\r\n     return true;\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * A crowdsale token.\r\n *\r\n * An ERC-20 token designed specifically for crowdsales with investor protection and \r\n * further development path.\r\n *\r\n * - The token transfer() is disabled until the crowdsale is over\r\n * - The token contract gives an opt-in upgrade path to a new contract\r\n * - The same token can be part of several crowdsales through approve() mechanism\r\n * - The token can be capped (supply set in the constructor) \r\n *   or uncapped (crowdsale contract can mint new tokens)\r\n */\r\ncontract DayToken is  ReleasableToken, MintableToken, UpgradeableToken {\r\n\r\n    enum sellingStatus {NOTONSALE, EXPIRED, ONSALE}\r\n\r\n    /** Basic structure for a contributor with a minting Address\r\n     * adr address of the contributor\r\n     * initialContributionDay initial contribution of the contributor in wei\r\n     * lastUpdatedOn day count from Minting Epoch when the account balance was last updated\r\n     * mintingPower Initial Minting power of the address\r\n     * expiryBlockNumber Variable to mark end of Minting address sale. Set by user\r\n     * minPriceInDay minimum price of Minting address in Day tokens. Set by user\r\n     * status Selling status Variable for transfer Minting address.\r\n     * sellingPriceInDay Variable for transfer Minting address. Price at which the address is actually sold\r\n     */ \r\n    struct Contributor {\r\n        address adr;\r\n        uint256 initialContributionDay;\r\n        uint256 lastUpdatedOn; //Day from Minting Epoch\r\n        uint256 mintingPower;\r\n        uint expiryBlockNumber;\r\n        uint256 minPriceInDay;\r\n        sellingStatus status;\r\n    }\r\n\r\n    /* Stores maximum days for which minting will happen since minting epoch */\r\n    uint256 public maxMintingDays = 1095;\r\n\r\n    /* Mapping to store id of each minting address */\r\n    mapping (address => uint) public idOf;\r\n    /* Mapping from id of each minting address to their respective structures */\r\n    mapping (uint256 => Contributor) public contributors;\r\n    /* mapping to store unix timestamp of when the minting address is issued to each team member */\r\n    mapping (address => uint256) public teamIssuedTimestamp;\r\n    mapping (address => bool) public soldAddresses;\r\n    mapping (address => uint256) public sellingPriceInDayOf;\r\n\r\n    /* Stores the id of the first  contributor */\r\n    uint256 public firstContributorId;\r\n    /* Stores total Pre + Post ICO TimeMints */\r\n    uint256 public totalNormalContributorIds;\r\n    /* Stores total Normal TimeMints allocated */\r\n    uint256 public totalNormalContributorIdsAllocated = 0;\r\n    \r\n    /* Stores the id of the first team TimeMint */\r\n    uint256 public firstTeamContributorId;\r\n    /* Stores the total team TimeMints */\r\n    uint256 public totalTeamContributorIds;\r\n    /* Stores total team TimeMints allocated */\r\n    uint256 public totalTeamContributorIdsAllocated = 0;\r\n\r\n    /* Stores the id of the first Post ICO contributor (for auctionable TimeMints) */\r\n    uint256 public firstPostIcoContributorId;\r\n    /* Stores total Post ICO TimeMints (for auction) */\r\n    uint256 public totalPostIcoContributorIds;\r\n    /* Stores total Auction TimeMints allocated */\r\n    uint256 public totalPostIcoContributorIdsAllocated = 0;\r\n\r\n    /* Maximum number of address */\r\n    uint256 public maxAddresses;\r\n\r\n    /* Min Minting power with 19 decimals: 0.5% : 5000000000000000000 */\r\n    uint256 public minMintingPower;\r\n    /* Max Minting power with 19 decimals: 1% : 10000000000000000000 */\r\n    uint256 public maxMintingPower;\r\n    /* Halving cycle in days (88) */\r\n    uint256 public halvingCycle; \r\n    /* Unix timestamp when minting is to be started */\r\n    uint256 public initialBlockTimestamp;\r\n    /* Flag to prevent setting initialBlockTimestamp more than once */\r\n    bool public isInitialBlockTimestampSet;\r\n    /* number of decimals in minting power */\r\n    uint256 public mintingDec; \r\n\r\n    /* Minimum Balance in Day tokens required to sell a minting address */\r\n    uint256 public minBalanceToSell;\r\n    /* Team address lock down period from issued time, in seconds */\r\n    uint256 public teamLockPeriodInSec;  //Initialize and set function\r\n    /* Duration in secs that we consider as a day. (For test deployment purposes, \r\n       if we want to decrease length of a day. default: 84600)*/\r\n    uint256 public DayInSecs;\r\n\r\n    event UpdatedTokenInformation(string newName, string newSymbol); \r\n    event MintingAdrTransferred(uint id, address from, address to);\r\n    event ContributorAdded(address adr, uint id);\r\n    event TimeMintOnSale(uint id, address seller, uint minPriceInDay, uint expiryBlockNumber);\r\n    event TimeMintSold(uint id, address buyer, uint offerInDay);\r\n    event PostInvested(address investor, uint weiAmount, uint tokenAmount, uint customerId, uint contributorId);\r\n    \r\n    event TeamAddressAdded(address teamAddress, uint id);\r\n    // Tell us invest was success\r\n    event Invested(address receiver, uint weiAmount, uint tokenAmount, uint customerId, uint contributorId);\r\n\r\n    modifier onlyContributor(uint id){\r\n        require(isValidContributorId(id));\r\n        _;\r\n    }\r\n\r\n    string public name; \r\n\r\n    string public symbol; \r\n\r\n    uint8 public decimals; \r\n\r\n    /**\r\n        * Construct the token.\r\n        *\r\n        * This token must be created through a team multisig wallet, so that it is owned by that wallet.\r\n        *\r\n        * @param _name Token name\r\n        * @param _symbol Token symbol - should be all caps\r\n        * @param _initialSupply How many tokens we start with\r\n        * @param _decimals Number of decimal places\r\n        * _mintable Are new tokens created over the crowdsale or do we distribute only the initial supply?\r\n        */\r\n    function DayToken(string _name, string _symbol, uint _initialSupply, uint8 _decimals, \r\n        bool _mintable, uint _maxAddresses, uint _firstTeamContributorId, uint _totalTeamContributorIds, \r\n        uint _totalPostIcoContributorIds, uint256 _minMintingPower, uint256 _maxMintingPower, uint _halvingCycle, \r\n        uint256 _minBalanceToSell, uint256 _dayInSecs, uint256 _teamLockPeriodInSec) \r\n        UpgradeableToken(msg.sender) {\r\n        \r\n        // Create any address, can be transferred\r\n        // to team multisig via changeOwner(),\r\n        // also remember to call setUpgradeMaster()\r\n        owner = msg.sender; \r\n        name = _name; \r\n        symbol = _symbol;  \r\n        totalSupply = _initialSupply; \r\n        decimals = _decimals; \r\n        // Create initially all balance on the team multisig\r\n        balances[owner] = totalSupply; \r\n        maxAddresses = _maxAddresses;\r\n        require(maxAddresses > 1); // else division by zero will occur in setInitialMintingPowerOf\r\n        \r\n        firstContributorId = 1;\r\n        totalNormalContributorIds = maxAddresses - _totalTeamContributorIds - _totalPostIcoContributorIds;\r\n\r\n        // check timeMint total is sane\r\n        require(totalNormalContributorIds >= 1);\r\n\r\n        firstTeamContributorId = _firstTeamContributorId;\r\n        totalTeamContributorIds = _totalTeamContributorIds;\r\n        totalPostIcoContributorIds = _totalPostIcoContributorIds;\r\n        \r\n        // calculate first contributor id to be auctioned post ICO\r\n        firstPostIcoContributorId = maxAddresses - totalPostIcoContributorIds + 1;\r\n        minMintingPower = _minMintingPower;\r\n        maxMintingPower = _maxMintingPower;\r\n        halvingCycle = _halvingCycle;\r\n        // setting future date far far away, year 2020, \r\n        // call setInitialBlockTimestamp to set proper timestamp\r\n        initialBlockTimestamp = 1577836800;\r\n        isInitialBlockTimestampSet = false;\r\n        // use setMintingDec to change this\r\n        mintingDec = 19;\r\n        minBalanceToSell = _minBalanceToSell;\r\n        DayInSecs = _dayInSecs;\r\n        teamLockPeriodInSec = _teamLockPeriodInSec;\r\n        \r\n        if (totalSupply > 0) {\r\n            Minted(owner, totalSupply); \r\n        }\r\n\r\n        if (!_mintable) {\r\n            mintingFinished = true; \r\n            require(totalSupply != 0); \r\n        }\r\n    }\r\n\r\n    /**\r\n    * Used to set timestamp at which minting power of TimeMints is activated\r\n    * Can be called only by owner\r\n    * @param _initialBlockTimestamp timestamp to be set.\r\n    */\r\n    function setInitialBlockTimestamp(uint _initialBlockTimestamp) internal onlyOwner {\r\n        require(!isInitialBlockTimestampSet);\r\n        isInitialBlockTimestampSet = true;\r\n        initialBlockTimestamp = _initialBlockTimestamp;\r\n    }\r\n\r\n    /**\r\n    * check if mintining power is activated and Day token and Timemint transfer is enabled\r\n    */\r\n    function isDayTokenActivated() constant returns (bool isActivated) {\r\n        return (block.timestamp >= initialBlockTimestamp);\r\n    }\r\n\r\n\r\n    /**\r\n    * to check if an id is a valid contributor\r\n    * @param _id contributor id to check.\r\n    */\r\n    function isValidContributorId(uint _id) constant returns (bool isValidContributor) {\r\n        return (_id > 0 && _id <= maxAddresses && contributors[_id].adr != 0 \r\n            && idOf[contributors[_id].adr] == _id); // cross checking\r\n    }\r\n\r\n    /**\r\n    * to check if an address is a valid contributor\r\n    * @param _address  contributor address to check.\r\n    */\r\n    function isValidContributorAddress(address _address) constant returns (bool isValidContributor) {\r\n        return isValidContributorId(idOf[_address]);\r\n    }\r\n\r\n\r\n    /**\r\n    * In case of Team address check if lock-in period is over (returns true for all non team addresses)\r\n    * @param _address team address to check lock in period for.\r\n    */\r\n    function isTeamLockInPeriodOverIfTeamAddress(address _address) constant returns (bool isLockInPeriodOver) {\r\n        isLockInPeriodOver = true;\r\n        if (teamIssuedTimestamp[_address] != 0) {\r\n                if (block.timestamp - teamIssuedTimestamp[_address] < teamLockPeriodInSec)\r\n                    isLockInPeriodOver = false;\r\n        }\r\n\r\n        return isLockInPeriodOver;\r\n    }\r\n\r\n    /**\r\n    * Used to set mintingDec\r\n    * Can be called only by owner\r\n    * @param _mintingDec bounty to be set.\r\n    */\r\n    function setMintingDec(uint256 _mintingDec) onlyOwner {\r\n        require(!isInitialBlockTimestampSet);\r\n        mintingDec = _mintingDec;\r\n    }\r\n\r\n    /**\r\n        * When token is released to be transferable, enforce no new tokens can be created.\r\n        */\r\n    function releaseTokenTransfer() public onlyOwner {\r\n        require(isInitialBlockTimestampSet);\r\n        mintingFinished = true; \r\n        super.releaseTokenTransfer(); \r\n    }\r\n\r\n    /**\r\n        * Allow upgrade agent functionality kick in only if the crowdsale was success.\r\n        */\r\n    function canUpgrade() public constant returns(bool) {\r\n        return released && super.canUpgrade(); \r\n    }\r\n\r\n    /**\r\n        * Owner can update token information here\r\n        */\r\n    function setTokenInformation(string _name, string _symbol) onlyOwner {\r\n        name = _name; \r\n        symbol = _symbol; \r\n        UpdatedTokenInformation(name, symbol); \r\n    }\r\n\r\n    /**\r\n        * Returns the current phase.  \r\n        * Note: Phase starts with 1\r\n        * @param _day Number of days since Minting Epoch\r\n        */\r\n    function getPhaseCount(uint _day) public constant returns (uint phase) {\r\n        phase = (_day/halvingCycle) + 1; \r\n        return (phase); \r\n    }\r\n    /**\r\n        * Returns current day number since minting epoch \r\n        * or zero if initialBlockTimestamp is in future or its DayZero.\r\n        */\r\n    function getDayCount() public constant returns (uint daySinceMintingEpoch) {\r\n        daySinceMintingEpoch = 0;\r\n        if (isDayTokenActivated())\r\n            daySinceMintingEpoch = (block.timestamp - initialBlockTimestamp)/DayInSecs; \r\n\r\n        return daySinceMintingEpoch; \r\n    }\r\n    /**\r\n        * Calculates and Sets the minting power of a particular id.\r\n        * Called before Minting Epoch by constructor\r\n        * @param _id id of the address whose minting power is to be set.\r\n        */\r\n    function setInitialMintingPowerOf(uint256 _id) internal onlyContributor(_id) {\r\n        contributors[_id].mintingPower = \r\n            (maxMintingPower - ((_id-1) * (maxMintingPower - minMintingPower)/(maxAddresses-1))); \r\n    }\r\n\r\n    /**\r\n        * Returns minting power of a particular id.\r\n        * @param _id Contribution id whose minting power is to be returned\r\n        */\r\n    function getMintingPowerById(uint _id) public constant returns (uint256 mintingPower) {\r\n        return contributors[_id].mintingPower/(2**(getPhaseCount(getDayCount())-1)); \r\n    }\r\n\r\n    /**\r\n        * Returns minting power of a particular address.\r\n        * @param _adr Address whose minting power is to be returned\r\n        */\r\n    function getMintingPowerByAddress(address _adr) public constant returns (uint256 mintingPower) {\r\n        return getMintingPowerById(idOf[_adr]);\r\n    }\r\n\r\n\r\n    /**\r\n        * Calculates and returns the balance based on the minting power, day and phase.\r\n        * Can only be called internally\r\n        * Can calculate balance based on last updated.\r\n        * @param _id id whose balnce is to be calculated\r\n        * @param _dayCount day count upto which balance is to be updated\r\n        */\r\n    function availableBalanceOf(uint256 _id, uint _dayCount) internal returns (uint256) {\r\n        uint256 balance = balances[contributors[_id].adr]; \r\n        uint maxUpdateDays = _dayCount < maxMintingDays ? _dayCount : maxMintingDays;\r\n        uint i = contributors[_id].lastUpdatedOn + 1;\r\n        while(i <= maxUpdateDays) {\r\n             uint phase = getPhaseCount(i);\r\n             uint phaseEndDay = phase * halvingCycle - 1; // as first day is 0\r\n             uint constantFactor = contributors[_id].mintingPower / 2**(phase-1);\r\n\r\n            for (uint j = i; j <= phaseEndDay && j <= maxUpdateDays; j++) {\r\n                balance = safeAdd( balance, constantFactor * balance / 10**(mintingDec + 2) );\r\n            }\r\n\r\n            i = j;\r\n            \r\n        } \r\n        return balance; \r\n    }\r\n\r\n    /**\r\n        * Updates the balance of the specified id in its structure and also in the balances[] mapping.\r\n        * returns true if successful.\r\n        * Only for internal calls. Not public.\r\n        * @param _id id whose balance is to be updated.\r\n        */\r\n    function updateBalanceOf(uint256 _id) internal returns (bool success) {\r\n        // check if its contributor\r\n        if (isValidContributorId(_id)) {\r\n            uint dayCount = getDayCount();\r\n            // proceed only if not already updated today\r\n            if (contributors[_id].lastUpdatedOn != dayCount && contributors[_id].lastUpdatedOn < maxMintingDays) {\r\n                address adr = contributors[_id].adr;\r\n                uint oldBalance = balances[adr];\r\n                totalSupply = safeSub(totalSupply, oldBalance);\r\n                uint newBalance = availableBalanceOf(_id, dayCount);\r\n                balances[adr] = newBalance;\r\n                totalSupply = safeAdd(totalSupply, newBalance);\r\n                contributors[_id].lastUpdatedOn = dayCount;\r\n                Transfer(0, adr, newBalance - oldBalance);\r\n                return true; \r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    /**\r\n        * Standard ERC20 function overridden.\r\n        * Returns the balance of the specified address.\r\n        * Calculates the balance on fly only if it is a minting address else \r\n        * simply returns balance from balances[] mapping.\r\n        * For public calls.\r\n        * @param _adr address whose balance is to be returned.\r\n        */\r\n    function balanceOf(address _adr) constant returns (uint balance) {\r\n        uint id = idOf[_adr];\r\n        if (id != 0)\r\n            return balanceById(id);\r\n        else \r\n            return balances[_adr]; \r\n    }\r\n\r\n\r\n    /**\r\n        * Standard ERC20 function overridden.\r\n        * Returns the balance of the specified id.\r\n        * Calculates the balance on fly only if it is a minting address else \r\n        * simply returns balance from balances[] mapping.\r\n        * For public calls.\r\n        * @param _id address whose balance is to be returned.\r\n        */\r\n    function balanceById(uint _id) public constant returns (uint256 balance) {\r\n        address adr = contributors[_id].adr; \r\n        if (isDayTokenActivated()) {\r\n            if (isValidContributorId(_id)) {\r\n                return ( availableBalanceOf(_id, getDayCount()) );\r\n            }\r\n        }\r\n        return balances[adr]; \r\n    }\r\n\r\n    /**\r\n        * Returns totalSupply of DAY tokens.\r\n        */\r\n    function getTotalSupply() public constant returns (uint) {\r\n        return totalSupply;\r\n    }\r\n\r\n    /** Function to update balance of a Timemint\r\n        * returns true if balance updated, false otherwise\r\n        * @param _id TimeMint to update\r\n        */\r\n    function updateTimeMintBalance(uint _id) public returns (bool) {\r\n        require(isDayTokenActivated());\r\n        return updateBalanceOf(_id);\r\n    }\r\n\r\n    /** Function to update balance of sender's Timemint\r\n        * returns true if balance updated, false otherwise\r\n        */\r\n    function updateMyTimeMintBalance() public returns (bool) {\r\n        require(isDayTokenActivated());\r\n        return updateBalanceOf(idOf[msg.sender]);\r\n    }\r\n\r\n    /**\r\n        * Standard ERC20 function overidden.\r\n        * Used to transfer day tokens from caller's address to another\r\n        * @param _to address to which Day tokens are to be transferred\r\n        * @param _value Number of Day tokens to be transferred\r\n        */\r\n    function transfer(address _to, uint _value) public returns (bool success) {\r\n        require(isDayTokenActivated());\r\n        // if Team address, check if lock-in period is over\r\n        require(isTeamLockInPeriodOverIfTeamAddress(msg.sender));\r\n\r\n        updateBalanceOf(idOf[msg.sender]);\r\n\r\n        // Check sender account has enough balance and transfer amount is non zero\r\n        require ( balanceOf(msg.sender) >= _value && _value != 0 ); \r\n        \r\n        updateBalanceOf(idOf[_to]);\r\n\r\n        balances[msg.sender] = safeSub(balances[msg.sender], _value); \r\n        balances[_to] = safeAdd(balances[_to], _value); \r\n        Transfer(msg.sender, _to, _value);\r\n\r\n        return true;\r\n    }\r\n    \r\n\r\n    /**\r\n        * Standard ERC20 Standard Token function overridden. Added Team address vesting period lock. \r\n        */\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\r\n        require(isDayTokenActivated());\r\n\r\n        // if Team address, check if lock-in period is over\r\n        require(isTeamLockInPeriodOverIfTeamAddress(_from));\r\n\r\n        uint _allowance = allowed[_from][msg.sender];\r\n\r\n        updateBalanceOf(idOf[_from]);\r\n\r\n        // Check from account has enough balance, transfer amount is non zero \r\n        // and _value is allowed to be transferred\r\n        require ( balanceOf(_from) >= _value && _value != 0  &&  _value <= _allowance); \r\n\r\n        updateBalanceOf(idOf[_to]);\r\n\r\n        allowed[_from][msg.sender] = safeSub(_allowance, _value);\r\n        balances[_from] = safeSub(balances[_from], _value);\r\n        balances[_to] = safeAdd(balances[_to], _value);\r\n    \r\n        Transfer(_from, _to, _value);\r\n        \r\n        return true;\r\n    }\r\n\r\n\r\n    /** \r\n        * Add any contributor structure (For every kind of contributors: Team/Pre-ICO/ICO/Test)\r\n        * @param _adr Address of the contributor to be added  \r\n        * @param _initialContributionDay Initial Contribution of the contributor to be added\r\n        */\r\n  function addContributor(uint contributorId, address _adr, uint _initialContributionDay) internal onlyOwner {\r\n        require(contributorId <= maxAddresses);\r\n        //address should not be an existing contributor\r\n        require(!isValidContributorAddress(_adr));\r\n        //TimeMint should not be already allocated\r\n        require(!isValidContributorId(contributorId));\r\n        contributors[contributorId].adr = _adr;\r\n        idOf[_adr] = contributorId;\r\n        setInitialMintingPowerOf(contributorId);\r\n        contributors[contributorId].initialContributionDay = _initialContributionDay;\r\n        contributors[contributorId].lastUpdatedOn = getDayCount();\r\n        ContributorAdded(_adr, contributorId);\r\n        contributors[contributorId].status = sellingStatus.NOTONSALE;\r\n    }\r\n\r\n\r\n    /** Function to be called by minting addresses in order to sell their address\r\n        * @param _minPriceInDay Minimum price in DAY tokens set by the seller\r\n        * @param _expiryBlockNumber Expiry Block Number set by the seller\r\n        */\r\n    function sellMintingAddress(uint256 _minPriceInDay, uint _expiryBlockNumber) public returns (bool) {\r\n        require(isDayTokenActivated());\r\n        require(_expiryBlockNumber > block.number);\r\n\r\n        // if Team address, check if lock-in period is over\r\n        require(isTeamLockInPeriodOverIfTeamAddress(msg.sender));\r\n\r\n        uint id = idOf[msg.sender];\r\n        require(contributors[id].status == sellingStatus.NOTONSALE);\r\n\r\n        // update balance of sender address before checking for minimum required balance\r\n        updateBalanceOf(id);\r\n        require(balances[msg.sender] >= minBalanceToSell);\r\n        contributors[id].minPriceInDay = _minPriceInDay;\r\n        contributors[id].expiryBlockNumber = _expiryBlockNumber;\r\n        contributors[id].status = sellingStatus.ONSALE;\r\n        balances[msg.sender] = safeSub(balances[msg.sender], minBalanceToSell);\r\n        balances[this] = safeAdd(balances[this], minBalanceToSell);\r\n        Transfer(msg.sender, this, minBalanceToSell);\r\n        TimeMintOnSale(id, msg.sender, contributors[id].minPriceInDay, contributors[id].expiryBlockNumber);\r\n        return true;\r\n    }\r\n\r\n\r\n    /** Function to be called by minting address in order to cancel the sale of their TimeMint\r\n        */\r\n    function cancelSaleOfMintingAddress() onlyContributor(idOf[msg.sender]) public {\r\n        uint id = idOf[msg.sender];\r\n        // TimeMint should be on sale\r\n        require(contributors[id].status == sellingStatus.ONSALE);\r\n        contributors[id].status = sellingStatus.EXPIRED;\r\n    }\r\n\r\n\r\n    /** Function to be called by any user to get a list of all On Sale TimeMints\r\n        */\r\n    function getOnSaleIds() constant public returns(uint[]) {\r\n        uint[] memory idsOnSale = new uint[](maxAddresses);\r\n        uint j = 0;\r\n        for(uint i=1; i <= maxAddresses; i++) {\r\n\r\n            if ( isValidContributorId(i) &&\r\n                block.number <= contributors[i].expiryBlockNumber && \r\n                contributors[i].status == sellingStatus.ONSALE ) {\r\n                    idsOnSale[j] = i;\r\n                    j++;     \r\n            }\r\n            \r\n        }\r\n        return idsOnSale;\r\n    }\r\n\r\n\r\n    /** Function to be called by any user to get status of a Time Mint.\r\n        * returns status 0 - Not on sale, 1 - Expired, 2 - On sale,\r\n        * @param _id ID number of the Time Mint \r\n        */\r\n    function getSellingStatus(uint _id) constant public returns(sellingStatus status) {\r\n        require(isValidContributorId(_id));\r\n        status = contributors[_id].status;\r\n        if ( block.number > contributors[_id].expiryBlockNumber && \r\n                status == sellingStatus.ONSALE )\r\n            status = sellingStatus.EXPIRED;\r\n\r\n        return status;\r\n    }\r\n\r\n    /** Function to be called by any user to buy a onsale address by offering an amount\r\n        * @param _offerId ID number of the address to be bought by the buyer\r\n        * @param _offerInDay Offer given by the buyer in number of DAY tokens\r\n        */\r\n    function buyMintingAddress(uint _offerId, uint256 _offerInDay) public returns(bool) {\r\n        if (contributors[_offerId].status == sellingStatus.ONSALE \r\n            && block.number > contributors[_offerId].expiryBlockNumber)\r\n        {\r\n            contributors[_offerId].status = sellingStatus.EXPIRED;\r\n        }\r\n        address soldAddress = contributors[_offerId].adr;\r\n        require(contributors[_offerId].status == sellingStatus.ONSALE);\r\n        require(_offerInDay >= contributors[_offerId].minPriceInDay);\r\n\r\n        // prevent seller from cancelling sale in between\r\n        contributors[_offerId].status = sellingStatus.NOTONSALE;\r\n\r\n        // first get the offered DayToken in the token contract & \r\n        // then transfer the total sum (minBalanceToSend+_offerInDay) to the seller\r\n        balances[msg.sender] = safeSub(balances[msg.sender], _offerInDay);\r\n        balances[this] = safeAdd(balances[this], _offerInDay);\r\n        Transfer(msg.sender, this, _offerInDay);\r\n        if(transferMintingAddress(contributors[_offerId].adr, msg.sender)) {\r\n            //mark the offer as sold & let seller pull the proceed to their own account.\r\n            sellingPriceInDayOf[soldAddress] = _offerInDay;\r\n            soldAddresses[soldAddress] = true; \r\n            TimeMintSold(_offerId, msg.sender, _offerInDay);  \r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n        * Transfer minting address from one user to another\r\n        * Gives the transfer-to address, the id of the original address\r\n        * returns true if successful and false if not.\r\n        * @param _to address of the user to which minting address is to be tranferred\r\n        */\r\n    function transferMintingAddress(address _from, address _to) internal onlyContributor(idOf[_from]) returns (bool) {\r\n        require(isDayTokenActivated());\r\n\r\n        // _to should be non minting address\r\n        require(!isValidContributorAddress(_to));\r\n        \r\n        uint id = idOf[_from];\r\n        // update balance of from address before transferring minting power\r\n        updateBalanceOf(id);\r\n\r\n        contributors[id].adr = _to;\r\n        idOf[_to] = id;\r\n        idOf[_from] = 0;\r\n        contributors[id].initialContributionDay = 0;\r\n        // needed as id is assigned to new address\r\n        contributors[id].lastUpdatedOn = getDayCount();\r\n        contributors[id].expiryBlockNumber = 0;\r\n        contributors[id].minPriceInDay = 0;\r\n        MintingAdrTransferred(id, _from, _to);\r\n        return true;\r\n    }\r\n\r\n\r\n    /** Function to allow seller to get back their deposited amount of day tokens(minBalanceToSell) and \r\n        * offer made by buyer after successful sale.\r\n        * Throws if sale is not successful\r\n        */\r\n    function fetchSuccessfulSaleProceed() public  returns(bool) {\r\n        require(soldAddresses[msg.sender] == true);\r\n        // to prevent re-entrancy attack\r\n        soldAddresses[msg.sender] = false;\r\n        uint saleProceed = safeAdd(minBalanceToSell, sellingPriceInDayOf[msg.sender]);\r\n        balances[this] = safeSub(balances[this], saleProceed);\r\n        balances[msg.sender] = safeAdd(balances[msg.sender], saleProceed);\r\n        Transfer(this, msg.sender, saleProceed);\r\n        return true;\r\n                \r\n    }\r\n\r\n    /** Function that lets a seller get their deposited day tokens (minBalanceToSell) back, if no buyer turns up.\r\n        * Allowed only after expiryBlockNumber\r\n        * Throws if any other state other than EXPIRED\r\n        */\r\n    function refundFailedAuctionAmount() onlyContributor(idOf[msg.sender]) public returns(bool){\r\n        uint id = idOf[msg.sender];\r\n        if(block.number > contributors[id].expiryBlockNumber && contributors[id].status == sellingStatus.ONSALE)\r\n        {\r\n            contributors[id].status = sellingStatus.EXPIRED;\r\n        }\r\n        require(contributors[id].status == sellingStatus.EXPIRED);\r\n        // reset selling status\r\n        contributors[id].status = sellingStatus.NOTONSALE;\r\n        balances[this] = safeSub(balances[this], minBalanceToSell);\r\n        // update balance of seller address before refunding\r\n        updateBalanceOf(id);\r\n        balances[msg.sender] = safeAdd(balances[msg.sender], minBalanceToSell);\r\n        contributors[id].minPriceInDay = 0;\r\n        contributors[id].expiryBlockNumber = 0;\r\n        Transfer(this, msg.sender, minBalanceToSell);\r\n        return true;\r\n    }\r\n\r\n\r\n    /** Function to add a team address as a contributor and store it's time issued to calculate vesting period\r\n        * Called by owner\r\n        */\r\n    function addTeamTimeMints(address _adr, uint _id, uint _tokens, bool _isTest) public onlyOwner {\r\n        //check if Id is in range of team Ids\r\n        require(_id >= firstTeamContributorId && _id < firstTeamContributorId + totalTeamContributorIds);\r\n        require(totalTeamContributorIdsAllocated < totalTeamContributorIds);\r\n        addContributor(_id, _adr, 0);\r\n        totalTeamContributorIdsAllocated++;\r\n        // enforce lockin period if not test address\r\n        if(!_isTest) teamIssuedTimestamp[_adr] = block.timestamp;\r\n        mint(_adr, _tokens);\r\n        TeamAddressAdded(_adr, _id);\r\n    }\r\n\r\n\r\n    /** Function to add reserved aution TimeMints post-ICO. Only by owner\r\n        * @param _receiver Address of the minting to be added\r\n        * @param _customerId Server side id of the customer\r\n        * @param _id contributorId\r\n        */\r\n    function postAllocateAuctionTimeMints(address _receiver, uint _customerId, uint _id) public onlyOwner {\r\n\r\n        //check if Id is in range of Auction Ids\r\n        require(_id >= firstPostIcoContributorId && _id < firstPostIcoContributorId + totalPostIcoContributorIds);\r\n        require(totalPostIcoContributorIdsAllocated < totalPostIcoContributorIds);\r\n        \r\n        require(released == true);\r\n        addContributor(_id, _receiver, 0);\r\n        totalPostIcoContributorIdsAllocated++;\r\n        PostInvested(_receiver, 0, 0, _customerId, _id);\r\n    }\r\n\r\n\r\n    /** Function to add all contributors except team, test and Auctions TimeMints. Only by owner\r\n        * @param _receiver Address of the minting to be added\r\n        * @param _customerId Server side id of the customer\r\n        * @param _id contributor id\r\n        * @param _tokens day tokens to allocate\r\n        * @param _weiAmount ether invested in wei\r\n        */\r\n    function allocateNormalTimeMints(address _receiver, uint _customerId, uint _id, uint _tokens, uint _weiAmount) public onlyOwner {\r\n        // check if Id is in range of Normal Ids\r\n        require(_id >= firstContributorId && _id <= totalNormalContributorIds);\r\n        require(totalNormalContributorIdsAllocated < totalNormalContributorIds);\r\n        addContributor(_id, _receiver, _tokens);\r\n        totalNormalContributorIdsAllocated++;\r\n        mint(_receiver, _tokens);\r\n        Invested(_receiver, _weiAmount, _tokens, _customerId, _id);\r\n        \r\n    }\r\n\r\n\r\n    /** Function to release token\r\n        * Called by owner\r\n        */\r\n    function releaseToken(uint _initialBlockTimestamp) public onlyOwner {\r\n        require(!released); // check not already released\r\n        \r\n        setInitialBlockTimestamp(_initialBlockTimestamp);\r\n\r\n        // Make token transferable\r\n        releaseTokenTransfer();\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setTransferAgent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalNormalContributorIdsAllocated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintingFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_customerId\",\"type\":\"uint256\"},{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_tokens\",\"type\":\"uint256\"},{\"name\":\"_weiAmount\",\"type\":\"uint256\"}],\"name\":\"allocateNormalTimeMints\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamLockPeriodInSec\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isDayTokenActivated\",\"outputs\":[{\"name\":\"isActivated\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstTeamContributorId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalPostIcoContributorIdsAllocated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setReleaseAgent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"fetchSuccessfulSaleProceed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_adr\",\"type\":\"address\"},{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_tokens\",\"type\":\"uint256\"},{\"name\":\"_isTest\",\"type\":\"bool\"}],\"name\":\"addTeamTimeMints\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getMintingPowerById\",\"outputs\":[{\"name\":\"mintingPower\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_day\",\"type\":\"uint256\"}],\"name\":\"getPhaseCount\",\"outputs\":[{\"name\":\"phase\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"contributors\",\"outputs\":[{\"name\":\"adr\",\"type\":\"address\"},{\"name\":\"initialContributionDay\",\"type\":\"uint256\"},{\"name\":\"lastUpdatedOn\",\"type\":\"uint256\"},{\"name\":\"mintingPower\",\"type\":\"uint256\"},{\"name\":\"expiryBlockNumber\",\"type\":\"uint256\"},{\"name\":\"minPriceInDay\",\"type\":\"uint256\"},{\"name\":\"status\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minPriceInDay\",\"type\":\"uint256\"},{\"name\":\"_expiryBlockNumber\",\"type\":\"uint256\"}],\"name\":\"sellMintingAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"mintAgents\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setMintAgent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"upgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"balanceById\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"halvingCycle\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DayInSecs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"teamIssuedTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialBlockTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"setTokenInformation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintingDec\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxMintingPower\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"soldAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minMintingPower\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgradeAgent\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_offerId\",\"type\":\"uint256\"},{\"name\":\"_offerInDay\",\"type\":\"uint256\"}],\"name\":\"buyMintingAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"releaseTokenTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgradeMaster\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_adr\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTeamContributorIdsAllocated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cancelSaleOfMintingAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUpgradeState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isValidContributorAddress\",\"outputs\":[{\"name\":\"isValidContributor\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"transferAgents\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isTeamLockInPeriodOverIfTeamAddress\",\"outputs\":[{\"name\":\"isLockInPeriodOver\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"sellingPriceInDayOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalPostIcoContributorIds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"released\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_customerId\",\"type\":\"uint256\"},{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"postAllocateAuctionTimeMints\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"canUpgrade\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isInitialBlockTimestampSet\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_mintingDec\",\"type\":\"uint256\"}],\"name\":\"setMintingDec\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstPostIcoContributorId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeSub\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxMintingDays\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"updateTimeMintBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalNormalContributorIds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refundFailedAuctionAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_initialBlockTimestamp\",\"type\":\"uint256\"}],\"name\":\"releaseToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_adr\",\"type\":\"address\"}],\"name\":\"getMintingPowerByAddress\",\"outputs\":[{\"name\":\"mintingPower\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTeamContributorIds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getSellingStatus\",\"outputs\":[{\"name\":\"status\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateMyTimeMintBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalUpgraded\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstContributorId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeMul\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"releaseAgent\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minBalanceToSell\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"agent\",\"type\":\"address\"}],\"name\":\"setUpgradeAgent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"idOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"isValidContributorId\",\"outputs\":[{\"name\":\"isValidContributor\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOnSaleIds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeAdd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDayCount\",\"outputs\":[{\"name\":\"daySinceMintingEpoch\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"master\",\"type\":\"address\"}],\"name\":\"setUpgradeMaster\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_initialSupply\",\"type\":\"uint256\"},{\"name\":\"_decimals\",\"type\":\"uint8\"},{\"name\":\"_mintable\",\"type\":\"bool\"},{\"name\":\"_maxAddresses\",\"type\":\"uint256\"},{\"name\":\"_firstTeamContributorId\",\"type\":\"uint256\"},{\"name\":\"_totalTeamContributorIds\",\"type\":\"uint256\"},{\"name\":\"_totalPostIcoContributorIds\",\"type\":\"uint256\"},{\"name\":\"_minMintingPower\",\"type\":\"uint256\"},{\"name\":\"_maxMintingPower\",\"type\":\"uint256\"},{\"name\":\"_halvingCycle\",\"type\":\"uint256\"},{\"name\":\"_minBalanceToSell\",\"type\":\"uint256\"},{\"name\":\"_dayInSecs\",\"type\":\"uint256\"},{\"name\":\"_teamLockPeriodInSec\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newName\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"newSymbol\",\"type\":\"string\"}],\"name\":\"UpdatedTokenInformation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"MintingAdrTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"adr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ContributorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"minPriceInDay\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"expiryBlockNumber\",\"type\":\"uint256\"}],\"name\":\"TimeMintOnSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"offerInDay\",\"type\":\"uint256\"}],\"name\":\"TimeMintSold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"customerId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"contributorId\",\"type\":\"uint256\"}],\"name\":\"PostInvested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"teamAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"TeamAddressAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"customerId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"contributorId\",\"type\":\"uint256\"}],\"name\":\"Invested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Upgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"agent\",\"type\":\"address\"}],\"name\":\"UpgradeAgentSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"MintingAgentChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Minted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"DayToken","CompilerVersion":"v0.4.16+commit.d7661dd9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000002200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000d050000000000000000000000000000000000000000000000000000000000000c9c0000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000005800000000000000000000000000000000000000000000000006f05b59d3b200000000000000000000000000000000000000000000000000000de0b6b3a764000000000000000000000000000000000000000000000000000000000000000000580000000000000000000000000000000000000000000001e1d1c72d5b97e0000000000000000000000000000000000000000000000000000000000000000151800000000000000000000000000000000000000000000000000000000001e133800000000000000000000000000000000000000000000000000000000000000003444159000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034441590000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://3c8e25f14894b4155b24701de30f025078d8ed7672c303ae840676a0ea8b273f"}]}