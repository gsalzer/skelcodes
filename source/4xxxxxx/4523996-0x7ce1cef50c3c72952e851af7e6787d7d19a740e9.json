{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n//@proofsuite testing on mainnet\r\n\r\ninterface Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply);\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\nlibrary NettingChannelLibrary {\r\n    string constant public contract_version = \"0.1._\";\r\n\r\n    struct Participant\r\n    {\r\n        address node_address;\r\n\r\n        // Total amount of token transferred to this smart contract through the\r\n        // `deposit` function, note that direct token transfer cannot be\r\n        // tracked and will be burned.\r\n        uint256 balance;\r\n\r\n        // The latest known merkle root of the pending hash-time locks, used to\r\n        // validate the withdrawn proofs.\r\n        bytes32 locksroot;\r\n\r\n        // The latest known transferred_amount from this node to the other\r\n        // participant, used to compute the net balance on settlement.\r\n        uint256 transferred_amount;\r\n\r\n        // Value used to order transfers and only accept the latest on calls to\r\n        // update, this will only be relevant after either #182 or #293 is\r\n        // implemented.\r\n        uint64 nonce;\r\n\r\n        // A mapping to keep track of locks that have been withdrawn.\r\n        mapping(bytes32 => bool) withdrawn_locks;\r\n    }\r\n\r\n    struct Data {\r\n        uint settle_timeout;\r\n        uint opened;\r\n        uint closed;\r\n        uint settled;\r\n        address closing_address;\r\n        Token token;\r\n        Participant[2] participants;\r\n        mapping(address => uint8) participant_index;\r\n        bool updated;\r\n    }\r\n\r\n\r\n    modifier notSettledButClosed(Data storage self) {\r\n        require(self.settled <= 0 && self.closed > 0);\r\n        _;\r\n    }\r\n\r\n    modifier stillTimeout(Data storage self) {\r\n        require(self.closed + self.settle_timeout >= block.number);\r\n        _;\r\n    }\r\n\r\n    modifier timeoutOver(Data storage self) {\r\n        require(self.closed + self.settle_timeout <= block.number);\r\n        _;\r\n    }\r\n\r\n    modifier channelSettled(Data storage self) {\r\n        require(self.settled != 0);\r\n        _;\r\n    }\r\n\r\n    /// @notice Deposit amount to channel.\r\n    /// @dev Deposit an amount to the channel. At least one of the participants\r\n    /// must deposit before the channel is opened.\r\n    /// @param amount The amount to be deposited to the address\r\n    /// @return Success if the transfer was successful\r\n    /// @return The new balance of the invoker\r\n    function deposit(Data storage self, uint256 amount)\r\n        returns (bool success, uint256 balance)\r\n    {\r\n        uint8 index;\r\n\r\n        require(self.opened > 0);\r\n        require(self.closed == 0);\r\n        require(self.token.balanceOf(msg.sender) >= amount);\r\n\r\n        index = index_or_throw(self, msg.sender);\r\n        Participant storage participant = self.participants[index];\r\n\r\n        success = self.token.transferFrom(msg.sender, this, amount);\r\n        if (success == true) {\r\n            balance = participant.balance;\r\n            balance += amount;\r\n            participant.balance = balance;\r\n\r\n            return (true, balance);\r\n        }\r\n\r\n        return (false, 0);\r\n    }\r\n\r\n    /// @notice Close a channel between two parties that was used bidirectionally\r\n    function close(\r\n        Data storage self,\r\n        uint64 nonce,\r\n        uint256 transferred_amount,\r\n        bytes32 locksroot,\r\n        bytes32 extra_hash,\r\n        bytes signature\r\n    ) {\r\n        address transfer_address;\r\n        uint closer_index;\r\n        uint counterparty_index;\r\n\r\n        // close can be called only once\r\n        require(self.closed == 0);\r\n        self.closed = block.number;\r\n\r\n        // Only a participant can call close\r\n        closer_index = index_or_throw(self, msg.sender);\r\n        self.closing_address = msg.sender;\r\n\r\n        // Only the closing party can provide a transfer from the counterparty,\r\n        // and only when this function is called, i.e. this value can not be\r\n        // updated afterwards.\r\n\r\n        // An empty value means that the closer never received a transfer, or\r\n        // he is intentionally not providing the latest transfer, in which case\r\n        // the closing party is going to lose the tokens that were transferred\r\n        // to him.\r\n        if (signature.length == 65) {\r\n            transfer_address = recoverAddressFromSignature(\r\n                nonce,\r\n                transferred_amount,\r\n                locksroot,\r\n                extra_hash,\r\n                signature \r\n            );\r\n\r\n            counterparty_index = index_or_throw(self, transfer_address);\r\n            require(closer_index != counterparty_index);\r\n\r\n            // update the structure of the counterparty with its data provided\r\n            // by the closing node\r\n            Participant storage counterparty = self.participants[counterparty_index];\r\n            counterparty.nonce = uint64(nonce);\r\n            counterparty.locksroot = locksroot;\r\n            counterparty.transferred_amount = transferred_amount;\r\n        }\r\n    }\r\n\r\n    /// @notice Updates counter party transfer after closing.\r\n    function updateTransfer(\r\n        Data storage self,\r\n        uint64 nonce,\r\n        uint256 transferred_amount,\r\n        bytes32 locksroot,\r\n        bytes32 extra_hash,\r\n        bytes signature\r\n    )\r\n        notSettledButClosed(self)\r\n        stillTimeout(self)\r\n    {\r\n        address transfer_address;\r\n        uint8 caller_index;\r\n        uint8 closer_index;\r\n\r\n        // updateTransfer can be called by the counter party only once\r\n        require(!self.updated);\r\n        self.updated = true;\r\n\r\n        // Only a participant can call updateTransfer (#293 for third parties)\r\n        caller_index = index_or_throw(self, msg.sender);\r\n\r\n        // The closer is not allowed to call updateTransfer\r\n        require(self.closing_address != msg.sender);\r\n\r\n        // Counter party can only update the closer transfer\r\n        transfer_address = recoverAddressFromSignature(\r\n            nonce,\r\n            transferred_amount,\r\n            locksroot,\r\n            extra_hash,\r\n            signature \r\n        );\r\n        require(transfer_address == self.closing_address);\r\n\r\n        // Update the structure of the closer with its data provided by the\r\n        // counterparty\r\n        closer_index = 1 - caller_index;\r\n\r\n        self.participants[closer_index].nonce = nonce;\r\n        self.participants[closer_index].locksroot = locksroot;\r\n        self.participants[closer_index].transferred_amount = transferred_amount;\r\n    }\r\n\r\n    function recoverAddressFromSignature(\r\n        uint64 nonce,\r\n        uint256 transferred_amount,\r\n        bytes32 locksroot,\r\n        bytes32 extra_hash,\r\n        bytes signature\r\n    )\r\n        constant internal returns (address)\r\n    {\r\n        bytes32 signed_hash;\r\n\r\n        require(signature.length == 65);\r\n\r\n        signed_hash = sha3(\r\n            nonce,\r\n            transferred_amount,\r\n            locksroot,\r\n            this,\r\n            extra_hash\r\n        );\r\n\r\n        var (r, s, v) = signatureSplit(signature);\r\n        return ecrecover(signed_hash, v, r, s);\r\n    }\r\n\r\n    /// @notice Unlock a locked transfer\r\n    /// @dev Unlock a locked transfer\r\n    /// @param locked_encoded The lock\r\n    /// @param merkle_proof The merkle proof\r\n    /// @param secret The secret\r\n    function withdraw(Data storage self, bytes locked_encoded, bytes merkle_proof, bytes32 secret)\r\n        notSettledButClosed(self)\r\n    {\r\n        uint amount;\r\n        uint8 index;\r\n        uint64 expiration;\r\n        bytes32 h;\r\n        bytes32 hashlock;\r\n\r\n        // Check if msg.sender is a participant and select the partner (for\r\n        // third party unlock see #541)\r\n        index = 1 - index_or_throw(self, msg.sender);\r\n        Participant storage counterparty = self.participants[index];\r\n\r\n        // An empty locksroot means there are no pending locks\r\n        require(counterparty.locksroot != 0);\r\n\r\n        (expiration, amount, hashlock) = decodeLock(locked_encoded);\r\n\r\n        // A lock can be withdrawn only once per participant\r\n        require(!counterparty.withdrawn_locks[hashlock]);\r\n\r\n        counterparty.withdrawn_locks[hashlock] = true;\r\n\r\n        // The lock must not have expired, it does not matter how far in the\r\n        // future it would have expired\r\n        require(expiration >= block.number);\r\n        require(hashlock == sha3(secret));\r\n\r\n        h = computeMerkleRoot(locked_encoded, merkle_proof);\r\n\r\n        require(counterparty.locksroot == h);\r\n\r\n        // This implementation allows for each transfer to be set only once, so\r\n        // it's safe to update the transferred_amount in place.\r\n        //\r\n        // Once third parties are allowed to update the counter party transfer\r\n        // (#293, #182) the locksroot may change, if the locksroot change the\r\n        // transferred_amount must be reset and locks must be re-withdrawn, so\r\n        // this is also safe.\r\n        //\r\n        // This may be problematic if an update changes the transferred_amount\r\n        // but not the locksroot, since the locks don't need to be\r\n        // re-withdrawn, the difference in the transferred_amount must be\r\n        // accounted for.\r\n        counterparty.transferred_amount += amount;\r\n    }\r\n\r\n    function computeMerkleRoot(bytes lock, bytes merkle_proof)\r\n        internal\r\n        constant\r\n        returns (bytes32)\r\n    {\r\n        require(merkle_proof.length % 32 == 0);\r\n\r\n        uint i;\r\n        bytes32 h;\r\n        bytes32 el;\r\n\r\n        h = sha3(lock);\r\n        for (i = 32; i <= merkle_proof.length; i += 32) {\r\n            assembly {\r\n                el := mload(add(merkle_proof, i))\r\n            }\r\n\r\n            if (h < el) {\r\n                h = sha3(h, el);\r\n            } else {\r\n                h = sha3(el, h);\r\n            }\r\n        }\r\n\r\n        return h;\r\n    }\r\n\r\n    /// @notice Settles the balance between the two parties\r\n    /// @dev Settles the balances of the two parties fo the channel\r\n    /// @return The participants with netted balances\r\n    function settle(Data storage self)\r\n        notSettledButClosed(self)\r\n        timeoutOver(self)\r\n    {\r\n        uint8 closing_index;\r\n        uint8 counter_index;\r\n        uint256 total_deposit;\r\n        uint256 counter_net;\r\n        uint256 closer_amount;\r\n        uint256 counter_amount;\r\n\r\n        self.settled = block.number;\r\n\r\n        closing_index = index_or_throw(self, self.closing_address);\r\n        counter_index = 1 - closing_index;\r\n\r\n        Participant storage closing_party = self.participants[closing_index];\r\n        Participant storage counter_party = self.participants[counter_index];\r\n\r\n        counter_net = (\r\n            counter_party.balance\r\n            + closing_party.transferred_amount\r\n            - counter_party.transferred_amount\r\n        );\r\n\r\n        // Direct token transfers done through the token `transfer` function\r\n        // cannot be accounted for, these superfluous tokens will be burned,\r\n        // this is because there is no way to tell which participant (if any)\r\n        // had ownership over the token.\r\n        total_deposit = closing_party.balance + counter_party.balance;\r\n\r\n        // When the closing party does not provide the counter party transfer,\r\n        // the `counter_net` may be larger than the `total_deposit`, without\r\n        // the min the token transfer fail and the token is locked.\r\n        counter_amount = min(counter_net, total_deposit);\r\n\r\n        // When the counter party does not provide the closing party transfer,\r\n        // then `counter_amount` may be negative and the transfer fails, force\r\n        // the value to 0.\r\n        counter_amount = max(counter_amount, 0);\r\n\r\n        // At this point `counter_amount` is between [0,total_deposit], so this\r\n        // is safe.\r\n        closer_amount = total_deposit - counter_amount;\r\n\r\n        if (counter_amount > 0) {\r\n            require(self.token.transfer(counter_party.node_address, counter_amount));\r\n        }\r\n\r\n        if (closer_amount > 0) {\r\n            require(self.token.transfer(closing_party.node_address, closer_amount));\r\n        }\r\n\r\n        kill(self);\r\n    }\r\n\r\n    // NOTES:\r\n    //\r\n    // - The EVM is a big-endian, byte addressing machine, with 32bytes/256bits\r\n    //   words.\r\n    // - The Ethereum Contract ABI specifies that variable length types have a\r\n    //   32bytes prefix to define the variable size.\r\n    // - Solidity has additional data types that are narrower than 32bytes\r\n    //   (e.g. uint128 uses a half word).\r\n    // - Solidity uses the *least-significant* bits of the word to store the\r\n    //   values of a narrower type.\r\n    //\r\n    // GENERAL APPROACH:\r\n    //\r\n    // Add to the message pointer the number of bytes required to move the\r\n    // address so that the target data is at the end of the 32bytes word.\r\n    //\r\n    // EXAMPLE:\r\n    //\r\n    // To decode the cmdid, consider this initial state:\r\n    //\r\n    //\r\n    //     v- pointer word start\r\n    //     [ 32 bytes length prefix ][ cmdid ] ----\r\n    //                              ^- pointer word end\r\n    //\r\n    //\r\n    // Because the cmdid has 1 byte length the type uint8 is used, the decoder\r\n    // needs to move the pointer so the cmdid is at the end of the pointer\r\n    // word.\r\n    //\r\n    //\r\n    //             v- pointer word start [moved 1byte ahead]\r\n    //     [ 32 bytes length prefix ][ cmdid ] ----\r\n    //                                       ^- pointer word end\r\n    //\r\n    //\r\n    // Now the data of the cmdid can be loaded to the uint8 variable.\r\n    //\r\n    // REFERENCES:\r\n    // - https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\r\n    // - http://solidity.readthedocs.io/en/develop/assembly.html\r\n\r\n    function decodeLock(bytes lock) internal returns (uint64 expiration, uint amount, bytes32 hashlock) {\r\n        require(lock.length == 72);\r\n\r\n        // Lock format:\r\n        // [0:8] expiration\r\n        // [8:40] amount\r\n        // [40:72] hashlock\r\n        assembly {\r\n            expiration := mload(add(lock, 8))\r\n            amount := mload(add(lock, 40))\r\n            hashlock := mload(add(lock, 72))\r\n        }\r\n    }\r\n\r\n    function signatureSplit(bytes signature) internal returns (bytes32 r, bytes32 s, uint8 v) {\r\n        // The signature format is a compact form of:\r\n        //   {bytes32 r}{bytes32 s}{uint8 v}\r\n        // Compact means, uint8 is not padded to 32 bytes.\r\n        assembly {\r\n            r := mload(add(signature, 32))\r\n            s := mload(add(signature, 64))\r\n            // Here we are loading the last 32 bytes, including 31 bytes\r\n            // of 's'. There is no 'mload8' to do this.\r\n            //\r\n            // 'byte' is not working due to the Solidity parser, so lets\r\n            // use the second best option, 'and'\r\n            v := and(mload(add(signature, 65)), 0xff)\r\n        }\r\n\r\n        require(v == 27 || v == 28);\r\n    }\r\n\r\n    function index_or_throw(Data storage self, address participant_address) private returns (uint8) {\r\n        uint8 n;\r\n        // Return index of participant, or throw\r\n        n = self.participant_index[participant_address];\r\n        assert(n != 0);\r\n        return n - 1;\r\n    }\r\n\r\n    function min(uint a, uint b) constant internal returns (uint) {\r\n        return a > b ? b : a;\r\n    }\r\n\r\n    function max(uint a, uint b) constant internal returns (uint) {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n    function kill(Data storage self) channelSettled(self) {\r\n        selfdestruct(0x00000000000000000000);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"NettingChannelLibrary.Data storage\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"},{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"NettingChannelLibrary.Data storage\"}],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contract_version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"NettingChannelLibrary.Data storage\"},{\"name\":\"locked_encoded\",\"type\":\"bytes\"},{\"name\":\"merkle_proof\",\"type\":\"bytes\"},{\"name\":\"secret\",\"type\":\"bytes32\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"NettingChannelLibrary.Data storage\"},{\"name\":\"nonce\",\"type\":\"uint64\"},{\"name\":\"transferred_amount\",\"type\":\"uint256\"},{\"name\":\"locksroot\",\"type\":\"bytes32\"},{\"name\":\"extra_hash\",\"type\":\"bytes32\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"close\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"NettingChannelLibrary.Data storage\"}],\"name\":\"settle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"NettingChannelLibrary.Data storage\"},{\"name\":\"nonce\",\"type\":\"uint64\"},{\"name\":\"transferred_amount\",\"type\":\"uint256\"},{\"name\":\"locksroot\",\"type\":\"bytes32\"},{\"name\":\"extra_hash\",\"type\":\"bytes32\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"updateTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"NettingChannelLibrary","CompilerVersion":"v0.4.16+commit.d7661dd9","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://9273410242a08ed7068176d91fcd4d9e2988f5c73a0ce9f80a4cbc795d5bfd65"}]}