{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\ninterface ERC20 {\r\n    function balanceOf(address _owner) public constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n}\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  //function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    //// require(b > 0); // Solidity automatically throws when dividing by 0\r\n    //uint256 c = a / b;\r\n    //// require(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    //return c;\r\n  //}\r\n\r\n  //function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    //require(b <= a);\r\n    //return a - b;\r\n  //}\r\n\r\n  //function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    //uint256 c = a + b;\r\n    //require(c >= a);\r\n    //return c;\r\n  //}\r\n}\r\n\r\n// A contract that distributes ERC20 tokens with predetermined terms.\r\n// WARNING: This contract does not protect against malicious token contracts,\r\n//          under the assumption that if the token sellers are malicious,\r\n//          the tokens will be worthless anyway.\r\ncontract Distribution {\r\n  using SafeMath for uint256;\r\n\r\n  enum State {\r\n    AwaitingTokens,\r\n    DistributingNormally,\r\n    DistributingProRata,\r\n    Done\r\n  }\r\n \r\n  address admin;\r\n  ERC20 tokenContract;\r\n  State state;\r\n  uint256 actualTotalTokens;\r\n  uint256 tokensTransferred;\r\n\r\n  bytes32[] contributionHashes;\r\n  uint256 expectedTotalTokens;\r\n\r\n  function Distribution(address _admin, ERC20 _tokenContract,\r\n                        bytes32[] _contributionHashes, uint256 _expectedTotalTokens) public {\r\n    expectedTotalTokens = _expectedTotalTokens;\r\n    contributionHashes = _contributionHashes;\r\n    tokenContract = _tokenContract;\r\n    admin = _admin;\r\n\r\n    state = State.AwaitingTokens;\r\n  }\r\n\r\n  function handleTokensReceived() public {\r\n    require(state == State.AwaitingTokens);\r\n    uint256 totalTokens = tokenContract.balanceOf(this);\r\n    require(totalTokens > 0);\r\n\r\n    tokensTransferred = 0;\r\n    if (totalTokens == expectedTotalTokens) {\r\n      state = State.DistributingNormally;\r\n    } else {\r\n      actualTotalTokens = totalTokens;\r\n      state = State.DistributingProRata;\r\n    }\r\n  }\r\n\r\n  function _numTokensForContributor(uint256 contributorExpectedTokens, State _state)\r\n      internal view returns (uint256) {\r\n    if (_state == State.DistributingNormally) {\r\n      return contributorExpectedTokens;\r\n    } else if (_state == State.DistributingProRata) {\r\n      uint256 tokensRemaining = actualTotalTokens - tokensTransferred;\r\n      uint256 tokens = actualTotalTokens.mul(contributorExpectedTokens) / expectedTotalTokens;\r\n\r\n      // Handle roundoff on last contributor.\r\n      if (tokens < tokensRemaining) {\r\n        return tokens;\r\n      } else {\r\n        return tokensRemaining;\r\n      }\r\n    } else {\r\n      revert();\r\n    }\r\n  }\r\n\r\n  function doDistribution(uint256 contributorIndex, address contributor,\r\n                          uint256 contributorExpectedTokens)\r\n      public {\r\n    // Make sure the arguments match the compressed storage.\r\n    require(contributionHashes[contributorIndex] == keccak256(contributor, contributorExpectedTokens));\r\n\r\n    uint256 numTokens = _numTokensForContributor(contributorExpectedTokens, state);\r\n    contributionHashes[contributorIndex] = 0x00000000000000000000000000000000;\r\n    tokensTransferred += numTokens;\r\n    if (tokensTransferred == actualTotalTokens) {\r\n      state = State.Done;\r\n    }\r\n\r\n    require(tokenContract.transfer(contributor, numTokens));\r\n  }\r\n\r\n  function doDistributionRange(uint256 start, address[] contributors,\r\n                               uint256[] contributorExpectedTokens) public {\r\n    require(contributors.length == contributorExpectedTokens.length);\r\n\r\n    uint256 tokensTransferredThisCall = 0;\r\n    uint256 end = start + contributors.length;\r\n    State _state = state;\r\n    for (uint256 i = start; i < end; ++i) {\r\n      address contributor = contributors[i];\r\n      uint256 expectedTokens = contributorExpectedTokens[i];\r\n      require(contributionHashes[i] == keccak256(contributor, expectedTokens));\r\n      contributionHashes[i] = 0x00000000000000000000000000000000;\r\n\r\n      uint256 numTokens = _numTokensForContributor(expectedTokens, _state);\r\n      tokensTransferredThisCall += numTokens;\r\n      require(tokenContract.transfer(contributor, numTokens));\r\n    }\r\n\r\n    tokensTransferred += tokensTransferredThisCall;\r\n    if (tokensTransferred == actualTotalTokens) {\r\n      state = State.Done;\r\n    }\r\n  }\r\n\r\n  function numTokensForContributor(uint256 contributorExpectedTokens)\r\n      public view returns (uint256) {\r\n    return _numTokensForContributor(contributorExpectedTokens, state);\r\n  }\r\n\r\n  function temporaryEscapeHatch(address to, uint256 value, bytes data) public {\r\n    require(msg.sender == admin);\r\n    require(to.call.value(value)(data));\r\n  }\r\n\r\n  function temporaryKill(address to) public {\r\n    require(msg.sender == admin);\r\n    require(state == State.Done);\r\n    require(tokenContract.balanceOf(this) == 0);\r\n    selfdestruct(to);\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"contributors\",\"type\":\"address[]\"},{\"name\":\"contributorExpectedTokens\",\"type\":\"uint256[]\"}],\"name\":\"doDistributionRange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"contributorExpectedTokens\",\"type\":\"uint256\"}],\"name\":\"numTokensForContributor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"temporaryEscapeHatch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"}],\"name\":\"temporaryKill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contributorIndex\",\"type\":\"uint256\"},{\"name\":\"contributor\",\"type\":\"address\"},{\"name\":\"contributorExpectedTokens\",\"type\":\"uint256\"}],\"name\":\"doDistribution\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"handleTokensReceived\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"},{\"name\":\"_tokenContract\",\"type\":\"address\"},{\"name\":\"_contributionHashes\",\"type\":\"bytes32[]\"},{\"name\":\"_expectedTotalTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"Distribution","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000d7c02a75d24e5a0f8140488877874cd880dafe150000000000000000000000005d65d971895edc438f465c17db6992698a52318d00000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000003e0dd89fd4ea92dbc150000000000000000000000000000000000000000000000000000000000000006fb9d49b126e4de8a346b39348e2811504dcb138fdd95402a79be4e9e6438e7c8bc5996d666634626663f509abc248f5da05a60495952894465e94942d2a78c8aaa84af03d39f0336d5b1efa5bd4ea592dee767e5cd8ab9a0fd0c559874047e8b507bcf47d706f941e05c3bd16fd8cb6c79658efb5390aa9ebf389e543565bf6d131f7bf14066c4a71d4ab8ddc49eeee9c4cd2f931f4529ed5c753293b3a9200fb06efe8707d48a6728c7d0774578c279251849412799864fad25e54620aede0f","Library":"","SwarmSource":"bzzr://5bbfa8adfce95b82645e8d4d5554ce1502ce6746cd6111b1e009a76471b8badf"}]}