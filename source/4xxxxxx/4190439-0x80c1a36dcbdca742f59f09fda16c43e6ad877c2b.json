{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^ 0.4 .15;\r\n\r\n\r\n/*\r\n * ERC20 interface\r\n * see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) constant returns (uint);\r\n  function allowance(address owner, address spender) constant returns (uint);\r\n\r\n  function transfer(address to, uint value) returns (bool ok);\r\n  function transferFrom(address from, address to, uint value) returns (bool ok);\r\n  function approve(address spender, uint value) returns (bool ok);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n\r\n/**\r\n * Math operations with safety checks\r\n */\r\ncontract SafeMath {\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeDiv(uint a, uint b) internal returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a / b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation.\r\n *\r\n * Based on code by FirstBlood:\r\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, SafeMath {\r\n\r\n  mapping(address => uint) balances;\r\n  mapping (address => mapping (address => uint)) allowed;\r\n\r\n  /**\r\n   *\r\n   * Fix for the ERC20 short address attack\r\n   *\r\n   * http://vessenes.com/the-erc20-short-address-attack-explained/\r\n   */\r\n  modifier onlyPayloadSize(uint size) {\r\n     if(msg.data.length < size + 4) revert();\r\n     _;\r\n  }\r\n\r\n  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) returns (bool success) {\r\n    balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value)  returns (bool success) {\r\n    var _allowance = allowed[_from][msg.sender];\r\n\r\n    // Check is not needed because safeSub(_allowance, _value) will already throw if this condition is not met\r\n    // if (_value > _allowance) throw;\r\n\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    balances[_from] = safeSub(balances[_from], _value);\r\n    allowed[_from][msg.sender] = safeSub(_allowance, _value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function approve(address _spender, uint _value) returns (bool success) {\r\n\r\n    // To change the approve amount you first have to reduce the addresses`\r\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n    //  already 0 to mitigate the race condition described here:\r\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) revert();\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n}\r\n\r\ncontract owned {\r\n    address owner;\r\n\r\n    modifier onlyOwner() {\r\n      require(msg.sender == owner);\r\n      _;\r\n    }\r\n}\r\n\r\ncontract Fish is owned, StandardToken {\r\n\r\n  string public constant TermsOfUse = \"https://github.com/triangles-things/fish.project/blob/master/terms-of-use.md\";\r\n\r\n  /*\r\n   * State variables\r\n   */\r\n\r\n  string public constant symbol = \"FSH\";\r\n  string public constant name = \"Fish\";\r\n  uint8 public constant decimals = 3;\r\n\r\n  /*\r\n   * Constructor function\r\n   */\r\n\r\n  function Fish() {\r\n    owner = msg.sender;\r\n    balances[msg.sender] = 1;                                                   // Owner can now be a referral\r\n    totalSupply = 1;\r\n    buyPrice_wie= 100000000000000;                                              // 100 szabo per one token. One unit = 1000 tokens. 1 ether = 10 units\r\n    sellPrice_wie = buyPrice_wie * sell_ppc / 100;\r\n  }\r\n\r\n  function () payable { revert(); }\r\n\r\n  /*\r\n   * SECTION: PRICE GROWTH\r\n   *\r\n   * This section is responsible for daily price increase. Once per day the buy price will be increased \r\n   * through adjustPrice modifier. The price update happens before buy and sell functions are executed.\r\n   * Contract owner has only one way to control the growth rate here - setGrowth.\r\n   */\r\n\r\n  // Growth rate is present in parts per million (ppm)\r\n  uint32 public dailyGrowth_ppm = 6100;                                         // default growth is 20% (0.61% per day)\r\n  uint public dailyGrowthUpdated_date = now;                                    // Don't update it on first day of contract\r\n  \r\n  uint32 private constant dailyGrowthMin_ppm =  6096;                           // 20% every month in price growth or 0.00610 daily\r\n  uint32 private constant dailyGrowthMax_ppm = 23374;                           // 100% in growth every month or 0,02337 daily\r\n  \r\n  uint32 public constant sell_ppc = 90;                                         // Sell price is 90% of buy price\r\n\r\n  event DailyGrowthUpdate(uint _newRate_ppm);\r\n  event PriceAdjusted(uint _newBuyPrice_wei, uint _newSellPrice_wei);\r\n\r\n  /*\r\n   * MODIFIER\r\n   * If last update happened more than one day ago, update the price, save the time of current price update\r\n   * Adjust sell price and log the event\r\n   */\r\n  modifier adjustPrice() {\r\n    if ( (dailyGrowthUpdated_date + 1 days) < now ) {\r\n      dailyGrowthUpdated_date = now;\r\n      buyPrice_wie = buyPrice_wie * (1000000 + dailyGrowth_ppm) / 1000000;\r\n      sellPrice_wie = buyPrice_wie * sell_ppc / 100;\r\n      PriceAdjusted(buyPrice_wie, sellPrice_wie);\r\n    }\r\n    _;\r\n  }\r\n\r\n  /* \r\n   * OWNER ONLY; EXTERNAL METHOD\r\n   * setGrowth can accept values within range from 20% to 100% of growth per month (based on 30 days per month assumption).\r\n   * \r\n   *   Formula is:\r\n   *\r\n   *       buyPrice_eth = buyPrice_eth * (1000000 + dailyGrowthMin_ppm) / 1000000;\r\n   *       ^new value     ^current value  ^1.0061 (if dailyGrowth_ppm == 6100)\r\n   *\r\n   *       1.0061^30 = 1.20 (if dailyGrowth_ppm == 6100)\r\n   *       1.023374^30 = 2 (if dailyGrowth_ppm == 23374)\r\n   * \r\n   *  Some other daily rates\r\n   *\r\n   *   Per month -> Value in ppm\r\n   *      1.3    ->  8783\r\n   *      1.4    -> 11278\r\n   *      1.5    -> 13607\r\n   *      1.6    -> 15790\r\n   *      1.7    -> 17844\r\n   *      1.8    -> 19786\r\n   */\r\n  function setGrowth(uint32 _newGrowth_ppm) onlyOwner external returns(bool result) {\r\n    if (_newGrowth_ppm >= dailyGrowthMin_ppm &&\r\n        _newGrowth_ppm <= dailyGrowthMax_ppm\r\n    ) {\r\n      dailyGrowth_ppm = _newGrowth_ppm;\r\n      DailyGrowthUpdate(_newGrowth_ppm);\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /* \r\n   * SECTION: TRADING\r\n   *\r\n   * This section is responsible purely for trading the tokens. User can buy tokens, user can sell tokens.\r\n   *\r\n   */\r\n\r\n  uint256 public sellPrice_wie;\r\n  uint256 public buyPrice_wie;\r\n\r\n  /*\r\n   * EXTERNAL METHOD\r\n   * User can buy arbitrary amount of tokens. Before amount of tokens will be calculated, the price of tokens \r\n   * has to be adjusted. This happens in adjustPrice modified before function call.\r\n   *\r\n   * Short description of this method\r\n   *\r\n   *   Calculate tokens that user is buying\r\n   *   Assign awards ro refereals\r\n   *   Add some bounty for new users who set referral before first buy\r\n   *   Send tokens that belong to contract or if there is non issue more and send them to user\r\n   *\r\n   * Read -> https://github.com/triangles-things/fish.project/blob/master/terms-of-use.md\r\n   */\r\n  function buy() adjustPrice payable external {\r\n    require(msg.value >= buyPrice_wie);\r\n    var amount = safeDiv(msg.value, buyPrice_wie);\r\n\r\n    assignBountryToReferals(msg.sender, amount);                                // First assign bounty\r\n\r\n    // Buy discount if User is a new user and has set referral\r\n    if ( balances[msg.sender] == 0 && referrals[msg.sender][0] != 0 ) {\r\n      // Check that user has to wait at least two weeks before he get break even on what he will get\r\n      amount = amount * (100 + landingDiscount_ppc) / 100;\r\n    }\r\n\r\n    issueTo(msg.sender, amount);\r\n  }\r\n\r\n  /*\r\n   * EXTERNAL METHOD\r\n   * User can sell tokens back to contract.\r\n   *\r\n   * Short description of this method\r\n   *\r\n   *   Adjust price\r\n   *   Calculate tokens price that user is selling \r\n   *   Make all possible checks\r\n   *   Transfer the money\r\n   */\r\n  function sell(uint256 _amount) adjustPrice external {\r\n    require(_amount > 0 && balances[msg.sender] >= _amount);\r\n    uint moneyWorth = safeMul(_amount, sellPrice_wie);\r\n    require(this.balance > moneyWorth);                                         // We can't sell if we don't have enough money\r\n    \r\n    if (\r\n        balances[this] + _amount > balances[this] &&\r\n        balances[msg.sender] - _amount < balances[msg.sender]\r\n    ) {\r\n      balances[this] = safeAdd(balances[this], _amount);                        // adds the amount to owner's balance\r\n      balances[msg.sender] = safeSub(balances[msg.sender], _amount);            // subtracts the amount from seller's balance\r\n      if (!msg.sender.send(moneyWorth)) {                                       // sends ether to the seller. It's important\r\n        revert();                                                               // to do this last to avoid recursion attacks\r\n      } else {\r\n        Transfer(msg.sender, this, _amount);                                    // executes an event reflecting on the change\r\n      }        \r\n    } else {\r\n      revert();                                                                 // checks if the sender has enough to sell\r\n    }  \r\n  }\r\n\r\n  /*\r\n   * PRIVATE METHOD\r\n   * Issue  new tokens to contract\r\n   */\r\n  function issueTo(address _beneficiary, uint256 _amount_tkns) private {\r\n    if (\r\n        balances[this] >= _amount_tkns\r\n    ) {\r\n      // All tokens are taken from balance\r\n      balances[this] = safeSub(balances[this], _amount_tkns);\r\n      balances[_beneficiary] = safeAdd(balances[_beneficiary], _amount_tkns);\r\n    } else {\r\n      // Balance will be lowered and new tokens will be issued\r\n      uint diff = safeSub(_amount_tkns, balances[this]);\r\n\r\n      totalSupply = safeAdd(totalSupply, diff);\r\n      balances[this] = 0;\r\n      balances[_beneficiary] = safeAdd(balances[_beneficiary], _amount_tkns);\r\n    }\r\n    \r\n    Transfer(this, _beneficiary, _amount_tkns);\r\n  }\r\n  \r\n  /*\r\n   * SECTION: BOUNTIES\r\n   *\r\n   * This section describes all possible awards.\r\n   */\r\n    \r\n  mapping(address => address[3]) referrals;\r\n  mapping(address => uint256) bounties;\r\n\r\n  uint32 public constant landingDiscount_ppc = 4;                               // Landing discount is 4%\r\n\r\n  /*\r\n   * EXTERNAL METHOD \r\n   * Set your referral first. You will get 4% more tokens on your first buy and trigger a\r\n   * reward of whoever told you about this contract. A win-win scenario.\r\n   */\r\n  function referral(address _referral) external returns(bool) {\r\n    if ( balances[_referral] > 0 &&                                              // Referral participated already\r\n         balances[msg.sender] == 0  &&                                          // Sender is a new user\r\n         referrals[msg.sender][0] == 0                                           // Not returning user. User can not reassign their referrals but they can assign them later on\r\n    ) {\r\n      var referral_referrals = referrals[_referral];\r\n      referrals[msg.sender] = [_referral, referral_referrals[0], referral_referrals[1]];\r\n      return true;\r\n    }\r\n    \r\n    return false;\r\n  }\r\n\r\n  /*\r\n   * PRIVATE METHOD\r\n   * Award bounties to referrals.\r\n   */ \r\n  function assignBountryToReferals(address _referralsOf, uint256 _amount) private {\r\n    var refs = referrals[_referralsOf];\r\n    \r\n    if (refs[0] != 0) {\r\n     issueTo(refs[0], (_amount * 4) / 100);                                     // 4% bounty to direct referral\r\n      if (refs[1] != 0) {\r\n        issueTo(refs[1], (_amount * 2) / 100);                                  // 2% bounty to referral of referral\r\n        if (refs[2] != 0) {\r\n          issueTo(refs[2], (_amount * 1) / 100);                                // 1% bounty to referral of referral of referral\r\n       }\r\n      }\r\n    }\r\n  }\r\n\r\n  /*\r\n   * OWNER ONLY; EXTERNAL METHOD\r\n   * Santa is coming! Who ever made impact to promote the Fish and can prove it will get the bonus\r\n   */\r\n  function assignBounty(address _account, uint256 _amount) onlyOwner external returns(bool) {\r\n    require(_amount > 0); \r\n     \r\n    if (balances[_account] > 0 &&                                               // Account had participated already\r\n        bounties[_account] + _amount <= 1000000                                 // no more than 100 token units per account\r\n    ) {\r\n      issueTo(_account, _amount);\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"assignBounty\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sell_ppc\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dailyGrowth_ppm\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_referral\",\"type\":\"address\"}],\"name\":\"referral\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyPrice_wie\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellPrice_wie\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newGrowth_ppm\",\"type\":\"uint32\"}],\"name\":\"setGrowth\",\"outputs\":[{\"name\":\"result\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"landingDiscount_ppc\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dailyGrowthUpdated_date\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TermsOfUse\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_newRate_ppm\",\"type\":\"uint256\"}],\"name\":\"DailyGrowthUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_newBuyPrice_wei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newSellPrice_wei\",\"type\":\"uint256\"}],\"name\":\"PriceAdjusted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"Fish","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://4613992a993e1bbc51872aa0c9329a881775179ceea4634a49734b7b20cbfb32"}]}