{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.14;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n//Interface declaration from: https://github.com/ethereum/eips/issues/20\r\ncontract ERC20Interface {\r\n    //from: https://github.com/OpenZeppelin/zeppelin-solidity/blob/b395b06b65ce35cac155c13d01ab3fc9d42c5cfb/contracts/token/ERC20Basic.sol\r\n    uint256 public totalSupply; //tokens that can vote, transfer, receive dividend\r\n    function balanceOf(address who) public constant returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    //from: https://github.com/OpenZeppelin/zeppelin-solidity/blob/b395b06b65ce35cac155c13d01ab3fc9d42c5cfb/contracts/token/ERC20.sol\r\n    function allowance(address owner, address spender) public constant returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract ModumToken is ERC20Interface {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    address public owner;\r\n\r\n    mapping(address => mapping (address => uint256)) public allowed;\r\n\r\n    enum UpdateMode{Wei, Vote, Both} //update mode for the account\r\n    struct Account {\r\n        uint256 lastProposalStartTime; //For checking at which proposal valueModVote was last updated\r\n        uint256 lastAirdropWei; //For checking after which airDrop bonusWei was last updated\r\n        uint256 lastAirdropClaimTime; //for unclaimed airdrops, re-airdrop\r\n        uint256 bonusWei;      //airDrop/Dividend payout available for withdrawal.\r\n        uint256 valueModVote;  // votes available for voting on active Proposal\r\n        uint256 valueMod;      // the owned tokens\r\n    }\r\n    mapping(address => Account) public accounts;\r\n\r\n    //Airdorp\r\n    uint256 public totalDropPerUnlockedToken = 0;     //totally airdropped eth per unlocked token\r\n    uint256 public rounding = 0;                      //airdrops not accounted yet to make system rounding error proof\r\n\r\n    //Token locked/unlocked - totalSupply/max\r\n    uint256 public lockedTokens = 9 * 1100 * 1000;   //token that need to be unlocked by voting\r\n    uint256 public constant maxTokens = 30 * 1000 * 1000;      //max distributable tokens\r\n\r\n    //minting phase running if false, true otherwise. Many operations can only be called when\r\n    //minting phase is over\r\n    bool public mintDone = false;\r\n    uint256 public constant redistributionTimeout = 548 days; //18 month\r\n\r\n    //as suggested in https://theethereum.wiki/w/index.php/ERC20_Token_Standard\r\n    string public constant name = \"Modum Token\";\r\n    string public constant symbol = \"MOD\";\r\n    uint8 public constant decimals = 0;\r\n\r\n    //Voting\r\n    struct Proposal {\r\n        string addr;        //Uri for more info\r\n        bytes32 hash;       //Hash of the uri content for checking\r\n        uint256 valueMod;      //token to unlock: proposal with 0 amount is invalid\r\n        uint256 startTime;\r\n        uint256 yay;\r\n        uint256 nay;\r\n    }\r\n    Proposal public currentProposal;\r\n    uint256 public constant votingDuration = 2 weeks;\r\n    uint256 public lastNegativeVoting = 0;\r\n    uint256 public constant blockingDuration = 90 days;\r\n\r\n    event Voted(address _addr, bool option, uint256 votes); //called when a vote is casted\r\n    event Payout(uint256 weiPerToken); //called when an someone payed ETHs to this contract, that can be distributed\r\n\r\n    function ModumToken() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * In case an owner account gets compromised, it should be possible to move control\r\n     * over to another account. This helps in cases like the Parity multisig exploit: As\r\n     * soon as an exploit becomes known, the affected parties might have a small time\r\n     * window before being attacked.\r\n     */\r\n    function transferOwnership(address _newOwner) public {\r\n        require(msg.sender == owner);\r\n        require(_newOwner != address(0));\r\n        owner = _newOwner;\r\n    }\r\n\r\n    //*************************** Voting *****************************************\r\n    /*\r\n     * In addition to the the vode with address/URL and its hash, we also set the value\r\n     * of tokens to be transfered from the locked tokens to the modum account.\r\n     */\r\n    function votingProposal(string _addr, bytes32 _hash, uint256 _value) public {\r\n        require(msg.sender == owner); // proposal ony by onwer\r\n        require(!isProposalActive()); // no proposal is active, cannot vote in parallel\r\n        require(_value <= lockedTokens); //proposal cannot be larger than remaining locked tokens\r\n        require(_value > 0); //there needs to be locked tokens to make proposal, at least 1 locked token\r\n        require(_hash != bytes32(0)); //hash need to be set\r\n        require(bytes(_addr).length > 0); //the address need to be set and non-empty\r\n        require(mintDone); //minting phase needs to be over\r\n        //in case of negative vote, wait 90 days. If no lastNegativeVoting have\r\n        //occured, lastNegativeVoting is 0 and now is always larger than 14.1.1970\r\n        //(1.1.1970 plus blockingDuration).\r\n        require(now >= lastNegativeVoting.add(blockingDuration));\r\n\r\n        currentProposal = Proposal(_addr, _hash, _value, now, 0, 0);\r\n    }\r\n\r\n    function vote(bool _vote) public returns (uint256) {\r\n        require(isVoteOngoing()); // vote needs to be ongoing\r\n        Account storage account = updateAccount(msg.sender, UpdateMode.Vote);\r\n        uint256 votes = account.valueModVote; //available votes\r\n        require(votes > 0); //voter must have a vote left, either by not voting yet, or have modum tokens\r\n\r\n        if(_vote) {\r\n            currentProposal.yay = currentProposal.yay.add(votes);\r\n        }\r\n        else {\r\n            currentProposal.nay = currentProposal.nay.add(votes);\r\n        }\r\n\r\n        account.valueModVote = 0;\r\n        Voted(msg.sender, _vote, votes);\r\n        return votes;\r\n    }\r\n\r\n    function showVotes(address _addr) public constant returns (uint256) {\r\n        Account memory account = accounts[_addr];\r\n        if(account.lastProposalStartTime < currentProposal.startTime || // the user did set his token power yet\r\n            (account.lastProposalStartTime == 0 && currentProposal.startTime == 0)) {\r\n            return account.valueMod;\r\n        }\r\n        return account.valueModVote;\r\n    }\r\n\r\n    // The voting can be claimed by the owner of this contract\r\n    function claimVotingProposal() public {\r\n        require(msg.sender == owner); //only owner can claim proposal\r\n        require(isProposalActive()); // proposal active\r\n        require(isVotingPhaseOver()); // voting has already ended\r\n\r\n        if(currentProposal.yay > currentProposal.nay && currentProposal.valueMod > 0) {\r\n            //Vote was accepted\r\n            Account storage account = updateAccount(owner, UpdateMode.Both);\r\n            uint256 valueMod = currentProposal.valueMod;\r\n            account.valueMod = account.valueMod.add(valueMod); //add tokens to owner\r\n            totalSupply = totalSupply.add(valueMod);\r\n            lockedTokens = lockedTokens.sub(valueMod);\r\n        } else if(currentProposal.yay <= currentProposal.nay) {\r\n            //in case of a negative vote, set the time of this negative\r\n            //vote to the end of the negative voting period.\r\n            //This will prevent any new voting to be conducted.\r\n            lastNegativeVoting = currentProposal.startTime.add(votingDuration);\r\n        }\r\n        delete currentProposal; //proposal ended\r\n    }\r\n\r\n    function isProposalActive() public constant returns (bool)  {\r\n        return currentProposal.hash != bytes32(0);\r\n    }\r\n\r\n    function isVoteOngoing() public constant returns (bool)  {\r\n        return isProposalActive()\r\n            && now >= currentProposal.startTime\r\n            && now < currentProposal.startTime.add(votingDuration);\r\n        //its safe to use it for longer periods:\r\n        //https://ethereum.stackexchange.com/questions/6795/is-block-timestamp-safe-for-longer-time-periods\r\n    }\r\n\r\n    function isVotingPhaseOver() public constant returns (bool)  {\r\n        //its safe to use it for longer periods:\r\n        //https://ethereum.stackexchange.com/questions/6795/is-block-timestamp-safe-for-longer-time-periods\r\n        return now >= currentProposal.startTime.add(votingDuration);\r\n    }\r\n\r\n    //*********************** Minting *****************************************\r\n    function mint(address[] _recipient, uint256[] _value) public {\r\n        require(msg.sender == owner); //only owner can claim proposal\r\n        require(!mintDone); //only during minting\r\n        //require(_recipient.length == _value.length); //input need to be of same size\r\n        //we know what we are doing... remove check to save gas\r\n\r\n        //we want to mint a couple of accounts\r\n        for (uint8 i=0; i<_recipient.length; i++) {\r\n            \r\n            //require(lockedTokens.add(totalSupply).add(_value[i]) <= maxTokens);\r\n            //do the check in the mintDone\r\n\r\n            //121 gas can be saved by creating temporary variables\r\n            address tmpRecipient = _recipient[i];\r\n            uint tmpValue = _value[i];\r\n\r\n            //no need to update account, as we have not set minting to true. This means\r\n            //nobody can start a proposal (isVoteOngoing() is always false) and airdrop\r\n            //cannot be done either totalDropPerUnlockedToken is 0 thus, bonus is always\r\n            //zero.\r\n            Account storage account = accounts[tmpRecipient];\r\n            account.valueMod = account.valueMod.add(tmpValue);\r\n            //if this remains 0, we cannot calculate the time period when the user claimed\r\n            //his airdrop, thus, set it to now\r\n            account.lastAirdropClaimTime = now;\r\n            totalSupply = totalSupply.add(tmpValue); //create the tokens and add to recipient\r\n            Transfer(msg.sender, tmpRecipient, tmpValue);\r\n        }\r\n    }\r\n\r\n    function setMintDone() public {\r\n        require(msg.sender == owner);\r\n        require(!mintDone); //only in minting phase\r\n        //here we check that we never exceed the 30mio max tokens. This includes\r\n        //the locked and the unlocked tokens.\r\n        require(lockedTokens.add(totalSupply) <= maxTokens);\r\n        mintDone = true; //end the minting\r\n    }\r\n\r\n    //updates an account for voting or airdrop or both. This is required to be able to fix the amount of tokens before\r\n    //a vote or airdrop happend.\r\n    function updateAccount(address _addr, UpdateMode mode) internal returns (Account storage){\r\n        Account storage account = accounts[_addr];\r\n        if(mode == UpdateMode.Vote || mode == UpdateMode.Both) {\r\n            if(isVoteOngoing() && account.lastProposalStartTime < currentProposal.startTime) {// the user did set his token power yet\r\n                account.valueModVote = account.valueMod;\r\n                account.lastProposalStartTime = currentProposal.startTime;\r\n            }\r\n        }\r\n\r\n        if(mode == UpdateMode.Wei || mode == UpdateMode.Both) {\r\n            uint256 bonus = totalDropPerUnlockedToken.sub(account.lastAirdropWei);\r\n            if(bonus != 0) {\r\n                account.bonusWei = account.bonusWei.add(bonus.mul(account.valueMod));\r\n                account.lastAirdropWei = totalDropPerUnlockedToken;\r\n            }\r\n        }\r\n\r\n        return account;\r\n    }\r\n\r\n    //*********************** Airdrop ************************************************\r\n    //default function to pay bonus, anybody that sends eth to this contract will distribute the wei\r\n    //to their token holders\r\n    //Dividend payment / Airdrop\r\n    function() public payable {\r\n        require(mintDone); //minting needs to be over\r\n        require(msg.sender == owner); //ETH payment need to be one-way only, from modum to tokenholders, confirmed by Lykke\r\n        payout(msg.value);\r\n    }\r\n    \r\n    //anybody can pay and add address that will be checked if they\r\n    //can be added to the bonus\r\n    function payBonus(address[] _addr) public payable {\r\n        require(msg.sender == owner);  //ETH payment need to be one-way only, from modum to tokenholders, confirmed by Lykke\r\n        uint256 totalWei = 0;\r\n        for (uint8 i=0; i<_addr.length; i++) {\r\n            Account storage account = updateAccount(_addr[i], UpdateMode.Wei);\r\n            if(now >= account.lastAirdropClaimTime + redistributionTimeout) {\r\n                totalWei += account.bonusWei;\r\n                account.bonusWei = 0;\r\n                account.lastAirdropClaimTime = now;\r\n            } else {\r\n                revert();\r\n            }\r\n        }\r\n        payout(msg.value.add(totalWei));\r\n    }\r\n    \r\n    function payout(uint256 valueWei) internal {\r\n        uint256 value = valueWei.add(rounding); //add old rounding\r\n        rounding = value % totalSupply; //ensure no rounding error\r\n        uint256 weiPerToken = value.sub(rounding).div(totalSupply);\r\n        totalDropPerUnlockedToken = totalDropPerUnlockedToken.add(weiPerToken); //account for locked tokens and add the drop\r\n        Payout(weiPerToken);\r\n    }\r\n\r\n    function showBonus(address _addr) public constant returns (uint256) {\r\n        uint256 bonus = totalDropPerUnlockedToken.sub(accounts[_addr].lastAirdropWei);\r\n        if(bonus != 0) {\r\n            return accounts[_addr].bonusWei.add(bonus.mul(accounts[_addr].valueMod));\r\n        }\r\n        return accounts[_addr].bonusWei;\r\n    }\r\n\r\n    function claimBonus() public returns (uint256) {\r\n        require(mintDone); //minting needs to be over\r\n\r\n        Account storage account = updateAccount(msg.sender, UpdateMode.Wei);\r\n        uint256 sendValue = account.bonusWei; //fetch the values\r\n\r\n        if(sendValue != 0) {\r\n            account.bonusWei = 0; //set to zero (before, against reentry)\r\n            account.lastAirdropClaimTime = now; //mark as collected now\r\n            msg.sender.transfer(sendValue); //send the bonus to the correct account\r\n            return sendValue;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    //****************************** ERC20 ************************************\r\n\r\n    // Get the account balance of another account with address _owner\r\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n        return accounts[_owner].valueMod;\r\n    }\r\n\r\n    // Send _value amount of tokens to address _to\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        require(mintDone);\r\n        require(_value > 0);\r\n        Account memory tmpFrom = accounts[msg.sender];\r\n        require(tmpFrom.valueMod >= _value);\r\n\r\n        Account storage from = updateAccount(msg.sender, UpdateMode.Both);\r\n        Account storage to = updateAccount(_to, UpdateMode.Both);\r\n        from.valueMod = from.valueMod.sub(_value);\r\n        to.valueMod = to.valueMod.add(_value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    // Send _value amount of tokens from address _from to address _to\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        require(mintDone);\r\n        require(_value > 0);\r\n        Account memory tmpFrom = accounts[_from];\r\n        require(tmpFrom.valueMod >= _value);\r\n        require(allowed[_from][msg.sender] >= _value);\r\n\r\n        Account storage from = updateAccount(_from, UpdateMode.Both);\r\n        Account storage to = updateAccount(_to, UpdateMode.Both);\r\n        from.valueMod = from.valueMod.sub(_value);\r\n        to.valueMod = to.valueMod.add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    // ********************** approve, allowance, increaseApproval, and decreaseApproval used from:\r\n    // https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/StandardToken.sol\r\n    //\r\n    // changed from uint to uint256 as this is considered to be best practice.\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _value The amount of tokens to be spent.\r\n     */\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        // To change the approve amount you first have to reduce the addresses`\r\n        //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n        //  already 0 to mitigate the race condition described here:\r\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param _owner address The address which owns the funds.\r\n     * @param _spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /*\r\n     * approve should be called when allowed[_spender] == 0. To increment\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     */\r\n    function increaseApproval(address _spender, uint256 _addedValue) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool success) {\r\n        uint256 oldValue = allowed[msg.sender][_spender];\r\n        if(_subtractedValue > oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"votingDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimVotingProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentProposal\",\"outputs\":[{\"name\":\"addr\",\"type\":\"string\"},{\"name\":\"hash\",\"type\":\"bytes32\"},{\"name\":\"valueMod\",\"type\":\"uint256\"},{\"name\":\"startTime\",\"type\":\"uint256\"},{\"name\":\"yay\",\"type\":\"uint256\"},{\"name\":\"nay\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rounding\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"showVotes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_vote\",\"type\":\"bool\"}],\"name\":\"vote\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"accounts\",\"outputs\":[{\"name\":\"lastProposalStartTime\",\"type\":\"uint256\"},{\"name\":\"lastAirdropWei\",\"type\":\"uint256\"},{\"name\":\"lastAirdropClaimTime\",\"type\":\"uint256\"},{\"name\":\"bonusWei\",\"type\":\"uint256\"},{\"name\":\"valueModVote\",\"type\":\"uint256\"},{\"name\":\"valueMod\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"string\"},{\"name\":\"_hash\",\"type\":\"bytes32\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"votingProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address[]\"}],\"name\":\"payBonus\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isProposalActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"redistributionTimeout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setMintDone\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isVotingPhaseOver\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintDone\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"showBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastNegativeVoting\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address[]\"},{\"name\":\"_value\",\"type\":\"uint256[]\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blockingDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDropPerUnlockedToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isVoteOngoing\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"option\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"votes\",\"type\":\"uint256\"}],\"name\":\"Voted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"weiPerToken\",\"type\":\"uint256\"}],\"name\":\"Payout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"ModumToken","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://6378abcfaefceadc69da8c6a5ce5584d9407c8c1b14d336a43049204bdd50245"}]}