{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n    uint256 public totalSupply = 90000000 * 10 ** 18;\r\n\r\n    function balanceOf(address who) public constant returns (uint256);\r\n\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n    function allowance(address owner, address spender) public constant returns (uint256);\r\n\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) public balances;\r\n\r\n    /**\r\n    * @dev transfer token for a specified address\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n\r\n        // SafeMath.sub will throw if there is not enough balance.\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param _owner The address to query the the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another\r\n     * @param _from address The address which you want to send tokens from\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n\r\n        uint256 _allowance = allowed[_from][msg.sender];\r\n\r\n        // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n        // require (_value <= _allowance);\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = _allowance.sub(_value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     *\r\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _value The amount of tokens to be spent.\r\n     */\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param _owner address The address which owns the funds.\r\n     * @param _spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n     * approve should be called when allowed[_spender] == 0. To increment\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     */\r\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseApproval(address _spender, uint _subtractedValue)\r\n    public returns (bool success) {\r\n        uint oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        }\r\n        else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n\r\n    address public owner;\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) onlyOwner public {\r\n        require(newOwner != address(0));\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n/*\r\n * ChargCoinContract\r\n *\r\n * Simple ERC20 Token example, with crowdsale token creation\r\n */\r\ncontract ChargCoinContract is StandardToken, Ownable {\r\n\r\n    string public standard = \"CHG\";\r\n    string public name = \"Charg Coin\";\r\n    string public symbol = \"CHG\";\r\n\r\n    uint public decimals = 18;\r\n\r\n    address public multisig = 0x482EFd447bE88748e7625e2b7c522c388970B790;\r\n\r\n    struct ChargingData {\r\n    address node;\r\n    uint startTime;\r\n    uint endTime;\r\n    uint256 fixedRate;\r\n    bool initialized;\r\n    uint256 predefinedAmount;\r\n    }\r\n\r\n    struct ParkingData {\r\n    address node;\r\n    uint startTime;\r\n    uint endTime;\r\n    uint256 fixedRate;\r\n    bool initialized;\r\n    uint256 predefinedAmount;\r\n    }\r\n\r\n    mapping (address => uint256) public authorized;\r\n\r\n    mapping (address => uint256) public rateOfCharging;\r\n    mapping (address => uint256) public rateOfParking;\r\n\r\n    mapping (address => ChargingData) public chargingSwitches;\r\n    mapping (address => ParkingData) public parkingSwitches;\r\n\r\n    mapping (address => uint256) public reservedFundsCharging;\r\n    mapping (address => uint256) public reservedFundsParking;\r\n\r\n    // 1 ETH = 500 CHARG tokens (1 CHARG = 0.59 USD)\r\n    uint PRICE = 500;\r\n\r\n    struct ContributorData {\r\n    uint contributionAmount;\r\n    uint tokensIssued;\r\n    }\r\n\r\n    function ChargCoinContract() public {\r\n        balances[msg.sender] = totalSupply;\r\n    }\r\n\r\n    mapping (address => ContributorData) public contributorList;\r\n\r\n    uint nextContributorIndex;\r\n\r\n    mapping (uint => address) contributorIndexes;\r\n\r\n    state public crowdsaleState = state.pendingStart;\r\n    enum state {pendingStart, crowdsale, crowdsaleEnded}\r\n\r\n    event CrowdsaleStarted(uint blockNumber);\r\n\r\n    event CrowdsaleEnded(uint blockNumber);\r\n\r\n    event ErrorSendingETH(address to, uint amount);\r\n\r\n    event MinCapReached(uint blockNumber);\r\n\r\n    event MaxCapReached(uint blockNumber);\r\n\r\n    uint public constant BEGIN_TIME = 1513896982;\r\n\r\n    uint public constant END_TIME = 1545432981;\r\n\r\n    uint public minCap = 1 ether;\r\n\r\n    uint public maxCap = 70200 ether;\r\n\r\n    uint public ethRaised = 0;\r\n\r\n    uint public totalSupply = 90000000 * 10 ** decimals;\r\n\r\n    uint crowdsaleTokenCap = 10000000 * 10 ** decimals; // 39%\r\n    uint foundersAndTeamTokens = 9000000 * 10 ** decimals; // 10%\r\n    uint slushFundTokens = 45900000 * 10 ** decimals; // 51%\r\n\r\n    bool foundersAndTeamTokensClaimed = false;\r\n    bool slushFundTokensClaimed = false;\r\n\r\n    uint nextContributorToClaim;\r\n\r\n    mapping (address => bool) hasClaimedEthWhenFail;\r\n\r\n    function() payable public {\r\n        require(msg.value != 0);\r\n        require(crowdsaleState != state.crowdsaleEnded);\r\n        // Check if crowdsale has ended\r\n\r\n        bool stateChanged = checkCrowdsaleState();\r\n        // Check blocks and calibrate crowdsale state\r\n\r\n        if (crowdsaleState == state.crowdsale) {\r\n            createTokens(msg.sender);\r\n            // Process transaction and issue tokens\r\n        }\r\n        else {\r\n            refundTransaction(stateChanged);\r\n            // Set state and return funds or throw\r\n        }\r\n    }\r\n\r\n    //\r\n    // Check crowdsale state and calibrate it\r\n    //\r\n    function checkCrowdsaleState() internal returns (bool) {\r\n        if (ethRaised >= maxCap && crowdsaleState != state.crowdsaleEnded) {// Check if max cap is reached\r\n            crowdsaleState = state.crowdsaleEnded;\r\n            CrowdsaleEnded(block.number);\r\n            // Raise event\r\n            return true;\r\n        }\r\n\r\n        if (now >= END_TIME) {\r\n            crowdsaleState = state.crowdsaleEnded;\r\n            CrowdsaleEnded(block.number);\r\n            // Raise event\r\n            return true;\r\n        }\r\n\r\n        if (now >= BEGIN_TIME && now < END_TIME) {// Check if we are in crowdsale state\r\n            if (crowdsaleState != state.crowdsale) {// Check if state needs to be changed\r\n                crowdsaleState = state.crowdsale;\r\n                // Set new state\r\n                CrowdsaleStarted(block.number);\r\n                // Raise event\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    //\r\n    // Decide if throw or only return ether\r\n    //\r\n    function refundTransaction(bool _stateChanged) internal {\r\n        if (_stateChanged) {\r\n            msg.sender.transfer(msg.value);\r\n        }\r\n        else {\r\n            revert();\r\n        }\r\n    }\r\n\r\n    function createTokens(address _contributor) payable public {\r\n\r\n        uint _amount = msg.value;\r\n\r\n        uint contributionAmount = _amount;\r\n        uint returnAmount = 0;\r\n\r\n        if (_amount > (maxCap - ethRaised)) {// Check if max contribution is lower than _amount sent\r\n            contributionAmount = maxCap - ethRaised;\r\n            // Set that user contibutes his maximum alowed contribution\r\n            returnAmount = _amount - contributionAmount;\r\n            // Calculate how much he must get back\r\n        }\r\n\r\n        if (ethRaised + contributionAmount > minCap && minCap > ethRaised) {\r\n            MinCapReached(block.number);\r\n        }\r\n\r\n        if (ethRaised + contributionAmount == maxCap && ethRaised < maxCap) {\r\n            MaxCapReached(block.number);\r\n        }\r\n\r\n        if (contributorList[_contributor].contributionAmount == 0) {\r\n            contributorIndexes[nextContributorIndex] = _contributor;\r\n            nextContributorIndex += 1;\r\n        }\r\n\r\n        contributorList[_contributor].contributionAmount += contributionAmount;\r\n        ethRaised += contributionAmount;\r\n        // Add to eth raised\r\n\r\n        uint256 tokenAmount = calculateEthToChargcoin(contributionAmount);\r\n        // Calculate how much tokens must contributor get\r\n        if (tokenAmount > 0) {\r\n            transferToContributor(_contributor, tokenAmount);\r\n            contributorList[_contributor].tokensIssued += tokenAmount;\r\n            // log token issuance\r\n        }\r\n\r\n        if (!multisig.send(msg.value)) {\r\n            revert();\r\n        }\r\n    }\r\n\r\n\r\n    function transferToContributor(address _to, uint256 _value)  public {\r\n        balances[owner] = balances[owner].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n    }\r\n\r\n    function calculateEthToChargcoin(uint _eth) constant public returns (uint256) {\r\n\r\n        uint tokens = _eth.mul(getPrice());\r\n        uint percentage = 0;\r\n\r\n        if (ethRaised > 0) {\r\n            percentage = ethRaised * 100 / maxCap;\r\n        }\r\n\r\n        return tokens + getAmountBonus(tokens);\r\n    }\r\n\r\n    function getAmountBonus(uint tokens) pure public returns (uint) {\r\n        uint amountBonus = 0;\r\n\r\n        if (tokens >= 10000) amountBonus = tokens;\r\n        else if (tokens >= 5000) amountBonus = tokens * 60 / 100;\r\n        else if (tokens >= 1000) amountBonus = tokens * 30 / 100;\r\n        else if (tokens >= 500) amountBonus = tokens * 10 / 100;\r\n        else if (tokens >= 100) amountBonus = tokens * 5 / 100;\r\n        else if (tokens >= 10) amountBonus = tokens * 1 / 100;\r\n\r\n        return amountBonus;\r\n    }\r\n\r\n    // replace this with any other price function\r\n    function getPrice() constant public returns (uint result) {\r\n        return PRICE;\r\n    }\r\n\r\n    //\r\n    // Owner can batch return contributors contributions(eth)\r\n    //\r\n    function batchReturnEthIfFailed(uint _numberOfReturns) onlyOwner public {\r\n        require(crowdsaleState != state.crowdsaleEnded);\r\n        // Check if crowdsale has ended\r\n        require(ethRaised < minCap);\r\n        // Check if crowdsale has failed\r\n        address currentParticipantAddress;\r\n        uint contribution;\r\n        for (uint cnt = 0; cnt < _numberOfReturns; cnt++) {\r\n            currentParticipantAddress = contributorIndexes[nextContributorToClaim];\r\n            // Get next unclaimed participant\r\n            if (currentParticipantAddress == 0x0) return;\r\n            // Check if all the participants were compensated\r\n            if (!hasClaimedEthWhenFail[currentParticipantAddress]) {// Check if participant has already claimed\r\n                contribution = contributorList[currentParticipantAddress].contributionAmount;\r\n                // Get contribution of participant\r\n                hasClaimedEthWhenFail[currentParticipantAddress] = true;\r\n                // Set that he has claimed\r\n                balances[currentParticipantAddress] = 0;\r\n                if (!currentParticipantAddress.send(contribution)) {// Refund eth\r\n                    ErrorSendingETH(currentParticipantAddress, contribution);\r\n                    // If there is an issue raise event for manual recovery\r\n                }\r\n            }\r\n            nextContributorToClaim += 1;\r\n            // Repeat\r\n        }\r\n    }\r\n\r\n    //\r\n    // Owner can set multisig address for crowdsale\r\n    //\r\n    function setMultisigAddress(address _newAddress) onlyOwner public {\r\n        multisig = _newAddress;\r\n    }\r\n\r\n    //\r\n    // Registers node with rate\r\n    //\r\n    function registerNode(uint256 chargingRate, uint256 parkingRate) public {\r\n        if (authorized[msg.sender] == 1) revert();\r\n\r\n        rateOfCharging[msg.sender] = chargingRate;\r\n        rateOfParking[msg.sender] = parkingRate;\r\n        authorized[msg.sender] = 1;\r\n    }\r\n\r\n    // \r\n    // Block node\r\n    //\r\n    function blockNode (address node) onlyOwner public {\r\n        authorized[node] = 0;\r\n    }\r\n\r\n    //\r\n    // Updates node charging rate\r\n    // \r\n    function updateChargingRate (uint256 rate) public {\r\n        rateOfCharging[msg.sender] = rate;\r\n    }\r\n\r\n    //\r\n    // Updates node parking rate\r\n    // \r\n    function updateParkingRate (uint256 rate) public {\r\n        rateOfCharging[msg.sender] = rate;\r\n    }\r\n\r\n    function chargeOn (address node, uint time) public {\r\n        // Prevent from not authorized nodes\r\n        if (authorized[node] == 0) revert();\r\n        // Prevent from double charging\r\n        if (chargingSwitches[msg.sender].initialized) revert();\r\n\r\n        // Determine endTime\r\n        uint endTime = now + time;\r\n\r\n        // Prevent from past dates\r\n        if (endTime <= now) revert();\r\n\r\n        // Calculate the amount of tokens has to be taken from users account\r\n        uint256 predefinedAmount = (endTime - now) * rateOfCharging[node];\r\n\r\n        if (balances[msg.sender] < predefinedAmount) revert();\r\n\r\n        chargingSwitches[msg.sender] = ChargingData(node, now, endTime, rateOfCharging[node], true, predefinedAmount);\r\n        balances[msg.sender] = balances[msg.sender].sub(predefinedAmount);\r\n        reservedFundsCharging[msg.sender] = reservedFundsCharging[msg.sender].add(predefinedAmount);\r\n    }\r\n\r\n    function chargeOff (address node) public {\r\n        // Check that initialization happened\r\n        if (!chargingSwitches[msg.sender].initialized) revert();\r\n        // Calculate the amount depending on rate\r\n        uint256 amount = (now - chargingSwitches[msg.sender].startTime) * chargingSwitches[msg.sender].fixedRate;\r\n        // Maximum can be predefinedAmount, if it less than that, return tokens\r\n        amount = amount > chargingSwitches[msg.sender].predefinedAmount ? chargingSwitches[msg.sender].predefinedAmount : amount;\r\n\r\n        // Take tokens from reserFunds and put it on balance\r\n        balances[node] = balances[node] + amount;\r\n        reservedFundsCharging[msg.sender] = reservedFundsCharging[msg.sender] - amount;\r\n\r\n        // When amount is less than predefinedAmount, return other tokens to user\r\n        if (reservedFundsCharging[msg.sender] > 0) {\r\n            balances[msg.sender] = balances[msg.sender] + reservedFundsCharging[msg.sender];\r\n            reservedFundsCharging[msg.sender] = 0;\r\n        }\r\n\r\n        // Uninitialize\r\n        chargingSwitches[msg.sender].node = 0;\r\n        chargingSwitches[msg.sender].startTime = 0;\r\n        chargingSwitches[msg.sender].endTime = 0;\r\n        chargingSwitches[msg.sender].fixedRate = 0;\r\n        chargingSwitches[msg.sender].initialized = false;\r\n        chargingSwitches[msg.sender].predefinedAmount = 0;\r\n    }\r\n\r\n    function parkingOn (address node, uint time) public {\r\n        // Prevent from not authorized nodes\r\n        if (authorized[node] == 0) revert();\r\n        // Prevent from double charging\r\n        if (parkingSwitches[msg.sender].initialized) revert();\r\n\r\n        if (balances[msg.sender] < predefinedAmount) revert();\r\n\r\n        uint endTime = now + time;\r\n\r\n        // Prevent from past dates\r\n        if (endTime <= now) revert();\r\n\r\n        uint256 predefinedAmount = (endTime - now) * rateOfParking[node];\r\n\r\n        parkingSwitches[msg.sender] = ParkingData(node, now, endTime, rateOfParking[node], true, predefinedAmount);\r\n        balances[msg.sender] = balances[msg.sender].sub(predefinedAmount);\r\n        reservedFundsParking[msg.sender] = reservedFundsParking[msg.sender].add(predefinedAmount);\r\n    }\r\n\r\n    // Parking off     \r\n    function parkingOff (address node) public {\r\n        if (!parkingSwitches[msg.sender].initialized) revert();\r\n\r\n        // Calculate the amount depending on rate\r\n        uint256 amount = (now - parkingSwitches[msg.sender].startTime) * parkingSwitches[msg.sender].fixedRate;\r\n        // Maximum can be predefinedAmount, if it less than that, return tokens\r\n        amount = amount > parkingSwitches[msg.sender].predefinedAmount ? parkingSwitches[msg.sender].predefinedAmount : amount;\r\n\r\n        balances[node] = balances[node] + amount;\r\n        reservedFundsParking[msg.sender] = reservedFundsParking[msg.sender] - amount;\r\n\r\n        //  \r\n        if (reservedFundsParking[msg.sender] > 0) {\r\n            balances[msg.sender] = balances[msg.sender] + reservedFundsParking[msg.sender];\r\n            // all tokens taken, set to 0\r\n            reservedFundsParking[msg.sender] = 0;\r\n        }\r\n\r\n        // Uninitialize\r\n        parkingSwitches[msg.sender].node = 0;\r\n        parkingSwitches[msg.sender].startTime = 0;\r\n        parkingSwitches[msg.sender].endTime = 0;\r\n        parkingSwitches[msg.sender].fixedRate = 0;\r\n        parkingSwitches[msg.sender].initialized = false;\r\n        parkingSwitches[msg.sender].predefinedAmount = 0;\r\n    }\r\n}\r\n\r\ncontract ChgUsdConverter is Ownable{\r\n    address public contractAddress = 0xC4A86561cb0b7EA1214904f26E6D50FD357C7986;\r\n    address public dashboardAddress = 0x482EFd447bE88748e7625e2b7c522c388970B790;\r\n    uint public ETHUSDPRICE = 810;\r\n    uint public CHGUSDPRICE = 4; // $0.4\r\n\r\n    function setETHUSDPrice(uint newPrice) public {\r\n        if (msg.sender != dashboardAddress) revert();\r\n        \r\n        ETHUSDPRICE = newPrice;\r\n    }\r\n\r\n    function setCHGUSDPrice(uint newPrice) public {\r\n        if (msg.sender != dashboardAddress) revert();\r\n\r\n        CHGUSDPRICE = newPrice;\r\n    }\r\n\r\n    function calculateCHGAmountToEther(uint etherAmount) view public returns (uint){\r\n        return ((etherAmount * ETHUSDPRICE) / CHGUSDPRICE) * 10;\r\n    }\r\n\r\n    function balances(address a) view public returns (uint) {\r\n        ChargCoinContract c = ChargCoinContract(contractAddress);\r\n        return c.balances(a);\r\n    }\r\n\r\n    function currentBalance() view public returns (uint) {\r\n        ChargCoinContract c = ChargCoinContract(contractAddress);\r\n        return c.balances(address(this));\r\n    }\r\n\r\n    function() payable public {\r\n        uint calculatedAmount = calculateCHGAmountToEther(msg.value);\r\n\r\n        ChargCoinContract c = ChargCoinContract(contractAddress);\r\n\r\n        if (currentBalance() < calculatedAmount) {\r\n            revert();\r\n        }\r\n\r\n        if (!c.transfer(msg.sender, calculatedAmount)) {\r\n            revert();\r\n        }\r\n\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"dashboardAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETHUSDPRICE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"setETHUSDPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"setCHGUSDPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CHGUSDPRICE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"etherAmount\",\"type\":\"uint256\"}],\"name\":\"calculateCHGAmountToEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"ChgUsdConverter","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://e9889d81dadf5bea55505cb79d0685e082759180e67f1356ff8a28ac47c301ad"}]}