{"status":"1","message":"OK","result":[{"SourceCode":"contract DSAuthority {\r\n    function canCall(\r\n        address src, address dst, bytes4 sig\r\n    ) constant returns (bool);\r\n}\r\n\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority (address indexed authority);\r\n    event LogSetOwner     (address indexed owner);\r\n}\r\n\r\ncontract DSAuth is DSAuthEvents {\r\n    DSAuthority  public  authority;\r\n    address      public  owner;\r\n\r\n    function DSAuth() {\r\n        owner = msg.sender;\r\n        LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_)\r\n        auth\r\n    {\r\n        owner = owner_;\r\n        LogSetOwner(owner);\r\n    }\r\n\r\n    function setAuthority(DSAuthority authority_)\r\n        auth\r\n    {\r\n        authority = authority_;\r\n        LogSetAuthority(authority);\r\n    }\r\n\r\n    modifier auth {\r\n        assert(isAuthorized(msg.sender, msg.sig));\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal returns (bool) {\r\n        if (src == address(this)) {\r\n            return true;\r\n        } else if (src == owner) {\r\n            return true;\r\n        } else if (authority == DSAuthority(0)) {\r\n            return false;\r\n        } else {\r\n            return authority.canCall(src, this, sig);\r\n        }\r\n    }\r\n\r\n    function assert(bool x) internal {\r\n        if (!x) throw;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract ERC20 {\r\n    function totalSupply() constant returns (uint supply);\r\n    function balanceOf( address who ) constant returns (uint value);\r\n    function allowance( address owner, address spender ) constant returns (uint _allowance);\r\n\r\n    function transfer( address to, uint value) returns (bool ok);\r\n    function transferFrom( address from, address to, uint value) returns (bool ok);\r\n    function approve( address spender, uint value ) returns (bool ok);\r\n\r\n    event Transfer( address indexed from, address indexed to, uint value);\r\n    event Approval( address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract DSMath {\r\n    \r\n\r\n    function add(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        assert((z = x + y) >= x);\r\n    }\r\n\r\n    function sub(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        assert((z = x - y) <= x);\r\n    }\r\n\r\n    function mul(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        z = x * y;\r\n        assert(x == 0 || z / x == y);\r\n    }\r\n\r\n    function div(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        z = x / y;\r\n    }\r\n\r\n    function min(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n\r\n\r\n    function hadd(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        assert((z = x + y) >= x);\r\n    }\r\n\r\n    function hsub(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        assert((z = x - y) <= x);\r\n    }\r\n\r\n    function hmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        z = x * y;\r\n        assert(x == 0 || z / x == y);\r\n    }\r\n\r\n    function hdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        z = x / y;\r\n    }\r\n\r\n    function hmin(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function hmax(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n\r\n\r\n    function imin(int256 x, int256 y) constant internal returns (int256 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int256 x, int256 y) constant internal returns (int256 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    /*\r\n    WAD math\r\n     */\r\n\r\n    uint128 constant WAD = 10 ** 18;\r\n\r\n    function wadd(uint128 x, uint128 y) constant internal returns (uint128) {\r\n        return hadd(x, y);\r\n    }\r\n\r\n    function wsub(uint128 x, uint128 y) constant internal returns (uint128) {\r\n        return hsub(x, y);\r\n    }\r\n\r\n    function wmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        z = cast((uint256(x) * y + WAD / 2) / WAD);\r\n    }\r\n\r\n    function wdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        z = cast((uint256(x) * WAD + y / 2) / y);\r\n    }\r\n\r\n    function wmin(uint128 x, uint128 y) constant internal returns (uint128) {\r\n        return hmin(x, y);\r\n    }\r\n    function wmax(uint128 x, uint128 y) constant internal returns (uint128) {\r\n        return hmax(x, y);\r\n    }\r\n\r\n    /*\r\n    RAY math\r\n     */\r\n\r\n    uint128 constant RAY = 10 ** 27;\r\n\r\n    function radd(uint128 x, uint128 y) constant internal returns (uint128) {\r\n        return hadd(x, y);\r\n    }\r\n\r\n    function rsub(uint128 x, uint128 y) constant internal returns (uint128) {\r\n        return hsub(x, y);\r\n    }\r\n\r\n    function rmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        z = cast((uint256(x) * y + RAY / 2) / RAY);\r\n    }\r\n\r\n    function rdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        z = cast((uint256(x) * RAY + y / 2) / y);\r\n    }\r\n\r\n    function rpow(uint128 x, uint64 n) constant internal returns (uint128 z) {\r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n\r\n    function rmin(uint128 x, uint128 y) constant internal returns (uint128) {\r\n        return hmin(x, y);\r\n    }\r\n    function rmax(uint128 x, uint128 y) constant internal returns (uint128) {\r\n        return hmax(x, y);\r\n    }\r\n\r\n    function cast(uint256 x) constant internal returns (uint128 z) {\r\n        assert((z = uint128(x)) == x);\r\n    }\r\n\r\n}\r\n\r\ncontract IkuraStorage is DSMath, DSAuth {\r\n  \r\n  address[] ownerAddresses;\r\n\r\n  \r\n  mapping(address => uint) coinBalances;\r\n\r\n  \r\n  mapping(address => uint) tokenBalances;\r\n\r\n  \r\n  mapping(address => mapping (address => uint)) coinAllowances;\r\n\r\n  \r\n  uint _totalSupply = 0;\r\n\r\n  \r\n  \r\n  \r\n  uint _transferFeeRate = 500;\r\n\r\n  \r\n  \r\n  \r\n  uint8 _transferMinimumFee = 5;\r\n\r\n  address tokenAddress;\r\n  address multiSigAddress;\r\n  address authorityAddress;\r\n\r\n  \r\n  \r\n  \r\n  function IkuraStorage() DSAuth() {\r\n    /*address controllerAddress = 0x34c5605A4Ef1C98575DB6542179E55eE1f77A188;\r\n    owner = controllerAddress;\r\n    LogSetOwner(controllerAddress);*/\r\n  }\r\n\r\n  function changeToken(address tokenAddress_) auth {\r\n    tokenAddress = tokenAddress_;\r\n  }\r\n\r\n  function changeAssociation(address multiSigAddress_) auth {\r\n    multiSigAddress = multiSigAddress_;\r\n  }\r\n\r\n  function changeAuthority(address authorityAddress_) auth {\r\n    authorityAddress = authorityAddress_;\r\n  }\r\n\r\n  function totalSupply() auth returns (uint) {\r\n    return _totalSupply;\r\n  }\r\n  function addTotalSupply(uint amount) auth {\r\n    _totalSupply = add(_totalSupply, amount);\r\n  }\r\n  function subTotalSupply(uint amount) auth {\r\n    _totalSupply = sub(_totalSupply, amount);\r\n  }\r\n  function transferFeeRate() auth returns (uint) {\r\n    return _transferFeeRate;\r\n  }\r\n\r\n  function setTransferFeeRate(uint newTransferFeeRate) auth returns (bool) {\r\n    _transferFeeRate = newTransferFeeRate;\r\n\r\n    return true;\r\n  }\r\n\r\n  \r\n  \r\n  \r\n\r\n  function transferMinimumFee() auth returns (uint8) {\r\n    return _transferMinimumFee;\r\n  }\r\n\r\n  function setTransferMinimumFee(uint8 newTransferMinimumFee) auth {\r\n    _transferMinimumFee = newTransferMinimumFee;\r\n  }\r\n\r\n  function addOwnerAddress(address addr) internal returns (bool) {\r\n    ownerAddresses.push(addr);\r\n\r\n    return true;\r\n  }\r\n\r\n  function removeOwnerAddress(address addr) internal returns (bool) {\r\n    uint i = 0;\r\n\r\n    while (ownerAddresses[i] != addr) { i++; }\r\n\r\n    while (i < ownerAddresses.length - 1) {\r\n      ownerAddresses[i] = ownerAddresses[i + 1];\r\n      i++;\r\n    }\r\n\r\n    ownerAddresses.length--;\r\n\r\n    return true;\r\n  }\r\n\r\n  function primaryOwner() auth returns (address) {\r\n    return ownerAddresses[0];\r\n  }\r\n\r\n  function isOwnerAddress(address addr) auth returns (bool) {\r\n    for (uint i = 0; i < ownerAddresses.length; i++) {\r\n      if (ownerAddresses[i] == addr) return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  function numOwnerAddress() auth constant returns (uint) {\r\n    return ownerAddresses.length;\r\n  }\r\n\r\n  \r\n  \r\n  \r\n\r\n  function coinBalance(address addr) auth returns (uint) {\r\n    return coinBalances[addr];\r\n  }\r\n\r\n  function addCoinBalance(address addr, uint amount) auth returns (bool) {\r\n    coinBalances[addr] = add(coinBalances[addr], amount);\r\n\r\n    return true;\r\n  }\r\n\r\n  function subCoinBalance(address addr, uint amount) auth returns (bool) {\r\n    coinBalances[addr] = sub(coinBalances[addr], amount);\r\n\r\n    return true;\r\n  }\r\n\r\n  \r\n  \r\n  \r\n\r\n  function tokenBalance(address addr) auth returns (uint) {\r\n    return tokenBalances[addr];\r\n  }\r\n\r\n  function addTokenBalance(address addr, uint amount) auth returns (bool) {\r\n    tokenBalances[addr] = add(tokenBalances[addr], amount);\r\n\r\n    if (tokenBalances[addr] > 0 && !isOwnerAddress(addr)) {\r\n      addOwnerAddress(addr);\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  function subTokenBalance(address addr, uint amount) auth returns (bool) {\r\n    tokenBalances[addr] = sub(tokenBalances[addr], amount);\r\n\r\n    if (tokenBalances[addr] <= 0) {\r\n      removeOwnerAddress(addr);\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  \r\n  \r\n  \r\n\r\n  function coinAllowance(address owner_, address spender) auth returns (uint) {\r\n    return coinAllowances[owner_][spender];\r\n  }\r\n\r\n  function addCoinAllowance(address owner_, address spender, uint amount) auth returns (bool) {\r\n    coinAllowances[owner_][spender] = add(coinAllowances[owner_][spender], amount);\r\n\r\n    return true;\r\n  }\r\n\r\n  function subCoinAllowance(address owner_, address spender, uint amount) auth returns (bool) {\r\n    coinAllowances[owner_][spender] = sub(coinAllowances[owner_][spender], amount);\r\n\r\n    return true;\r\n  }\r\n\r\n  function setCoinAllowance(address owner_, address spender, uint amount) auth returns (bool) {\r\n    coinAllowances[owner_][spender] = amount;\r\n\r\n    return true;\r\n  }\r\n\r\n  function isAuthorized(address src, bytes4 sig) internal returns (bool) {\r\n    sig; \r\n\r\n    return  src == address(this) ||\r\n            src == owner ||\r\n            src == tokenAddress ||\r\n            src == authorityAddress ||\r\n            src == multiSigAddress;\r\n  }\r\n}\r\n\r\ncontract IkuraTokenEvent {\r\n  /** オーナーがdJPYを鋳造した際に発火するイベント */\r\n  event IkuraMint(address indexed owner, uint);\r\n\r\n  /** オーナーがdJPYを消却した際に発火するイベント */\r\n  event IkuraBurn(address indexed owner, uint);\r\n\r\n  /** トークンの移動時に発火するイベント */\r\n  event IkuraTransferToken(address indexed from, address indexed to, uint value);\r\n\r\n  /** 手数料が発生したときに発火するイベント */\r\n  event IkuraTransferFee(address indexed from, address indexed to, address indexed owner, uint value);\r\n\r\n  event IkuraTransfer(address indexed from, address indexed to, uint value);\r\n\r\n  /** 送金許可イベント */\r\n  event IkuraApproval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract IkuraAssociation is DSMath, DSAuth {\r\n  \r\n  \r\n  \r\n\r\n  \r\n  uint public confirmTotalTokenThreshold = 50;\r\n\r\n  \r\n  \r\n  \r\n\r\n  \r\n  IkuraStorage _storage;\r\n  IkuraToken _token;\r\n\r\n  \r\n  Proposal[] mintProposals;\r\n  Proposal[] burnProposals;\r\n  Proposal[] transferMinimumFeeProposals;\r\n  Proposal[] transferFeeRateProposals;\r\n\r\n  mapping (bytes32 => Proposal[]) proposals;\r\n\r\n  struct Proposal {\r\n    address proposer;                     \r\n    bytes32 digest;                       \r\n    bool executed;                        \r\n    uint createdAt;                       \r\n    uint expireAt;                        \r\n    address[] confirmers;                 \r\n    uint amount;                          \r\n    uint8 transferMinimumFee;             \r\n    uint transferFeeRate;                 \r\n  }\r\n\r\n  \r\n  \r\n  \r\n\r\n  event MintProposalAdded(uint proposalId, address proposer, uint amount);\r\n  event MintConfirmed(uint proposalId, address confirmer, uint amount);\r\n  event MintExecuted(uint proposalId, address proposer, uint amount);\r\n\r\n  event BurnProposalAdded(uint proposalId, address proposer, uint amount);\r\n  event BurnConfirmed(uint proposalId, address confirmer, uint amount);\r\n  event BurnExecuted(uint proposalId, address proposer, uint amount);\r\n\r\n  event TransferMinimumFeeProposalAdded(uint proposalId, address proposer, uint8 transferMinimumFee);\r\n  event TransferMinimumFeeConfirmed(uint proposalId, address confirmer, uint8 transferMinimumFee);\r\n  event TransferMinimumFeeExecuted(uint proposalId, address proposer, uint8 transferMinimumFee);\r\n\r\n  event TransferFeeRateProposalAdded(uint proposalId, address proposer, uint transferFeeRate);\r\n  event TransferFeeRateConfirmed(uint proposalId, address confirmer, uint transferFeeRate);\r\n  event TransferFeeRateExecuted(uint proposalId, address proposer, uint transferFeeRate);\r\n\r\n  function IkuraAssociation() {\r\n    proposals[sha3('mint')] = mintProposals;\r\n    proposals[sha3('burn')] = burnProposals;\r\n    proposals[sha3('transferMinimumFee')] = transferMinimumFeeProposals;\r\n    proposals[sha3('transferFeeRate')] = transferFeeRateProposals;\r\n\r\n  }\r\n\r\n  function changeStorage(IkuraStorage newStorage) auth returns (bool) {\r\n    _storage = newStorage;\r\n\r\n    return true;\r\n  }\r\n\r\n  function changeToken(IkuraToken token_) auth returns (bool) {\r\n    _token = token_;\r\n\r\n    return true;\r\n  }\r\n\r\n  function newProposal(bytes32 type_, address proposer, uint amount, uint8 transferMinimumFee, uint transferFeeRate, bytes transationBytecode) returns (uint) {\r\n    uint proposalId = proposals[type_].length++;\r\n    Proposal proposal = proposals[type_][proposalId];\r\n    proposal.proposer = proposer;\r\n    proposal.amount = amount;\r\n    proposal.transferMinimumFee = transferMinimumFee;\r\n    proposal.transferFeeRate = transferFeeRate;\r\n    proposal.digest = sha3(proposer, amount, transationBytecode);\r\n    proposal.executed = false;\r\n    proposal.createdAt = now;\r\n    proposal.expireAt = proposal.createdAt + 86400;\r\n\r\n    \r\n    \r\n    if (type_ == sha3('mint')) MintProposalAdded(proposalId, proposer, amount);\r\n    if (type_ == sha3('burn')) BurnProposalAdded(proposalId, proposer, amount);\r\n    if (type_ == sha3('transferMinimumFee')) TransferMinimumFeeProposalAdded(proposalId, proposer, transferMinimumFee);\r\n    if (type_ == sha3('transferFeeRate')) TransferFeeRateProposalAdded(proposalId, proposer, transferFeeRate);\r\n\r\n    \r\n    confirmProposal(type_, proposer, proposalId);\r\n\r\n    return proposalId;\r\n  }\r\n\r\n  function confirmProposal(bytes32 type_, address confirmer, uint proposalId) {\r\n    Proposal proposal = proposals[type_][proposalId];\r\n\r\n    \r\n    if (hasConfirmed(type_, confirmer, proposalId)) throw;\r\n\r\n    \r\n    proposal.confirmers.push(confirmer);\r\n\r\n    \r\n    \r\n    if (type_ == sha3('mint')) MintConfirmed(proposalId, confirmer, proposal.amount);\r\n    if (type_ == sha3('burn')) BurnConfirmed(proposalId, confirmer, proposal.amount);\r\n    if (type_ == sha3('transferMinimumFee')) TransferMinimumFeeConfirmed(proposalId, confirmer, proposal.transferMinimumFee);\r\n    if (type_ == sha3('transferFeeRate')) TransferFeeRateConfirmed(proposalId, confirmer, proposal.transferFeeRate);\r\n\r\n    if (isProposalExecutable(type_, proposalId, proposal.proposer, '')) {\r\n      proposal.executed = true;\r\n\r\n      \r\n      \r\n      if (type_ == sha3('mint')) executeMintProposal(proposalId);\r\n      if (type_ == sha3('burn')) executeBurnProposal(proposalId);\r\n      if (type_ == sha3('transferMinimumFee')) executeUpdateTransferMinimumFeeProposal(proposalId);\r\n      if (type_ == sha3('transferFeeRate')) executeUpdateTransferFeeRateProposal(proposalId);\r\n    }\r\n  }\r\n\r\n  function hasConfirmed(bytes32 type_, address addr, uint proposalId) returns (bool) {\r\n    Proposal proposal = proposals[type_][proposalId];\r\n    uint length = proposal.confirmers.length;\r\n\r\n    for (uint i = 0; i < length; i++) {\r\n      if (proposal.confirmers[i] == addr) return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  function confirmedTotalToken(bytes32 type_, uint proposalId) returns (uint) {\r\n    Proposal proposal = proposals[type_][proposalId];\r\n    uint length = proposal.confirmers.length;\r\n    uint total = 0;\r\n\r\n    for (uint i = 0; i < length; i++) {\r\n      total = add(total, _storage.tokenBalance(proposal.confirmers[i]));\r\n    }\r\n\r\n    return total;\r\n  }\r\n\r\n  function proposalExpireAt(bytes32 type_, uint proposalId) returns (uint) {\r\n    Proposal proposal = proposals[type_][proposalId];\r\n    return proposal.expireAt;\r\n  }\r\n\r\n  function isProposalExecutable(bytes32 type_, uint proposalId, address proposer, bytes transactionBytecode) returns (bool) {\r\n    Proposal proposal = proposals[type_][proposalId];\r\n\r\n    \r\n    if (_storage.numOwnerAddress() < 2) {\r\n      return true;\r\n    }\r\n\r\n    return  proposal.digest == sha3(proposer, proposal.amount, transactionBytecode) &&\r\n            isProposalNotExpired(type_, proposalId) &&\r\n            div(mul(100, confirmedTotalToken(type_, proposalId)), _storage.totalSupply()) > confirmTotalTokenThreshold;\r\n  }\r\n\r\n  function numberOfProposals(bytes32 type_) constant returns (uint) {\r\n    return proposals[type_].length;\r\n  }\r\n\r\n  function numberOfActiveProposals(bytes32 type_) constant returns (uint) {\r\n    uint numActiveProposal = 0;\r\n\r\n    for(uint i = 0; i < proposals[type_].length; i++) {\r\n      Proposal proposal = proposals[type_][i];\r\n\r\n      if (isProposalNotExpired(type_, i)) {\r\n        numActiveProposal++;\r\n      }\r\n    }\r\n\r\n    return numActiveProposal;\r\n  }\r\n\r\n  function isProposalNotExpired(bytes32 type_, uint proposalId) internal returns (bool) {\r\n    Proposal proposal = proposals[type_][proposalId];\r\n\r\n    return  !proposal.executed &&\r\n            now < proposal.expireAt;\r\n  }\r\n\r\n  function executeMintProposal(uint proposalId) internal {\r\n    Proposal proposal = proposals[sha3('mint')][proposalId];\r\n\r\n    \r\n    if (proposal.amount <= 0) throw;\r\n\r\n    MintExecuted(proposalId, proposal.proposer, proposal.amount);\r\n\r\n    \r\n    _storage.addTotalSupply(proposal.amount);\r\n    _storage.addCoinBalance(proposal.proposer, proposal.amount);\r\n    _storage.addTokenBalance(proposal.proposer, proposal.amount);\r\n  }\r\n\r\n  function executeBurnProposal(uint proposalId) internal {\r\n    Proposal proposal = proposals[sha3('burn')][proposalId];\r\n\r\n    \r\n    if (proposal.amount <= 0) throw;\r\n    if (_storage.coinBalance(proposal.proposer) < proposal.amount) throw;\r\n    if (_storage.tokenBalance(proposal.proposer) < proposal.amount) throw;\r\n\r\n    BurnExecuted(proposalId, proposal.proposer, proposal.amount);\r\n\r\n    \r\n    _storage.subTotalSupply(proposal.amount);\r\n    _storage.subCoinBalance(proposal.proposer, proposal.amount);\r\n    _storage.subTokenBalance(proposal.proposer, proposal.amount);\r\n  }\r\n\r\n  function executeUpdateTransferMinimumFeeProposal(uint proposalId) internal {\r\n    Proposal proposal = proposals[sha3('transferMinimumFee')][proposalId];\r\n\r\n    if (proposal.transferMinimumFee < 0) throw;\r\n\r\n    TransferMinimumFeeExecuted(proposalId, proposal.proposer, proposal.transferMinimumFee);\r\n\r\n    _storage.setTransferMinimumFee(proposal.transferMinimumFee);\r\n  }\r\n\r\n  function executeUpdateTransferFeeRateProposal(uint proposalId) internal {\r\n    Proposal proposal = proposals[sha3('transferFeeRate')][proposalId];\r\n\r\n    if (proposal.transferFeeRate < 0) throw;\r\n\r\n    TransferFeeRateExecuted(proposalId, proposal.proposer, proposal.transferFeeRate);\r\n\r\n    _storage.setTransferFeeRate(proposal.transferFeeRate);\r\n  }\r\n\r\n  function isAuthorized(address src, bytes4 sig) internal returns (bool) {\r\n    sig; \r\n\r\n    return  src == address(this) ||\r\n            src == owner ||\r\n            src == address(_token);\r\n  }\r\n}\r\nlibrary ProposalLibrary {\r\n  \r\n  \r\n  \r\n\r\n  \r\n  struct Entity {\r\n    IkuraStorage _storage;\r\n    IkuraAssociation _association;\r\n  }\r\n\r\n  function changeStorage(Entity storage self, address storage_) internal {\r\n    self._storage = IkuraStorage(storage_);\r\n  }\r\n\r\n  function changeAssociation(Entity storage self, address association_) internal {\r\n    self._association = IkuraAssociation(association_);\r\n  }\r\n\r\n  function updateTransferMinimumFee(Entity storage self, address sender, uint8 fee) returns (bool) {\r\n    if (fee < 0) throw;\r\n\r\n    self._association.newProposal(sha3('transferMinimumFee'), sender, 0, fee, 0, '');\r\n\r\n    return true;\r\n  }\r\n\r\n  function updateTransferFeeRate(Entity storage self, address sender, uint rate) returns (bool) {\r\n    if (rate < 0) throw;\r\n\r\n    self._association.newProposal(sha3('transferFeeRate'), sender, 0, 0, rate, '');\r\n\r\n    return true;\r\n  }\r\n\r\n  function mint(Entity storage self, address sender, uint amount) returns (bool) {\r\n    if (amount <= 0) throw;\r\n\r\n    self._association.newProposal(sha3('mint'), sender, amount, 0, 0, '');\r\n\r\n    return true;\r\n  }\r\n\r\n  function burn(Entity storage self, address sender, uint amount) returns (bool) {\r\n    if (amount <= 0) throw;\r\n    if (self._storage.coinBalance(sender) < amount) throw;\r\n    if (self._storage.tokenBalance(sender) < amount) throw;\r\n\r\n    self._association.newProposal(sha3('burn'), sender, amount, 0, 0, '');\r\n\r\n    return true;\r\n  }\r\n\r\n  function confirmProposal(Entity storage self, address sender, bytes32 type_, uint proposalId) {\r\n    self._association.confirmProposal(type_, sender, proposalId);\r\n  }\r\n\r\n  function numberOfProposals(Entity storage self, bytes32 type_) constant returns (uint) {\r\n    return self._association.numberOfProposals(type_);\r\n  }\r\n}\r\n\r\ncontract IkuraToken is IkuraTokenEvent, DSMath, DSAuth {\r\n  \r\n  \r\n  \r\n\r\n  /*using ProposalLibrary for ProposalLibrary.Entity;\r\n  ProposalLibrary.Entity proposalEntity;*/\r\n\r\n  \r\n  \r\n  \r\n\r\n  \r\n  IkuraStorage _storage;\r\n  IkuraAssociation _association;\r\n\r\n  function IkuraToken() DSAuth() {\r\n    \r\n    \r\n    \r\n    /*address controllerAddress = 0x34c5605A4Ef1C98575DB6542179E55eE1f77A188;\r\n    owner = controllerAddress;\r\n    LogSetOwner(controllerAddress);*/\r\n  }\r\n\r\n  function totalSupply(address sender) auth constant returns (uint) {\r\n    sender; \r\n\r\n    return _storage.totalSupply();\r\n  }\r\n\r\n  function balanceOf(address sender, address addr) auth constant returns (uint) {\r\n    sender; \r\n\r\n    return _storage.coinBalance(addr);\r\n  }\r\n\r\n  function transfer(address sender, address to, uint amount) auth returns (bool success) {\r\n    uint fee = transferFee(sender, sender, to, amount);\r\n\r\n    if (_storage.coinBalance(sender) < add(amount, fee)) throw;\r\n    if (amount <= 0) throw;\r\n\r\n    \r\n    address owner = selectOwnerAddressForTransactionFee(sender);\r\n\r\n    \r\n    _storage.subCoinBalance(sender, add(amount, fee));\r\n\r\n    \r\n    _storage.addCoinBalance(to, amount);\r\n\r\n    \r\n    _storage.addCoinBalance(owner, fee);\r\n\r\n    \r\n    IkuraTransfer(sender, to, amount);\r\n    IkuraTransferFee(sender, to, owner, fee);\r\n\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address sender, address from, address to, uint amount) auth returns (bool success) {\r\n    uint fee = transferFee(sender, from, to, amount);\r\n\r\n    if (_storage.coinBalance(from) < amount) throw;\r\n    if (_storage.coinAllowance(from, sender) < amount) throw;\r\n    if (amount <= 0) throw;\r\n    if (add(_storage.coinBalance(to), amount) <= _storage.coinBalance(to)) throw;\r\n    if (_storage.coinBalance(sender) < fee) throw;\r\n\r\n    \r\n    address owner = selectOwnerAddressForTransactionFee(sender);\r\n\r\n    \r\n    _storage.subCoinBalance(sender, fee);\r\n\r\n    \r\n    _storage.subCoinBalance(from, amount);\r\n\r\n    \r\n    _storage.subCoinAllowance(from, sender, amount);\r\n\r\n    \r\n    _storage.addCoinBalance(to, amount);\r\n\r\n    \r\n    _storage.addCoinBalance(owner, fee);\r\n\r\n    \r\n    IkuraTransfer(from, to, amount);\r\n\r\n    return true;\r\n  }\r\n\r\n  function approve(address sender, address spender, uint amount) auth returns (bool success) {\r\n    _storage.setCoinAllowance(sender, spender, amount);\r\n\r\n    \r\n    IkuraApproval(sender, spender, amount);\r\n\r\n    return true;\r\n  }\r\n\r\n\r\n  function allowance(address sender, address owner, address spender) auth constant returns (uint remaining) {\r\n    sender; \r\n\r\n    return _storage.coinAllowance(owner, spender);\r\n  }\r\n\r\n  \r\n  \r\n  \r\n\r\n\r\n  function tokenBalanceOf(address sender, address owner) auth constant returns (uint balance) {\r\n    sender; \r\n\r\n    return _storage.tokenBalance(owner);\r\n  }\r\n\r\n\r\n  function transferToken(address sender, address to, uint amount) auth returns (bool success) {\r\n    if (_storage.tokenBalance(sender) < amount ) throw;\r\n    if (amount <= 0) throw;\r\n    if (add(_storage.tokenBalance(to), amount) <= _storage.tokenBalance(to)) throw;\r\n\r\n    _storage.subTokenBalance(sender, amount);\r\n    _storage.addTokenBalance(to, amount);\r\n\r\n    IkuraTransferToken(sender, to, amount);\r\n\r\n    return true;\r\n  }\r\n\r\n\r\n  function transferFeeRate(address sender) auth constant returns (uint) {\r\n    sender; \r\n\r\n    return _storage.transferFeeRate();\r\n  }\r\n\r\n\r\n  function transferMinimumFee(address sender) auth constant returns (uint8) {\r\n    sender; \r\n\r\n    return _storage.transferMinimumFee();\r\n  }\r\n\r\n\r\n  function transferFee(address sender, address from, address to, uint amount) auth returns (uint) {\r\n    from; to; \r\n\r\n    uint rate = transferFeeRate(sender);\r\n    uint denominator = 1000000; \r\n    uint numerator = mul(amount, rate);\r\n\r\n    uint fee = div(numerator, denominator);\r\n    uint remainder = sub(numerator, mul(denominator, fee));\r\n\r\n    \r\n    if (remainder > 0) {\r\n      fee++;\r\n    }\r\n\r\n    if (fee < transferMinimumFee(sender)) {\r\n      fee = transferMinimumFee(sender);\r\n    }\r\n\r\n    return fee;\r\n  }\r\n\r\n\r\n  function updateTransferMinimumFee(address sender, uint8 fee) auth returns (bool) {\r\n    if (fee < 0) throw;\r\n\r\n    _association.newProposal(sha3('transferMinimumFee'), sender, 0, fee, 0, '');\r\n    return true;\r\n\r\n    /*return proposalEntity.updateTransferMinimumFee(sender, fee);*/\r\n  }\r\n\r\n\r\n  function updateTransferFeeRate(address sender, uint rate) auth returns (bool) {\r\n    if (rate < 0) throw;\r\n\r\n    _association.newProposal(sha3('transferFeeRate'), sender, 0, 0, rate, '');\r\n    return true;\r\n\r\n    /*return proposalEntity.updateTransferFeeRate(sender, rate);*/\r\n  }\r\n\r\n\r\n  function selectOwnerAddressForTransactionFee(address sender) auth returns (address) {\r\n    sender; \r\n\r\n    return _storage.primaryOwner();\r\n  }\r\n\r\n  function mint(address sender, uint amount) auth returns (bool) {\r\n    if (amount <= 0) throw;\r\n\r\n    _association.newProposal(sha3('mint'), sender, amount, 0, 0, '');\r\n\r\n    /*return proposalEntity.mint(sender, amount);*/\r\n  }\r\n\r\n\r\n  function burn(address sender, uint amount) auth returns (bool) {\r\n    if (amount <= 0) throw;\r\n    if (_storage.coinBalance(sender) < amount) throw;\r\n    if (_storage.tokenBalance(sender) < amount) throw;\r\n\r\n    _association.newProposal(sha3('burn'), sender, amount, 0, 0, '');\r\n    /*return proposalEntity.burn(sender, amount);*/\r\n  }\r\n\r\n  function confirmProposal(address sender, bytes32 type_, uint proposalId) auth {\r\n    _association.confirmProposal(type_, sender, proposalId);\r\n    /*proposalEntity.confirmProposal(sender, type_, proposalId);*/\r\n  }\r\n\r\n\r\n  function numberOfProposals(bytes32 type_) constant returns (uint) {\r\n    return _association.numberOfProposals(type_);\r\n    /*return proposalEntity.numberOfProposals(type_);*/\r\n  }\r\n\r\n\r\n  function changeAssociation(address association_) auth returns (bool) {\r\n    _association = IkuraAssociation(association_);\r\n    /*proposalEntity.changeAssociation(_association);*/\r\n\r\n    return true;\r\n  }\r\n\r\n\r\n  function changeStorage(address storage_) auth returns (bool) {\r\n    _storage = IkuraStorage(storage_);\r\n    /*proposalEntity.changeStorage(_storage);*/\r\n\r\n    return true;\r\n  }\r\n\r\n\r\n  function logicVersion(address sender) auth constant returns (uint) {\r\n    sender; \r\n\r\n    return 1;\r\n  }\r\n}\r\n\r\n\r\ncontract IkuraAuthority is DSAuthority, DSAuth {\r\n  \r\n  IkuraStorage tokenStorage;\r\n\r\n  \r\n  \r\n  mapping(bytes4 => bool) actionsWithToken;\r\n\r\n  \r\n  mapping(bytes4 => bool) actionsForbidden;\r\n\r\n  \r\n  \r\n  \r\n  function IkuraAuthority() DSAuth() {\r\n    /*address controllerAddress = 0x34c5605A4Ef1C98575DB6542179E55eE1f77A188;\r\n    owner = controllerAddress;\r\n    LogSetOwner(controllerAddress);*/\r\n  }\r\n\r\n\r\n  function changeStorage(address storage_) auth {\r\n    tokenStorage = IkuraStorage(storage_);\r\n\r\n    \r\n    actionsWithToken[stringToSig('mint(uint256)')] = true;\r\n    actionsWithToken[stringToSig('burn(uint256)')] = true;\r\n    actionsWithToken[stringToSig('updateTransferMinimumFee(uint8)')] = true;\r\n    actionsWithToken[stringToSig('updateTransferFeeRate(uint256)')] = true;\r\n    actionsWithToken[stringToSig('confirmProposal(string, uint256)')] = true;\r\n    actionsWithToken[stringToSig('numberOfProposals(string)')] = true;\r\n\r\n    \r\n    actionsForbidden[stringToSig('forbiddenAction()')] = true;\r\n  }\r\n\r\n  function canCall(address src, address dst, bytes4 sig) constant returns (bool) {\r\n    \r\n    if (actionsWithToken[sig]) return canCallWithAssociation(src, dst);\r\n\r\n    \r\n    if (actionsForbidden[sig]) return canCallWithNoOne();\r\n\r\n    \r\n    return canCallDefault(src);\r\n  }\r\n\r\n  function canCallDefault(address src) internal constant returns (bool) {\r\n    return tokenStorage.isOwnerAddress(src);\r\n  }\r\n\r\n\r\n  function canCallWithAssociation(address src, address dst) internal returns (bool) {\r\n    \r\n    dst;\r\n\r\n    return tokenStorage.isOwnerAddress(src) &&\r\n           (tokenStorage.numOwnerAddress() == 1 || tokenStorage.tokenBalance(src) > 0);\r\n  }\r\n\r\n\r\n  function canCallWithNoOne() internal constant returns (bool) {\r\n    return false;\r\n  }\r\n\r\n\r\n  function stringToSig(string str) internal constant returns (bytes4) {\r\n    return bytes4(sha3(str));\r\n  }\r\n}\r\n\r\n\r\ncontract IkuraController is ERC20, DSAuth {\r\n  \r\n  \r\n  \r\n\r\n  \r\n  string public name = \"XJP 0.6.0\";\r\n\r\n  \r\n  string public constant symbol = \"XJP\";\r\n\r\n  \r\n  uint8 public constant decimals = 0;\r\n\r\n  \r\n  \r\n  \r\n\r\n  \r\n  \r\n  IkuraToken private token;\r\n\r\n  \r\n  IkuraStorage private tokenStorage;\r\n\r\n  \r\n  IkuraAuthority private authority;\r\n\r\n  \r\n  IkuraAssociation private association;\r\n\r\n  \r\n  \r\n  \r\n\r\n  function totalSupply() constant returns (uint) {\r\n    return token.totalSupply(msg.sender);\r\n  }\r\n\r\n  function balanceOf(address addr) constant returns (uint) {\r\n    return token.balanceOf(msg.sender, addr);\r\n  }\r\n\r\n  function transfer(address to, uint amount) returns (bool) {\r\n    if (token.transfer(msg.sender, to, amount)) {\r\n      Transfer(msg.sender, to, amount);\r\n\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  function transferFrom(address from, address to, uint amount) returns (bool) {\r\n    if (token.transferFrom(msg.sender, from, to, amount)) {\r\n      Transfer(from, to, amount);\r\n\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  function approve(address spender, uint amount) returns (bool) {\r\n    if (token.approve(msg.sender, spender, amount)) {\r\n      Approval(msg.sender, spender, amount);\r\n\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  function allowance(address addr, address spender) constant returns (uint) {\r\n    return token.allowance(msg.sender, addr, spender);\r\n  }\r\n\r\n  \r\n  \r\n  \r\n\r\n  function tokenBalanceOf(address addr) constant returns (uint) {\r\n    return token.tokenBalanceOf(msg.sender, addr);\r\n  }\r\n\r\n  function transferToken(address to, uint amount) returns (bool) {\r\n    return token.transferToken(msg.sender, to, amount);\r\n  }\r\n\r\n  function transferFeeRate() constant returns (uint) {\r\n    return token.transferFeeRate(msg.sender);\r\n  }\r\n\r\n  function transferMinimumFee() constant returns (uint8) {\r\n    return token.transferMinimumFee(msg.sender);\r\n  }\r\n\r\n  function transferFee(address from, address to, uint amount) returns (uint) {\r\n    return token.transferFee(msg.sender, from, to, amount);\r\n  }\r\n\r\n  \r\n\r\n  function updateTransferMinimumFee(uint8 minimumFee) auth returns (bool) {\r\n    return token.updateTransferMinimumFee(msg.sender, minimumFee);\r\n  }\r\n\r\n  function updateTransferFeeRate(uint feeRate) auth returns (bool) {\r\n    return token.updateTransferFeeRate(msg.sender, feeRate);\r\n  }\r\n\r\n  function mint(uint amount) auth returns (bool) {\r\n    return token.mint(msg.sender, amount);\r\n  }\r\n\r\n  function burn(uint amount) auth returns (bool) {\r\n    return token.burn(msg.sender, amount);\r\n  }\r\n\r\n  function isOwner(address addr) auth returns (bool) {\r\n    return tokenStorage.isOwnerAddress(addr);\r\n  }\r\n\r\n\r\n  function confirmProposal(string type_, uint proposalId) auth {\r\n    token.confirmProposal(msg.sender, sha3(type_), proposalId);\r\n  }\r\n\r\n  function numOwnerAddress() auth constant returns (uint) {\r\n    return tokenStorage.numOwnerAddress();\r\n  }\r\n\r\n\r\n  function numberOfProposals(string type_) auth constant returns (uint) {\r\n    return token.numberOfProposals(sha3(type_));\r\n  }\r\n\r\n  \r\n  \r\n  \r\n\r\n\r\n  function setup(address storageAddress, address tokenAddress, address authorityAddress, address associationAddress) auth {\r\n    changeStorage(storageAddress);\r\n    changeToken(tokenAddress);\r\n    changeAuthority(authorityAddress);\r\n    changeAssociation(associationAddress);\r\n  }\r\n\r\n\r\n  function changeToken(address tokenAddress) auth {\r\n    \r\n    token = IkuraToken(tokenAddress);\r\n\r\n    \r\n    tokenStorage.changeToken(token);\r\n    token.changeStorage(tokenStorage);\r\n\r\n    \r\n    if (association != address(0)) {\r\n      association.changeToken(token);\r\n      token.changeAssociation(association);\r\n    }\r\n  }\r\n\r\n  function changeStorage(address storageAddress) auth {\r\n    \r\n    tokenStorage = IkuraStorage(storageAddress);\r\n  }\r\n\r\n\r\n  function changeAuthority(address authorityAddress) auth {\r\n    \r\n    authority = IkuraAuthority(authorityAddress);\r\n    setAuthority(authority);\r\n\r\n    \r\n    authority.changeStorage(tokenStorage);\r\n    tokenStorage.changeAuthority(authority);\r\n  }\r\n\r\n  function changeAssociation(address associationAddress) auth {\r\n    \r\n    association = IkuraAssociation(associationAddress);\r\n\r\n    \r\n    association.changeStorage(tokenStorage);\r\n    tokenStorage.changeAssociation(association);\r\n\r\n    \r\n    if (token != address(0)) {\r\n      association.changeToken(token);\r\n      token.changeAssociation(association);\r\n    }\r\n  }\r\n\r\n\r\n  function forbiddenAction() auth returns (bool) {\r\n    return true;\r\n  }\r\n\r\n \r\n  function logicVersion() constant returns (uint) {\r\n    return token.logicVersion(msg.sender);\r\n  }\r\n\r\n\r\n  function isAuthorized(address src, bytes4 sig) internal returns (bool) {\r\n    return  src == address(this) ||\r\n            src == owner ||\r\n            authority.canCall(src, this, sig);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"authorityAddress\",\"type\":\"address\"}],\"name\":\"changeAuthority\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"logicVersion\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferFeeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"type_\",\"type\":\"string\"},{\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"confirmProposal\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"feeRate\",\"type\":\"uint256\"}],\"name\":\"updateTransferFeeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"storageAddress\",\"type\":\"address\"},{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"authorityAddress\",\"type\":\"address\"},{\"name\":\"associationAddress\",\"type\":\"address\"}],\"name\":\"setup\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"changeToken\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"authority_\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numOwnerAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferMinimumFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"forbiddenAction\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"associationAddress\",\"type\":\"address\"}],\"name\":\"changeAssociation\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"storageAddress\",\"type\":\"address\"}],\"name\":\"changeStorage\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"minimumFee\",\"type\":\"uint8\"}],\"name\":\"updateTransferMinimumFee\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"type_\",\"type\":\"string\"}],\"name\":\"numberOfProposals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"tokenBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"LogSetAuthority\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogSetOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"IkuraController","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://792b492909f01c0cd2478bd5bec8959d698c39f31179b42ec9e3d9207e604d8a"}]}