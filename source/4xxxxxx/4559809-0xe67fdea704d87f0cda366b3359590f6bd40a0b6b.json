{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n* @title SafeMath\r\n* @dev Math operations with safety checks that throw on error\r\n*/\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract IERC20Token {\r\n  function name() public constant returns (string) { name; }\r\n  function symbol() public constant returns (string) { symbol; }\r\n  function decimals() public constant returns (uint8) { decimals; }\r\n  function totalSupply() public constant returns (uint256) { totalSupply; }\r\n  function balanceOf(address _owner) public constant returns (uint256 balance) { _owner; balance; }\r\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { _owner; _spender; remaining; }\r\n\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\r\n  function approve(address _spender, uint256 _value) public returns (bool);\r\n}\r\n\r\ncontract ERC20Token is IERC20Token {\r\n  using SafeMath for uint256;\r\n\r\n  string public standard = 'Token 0.1';\r\n  string public name = '';\r\n  string public symbol = '';\r\n  uint8 public decimals = 0;\r\n  uint256 public totalSupply = 0;\r\n  mapping (address => uint256) public balanceOf;\r\n  mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n  function ERC20Token(string _name, string _symbol, uint8 _decimals) public {\r\n    require(bytes(_name).length > 0 && bytes(_symbol).length > 0);\r\n    name = _name;\r\n    symbol = _symbol;\r\n    decimals = _decimals;\r\n  }\r\n\r\n  modifier validAddress(address _address) {\r\n    require(_address != 0x0);\r\n    _;\r\n  }\r\n\r\n  function transfer(address _to, uint256 _value) public validAddress(_to) returns (bool) {\r\n    balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);\r\n    balanceOf[_to] = balanceOf[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    \r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value) public validAddress(_to) returns (bool) {\r\n    allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\r\n    balanceOf[_from] = balanceOf[_from].sub(_value);\r\n    balanceOf[_to] = balanceOf[_to].add(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function approve(address _spender, uint256 _value) public validAddress(_spender) returns (bool) {\r\n    require(_value == 0 || allowance[msg.sender][_spender] == 0);\r\n    allowance[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n}\r\n\r\n\r\ncontract IOwned {\r\n  function owner() public constant returns (address) { owner; }\r\n  function transferOwnership(address _newOwner) public;\r\n}\r\n\r\ncontract Owned is IOwned {\r\n  address public owner;\r\n\r\n  function Owned() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  modifier validAddress(address _address) {\r\n    require(_address != 0x0);\r\n    _;\r\n  }\r\n  modifier onlyOwner {\r\n    assert(msg.sender == owner);\r\n    _;\r\n  }\r\n  \r\n  function transferOwnership(address _newOwner) public validAddress(_newOwner) onlyOwner {\r\n    require(_newOwner != owner);\r\n    \r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n\r\ncontract ISerenityToken {\r\n  function initialSupply () public constant returns (uint256) { initialSupply; }\r\n\r\n  function totalSoldTokens () public constant returns (uint256) { totalSoldTokens; }\r\n  function totalProjectToken() public constant returns (uint256) { totalProjectToken; }\r\n\r\n  function fundingEnabled() public constant returns (bool) { fundingEnabled; }\r\n  function transfersEnabled() public constant returns (bool) { transfersEnabled; }\r\n}\r\n\r\ncontract SerenityToken is ISerenityToken, ERC20Token, Owned {\r\n  using SafeMath for uint256;\r\n \r\n  address public fundingWallet;\r\n  bool public fundingEnabled = true;\r\n  uint256 public maxSaleToken = 3500000;\r\n  uint256 public initialSupply = 350000 ether;\r\n  uint256 public totalSoldTokens;\r\n  uint256 public totalProjectToken;\r\n  uint256 private totalLockToken;\r\n  bool public transfersEnabled = false; \r\n\r\n  mapping (address => bool) private fundingWallets;\r\n  mapping (address => allocationLock) public allocations;\r\n\r\n  struct allocationLock {\r\n    uint256 value;\r\n    uint256 end;\r\n    bool locked;\r\n  }\r\n\r\n  event Finalize(address indexed _from, uint256 _value);\r\n  event Lock(address indexed _from, address indexed _to, uint256 _value, uint256 _end);\r\n  event Unlock(address indexed _from, address indexed _to, uint256 _value);\r\n  event DisableTransfers(address indexed _from);\r\n\r\n  function SerenityToken() ERC20Token(\"SERENITY INVEST\", \"SERENITY\", 18) public {\r\n    fundingWallet = msg.sender; \r\n\r\n    balanceOf[fundingWallet] = maxSaleToken;\r\n    balanceOf[0xCAD0AfB8Ec657D0DB9518B930855534f6433360f] = maxSaleToken;\r\n    balanceOf[0x47c8F28e6056374aBA3DF0854306c2556B104601] = maxSaleToken;\r\n\r\n    fundingWallets[fundingWallet] = true;\r\n    fundingWallets[0x47c8F28e6056374aBA3DF0854306c2556B104601] = true;\r\n    fundingWallets[0xCAD0AfB8Ec657D0DB9518B930855534f6433360f] = true;\r\n  }\r\n\r\n  modifier validAddress(address _address) {\r\n    require(_address != 0x0);\r\n    _;\r\n  }\r\n\r\n  modifier transfersAllowed(address _address) {\r\n    if (fundingEnabled) {\r\n      require(fundingWallets[_address]);\r\n    }\r\n    else {\r\n      require(transfersEnabled);\r\n    }\r\n    _;\r\n  }\r\n\r\n  function transfer(address _to, uint256 _value) public validAddress(_to) transfersAllowed(msg.sender) returns (bool) {\r\n    return super.transfer(_to, _value);\r\n  }\r\n\r\n  function autoTransfer(address _to, uint256 _value) public validAddress(_to) onlyOwner returns (bool) {\r\n    return super.transfer(_to, _value);\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value) public validAddress(_to) transfersAllowed(_from) returns (bool) {\r\n    return super.transferFrom(_from, _to, _value);\r\n  }\r\n\r\n  function lock(address _to, uint256 _value, uint256 _end) internal validAddress(_to) onlyOwner returns (bool) {\r\n    require(_value > 0);\r\n\r\n    assert(totalProjectToken > 0);\r\n    totalLockToken = totalLockToken.add(_value);\r\n    assert(totalProjectToken >= totalLockToken);\r\n\r\n    require(allocations[_to].value == 0);\r\n\r\n    // Assign a new lock.\r\n    allocations[_to] = allocationLock({\r\n      value: _value,\r\n      end: _end,\r\n      locked: true\r\n    });\r\n\r\n    Lock(this, _to, _value, _end);\r\n\r\n    return true;\r\n  }\r\n\r\n  function unlock() external {\r\n    require(allocations[msg.sender].locked);\r\n    require(now >= allocations[msg.sender].end);\r\n    \r\n    balanceOf[msg.sender] = balanceOf[msg.sender].add(allocations[msg.sender].value);\r\n\r\n    allocations[msg.sender].locked = false;\r\n\r\n    Transfer(this, msg.sender, allocations[msg.sender].value);\r\n    Unlock(this, msg.sender, allocations[msg.sender].value);\r\n  }\r\n\r\n  function finalize() external onlyOwner {\r\n    require(fundingEnabled);\r\n    \r\n    totalSoldTokens = maxSaleToken.sub(balanceOf[fundingWallet]);\r\n\r\n    totalProjectToken = totalSoldTokens.mul(15).div(100);\r\n\r\n    lock(0x47c8F28e6056374aBA3DF0854306c2556B104601, totalProjectToken, now);\r\n    \r\n    // Zeroing a cold wallet.\r\n    balanceOf[fundingWallet] = 0;\r\n    balanceOf[0x47c8F28e6056374aBA3DF0854306c2556B104601] = 0;\r\n    balanceOf[0xCAD0AfB8Ec657D0DB9518B930855534f6433360f] = 0;\r\n\r\n    // End of crowdfunding.\r\n    fundingEnabled = false;\r\n    transfersEnabled = true;\r\n\r\n    // End of crowdfunding.\r\n    Transfer(this, fundingWallet, 0);\r\n    Finalize(msg.sender, totalSupply);\r\n  }\r\n\r\n  function disableTransfers() external onlyOwner {\r\n    require(transfersEnabled);\r\n\r\n    transfersEnabled = false;\r\n\r\n    DisableTransfers(msg.sender);\r\n  }\r\n\r\n  function disableFundingWallets(address _address) external onlyOwner {\r\n    require(fundingEnabled);\r\n    require(fundingWallet != _address);\r\n    require(fundingWallets[_address]);\r\n\r\n    fundingWallets[_address] = false;\r\n  }\r\n}\r\n\r\n\r\ncontract Crowdsale {\r\n  using SafeMath for uint256;\r\n\r\n  SerenityToken public token;\r\n\r\n  mapping(uint256 => uint8) icoWeeksDiscounts; \r\n\r\n  uint256 public preStartTime = 1510704000;\r\n  uint256 public preEndTime = 1512086400; \r\n\r\n  bool public isICOStarted = false; \r\n  uint256 public icoStartTime; \r\n  uint256 public icoEndTime; \r\n\r\n  address public wallet = 0x47c8F28e6056374aBA3DF0854306c2556B104601;\r\n  uint256 public finneyPerToken = 100;\r\n  uint256 public weiRaised;\r\n  uint256 public ethRaised;\r\n\r\n  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\r\n\r\n  modifier validAddress(address _address) {\r\n    require(_address != 0x0);\r\n    _;\r\n  }\r\n\r\n  function Crowdsale() public {\r\n    token = createTokenContract();\r\n    initDiscounts();\r\n  }\r\n\r\n  function initDiscounts() internal {\r\n    icoWeeksDiscounts[0] = 40;\r\n    icoWeeksDiscounts[1] = 35;\r\n    icoWeeksDiscounts[2] = 30;\r\n    icoWeeksDiscounts[3] = 25;\r\n    icoWeeksDiscounts[4] = 20;\r\n    icoWeeksDiscounts[5] = 10;\r\n  }\r\n\r\n  function createTokenContract() internal returns (SerenityToken) {\r\n    return new SerenityToken();\r\n  }\r\n\r\n  function () public payable {\r\n    buyTokens(msg.sender);\r\n  }\r\n\r\n  function getTimeDiscount() internal returns(uint8) {\r\n    require(isICOStarted == true);\r\n    require(icoStartTime < now);\r\n    require(icoEndTime > now);\r\n\r\n    uint256 weeksPassed = (now - icoStartTime) / 7 days;\r\n    return icoWeeksDiscounts[weeksPassed];\r\n  } \r\n\r\n  function getTotalSoldDiscount() internal returns(uint8) {\r\n    require(isICOStarted == true);\r\n    require(icoStartTime < now);\r\n    require(icoEndTime > now);\r\n\r\n    uint256 totalSold = token.totalSoldTokens();\r\n\r\n    if (totalSold < 150000)\r\n      return 50;\r\n    else if (totalSold < 250000)\r\n      return 40;\r\n    else if (totalSold < 500000)\r\n      return 35;\r\n    else if (totalSold < 700000)\r\n      return 30;\r\n    else if (totalSold < 1100000)\r\n      return 25;\r\n    else if (totalSold < 2100000)\r\n      return 20;\r\n    else if (totalSold < 3500000)\r\n      return 10;\r\n  }\r\n\r\n  function getDiscount() internal constant returns (uint8) {\r\n    if (!isICOStarted)\r\n      return 50;\r\n    else {\r\n      uint8 timeDiscount = getTimeDiscount();\r\n      uint8 totalSoldDiscount = getTotalSoldDiscount();\r\n\r\n      if (timeDiscount < totalSoldDiscount)\r\n        return timeDiscount;\r\n      else \r\n        return totalSoldDiscount;\r\n    }\r\n  }\r\n\r\n  function buyTokens(address beneficiary) public validAddress(beneficiary) payable {\r\n    require(validPurchase());\r\n\r\n    uint256 finneyAmount = msg.value / 1 finney;\r\n\r\n    uint8 discountPercents = getDiscount();\r\n    uint256 tokens = finneyAmount.mul(100).div(100 - discountPercents).div(finneyPerToken);\r\n\r\n    require(tokens > 0);\r\n\r\n    weiRaised = weiRaised.add(finneyAmount * 1 finney);\r\n    \r\n    token.autoTransfer(beneficiary, tokens);\r\n    TokenPurchase(msg.sender, beneficiary, finneyAmount * 1 finney, tokens);\r\n\r\n    forwardFunds();\r\n  }\r\n\r\n  function activeteICO(uint256 _icoEndTime) public {\r\n    require(msg.sender == wallet);\r\n    require(_icoEndTime >= now);\r\n    require(_icoEndTime >= preEndTime);\r\n    require(isICOStarted == false);\r\n      \r\n    isICOStarted = true;\r\n    icoEndTime = _icoEndTime;\r\n  }\r\n\r\n  function forwardFunds() internal {\r\n    wallet.transfer(msg.value);\r\n  }\r\n\r\n  function validPurchase() internal constant returns (bool) {\r\n    bool withinPresalePeriod = now >= preStartTime && now <= preEndTime;\r\n    bool withinICOPeriod = isICOStarted && now >= icoStartTime && now <= icoEndTime;\r\n\r\n    bool nonZeroPurchase = msg.value != 0;\r\n    \r\n    return (withinPresalePeriod || withinICOPeriod) && nonZeroPurchase;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"autoTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableTransfers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allocations\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"},{\"name\":\"locked\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalProjectToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxSaleToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"standard\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"disableFundingWallets\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transfersEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSoldTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Finalize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_end\",\"type\":\"uint256\"}],\"name\":\"Lock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Unlock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"DisableTransfers\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"SerenityToken","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://bc599124e8c2d3ebfd0837f13618f4cedffa3784c6a811fbfd75e740c2180a85"}]}