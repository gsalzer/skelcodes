{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.15;\r\n\r\n// File: contracts/BTC.sol\r\n\r\n// Bitcoin transaction parsing library\r\n\r\n// Copyright 2016 rain <https://keybase.io/rain>\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n// https://en.bitcoin.it/wiki/Protocol_documentation#tx\r\n//\r\n// Raw Bitcoin transaction structure:\r\n//\r\n// field     | size | type     | description\r\n// version   | 4    | int32    | transaction version number\r\n// n_tx_in   | 1-9  | var_int  | number of transaction inputs\r\n// tx_in     | 41+  | tx_in[]  | list of transaction inputs\r\n// n_tx_out  | 1-9  | var_int  | number of transaction outputs\r\n// tx_out    | 9+   | tx_out[] | list of transaction outputs\r\n// lock_time | 4    | uint32   | block number / timestamp at which tx locked\r\n//\r\n// Transaction input (tx_in) structure:\r\n//\r\n// field      | size | type     | description\r\n// previous   | 36   | outpoint | Previous output transaction reference\r\n// script_len | 1-9  | var_int  | Length of the signature script\r\n// sig_script | ?    | uchar[]  | Script for confirming transaction authorization\r\n// sequence   | 4    | uint32   | Sender transaction version\r\n//\r\n// OutPoint structure:\r\n//\r\n// field      | size | type     | description\r\n// hash       | 32   | char[32] | The hash of the referenced transaction\r\n// index      | 4    | uint32   | The index of this output in the referenced transaction\r\n//\r\n// Transaction output (tx_out) structure:\r\n//\r\n// field         | size | type     | description\r\n// value         | 8    | int64    | Transaction value (Satoshis)\r\n// pk_script_len | 1-9  | var_int  | Length of the public key script\r\n// pk_script     | ?    | uchar[]  | Public key as a Bitcoin script.\r\n//\r\n// Variable integers (var_int) can be encoded differently depending\r\n// on the represented value, to save space. Variable integers always\r\n// precede an array of a variable length data type (e.g. tx_in).\r\n//\r\n// Variable integer encodings as a function of represented value:\r\n//\r\n// value           | bytes  | format\r\n// <0xFD (253)     | 1      | uint8\r\n// <=0xFFFF (65535)| 3      | 0xFD followed by length as uint16\r\n// <=0xFFFF FFFF   | 5      | 0xFE followed by length as uint32\r\n// -               | 9      | 0xFF followed by length as uint64\r\n//\r\n// Public key scripts `pk_script` are set on the output and can\r\n// take a number of forms. The regular transaction script is\r\n// called 'pay-to-pubkey-hash' (P2PKH):\r\n//\r\n// OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG\r\n//\r\n// OP_x are Bitcoin script opcodes. The bytes representation (including\r\n// the 0x14 20-byte stack push) is:\r\n//\r\n// 0x76 0xA9 0x14 <pubKeyHash> 0x88 0xAC\r\n//\r\n// The <pubKeyHash> is the ripemd160 hash of the sha256 hash of\r\n// the public key, preceded by a network version byte. (21 bytes total)\r\n//\r\n// Network version bytes: 0x00 (mainnet); 0x6f (testnet); 0x34 (namecoin)\r\n//\r\n// The Bitcoin address is derived from the pubKeyHash. The binary form is the\r\n// pubKeyHash, plus a checksum at the end.  The checksum is the first 4 bytes\r\n// of the (32 byte) double sha256 of the pubKeyHash. (25 bytes total)\r\n// This is converted to base58 to form the publicly used Bitcoin address.\r\n// Mainnet P2PKH transaction scripts are to addresses beginning with '1'.\r\n//\r\n// P2SH ('pay to script hash') scripts only supply a script hash. The spender\r\n// must then provide the script that would allow them to redeem this output.\r\n// This allows for arbitrarily complex scripts to be funded using only a\r\n// hash of the script, and moves the onus on providing the script from\r\n// the spender to the redeemer.\r\n//\r\n// The P2SH script format is simple:\r\n//\r\n// OP_HASH160 <scriptHash> OP_EQUAL\r\n//\r\n// 0xA9 0x14 <scriptHash> 0x87\r\n//\r\n// The <scriptHash> is the ripemd160 hash of the sha256 hash of the\r\n// redeem script. The P2SH address is derived from the scriptHash.\r\n// Addresses are the scriptHash with a version prefix of 5, encoded as\r\n// Base58check. These addresses begin with a '3'.\r\n\r\npragma solidity ^0.4.11;\r\n\r\n// parse a raw bitcoin transaction byte array\r\nlibrary BTC {\r\n    // Convert a variable integer into something useful and return it and\r\n    // the index to after it.\r\n    function parseVarInt(bytes txBytes, uint pos) returns (uint, uint) {\r\n        // the first byte tells us how big the integer is\r\n        var ibit = uint8(txBytes[pos]);\r\n        pos += 1;  // skip ibit\r\n\r\n        if (ibit < 0xfd) {\r\n            return (ibit, pos);\r\n        } else if (ibit == 0xfd) {\r\n            return (getBytesLE(txBytes, pos, 16), pos + 2);\r\n        } else if (ibit == 0xfe) {\r\n            return (getBytesLE(txBytes, pos, 32), pos + 4);\r\n        } else if (ibit == 0xff) {\r\n            return (getBytesLE(txBytes, pos, 64), pos + 8);\r\n        }\r\n    }\r\n    // convert little endian bytes to uint\r\n    function getBytesLE(bytes data, uint pos, uint bits) returns (uint) {\r\n        if (bits == 8) {\r\n            return uint8(data[pos]);\r\n        } else if (bits == 16) {\r\n            return uint16(data[pos])\r\n                 + uint16(data[pos + 1]) * 2 ** 8;\r\n        } else if (bits == 32) {\r\n            return uint32(data[pos])\r\n                 + uint32(data[pos + 1]) * 2 ** 8\r\n                 + uint32(data[pos + 2]) * 2 ** 16\r\n                 + uint32(data[pos + 3]) * 2 ** 24;\r\n        } else if (bits == 64) {\r\n            return uint64(data[pos])\r\n                 + uint64(data[pos + 1]) * 2 ** 8\r\n                 + uint64(data[pos + 2]) * 2 ** 16\r\n                 + uint64(data[pos + 3]) * 2 ** 24\r\n                 + uint64(data[pos + 4]) * 2 ** 32\r\n                 + uint64(data[pos + 5]) * 2 ** 40\r\n                 + uint64(data[pos + 6]) * 2 ** 48\r\n                 + uint64(data[pos + 7]) * 2 ** 56;\r\n        }\r\n    }\r\n    // scan the full transaction bytes and return the first two output\r\n    // values (in satoshis) and addresses (in binary)\r\n    function getFirstTwoOutputs(bytes txBytes)\r\n             returns (uint, bytes20, uint, bytes20)\r\n    {\r\n        uint pos;\r\n        uint[] memory input_script_lens = new uint[](2);\r\n        uint[] memory output_script_lens = new uint[](2);\r\n        uint[] memory script_starts = new uint[](2);\r\n        uint[] memory output_values = new uint[](2);\r\n        bytes20[] memory output_addresses = new bytes20[](2);\r\n\r\n        pos = 4;  // skip version\r\n\r\n        (input_script_lens, pos) = scanInputs(txBytes, pos, 0);\r\n\r\n        (output_values, script_starts, output_script_lens, pos) = scanOutputs(txBytes, pos, 2);\r\n\r\n        for (uint i = 0; i < 2; i++) {\r\n            var pkhash = parseOutputScript(txBytes, script_starts[i], output_script_lens[i]);\r\n            output_addresses[i] = pkhash;\r\n        }\r\n\r\n        return (output_values[0], output_addresses[0],\r\n                output_values[1], output_addresses[1]);\r\n    }\r\n    // Check whether `btcAddress` is in the transaction outputs *and*\r\n    // whether *at least* `value` has been sent to it.\r\n        // Check whether `btcAddress` is in the transaction outputs *and*\r\n    // whether *at least* `value` has been sent to it.\r\n    function checkValueSent(bytes txBytes, bytes20 btcAddress, uint value)\r\n             returns (bool,uint)\r\n    {\r\n        uint pos = 4;  // skip version\r\n        (, pos) = scanInputs(txBytes, pos, 0);  // find end of inputs\r\n\r\n        // scan *all* the outputs and find where they are\r\n        var (output_values, script_starts, output_script_lens,) = scanOutputs(txBytes, pos, 0);\r\n\r\n        // look at each output and check whether it at least value to btcAddress\r\n        for (uint i = 0; i < output_values.length; i++) {\r\n            var pkhash = parseOutputScript(txBytes, script_starts[i], output_script_lens[i]);\r\n            if (pkhash == btcAddress && output_values[i] >= value) {\r\n                return (true,output_values[i]);\r\n            }\r\n        }\r\n    }\r\n    // scan the inputs and find the script lengths.\r\n    // return an array of script lengths and the end position\r\n    // of the inputs.\r\n    // takes a 'stop' argument which sets the maximum number of\r\n    // outputs to scan through. stop=0 => scan all.\r\n    function scanInputs(bytes txBytes, uint pos, uint stop)\r\n             returns (uint[], uint)\r\n    {\r\n        uint n_inputs;\r\n        uint halt;\r\n        uint script_len;\r\n\r\n        (n_inputs, pos) = parseVarInt(txBytes, pos);\r\n\r\n        if (stop == 0 || stop > n_inputs) {\r\n            halt = n_inputs;\r\n        } else {\r\n            halt = stop;\r\n        }\r\n\r\n        uint[] memory script_lens = new uint[](halt);\r\n\r\n        for (var i = 0; i < halt; i++) {\r\n            pos += 36;  // skip outpoint\r\n            (script_len, pos) = parseVarInt(txBytes, pos);\r\n            script_lens[i] = script_len;\r\n            pos += script_len + 4;  // skip sig_script, seq\r\n        }\r\n\r\n        return (script_lens, pos);\r\n    }\r\n    // scan the outputs and find the values and script lengths.\r\n    // return array of values, array of script lengths and the\r\n    // end position of the outputs.\r\n    // takes a 'stop' argument which sets the maximum number of\r\n    // outputs to scan through. stop=0 => scan all.\r\n    function scanOutputs(bytes txBytes, uint pos, uint stop)\r\n             returns (uint[], uint[], uint[], uint)\r\n    {\r\n        uint n_outputs;\r\n        uint halt;\r\n        uint script_len;\r\n\r\n        (n_outputs, pos) = parseVarInt(txBytes, pos);\r\n\r\n        if (stop == 0 || stop > n_outputs) {\r\n            halt = n_outputs;\r\n        } else {\r\n            halt = stop;\r\n        }\r\n\r\n        uint[] memory script_starts = new uint[](halt);\r\n        uint[] memory script_lens = new uint[](halt);\r\n        uint[] memory output_values = new uint[](halt);\r\n\r\n        for (var i = 0; i < halt; i++) {\r\n            output_values[i] = getBytesLE(txBytes, pos, 64);\r\n            pos += 8;\r\n\r\n            (script_len, pos) = parseVarInt(txBytes, pos);\r\n            script_starts[i] = pos;\r\n            script_lens[i] = script_len;\r\n            pos += script_len;\r\n        }\r\n\r\n        return (output_values, script_starts, script_lens, pos);\r\n    }\r\n    // Slice 20 contiguous bytes from bytes `data`, starting at `start`\r\n    function sliceBytes20(bytes data, uint start) returns (bytes20) {\r\n        uint160 slice = 0;\r\n        for (uint160 i = 0; i < 20; i++) {\r\n            slice += uint160(data[i + start]) << (8 * (19 - i));\r\n        }\r\n        return bytes20(slice);\r\n    }\r\n    // returns true if the bytes located in txBytes by pos and\r\n    // script_len represent a P2PKH script\r\n    function isP2PKH(bytes txBytes, uint pos, uint script_len) returns (bool) {\r\n        return (script_len == 25)           // 20 byte pubkeyhash + 5 bytes of script\r\n            && (txBytes[pos] == 0x76)       // OP_DUP\r\n            && (txBytes[pos + 1] == 0xa9)   // OP_HASH160\r\n            && (txBytes[pos + 2] == 0x14)   // bytes to push\r\n            && (txBytes[pos + 23] == 0x88)  // OP_EQUALVERIFY\r\n            && (txBytes[pos + 24] == 0xac); // OP_CHECKSIG\r\n    }\r\n    // returns true if the bytes located in txBytes by pos and\r\n    // script_len represent a P2SH script\r\n    function isP2SH(bytes txBytes, uint pos, uint script_len) returns (bool) {\r\n        return (script_len == 23)           // 20 byte scripthash + 3 bytes of script\r\n            && (txBytes[pos + 0] == 0xa9)   // OP_HASH160\r\n            && (txBytes[pos + 1] == 0x14)   // bytes to push\r\n            && (txBytes[pos + 22] == 0x87); // OP_EQUAL\r\n    }\r\n    // Get the pubkeyhash / scripthash from an output script. Assumes\r\n    // pay-to-pubkey-hash (P2PKH) or pay-to-script-hash (P2SH) outputs.\r\n    // Returns the pubkeyhash/ scripthash, or zero if unknown output.\r\n    function parseOutputScript(bytes txBytes, uint pos, uint script_len)\r\n             returns (bytes20)\r\n    {\r\n        if (isP2PKH(txBytes, pos, script_len)) {\r\n            return sliceBytes20(txBytes, pos + 3);\r\n        } else if (isP2SH(txBytes, pos, script_len)) {\r\n            return sliceBytes20(txBytes, pos + 2);\r\n        } else {\r\n            return;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/Ownable.sol\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    if (msg.sender == owner)\r\n      _;\r\n  }\r\n\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    if (newOwner != address(0)) owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/Pausable.sol\r\n\r\n/*\r\n * Pausable\r\n * Abstract contract that allows children to implement an\r\n * emergency stop mechanism.\r\n */\r\n\r\ncontract Pausable is Ownable {\r\n  bool public stopped;\r\n\r\n  modifier stopInEmergency {\r\n    if (stopped) {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n  modifier onlyInEmergency {\r\n    if (!stopped) {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n  // called by the owner on emergency, triggers stopped state\r\n  function emergencyStop() external onlyOwner {\r\n    stopped = true;\r\n  }\r\n\r\n  // called by the owner on end of emergency, returns to normal state\r\n  function release() external onlyOwner onlyInEmergency {\r\n    stopped = false;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/SafeMath.sol\r\n\r\n/**\r\n * Math operations with safety checks\r\n */\r\ncontract SafeMath {\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeDiv(uint a, uint b) internal returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a / b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/StandardToken.sol\r\n\r\ncontract Token {\r\n    uint256 public totalSupply;\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\n/*  ERC 20 token */\r\ncontract StandardToken is Token {\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n      if (balances[msg.sender] >= _value && _value > 0) {\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n      if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n  }\r\n\r\n\r\n}\r\n\r\n// File: contracts/Utils.sol\r\n\r\ncontract Utils{\r\n\r\n\t//verifies the amount greater than zero\r\n\r\n\tmodifier greaterThanZero(uint256 _value){\r\n\t\trequire(_value>0);\r\n\t\t_;\r\n\t}\r\n\r\n\t///verifies an address\r\n\r\n\tmodifier validAddress(address _add){\r\n\t\trequire(_add!=0x0);\r\n\t\t_;\r\n\t}\r\n}\r\n\r\n// File: contracts/Crowdsale.sol\r\n\r\ncontract Crowdsale is StandardToken, Pausable, SafeMath, Utils{\r\n\tstring public constant name = \"Mudra\";\r\n\tstring public constant symbol = \"MUDRA\";\r\n\tuint256 public constant decimals = 18;\r\n\tstring public version = \"1.0\";\r\n\tbool public tradingStarted = false;\r\n\r\n    /**\r\n   * @dev modifier that throws if trading has not started yet\r\n   */\r\n   modifier hasStartedTrading() {\r\n   \trequire(tradingStarted);\r\n   \t_;\r\n   }\r\n  /**\r\n   * @dev Allows the owner to enable the trading. This can not be undone\r\n   */\r\n   function startTrading() onlyOwner() {\r\n   \ttradingStarted = true;\r\n   }\r\n\r\n   function transfer(address _to, uint _value) hasStartedTrading returns (bool success) {super.transfer(_to, _value);}\r\n\r\n   function transferFrom(address _from, address _to, uint _value) hasStartedTrading returns (bool success) {super.transferFrom(_from, _to, _value);}\r\n\r\n   enum State{\r\n   \tInactive,\r\n   \tFunding,\r\n   \tSuccess,\r\n   \tFailure\r\n   }\r\n\r\n   uint256 public investmentETH;\r\n   uint256 public investmentBTC;\r\n   mapping(uint256 => bool) transactionsClaimed;\r\n   uint256 public initialSupply;\r\n   address wallet;\r\n   uint256 public constant _totalSupply = 100 * (10**6) * 10 ** decimals; // 100M ~ 10 Crores\r\n   uint256 public fundingStartBlock; // crowdsale start block\r\n   uint256 public constant minBtcValue = 10000; // ~ approx 1$\r\n   uint256 public tokensPerEther = 450; // 1 ETH = 460 tokens\r\n   uint256 public tokensPerBTC = 140 * 10 ** 10 * 10 ** 2; // 1 btc = 11500 Tokens\r\n   uint256 public constant tokenCreationMax = 10 * (10**6) * 10 ** decimals; // 10M ~ 1 Crores\r\n   address[] public investors;\r\n\r\n   //displays number of uniq investors\r\n   function investorsCount() constant external returns(uint) { return investors.length; }\r\n\r\n   function Crowdsale(uint256 _fundingStartBlock, address _owner, address _wallet){\r\n      owner = _owner;\r\n      fundingStartBlock =_fundingStartBlock;\r\n      totalSupply = _totalSupply;\r\n      initialSupply = 0;\r\n      wallet = _wallet;\r\n\r\n      //check configuration if something in setup is looking weird\r\n      if (\r\n        tokensPerEther == 0\r\n        || tokensPerBTC == 0\r\n        || owner == 0x0\r\n        || wallet == 0x0\r\n        || fundingStartBlock == 0\r\n        || totalSupply == 0\r\n        || tokenCreationMax == 0\r\n        || fundingStartBlock <= block.number)\r\n      throw;\r\n\r\n   }\r\n\r\n   // don't just send ether to the contract expecting to get tokens\r\n   //function() { throw; }\r\n   ////@dev This function manages the Crowdsale State machine\r\n   ///We make it a function and do not assign to a variable//\r\n   ///so that no chance of stale variable\r\n   function getState() constant public returns(State){\r\n   \t///once we reach success lock the State\r\n   \tif(block.number<fundingStartBlock) return State.Inactive;\r\n   \telse if(block.number>fundingStartBlock && initialSupply<tokenCreationMax) return State.Funding;\r\n   \telse if (initialSupply >= tokenCreationMax) return State.Success;\r\n   \telse return State.Failure;\r\n   }\r\n\r\n   ///get total tokens in that address mapping\r\n   function getTokens(address addr) public returns(uint256){\r\n   \treturn balances[addr];\r\n   }\r\n\r\n   ///get the block number state\r\n   function getStateFunding() public returns (uint256){\r\n   \t// average 6000 blocks mined in 24 hrs\r\n   \tif(block.number<fundingStartBlock + 180000) return 20; // 1 month 20%\r\n   \telse if(block.number>=fundingStartBlock+ 180001 && block.number<fundingStartBlock + 270000) return 10; // next 15 days\r\n   \telse if(block.number>=fundingStartBlock + 270001 && block.number<fundingStartBlock + 36000) return 5; // next 15 days\r\n   \telse return 0;\r\n   }\r\n   ///a function using safemath to work with\r\n   ///the new function\r\n   function calNewTokens(uint256 tokens) returns (uint256){\r\n   \tuint256 disc = getStateFunding();\r\n   \ttokens = safeAdd(tokens,safeDiv(safeMul(tokens,disc),100));\r\n   \treturn tokens;\r\n   }\r\n\r\n   function() external payable stopInEmergency{\r\n   \t// Abort if not in Funding Active state.\r\n   \tif(getState() == State.Success) throw;\r\n   \tif (msg.value == 0) throw;\r\n   \tuint256 newCreatedTokens = safeMul(msg.value,tokensPerEther);\r\n   \tnewCreatedTokens = calNewTokens(newCreatedTokens);\r\n   \t///since we are creating tokens we need to increase the total supply\r\n   \tinitialSupply = safeAdd(initialSupply,newCreatedTokens);\r\n   \tif(initialSupply>tokenCreationMax) throw;\r\n      if (balances[msg.sender] == 0) investors.push(msg.sender);\r\n      investmentETH += msg.value;\r\n      balances[msg.sender] = safeAdd(balances[msg.sender],newCreatedTokens);\r\n      // Pocket the money\r\n      if(!wallet.send(msg.value)) throw;\r\n   }\r\n\r\n\r\n   ///token distribution initial function for the one in the exchanges\r\n   ///to be done only the owner can run this function\r\n   function tokenAssignExchange(address addr,uint256 val)\r\n   external\r\n   stopInEmergency\r\n   onlyOwner()\r\n   {\r\n   \tif(getState() == State.Success) throw;\r\n    if(addr == 0x0) throw;\r\n   \tif (val == 0) throw;\r\n   \tuint256 newCreatedTokens = safeMul(val,tokensPerEther);\r\n   \tnewCreatedTokens = calNewTokens(newCreatedTokens);\r\n   \tinitialSupply = safeAdd(initialSupply,newCreatedTokens);\r\n   \tif(initialSupply>tokenCreationMax) throw;\r\n      if (balances[addr] == 0) investors.push(addr);\r\n      investmentETH += val;\r\n      balances[addr] = safeAdd(balances[addr],newCreatedTokens);\r\n   }\r\n\r\n   ///function to run when the transaction has been veified\r\n   function processTransaction(bytes txn, uint256 txHash,address addr,bytes20 btcaddr)\r\n   external\r\n   stopInEmergency\r\n   onlyOwner()\r\n   returns (uint)\r\n   {\r\n   \tif(getState() == State.Success) throw;\r\n    if(addr == 0x0) throw;\r\n   \tvar (output1,output2,output3,output4) = BTC.getFirstTwoOutputs(txn);\r\n      if(transactionsClaimed[txHash]) throw;\r\n      var (a,b) = BTC.checkValueSent(txn,btcaddr,minBtcValue);\r\n      if(a){\r\n         transactionsClaimed[txHash] = true;\r\n         uint256 newCreatedTokens = safeMul(b,tokensPerBTC);\r\n         ///since we are creating tokens we need to increase the total supply\r\n         newCreatedTokens = calNewTokens(newCreatedTokens);\r\n         initialSupply = safeAdd(initialSupply,newCreatedTokens);\r\n         ///remember not to go off the LIMITS!!\r\n         if(initialSupply>tokenCreationMax) throw;\r\n         if (balances[addr] == 0) investors.push(addr);\r\n         investmentBTC += b;\r\n         balances[addr] = safeAdd(balances[addr],newCreatedTokens);\r\n         return 1;\r\n      }\r\n      else return 0;\r\n   }\r\n\r\n   ///change exchange rate ~ update price everyday\r\n   function changeExchangeRate(uint256 eth, uint256 btc)\r\n   external\r\n   onlyOwner()\r\n   {\r\n     if(eth == 0 || btc == 0) throw;\r\n     tokensPerEther = eth;\r\n     tokensPerBTC = btc;\r\n  }\r\n\r\n  ///blacklist the users which are fraudulent\r\n  ///from getting any tokens\r\n  ///to do also refund just in cases\r\n  function blacklist(address addr)\r\n  external\r\n  onlyOwner()\r\n  {\r\n     balances[addr] = 0;\r\n  }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenCreationMax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startTrading\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investorsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minBtcValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"investors\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tradingStarted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investmentETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"emergencyStop\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stopped\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"release\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getStateFunding\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"tokenAssignExchange\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investmentBTC\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"txn\",\"type\":\"bytes\"},{\"name\":\"txHash\",\"type\":\"uint256\"},{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"btcaddr\",\"type\":\"bytes20\"}],\"name\":\"processTransaction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"calNewTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingStartBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensPerBTC\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"btc\",\"type\":\"uint256\"}],\"name\":\"changeExchangeRate\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensPerEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"blacklist\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_fundingStartBlock\",\"type\":\"uint256\"},{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_wallet\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"Crowdsale","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000047aadc00000000000000000000000056d469e2219e4e324266b520cbd596c29836e703000000000000000000000000fab0c028081dd7af5f6d7f6a8d24973aeb9554a7","Library":"BTC:a92ccdc61207c6718f4d3aed702d05820616d69f","SwarmSource":"bzzr://63c5b44d1bba234999fab0cce4b9949d28cfeb9d954c2e03e61dd3116cfcb89e"}]}