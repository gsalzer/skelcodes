{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.15;\r\n\r\n// ERC20 Interface\r\ncontract ERC20 {\r\n    function transfer(address _to, uint _value) returns (bool success);\r\n    function balanceOf(address _owner) constant returns (uint balance);\r\n}\r\n\r\ncontract PresalePool {\r\n    enum State { Open, Failed, Closed, Paid }\r\n    State public state;\r\n\r\n    address[] public admins;\r\n\r\n    uint public minContribution;\r\n    uint public maxContribution;\r\n    uint public maxPoolTotal;\r\n\r\n    address[] public participants;\r\n\r\n    bool public whitelistAll;\r\n\r\n    struct ParticipantState {\r\n        uint contribution;\r\n        uint remaining;\r\n        bool whitelisted;\r\n        bool exists;\r\n    }\r\n    mapping (address => ParticipantState) public balances;\r\n    uint public poolTotal;\r\n\r\n    address presaleAddress;\r\n    bool refundable;\r\n    uint gasFundTotal;\r\n\r\n    ERC20 public token;\r\n\r\n    event Deposit(\r\n        address indexed _from,\r\n        uint _value\r\n    );\r\n    event Payout(\r\n        address indexed _to,\r\n        uint _value\r\n    );\r\n    event Withdrawl(\r\n        address indexed _to,\r\n        uint _value\r\n    );\r\n\r\n    modifier onlyAdmins() {\r\n        require(isAdmin(msg.sender));\r\n        _;\r\n    }\r\n\r\n    modifier onState(State s) {\r\n        require(state == s);\r\n        _;\r\n    }\r\n\r\n    modifier stateAllowsConfiguration() {\r\n        require(state == State.Open || state == State.Closed);\r\n        _;\r\n    }\r\n\r\n    bool locked;\r\n    modifier noReentrancy() {\r\n        require(!locked);\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n\r\n    function PresalePool(uint _minContribution, uint _maxContribution, uint _maxPoolTotal, address[] _admins) payable {\r\n        state = State.Open;\r\n        admins.push(msg.sender);\r\n\r\n        setContributionSettings(_minContribution, _maxContribution, _maxPoolTotal);\r\n\r\n        whitelistAll = true;\r\n\r\n        for (uint i = 0; i < _admins.length; i++) {\r\n            var admin = _admins[i];\r\n            if (!isAdmin(admin)) {\r\n                admins.push(admin);\r\n            }\r\n        }\r\n\r\n        deposit();\r\n    }\r\n\r\n    function () payable {\r\n        deposit();\r\n    }\r\n\r\n    function close() public onlyAdmins onState(State.Open) {\r\n        state = State.Closed;\r\n    }\r\n\r\n    function open() public onlyAdmins onState(State.Closed) {\r\n        state = State.Open;\r\n    }\r\n\r\n    function fail() public onlyAdmins stateAllowsConfiguration {\r\n        state = State.Failed;\r\n    }\r\n\r\n    function payToPresale(address _presaleAddress) public onlyAdmins onState(State.Closed) {\r\n        state = State.Paid;\r\n        presaleAddress = _presaleAddress;\r\n        refundable = true;\r\n        presaleAddress.transfer(poolTotal);\r\n    }\r\n\r\n    function refundPresale() payable public onState(State.Paid) {\r\n        require(refundable && msg.value >= poolTotal);\r\n        require(msg.sender == presaleAddress || isAdmin(msg.sender));\r\n        gasFundTotal = msg.value - poolTotal;\r\n        state = State.Failed;\r\n    }\r\n\r\n    function setToken(address tokenAddress) public onlyAdmins {\r\n        token = ERC20(tokenAddress);\r\n    }\r\n\r\n    function withdrawAll() public {\r\n        uint total = balances[msg.sender].remaining;\r\n        balances[msg.sender].remaining = 0;\r\n\r\n        if (state == State.Open || state == State.Failed) {\r\n            total += balances[msg.sender].contribution;\r\n            if (gasFundTotal > 0) {\r\n                uint gasRefund = (balances[msg.sender].contribution * gasFundTotal) / (poolTotal);\r\n                gasFundTotal -= gasRefund;\r\n                total += gasRefund;\r\n            }\r\n            poolTotal -= balances[msg.sender].contribution;\r\n            balances[msg.sender].contribution = 0;\r\n        } else {\r\n            require(state == State.Paid);\r\n        }\r\n\r\n        msg.sender.transfer(total);\r\n        Withdrawl(msg.sender, total);\r\n    }\r\n\r\n    function withdraw(uint amount) public onState(State.Open) {\r\n        uint total = balances[msg.sender].remaining + balances[msg.sender].contribution;\r\n        require(total >= amount);\r\n        uint debit = min(balances[msg.sender].remaining, amount);\r\n        balances[msg.sender].remaining -= debit;\r\n        debit = amount - debit;\r\n        balances[msg.sender].contribution -= debit;\r\n        poolTotal -= debit;\r\n\r\n        (balances[msg.sender].contribution, balances[msg.sender].remaining) = getContribution(msg.sender, 0);\r\n        // must respect the minContribution limit\r\n        require(balances[msg.sender].remaining == 0 || balances[msg.sender].contribution > 0);\r\n        msg.sender.transfer(amount);\r\n        Withdrawl(msg.sender, amount);\r\n    }\r\n\r\n    function transferMyTokens() public onState(State.Paid) noReentrancy {\r\n        uint tokenBalance = token.balanceOf(address(this));\r\n        require(tokenBalance > 0);\r\n\r\n        uint participantContribution = balances[msg.sender].contribution;\r\n        uint participantShare = participantContribution * tokenBalance / poolTotal;\r\n\r\n        poolTotal -= participantContribution;\r\n        balances[msg.sender].contribution = 0;\r\n        refundable = false;\r\n        require(token.transfer(msg.sender, participantShare));\r\n\r\n        Payout(msg.sender, participantShare);\r\n    }\r\n\r\n    address[] public failures;\r\n    function transferAllTokens() public onlyAdmins onState(State.Paid) noReentrancy returns (address[]) {\r\n        uint tokenBalance = token.balanceOf(address(this));\r\n        require(tokenBalance > 0);\r\n        delete failures;\r\n\r\n        for (uint i = 0; i < participants.length; i++) {\r\n            address participant = participants[i];\r\n            uint participantContribution = balances[participant].contribution;\r\n\r\n            if (participantContribution > 0) {\r\n                uint participantShare = participantContribution * tokenBalance / poolTotal;\r\n\r\n                poolTotal -= participantContribution;\r\n                balances[participant].contribution = 0;\r\n\r\n                if (token.transfer(participant, participantShare)) {\r\n                    refundable = false;\r\n                    Payout(participant, participantShare);\r\n                    tokenBalance -= participantShare;\r\n                    if (tokenBalance == 0) {\r\n                        break;\r\n                    }\r\n                } else {\r\n                    balances[participant].contribution = participantContribution;\r\n                    poolTotal += participantContribution;\r\n                    failures.push(participant);\r\n                }\r\n            }\r\n        }\r\n\r\n        return failures;\r\n    }\r\n\r\n    function modifyWhitelist(address[] toInclude, address[] toExclude) public onlyAdmins stateAllowsConfiguration {\r\n        bool previous = whitelistAll;\r\n        uint i;\r\n        if (previous) {\r\n            require(toExclude.length == 0);\r\n            for (i = 0; i < participants.length; i++) {\r\n                balances[participants[i]].whitelisted = false;\r\n            }\r\n            whitelistAll = false;\r\n        }\r\n\r\n        for (i = 0; i < toInclude.length; i++) {\r\n            balances[toInclude[i]].whitelisted = true;\r\n        }\r\n\r\n        address excludedParticipant;\r\n        uint contribution;\r\n        if (previous) {\r\n            for (i = 0; i < participants.length; i++) {\r\n                excludedParticipant = participants[i];\r\n                if (!balances[excludedParticipant].whitelisted) {\r\n                    contribution = balances[excludedParticipant].contribution;\r\n                    balances[excludedParticipant].contribution = 0;\r\n                    balances[excludedParticipant].remaining += contribution;\r\n                    poolTotal -= contribution;\r\n                }\r\n            }\r\n        } else {\r\n            for (i = 0; i < toExclude.length; i++) {\r\n                excludedParticipant = toExclude[i];\r\n                balances[excludedParticipant].whitelisted = false;\r\n                contribution = balances[excludedParticipant].contribution;\r\n                balances[excludedParticipant].contribution = 0;\r\n                balances[excludedParticipant].remaining += contribution;\r\n                poolTotal -= contribution;\r\n            }\r\n        }\r\n    }\r\n\r\n    function removeWhitelist() public onlyAdmins stateAllowsConfiguration {\r\n        if (!whitelistAll) {\r\n            whitelistAll = true;\r\n            for (uint i = 0; i < participants.length; i++) {\r\n                balances[participants[i]].whitelisted = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    function setContributionSettings(uint _minContribution, uint _maxContribution, uint _maxPoolTotal) public onlyAdmins stateAllowsConfiguration {\r\n        // we raised the minContribution threshold\r\n        bool recompute = (minContribution < _minContribution);\r\n        // we lowered the maxContribution threshold\r\n        recompute = recompute || (maxContribution > _maxContribution);\r\n        // we did not have a maxContribution threshold and now we do\r\n        recompute = recompute || (maxContribution == 0 && _maxContribution > 0);\r\n        // we want to make maxPoolTotal lower than the current pool total\r\n        recompute = recompute || (poolTotal > _maxPoolTotal);\r\n\r\n        minContribution = _minContribution;\r\n        maxContribution = _maxContribution;\r\n        maxPoolTotal = _maxPoolTotal;\r\n\r\n        if (maxContribution > 0) {\r\n            require(maxContribution >= minContribution);\r\n        }\r\n        if (maxPoolTotal > 0) {\r\n            require(maxPoolTotal >= minContribution);\r\n            require(maxPoolTotal >= maxContribution);\r\n        }\r\n\r\n        if (recompute) {\r\n            poolTotal = 0;\r\n            for (uint i = 0; i < participants.length; i++) {\r\n                address participant = participants[i];\r\n                var balance = balances[participant];\r\n                (balance.contribution, balance.remaining) = getContribution(participant, 0);\r\n                poolTotal += balance.contribution;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getParticipantBalances() public returns(address[], uint[], uint[], bool[], bool[]) {\r\n        uint[] memory contribution = new uint[](participants.length);\r\n        uint[] memory remaining = new uint[](participants.length);\r\n        bool[] memory whitelisted = new bool[](participants.length);\r\n        bool[] memory exists = new bool[](participants.length);\r\n\r\n        for (uint i = 0; i < participants.length; i++) {\r\n            var balance = balances[participants[i]];\r\n            contribution[i] = balance.contribution;\r\n            remaining[i] = balance.remaining;\r\n            whitelisted[i] = balance.whitelisted;\r\n            exists[i] = balance.exists;\r\n        }\r\n\r\n        return (participants, contribution, remaining, whitelisted, exists);\r\n    }\r\n\r\n    function deposit() internal onState(State.Open) {\r\n        if (msg.value > 0) {\r\n            require(included(msg.sender));\r\n            (balances[msg.sender].contribution, balances[msg.sender].remaining) = getContribution(msg.sender, msg.value);\r\n            // must respect the maxContribution and maxPoolTotal limits\r\n            require(balances[msg.sender].remaining == 0);\r\n            balances[msg.sender].whitelisted = true;\r\n            poolTotal += msg.value;\r\n            if (!balances[msg.sender].exists) {\r\n                balances[msg.sender].exists = true;\r\n                participants.push(msg.sender);\r\n            }\r\n            Deposit(msg.sender, msg.value);\r\n        }\r\n    }\r\n\r\n    function isAdmin(address addr) internal constant returns (bool) {\r\n        for (uint i = 0; i < admins.length; i++) {\r\n            if (admins[i] == addr) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function included(address participant) internal constant returns (bool) {\r\n        return whitelistAll || balances[participant].whitelisted || isAdmin(participant);\r\n    }\r\n\r\n    function getContribution(address participant, uint amount) internal constant returns (uint, uint) {\r\n        var balance = balances[participant];\r\n        uint total = balance.remaining + balance.contribution + amount;\r\n        uint contribution = total;\r\n        if (!included(participant)) {\r\n            return (0, total);\r\n        }\r\n        if (maxContribution > 0) {\r\n            contribution = min(maxContribution, contribution);\r\n        }\r\n        if (maxPoolTotal > 0) {\r\n            contribution = min(maxPoolTotal - poolTotal, contribution);\r\n        }\r\n        if (contribution < minContribution) {\r\n            return (0, total);\r\n        }\r\n        return (contribution, total - contribution);\r\n    }\r\n\r\n    function min(uint a, uint b) internal pure returns (uint _min) {\r\n        if (a < b) {\r\n            return a;\r\n        }\r\n        return b;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"admins\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"removeWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_presaleAddress\",\"type\":\"address\"}],\"name\":\"payToPresale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refundPresale\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"contribution\",\"type\":\"uint256\"},{\"name\":\"remaining\",\"type\":\"uint256\"},{\"name\":\"whitelisted\",\"type\":\"bool\"},{\"name\":\"exists\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"participants\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getParticipantBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"bool[]\"},{\"name\":\"\",\"type\":\"bool[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"close\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"transferAllTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whitelistAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"poolTotal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxContribution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minContribution\",\"type\":\"uint256\"},{\"name\":\"_maxContribution\",\"type\":\"uint256\"},{\"name\":\"_maxPoolTotal\",\"type\":\"uint256\"}],\"name\":\"setContributionSettings\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"fail\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minContribution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"failures\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"toInclude\",\"type\":\"address[]\"},{\"name\":\"toExclude\",\"type\":\"address[]\"}],\"name\":\"modifyWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"transferMyTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxPoolTotal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"open\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_minContribution\",\"type\":\"uint256\"},{\"name\":\"_maxContribution\",\"type\":\"uint256\"},{\"name\":\"_maxPoolTotal\",\"type\":\"uint256\"},{\"name\":\"_admins\",\"type\":\"address[]\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Payout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Withdrawl\",\"type\":\"event\"}]","ContractName":"PresalePool","CompilerVersion":"v0.4.16+commit.d7661dd9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://fa3372d264e6f716085c85bfa5952d5cf818fbea45d00ed1fa0a3f93e184d26d"}]}