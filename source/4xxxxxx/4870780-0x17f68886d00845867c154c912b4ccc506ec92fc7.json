{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract TokenLocker {\r\n    \r\n    address public owner;\r\n\r\n    ERC20 public token;\r\n\r\n    /**\r\n     * @dev Create a new TokenLocker contract\r\n     * @param tokenAddr ERC20 token this contract will be used to lock\r\n     */\r\n    function TokenLocker (ERC20 tokenAddr) public {\r\n        owner = msg.sender;\r\n        token = tokenAddr;\r\n    }\r\n\r\n    /** \r\n     *  @dev Call the ERC20 `transfer` function on the underlying token contract\r\n     *  @param dest Token destination\r\n     *  @param amount Amount of tokens to be transferred\r\n     */\r\n    function transfer(address dest, uint amount) public returns (bool) {\r\n        require(msg.sender == owner);\r\n        return token.transfer(dest, amount);\r\n    }\r\n\r\n}\r\n\r\ncontract TokenRecipient {\r\n    event ReceivedEther(address indexed sender, uint amount);\r\n    event ReceivedTokens(address indexed from, uint256 value, address indexed token, bytes extraData);\r\n\r\n    /**\r\n     * @dev Receive tokens and generate a log event\r\n     * @param from Address from which to transfer tokens\r\n     * @param value Amount of tokens to transfer\r\n     * @param token Address of token\r\n     * @param extraData Additional data to log\r\n     */\r\n    function receiveApproval(address from, uint256 value, address token, bytes extraData) public {\r\n        ERC20 t = ERC20(token);\r\n        require(t.transferFrom(from, this, value));\r\n        ReceivedTokens(from, value, token, extraData);\r\n    }\r\n\r\n    /**\r\n     * @dev Receive Ether and generate a log event\r\n     */\r\n    function () payable public {\r\n        ReceivedEther(msg.sender, msg.value);\r\n    }\r\n}\r\n\r\ncontract DelegatedShareholderAssociation is TokenRecipient {\r\n\r\n    uint public minimumQuorum;\r\n    uint public debatingPeriodInMinutes;\r\n    Proposal[] public proposals;\r\n    uint public numProposals;\r\n    ERC20 public sharesTokenAddress;\r\n\r\n    /* Delegate addresses by delegator. */\r\n    mapping (address => address) public delegatesByDelegator;\r\n\r\n    /* Locked tokens by delegator. */\r\n    mapping (address => uint) public lockedDelegatingTokens;\r\n\r\n    /* Delegated votes by delegate. */\r\n    mapping (address => uint) public delegatedAmountsByDelegate;\r\n    \r\n    /* Tokens currently locked by vote delegation. */\r\n    uint public totalLockedTokens;\r\n\r\n    /* Threshold for the ability to create proposals. */\r\n    uint public requiredSharesToBeBoardMember;\r\n\r\n    /* Token Locker contract. */\r\n    TokenLocker public tokenLocker;\r\n\r\n    /* Events for all state changes. */\r\n\r\n    event ProposalAdded(uint proposalID, address recipient, uint amount, bytes metadataHash);\r\n    event Voted(uint proposalID, bool position, address voter);\r\n    event ProposalTallied(uint proposalID, uint yea, uint nay, uint quorum, bool active);\r\n    event ChangeOfRules(uint newMinimumQuorum, uint newDebatingPeriodInMinutes, address newSharesTokenAddress);\r\n    event TokensDelegated(address indexed delegator, uint numberOfTokens, address indexed delegate);\r\n    event TokensUndelegated(address indexed delegator, uint numberOfTokens, address indexed delegate);\r\n\r\n    struct Proposal {\r\n        address recipient;\r\n        uint amount;\r\n        bytes metadataHash;\r\n        uint timeCreated;\r\n        uint votingDeadline;\r\n        bool finalized;\r\n        bool proposalPassed;\r\n        uint numberOfVotes;\r\n        bytes32 proposalHash;\r\n        Vote[] votes;\r\n        mapping (address => bool) voted;\r\n    }\r\n\r\n    struct Vote {\r\n        bool inSupport;\r\n        address voter;\r\n    }\r\n\r\n    /* Only shareholders can execute a function with this modifier. */\r\n    modifier onlyShareholders {\r\n        require(ERC20(sharesTokenAddress).balanceOf(msg.sender) > 0);\r\n        _;\r\n    }\r\n\r\n    /* Only the DAO itself (via an approved proposal) can execute a function with this modifier. */\r\n    modifier onlySelf {\r\n        require(msg.sender == address(this));\r\n        _;\r\n    }\r\n\r\n    /* Any account except the DAO itself can execute a function with this modifier. */\r\n    modifier notSelf {\r\n        require(msg.sender != address(this));\r\n        _;\r\n    }\r\n\r\n    /* Only a shareholder who has *not* delegated his vote can execute a function with this modifier. */\r\n    modifier onlyUndelegated {\r\n        require(delegatesByDelegator[msg.sender] == address(0));\r\n        _;\r\n    }\r\n\r\n    /* Only boardmembers (shareholders above a certain threshold) can execute a function with this modifier. */\r\n    modifier onlyBoardMembers {\r\n        require(ERC20(sharesTokenAddress).balanceOf(msg.sender) >= requiredSharesToBeBoardMember);\r\n        _;\r\n    }\r\n\r\n    /* Only a shareholder who has delegated his vote can execute a function with this modifier. */\r\n    modifier onlyDelegated {\r\n        require(delegatesByDelegator[msg.sender] != address(0));\r\n        _;\r\n    }\r\n\r\n    /**\r\n      * Delegate an amount of tokens\r\n      * \r\n      * @notice Set the delegate address for a specified number of tokens belonging to the sending address, locking the tokens.\r\n      * @dev An address holding tokens (shares) may only delegate some portion of their vote to one delegate at any one time\r\n      * @param tokensToLock number of tokens to be locked (sending address must have at least this many tokens)\r\n      * @param delegate the address to which votes equal to the number of tokens locked will be delegated\r\n      */\r\n    function setDelegateAndLockTokens(uint tokensToLock, address delegate)\r\n        public\r\n        onlyShareholders\r\n        onlyUndelegated\r\n        notSelf\r\n    {\r\n        lockedDelegatingTokens[msg.sender] = tokensToLock;\r\n        delegatedAmountsByDelegate[delegate] = SafeMath.add(delegatedAmountsByDelegate[delegate], tokensToLock);\r\n        totalLockedTokens = SafeMath.add(totalLockedTokens, tokensToLock);\r\n        delegatesByDelegator[msg.sender] = delegate;\r\n        require(sharesTokenAddress.transferFrom(msg.sender, tokenLocker, tokensToLock));\r\n        require(sharesTokenAddress.balanceOf(tokenLocker) == totalLockedTokens);\r\n        TokensDelegated(msg.sender, tokensToLock, delegate);\r\n    }\r\n\r\n    /** \r\n     * Undelegate all delegated tokens\r\n     * \r\n     * @notice Clear the delegate address for all tokens delegated by the sending address, unlocking the locked tokens.\r\n     * @dev Can only be called by a sending address currently delegating tokens, will transfer all locked tokens back to the sender\r\n     * @return The number of tokens previously locked, now released\r\n     */\r\n    function clearDelegateAndUnlockTokens()\r\n        public\r\n        onlyDelegated\r\n        notSelf\r\n        returns (uint lockedTokens)\r\n    {\r\n        address delegate = delegatesByDelegator[msg.sender];\r\n        lockedTokens = lockedDelegatingTokens[msg.sender];\r\n        lockedDelegatingTokens[msg.sender] = 0;\r\n        delegatedAmountsByDelegate[delegate] = SafeMath.sub(delegatedAmountsByDelegate[delegate], lockedTokens);\r\n        totalLockedTokens = SafeMath.sub(totalLockedTokens, lockedTokens);\r\n        delete delegatesByDelegator[msg.sender];\r\n        require(tokenLocker.transfer(msg.sender, lockedTokens));\r\n        require(sharesTokenAddress.balanceOf(tokenLocker) == totalLockedTokens);\r\n        TokensUndelegated(msg.sender, lockedTokens, delegate);\r\n        return lockedTokens;\r\n    }\r\n\r\n    /**\r\n     * Change voting rules\r\n     *\r\n     * Make so that proposals need tobe discussed for at least `minutesForDebate/60` hours\r\n     * and all voters combined must own more than `minimumSharesToPassAVote` shares of token `sharesAddress` to be executed\r\n     * and a shareholder needs `sharesToBeBoardMember` shares to create a transaction proposal\r\n     *\r\n     * @param minimumSharesToPassAVote proposal can vote only if the sum of shares held by all voters exceed this number\r\n     * @param minutesForDebate the minimum amount of delay between when a proposal is made and when it can be executed\r\n     * @param sharesToBeBoardMember the minimum number of shares required to create proposals\r\n     */\r\n    function changeVotingRules(uint minimumSharesToPassAVote, uint minutesForDebate, uint sharesToBeBoardMember)\r\n        public\r\n        onlySelf\r\n    {\r\n        if (minimumSharesToPassAVote == 0 ) {\r\n            minimumSharesToPassAVote = 1;\r\n        }\r\n        minimumQuorum = minimumSharesToPassAVote;\r\n        debatingPeriodInMinutes = minutesForDebate;\r\n        requiredSharesToBeBoardMember = sharesToBeBoardMember;\r\n        ChangeOfRules(minimumQuorum, debatingPeriodInMinutes, sharesTokenAddress);\r\n    }\r\n\r\n    /**\r\n     * Add Proposal\r\n     *\r\n     * Propose to send `weiAmount / 1e18` ether to `beneficiary` for `jobMetadataHash`. `transactionBytecode ? Contains : Does not contain` code.\r\n     *\r\n     * @dev Submit proposal for the DAO to execute a particular transaction. Submitter should check that the `beneficiary` account exists, unless the intent is to burn Ether.\r\n     * @param beneficiary who to send the ether to\r\n     * @param weiAmount amount of ether to send, in wei\r\n     * @param jobMetadataHash Hash of job metadata (IPFS)\r\n     * @param transactionBytecode bytecode of transaction\r\n     */\r\n    function newProposal(\r\n        address beneficiary,\r\n        uint weiAmount,\r\n        bytes jobMetadataHash,\r\n        bytes transactionBytecode\r\n    )\r\n        public\r\n        onlyBoardMembers\r\n        notSelf\r\n        returns (uint proposalID)\r\n    {\r\n        /* Proposals cannot be directed to the token locking contract. */\r\n        require(beneficiary != address(tokenLocker));\r\n        proposalID = proposals.length++;\r\n        Proposal storage p = proposals[proposalID];\r\n        p.recipient = beneficiary;\r\n        p.amount = weiAmount;\r\n        p.metadataHash = jobMetadataHash;\r\n        p.proposalHash = keccak256(beneficiary, weiAmount, transactionBytecode);\r\n        p.timeCreated = now;\r\n        p.votingDeadline = now + debatingPeriodInMinutes * 1 minutes;\r\n        p.finalized = false;\r\n        p.proposalPassed = false;\r\n        p.numberOfVotes = 0;\r\n        ProposalAdded(proposalID, beneficiary, weiAmount, jobMetadataHash);\r\n        numProposals = proposalID+1;\r\n        return proposalID;\r\n    }\r\n\r\n    /**\r\n     * Check if a proposal code matches\r\n     *\r\n     * @param proposalNumber ID number of the proposal to query\r\n     * @param beneficiary who to send the ether to\r\n     * @param weiAmount amount of ether to send\r\n     * @param transactionBytecode bytecode of transaction\r\n     */\r\n    function checkProposalCode(\r\n        uint proposalNumber,\r\n        address beneficiary,\r\n        uint weiAmount,\r\n        bytes transactionBytecode\r\n    )\r\n        public\r\n        view\r\n        returns (bool codeChecksOut)\r\n    {\r\n        Proposal storage p = proposals[proposalNumber];\r\n        return p.proposalHash == keccak256(beneficiary, weiAmount, transactionBytecode);\r\n    }\r\n\r\n    /**\r\n     * Log a vote for a proposal\r\n     *\r\n     * Vote `supportsProposal? in support of : against` proposal #`proposalNumber`\r\n     *\r\n     * @dev Vote in favor or against an existing proposal. Voter should check that the proposal destination account exists, unless the intent is to burn Ether.\r\n     * @param proposalNumber number of proposal\r\n     * @param supportsProposal either in favor or against it\r\n     */\r\n    function vote(\r\n        uint proposalNumber,\r\n        bool supportsProposal\r\n    )\r\n        public\r\n        onlyShareholders\r\n        notSelf\r\n        returns (uint voteID)\r\n    {\r\n        Proposal storage p = proposals[proposalNumber];\r\n        require(p.voted[msg.sender] != true);\r\n        voteID = p.votes.length++;\r\n        p.votes[voteID] = Vote({inSupport: supportsProposal, voter: msg.sender});\r\n        p.voted[msg.sender] = true;\r\n        p.numberOfVotes = voteID + 1;\r\n        Voted(proposalNumber, supportsProposal, msg.sender);\r\n        return voteID;\r\n    }\r\n\r\n    /**\r\n     * Return whether a particular shareholder has voted on a particular proposal (convenience function)\r\n     * @param proposalNumber proposal number\r\n     * @param shareholder address to query\r\n     * @return whether or not the specified address has cast a vote on the specified proposal\r\n     */\r\n    function hasVoted(uint proposalNumber, address shareholder) public view returns (bool) {\r\n        Proposal storage p = proposals[proposalNumber];\r\n        return p.voted[shareholder];\r\n    }\r\n\r\n    /**\r\n     * Count the votes, including delegated votes, in support of, against, and in total for a particular proposal\r\n     * @param proposalNumber proposal number\r\n     * @return yea votes, nay votes, quorum (total votes)\r\n     */\r\n    function countVotes(uint proposalNumber) public view returns (uint yea, uint nay, uint quorum) {\r\n        Proposal storage p = proposals[proposalNumber];\r\n        yea = 0;\r\n        nay = 0;\r\n        quorum = 0;\r\n        for (uint i = 0; i < p.votes.length; ++i) {\r\n            Vote storage v = p.votes[i];\r\n            uint voteWeight = SafeMath.add(sharesTokenAddress.balanceOf(v.voter), delegatedAmountsByDelegate[v.voter]);\r\n            quorum = SafeMath.add(quorum, voteWeight);\r\n            if (v.inSupport) {\r\n                yea = SafeMath.add(yea, voteWeight);\r\n            } else {\r\n                nay = SafeMath.add(nay, voteWeight);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Finish vote\r\n     *\r\n     * Count the votes proposal #`proposalNumber` and execute it if approved\r\n     *\r\n     * @param proposalNumber proposal number\r\n     * @param transactionBytecode optional: if the transaction contained a bytecode, you need to send it\r\n     */\r\n    function executeProposal(uint proposalNumber, bytes transactionBytecode)\r\n        public\r\n        notSelf\r\n    {\r\n        Proposal storage p = proposals[proposalNumber];\r\n\r\n        /* If at or past deadline, not already finalized, and code is correct, keep going. */\r\n        require((now >= p.votingDeadline) && !p.finalized && p.proposalHash == keccak256(p.recipient, p.amount, transactionBytecode));\r\n\r\n        /* Count the votes. */\r\n        var ( yea, nay, quorum ) = countVotes(proposalNumber);\r\n\r\n        /* Assert that a minimum quorum has been reached. */\r\n        require(quorum >= minimumQuorum);\r\n        \r\n        /* Mark proposal as finalized. */   \r\n        p.finalized = true;\r\n\r\n        if (yea > nay) {\r\n            /* Mark proposal as passed. */\r\n            p.proposalPassed = true;\r\n\r\n            /* Execute the function. */\r\n            require(p.recipient.call.value(p.amount)(transactionBytecode));\r\n\r\n        } else {\r\n            /* Proposal failed. */\r\n            p.proposalPassed = false;\r\n        }\r\n\r\n        /* Log event. */\r\n        ProposalTallied(proposalNumber, yea, nay, quorum, p.proposalPassed);\r\n    }\r\n}\r\n\r\ncontract WyvernDAO is DelegatedShareholderAssociation {\r\n\r\n    string public constant name = \"Project Wyvern DAO\";\r\n\r\n    uint public constant TOKEN_DECIMALS                     = 18;\r\n    uint public constant REQUIRED_SHARES_TO_BE_BOARD_MEMBER = 2000 * (10 ** TOKEN_DECIMALS); // set to ~ 0.1% of supply\r\n    uint public constant MINIMUM_QUORUM                     = 200000 * (10 ** TOKEN_DECIMALS); // set to 10% of supply\r\n    uint public constant DEBATE_PERIOD_MINUTES              = 60 * 24 * 3; // set to 3 days\r\n\r\n    function WyvernDAO (ERC20 sharesAddress) public {\r\n        sharesTokenAddress = sharesAddress;\r\n        requiredSharesToBeBoardMember = REQUIRED_SHARES_TO_BE_BOARD_MEMBER;\r\n        minimumQuorum = MINIMUM_QUORUM;\r\n        debatingPeriodInMinutes = DEBATE_PERIOD_MINUTES;\r\n        tokenLocker = new TokenLocker(sharesAddress);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"metadataHash\",\"type\":\"bytes\"},{\"name\":\"timeCreated\",\"type\":\"uint256\"},{\"name\":\"votingDeadline\",\"type\":\"uint256\"},{\"name\":\"finalized\",\"type\":\"bool\"},{\"name\":\"proposalPassed\",\"type\":\"bool\"},{\"name\":\"numberOfVotes\",\"type\":\"uint256\"},{\"name\":\"proposalHash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"delegatesByDelegator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REQUIRED_SHARES_TO_BE_BOARD_MEMBER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lockedDelegatingTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"proposalNumber\",\"type\":\"uint256\"}],\"name\":\"countVotes\",\"outputs\":[{\"name\":\"yea\",\"type\":\"uint256\"},{\"name\":\"nay\",\"type\":\"uint256\"},{\"name\":\"quorum\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"proposalNumber\",\"type\":\"uint256\"},{\"name\":\"transactionBytecode\",\"type\":\"bytes\"}],\"name\":\"executeProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sharesTokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"delegatedAmountsByDelegate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numProposals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"proposalNumber\",\"type\":\"uint256\"},{\"name\":\"shareholder\",\"type\":\"address\"}],\"name\":\"hasVoted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_DECIMALS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokensToLock\",\"type\":\"uint256\"},{\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"setDelegateAndLockTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"clearDelegateAndUnlockTokens\",\"outputs\":[{\"name\":\"lockedTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"debatingPeriodInMinutes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"minimumSharesToPassAVote\",\"type\":\"uint256\"},{\"name\":\"minutesForDebate\",\"type\":\"uint256\"},{\"name\":\"sharesToBeBoardMember\",\"type\":\"uint256\"}],\"name\":\"changeVotingRules\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumQuorum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"receiveApproval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenLocker\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MINIMUM_QUORUM\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"requiredSharesToBeBoardMember\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"proposalNumber\",\"type\":\"uint256\"},{\"name\":\"supportsProposal\",\"type\":\"bool\"}],\"name\":\"vote\",\"outputs\":[{\"name\":\"voteID\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"weiAmount\",\"type\":\"uint256\"},{\"name\":\"jobMetadataHash\",\"type\":\"bytes\"},{\"name\":\"transactionBytecode\",\"type\":\"bytes\"}],\"name\":\"newProposal\",\"outputs\":[{\"name\":\"proposalID\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DEBATE_PERIOD_MINUTES\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"proposalNumber\",\"type\":\"uint256\"},{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"weiAmount\",\"type\":\"uint256\"},{\"name\":\"transactionBytecode\",\"type\":\"bytes\"}],\"name\":\"checkProposalCode\",\"outputs\":[{\"name\":\"codeChecksOut\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalLockedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"sharesAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"proposalID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"metadataHash\",\"type\":\"bytes\"}],\"name\":\"ProposalAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"proposalID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"position\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"Voted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"proposalID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"yea\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nay\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"quorum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"ProposalTallied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newMinimumQuorum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newDebatingPeriodInMinutes\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newSharesTokenAddress\",\"type\":\"address\"}],\"name\":\"ChangeOfRules\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"delegator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"numberOfTokens\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"TokensDelegated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"delegator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"numberOfTokens\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"TokensUndelegated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReceivedEther\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"ReceivedTokens\",\"type\":\"event\"}]","ContractName":"WyvernDAO","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000056017c55ae7ae32d12aef7c679df83a85ca75ff","Library":"","SwarmSource":"bzzr://034deef1551c458c17f29dd97009e6cb31537e228033774d62944011d6ea30b0"}]}