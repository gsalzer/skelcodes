{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *  The Monetha token contract complies with the ERC20 standard (see https://github.com/ethereum/EIPs/issues/20).\r\n *  The owner's share of tokens is locked for the first year and all tokens not\r\n *  being sold during the crowdsale but the owner's share + reserved tokend for bounty, loyalty program and future financing are burned.\r\n *  Author: Julia Altenried\r\n *  Internal audit: Alex Bazhanau, Andrej Ruckij\r\n *  Audit: Blockchain & Smart Contract Security Group\r\n **/\r\n\r\npragma solidity ^0.4.15;\r\n\r\ncontract SafeMath {\r\n\t//internals\r\n\r\n\tfunction safeMul(uint a, uint b) internal returns(uint) {\r\n\t\tuint c = a * b;\r\n\t\tassert(a == 0 || c / a == b);\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction safeSub(uint a, uint b) internal returns(uint) {\r\n\t\tassert(b <= a);\r\n\t\treturn a - b;\r\n\t}\r\n\r\n\tfunction safeAdd(uint a, uint b) internal returns(uint) {\r\n\t\tuint c = a + b;\r\n\t\tassert(c >= a && c >= b);\r\n\t\treturn c;\r\n\t}\r\n}\r\n\r\ncontract MonethaToken is SafeMath {\r\n\t/* Public variables of the token */\r\n\tstring constant public standard = \"ERC20\";\r\n\tstring constant public name = \"Monetha\";\r\n\tstring constant public symbol = \"MTH\";\r\n\tuint8 constant public decimals = 5;\r\n\tuint public totalSupply = 40240000000000;\r\n\tuint constant public tokensForIco = 20120000000000;\r\n\tuint constant public reservedAmount = 20120000000000;\r\n\tuint constant public lockedAmount = 15291200000000;\r\n\taddress public owner;\r\n\taddress public ico;\r\n\t/* from this time on tokens may be transfered (after ICO)*/\r\n\tuint public startTime;\r\n\tuint public lockReleaseDate;\r\n\t/* tells if tokens have been burned already */\r\n\tbool burned;\r\n\r\n\t/* This creates an array with all balances */\r\n\tmapping(address => uint) public balanceOf;\r\n\tmapping(address => mapping(address => uint)) public allowance;\r\n\r\n\r\n\t/* This generates a public event on the blockchain that will notify clients */\r\n\tevent Transfer(address indexed from, address indexed to, uint value);\r\n\tevent Approval(address indexed _owner, address indexed spender, uint value);\r\n\tevent Burned(uint amount);\r\n\r\n\t/* Initializes contract with initial supply tokens to the creator of the contract */\r\n\tfunction MonethaToken(address _ownerAddr, uint _startTime) {\r\n\t\towner = _ownerAddr;\r\n\t\tstartTime = _startTime;\r\n\t\tlockReleaseDate = startTime + 1 years;\r\n\t\tbalanceOf[owner] = totalSupply; // Give the owner all initial tokens\r\n\t}\r\n\r\n\t/* Send some of your tokens to a given address */\r\n\tfunction transfer(address _to, uint _value) returns(bool success) {\r\n\t\trequire(now >= startTime); //check if the crowdsale is already over\r\n\t\tif (msg.sender == owner && now < lockReleaseDate) \r\n\t\t\trequire(safeSub(balanceOf[msg.sender], _value) >= lockedAmount); //prevent the owner of spending his share of tokens for company, loyalty program and future financing of the company within the first year\r\n\t\tbalanceOf[msg.sender] = safeSub(balanceOf[msg.sender], _value); // Subtract from the sender\r\n\t\tbalanceOf[_to] = safeAdd(balanceOf[_to], _value); // Add the same to the recipient\r\n\t\tTransfer(msg.sender, _to, _value); // Notify anyone listening that this transfer took place\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/* Allow another contract or person to spend some tokens in your behalf */\r\n\tfunction approve(address _spender, uint _value) returns(bool success) {\r\n\t\treturn _approve(_spender,_value);\r\n\t}\r\n\t\r\n\t/* internal approve functionality. needed, so we can check the payloadsize if called externally, but smaller \r\n\t*  payload allowed internally */\r\n\tfunction _approve(address _spender, uint _value) internal returns(bool success) {\r\n\t\t//  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n\t\trequire((_value == 0) || (allowance[msg.sender][_spender] == 0));\r\n\t\tallowance[msg.sender][_spender] = _value;\r\n\t\tApproval(msg.sender, _spender, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\r\n\t/* A contract or  person attempts to get the tokens of somebody else.\r\n\t *  This is only allowed if the token holder approved. */\r\n\tfunction transferFrom(address _from, address _to, uint _value) returns(bool success) {\r\n\t\tif (now < startTime) \r\n\t\t\trequire(_from == owner); //check if the crowdsale is already over\r\n\t\tif (_from == owner && now < lockReleaseDate) \r\n\t\t\trequire(safeSub(balanceOf[_from], _value) >= lockedAmount); //prevent the owner of spending his share of tokens for company, loyalty program and future financing of the company within the first year\r\n\t\tvar _allowance = allowance[_from][msg.sender];\r\n\t\tbalanceOf[_from] = safeSub(balanceOf[_from], _value); // Subtract from the sender\r\n\t\tbalanceOf[_to] = safeAdd(balanceOf[_to], _value); // Add the same to the recipient\r\n\t\tallowance[_from][msg.sender] = safeSub(_allowance, _value);\r\n\t\tTransfer(_from, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\r\n\t/* to be called when ICO is closed. burns the remaining tokens except the company share (60360000), the tokens reserved\r\n\t *  for the bounty/advisors/marketing program (48288000), for the loyalty program (52312000) and for future financing of the company (40240000).\r\n\t *  anybody may burn the tokens after ICO ended, but only once (in case the owner holds more tokens in the future).\r\n\t *  this ensures that the owner will not posses a majority of the tokens. */\r\n\tfunction burn() {\r\n\t\t//if tokens have not been burned already and the ICO ended\r\n\t\tif (!burned && now > startTime) {\r\n\t\t\tuint difference = safeSub(balanceOf[owner], reservedAmount);\r\n\t\t\tbalanceOf[owner] = reservedAmount;\r\n\t\t\ttotalSupply = safeSub(totalSupply, difference);\r\n\t\t\tburned = true;\r\n\t\t\tBurned(difference);\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t* sets the ico address and give it allowance to spend the crowdsale tokens. Only callable once.\r\n\t* @param _icoAddress the address of the ico contract\r\n\t* value the max amount of tokens to sell during the ICO\r\n\t**/\r\n\tfunction setICO(address _icoAddress) {\r\n\t\trequire(msg.sender == owner);\r\n\t\tico = _icoAddress;\r\n\t\tassert(_approve(ico, tokensForIco));\r\n\t}\r\n\t\r\n\t/**\r\n\t* Allows the ico contract to set the trading start time to an earlier point of time.\r\n\t* (In case the soft cap has been reached)\r\n\t* @param _newStart the new start date\r\n\t**/\r\n\tfunction setStart(uint _newStart) {\r\n\t\trequire(msg.sender == ico && _newStart < startTime);\r\n\t\tstartTime = _newStart;\r\n\t}\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"standard\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ico\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockedAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensForIco\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockReleaseDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_icoAddress\",\"type\":\"address\"}],\"name\":\"setICO\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newStart\",\"type\":\"uint256\"}],\"name\":\"setStart\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reservedAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_ownerAddr\",\"type\":\"address\"},{\"name\":\"_startTime\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Burned\",\"type\":\"event\"}]","ContractName":"MonethaToken","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000027bcc0275ed76e0b338a42e7e08dec36d256780000000000000000000000000000000000000000000000000000000059cfa360","Library":"","SwarmSource":"bzzr://1ece16a4849d6f063ac16d4723492df94b137bb9f49ec010ea71aa0475f8a1f8"}]}