{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n * @dev Based on code by OpenZeppelin: https://github.com/OpenZeppelin/zeppelin-solidity/blob/v1.4.0/contracts/math/SafeMath.sol\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b > 0);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n * @dev Based on code by OpenZeppelin: https://github.com/OpenZeppelin/zeppelin-solidity/blob/v1.4.0/contracts/ownership/Ownable.sol\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n * @dev Based on code by OpenZeppelin: https://github.com/OpenZeppelin/zeppelin-solidity/blob/v1.4.0/contracts/lifecycle/Pausable.sol\r\n */\r\ncontract Pausable is Ownable {\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool public paused = false;\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to pause, triggers stopped state\r\n     */\r\n    function pause() public onlyOwner whenNotPaused {\r\n        paused = true;\r\n        Pause();\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to unpause, returns to normal state\r\n     */\r\n    function unpause() public onlyOwner whenPaused {\r\n        paused = false;\r\n        Unpause();\r\n    }\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n * @dev Based on code by OpenZeppelin: https://github.com/OpenZeppelin/zeppelin-solidity/blob/v1.4.0/contracts/token/ERC20Basic.sol\r\n */\r\ncontract ERC20Basic {\r\n    uint256 public totalSupply;\r\n\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n * @dev Based on code by OpenZeppelin: https://github.com/OpenZeppelin/zeppelin-solidity/blob/v1.4.0/contracts/token/BasicToken.sol\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => uint256) balances;\r\n\r\n    /**\r\n    * @dev Transfer token for a specified address\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[msg.sender]);\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param _owner The address to query the the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by OpenZeppelin: https://github.com/OpenZeppelin/zeppelin-solidity/blob/v1.4.0/contracts/token/ERC20.sol\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    \r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by OpenZeppelin: https://github.com/OpenZeppelin/zeppelin-solidity/blob/v1.4.0/contracts/token/StandardToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another\r\n     * @param _from address The address which you want to send tokens from\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 the amount of tokens to be transferred\r\n     * @return A boolean that indicates if the operation was successful.\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[_from]);\r\n        require(_value <= allowed[_from][msg.sender]);\r\n\r\n        uint256 _allowance = allowed[_from][msg.sender];\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = _allowance.sub(_value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     *\r\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _value The amount of tokens to be spent.\r\n     * @return A boolean that indicates if the operation was successful.\r\n     */\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param _owner address The address which owns the funds.\r\n     * @param _spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(address _owner, address _spender) public view returns (uint256) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n}\r\n\r\n/**\r\n * @title Mintable token\r\n * @dev Simple ERC20 Token example, with mintable token creation\r\n * @dev Based on code by OpenZeppelin: https://github.com/OpenZeppelin/zeppelin-solidity/blob/v1.4.0/contracts/token/MintableToken.sol\r\n */\r\n\r\ncontract MintableToken is StandardToken, Ownable {\r\n    event Mint(address indexed to, uint256 amount);\r\n    event MintFinished();\r\n\r\n    bool public mintingFinished = false;\r\n\r\n    address public mintAddress;\r\n\r\n    modifier canMint() {\r\n        require(!mintingFinished);\r\n        _;\r\n    }\r\n\r\n    modifier onlyMint() {\r\n        require(msg.sender == mintAddress);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to change address that is allowed to do emission.\r\n     * @param _mintAddress Address of the emission contract.\r\n     */\r\n    function setMintAddress(address _mintAddress) public onlyOwner {\r\n        require(_mintAddress != address(0));\r\n        mintAddress = _mintAddress;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to mint tokens\r\n     * @param _to The address that will receive the minted tokens.\r\n     * @param _amount The amount of tokens to mint.\r\n     * @return A boolean that indicates if the operation was successful.\r\n     */\r\n    function mint(address _to, uint256 _amount) public onlyMint canMint returns (bool) {\r\n        totalSupply = totalSupply.add(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        Mint(_to, _amount);\r\n        Transfer(address(0), _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to stop minting new tokens.\r\n     * @return True if the operation was successful.\r\n     */\r\n    function finishMinting() public onlyMint canMint returns (bool) {\r\n        mintingFinished = true;\r\n        MintFinished();\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * @title TokenTimelock\r\n * @dev TokenTimelock is a token holder contract that will allow a\r\n * beneficiary to extract the tokens after a given release time\r\n * @dev Based on code by OpenZeppelin: https://github.com/OpenZeppelin/zeppelin-solidity/blob/v1.4.0/contracts/token/TokenTimelock.sol\r\n */\r\ncontract TokenTimelock {\r\n    // ERC20 basic token contract being held\r\n    ERC20Basic public token;\r\n\r\n    // beneficiary of tokens after they are released\r\n    address public beneficiary;\r\n\r\n    // timestamp when token release is enabled\r\n    uint256 public releaseTime;\r\n\r\n    /**\r\n     * @dev The TokenTimelock constructor sets token address, beneficiary and time to release.\r\n     * @param _token Address of the token\r\n     * @param _beneficiary Address that will receive the tokens after release\r\n     * @param _releaseTime Time that will allow release the tokens\r\n     */\r\n    function TokenTimelock(ERC20Basic _token, address _beneficiary, uint256 _releaseTime) public {\r\n        require(_releaseTime > now);\r\n        token = _token;\r\n        beneficiary = _beneficiary;\r\n        releaseTime = _releaseTime;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers tokens held by timelock to beneficiary.\r\n     */\r\n    function release() public {\r\n        require(now >= releaseTime);\r\n\r\n        uint256 amount = token.balanceOf(this);\r\n        require(amount > 0);\r\n\r\n        token.transfer(beneficiary, amount);\r\n    }\r\n}\r\n\r\n/**\r\n * @title CraftyCrowdsale\r\n * @dev CraftyCrowdsale is a contract for managing a Crafty token crowdsale.\r\n */\r\ncontract CraftyCrowdsale is Pausable {\r\n    using SafeMath for uint256;\r\n\r\n    // Amount received from each address\r\n    mapping(address => uint256) received;\r\n\r\n    // The token being sold\r\n    MintableToken public token;\r\n\r\n    // start and end timestamps where investments are allowed (both inclusive)\r\n    uint256 public preSaleStart;\r\n    uint256 public preSaleEnd;\r\n    uint256 public saleStart;\r\n    uint256 public saleEnd;\r\n\r\n    // amount of tokens sold\r\n    uint256 public issuedTokens = 0;\r\n\r\n    // token cap\r\n    uint256 public constant hardCap = 5000000000 * 10**8; // 50%\r\n\r\n    // token wallets\r\n    uint256 constant teamCap = 1450000000 * 10**8; // 14.5%\r\n    uint256 constant advisorCap = 450000000 * 10**8; // 4.5%\r\n    uint256 constant bountyCap = 100000000 * 10**8; // 1%\r\n    uint256 constant fundCap = 3000000000 * 10**8; // 30%\r\n\r\n    // Number of days the tokens will be locked\r\n    uint256 constant lockTime = 180 days;\r\n\r\n    // wallets\r\n    address public etherWallet;\r\n    address public teamWallet;\r\n    address public advisorWallet;\r\n    address public fundWallet;\r\n    address public bountyWallet;\r\n\r\n    // timelocked tokens\r\n    TokenTimelock teamTokens;\r\n\r\n    uint256 public rate;\r\n\r\n    enum State { BEFORE_START, SALE, REFUND, CLOSED }\r\n    State currentState = State.BEFORE_START;\r\n\r\n    /**\r\n     * @dev Event for token purchase logging\r\n     * @param purchaser who paid for the tokens\r\n     * @param beneficiary who got the tokens\r\n     * @param amount amount of tokens purchased\r\n     */\r\n    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 amount);\r\n\r\n    /**\r\n     * @dev Event for refund\r\n     * @param to who sent wei\r\n     * @param amount amount of wei refunded\r\n     */\r\n    event Refund(address indexed to, uint256 amount);\r\n\r\n    /**\r\n     * @dev modifier to allow token creation only when the sale is on\r\n     */\r\n    modifier saleIsOn() {\r\n        require(\r\n            (\r\n                (now >= preSaleStart && now < preSaleEnd) || \r\n                (now >= saleStart && now < saleEnd)\r\n            ) && \r\n            issuedTokens < hardCap && \r\n            currentState == State.SALE\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev modifier to allow action only before sale\r\n     */\r\n    modifier beforeSale() {\r\n        require( now < preSaleStart);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev modifier that fails if state doesn't match\r\n     */\r\n    modifier inState(State _state) {\r\n        require(currentState == _state);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev CraftyCrowdsale constructor sets the token, period and exchange rate\r\n     * @param _token The address of Crafty Token.\r\n     * @param _preSaleStart The start time of pre-sale.\r\n     * @param _preSaleEnd The end time of pre-sale.\r\n     * @param _saleStart The start time of sale.\r\n     * @param _saleEnd The end time of sale.\r\n     * @param _rate The exchange rate of tokens.\r\n     */\r\n    function CraftyCrowdsale(address _token, uint256 _preSaleStart, uint256 _preSaleEnd, uint256 _saleStart, uint256 _saleEnd, uint256 _rate) public {\r\n        require(_token != address(0));\r\n        require(_preSaleStart < _preSaleEnd && _preSaleEnd < _saleStart && _saleStart < _saleEnd);\r\n        require(_rate > 0);\r\n\r\n        token = MintableToken(_token);\r\n        preSaleStart = _preSaleStart;\r\n        preSaleEnd = _preSaleEnd;\r\n        saleStart = _saleStart;\r\n        saleEnd = _saleEnd;\r\n        rate = _rate;\r\n    }\r\n\r\n    /**\r\n     * @dev Fallback function can be used to buy tokens\r\n     */\r\n    function () public payable {\r\n        if(msg.sender != owner)\r\n            buyTokens();\r\n    }\r\n\r\n    /**\r\n     * @dev Function used to buy tokens\r\n     */\r\n    function buyTokens() public saleIsOn whenNotPaused payable {\r\n        require(msg.sender != address(0));\r\n        require(msg.value >= 20 finney);\r\n\r\n        uint256 weiAmount = msg.value;\r\n        uint256 currentRate = getRate(weiAmount);\r\n\r\n        // calculate token amount to be created\r\n        uint256 newTokens = weiAmount.mul(currentRate).div(10**18);\r\n\r\n        require(issuedTokens.add(newTokens) <= hardCap);\r\n        \r\n        issuedTokens = issuedTokens.add(newTokens);\r\n        received[msg.sender] = received[msg.sender].add(weiAmount);\r\n        token.mint(msg.sender, newTokens);\r\n        TokenPurchase(msg.sender, msg.sender, newTokens);\r\n\r\n        etherWallet.transfer(msg.value);\r\n    }\r\n\r\n    /**\r\n     * @dev Function used to change the exchange rate.\r\n     * @param _rate The new rate.\r\n     */\r\n    function setRate(uint256 _rate) public onlyOwner beforeSale {\r\n        require(_rate > 0);\r\n\r\n        rate = _rate;\r\n    }\r\n\r\n    /**\r\n     * @dev Function used to set wallets and enable the sale.\r\n     * @param _etherWallet Address of ether wallet.\r\n     * @param _teamWallet Address of team wallet.\r\n     * @param _advisorWallet Address of advisors wallet.\r\n     * @param _bountyWallet Address of bounty wallet.\r\n     * @param _fundWallet Address of fund wallet.\r\n     */\r\n    function setWallets(address _etherWallet, address _teamWallet, address _advisorWallet, address _bountyWallet, address _fundWallet) public onlyOwner inState(State.BEFORE_START) {\r\n        require(_etherWallet != address(0));\r\n        require(_teamWallet != address(0));\r\n        require(_advisorWallet != address(0));\r\n        require(_bountyWallet != address(0));\r\n        require(_fundWallet != address(0));\r\n\r\n        etherWallet = _etherWallet;\r\n        teamWallet = _teamWallet;\r\n        advisorWallet = _advisorWallet;\r\n        bountyWallet = _bountyWallet;\r\n        fundWallet = _fundWallet;\r\n\r\n        uint256 releaseTime = saleEnd + lockTime;\r\n\r\n        // Mint locked tokens\r\n        teamTokens = new TokenTimelock(token, teamWallet, releaseTime);\r\n        token.mint(teamTokens, teamCap);\r\n\r\n        // Mint released tokens\r\n        token.mint(advisorWallet, advisorCap);\r\n        token.mint(bountyWallet, bountyCap);\r\n        token.mint(fundWallet, fundCap);\r\n\r\n        currentState = State.SALE;\r\n    }\r\n\r\n    /**\r\n     * @dev Generate tokens to specific address, necessary to accept other cryptos.\r\n     * @param beneficiary Address of the beneficiary.\r\n     * @param newTokens Amount of tokens to be minted.\r\n     */\r\n    function generateTokens(address beneficiary, uint256 newTokens) public onlyOwner {\r\n        require(beneficiary != address(0));\r\n        require(newTokens > 0);\r\n        require(issuedTokens.add(newTokens) <= hardCap);\r\n\r\n        issuedTokens = issuedTokens.add(newTokens);\r\n        token.mint(beneficiary, newTokens);\r\n        TokenPurchase(msg.sender, beneficiary, newTokens);\r\n    }\r\n\r\n    /**\r\n     * @dev Finish crowdsale and token minting.\r\n     */\r\n    function finishCrowdsale() public onlyOwner inState(State.SALE) {\r\n        require(now > saleEnd);\r\n        // tokens not sold to fund\r\n        uint256 unspentTokens = hardCap.sub(issuedTokens);\r\n        token.mint(fundWallet, unspentTokens);\r\n\r\n        currentState = State.CLOSED;\r\n\r\n        token.finishMinting();\r\n    }\r\n\r\n    /**\r\n     * @dev Enable refund after sale.\r\n     */\r\n    function enableRefund() public onlyOwner inState(State.CLOSED) {\r\n        currentState = State.REFUND;\r\n    }\r\n\r\n    /**\r\n     * @dev Check the amount of wei received by beneficiary.\r\n     * @param beneficiary Address of beneficiary.\r\n     */\r\n    function receivedFrom(address beneficiary) public view returns (uint256) {\r\n        return received[beneficiary];\r\n    }\r\n\r\n    /**\r\n     * @dev Function used to claim wei if refund is enabled.\r\n     */\r\n    function claimRefund() public whenNotPaused inState(State.REFUND) {\r\n        require(received[msg.sender] > 0);\r\n\r\n        uint256 amount = received[msg.sender];\r\n        received[msg.sender] = 0;\r\n        msg.sender.transfer(amount);\r\n        Refund(msg.sender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Function used to release token of team wallet.\r\n     */\r\n    function releaseTeamTokens() public {\r\n        teamTokens.release();\r\n    }\r\n\r\n    /**\r\n     * @dev Function used to reclaim ether by owner.\r\n     */\r\n    function reclaimEther() public onlyOwner {\r\n        owner.transfer(this.balance);\r\n    }\r\n\r\n    /**\r\n     * @dev Get exchange rate based on time and amount.\r\n     * @param amount Amount received.\r\n     * @return An uint256 representing the exchange rate.\r\n     */\r\n    function getRate(uint256 amount) internal view returns (uint256) {\r\n        if(now < preSaleEnd) {\r\n            require(amount >= 6797 finney);\r\n\r\n            if(amount <= 8156 finney)\r\n                return rate.mul(105).div(100);\r\n            if(amount <= 9515 finney)\r\n                return rate.mul(1055).div(1000);\r\n            if(amount <= 10874 finney)\r\n                return rate.mul(1065).div(1000);\r\n            if(amount <= 12234 finney)\r\n                return rate.mul(108).div(100);\r\n            if(amount <= 13593 finney)\r\n                return rate.mul(110).div(100);\r\n            if(amount <= 27185 finney)\r\n                return rate.mul(113).div(100);\r\n            if(amount > 27185 finney)\r\n                return rate.mul(120).div(100);\r\n        }\r\n\r\n        return rate;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"etherWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"preSaleStart\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"releaseTeamTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"advisorWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"setRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"receivedFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"preSaleEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_etherWallet\",\"type\":\"address\"},{\"name\":\"_teamWallet\",\"type\":\"address\"},{\"name\":\"_advisorWallet\",\"type\":\"address\"},{\"name\":\"_bountyWallet\",\"type\":\"address\"},{\"name\":\"_fundWallet\",\"type\":\"address\"}],\"name\":\"setWallets\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"newTokens\",\"type\":\"uint256\"}],\"name\":\"generateTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enableRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reclaimEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleStart\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"issuedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bountyWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_preSaleStart\",\"type\":\"uint256\"},{\"name\":\"_preSaleEnd\",\"type\":\"uint256\"},{\"name\":\"_saleStart\",\"type\":\"uint256\"},{\"name\":\"_saleEnd\",\"type\":\"uint256\"},{\"name\":\"_rate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"CraftyCrowdsale","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000006956983f8b3ce173b4ab84361aa0ad52f38d936f000000000000000000000000000000000000000000000000000000005a652981000000000000000000000000000000000000000000000000000000005a78efff000000000000000000000000000000000000000000000000000000005a80d901000000000000000000000000000000000000000000000000000000005aa865ff00000000000000000000000000000000000000000000000000000d61efc5eb6e","Library":"","SwarmSource":"bzzr://8abd80355ac2c56c234759535f574b7c99e152168d4aeb11099b8bd6ca14dc90"}]}