{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n// File: zeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/token/ERC20Basic.sol\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/token/BasicToken.sol\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/InkPublicPresale.sol\r\n\r\ncontract InkPublicPresale is Ownable {\r\n  using SafeMath for uint256;\r\n\r\n  // Flag to indicate whether or not the presale is currently active or is paused.\r\n  // This flag is used both before the presale is finalized as well as after.\r\n  // Pausing the presale before finalize means that no further contributions can\r\n  // be made. Pausing the presale after finalize means that no one can claim\r\n  // XNK tokens.\r\n  bool public active;\r\n\r\n  // Flag to indicate whether or not contributions can be refunded.\r\n  bool private refundable;\r\n\r\n  // The global minimum contribution (in Wei) imposed on all contributors.\r\n  uint256 public globalMin;\r\n  // The global maximum contribution (in Wei) imposed on all contributors.\r\n  // Contributor also have a personal max. When evaluating whether or not they\r\n  // can make a contribution, the lower of the global max and personal max is\r\n  // used.\r\n  uint256 public globalMax;\r\n  // The max amount of Ether (in Wei) that is available for contribution.\r\n  uint256 public etherCap;\r\n  // The running count of Ether (in Wei) that is already contributed.\r\n  uint256 private etherContributed;\r\n  // The running count of XNK that is purchased by contributors.\r\n  uint256 private xnkPurchased;\r\n  // The address of the XNK token contract. When this address is set, the\r\n  // presale is considered finalized and no further contributions can be made.\r\n  address public tokenAddress;\r\n  // Max gas price for contributing transactions.\r\n  uint256 public maxGasPrice;\r\n\r\n  // Contributors storage mapping.\r\n  mapping(address => Contributor) private contributors;\r\n\r\n  struct Contributor {\r\n    bool whitelisted;\r\n    // The individual rate (in XNK).\r\n    uint256 rate;\r\n    // The individual max contribution (in Wei).\r\n    uint256 max;\r\n    // The amount (in Wei) the contributor has contributed.\r\n    uint256 balance;\r\n  }\r\n\r\n  // The presale is considered finalized when the token address is set.\r\n  modifier finalized {\r\n    require(tokenAddress != address(0));\r\n    _;\r\n  }\r\n\r\n  // The presale is considered not finalized when the token address is not set.\r\n  modifier notFinalized {\r\n    require(tokenAddress == address(0));\r\n    _;\r\n  }\r\n\r\n  function InkPublicPresale() public {\r\n    globalMax = 1000000000000000000; // 1.0 Ether\r\n    globalMin = 100000000000000000;  // 0.1 Ether\r\n    maxGasPrice = 40000000000;       // 40 Gwei\r\n  }\r\n\r\n  function updateMaxGasPrice(uint256 _maxGasPrice) public onlyOwner {\r\n    require(_maxGasPrice > 0);\r\n\r\n    maxGasPrice = _maxGasPrice;\r\n  }\r\n\r\n  // Returns the amount of Ether contributed by all contributors.\r\n  function getEtherContributed() public view onlyOwner returns (uint256) {\r\n    return etherContributed;\r\n  }\r\n\r\n  // Returns the amount of XNK purchased by all contributes.\r\n  function getXNKPurchased() public view onlyOwner returns (uint256) {\r\n    return xnkPurchased;\r\n  }\r\n\r\n  // Update the global ether cap. If the new cap is set to something less than\r\n  // or equal to the current contributed ether (etherContributed), then no\r\n  // new contributions can be made.\r\n  function updateEtherCap(uint256 _newEtherCap) public notFinalized onlyOwner {\r\n    etherCap = _newEtherCap;\r\n  }\r\n\r\n  // Update the global max contribution.\r\n  function updateGlobalMax(uint256 _globalMax) public notFinalized onlyOwner {\r\n    require(_globalMax > globalMin);\r\n\r\n    globalMax = _globalMax;\r\n  }\r\n\r\n  // Update the global minimum contribution.\r\n  function updateGlobalMin(uint256 _globalMin) public notFinalized onlyOwner {\r\n    require(_globalMin > 0);\r\n    require(_globalMin < globalMax);\r\n\r\n    globalMin = _globalMin;\r\n  }\r\n\r\n  function updateTokenAddress(address _tokenAddress) public finalized onlyOwner {\r\n    require(_tokenAddress != address(0));\r\n\r\n    tokenAddress = _tokenAddress;\r\n  }\r\n\r\n  // Pause the presale (disables contributions and token claiming).\r\n  function pause() public onlyOwner {\r\n    require(active);\r\n    active = false;\r\n  }\r\n\r\n  // Resume the presale (enables contributions and token claiming).\r\n  function resume() public onlyOwner {\r\n    require(!active);\r\n    active = true;\r\n  }\r\n\r\n  // Allow contributors to call the refund function to get their contributions\r\n  // returned to their whitelisted address.\r\n  function enableRefund() public onlyOwner {\r\n    require(!refundable);\r\n    refundable = true;\r\n  }\r\n\r\n  // Disallow refunds (this is the case by default).\r\n  function disableRefund() public onlyOwner {\r\n    require(refundable);\r\n    refundable = false;\r\n  }\r\n\r\n  // Add a contributor to the whitelist.\r\n  function addContributor(address _account, uint256 _rate, uint256 _max) public onlyOwner notFinalized {\r\n    require(_account != address(0));\r\n    require(_rate > 0);\r\n    require(_max >= globalMin);\r\n    require(!contributors[_account].whitelisted);\r\n\r\n    contributors[_account].whitelisted = true;\r\n    contributors[_account].max = _max;\r\n    contributors[_account].rate = _rate;\r\n  }\r\n\r\n  // Updates a contributor's rate and/or max.\r\n  function updateContributor(address _account, uint256 _newRate, uint256 _newMax) public onlyOwner notFinalized {\r\n    require(_account != address(0));\r\n    require(_newRate > 0);\r\n    require(_newMax >= globalMin);\r\n    require(contributors[_account].whitelisted);\r\n\r\n    // Account for any changes in rate since we are keeping track of total XNK\r\n    // purchased.\r\n    if (contributors[_account].balance > 0 && contributors[_account].rate != _newRate) {\r\n      // Put back the purchased XNK for the old rate.\r\n      xnkPurchased = xnkPurchased.sub(contributors[_account].balance.mul(contributors[_account].rate));\r\n\r\n      // Purchase XNK at the new rate.\r\n      xnkPurchased = xnkPurchased.add(contributors[_account].balance.mul(_newRate));\r\n    }\r\n\r\n    contributors[_account].rate = _newRate;\r\n    contributors[_account].max = _newMax;\r\n  }\r\n\r\n  // Remove the contributor from the whitelist. This also refunds their\r\n  // contribution if they have made any.\r\n  function removeContributor(address _account) public onlyOwner {\r\n    require(_account != address(0));\r\n    require(contributors[_account].whitelisted);\r\n\r\n    // Remove from whitelist.\r\n    contributors[_account].whitelisted = false;\r\n\r\n    // If contributions were made, refund it.\r\n    if (contributors[_account].balance > 0) {\r\n      uint256 balance = contributors[_account].balance;\r\n\r\n      contributors[_account].balance = 0;\r\n      xnkPurchased = xnkPurchased.sub(balance.mul(contributors[_account].rate));\r\n      etherContributed = etherContributed.sub(balance);\r\n\r\n      // XXX: The exclamation point does nothing. We just want to get rid of the\r\n      // compiler warning that we're not using the returned value of the Ether\r\n      // transfer. The transfer *can* fail but we don't want it to stop the\r\n      // removal of the contributor. We will deal if the transfer failure\r\n      // manually outside this contract.\r\n      !_account.call.value(balance)();\r\n    }\r\n\r\n    delete contributors[_account];\r\n  }\r\n\r\n  function withdrawXNK(address _to) public onlyOwner {\r\n    require(_to != address(0));\r\n\r\n    BasicToken token = BasicToken(tokenAddress);\r\n    assert(token.transfer(_to, token.balanceOf(this)));\r\n  }\r\n\r\n  function withdrawEther(address _to) public finalized onlyOwner {\r\n    require(_to != address(0));\r\n\r\n    assert(_to.call.value(this.balance)());\r\n  }\r\n\r\n  // Returns a contributor's balance.\r\n  function balanceOf(address _account) public view returns (uint256) {\r\n    require(_account != address(0));\r\n\r\n    return contributors[_account].balance;\r\n  }\r\n\r\n  // When refunds are enabled, contributors can call this function get their\r\n  // contributed Ether back. The contributor must still be whitelisted.\r\n  function refund() public {\r\n    require(active);\r\n    require(refundable);\r\n    require(contributors[msg.sender].whitelisted);\r\n\r\n    uint256 balance = contributors[msg.sender].balance;\r\n\r\n    require(balance > 0);\r\n\r\n    contributors[msg.sender].balance = 0;\r\n    etherContributed = etherContributed.sub(balance);\r\n    xnkPurchased = xnkPurchased.sub(balance.mul(contributors[msg.sender].rate));\r\n\r\n    assert(msg.sender.call.value(balance)());\r\n  }\r\n\r\n  function airdrop(address _account) public finalized onlyOwner {\r\n    _processPayout(_account);\r\n  }\r\n\r\n  // Finalize the presale by specifying the XNK token's contract address.\r\n  // No further contributions can be made. The presale will be in the\r\n  // \"token claiming\" phase.\r\n  function finalize(address _tokenAddress) public notFinalized onlyOwner {\r\n    require(_tokenAddress != address(0));\r\n\r\n    tokenAddress = _tokenAddress;\r\n  }\r\n\r\n  // Fallback/payable method for contributions and token claiming.\r\n  function () public payable {\r\n    // Allow the owner to send Ether to the contract arbitrarily.\r\n    if (msg.sender == owner && msg.value > 0) {\r\n      return;\r\n    }\r\n\r\n    require(active);\r\n    require(contributors[msg.sender].whitelisted);\r\n\r\n    if (tokenAddress == address(0)) {\r\n      // Presale is still accepting contributions.\r\n      _processContribution();\r\n    } else {\r\n      // Presale has been finalized and the user is attempting to claim\r\n      // XNK tokens.\r\n      _processPayout(msg.sender);\r\n    }\r\n  }\r\n\r\n  // Process the contribution.\r\n  function _processContribution() private {\r\n    // Must be contributing a positive amount.\r\n    require(msg.value > 0);\r\n    // Limit the transaction's gas price.\r\n    require(tx.gasprice <= maxGasPrice);\r\n    // The sum of the contributor's total contributions must be higher than the\r\n    // global minimum.\r\n    require(contributors[msg.sender].balance.add(msg.value) >= globalMin);\r\n    // The global contribution cap must be higher than what has been contributed\r\n    // by everyone. Otherwise, there's zero room for any contribution.\r\n    require(etherCap > etherContributed);\r\n    // Make sure that this specific contribution does not take the total\r\n    // contribution by everyone over the global contribution cap.\r\n    require(msg.value <= etherCap.sub(etherContributed));\r\n\r\n    uint256 newBalance = contributors[msg.sender].balance.add(msg.value);\r\n\r\n    // We limit the individual's contribution based on whichever is lower\r\n    // between their individual max or the global max.\r\n    if (globalMax <= contributors[msg.sender].max) {\r\n      require(newBalance <= globalMax);\r\n    } else {\r\n      require(newBalance <= contributors[msg.sender].max);\r\n    }\r\n\r\n    // Increment the contributor's balance.\r\n    contributors[msg.sender].balance = newBalance;\r\n    // Increment the total amount of Ether contributed by everyone.\r\n    etherContributed = etherContributed.add(msg.value);\r\n    // Increment the total amount of XNK purchased by everyone.\r\n    xnkPurchased = xnkPurchased.add(msg.value.mul(contributors[msg.sender].rate));\r\n  }\r\n\r\n  // Process the token claim.\r\n  function _processPayout(address _recipient) private {\r\n    // The transaction must be 0 Ether.\r\n    require(msg.value == 0);\r\n\r\n    uint256 balance = contributors[_recipient].balance;\r\n\r\n    // The contributor must have contributed something.\r\n    require(balance > 0);\r\n\r\n    // Figure out the amount of XNK the contributor will receive.\r\n    uint256 amount = balance.mul(contributors[_recipient].rate);\r\n\r\n    // Zero out the contributor's balance to denote that they have received\r\n    // their tokens.\r\n    contributors[_recipient].balance = 0;\r\n\r\n    // Transfer XNK to the contributor.\r\n    assert(BasicToken(tokenAddress).transfer(_recipient, amount));\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"disableRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"active\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resume\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"airdrop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"},{\"name\":\"_newRate\",\"type\":\"uint256\"},{\"name\":\"_newMax\",\"type\":\"uint256\"}],\"name\":\"updateContributor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxGasPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxGasPrice\",\"type\":\"uint256\"}],\"name\":\"updateMaxGasPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"updateTokenAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"etherCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEtherContributed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enableRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"globalMax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_globalMin\",\"type\":\"uint256\"}],\"name\":\"updateGlobalMin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"},{\"name\":\"_rate\",\"type\":\"uint256\"},{\"name\":\"_max\",\"type\":\"uint256\"}],\"name\":\"addContributor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newEtherCap\",\"type\":\"uint256\"}],\"name\":\"updateEtherCap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"removeContributor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_globalMax\",\"type\":\"uint256\"}],\"name\":\"updateGlobalMax\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getXNKPurchased\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdrawXNK\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"globalMin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"InkPublicPresale","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://91c860d9c2adf2ab37def462e38121e8990948ae62e9875e7ca9d4ade41da4cc"}]}