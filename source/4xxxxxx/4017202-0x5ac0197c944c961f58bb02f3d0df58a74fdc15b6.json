{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.10;\r\n\r\n/**\r\n * @title Interface to communicate with ICO token contract\r\n */\r\ncontract IToken {\r\n  function balanceOf(address _address) constant returns (uint balance);\r\n  function transferFromOwner(address _to, uint256 _value) returns (bool success);\r\n}\r\n\r\n/**\r\n * @title Presale token contract\r\n */\r\ncontract TokenEscrow {\r\n\t// Token-related properties/description to display in Wallet client / UI\r\n\tstring public standard = 'PBKXToken 0.3';\r\n\tstring public name = 'PBKXToken';\r\n\tstring public symbol = 'PBKX';\r\n\tuint public decimals = 2;\r\n    \tuint public totalSupply = 300000000;\r\n\t\r\n\tIToken icoToken;\r\n\t\r\n\tevent Converted(address indexed from, uint256 value); // Event to inform about the fact of token burning/destroying\r\n    \tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\tevent Error(bytes32 error);\r\n\t\r\n\tmapping (address => uint) balanceFor; // Presale token balance for each of holders\r\n\t\r\n\taddress owner;  // Contract owner\r\n\t\r\n\tuint public exchangeRate; // preICO -> ICO token exchange rate\r\n\r\n\t// Token supply and discount policy structure\r\n\tstruct TokenSupply {\r\n\t\tuint limit;                 // Total amount of tokens\r\n\t\tuint totalSupply;           // Current amount of sold tokens\r\n\t\tuint tokenPriceInWei;  // Number of token per 1 Eth\r\n\t}\r\n\t\r\n\tTokenSupply[3] public tokenSupplies;\r\n\r\n\t// Modifiers\r\n\tmodifier owneronly { if (msg.sender == owner) _; }\r\n\r\n\t/**\r\n\t * @dev Set/change contract owner\r\n\t * @param _owner owner address\r\n\t */\r\n\tfunction setOwner(address _owner) owneronly {\r\n\t\towner = _owner;\r\n\t}\r\n\t\r\n\tfunction setRate(uint _exchangeRate) owneronly {\r\n\t\texchangeRate = _exchangeRate;\r\n\t}\r\n\t\r\n\tfunction setToken(address _icoToken) owneronly {\r\n\t\ticoToken = IToken(_icoToken);\r\n\t}\r\n\t\r\n\t/**\r\n\t * @dev Returns balance/token quanity owned by address\r\n\t * @param _address Account address to get balance for\r\n\t * @return balance value / token quantity\r\n\t */\r\n\tfunction balanceOf(address _address) constant returns (uint balance) {\r\n\t\treturn balanceFor[_address];\r\n\t}\r\n\t\r\n\t/**\r\n\t * @dev Transfers tokens from caller/method invoker/message sender to specified recipient\r\n\t * @param _to Recipient address\r\n\t * @param _value Token quantity to transfer\r\n\t * @return success/failure of transfer\r\n\t */\t\r\n\tfunction transfer(address _to, uint _value) returns (bool success) {\r\n\t\tif(_to != owner) {\r\n\t\t\tif (balanceFor[msg.sender] < _value) return false;           // Check if the sender has enough\r\n\t\t\tif (balanceFor[_to] + _value < balanceFor[_to]) return false; // Check for overflows\r\n\t\t\tif (msg.sender == owner) {\r\n\t\t\t\ttransferByOwner(_value);\r\n\t\t\t}\r\n\t\t\tbalanceFor[msg.sender] -= _value;                     // Subtract from the sender\r\n\t\t\tbalanceFor[_to] += _value;                            // Add the same to the recipient\r\n\t\t\tTransfer(owner,_to,_value);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\t\r\n\tfunction transferByOwner(uint _value) private {\r\n\t\tfor (uint discountIndex = 0; discountIndex < tokenSupplies.length; discountIndex++) {\r\n\t\t\tTokenSupply storage tokenSupply = tokenSupplies[discountIndex];\r\n\t\t\tif(tokenSupply.totalSupply < tokenSupply.limit) {\r\n\t\t\t\tif (tokenSupply.totalSupply + _value > tokenSupply.limit) {\r\n\t\t\t\t\t_value -= tokenSupply.limit - tokenSupply.totalSupply;\r\n\t\t\t\t\ttokenSupply.totalSupply = tokenSupply.limit;\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttokenSupply.totalSupply += _value;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * @dev Burns/destroys specified amount of Presale tokens for caller/method invoker/message sender\r\n\t * @return success/failure of transfer\r\n\t */\t\r\n\tfunction convert() returns (bool success) {\r\n\t\tif (balanceFor[msg.sender] == 0) return false;            // Check if the sender has enough\r\n\t\tif (!exchangeToIco(msg.sender)) return false; // Try to exchange preICO tokens to ICO tokens\r\n\t\tConverted(msg.sender, balanceFor[msg.sender]);\r\n\t\tbalanceFor[msg.sender] = 0;                      // Subtract from the sender\r\n\t\treturn true;\r\n\t} \r\n\t\r\n\t/**\r\n\t * @dev Converts/exchanges sold Presale tokens to ICO ones according to provided exchange rate\r\n\t * @param owner address\r\n\t\t */\r\n\tfunction exchangeToIco(address owner) private returns (bool) {\r\n\t    if(icoToken != address(0)) {\r\n\t\t    return icoToken.transferFromOwner(owner, balanceFor[owner] * exchangeRate);\r\n\t    }\r\n\t    return false;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Presale contract constructor\r\n\t */\r\n\tfunction TokenEscrow() {\r\n\t\towner = msg.sender;\r\n\t\t\r\n\t\tbalanceFor[msg.sender] = 300000000; // Give the creator all initial tokens\r\n\t\t\r\n\t\t// Discount policy\r\n\t\ttokenSupplies[0] = TokenSupply(100000000, 0, 11428571428571); // First million of tokens will go 11210762331838 wei for 1 token\r\n\t\ttokenSupplies[1] = TokenSupply(100000000, 0, 11848341232227); // Second million of tokens will go 12106537530266 wei for 1 token\r\n\t\ttokenSupplies[2] = TokenSupply(100000000, 0, 12500000000000); // Third million of tokens will go 13245033112582 wei for 1 token\r\n\t\r\n\t\t//Balances recovery\r\n\t\ttransferFromOwner(0xa0c6c73e09b18d96927a3427f98ff07aa39539e2,875);\r\n\t\ttransferByOwner(875);\r\n\t\ttransferFromOwner(0xa0c6c73e09b18d96927a3427f98ff07aa39539e2,2150);\r\n\t\ttransferByOwner(2150);\r\n\t\ttransferFromOwner(0xa0c6c73e09b18d96927a3427f98ff07aa39539e2,975);\r\n\t\ttransferByOwner(975);\r\n\t\ttransferFromOwner(0xa0c6c73e09b18d96927a3427f98ff07aa39539e2,875000);\r\n\t\ttransferByOwner(875000);\r\n\t\ttransferFromOwner(0xa4a90f8d12ae235812a4770e0da76f5bc2fdb229,3500000);\r\n\t\ttransferByOwner(3500000);\r\n\t\ttransferFromOwner(0xbd08c225306f6b341ce5a896392e0f428b31799c,43750);\r\n\t\ttransferByOwner(43750);\r\n\t\ttransferFromOwner(0xf948fc5be2d2fd8a7ee20154a18fae145afd6905,3316981);\r\n\t\ttransferByOwner(3316981);\r\n\t\ttransferFromOwner(0x23f15982c111362125319fd4f35ac9e1ed2de9d6,2625);\r\n\t\ttransferByOwner(2625);\r\n\t\ttransferFromOwner(0x23f15982c111362125319fd4f35ac9e1ed2de9d6,5250);\r\n\t\ttransferByOwner(5250);\r\n\t\ttransferFromOwner(0x6ebff66a68655d88733df61b8e35fbcbd670018e,58625);\r\n\t\ttransferByOwner(58625);\r\n\t\ttransferFromOwner(0x1aaa29dffffc8ce0f0eb42031f466dbc3c5155ce,1043875);\r\n\t\ttransferByOwner(1043875);\r\n\t\ttransferFromOwner(0x5d47871df00083000811a4214c38d7609e8b1121,3300000);\r\n\t\ttransferByOwner(3300000);\r\n\t\ttransferFromOwner(0x30ced0c61ccecdd17246840e0d0acb342b9bd2e6,261070);\r\n\t\ttransferByOwner(261070);\r\n\t\ttransferFromOwner(0x1079827daefe609dc7721023f811b7bb86e365a8,2051875);\r\n\t\ttransferByOwner(2051875);\r\n\t\ttransferFromOwner(0x6c0b6a5ac81e07f89238da658a9f0e61be6a0076,10500000);\r\n\t\ttransferByOwner(10500000);\r\n\t\ttransferFromOwner(0xd16e29637a29d20d9e21b146fcfc40aca47656e5,1750);\r\n\t\ttransferByOwner(1750);\r\n\t\ttransferFromOwner(0x4c9ba33dcbb5876e1a83d60114f42c949da4ee22,7787500);\r\n\t\ttransferByOwner(7787500);\r\n\t\ttransferFromOwner(0x0d8cc80efe5b136865b9788393d828fd7ffb5887,100000000);\r\n\t\ttransferByOwner(100000000);\r\n\t\r\n\t}\r\n  \r\n\t// Incoming transfer from the Presale token buyer\r\n\tfunction() payable {\r\n\t\t\r\n\t\tuint tokenAmount; // Amount of tokens which is possible to buy for incoming transfer/payment\r\n\t\tuint amountToBePaid; // Amount to be paid\r\n\t\tuint amountTransfered = msg.value; // Cost/price in WEI of incoming transfer/payment\r\n\t\t\r\n\t\tif (amountTransfered <= 0) {\r\n\t\t      \tError('no eth was transfered');\r\n              \t\tmsg.sender.transfer(msg.value);\r\n\t\t  \treturn;\r\n\t\t}\r\n\r\n\t\tif(balanceFor[owner] <= 0) {\r\n\t\t      \tError('all tokens sold');\r\n              \t\tmsg.sender.transfer(msg.value);\r\n\t\t      \treturn;\r\n\t\t}\r\n\t\t\r\n\t\t// Determine amount of tokens can be bought according to available supply and discount policy\r\n\t\tfor (uint discountIndex = 0; discountIndex < tokenSupplies.length; discountIndex++) {\r\n\t\t\t// If it's not possible to buy any tokens at all skip the rest of discount policy\r\n\t\t\t\r\n\t\t\tTokenSupply storage tokenSupply = tokenSupplies[discountIndex];\r\n\t\t\t\r\n\t\t\tif(tokenSupply.totalSupply < tokenSupply.limit) {\r\n\t\t\t\r\n\t\t\t\tuint tokensPossibleToBuy = amountTransfered / tokenSupply.tokenPriceInWei;\r\n\r\n                if (tokensPossibleToBuy > balanceFor[owner]) \r\n                    tokensPossibleToBuy = balanceFor[owner];\r\n\r\n\t\t\t\tif (tokenSupply.totalSupply + tokensPossibleToBuy > tokenSupply.limit) {\r\n\t\t\t\t\ttokensPossibleToBuy = tokenSupply.limit - tokenSupply.totalSupply;\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttokenSupply.totalSupply += tokensPossibleToBuy;\r\n\t\t\t\ttokenAmount += tokensPossibleToBuy;\r\n\r\n\t\t\t\tuint delta = tokensPossibleToBuy * tokenSupply.tokenPriceInWei;\r\n\r\n\t\t\t\tamountToBePaid += delta;\r\n                \t\tamountTransfered -= delta;\r\n\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// Do not waste gas if there is no tokens to buy\r\n\t\tif (tokenAmount == 0) {\r\n\t\t    \tError('no token to buy');\r\n            \t\tmsg.sender.transfer(msg.value);\r\n\t\t\treturn;\r\n        \t}\r\n\t\t\r\n\t\t// Transfer tokens to buyer\r\n\t\ttransferFromOwner(msg.sender, tokenAmount);\r\n\r\n\t\t// Transfer money to seller\r\n\t\towner.transfer(amountToBePaid);\r\n\t\t\r\n\t\t// Refund buyer if overpaid / no tokens to sell\r\n\t\tmsg.sender.transfer(msg.value - amountToBePaid);\r\n\t}\r\n  \r\n\t/**\r\n\t * @dev Removes/deletes contract\r\n\t */\r\n\tfunction kill() owneronly {\r\n\t\tsuicide(msg.sender);\r\n\t}\r\n  \r\n\t/**\r\n\t * @dev Transfers tokens from owner to specified recipient\r\n\t * @param _to Recipient address\r\n\t * @param _value Token quantity to transfer\r\n\t * @return success/failure of transfer\r\n\t */\r\n\tfunction transferFromOwner(address _to, uint256 _value) private returns (bool success) {\r\n\t\tif (balanceFor[owner] < _value) return false;                 // Check if the owner has enough\r\n\t\tif (balanceFor[_to] + _value < balanceFor[_to]) return false;  // Check for overflows\r\n\t\tbalanceFor[owner] -= _value;                          // Subtract from the owner\r\n\t\tbalanceFor[_to] += _value;                            // Add the same to the recipient\r\n        \tTransfer(owner,_to,_value);\r\n\t\treturn true;\r\n\t}\r\n  \r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_icoToken\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_exchangeRate\",\"type\":\"uint256\"}],\"name\":\"setRate\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"standard\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"convert\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenSupplies\",\"outputs\":[{\"name\":\"limit\",\"type\":\"uint256\"},{\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"name\":\"tokenPriceInWei\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Converted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"error\",\"type\":\"bytes32\"}],\"name\":\"Error\",\"type\":\"event\"}]","ContractName":"TokenEscrow","CompilerVersion":"v0.4.10+commit.f0d539ae","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://2a1bdc9b10a089c9a1a8785dc5d62a9c246574f5f12b0b9429e1b14645865e7d"}]}