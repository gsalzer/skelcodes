{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.15;\r\n\r\n/// @title Ownable\r\n/// @dev The Ownable contract has an owner address, and provides basic authorization control\r\n/// functions, this simplifies the implementation of \"user permissions\".\r\ncontract Ownable {\r\n\r\n  // EVENTS\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  // PUBLIC FUNCTIONS\r\n\r\n  /// @dev The Ownable constructor sets the original `owner` of the contract to the sender account.\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /// @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n  /// @param newOwner The address to transfer ownership to.\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n  // MODIFIERS\r\n\r\n  /// @dev Throws if called by any account other than the owner.\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  // FIELDS\r\n\r\n  address public owner;\r\n}\r\n\r\n\r\ncontract DaoOwnable is Ownable{\r\n\r\n    address public dao = address(0);\r\n\r\n    event DaoOwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the dao.\r\n     */\r\n    modifier onlyDao() {\r\n        require(msg.sender == dao);\r\n        _;\r\n    }\r\n\r\n    modifier onlyDaoOrOwner() {\r\n        require(msg.sender == dao || msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newDao.\r\n     * @param newDao The address to transfer ownership to.\r\n     */\r\n    function transferDao(address newDao) onlyOwner {\r\n        require(newDao != address(0));\r\n        dao = newDao;\r\n        DaoOwnershipTransferred(owner, newDao);\r\n    }\r\n\r\n}\r\n\r\ncontract PublisherRegistry {\r\n    // This is the function that actually insert a record.\r\n    function register(address key, bytes32[5] url, address recordOwner);\r\n\r\n    // Updates the values of the given record.\r\n    function updateUrl(address key, bytes32[5] url, address sender);\r\n\r\n    function applyKarmaDiff(address key, uint256[2] diff);\r\n\r\n    // Unregister a given record\r\n    function unregister(address key, address sender);\r\n\r\n    //Transfer ownership of record\r\n    function transfer(address key, address newOwner, address sender);\r\n\r\n    function getOwner(address key) constant returns(address);\r\n\r\n    // Tells whether a given key is registered.\r\n    function isRegistered(address key) constant returns(bool);\r\n\r\n    function getPublisher(address key) constant returns(address publisherAddress, bytes32[5] url, uint256[2] karma, address recordOwner);\r\n\r\n    //@dev Get list of all registered publishers\r\n    //@return Returns array of addresses registered as DSP with register times\r\n    function getAllPublishers() constant returns(address[] addresses, bytes32[5][] urls, uint256[2][] karmas, address[] recordOwners);\r\n\r\n    function kill();\r\n}\r\n\r\ncontract PublisherRegistryImpl is PublisherRegistry, DaoOwnable{\r\n    // This struct keeps all data for a publisher.\r\n    struct Publisher {\r\n        // Keeps the address of this record creator.\r\n        address owner;\r\n        // Keeps the time when this record was created.\r\n        uint time;\r\n        // Keeps the index of the keys array for fast lookup\r\n        uint keysIndex;\r\n        // publisher Address\r\n        address publisherAddress;\r\n\r\n        bytes32[5] url;\r\n\r\n        uint256[2] karma;\r\n    }\r\n\r\n    // This mapping keeps the records of this Registry.\r\n    mapping(address => Publisher) records;\r\n\r\n    // Keeps the total numbers of records in this Registry.\r\n    uint public numRecords;\r\n\r\n    // Keeps a list of all keys to interate the records.\r\n    address[] public keys;\r\n\r\n    // This is the function that actually insert a record.\r\n    function register(address key, bytes32[5] url, address recordOwner) onlyDaoOrOwner {\r\n        require(records[key].time == 0);\r\n        records[key].time = now;\r\n        records[key].owner = recordOwner;\r\n        records[key].keysIndex = keys.length;\r\n        records[key].publisherAddress = key;\r\n        records[key].url = url;\r\n        keys.length++;\r\n        keys[keys.length - 1] = key;\r\n        numRecords++;\r\n    }\r\n\r\n    // Updates the values of the given record.\r\n    function updateUrl(address key, bytes32[5] url, address sender) onlyDaoOrOwner {\r\n        // Only the owner can update his record.\r\n        require(records[key].owner == sender);\r\n        records[key].url = url;\r\n    }\r\n\r\n\r\n    function applyKarmaDiff(address key, uint256[2] diff) onlyDaoOrOwner {\r\n        Publisher storage publisher = records[key];\r\n        publisher.karma[0] += diff[0];\r\n        publisher.karma[1] += diff[1];\r\n    }\r\n\r\n    // Unregister a given record\r\n    function unregister(address key, address sender) onlyDaoOrOwner {\r\n        require(records[key].owner == sender);\r\n        uint keysIndex = records[key].keysIndex;\r\n        delete records[key];\r\n        numRecords--;\r\n        keys[keysIndex] = keys[keys.length - 1];\r\n        records[keys[keysIndex]].keysIndex = keysIndex;\r\n        keys.length--;\r\n    }\r\n\r\n    // Transfer ownership of a given record.\r\n    function transfer(address key, address newOwner, address sender) onlyDaoOrOwner {\r\n        require(records[key].owner == sender);\r\n        records[key].owner = newOwner;\r\n    }\r\n\r\n    // Tells whether a given key is registered.\r\n    function isRegistered(address key) constant returns(bool) {\r\n        return records[key].time != 0;\r\n    }\r\n\r\n    function getPublisher(address key) constant returns(address publisherAddress, bytes32[5] url, uint256[2] karma, address recordOwner) {\r\n        Publisher storage record = records[key];\r\n        publisherAddress = record.publisherAddress;\r\n        url = record.url;\r\n        karma = record.karma;\r\n        recordOwner = record.owner;\r\n    }\r\n\r\n    // Returns the owner of the given record. The owner could also be get\r\n    // by using the function getDSP but in that case all record attributes\r\n    // are returned.\r\n    function getOwner(address key) constant returns(address) {\r\n        return records[key].owner;\r\n    }\r\n\r\n    // Returns the registration time of the given record. The time could also\r\n    // be get by using the function getDSP but in that case all record attributes\r\n    // are returned.\r\n    function getTime(address key) constant returns(uint) {\r\n        return records[key].time;\r\n    }\r\n\r\n    //@dev Get list of all registered publishers\r\n    //@return Returns array of addresses registered as DSP with register times\r\n    function getAllPublishers() constant returns(address[] addresses, bytes32[5][] urls, uint256[2][] karmas, address[] recordOwners) {\r\n        addresses = new address[](numRecords);\r\n        urls = new bytes32[5][](numRecords);\r\n        karmas = new uint256[2][](numRecords);\r\n        recordOwners = new address[](numRecords);\r\n        uint i;\r\n        for(i = 0; i < numRecords; i++) {\r\n            Publisher storage publisher = records[keys[i]];\r\n            addresses[i] = publisher.publisherAddress;\r\n            urls[i] = publisher.url;\r\n            karmas[i] = publisher.karma;\r\n            recordOwners[i] = publisher.owner;\r\n        }\r\n    }\r\n\r\n    function kill() onlyOwner {\r\n        selfdestruct(owner);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"keys\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"key\",\"type\":\"address\"},{\"name\":\"url\",\"type\":\"bytes32[5]\"},{\"name\":\"recordOwner\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dao\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"key\",\"type\":\"address\"},{\"name\":\"url\",\"type\":\"bytes32[5]\"},{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"updateUrl\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"key\",\"type\":\"address\"},{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"unregister\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"key\",\"type\":\"address\"}],\"name\":\"getTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllPublishers\",\"outputs\":[{\"name\":\"addresses\",\"type\":\"address[]\"},{\"name\":\"urls\",\"type\":\"bytes32[5][]\"},{\"name\":\"karmas\",\"type\":\"uint256[2][]\"},{\"name\":\"recordOwners\",\"type\":\"address[]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"key\",\"type\":\"address\"},{\"name\":\"newOwner\",\"type\":\"address\"},{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"key\",\"type\":\"address\"}],\"name\":\"getPublisher\",\"outputs\":[{\"name\":\"publisherAddress\",\"type\":\"address\"},{\"name\":\"url\",\"type\":\"bytes32[5]\"},{\"name\":\"karma\",\"type\":\"uint256[2]\"},{\"name\":\"recordOwner\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numRecords\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"key\",\"type\":\"address\"}],\"name\":\"isRegistered\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"key\",\"type\":\"address\"},{\"name\":\"diff\",\"type\":\"uint256[2]\"}],\"name\":\"applyKarmaDiff\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newDao\",\"type\":\"address\"}],\"name\":\"transferDao\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"key\",\"type\":\"address\"}],\"name\":\"getOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"DaoOwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"PublisherRegistryImpl","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://6b5188ce66d1c6b1c858b85b9688bdf39410983850b32dba8b1b24c3afbf5bd5"}]}