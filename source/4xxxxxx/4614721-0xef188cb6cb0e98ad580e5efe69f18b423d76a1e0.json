{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.15;\r\n\r\n    /****************************************************************\r\n     *\r\n     * Name of the project: Genevieve VC Token Swapper\r\n     * Contract name: Swap\r\n     * Author: Juan Livingston @ Ethernity.live\r\n     * Developed for: Genevieve Co.\r\n     * GXVC is an ERC223 Token Swapper\r\n     *\r\n     * This swapper has 2 main functions: \r\n     * - makeSwapInternal will send new tokens when ether are received\r\n     * - makeSwap will send new tokens when old tokens are received\r\n     *  \r\n     * makeSwap is called by a javascript through an authorized address\r\n     *\r\n     ****************************************************************/\r\n\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) constant returns (uint256);\r\n  function transfer(address to, uint256 value) returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) returns (bool);\r\n  function approve(address spender, uint256 value) returns (bool);\r\n  function burn(address spender, uint256 value) returns (bool); // Optional \r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract ERC223 {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) constant returns (uint);\r\n  \r\n  function name() constant returns (string _name);\r\n  function symbol() constant returns (string _symbol);\r\n  function decimals() constant returns (uint8 _decimals);\r\n  function totalSupply() constant returns (uint256 _supply);\r\n\r\n  function transfer(address to, uint value) returns (bool ok);\r\n  function transfer(address to, uint value, bytes data) returns (bool ok);\r\n  function transfer(address to, uint value, bytes data, string custom_fallback) returns (bool ok);\r\n  function transferFrom(address from, address to, uint256 value) returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);\r\n}\r\n\r\n\r\ncontract Swap {\r\n\r\n    address authorizedCaller;\r\n    address collectorAddress;\r\n    address collectorTokens;\r\n\r\n    address oldTokenAdd;\r\n    address newTokenAdd; \r\n    address tokenSpender;\r\n\r\n    uint Etherrate;\r\n    uint Tokenrate;\r\n\r\n    bool pausedSwap;\r\n\r\n    uint public lastBlock;\r\n\r\n    // Constructor function with main constants and variables \r\n \r\n \tfunction Swap() {\r\n\t    authorizedCaller = msg.sender;\r\n\r\n\t    oldTokenAdd = 0x58ca3065C0F24C7c96Aee8d6056b5B5deCf9c2f8;\r\n\t    newTokenAdd = 0x22f0af8d78851b72ee799e05f54a77001586b18a; \r\n\r\n\t    Etherrate = 3000;\r\n\t    Tokenrate = 10;\r\n\r\n\t    authorized[authorizedCaller] = 1;\r\n\r\n\t    lastBlock = 0;\r\n\t}\r\n\r\n\r\n\t// Mapping to store swaps made and authorized callers\r\n\r\n    mapping(bytes32 => uint) internal payments;\r\n    mapping(address => uint8) internal authorized;\r\n\r\n    // Event definitions\r\n\r\n    event EtherReceived(uint _n , address _address , uint _value);\r\n    event GXVCSentByEther(uint _n , address _address , uint _value);\r\n\r\n    event GXVCReplay(uint _n , address _address);\r\n    event GXVCNoToken(uint _n , address _address);\r\n\r\n    event TokensReceived(uint _n , address _address , uint _value);\r\n    event GXVCSentByToken(uint _n , address _address , uint _value );\r\n\r\n    event SwapPaused(uint _n);\r\n    event SwapResumed(uint _n);\r\n\r\n    event EtherrateUpd(uint _n , uint _rate);\r\n    event TokenrateUpd(uint _n , uint _rate);\r\n\r\n    // Modifier for authorized calls\r\n\r\n    modifier isAuthorized() {\r\n        if ( authorized[msg.sender] != 1 ) revert();\r\n        _;\r\n    }\r\n\r\n    modifier isNotPaused() {\r\n    \tif (pausedSwap) revert();\r\n    \t_;\r\n    }\r\n\r\n    // Function borrowed from ds-math.\r\n\r\n    function mul(uint x, uint y) internal returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    // Falback function, invoked each time ethers are received\r\n\r\n    function () payable { \r\n        makeSwapInternal ();\r\n    }\r\n\r\n\r\n    // Ether swap, activated by the fallback function after receiving ethers\r\n\r\n   function makeSwapInternal () private isNotPaused { // Main function, called internally when ethers are received\r\n\r\n     ERC223 newTok = ERC223 ( newTokenAdd );\r\n\r\n     address _address = msg.sender;\r\n     uint _value = msg.value;\r\n\r\n     // Calculate the amount to send based on the rates supplied\r\n\r\n     uint etherstosend = mul( _value , Etherrate ) / 100000000; // Division to equipare 18 decimals to 10\r\n\r\n     // ---------------------------------------- Ether exchange --------------------------------------------\r\n\r\n    if ( etherstosend > 0 ) {   \r\n\r\n        // Log Ether received\r\n        EtherReceived ( 1, _address , _value);\r\n\r\n        //Send new tokens\r\n        require( newTok.transferFrom( tokenSpender , _address , etherstosend ) );\r\n\t\t// Log tokens sent for ethers;\r\n        GXVCSentByEther ( 2, _address , etherstosend) ;\r\n        // Send ethers to collector\r\n        require( collectorAddress.send( _value ) );\r\n        }\r\n\r\n    }\r\n\r\n    // This function is called from a javascript through an authorized address to inform of a transfer \r\n    // of old token.\r\n    // Parameters are trusted, but they may be accidentally replayed (specially if a rescan is made) \r\n    // so we store them in a mapping to avoid reprocessing\r\n    // We store the tx_hash, to allow many different swappings per address\r\n\r\n    function makeSwap (address _address , uint _value , bytes32 _hash) public isAuthorized isNotPaused {\r\n\r\n    ERC223 newTok = ERC223 ( newTokenAdd );\r\n\r\n\t// Calculate the amount to send based on the rates supplied\r\n\r\n    uint gpxtosend = mul( _value , Tokenrate ); \r\n\r\n     // ----------------------------------- No tokens or already used -------------------------------------\r\n\r\n    if ( payments[_hash] > 0 ) { // Check for accidental replay\r\n        GXVCReplay( 3, _address ); // Log \"Done before\";\r\n        return;\r\n     }\r\n\r\n     if ( gpxtosend == 0 ) {\r\n        GXVCNoToken( 4, _address ); // Log \"No GXC tokens found\";\r\n        return;\r\n     }\r\n      // ---------------------------------------- GPX exchange --------------------------------------------\r\n              \r\n     TokensReceived( 5, _address , _value ); // Log balance detected\r\n\r\n     payments[_hash] = gpxtosend; // To avoid future accidental replays\r\n\r\n      // Transfer new tokens to caller\r\n     require( newTok.transferFrom( tokenSpender , _address , gpxtosend ) );\r\n\r\n     GXVCSentByToken( 6, _address , gpxtosend ); // Log \"New token sent\";\r\n\r\n     lastBlock = block.number + 1;\r\n\r\n    }\r\n\r\nfunction pauseSwap () public isAuthorized {\r\n\tpausedSwap = true;\r\n\tSwapPaused(7);\r\n}\r\n\r\nfunction resumeSwap () public isAuthorized {\r\n\tpausedSwap = false;\r\n\tSwapResumed(8);\r\n}\r\n\r\nfunction updateOldToken (address _address) public isAuthorized {\r\n    oldTokenAdd = _address;\r\n}\r\n\r\nfunction updateNewToken (address _address , address _spender) public isAuthorized {\r\n    newTokenAdd = _address;\r\n    tokenSpender = _spender;   \r\n}\r\n\r\n\r\nfunction updateEthRate (uint _rate) public isAuthorized {\r\n    Etherrate = _rate;\r\n    EtherrateUpd(9,_rate);\r\n}\r\n\r\n\r\nfunction updateTokenRate (uint _rate) public isAuthorized {\r\n    Tokenrate = _rate;\r\n    TokenrateUpd(10,_rate);\r\n}\r\n\r\n\r\nfunction flushEthers () public isAuthorized { // Send ether to collector\r\n    require( collectorAddress.send( this.balance ) );\r\n}\r\n\r\nfunction flushTokens () public isAuthorized {\r\n\tERC20 oldTok = ERC20 ( oldTokenAdd );\r\n\trequire( oldTok.transfer(collectorTokens , oldTok.balanceOf(this) ) );\r\n}\r\n\r\nfunction addAuthorized(address _address) public isAuthorized {\r\n\tauthorized[_address] = 1;\r\n\r\n}\r\n\r\nfunction removeAuthorized(address _address) public isAuthorized {\r\n\tauthorized[_address] = 0;\r\n\r\n}\r\n\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"flushEthers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_hash\",\"type\":\"bytes32\"}],\"name\":\"makeSwap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"updateOldToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"updateEthRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"removeAuthorized\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"flushTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"updateTokenRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"addAuthorized\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pauseSwap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resumeSwap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"updateNewToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_n\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"EtherReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_n\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"GXVCSentByEther\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_n\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"GXVCReplay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_n\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"GXVCNoToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_n\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"TokensReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_n\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"GXVCSentByToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_n\",\"type\":\"uint256\"}],\"name\":\"SwapPaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_n\",\"type\":\"uint256\"}],\"name\":\"SwapResumed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_n\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"EtherrateUpd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_n\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"TokenrateUpd\",\"type\":\"event\"}]","ContractName":"Swap","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://55813d760ab120b30c10af48f7b8923a4444f5bf5c64a9d0b1e3b8749cba7073"}]}