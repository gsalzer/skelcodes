{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.17;\r\n\r\n// ----------------------------------------------------------------------------\r\n//\r\n// GZR 'Gizer Gaming' token presale contract\r\n//\r\n// For details, please visit: http://www.gizer.io\r\n//\r\n// ----------------------------------------------------------------------------\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n//\r\n// SafeM (div not needed but kept for completeness' sake)\r\n//\r\n// ----------------------------------------------------------------------------\r\n\r\nlibrary SafeM {\r\n\r\n  function add(uint a, uint b) public pure returns (uint c) {\r\n    c = a + b;\r\n    require( c >= a );\r\n  }\r\n\r\n  function sub(uint a, uint b) public pure returns (uint c) {\r\n    require( b <= a );\r\n    c = a - b;\r\n  }\r\n\r\n  function mul(uint a, uint b) public pure returns (uint c) {\r\n    c = a * b;\r\n    require( a == 0 || c / a == b );\r\n  }\r\n\r\n  function div(uint a, uint b) public pure returns (uint c) {\r\n    c = a / b;\r\n  }  \r\n\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n//\r\n// Owned contract\r\n//\r\n// ----------------------------------------------------------------------------\r\n\r\ncontract Owned {\r\n\r\n  address public owner;\r\n  address public newOwner;\r\n\r\n  // Events ---------------------------\r\n\r\n  event OwnershipTransferProposed(address indexed _from, address indexed _to);\r\n  event OwnershipTransferred(address indexed _to);\r\n\r\n  // Modifier -------------------------\r\n\r\n  modifier onlyOwner {\r\n    require( msg.sender == owner );\r\n    _;\r\n  }\r\n\r\n  // Functions ------------------------\r\n\r\n  function Owned() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    require( _newOwner != owner );\r\n    require( _newOwner != address(0x0) );\r\n    newOwner = _newOwner;\r\n    OwnershipTransferProposed(owner, _newOwner);\r\n  }\r\n\r\n  function acceptOwnership() public {\r\n    require( msg.sender == newOwner );\r\n    owner = newOwner;\r\n    OwnershipTransferred(owner);\r\n  }\r\n\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n//\r\n// ERC Token Standard #20 Interface\r\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n//\r\n// ----------------------------------------------------------------------------\r\n\r\ncontract ERC20Interface {\r\n\r\n  // Events ---------------------------\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint _value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n\r\n  // Functions ------------------------\r\n\r\n  function totalSupply() public view returns (uint);\r\n  function balanceOf(address _owner) public view returns (uint balance);\r\n  function transfer(address _to, uint _value) public returns (bool success);\r\n  function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n  function approve(address _spender, uint _value) public returns (bool success);\r\n  function allowance(address _owner, address _spender) public view returns (uint remaining);\r\n\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n//\r\n// ERC Token Standard #20\r\n//\r\n// ----------------------------------------------------------------------------\r\n\r\ncontract ERC20Token is ERC20Interface, Owned {\r\n  \r\n  using SafeM for uint;\r\n\r\n  uint public tokensIssuedTotal = 0;\r\n  mapping(address => uint) balances;\r\n  mapping(address => mapping (address => uint)) allowed;\r\n\r\n  // Functions ------------------------\r\n\r\n  /* Total token supply */\r\n\r\n  function totalSupply() public view returns (uint) {\r\n    return tokensIssuedTotal;\r\n  }\r\n\r\n  /* Get the account balance for an address */\r\n\r\n  function balanceOf(address _owner) public view returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  /* Transfer the balance from owner's account to another account */\r\n\r\n  function transfer(address _to, uint _amount) public returns (bool success) {\r\n    // amount sent cannot exceed balance\r\n    require( balances[msg.sender] >= _amount );\r\n\r\n    // update balances\r\n    balances[msg.sender] = balances[msg.sender].sub(_amount);\r\n    balances[_to]        = balances[_to].add(_amount);\r\n\r\n    // log event\r\n    Transfer(msg.sender, _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  /* Allow _spender to withdraw from your account up to _amount */\r\n\r\n  function approve(address _spender, uint _amount) public returns (bool success) {\r\n    // approval amount cannot exceed the balance\r\n    require( balances[msg.sender] >= _amount );\r\n      \r\n    // update allowed amount\r\n    allowed[msg.sender][_spender] = _amount;\r\n    \r\n    // log event\r\n    Approval(msg.sender, _spender, _amount);\r\n    return true;\r\n  }\r\n\r\n  /* Spender of tokens transfers tokens from the owner's balance */\r\n  /* Must be pre-approved by owner */\r\n\r\n  function transferFrom(address _from, address _to, uint _amount) public returns (bool success) {\r\n    // balance checks\r\n    require( balances[_from] >= _amount );\r\n    require( allowed[_from][msg.sender] >= _amount );\r\n\r\n    // update balances and allowed amount\r\n    balances[_from]            = balances[_from].sub(_amount);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\r\n    balances[_to]              = balances[_to].add(_amount);\r\n\r\n    // log event\r\n    Transfer(_from, _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  /* Returns the amount of tokens approved by the owner */\r\n  /* that can be transferred by spender */\r\n\r\n  function allowance(address _owner, address _spender) public view returns (uint remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n//\r\n// GZR token presale\r\n//\r\n// ----------------------------------------------------------------------------\r\n\r\ncontract GizerTokenPresale is ERC20Token {\r\n\r\n  /* Utility variables */\r\n  \r\n  uint constant E6  = 10**6;\r\n\r\n  /* Basic token data */\r\n\r\n  string public constant name     = \"Gizer Gaming Presale Token\";\r\n  string public constant symbol   = \"GZRPRE\";\r\n  uint8  public constant decimals = 6;\r\n\r\n  /* Wallets */\r\n  \r\n  address public wallet;\r\n  address public redemptionWallet;\r\n\r\n  /* General crowdsale parameters */  \r\n  \r\n  uint public constant MIN_CONTRIBUTION = 1 ether / 10; // 0.1 Ether\r\n  uint public constant MAX_CONTRIBUTION = 100 ether;\r\n  \r\n  /* Private sale */\r\n\r\n  uint public constant PRIVATE_SALE_MAX_ETHER = 2300 ether;\r\n  \r\n  /* Presale parameters */\r\n  \r\n  uint public constant DATE_PRESALE_START = 1512050400; // 30-Nov-2017 14:00 UTC\r\n  uint public constant DATE_PRESALE_END   = 1513260000; // 14-Dec-2017 14:00 UTC\r\n  \r\n  uint public constant TOKETH_PRESALE_ONE   = 1150 * E6; // presale wave 1 (  1-100)\r\n  uint public constant TOKETH_PRESALE_TWO   = 1100 * E6; // presale wave 2 (101-500)\r\n  uint public constant TOKETH_PRESALE_THREE = 1075 * E6; // presale - others\r\n  \r\n  uint public constant CUTOFF_PRESALE_ONE = 100; // last contributor wave 1\r\n  uint public constant CUTOFF_PRESALE_TWO = 500; // last contributor wave 2\r\n\r\n  uint public constant FUNDING_PRESALE_MAX = 2300 ether;\r\n\r\n  /* Presale variables */\r\n\r\n  uint public etherReceivedPrivate = 0; // private sale Ether\r\n  uint public etherReceivedCrowd   = 0; // crowdsale Ether\r\n\r\n  uint public tokensIssuedPrivate = 0; // private sale tokens\r\n  uint public tokensIssuedCrowd   = 0; // crowdsale tokens\r\n  uint public tokensBurnedTotal   = 0; // tokens burned by owner\r\n  \r\n  uint public presaleContributorCount = 0;\r\n  \r\n  bool public tokensFrozen = false;\r\n\r\n  /* Mappings */\r\n\r\n  mapping(address => uint) public balanceEthPrivate; // private sale Ether\r\n  mapping(address => uint) public balanceEthCrowd;   // crowdsale Ether\r\n\r\n  mapping(address => uint) public balancesPrivate; // private sale tokens\r\n  mapping(address => uint) public balancesCrowd;   // crowdsale tokens\r\n\r\n  // Events ---------------------------\r\n  \r\n  event WalletUpdated(address _newWallet);\r\n  event RedemptionWalletUpdated(address _newRedemptionWallet);\r\n  event TokensIssued(address indexed _owner, uint _tokens, uint _balance, uint _tokensIssuedCrowd, bool indexed _isPrivateSale, uint _amount);\r\n  event OwnerTokensBurned(uint _tokensBurned, uint _tokensBurnedTotal);\r\n  \r\n  // Basic Functions ------------------\r\n\r\n  /* Initialize */\r\n\r\n  function GizerTokenPresale() public {\r\n    wallet = owner;\r\n    redemptionWallet = owner;\r\n  }\r\n\r\n  /* Fallback */\r\n  \r\n  function () public payable {\r\n    buyTokens();\r\n  }\r\n\r\n  // Information Functions ------------\r\n  \r\n  /* What time is it? */\r\n  \r\n  function atNow() public view returns (uint) {\r\n    return now;\r\n  }\r\n\r\n  // Owner Functions ------------------\r\n  \r\n  /* Change the crowdsale wallet address */\r\n\r\n  function setWallet(address _wallet) public onlyOwner {\r\n    require( _wallet != address(0x0) );\r\n    wallet = _wallet;\r\n    WalletUpdated(_wallet);\r\n  }\r\n\r\n  /* Change the redemption wallet address */\r\n\r\n  function setRedemptionWallet(address _wallet) public onlyOwner {\r\n    redemptionWallet = _wallet;\r\n    RedemptionWalletUpdated(_wallet);\r\n  }\r\n  \r\n  /* Issue tokens for ETH received during private sale */\r\n\r\n  function privateSaleContribution(address _account, uint _amount) public onlyOwner {\r\n    // checks\r\n    require( _account != address(0x0) );\r\n    require( atNow() < DATE_PRESALE_END );\r\n    require( _amount >= MIN_CONTRIBUTION );\r\n    require( etherReceivedPrivate.add(_amount) <= PRIVATE_SALE_MAX_ETHER );\r\n    \r\n    // same conditions as early presale participants\r\n    uint tokens = TOKETH_PRESALE_ONE.mul(_amount) / 1 ether;\r\n    \r\n    // issue tokens\r\n    issueTokens(_account, tokens, _amount, true); // true => private sale\r\n  }\r\n\r\n  /* Freeze tokens */\r\n  \r\n  function freezeTokens() public onlyOwner {\r\n    require( atNow() > DATE_PRESALE_END );\r\n    tokensFrozen = true;\r\n  }\r\n  \r\n  /* Burn tokens held by owner */\r\n  \r\n  function burnOwnerTokens() public onlyOwner {\r\n    // check if there is anything to burn\r\n    require( balances[owner] > 0 );\r\n    \r\n    // update \r\n    uint tokensBurned = balances[owner];\r\n    balances[owner] = 0;\r\n    tokensIssuedTotal = tokensIssuedTotal.sub(tokensBurned);\r\n    tokensBurnedTotal = tokensBurnedTotal.add(tokensBurned);\r\n    \r\n    // log\r\n    Transfer(owner, 0x0, tokensBurned);\r\n    OwnerTokensBurned(tokensBurned, tokensBurnedTotal);\r\n\r\n  }  \r\n\r\n  /* Transfer out any accidentally sent ERC20 tokens */\r\n\r\n  function transferAnyERC20Token(address tokenAddress, uint amount) public onlyOwner returns (bool success) {\r\n      return ERC20Interface(tokenAddress).transfer(owner, amount);\r\n  }\r\n\r\n  // Private functions ----------------\r\n\r\n  /* Accept ETH during presale (called by default function) */\r\n\r\n  function buyTokens() private {\r\n    // initial checks\r\n    require( atNow() > DATE_PRESALE_START && atNow() < DATE_PRESALE_END );\r\n    require( msg.value >= MIN_CONTRIBUTION && msg.value <= MAX_CONTRIBUTION );\r\n    require( etherReceivedCrowd.add(msg.value) <= FUNDING_PRESALE_MAX );\r\n\r\n    // tokens\r\n    uint tokens;\r\n    if (presaleContributorCount < CUTOFF_PRESALE_ONE) {\r\n      // wave 1\r\n      tokens = TOKETH_PRESALE_ONE.mul(msg.value) / 1 ether;\r\n    } else if (presaleContributorCount < CUTOFF_PRESALE_TWO) {\r\n      // wave 2\r\n      tokens = TOKETH_PRESALE_TWO.mul(msg.value) / 1 ether;\r\n    } else {\r\n      // wave 3\r\n      tokens = TOKETH_PRESALE_THREE.mul(msg.value) / 1 ether;\r\n    }\r\n    presaleContributorCount += 1;\r\n    \r\n    // issue tokens\r\n    issueTokens(msg.sender, tokens, msg.value, false); // false => not private sale\r\n  }\r\n  \r\n  /* Issue tokens */\r\n  \r\n  function issueTokens(address _account, uint _tokens, uint _amount, bool _isPrivateSale) private {\r\n    // register tokens purchased and Ether received\r\n    balances[_account] = balances[_account].add(_tokens);\r\n    tokensIssuedCrowd  = tokensIssuedCrowd.add(_tokens);\r\n    tokensIssuedTotal  = tokensIssuedTotal.add(_tokens);\r\n    \r\n    if (_isPrivateSale) {\r\n      tokensIssuedPrivate         = tokensIssuedPrivate.add(_tokens);\r\n      etherReceivedPrivate        = etherReceivedPrivate.add(_amount);\r\n      balancesPrivate[_account]   = balancesPrivate[_account].add(_tokens);\r\n      balanceEthPrivate[_account] = balanceEthPrivate[_account].add(_amount);\r\n    } else {\r\n      etherReceivedCrowd        = etherReceivedCrowd.add(_amount);\r\n      balancesCrowd[_account]   = balancesCrowd[_account].add(_tokens);\r\n      balanceEthCrowd[_account] = balanceEthCrowd[_account].add(_amount);\r\n    }\r\n    \r\n    // log token issuance\r\n    Transfer(0x0, _account, _tokens);\r\n    TokensIssued(_account, _tokens, balances[_account], tokensIssuedCrowd, _isPrivateSale, _amount);\r\n\r\n    // transfer Ether out\r\n    if (this.balance > 0) wallet.transfer(this.balance);\r\n\r\n  }\r\n\r\n  // ERC20 functions ------------------\r\n\r\n  /* Override \"transfer\" */\r\n\r\n  function transfer(address _to, uint _amount) public returns (bool success) {\r\n    require( _to == owner || (!tokensFrozen && _to == redemptionWallet) );\r\n    return super.transfer(_to, _amount);\r\n  }\r\n  \r\n  /* Override \"transferFrom\" */\r\n\r\n  function transferFrom(address _from, address _to, uint _amount) public returns (bool success) {\r\n    require( !tokensFrozen && _to == redemptionWallet );\r\n    return super.transferFrom(_from, _to, _amount);\r\n  }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"add\",\"outputs\":[{\"name\":\"c\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"div\",\"outputs\":[{\"name\":\"c\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"sub\",\"outputs\":[{\"name\":\"c\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"mul\",\"outputs\":[{\"name\":\"c\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"SafeM","CompilerVersion":"v0.4.17+commit.bdeb9e52","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://cf4e502e28581e48939d2e1e2f9717b84fa4e7031f343d7063ebca1615b7ae39"}]}