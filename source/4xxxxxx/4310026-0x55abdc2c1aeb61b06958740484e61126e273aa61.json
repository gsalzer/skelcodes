{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n    }\r\n  }\r\n\r\n}\r\n\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev modifier to allow actions only when the contract IS paused\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to allow actions only when the contract IS NOT paused\r\n   */\r\n  modifier whenPaused {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused returns (bool) {\r\n    paused = true;\r\n    Pause();\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused returns (bool) {\r\n    paused = false;\r\n    Unpause();\r\n    return true;\r\n  }\r\n}\r\n\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) constant returns (uint256);\r\n  function transfer(address to, uint256 value) returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) returns (bool) {\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of. \r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) returns (bool);\r\n  function approve(address spender, uint256 value) returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amout of tokens to be transfered\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\r\n    var _allowance = allowed[_from][msg.sender];\r\n\r\n    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n    // require (_value <= _allowance);\r\n\r\n    balances[_to] = balances[_to].add(_value);\r\n    balances[_from] = balances[_from].sub(_value);\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) returns (bool) {\r\n\r\n    // To change the approve amount you first have to reduce the addresses`\r\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n    //  already 0 to mitigate the race condition described here:\r\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifing the amount of tokens still avaible for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n}\r\n\r\ncontract PausableToken is StandardToken, Pausable {\r\n\r\n  function transfer(address _to, uint _value) whenNotPaused returns (bool) {\r\n    return super.transfer(_to, _value);\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value) whenNotPaused returns (bool) {\r\n    return super.transferFrom(_from, _to, _value);\r\n  }\r\n}\r\n\r\ncontract Factory {\r\n\r\n    // address public mainnetPresaleContractAddress = 0x6a5B0fa01590ec2F03682023192C95A2EBd8e3B9;\r\n    // address[] public mainnetPresaleBuyers = [\r\n    //     0x00010bd8606a84b1bbad0f2c70b13cce44a46910,\r\n    //     0x00a109ab01028056768469aa11328c8f9d3db45b,\r\n    //     0x01e2f9ba53b6cb91e7f158090d24ebbcadf0c564,\r\n    //     0x0347297c8c1f278c739ff8d76550a3386cf88b60,\r\n    //     0x09b467499cfa5b094aa96eea80fa7095a2508731,\r\n    //     0x0cea3e5c3663f8634b623327a635ca8c2e0ca276,\r\n    //     0x0f659b838270390aaa6bf16e0b9d01ad15d43f00,\r\n    //     0x188cac349c6a156476711a2357779706cfed403f,\r\n    //     0x18ea39b27b1dd0e53a46a90f544a3ee6e16f94c4,\r\n    //     0x1b3b36b36a64aaef71354ef655bffd577ba0276c,\r\n    //     0x1e74a46e968bc0472d09533bf93da27a6c21b079,\r\n    //     0x20abf65634219512c6c98a64614c43220ca2085b,\r\n    //     0x2195fe76d358acd2dc7e804f60bb5f4d53d9f907,\r\n    //     0x23cdcdfcf58a593ed16cf8ff5516a37fee1d48d8,\r\n    //     0x2471ceb7520b926ba02d876cd032fd020237e413,\r\n    //     0x249f600fd158ccd81a418db93a5d3d1b3c420b13,\r\n    //     0x267be1c1d684f78cb4f6a176c4911b741e4ffdc0,\r\n    //     0x2c02d03f53489bd2774f9e360ea393a6c6329bdb,\r\n    //     0x330c63a5b737b5542be108a74b3fef6272619585,\r\n    //     0x358c39cc0aba5fcc0689d840024c4caeb06f85c0,\r\n    //     0x36ca1322f23209703d7bfc4663d2267b07a4cbe8,\r\n    //     0x3833f8dbdbd6bdcb6a883ff209b869148965b364,\r\n    //     0x387fa411fae6769e4fcedcba838d22ea2dd9ffed,\r\n    //     0x3d6f29c67f571cad827bb512c7949b0a1c0b9899,\r\n    //     0x3eb0aefabec429149dd0d4ae560238fb0b68976e,\r\n    //     0x3f04b7101708b7e4a2c693270254ef8a32977b36,\r\n    //     0x41e8374286aacb2b85189cc74b4d1c0362d4fc80,\r\n    //     0x4644c88b98dd5dda0cb6040366df2b4f37e6b50f,\r\n    //     0x4a83cee7d83c28891d851910f7a240a4c2c4d9eb,\r\n    //     0x4b0250098cf3f62f4595be93d8c0afcfe0bd63f1,\r\n    //     0x4f813b5cf2750a59a45f3c5e50397d6ac02b64f9,\r\n    //     0x5030baf58fab3c95799edc9e6cd08abfde5f1e5a,\r\n    //     0x51072c4f9bca88bc9b3b2327fb44b1272ba115c0,\r\n    //     0x532cbc68f66bb7482086a15972fa20ee3aca21c4,\r\n    //     0x53564581a45a5520243083ce050f76ef933a1e66,\r\n    //     0x55c86e80fbe2db0d81ff856110556b1df1713899,\r\n    //     0x598f65c344b3644a9b6bd23a99860cd8d0c3e20a,\r\n    //     0x5f2bdf26f6528ce05aac77d7fa52bac7a836ef66,\r\n    //     0x63e0d8753480ffcc6ce65ec46f9efb06778e819c,\r\n    //     0x66294a00e801db524b215952bf60e85e1a945895,\r\n    //     0x6771bb70d84bedeb60166df47ebb9056169d7a0d,\r\n    //     0x67adfab056edc1a03602139b8ac36a06fc62f1bb,\r\n    //     0x72df894c334a0b8a58b7d220b72d29a50521d9a4,\r\n    //     0x72f084f5ed9384194870b855c22b0065961305b4,\r\n    //     0x75360cbe8c7cb8174b1b623a6d9aacf952c117e3,\r\n    //     0x75e7f640bf6968b6f32c47a3cd82c3c2c9dcae68,\r\n    //     0x76d3451bec571316cfe096b1ab64681286b078d5,\r\n    //     0x783bd8a6077d02eeecbfc142929d71ff4aa2762d,\r\n    //     0x7c01113c3c382d9c1c39e3daa9262e27787a02ee,\r\n    //     0x7ed1e469fcb3ee19c0366d829e291451be638e59,\r\n    //     0x7fec3afb1075d3ee2ca6bd685a9895290ad917df,\r\n    //     0x83e09aee382c74ac0c3094d4a99a45d607590c28,\r\n    //     0x86a392b40c6b33fdbb142eae4c40ff05d3daa82f,\r\n    //     0x87b10daf0522e54cd4cdd3029eac0fdd306f644e,\r\n    //     0x87b325cf000e426b64518d50bf3fb11c28eee89e,\r\n    //     0x8c46dc82995d3bad337418df9a111b289fd50abc,\r\n    //     0x93fb7bea36d788bcb87ba92094b72c6c43586bdb,\r\n    //     0x952aa202f9656eca051ef36ce66925a0d0e34723,\r\n    //     0x9903322124677c2aaf289eec5117bfa8aeac3f42,\r\n    //     0x993841ab5028ee74245d350edd3c89405d4212ea,\r\n    //     0x9ac0233a97b0005462f7d65943b8cf6d7d074280,\r\n    //     0x9d8d17d134be89c832559e1653f8e15d6b8bb05a,\r\n    //     0xa102d39f4aa67f458e9536b04da9b80847c04a57,\r\n    //     0xa163d40de9dc681d7850ed24564d1805414ac468,\r\n    //     0xa263327200a9648c063ef1d9f0746a50b23caa56,\r\n    //     0xaefb5464fadc9293700a9c4bc4fbefb4d768931d,\r\n    //     0xaf302aa751058797c6ab5249cb83547a6357763a,\r\n    //     0xb37e62dce9daee5a2de41e4475c8262f5bb9edae,\r\n    //     0xb93b6e8816091ceb78cca35f7022b477e44c490a,\r\n    //     0xb94142f522bfe77b1075527d8e6a11cbcd901e26,\r\n    //     0xbb4e6fdfbc01b1f2b52272d998fcaa274d7f1651,\r\n    //     0xbdf9b5bda53c709cce44a073067b3e26afe1d816,\r\n    //     0xcd73fd5deec3670926d0cd29b634f6c2938b1df6,\r\n    //     0xcf1996c3b7f9ff891ebf94067b6d0edfa1b181f0,\r\n    //     0xd1f670779246349931ba76ffdf8c90de70946cac,\r\n    //     0xd2e3c4856d25a71fa777769b5dc9596890568026,\r\n    //     0xd4cb7fd8e2b214596c1cbd4ba0f1c701fbf2bcb8,\r\n    //     0xd5742c05e6ae9ea99af45a7c7d1517ce6c042d25,\r\n    //     0xe41ce247756d757e3060ec361c201be019bd54f6,\r\n    //     0xe702afb99a46f9a6e15d3565823867b8b40c499c,\r\n    //     0xec30eacdb39705ec281e10891d605cb0be41e094,\r\n    //     0xee55181386d9b743064c570601014df163d5554c,\r\n    //     0xee8ce6f0ebef4231068db3705fadff5ef9a1f45e,\r\n    //     0xef58321032cf693fa7e39f31e45cbc32f2092cb3,\r\n    //     0xef9a1b20384989f79f73fd5a261e270d6d1888d3,\r\n    //     0xf656d04f13b7bdf09410b8b5cb75bbe3ac5a37e7,\r\n    //     0xf6dc43ba328affec2afebda472ac6977200da957,\r\n    //     0xf6edf5dcdfba55f3cecee2a430bb6c2d30a4a1a8,\r\n    //     0xf8ac3740622308414a41619af0648328f69b6fc0,\r\n    //     0xf8f337c518b4979f12348c279696a5b7754f662e,\r\n    //     0xfbb1b73c4f0bda4f67dca266ce6ef42f520fbb98,\r\n    //     0xfc7d5e499f869d8ee0b17c61b0f6f83bbac2fbc2,\r\n    //     0xffca1e2e0e50faf10cd4a8e1d5bd2f5db57a0771\r\n    // ];\r\n\r\n    // address public testnetPresaleContractAddress = 0x6fb8A63800a00141052Ea524f415398188879086;\r\n    // address[] public testnetPresaleBuyers = [\r\n    //     0xf6c6fac8b78e3196eced61df42a0d37cfddbf3f8  \r\n    // ];\r\n\r\n    function createContract(\r\n        address newWallet,\r\n        address newMarketingWallet,\r\n        address newLiquidityReserveWallet,\r\n        uint256 newIcoEtherMinCap,\r\n        uint256 newIcoEtherMaxCap,\r\n        uint256 totalPresaleRaised) returns(address created)\r\n    {\r\n        return new SomaIco(\r\n                        newWallet,\r\n                        newMarketingWallet,\r\n                        newLiquidityReserveWallet,\r\n                        newIcoEtherMinCap * 1 ether,\r\n                        newIcoEtherMaxCap * 1 ether,\r\n                        totalPresaleRaised\r\n        );\r\n    }\r\n\r\n    function createTestNetContract(\r\n        address wallet,\r\n        address marketingWallet,\r\n        address liquidityReserveWallet,\r\n        uint256 newIcoEtherMinCap,\r\n        uint256 newIcoEtherMaxCap,\r\n        uint256 totalPresaleRaised) returns(address created)\r\n    {\r\n    \r\n     /*\r\n     Contract Admin/Owner: 0x695CA2a93A53f81a7bc48E2c92801A9c0D489a4C\r\n     Funds Wallet: 0x114189928020641C388cBD6126E615f8328A7409\r\n     Marketing wallet: 0x114189928020641C388cBD6126E615f8328A7409\r\n     Liquidity reserve 0x0873D8c478A2E80C5467374661e903c121c3A8C4\r\n     Presale total supply: 2007500000000000000000\r\n     */\r\n     \r\n        address contractAddress = createContract(\r\n            wallet,\r\n            marketingWallet,\r\n            liquidityReserveWallet,\r\n            newIcoEtherMinCap,\r\n            newIcoEtherMaxCap,\r\n            totalPresaleRaised\r\n        );\r\n\r\n        //migratePresaleBalances(contractAddress, testnetPresaleContractAddress, testnetPresaleBuyers);\r\n\r\n        //transferOwnership(owner, contractAddress);\r\n\r\n        return contractAddress;\r\n    }\r\n\r\n    function createMainNetContract(\r\n        uint256 newIcoEtherMinCap,\r\n        uint256 newIcoEtherMaxCap) returns(address created)\r\n    {\r\n        //address owner = 0x1025376b8991ACAFBc7d84Fa1a56a63DcfBF04CB; // mainnet admin\r\n        address wallet = 0x22c6731A21aD946Bcd934f62f04B2D06EBFbedC9; // mainnet funds\r\n        address marketingWallet = 0x4A5467431b54C152E404EB702242E78030972DE7; // marketing wallet\r\n        address liquidityReserveWallet = 0xdf398E0bE9e0Da2D8F8D687FD6B2c9082eEFC29a;\r\n\r\n        uint256 totalPresaleRaised = 258405312277978624000;\r\n\r\n        address contractAddress = createContract(\r\n            wallet,\r\n            marketingWallet,\r\n            liquidityReserveWallet,\r\n            newIcoEtherMinCap,\r\n            newIcoEtherMaxCap,\r\n            totalPresaleRaised\r\n        );\r\n\r\n        //migratePresaleBalances(contractAddress, mainnetPresaleContractAddress, mainnetPresaleBuyers);\r\n\r\n        //transferOwnership(owner, contractAddress);\r\n\r\n        return contractAddress;\r\n    }\r\n\r\n    function transferOwnership(address owner, address contractAddress) public {\r\n        Ownable ownableContract = Ownable(contractAddress);\r\n        ownableContract.transferOwnership(owner);\r\n    }\r\n\r\n    function migratePresaleBalances(\r\n        address icoContractAddress,\r\n        address presaleContractAddress,\r\n        address[] buyers) public\r\n    {\r\n        SomaIco icoContract = SomaIco(icoContractAddress);\r\n        ERC20Basic presaleContract = ERC20Basic(presaleContractAddress);\r\n        for (uint i = 0; i < buyers.length; i++) {\r\n            address buyer = buyers[i];\r\n            if (icoContract.balanceOf(buyer) > 0) {\r\n                continue;\r\n            }\r\n            uint256 balance = presaleContract.balanceOf(buyer);\r\n            if (balance > 0) {\r\n                icoContract.manuallyAssignTokens(buyer, balance);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract SomaIco is PausableToken {\r\n    using SafeMath for uint256;\r\n\r\n    string public name = \"Soma Community Token\";\r\n    string public symbol = \"SCT\";\r\n    uint8 public decimals = 18;\r\n\r\n    address public liquidityReserveWallet; // address where liquidity reserve tokens will be delivered\r\n    address public wallet; // address where funds are collected\r\n    address public marketingWallet; // address which controls marketing token pool\r\n\r\n    uint256 public icoStartTimestamp; // ICO start timestamp\r\n    uint256 public icoEndTimestamp; // ICO end timestamp\r\n\r\n    uint256 public totalRaised = 0; // total amount of money raised in wei\r\n    uint256 public totalSupply; // total token supply with decimals precisoin\r\n    uint256 public marketingPool; // marketing pool with decimals precisoin\r\n    uint256 public tokensSold = 0; // total number of tokens sold\r\n\r\n    bool public halted = false; //the owner address can set this to true to halt the crowdsale due to emergency\r\n\r\n    uint256 public icoEtherMinCap; // should be specified as: 8000 * 1 ether\r\n    uint256 public icoEtherMaxCap; // should be specified as: 120000 * 1 ether\r\n    uint256 public rate = 450; // standard SCT/ETH rate\r\n\r\n    event Burn(address indexed burner, uint256 value);\r\n\r\n    function SomaIco(\r\n        address newWallet,\r\n        address newMarketingWallet,\r\n        address newLiquidityReserveWallet,\r\n        uint256 newIcoEtherMinCap,\r\n        uint256 newIcoEtherMaxCap,\r\n        uint256 totalPresaleRaised\r\n    ) {\r\n        require(newWallet != 0x0);\r\n        require(newMarketingWallet != 0x0);\r\n        require(newLiquidityReserveWallet != 0x0);\r\n        require(newIcoEtherMinCap <= newIcoEtherMaxCap);\r\n        require(newIcoEtherMinCap > 0);\r\n        require(newIcoEtherMaxCap > 0);\r\n\r\n        pause();\r\n\r\n        icoEtherMinCap = newIcoEtherMinCap;\r\n        icoEtherMaxCap = newIcoEtherMaxCap;\r\n        wallet = newWallet;\r\n        marketingWallet = newMarketingWallet;\r\n        liquidityReserveWallet = newLiquidityReserveWallet;\r\n\r\n        // calculate marketingPool and totalSupply based on the max cap:\r\n        // totalSupply = rate * icoEtherMaxCap + marketingPool\r\n        // marketingPool = 10% * totalSupply\r\n        // hence:\r\n        // totalSupply = 10/9 * rate * icoEtherMaxCap\r\n        totalSupply = icoEtherMaxCap.mul(rate).mul(10).div(9);\r\n        marketingPool = totalSupply.div(10);\r\n\r\n        // account for the funds raised during the presale\r\n        totalRaised = totalRaised.add(totalPresaleRaised);\r\n\r\n        // assign marketing pool to marketing wallet\r\n        assignTokens(marketingWallet, marketingPool);\r\n    }\r\n\r\n    /// fallback function to buy tokens\r\n    function () nonHalted nonZeroPurchase acceptsFunds payable {\r\n        address recipient = msg.sender;\r\n        uint256 weiAmount = msg.value;\r\n\r\n        uint256 amount = weiAmount.mul(rate);\r\n\r\n        assignTokens(recipient, amount);\r\n        totalRaised = totalRaised.add(weiAmount);\r\n\r\n        forwardFundsToWallet();\r\n    }\r\n\r\n    modifier acceptsFunds() {\r\n        bool hasStarted = icoStartTimestamp != 0 && now >= icoStartTimestamp;\r\n        require(hasStarted);\r\n\r\n        // ICO is continued over the end date until the min cap is reached\r\n        bool isIcoInProgress = now <= icoEndTimestamp\r\n                || (icoEndTimestamp == 0) // before dates are set\r\n                || totalRaised < icoEtherMinCap;\r\n        require(isIcoInProgress);\r\n\r\n        bool isBelowMaxCap = totalRaised < icoEtherMaxCap;\r\n        require(isBelowMaxCap);\r\n\r\n        _;\r\n    }\r\n\r\n    modifier nonHalted() {\r\n        require(!halted);\r\n        _;\r\n    }\r\n\r\n    modifier nonZeroPurchase() {\r\n        require(msg.value > 0);\r\n        _;\r\n    }\r\n\r\n    function forwardFundsToWallet() internal {\r\n        wallet.transfer(msg.value); // immediately send Ether to wallet address, propagates exception if execution fails\r\n    }\r\n\r\n    function assignTokens(address recipient, uint256 amount) internal {\r\n        balances[recipient] = balances[recipient].add(amount);\r\n        tokensSold = tokensSold.add(amount);\r\n\r\n        // sanity safeguard\r\n        if (tokensSold > totalSupply) {\r\n            // there is a chance that tokens are sold over the supply:\r\n            // a) when: total presale bonuses > (maxCap - totalRaised) * rate\r\n            // b) when: last payment goes over the maxCap\r\n            totalSupply = tokensSold;\r\n        }\r\n\r\n        Transfer(0x0, recipient, amount);\r\n    }\r\n\r\n    function setIcoDates(uint256 newIcoStartTimestamp, uint256 newIcoEndTimestamp) public onlyOwner {\r\n        require(newIcoStartTimestamp < newIcoEndTimestamp);\r\n        require(!isIcoFinished());\r\n        icoStartTimestamp = newIcoStartTimestamp;\r\n        icoEndTimestamp = newIcoEndTimestamp;\r\n    }\r\n\r\n    function setRate(uint256 _rate) public onlyOwner {\r\n        require(!isIcoFinished());\r\n        rate = _rate;\r\n    }\r\n\r\n    function haltFundraising() public onlyOwner {\r\n        halted = true;\r\n    }\r\n\r\n    function unhaltFundraising() public onlyOwner {\r\n        halted = false;\r\n    }\r\n\r\n    function isIcoFinished() public constant returns (bool icoFinished) {\r\n        return (totalRaised >= icoEtherMinCap && icoEndTimestamp != 0 && now > icoEndTimestamp) ||\r\n               (totalRaised >= icoEtherMaxCap);\r\n    }\r\n\r\n    function prepareLiquidityReserve() public onlyOwner {\r\n        require(isIcoFinished());\r\n        \r\n        uint256 unsoldTokens = totalSupply.sub(tokensSold);\r\n        // make sure there are any unsold tokens to be assigned\r\n        require(unsoldTokens > 0);\r\n\r\n        // try to allocate up to 10% of total sold tokens to Liquidity Reserve fund:\r\n        uint256 liquidityReserveTokens = tokensSold.div(10);\r\n        if (liquidityReserveTokens > unsoldTokens) {\r\n            liquidityReserveTokens = unsoldTokens;\r\n        }\r\n        assignTokens(liquidityReserveWallet, liquidityReserveTokens);\r\n        unsoldTokens = unsoldTokens.sub(liquidityReserveTokens);\r\n\r\n        // if there are still unsold tokens:\r\n        if (unsoldTokens > 0) {\r\n            // decrease  (burn) total supply by the number of unsold tokens:\r\n            totalSupply = totalSupply.sub(unsoldTokens);\r\n        }\r\n\r\n        // make sure there are no tokens left\r\n        assert(tokensSold == totalSupply);\r\n    }\r\n\r\n    function manuallyAssignTokens(address recipient, uint256 amount) public onlyOwner {\r\n        require(tokensSold < totalSupply);\r\n        assignTokens(recipient, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Burns a specific amount of tokens.\r\n     * @param _value The amount of token to be burned.\r\n     */\r\n    function burn(uint256 _value) public whenNotPaused {\r\n        require(_value > 0);\r\n\r\n        address burner = msg.sender;\r\n        balances[burner] = balances[burner].sub(_value);\r\n        totalSupply = totalSupply.sub(_value);\r\n        Burn(burner, _value);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"newWallet\",\"type\":\"address\"},{\"name\":\"newMarketingWallet\",\"type\":\"address\"},{\"name\":\"newLiquidityReserveWallet\",\"type\":\"address\"},{\"name\":\"newIcoEtherMinCap\",\"type\":\"uint256\"},{\"name\":\"newIcoEtherMaxCap\",\"type\":\"uint256\"},{\"name\":\"totalPresaleRaised\",\"type\":\"uint256\"}],\"name\":\"createContract\",\"outputs\":[{\"name\":\"created\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"marketingWallet\",\"type\":\"address\"},{\"name\":\"liquidityReserveWallet\",\"type\":\"address\"},{\"name\":\"newIcoEtherMinCap\",\"type\":\"uint256\"},{\"name\":\"newIcoEtherMaxCap\",\"type\":\"uint256\"},{\"name\":\"totalPresaleRaised\",\"type\":\"uint256\"}],\"name\":\"createTestNetContract\",\"outputs\":[{\"name\":\"created\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newIcoEtherMinCap\",\"type\":\"uint256\"},{\"name\":\"newIcoEtherMaxCap\",\"type\":\"uint256\"}],\"name\":\"createMainNetContract\",\"outputs\":[{\"name\":\"created\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"icoContractAddress\",\"type\":\"address\"},{\"name\":\"presaleContractAddress\",\"type\":\"address\"},{\"name\":\"buyers\",\"type\":\"address[]\"}],\"name\":\"migratePresaleBalances\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Factory","CompilerVersion":"v0.4.16+commit.d7661dd9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://9457aaa26d3a4191ccb8a53dc79e1491fd99093777c794fd5948a8a0da0e8407"}]}