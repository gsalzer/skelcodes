{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^ 0.4.8;\r\n\r\ncontract Project {function studioHandler( address _from, uint256 _value );}\r\n\r\n \r\n contract Projects {\r\n     \r\n    Project public project_contract;\r\n \r\n    mapping( address => bool ) public projects;\r\n    mapping( address => bool ) public projectExists;\r\n    mapping( uint => address) public  projectIndex;\r\n    uint projectCount;\r\n    address public owner;\r\n    address public management;\r\n    \r\n    mapping( address => bool ) public mediaTokens;\r\n    mapping( address => uint256 ) public mediaTokensInitialSupply;\r\n    mapping( address => uint8 ) public mediaTokensDecimalUnits;\r\n    mapping( address => string ) public mediaTokensName;\r\n    mapping( address => string ) public mediaTokensSymbol;\r\n    mapping( uint => address) public  mediaTokenIndex;\r\n    uint mediaTokenCount;\r\n\r\n\r\n \r\n\r\n    event ProjectCall ( address _address, uint _value );\r\n\r\n\r\n     modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n     modifier onlyManagement {\r\n        require (  management == msg.sender || owner == msg.sender  );\r\n        _;\r\n    }\r\n\r\n\r\n    function addProject ( address _project ) public onlyManagement{\r\n        \r\n            projects[ _project ] = true;\r\n        if  ( !projectExists[ _project ]){\r\n            projectExists[ _project ] = true;\r\n            projectIndex[ projectCount ] = _project;\r\n            projectCount++;\r\n        }\r\n    }\r\n    \r\n    function removeProject ( address _project ) public onlyManagement{\r\n        \r\n        projects[ _project ] =false;\r\n        \r\n    }\r\n    \r\n    \r\n    function getProjectCount() public constant returns (uint256){\r\n        \r\n        return projectCount;\r\n        \r\n    }\r\n    \r\n    function getProjectAddress( uint slot ) public constant returns (address){\r\n        \r\n        return projectIndex[slot];\r\n        \r\n    }\r\n    \r\n    function getProjectStatus( address _address) public constant returns (bool) {\r\n        \r\n        return projects[ _address];\r\n    }\r\n\r\n\r\n    function projectCheck ( address _address, uint256 value ) internal  {\r\n        \r\n       \r\n        \r\n        if( projects[ _address ] ) {\r\n            project_contract = Project (  _address  );\r\n            project_contract.studioHandler  ( msg.sender , value );\r\n         \r\n        }        \r\n        ProjectCall ( _address , value  );\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\ncontract tokenRecipient {\r\n    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData);\r\n}\r\n\r\n\r\n\r\ncontract ERC20 {\r\n\r\n   function totalSupply() constant returns(uint totalSupply);\r\n\r\n    function balanceOf(address who) constant returns(uint256);\r\n\r\n    function transfer(address to, uint value) returns(bool ok);\r\n\r\n    function transferFrom(address from, address to, uint value) returns(bool ok);\r\n\r\n    function approve(address spender, uint value) returns(bool ok);\r\n\r\n    function allowance(address owner, address spender) constant returns(uint);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n\r\n}\r\n\r\ncontract BaseToken is ERC20 {\r\n\r\n    \r\n    string public standard = 'Token 1.0';\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    uint256 public totalSupply;\r\n    uint256 public initialSupply;\r\n\r\n\r\n    address public owner;\r\n    \r\n    \r\n\r\n    /* This creates an array with all balances */\r\n    mapping( address => uint256) public balanceOf;\r\n    mapping( uint => address) public accountIndex;\r\n    mapping (address => bool) public frozenAccount;\r\n    uint accountCount;\r\n    \r\n   \r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n    /* This generates a public event on the blockchain that will notify clients */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event FrozenFunds ( address target, bool frozen );\r\n\r\n    /* This notifies clients about the amount burnt */\r\n   // event Burn(address indexed from, uint256 value);\r\n\r\n    /* Initializes contract with initial supply tokens to the creator of the contract */\r\n    function BaseToken( uint256 _initialSupply, uint8 _decimalUnits, string _name, string _symbol, address _owner ) {\r\n\r\n        appendTokenHolders( _owner );\r\n        balanceOf[ _owner ] = _initialSupply; // Give the creator all initial tokens\r\n        totalSupply = _initialSupply; // Update total supply\r\n        initialSupply = _initialSupply;\r\n        name = _name; // Set the name for display purposes\r\n        symbol = _symbol; // Set the symbol for display purposes\r\n        decimals = _decimalUnits; // Amount of decimals for display purposes\r\n        owner = msg.sender;\r\n            \r\n\r\n    }\r\n\r\n    // Function allows for external access to tokenHoler's Balance\r\n    function balanceOf(address tokenHolder) constant returns(uint256) {\r\n\r\n        return balanceOf[tokenHolder];\r\n    }\r\n\r\n    function totalSupply() constant returns(uint256) {\r\n\r\n        return totalSupply;\r\n    }\r\n\r\n    // Function allows for external access to number of accounts that are holding or once held Studio\r\n    //tokens\r\n\r\n    function getAccountCount() constant returns(uint256) {\r\n\r\n        return accountCount;\r\n    }\r\n\r\n    //function allows for external access to tokenHolders\r\n    function getAddress(uint slot) constant returns(address) {\r\n\r\n        return accountIndex[slot];\r\n\r\n    }\r\n\r\n    // checks to see if tokenholder has a balance, if not it appends the tokenholder to the accountIndex\r\n   // which the getAddress() can later access externally\r\n\r\n    function appendTokenHolders(address tokenHolder) private {\r\n\r\n        if (balanceOf[tokenHolder] == 0) {\r\n            accountIndex[accountCount] = tokenHolder;\r\n            accountCount++;\r\n        }\r\n\r\n    }\r\n\r\n    /* Send coins */\r\n    function transfer(address _to, uint256 _value) returns(bool ok) {\r\n        \r\n        if (_to == 0x0) throw; // Prevent transfer to 0x0 address. Use burn() instead\r\n        if (balanceOf[msg.sender] < _value) throw; // Check if the sender has enough\r\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\r\n       //if ( frozenAccount[ msg.sender ]  ) throw;\r\n        appendTokenHolders(_to);\r\n        balanceOf[msg.sender] -= _value; // Subtract from the sender\r\n        balanceOf[_to] += _value; // Add the same to the recipient\r\n        Transfer(msg.sender, _to, _value); // Notify anyone listening that this transfer took place\r\n        return true;\r\n        \r\n    }\r\n\r\n    /* Allow another contract to spend some tokens in your behalf */\r\n    function approve(address _spender, uint256 _value) returns(bool success) {\r\n        \r\n        allowance[msg.sender][_spender] = _value;\r\n        Approval( msg.sender ,_spender, _value);\r\n        return true;\r\n        \r\n    }\r\n\r\n    /* Approve and then communicate the approved contract in a single tx */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns(bool success) {\r\n        \r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }\r\n        \r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns(uint256 remaining) {\r\n        \r\n        return allowance[_owner][_spender];\r\n    \r\n        \r\n    }\r\n\r\n    /* A contract attempts to get the coins */\r\n    function transferFrom(address _from, address _to, uint256 _value) returns(bool success) {\r\n        \r\n        if (_to == 0x0) throw; // Prevent transfer to 0x0 address. Use burn() instead\r\n        if (balanceOf[_from] < _value) throw; // Check if the sender has enough\r\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\r\n        if (_value > allowance[_from][msg.sender]) throw; // Check allowance\r\n        //if ( frozenAccount[ _from ]  ) throw;\r\n        appendTokenHolders(_to);\r\n        balanceOf[_from] -= _value; // Subtract from the sender\r\n        balanceOf[_to] += _value; // Add the same to the recipient\r\n        allowance[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n  /*\r\n    function burn(uint256 _value) returns(bool success) {\r\n        \r\n        if (balanceOf[msg.sender] < _value) throw; // Check if the sender has enough\r\n        balanceOf[msg.sender] -= _value; // Subtract from the sender\r\n        totalSupply -= _value; // Updates totalSupply\r\n        Burn(msg.sender, _value);\r\n        return true;\r\n    \r\n        \r\n    }\r\n\r\n    function burnFrom(address _from, uint256 _value) returns(bool success) {\r\n        \r\n        if (balanceOf[_from] < _value) throw; // Check if the sender has enough\r\n        if (_value > allowance[_from][msg.sender]) throw; // Check allowance\r\n        if ( (totalSupply - _value) <  ( initialSupply / 2 )) throw;\r\n        balanceOf[_from] -= _value; // Subtract from the sender\r\n        totalSupply -= _value; // Updates totalSupply\r\n        Burn(_from, _value);\r\n        return true;\r\n        \r\n    }\r\n*/\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n   \r\n    /*\r\n    function freezeAccount ( address _account ) public onlyOwner {\r\n        \r\n        frozenAccount [ _account ] = true;\r\n        FrozenFunds ( _account , true );\r\n        \r\n        \r\n    }\r\n    \r\n    function unfreezeAccount ( address _account ) public onlyOwner{\r\n        \r\n         frozenAccount [ _account ] = false;\r\n         FrozenFunds ( _account , false );\r\n        \r\n        \r\n    }\r\n    */\r\n    \r\n   \r\n    \r\n}\r\n\r\n\r\ncontract TheStudioToken is ERC20, Projects  {\r\n    \r\n    \r\n    uint associateproducer;\r\n    uint producer;\r\n    uint executiveproducer;\r\n    \r\n    event newMediaTokenCreated ( string _name , address _address , string _symbol );\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    \r\n   \r\n    /* Public variables of the token */\r\n    string public standard = 'Token 1.0';\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    uint256 public totalSupply;\r\n    uint256 public initialSupply;\r\n    \r\n\r\n    \r\n    BaseToken public mediaToken;\r\n    \r\n    //Crowdsale public mediaTokenCrowdSale;\r\n    \r\n    \r\n       \r\n    \r\n    \r\n\r\n    /* This creates an array with all balances */\r\n    mapping( address => uint256) public balanceOf;\r\n    mapping( uint => address) public accountIndex;\r\n    mapping( address =>bool ) public accountFreeze;\r\n    uint accountCount;\r\n    \r\n   \r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n    /* This generates a public event on the blockchain that will notify clients */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event FrozenFunds ( address target, bool frozen );\r\n    event FrozenMediaTokenFunds ( address mediatoken, address target, bool frozen );\r\n\r\n    /* This notifies clients about the amount burnt */\r\n    event Burn(address indexed from, uint256 value);\r\n    \r\n    \r\n   \r\n    \r\n    function TheStudioToken() {\r\n\r\n        associateproducer = 2500; // change to 2500\r\n        producer = 10000;          // change to 10000\r\n        executiveproducer = 100000;\r\n        uint256 _initialSupply = 5000000000000000; // THIS HERE MAY NEED TO BE ADJUSTED..\r\n        appendTokenHolders(msg.sender);\r\n        balanceOf[msg.sender] = _initialSupply; // Give the creator all initial tokens\r\n        totalSupply = _initialSupply; // Update total supply\r\n        initialSupply = _initialSupply;\r\n        name = \"STUDIO\"; // Set the name for display purposes\r\n        symbol = \"STDO\"; // Set the symbol for display purposes\r\n        decimals = 8; // Amount of decimals for display purposes\r\n        owner = msg.sender;\r\n\r\n    }\r\n       // checks to see if tokenholder has a balance, if not it appends the tokenholder to the accountIndex\r\n   // which the getAddress() can later access externally\r\n\r\n    \r\n      function appendTokenHolders(address tokenHolder) private {\r\n\r\n        if (balanceOf[tokenHolder] == 0) {\r\n            accountIndex[accountCount] = tokenHolder;\r\n            accountCount++;\r\n        }\r\n\r\n    }\r\n    \r\n    \r\n     function studioLevel ( address _address ) public constant returns(string){\r\n        \r\n        if ( balanceOf [ _address] == 0 ) return \"NO LOVE\";\r\n        if ( balanceOf [ _address] < associateproducer * 100000000 ) return \"FAN\";\r\n        if ( balanceOf [ _address] < producer * 100000000  ) return \"ASSOCIATE PRODUCER\";\r\n        if ( balanceOf [ _address] < executiveproducer * 100000000  ) return \"PRODUCER\";\r\n        return \"EXECUTIVE PRODUCER\";\r\n        \r\n    }\r\n    \r\n     function transferOwnership(address newOwner) public onlyOwner {\r\n\r\n        owner = newOwner;\r\n    }\r\n    \r\n    \r\n    \r\n     function assignManagement(address _management ) public onlyOwner {\r\n\r\n        management = _management;\r\n    }\r\n    \r\n    \r\n    /*\r\n    function freezeMediaTokenAccount ( address _mediatoken, address _account ) public onlyManagement {\r\n         \r\n         \r\n        mediaToken = BaseToken (  _mediatoken );\r\n        mediaToken.freezeAccount ( _account );\r\n        FrozenMediaTokenFunds ( _mediatoken,  _account , true );\r\n        \r\n        \r\n    }\r\n    \r\n    function unfreezeMediaTokenAccount  ( address  _mediatoken, address _account ) public onlyManagement {\r\n        \r\n        mediaToken = BaseToken (  _mediatoken );\r\n        mediaToken.unfreezeAccount ( _account );\r\n        FrozenMediaTokenFunds ( _mediatoken, _account , false );\r\n        \r\n        \r\n    }\r\n    \r\n    \r\n    */\r\n    \r\n    function newMediaToken ( uint256 _initialSupply, uint8 _decimalUnits, string _name, string _symbol ) public onlyManagement {\r\n        \r\n        BaseToken _mediaToken = new BaseToken(  _initialSupply,  _decimalUnits,  _name,  _symbol, owner  );\r\n        mediaTokens[ _mediaToken ] = true;\r\n        mediaTokenIndex[ mediaTokenCount ] = _mediaToken;\r\n        mediaTokensInitialSupply[ _mediaToken ] = _initialSupply;\r\n        mediaTokensDecimalUnits[ _mediaToken ] = _decimalUnits;\r\n        mediaTokensName[ _mediaToken ] = _name;\r\n        mediaTokensSymbol[ _mediaToken ] = _symbol;\r\n        mediaTokenCount++;\r\n        newMediaTokenCreated ( _name , _mediaToken , _symbol );\r\n        \r\n       \r\n        \r\n        \r\n        \r\n        \r\n        \r\n    }\r\n    \r\n    \r\n    \r\n    \r\n     function transfer(address _to, uint256 _value) returns(bool ok) {\r\n        \r\n        if (_to == 0x0) throw; // Prevent transfer to 0x0 address. Use burn() instead\r\n        if (balanceOf[msg.sender] < _value) throw; // Check if the sender has enough\r\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\r\n        if ( accountFreeze[ msg.sender ]  ) throw;\r\n        appendTokenHolders(_to);\r\n        balanceOf[msg.sender] -= _value; // Subtract from the sender\r\n        balanceOf[_to] += _value; // Add the same to the recipient\r\n        Transfer(msg.sender, _to, _value); // Notify anyone listening that this transfer took place\r\n        projectCheck( _to , _value );\r\n        return true;\r\n    }\r\n    \r\n    \r\n    function transferFrom(address _from, address _to, uint256 _value) returns(bool success) {\r\n    \r\n        if (_to == 0x0) throw; // Prevent transfer to 0x0 address. Use burn() instead\r\n        if (balanceOf[_from] < _value) throw; // Check if the sender has enough\r\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\r\n        if (_value > allowance[_from][msg.sender]) throw; // Check allowance\r\n        if ( accountFreeze[ _from ]  ) throw;\r\n        appendTokenHolders(_to);\r\n        balanceOf[_from] -= _value; // Subtract from the sender\r\n        balanceOf[_to] += _value; // Add the same to the recipient\r\n        allowance[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n        projectCheck( _to , _value );\r\n        return true;\r\n    }\r\n    \r\n     function approve(address _spender, uint256 _value)  returns(bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        Approval( msg.sender ,_spender, _value);\r\n        return true;\r\n    }\r\n    \r\n      \r\n    \r\n    // Function allows for external access to tokenHoler's Balance\r\n    function balanceOf(address tokenHolder) constant returns(uint256) {\r\n\r\n        return balanceOf[tokenHolder];\r\n    }\r\n\r\n    function totalSupply() constant returns(uint256) {\r\n\r\n        return totalSupply;\r\n    }\r\n\r\n    // Function allows for external access to number of accounts that are holding or once held Studio\r\n    //tokens\r\n\r\n    function getAccountCount() constant returns(uint256) {\r\n\r\n        return accountCount;\r\n    }\r\n\r\n    //function allows for external access to tokenHolders\r\n    function getAddress(uint slot) constant returns(address) {\r\n\r\n        return accountIndex[slot];\r\n\r\n    }\r\n\r\n \r\n   \r\n     function burn(uint256 _value) returns(bool success) {\r\n        if (balanceOf[msg.sender] < _value) throw; // Check if the sender has enough\r\n        if ( (totalSupply - _value) <  ( initialSupply / 2 ) ) throw;\r\n        balanceOf[msg.sender] -= _value; // Subtract from the sender\r\n        totalSupply -= _value; // Updates totalSupply\r\n        Burn(msg.sender, _value);\r\n        return true;\r\n    }\r\n\r\n    function burnFrom(address _from, uint256 _value) returns(bool success) {\r\n        if (balanceOf[_from] < _value) throw; // Check if the sender has enough\r\n        if (_value > allowance[_from][msg.sender]) throw; // Check allowance\r\n       if ( (totalSupply - _value) <  ( initialSupply / 2 )) throw;\r\n        balanceOf[_from] -= _value; // Subtract from the sender\r\n        totalSupply -= _value; // Updates totalSupply\r\n        Burn(_from, _value);\r\n        return true;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require( msg.sender == owner );\r\n        _;\r\n    }\r\n\r\n   \r\n    \r\n    function freezeAccount ( address _account ) public onlyOwner{\r\n        \r\n        accountFreeze [ _account ] = true;\r\n        FrozenFunds ( _account , true );\r\n        \r\n        \r\n    }\r\n    \r\n    function unfreezeAccount ( address _account ) public onlyOwner{\r\n        \r\n         accountFreeze [ _account ] = false;\r\n         FrozenFunds ( _account , false );\r\n        \r\n        \r\n    }\r\n   \r\n\r\n    /* Approve and then communicate the approved contract in a single tx */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\r\n    returns(bool success) {\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns(uint256 remaining) {\r\n        return allowance[_owner][_spender];\r\n    }\r\n    \r\n  \r\n     \r\n    \r\n    \r\n    \r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"mediaTokensInitialSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_project\",\"type\":\"address\"}],\"name\":\"removeProject\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"studioLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"mediaTokensDecimalUnits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"mediaTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"mediaTokensSymbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mediaTokenIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_initialSupply\",\"type\":\"uint256\"},{\"name\":\"_decimalUnits\",\"type\":\"uint8\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"newMediaToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"accountIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getProjectCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"projectIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"slot\",\"type\":\"uint256\"}],\"name\":\"getProjectAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"mediaTokensName\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"standard\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getProjectStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"projectExists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"unfreezeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_project\",\"type\":\"address\"}],\"name\":\"addProject\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"projects\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"management\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mediaToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"accountFreeze\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"project_contract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAccountCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"slot\",\"type\":\"uint256\"}],\"name\":\"getAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"freezeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_management\",\"type\":\"address\"}],\"name\":\"assignManagement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_name\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"newMediaTokenCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"FrozenFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"mediatoken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"FrozenMediaTokenFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"ProjectCall\",\"type\":\"event\"}]","ContractName":"TheStudioToken","CompilerVersion":"v0.4.17+commit.bdeb9e52","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://5fe26fbb6e7d1eecb2b5452c1c81fd8b94d803b201c6381aa9002a053a34b9c0"}]}