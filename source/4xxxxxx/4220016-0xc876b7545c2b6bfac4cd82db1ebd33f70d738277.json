{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.15;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    require(newOwner != address(0));      \r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\ninterface OraclizeI {\r\n    // address public cbAddress;\r\n    function cbAddress() constant returns (address); // Reads public variable cbAddress\r\n    function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id);\r\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id);\r\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id);\r\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id);\r\n    function queryN(uint _timestamp, string _datasource, bytes _argN) payable returns (bytes32 _id);\r\n    function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) payable returns (bytes32 _id);\r\n    function getPrice(string _datasoaurce) returns (uint _dsprice);\r\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\r\n    function useCoupon(string _coupon);\r\n    function setProofType(byte _proofType);\r\n    function setConfig(bytes32 _config);\r\n    function setCustomGasPrice(uint _gasPrice);\r\n    function randomDS_getSessionPubKeyHash() returns(bytes32);\r\n}\r\n\r\ninterface OraclizeAddrResolverI {\r\n    function getAddress() returns (address _addr);\r\n}\r\n\r\n// this is a reduced and optimize version of the usingOraclize contract in https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.4.sol\r\ncontract myUsingOraclize is Ownable {\r\n    OraclizeAddrResolverI OAR;\r\n    OraclizeI public oraclize;\r\n    uint public oraclize_gaslimit = 120000;\r\n\r\n    function myUsingOraclize() {\r\n        oraclize_setNetwork();\r\n        update_oraclize();\r\n    }\r\n\r\n    function update_oraclize() onlyOwner public {\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n    }\r\n\r\n    function oraclize_query(string datasource, string arg1, string arg2) internal returns (bytes32 id) {\r\n        uint price = oraclize.getPrice(datasource, oraclize_gaslimit);\r\n        if (price > 1 ether + tx.gasprice*oraclize_gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, oraclize_gaslimit);\r\n    }\r\n\r\n    function oraclize_getPrice(string datasource) internal returns (uint) {\r\n        return oraclize.getPrice(datasource, oraclize_gaslimit);\r\n    }\r\n\r\n\r\n    function setGasLimit(uint _newLimit) onlyOwner public {\r\n        oraclize_gaslimit = _newLimit;\r\n    }\r\n\r\n    function oraclize_setNetwork() internal {\r\n        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){ //mainnet\r\n            OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\r\n        }\r\n        else if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){ //ropsten testnet\r\n            OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\r\n        }\r\n        else if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){ //kovan testnet\r\n            OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\r\n        }\r\n        else if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){ //rinkeby testnet\r\n            OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\r\n        }\r\n        else if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){ //ethereum-bridge\r\n            OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\r\n        }\r\n        else if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){ //ether.camp ide\r\n            OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\r\n        }\r\n        else if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){ //browser-solidity\r\n            OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\r\n        }\r\n        else {\r\n            revert();\r\n        }\r\n    }\r\n\r\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\r\n        assembly {\r\n            _size := extcodesize(_addr)\r\n        }\r\n        return _size;\r\n    }\r\n\r\n    // This will not throw error on wrong input, but instead consume large and unknown amount of gas\r\n    // This should never occure as it's use with the ShapeShift deposit return value is checked before calling function\r\n    function parseAddr(string _a) internal returns (address){\r\n        bytes memory tmp = bytes(_a);\r\n        uint160 iaddr = 0;\r\n        uint160 b1;\r\n        uint160 b2;\r\n        for (uint i=2; i<2+2*20; i+=2){\r\n            iaddr *= 256;\r\n            b1 = uint160(tmp[i]);\r\n            b2 = uint160(tmp[i+1]);\r\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\r\n            else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;\r\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\r\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\r\n            else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;\r\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\r\n            iaddr += (b1*16+b2);\r\n        }\r\n        return address(iaddr);\r\n    }\r\n}\r\n\r\n/**\r\n * @title InterCrypto\r\n * @dev The InterCrypto offers a no-commission service using Oraclize and ShapeShift\r\n * that allows for on-blockchain conversion from Ether to any other blockchain that ShapeShift supports.\r\n * @author Jack Tanner - <jnt16@ic.ac.uk>\r\n */\r\ncontract InterCrypto is Ownable, myUsingOraclize {\r\n    // _______________VARIABLES_______________\r\n    struct Conversion {\r\n        address returnAddress;\r\n        uint amount;\r\n    }\r\n\r\n    mapping (uint => Conversion) public conversions;\r\n    uint conversionCount = 0;\r\n    mapping (bytes32 => uint) oraclizeMyId2conversionID;\r\n    mapping (address => uint) public recoverable;\r\n\r\n    // _______________EVENTS_______________\r\n    event ConversionStarted(uint indexed conversionID);\r\n    event ConversionSentToShapeShift(uint indexed conversionID, address indexed returnAddress, address indexed depositAddress, uint amount);\r\n    event ConversionAborted(uint indexed conversionID, string reason);\r\n    event Recovered(address indexed recoveredTo, uint amount);\r\n\r\n    // _______________EXTERNAL FUNCTIONS_______________\r\n    /**\r\n     * Constructor.\r\n     */\r\n    function InterCrypto() {}\r\n\r\n    /**\r\n     * Destroys the contract and returns and Ether to the owner.\r\n     */\r\n    function kill() onlyOwner external {\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    /**\r\n     * Fallback function to allow contract to accept Ether.\r\n     */\r\n    function () payable {}\r\n\r\n    /**\r\n     * Sets up a ShapeShift cryptocurrency conversion using Oraclize and the ShapeShift API. Must be sent more Ether than the Oraclize price.\r\n     * Returns a conversionID which can be used for tracking of the conversion.\r\n     * @param _coinSymbol The coinsymbol of the other blockchain to be used by ShapeShift. See engine() function for more details.\r\n     * @param _toAddress The address on the other blockchain that the converted cryptocurrency will be sent to.\r\n     */\r\n    function convert1(string _coinSymbol, string _toAddress) external payable returns(uint) {\r\n        return engine(_coinSymbol, _toAddress, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * Sets up a ShapeShift cryptocurrency conversion using Oraclize and the ShapeShift API. Must be sent more Ether than the Oraclize price.\r\n     * Returns a conversionID which can be used for tracking of the conversion.\r\n     * @param _coinSymbol The coinsymbol of the other blockchain to be used by ShapeShift. See engine() function for more details.\r\n     * @param _toAddress The address on the other blockchain that the converted cryptocurrency will be sent to.\r\n     * @param _returnAddress The Ethereum address that any Ether should be sent back to in the event that the ShapeShift conversion is invalid or fails\r\n     */\r\n    function convert2(string _coinSymbol, string _toAddress, address _returnAddress) external payable returns(uint) {\r\n        return engine(_coinSymbol, _toAddress, _returnAddress);\r\n    }\r\n\r\n    /**\r\n     * Callback function for use exclusively by Oraclize.\r\n     * @param myid The Oraclize id of the query.\r\n     * @param result The result of the query.\r\n     */\r\n    function __callback(bytes32 myid, string result) {\r\n        if (msg.sender != oraclize.cbAddress()) revert();\r\n\r\n        uint conversionID = oraclizeMyId2conversionID[myid];\r\n\r\n        if( bytes(result).length == 0 ) {\r\n            ConversionAborted(conversionID, \"Oraclize return value was invalid, this is probably due to incorrect convert() argments\");\r\n            recoverable[conversions[conversionID].returnAddress] += conversions[conversionID].amount;\r\n            conversions[conversionID].amount = 0;\r\n        }\r\n        else {\r\n            address depositAddress = parseAddr(result);\r\n            require(depositAddress != msg.sender); // prevent DAO tpe re-entracy vulnerability that can potentially be done by Oraclize\r\n            uint sendAmount = conversions[conversionID].amount;\r\n            conversions[conversionID].amount = 0;\r\n            if (depositAddress.send(sendAmount)) {\r\n                ConversionSentToShapeShift(conversionID, conversions[conversionID].returnAddress, depositAddress, sendAmount);\r\n            }\r\n            else {\r\n                ConversionAborted(conversionID, \"deposit to address returned by Oraclize failed\");\r\n                recoverable[conversions[conversionID].returnAddress] += sendAmount;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Cancel a cryptocurrency conversion.\r\n     * This should only be required to be called if Oraclize fails make a return call to __callback().\r\n     * @param conversionID The conversion ID of the cryptocurrency conversion, generated during engine().\r\n     */\r\n     function cancelConversion(uint conversionID) external {\r\n        Conversion memory conversion = conversions[conversionID];\r\n\r\n        if (conversion.amount > 0) {\r\n            require(msg.sender == conversion.returnAddress);\r\n            recoverable[msg.sender] += conversion.amount;\r\n            conversions[conversionID].amount = 0;\r\n            ConversionAborted(conversionID, \"conversion cancelled by creator\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Recover any recoverable funds due to the failure of InterCrypto. Failure can occure due to:\r\n     * 1. Bad user inputs to convert().\r\n     * 2. ShapeShift temporarily or permanently discontinues support of other blockchain.\r\n     * 3. ShapeShift service becomes unavailable.\r\n     * 4. Oraclize service become unavailable.\r\n     */\r\n     function recover() external {\r\n        uint amount = recoverable[msg.sender];\r\n        recoverable[msg.sender] = 0;\r\n        if (msg.sender.send(amount)) {\r\n            Recovered(msg.sender, amount);\r\n        }\r\n        else {\r\n            recoverable[msg.sender] = amount;\r\n        }\r\n    }\r\n    // _______________PUBLIC FUNCTIONS_______________\r\n    /**\r\n     * Returns the price in Wei paid to Oraclize.\r\n     */\r\n    function getInterCryptoPrice() constant public returns (uint) {\r\n        return oraclize_getPrice('URL');\r\n    }\r\n\r\n    // _______________INTERNAL FUNCTIONS_______________\r\n    /**\r\n     * Sets up a ShapeShift cryptocurrency conversion using Oraclize and the ShapeShift API. Must be sent more Ether than the Oraclize price.\r\n     * Returns a conversionID which can be used for tracking of the conversion.\r\n     * @param _coinSymbol The coinsymbol of the other blockchain to be used by ShapeShift. See engine() function for more details.\r\n     * @param _toAddress The address on the other blockchain that the converted cryptocurrency will be sent to.\r\n     * Example first two arguments:\r\n     * \"ltc\", \"LbZcDdMeP96ko85H21TQii98YFF9RgZg3D\"    Litecoin\r\n     * \"btc\", \"1L8oRijgmkfcZDYA21b73b6DewLtyYs87s\"    Bitcoin\r\n     * \"dash\", \"Xoopows17idkTwNrMZuySXBwQDorsezQAx\"   Dash\r\n     * \"zec\", \"t1N7tf1xRxz5cBK51JADijLDWS592FPJtya\"   ZCash\r\n     * \"doge\", \"DMAFvwTH2upni7eTau8au6Rktgm2bUkMei\"   Dogecoin\r\n     * Test symbol pairs using ShapeShift API (shapeshift.io/validateAddress/[address]/[coinSymbol]) or by creating a test\r\n     * conversion on https://shapeshift.io first whenever possible before using it with InterCrypto.\r\n     * @param _returnAddress The Ethereum address that any Ether should be sent back to in the event that the ShapeShift conversion is invalid or fails.\r\n     */\r\n    function engine(string _coinSymbol, string _toAddress, address _returnAddress) internal returns(uint conversionID) {\r\n        conversionID = conversionCount++;\r\n\r\n        if (\r\n            !isValidString(_coinSymbol, 6) || // Waves smbol is \"waves\"\r\n            !isValidString(_toAddress, 120)   // Monero integrated addresses are 106 characters\r\n            ) {\r\n            ConversionAborted(conversionID, \"input parameters are too long or contain invalid symbols\");\r\n            recoverable[msg.sender] += msg.value;\r\n            return;\r\n        }\r\n\r\n        uint oraclizePrice = getInterCryptoPrice();\r\n\r\n        if (msg.value > oraclizePrice) {\r\n            Conversion memory conversion = Conversion(_returnAddress, msg.value-oraclizePrice);\r\n            conversions[conversionID] = Conversion(_returnAddress, msg.value-oraclizePrice);\r\n\r\n            string memory postData = createShapeShiftConversionPost(_coinSymbol, _toAddress);\r\n            bytes32 myQueryId = oraclize_query(\"URL\", \"json(https://shapeshift.io/shift).deposit\", postData);\r\n\r\n            if (myQueryId == 0) {\r\n                ConversionAborted(conversionID, \"unexpectedly high Oraclize price when calling oraclize_query\");\r\n                recoverable[msg.sender] += msg.value-oraclizePrice;\r\n                conversions[conversionID].amount = 0;\r\n                return;\r\n            }\r\n            oraclizeMyId2conversionID[myQueryId] = conversionID;\r\n            ConversionStarted(conversionID);\r\n        }\r\n        else {\r\n            ConversionAborted(conversionID, \"Not enough Ether sent to cover Oraclize fee\");\r\n            conversions[conversionID].amount = 0;\r\n            recoverable[msg.sender] += msg.value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns true if a given string contains only numbers and letters, and is below a maximum length.\r\n     * @param _string String to be checked.\r\n     * @param maxSize The maximum allowable sting character length. The address on the other blockchain that the converted cryptocurrency will be sent to.\r\n     */\r\n    function isValidString(string _string, uint maxSize) constant internal returns (bool allowed) {\r\n        bytes memory stringBytes = bytes(_string);\r\n        uint lengthBytes = stringBytes.length;\r\n        if (lengthBytes < 1 ||\r\n            lengthBytes > maxSize) {\r\n            return false;\r\n        }\r\n\r\n        for (uint i = 0; i < lengthBytes; i++) {\r\n            byte b = stringBytes[i];\r\n            if ( !(\r\n                (b >= 48 && b <= 57) || // 0 - 9\r\n                (b >= 65 && b <= 90) || // A - Z\r\n                (b >= 97 && b <= 122)   // a - z\r\n            )) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns a concatenation of seven bytes.\r\n     * @param b1 The first bytes to be concatenated.\r\n     * ...\r\n     * @param b7 The last bytes to be concatenated.\r\n     */\r\n    function concatBytes(bytes b1, bytes b2, bytes b3, bytes b4, bytes b5, bytes b6, bytes b7) internal returns (bytes bFinal) {\r\n        bFinal = new bytes(b1.length + b2.length + b3.length + b4.length + b5.length + b6.length + b7.length);\r\n\r\n        uint i = 0;\r\n        uint j;\r\n        for (j = 0; j < b1.length; j++) bFinal[i++] = b1[j];\r\n        for (j = 0; j < b2.length; j++) bFinal[i++] = b2[j];\r\n        for (j = 0; j < b3.length; j++) bFinal[i++] = b3[j];\r\n        for (j = 0; j < b4.length; j++) bFinal[i++] = b4[j];\r\n        for (j = 0; j < b5.length; j++) bFinal[i++] = b5[j];\r\n        for (j = 0; j < b6.length; j++) bFinal[i++] = b6[j];\r\n        for (j = 0; j < b7.length; j++) bFinal[i++] = b7[j];\r\n    }\r\n\r\n    /**\r\n     * Returns the ShapeShift shift API string that is needed to be sent to Oraclize.\r\n     * @param _coinSymbol The coinsymbol of the other blockchain to be used by ShapeShift. See engine() function for more details.\r\n     * @param _toAddress The address on the other blockchain that the converted cryptocurrency will be sent to.\r\n     * Example output:\r\n     * ' {\"withdrawal\":\"LbZcDdMeP96ko85H21TQii98YFF9RgZg3D\",\"pair\":\"eth_ltc\",\"returnAddress\":\"558999ff2e0daefcb4fcded4c89e07fdf9ccb56c\"}'\r\n     * Note that an extra space ' ' is needed at the start to tell Oraclize to make a POST query\r\n     */\r\n    function createShapeShiftConversionPost(string _coinSymbol, string _toAddress) internal returns (string sFinal) {\r\n        string memory s1 = ' {\"withdrawal\":\"';\r\n        string memory s3 = '\",\"pair\":\"eth_';\r\n        string memory s5 = '\",\"returnAddress\":\"';\r\n        string memory s7 = '\"}';\r\n\r\n        bytes memory bFinal = concatBytes(bytes(s1), bytes(_toAddress), bytes(s3), bytes(_coinSymbol), bytes(s5), bytes(addressToBytes(msg.sender)), bytes(s7));\r\n\r\n        sFinal = string(bFinal);\r\n    }\r\n\r\n    /**\r\n     * Returns the ASCII numeric or lower case character representation of a number.\r\n     * Authored by from https://github.com/axic\r\n     * @param nibble Nuber to be converted\r\n     */\r\n    function nibbleToChar(uint nibble) internal returns (uint ret) {\r\n        if (nibble > 9)\r\n        return nibble + 87; // nibble + 'a'- 10\r\n        else\r\n        return nibble + 48; // '0'\r\n    }\r\n\r\n    /**\r\n     * Returns the bytes representation of a provided Ethereum address\r\n     * Authored by from https://github.com/axic\r\n     * @param _address Ethereum address to be cast to bytes\r\n     */\r\n    function addressToBytes(address _address) internal returns (bytes) {\r\n        uint160 tmp = uint160(_address);\r\n\r\n        // 40 bytes of space, but actually uses 64 bytes\r\n        string memory holder = \"                                        \";\r\n        bytes memory ret = bytes(holder);\r\n\r\n        // NOTE: this is written in an expensive way, as out-of-order array access\r\n        //       is not supported yet, e.g. we cannot go in reverse easily\r\n        //       (or maybe it is a bug: https://github.com/ethereum/solidity/issues/212)\r\n        uint j = 0;\r\n        for (uint i = 0; i < 20; i++) {\r\n            uint _tmp = tmp / (2 ** (8*(19-i))); // shr(tmp, 8*(19-i))\r\n            uint nb1 = (_tmp / 0x10) & 0x0f;     // shr(tmp, 8) & 0x0f\r\n            uint nb2 = _tmp & 0x0f;\r\n            ret[j++] = byte(nibbleToChar(nb1));\r\n            ret[j++] = byte(nibbleToChar(nb2));\r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n    // _______________PRIVATE FUNCTIONS_______________\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_coinSymbol\",\"type\":\"string\"},{\"name\":\"_toAddress\",\"type\":\"string\"},{\"name\":\"_returnAddress\",\"type\":\"address\"}],\"name\":\"convert2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"conversions\",\"outputs\":[{\"name\":\"returnAddress\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"myid\",\"type\":\"bytes32\"},{\"name\":\"result\",\"type\":\"string\"}],\"name\":\"__callback\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_coinSymbol\",\"type\":\"string\"},{\"name\":\"_toAddress\",\"type\":\"string\"}],\"name\":\"convert1\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oraclize\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"update_oraclize\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"recoverable\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"conversionID\",\"type\":\"uint256\"}],\"name\":\"cancelConversion\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInterCryptoPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oraclize_gaslimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"recover\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setGasLimit\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"conversionID\",\"type\":\"uint256\"}],\"name\":\"ConversionStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"conversionID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"returnAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"depositAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ConversionSentToShapeShift\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"conversionID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"ConversionAborted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"recoveredTo\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Recovered\",\"type\":\"event\"}]","ContractName":"InterCrypto","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://3dff54c8aa29bbd27ca65787820ac07d55f718cecee0238e67aec19085f5a7d6"}]}