{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n// File: contracts/ReceivingContractCallback.sol\r\n\r\ncontract ReceivingContractCallback {\r\n\r\n  function tokenFallback(address _from, uint _value) public;\r\n\r\n}\r\n\r\n// File: contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/token/ERC20Basic.sol\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: contracts/token/BasicToken.sol\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/token/ERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/token/StandardToken.sol\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public view returns (uint256) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   */\r\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/LightcashCryptoToken.sol\r\n\r\ncontract LightcashCryptoToken is StandardToken, Ownable {\r\n\r\n  event Mint(address indexed to, uint256 amount);\r\n\r\n  event MintFinished();\r\n\r\n  string public constant name = 'Lightcash crypto';\r\n\r\n  string public constant symbol = 'LCSH';\r\n\r\n  uint32 public constant decimals = 18;\r\n\r\n  bool public mintingFinished = false;\r\n\r\n  address public saleAgent;\r\n\r\n  mapping(address => bool) public authorized;\r\n\r\n  mapping(address => bool)  public registeredCallbacks;\r\n\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    return processCallback(super.transfer(_to, _value), msg.sender, _to, _value);\r\n  }\r\n\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool) {\r\n    return processCallback(super.transferFrom(from, to, value), from, to, value);\r\n  }\r\n\r\n  function setSaleAgent(address newSaleAgent) public {\r\n    require(saleAgent == msg.sender || owner == msg.sender);\r\n    saleAgent = newSaleAgent;\r\n  }\r\n\r\n  function mint(address _to, uint256 _amount) public returns (bool) {\r\n    require(!mintingFinished);\r\n    require(msg.sender == saleAgent);\r\n    totalSupply = totalSupply.add(_amount);\r\n    balances[_to] = balances[_to].add(_amount);\r\n    Mint(address(0), _amount);\r\n    Transfer(address(0), _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  function finishMinting() public returns (bool) {\r\n    require(!mintingFinished);\r\n    require(msg.sender == owner || msg.sender == saleAgent);\r\n    mintingFinished = true;\r\n    MintFinished();\r\n    return true;\r\n  }\r\n\r\n  function registerCallback(address callback) public onlyOwner {\r\n    registeredCallbacks[callback] = true;\r\n  }\r\n\r\n  function deregisterCallback(address callback) public onlyOwner {\r\n    registeredCallbacks[callback] = false;\r\n  }\r\n\r\n  function processCallback(bool result, address from, address to, uint value) internal returns(bool) {\r\n    if (result && registeredCallbacks[to]) {\r\n      ReceivingContractCallback targetCallback = ReceivingContractCallback(to);\r\n      targetCallback.tokenFallback(from, value);\r\n    }\r\n    return result;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/CommonTokenEvent.sol\r\n\r\ncontract CommonTokenEvent is Ownable {\r\n\r\n  using SafeMath for uint;\r\n\r\n  uint public constant PERCENT_RATE = 100;\r\n\r\n  uint public price;\r\n\r\n  uint public start;\r\n\r\n  uint public period;\r\n\r\n  uint public minPurchaseLimit;\r\n\r\n  uint public minted;\r\n\r\n  uint public hardcap;\r\n\r\n  uint public invested;\r\n\r\n  uint public referrerPercent;\r\n\r\n  uint public maxReferrerTokens;\r\n\r\n  address public directMintAgent;\r\n\r\n  address public wallet;\r\n\r\n  LightcashCryptoToken public token;\r\n\r\n  modifier canMint() {\r\n    require(now >= start && now < lastSaleDate() && msg.value >= minPurchaseLimit && minted < hardcap);\r\n    _;\r\n  }\r\n\r\n  modifier onlyDirectMintAgentOrOwner() {\r\n    require(directMintAgent == msg.sender || owner == msg.sender);\r\n    _;\r\n  }\r\n\r\n  function sendReferrerTokens(uint tokens) internal {\r\n    if (msg.data.length == 20) {\r\n      address referrer = bytesToAddres(bytes(msg.data));\r\n      require(referrer != address(token) && referrer != msg.sender);\r\n      uint referrerTokens = tokens.mul(referrerPercent).div(PERCENT_RATE);\r\n      if(referrerTokens > maxReferrerTokens) {\r\n        referrerTokens = maxReferrerTokens;\r\n      }\r\n      mintAndSendTokens(referrer, referrerTokens);\r\n    }\r\n  }\r\n\r\n  function bytesToAddres(bytes source) internal pure returns(address) {\r\n    uint result;\r\n    uint mul = 1;\r\n    for (uint i = 20; i > 0; i--) {\r\n      result += uint8(source[i-1])*mul;\r\n      mul = mul*256;\r\n    }\r\n    return address(result);\r\n  }\r\n\r\n  function setMaxReferrerTokens(uint newMaxReferrerTokens) public onlyOwner {\r\n    maxReferrerTokens = newMaxReferrerTokens;\r\n  }\r\n\r\n  function setHardcap(uint newHardcap) public onlyOwner {\r\n    hardcap = newHardcap;\r\n  }\r\n\r\n  function setToken(address newToken) public onlyOwner {\r\n    token = LightcashCryptoToken(newToken);\r\n  }\r\n\r\n  function setReferrerPercent(uint newReferrerPercent) public onlyOwner {\r\n    referrerPercent = newReferrerPercent;\r\n  }\r\n\r\n  function setStart(uint newStart) public onlyOwner {\r\n    start = newStart;\r\n  }\r\n\r\n  function setPrice(uint newPrice) public onlyOwner {\r\n    price = newPrice;\r\n  }\r\n\r\n  function lastSaleDate() public view returns(uint) {\r\n    return start + period * 1 days;\r\n  }\r\n\r\n  function setMinPurchaseLimit(uint newMinPurchaseLimit) public onlyOwner {\r\n    minPurchaseLimit = newMinPurchaseLimit;\r\n  }\r\n\r\n  function setWallet(address newWallet) public onlyOwner {\r\n    wallet = newWallet;\r\n  }\r\n\r\n  function setDirectMintAgent(address newDirectMintAgent) public onlyOwner {\r\n    directMintAgent = newDirectMintAgent;\r\n  }\r\n\r\n  function directMint(address to, uint investedWei) public onlyDirectMintAgentOrOwner {\r\n    calculateAndTransferTokens(to, investedWei);\r\n  }\r\n\r\n  function directMintTokens(address to, uint count) public onlyDirectMintAgentOrOwner {\r\n    mintAndSendTokens(to, count);\r\n  }\r\n\r\n  function mintAndSendTokens(address to, uint amount) internal {\r\n    token.mint(to, amount);\r\n    minted = minted.add(amount);\r\n  }\r\n\r\n  function calculateAndTransferTokens(address to, uint investedInWei) internal returns(uint) {\r\n    uint tokens = calculateTokens(investedInWei);\r\n    mintAndSendTokens(to, tokens);\r\n    invested = invested.add(investedInWei);\r\n    return tokens;\r\n  }\r\n\r\n  function calculateAndTransferTokensWithReferrer(address to, uint investedInWei) internal {\r\n    uint tokens = calculateAndTransferTokens(to, investedInWei);\r\n    sendReferrerTokens(tokens);\r\n  }\r\n\r\n  function calculateTokens(uint investedInWei) public view returns(uint);\r\n\r\n  function createTokens() public payable;\r\n\r\n  function() external payable {\r\n    createTokens();\r\n  }\r\n\r\n  function retrieveTokens(address to, address anotherToken) public onlyOwner {\r\n    ERC20 alienToken = ERC20(anotherToken);\r\n    alienToken.transfer(to, alienToken.balanceOf(this));\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/PreTGE.sol\r\n\r\ncontract PreTGE is CommonTokenEvent {\r\n\r\n  uint public softcap;\r\n\r\n  bool public refundOn;\r\n\r\n  bool public softcapAchieved;\r\n\r\n  address public nextSaleAgent;\r\n\r\n  mapping (address => uint) public balances;\r\n\r\n  event RefundsEnabled();\r\n\r\n  event SoftcapReached();\r\n\r\n  event Refunded(address indexed beneficiary, uint256 weiAmount);\r\n\r\n  function setPeriod(uint newPeriod) public onlyOwner {\r\n    period = newPeriod;\r\n  }\r\n\r\n  function calculateTokens(uint investedInWei) public view returns(uint) {\r\n    return investedInWei.mul(price).div(1 ether);\r\n  }\r\n\r\n  function setNextSaleAgent(address newNextSaleAgent) public onlyOwner {\r\n    nextSaleAgent = newNextSaleAgent;\r\n  }\r\n\r\n  function setSoftcap(uint newSoftcap) public onlyOwner {\r\n    softcap = newSoftcap;\r\n  }\r\n\r\n  function refund() public {\r\n    require(now > start && refundOn && balances[msg.sender] > 0);\r\n    uint value = balances[msg.sender];\r\n    balances[msg.sender] = 0;\r\n    msg.sender.transfer(value);\r\n    Refunded(msg.sender, value);\r\n  }\r\n\r\n  function widthraw() public {\r\n    require(softcapAchieved);\r\n    wallet.transfer(this.balance);\r\n  }\r\n\r\n  function createTokens() public payable canMint {\r\n    balances[msg.sender] = balances[msg.sender].add(msg.value);\r\n    super.calculateAndTransferTokensWithReferrer(msg.sender, msg.value);\r\n    if (!softcapAchieved && minted >= softcap) {\r\n      softcapAchieved = true;\r\n      SoftcapReached();\r\n    }\r\n  }\r\n\r\n  function finish() public onlyOwner {\r\n    if (!softcapAchieved) {\r\n      refundOn = true;\r\n      RefundsEnabled();\r\n    } else {\r\n      widthraw();\r\n      token.setSaleAgent(nextSaleAgent);\r\n    }\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/StagedTokenEvent.sol\r\n\r\ncontract StagedTokenEvent is CommonTokenEvent {\r\n\r\n  using SafeMath for uint;\r\n\r\n  struct Stage {\r\n    uint period;\r\n    uint discount;\r\n  }\r\n\r\n  uint public constant STAGES_PERCENT_RATE = 100;\r\n\r\n  Stage[] public stages;\r\n\r\n  function stagesCount() public constant returns(uint) {\r\n    return stages.length;\r\n  }\r\n\r\n  function addStage(uint stagePeriod, uint discount) public onlyOwner {\r\n    require(stagePeriod > 0);\r\n    stages.push(Stage(stagePeriod, discount));\r\n    period = period.add(stagePeriod);\r\n  }\r\n\r\n  function removeStage(uint8 number) public onlyOwner {\r\n    require(number >= 0 && number < stages.length);\r\n\r\n    Stage storage stage = stages[number];\r\n    period = period.sub(stage.period);\r\n\r\n    delete stages[number];\r\n\r\n    for (uint i = number; i < stages.length - 1; i++) {\r\n      stages[i] = stages[i+1];\r\n    }\r\n\r\n    stages.length--;\r\n  }\r\n\r\n  function changeStage(uint8 number, uint stagePeriod, uint discount) public onlyOwner {\r\n    require(number >= 0 && number < stages.length);\r\n\r\n    Stage storage stage = stages[number];\r\n\r\n    period = period.sub(stage.period);\r\n\r\n    stage.period = stagePeriod;\r\n    stage.discount = discount;\r\n\r\n    period = period.add(stagePeriod);\r\n  }\r\n\r\n  function insertStage(uint8 numberAfter, uint stagePeriod, uint discount) public onlyOwner {\r\n    require(numberAfter < stages.length);\r\n\r\n\r\n    period = period.add(stagePeriod);\r\n\r\n    stages.length++;\r\n\r\n    for (uint i = stages.length - 2; i > numberAfter; i--) {\r\n      stages[i + 1] = stages[i];\r\n    }\r\n\r\n    stages[numberAfter + 1] = Stage(period, discount);\r\n  }\r\n\r\n  function clearStages() public onlyOwner {\r\n    for (uint i = 0; i < stages.length; i++) {\r\n      delete stages[i];\r\n    }\r\n    stages.length -= stages.length;\r\n    period = 0;\r\n  }\r\n\r\n  function getDiscount() public constant returns(uint) {\r\n    uint prevTimeLimit = start;\r\n    for (uint i = 0; i < stages.length; i++) {\r\n      Stage storage stage = stages[i];\r\n      prevTimeLimit += stage.period * 1 days;\r\n      if (now < prevTimeLimit)\r\n        return stage.discount;\r\n    }\r\n    revert();\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/TGE.sol\r\n\r\ncontract TGE is StagedTokenEvent {\r\n\r\n  address public extraTokensWallet;\r\n\r\n  uint public extraTokensPercent;\r\n\r\n  bool public finished = false;\r\n\r\n  function setExtraTokensWallet(address newExtraTokensWallet) public onlyOwner {\r\n    extraTokensWallet = newExtraTokensWallet;\r\n  }\r\n\r\n  function setExtraTokensPercent(uint newExtraTokensPercent) public onlyOwner {\r\n    extraTokensPercent = newExtraTokensPercent;\r\n  }\r\n\r\n  function calculateTokens(uint investedInWei) public view returns(uint) {\r\n    return investedInWei.mul(price).mul(STAGES_PERCENT_RATE).div(STAGES_PERCENT_RATE.sub(getDiscount())).div(1 ether);\r\n  }\r\n\r\n  function finish() public onlyOwner {\r\n    require(!finished);\r\n    finished = true;\r\n    uint256 totalSupply = token.totalSupply();\r\n    uint allTokens = totalSupply.mul(PERCENT_RATE).div(PERCENT_RATE.sub(extraTokensPercent));\r\n    uint extraTokens = allTokens.mul(extraTokensPercent).div(PERCENT_RATE);\r\n    mintAndSendTokens(extraTokensWallet, extraTokens);\r\n  }\r\n\r\n  function createTokens() public payable canMint {\r\n    require(!finished);\r\n    wallet.transfer(msg.value);\r\n    calculateAndTransferTokensWithReferrer(msg.sender, msg.value);\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/Deployer.sol\r\n\r\ncontract Deployer is Ownable {\r\n\r\n  LightcashCryptoToken public token;\r\n\r\n  PreTGE public preTGE;\r\n\r\n  TGE public tge;\r\n\r\n  function deploy() public onlyOwner {\r\n    token = new LightcashCryptoToken();\r\n\r\n    preTGE = new PreTGE();\r\n    preTGE.setPrice(7143000000000000000000);\r\n    preTGE.setMinPurchaseLimit(100000000000000000);\r\n    preTGE.setSoftcap(7142857000000000000000000);\r\n    preTGE.setHardcap(52500000000000000000000000);\r\n    preTGE.setStart(1517230800);\r\n    preTGE.setPeriod(11);\r\n    preTGE.setWallet(0xDFDCAc0c9Eb45C63Bcff91220A48684882F1DAd0);\r\n    preTGE.setMaxReferrerTokens(10000000000000000000000);\r\n    preTGE.setReferrerPercent(10);\r\n\r\n    tge = new TGE();\r\n    tge.setPrice(5000000000000000000000);\r\n    tge.setMinPurchaseLimit(10000000000000000);\r\n    tge.setHardcap(126000000000000000000000000);\r\n    tge.setStart(1517835600);\r\n    tge.setWallet(0x3aC45b49A4D3CB35022fd8122Fd865cd1B47932f);\r\n    tge.setExtraTokensWallet(0xF0e830148F3d1C4656770DAa282Fda6FAAA0Fe0B);\r\n    tge.setExtraTokensPercent(15);\r\n    tge.addStage(7, 20);\r\n    tge.addStage(7, 15);\r\n    tge.addStage(7, 10);\r\n    tge.addStage(1000, 5);\r\n    tge.setMaxReferrerTokens(10000000000000000000000);\r\n    tge.setReferrerPercent(10);\r\n\r\n    preTGE.setToken(token);\r\n    tge.setToken(token);\r\n    preTGE.setNextSaleAgent(tge);\r\n    token.setSaleAgent(preTGE);\r\n\r\n    address newOnwer = 0xF51E0a3a17990D41C5f1Ff1d0D772b26E4D6B6d0;\r\n    token.transferOwnership(newOnwer);\r\n    preTGE.transferOwnership(newOnwer);\r\n    tge.transferOwnership(newOnwer);\r\n  }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"newPeriod\",\"type\":\"uint256\"}],\"name\":\"setPeriod\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newSoftcap\",\"type\":\"uint256\"}],\"name\":\"setSoftcap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newToken\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"directMintTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastSaleDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxReferrerTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PERCENT_RATE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"investedWei\",\"type\":\"uint256\"}],\"name\":\"directMint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minPurchaseLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minted\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"refundOn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"anotherToken\",\"type\":\"address\"}],\"name\":\"retrieveTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"referrerPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"directMintAgent\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investedInWei\",\"type\":\"uint256\"}],\"name\":\"calculateTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newDirectMintAgent\",\"type\":\"address\"}],\"name\":\"setDirectMintAgent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"softcapAchieved\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMaxReferrerTokens\",\"type\":\"uint256\"}],\"name\":\"setMaxReferrerTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"widthraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardcap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"createTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMinPurchaseLimit\",\"type\":\"uint256\"}],\"name\":\"setMinPurchaseLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"start\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"invested\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finish\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newReferrerPercent\",\"type\":\"uint256\"}],\"name\":\"setReferrerPercent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextSaleAgent\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"setWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newHardcap\",\"type\":\"uint256\"}],\"name\":\"setHardcap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newNextSaleAgent\",\"type\":\"address\"}],\"name\":\"setNextSaleAgent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"period\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newStart\",\"type\":\"uint256\"}],\"name\":\"setStart\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"softcap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"RefundsEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"SoftcapReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"Refunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"PreTGE","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://c7fe42854ff78191ead4aa74938006d87a891a8360371afecfd6db9210705480"}]}