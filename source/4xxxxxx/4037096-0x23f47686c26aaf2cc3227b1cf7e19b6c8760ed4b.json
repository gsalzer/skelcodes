{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n/**\r\n * @title ETHCON Early Bird Donation Contract\r\n * @author majoolr.io\r\n *\r\n * Accepts donations and issues ETHCON token if at or above 3.9604 ETH.\r\n * See ETHCON.org for further information.\r\n * ETHCONEarlyBirdToken contract at 0x2d9498d0fd6f40760d53a847eb64eaf51c9b8e74\r\n */\r\n\r\ncontract ETHCONEarlyBirdDonation {\r\n  address majoolr;\r\n  ETHCONEarlyBirdToken token;\r\n\r\n  uint256 public donations;\r\n  mapping (address => uint256) public donationMap;\r\n  mapping (address => uint256) public failedDonations;\r\n  uint256 public minimum = 3960400000000000000;\r\n\r\n  event ErrMsg(address indexed _from, string _msg);\r\n  event ThxMsg(address indexed _from, string _msg);\r\n\r\n  modifier andIsMajoolr {\r\n    require(msg.sender == majoolr);\r\n    _;\r\n  }\r\n\r\n  function(){ ErrMsg(msg.sender, 'No function called'); }\r\n\r\n  function ETHCONEarlyBirdDonation(address _token){\r\n    token = ETHCONEarlyBirdToken(_token);\r\n    majoolr = msg.sender;\r\n  }\r\n\r\n  function donate() payable returns (bool){\r\n    uint256 totalDonation = donationMap[msg.sender] + msg.value;\r\n    if(totalDonation < minimum){\r\n      failedDonations[msg.sender] += msg.value;\r\n      ErrMsg(msg.sender, \"Donation too low, call withdrawDonation()\");\r\n      return false;\r\n    }\r\n\r\n    bool success = token.transferFrom(majoolr,msg.sender,1);\r\n    if(!success){\r\n      failedDonations[msg.sender] += msg.value;\r\n      ErrMsg(msg.sender, \"Transer failed, call withdrawDonation()\");\r\n      return false;\r\n    }\r\n\r\n    donationMap[msg.sender] += msg.value;\r\n    donations += msg.value;\r\n    ThxMsg(msg.sender, \"Thank you for your donation!\");\r\n    return true;\r\n  }\r\n\r\n  function generousDonation() payable returns (bool){\r\n    uint256 tokensLeft = token.allowance(majoolr, this);\r\n    if(tokensLeft == 0){\r\n      failedDonations[msg.sender] += msg.value;\r\n      ErrMsg(msg.sender, \"No more donations here check Majoolr.io, call withdrawDonation()\");\r\n      return false;\r\n    }\r\n\r\n    donationMap[msg.sender] += msg.value;\r\n    donations += msg.value;\r\n    ThxMsg(msg.sender, \"Thank you for your donation!\");\r\n    return true;\r\n  }\r\n\r\n  function withdraw() andIsMajoolr {\r\n    uint256 amount = donations;\r\n    donations = 0;\r\n    msg.sender.transfer(amount);\r\n  }\r\n\r\n  function withdrawDonation(){\r\n    uint256 amount = failedDonations[msg.sender];\r\n    failedDonations[msg.sender] = 0;\r\n    msg.sender.transfer(amount);\r\n  }\r\n}\r\n\r\ncontract ETHCONEarlyBirdToken {\r\n   using ERC20Lib for ERC20Lib.TokenStorage;\r\n\r\n   ERC20Lib.TokenStorage token;\r\n\r\n   string public name = \"ETHCON-Early-Bird\";\r\n   string public symbol = \"THX\";\r\n   uint public decimals = 0;\r\n   uint public INITIAL_SUPPLY = 600;\r\n\r\n   event ErrorMsg(string msg);\r\n\r\n   function ETHCONEarlyBirdToken() {\r\n     token.init(INITIAL_SUPPLY);\r\n   }\r\n\r\n   function totalSupply() constant returns (uint) {\r\n     return token.totalSupply;\r\n   }\r\n\r\n   function balanceOf(address who) constant returns (uint) {\r\n     return token.balanceOf(who);\r\n   }\r\n\r\n   function allowance(address owner, address spender) constant returns (uint) {\r\n     return token.allowance(owner, spender);\r\n   }\r\n\r\n   function transfer(address to, uint value) returns (bool ok) {\r\n     if(token.balanceOf(to) == 0){\r\n       return token.transfer(to, value);\r\n     } else {\r\n       ErrorMsg(\"Recipient already has token\");\r\n       return false;\r\n     }\r\n\r\n   }\r\n\r\n   function transferFrom(address from, address to, uint value) returns (bool ok) {\r\n     if(token.balanceOf(to) == 0){\r\n       return token.transferFrom(from, to, value);\r\n     } else {\r\n       ErrorMsg(\"Recipient already has token\");\r\n       return false;\r\n     }\r\n   }\r\n\r\n   function approve(address spender, uint value) returns (bool ok) {\r\n     return token.approve(spender, value);\r\n   }\r\n\r\n   event Transfer(address indexed from, address indexed to, uint value);\r\n   event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\nlibrary ERC20Lib {\r\n  using BasicMathLib for uint256;\r\n\r\n  struct TokenStorage {\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint totalSupply;\r\n  }\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n  event ErrorMsg(string msg);\r\n\r\n  /// @dev Called by the Standard Token upon creation.\r\n  /// @param self Stored token from token contract\r\n  /// @param _initial_supply The initial token supply\r\n  function init(TokenStorage storage self, uint256 _initial_supply) {\r\n    self.totalSupply = _initial_supply;\r\n    self.balances[msg.sender] = _initial_supply;\r\n  }\r\n\r\n  /// @dev Transfer tokens from caller's account to another account.\r\n  /// @param self Stored token from token contract\r\n  /// @param _to Address to send tokens\r\n  /// @param _value Number of tokens to send\r\n  /// @return success True if completed, false otherwise\r\n  function transfer(TokenStorage storage self, address _to, uint256 _value) returns (bool success) {\r\n    bool err;\r\n    uint256 balance;\r\n\r\n    (err,balance) = self.balances[msg.sender].minus(_value);\r\n    if(err) {\r\n      ErrorMsg(\"Balance too low for transfer\");\r\n      return false;\r\n    }\r\n    self.balances[msg.sender] = balance;\r\n    //It's not possible to overflow token supply\r\n    self.balances[_to] = self.balances[_to] + _value;\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /// @dev Authorized caller transfers tokens from one account to another\r\n  /// @param self Stored token from token contract\r\n  /// @param _from Address to send tokens from\r\n  /// @param _to Address to send tokens to\r\n  /// @param _value Number of tokens to send\r\n  /// @return success True if completed, false otherwise\r\n  function transferFrom(TokenStorage storage self,\r\n                        address _from,\r\n                        address _to,\r\n                        uint256 _value)\r\n                        returns (bool success) {\r\n    var _allowance = self.allowed[_from][msg.sender];\r\n    bool err;\r\n    uint256 balanceOwner;\r\n    uint256 balanceSpender;\r\n\r\n    (err,balanceOwner) = self.balances[_from].minus(_value);\r\n    if(err) {\r\n      ErrorMsg(\"Balance too low for transfer\");\r\n      return false;\r\n    }\r\n\r\n    (err,balanceSpender) = _allowance.minus(_value);\r\n    if(err) {\r\n      ErrorMsg(\"Transfer exceeds allowance\");\r\n      return false;\r\n    }\r\n    self.balances[_from] = balanceOwner;\r\n    self.allowed[_from][msg.sender] = balanceSpender;\r\n    self.balances[_to] = self.balances[_to] + _value;\r\n\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /// @dev Retrieve token balance for an account\r\n  /// @param self Stored token from token contract\r\n  /// @param _owner Address to retrieve balance of\r\n  /// @return balance The number of tokens in the subject account\r\n  function balanceOf(TokenStorage storage self, address _owner) constant returns (uint256 balance) {\r\n    return self.balances[_owner];\r\n  }\r\n\r\n  /// @dev Authorize an account to send tokens on caller's behalf\r\n  /// @param self Stored token from token contract\r\n  /// @param _spender Address to authorize\r\n  /// @param _value Number of tokens authorized account may send\r\n  /// @return success True if completed, false otherwise\r\n  function approve(TokenStorage storage self, address _spender, uint256 _value) returns (bool success) {\r\n    self.allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /// @dev Remaining tokens third party spender has to send\r\n  /// @param self Stored token from token contract\r\n  /// @param _owner Address of token holder\r\n  /// @param _spender Address of authorized spender\r\n  /// @return remaining Number of tokens spender has left in owner's account\r\n  function allowance(TokenStorage storage self, address _owner, address _spender) constant returns (uint256 remaining) {\r\n    return self.allowed[_owner][_spender];\r\n  }\r\n}\r\n\r\nlibrary BasicMathLib {\r\n  event Err(string typeErr);\r\n\r\n  /// @dev Multiplies two numbers and checks for overflow before returning.\r\n  /// Does not throw but rather logs an Err event if there is overflow.\r\n  /// @param a First number\r\n  /// @param b Second number\r\n  /// @return err False normally, or true if there is overflow\r\n  /// @return res The product of a and b, or 0 if there is overflow\r\n  function times(uint256 a, uint256 b) constant returns (bool err,uint256 res) {\r\n    assembly{\r\n      res := mul(a,b)\r\n      jumpi(allGood, or(iszero(b), eq(div(res,b), a)))\r\n      err := 1\r\n      res := 0\r\n      allGood:\r\n    }\r\n    if (err)\r\n      Err(\"times func overflow\");\r\n  }\r\n\r\n  /// @dev Divides two numbers but checks for 0 in the divisor first.\r\n  /// Does not throw but rather logs an Err event if 0 is in the divisor.\r\n  /// @param a First number\r\n  /// @param b Second number\r\n  /// @return err False normally, or true if `b` is 0\r\n  /// @return res The quotient of a and b, or 0 if `b` is 0\r\n  function dividedBy(uint256 a, uint256 b) constant returns (bool err,uint256 res) {\r\n    assembly{\r\n      jumpi(e, iszero(b))\r\n      res := div(a,b)\r\n      mstore(add(mload(0x40),0x20),res)\r\n      return(mload(0x40),0x40)\r\n      e:\r\n    }\r\n    Err(\"tried to divide by zero\");\r\n    return (true, 0);\r\n  }\r\n\r\n  /// @dev Adds two numbers and checks for overflow before returning.\r\n  /// Does not throw but rather logs an Err event if there is overflow.\r\n  /// @param a First number\r\n  /// @param b Second number\r\n  /// @return err False normally, or true if there is overflow\r\n  /// @return res The sum of a and b, or 0 if there is overflow\r\n  function plus(uint256 a, uint256 b) constant returns (bool err, uint256 res) {\r\n    assembly{\r\n      res := add(a,b)\r\n      jumpi(allGood, and(eq(sub(res,b), a), gt(res,b)))\r\n      err := 1\r\n      res := 0\r\n      allGood:\r\n    }\r\n    if (err)\r\n      Err(\"plus func overflow\");\r\n  }\r\n\r\n  /// @dev Subtracts two numbers and checks for underflow before returning.\r\n  /// Does not throw but rather logs an Err event if there is underflow.\r\n  /// @param a First number\r\n  /// @param b Second number\r\n  /// @return err False normally, or true if there is underflow\r\n  /// @return res The difference between a and b, or 0 if there is underflow\r\n  function minus(uint256 a, uint256 b) constant returns (bool err,uint256 res) {\r\n    assembly{\r\n      res := sub(a,b)\r\n      jumpi(allGood, eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1))\r\n      err := 1\r\n      res := 0\r\n      allGood:\r\n    }\r\n    if (err)\r\n      Err(\"minus func underflow\");\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"failedDonations\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"generousDonation\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"donationMap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawDonation\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"donations\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"donate\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":false,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_msg\",\"type\":\"string\"}],\"name\":\"ErrMsg\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_msg\",\"type\":\"string\"}],\"name\":\"ThxMsg\",\"type\":\"event\"}]","ContractName":"ETHCONEarlyBirdDonation","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"1","Runs":"0","ConstructorArguments":"0000000000000000000000002d9498d0fd6f40760d53a847eb64eaf51c9b8e74","Library":"","SwarmSource":"bzzr://a00fd8f9bac167578200b6a762dfb11d275cb4c56a47150afc5faabd2e381d61"}]}