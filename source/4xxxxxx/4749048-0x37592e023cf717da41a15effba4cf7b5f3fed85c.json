{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract ReentrancyGuard {\r\n\r\n  /**\r\n   * @dev We use a single lock for the whole contract.\r\n   */\r\n  bool private rentrancy_lock = false;\r\n\r\n  /**\r\n   * @dev Prevents a contract from calling itself, directly or indirectly.\r\n   * @notice If you mark a function `nonReentrant`, you should also\r\n   * mark it `external`. Calling one nonReentrant function from\r\n   * another is not supported. Instead, you can implement a\r\n   * `private` function doing the actual work, and a `external`\r\n   * wrapper marked as `nonReentrant`.\r\n   */\r\n  modifier nonReentrant() {\r\n    require(!rentrancy_lock);\r\n    rentrancy_lock = true;\r\n    _;\r\n    rentrancy_lock = false;\r\n  }\r\n\r\n}\r\n\r\ncontract ArgumentsChecker {\r\n\r\n    /// @dev check which prevents short address attack\r\n    modifier payloadSizeIs(uint size) {\r\n       require(msg.data.length == size + 4 /* function selector */);\r\n       _;\r\n    }\r\n\r\n    /// @dev check that address is valid\r\n    modifier validAddress(address addr) {\r\n        require(addr != address(0));\r\n        _;\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\ncontract LightFundsRegistry is ArgumentsChecker, Ownable, ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n\r\n    enum State {\r\n        // gathering funds\r\n        GATHERING,\r\n        // returning funds to investors\r\n        REFUNDING,\r\n        // funds sent to owners\r\n        SUCCEEDED\r\n    }\r\n\r\n    event StateChanged(State _state);\r\n    event Invested(address indexed investor, uint256 amount);\r\n    event EtherSent(address indexed to, uint value);\r\n    event RefundSent(address indexed to, uint value);\r\n\r\n\r\n    modifier requiresState(State _state) {\r\n        require(m_state == _state);\r\n        _;\r\n    }\r\n\r\n\r\n    // PUBLIC interface\r\n\r\n    function LightFundsRegistry(address owner80, address owner20)\r\n        public\r\n        validAddress(owner80)\r\n        validAddress(owner20)\r\n    {\r\n        m_owner80 = owner80;\r\n        m_owner20 = owner20;\r\n    }\r\n\r\n    /// @dev performs only allowed state transitions\r\n    function changeState(State _newState)\r\n        external\r\n        onlyOwner\r\n    {\r\n        assert(m_state != _newState);\r\n\r\n        if (State.GATHERING == m_state) {   assert(State.REFUNDING == _newState || State.SUCCEEDED == _newState); }\r\n        else assert(false);\r\n\r\n        m_state = _newState;\r\n        StateChanged(m_state);\r\n\r\n        if (State.SUCCEEDED == _newState) {\r\n            uint _80percent = this.balance.mul(80).div(100);\r\n            m_owner80.transfer(_80percent);\r\n            EtherSent(m_owner80, _80percent);\r\n\r\n            uint _20percent = this.balance;\r\n            m_owner20.transfer(_20percent);\r\n            EtherSent(m_owner20, _20percent);\r\n        }\r\n    }\r\n\r\n    /// @dev records an investment\r\n    function invested(address _investor)\r\n        external\r\n        payable\r\n        onlyOwner\r\n        requiresState(State.GATHERING)\r\n    {\r\n        uint256 amount = msg.value;\r\n        require(0 != amount);\r\n\r\n        // register investor\r\n        if (0 == m_weiBalances[_investor])\r\n            m_investors.push(_investor);\r\n\r\n        // register payment\r\n        totalInvested = totalInvested.add(amount);\r\n        m_weiBalances[_investor] = m_weiBalances[_investor].add(amount);\r\n\r\n        Invested(_investor, amount);\r\n    }\r\n\r\n    /// @notice withdraw accumulated balance, called by payee in case crowdsale has failed\r\n    function withdrawPayments(address payee)\r\n        external\r\n        nonReentrant\r\n        onlyOwner\r\n        requiresState(State.REFUNDING)\r\n    {\r\n        uint256 payment = m_weiBalances[payee];\r\n\r\n        require(payment != 0);\r\n        require(this.balance >= payment);\r\n\r\n        totalInvested = totalInvested.sub(payment);\r\n        m_weiBalances[payee] = 0;\r\n\r\n        payee.transfer(payment);\r\n        RefundSent(payee, payment);\r\n    }\r\n\r\n    function getInvestorsCount() external view returns (uint) { return m_investors.length; }\r\n\r\n\r\n    // FIELDS\r\n\r\n    /// @notice total amount of investments in wei\r\n    uint256 public totalInvested;\r\n\r\n    /// @notice state of the registry\r\n    State public m_state = State.GATHERING;\r\n\r\n    /// @dev balances of investors in wei\r\n    mapping(address => uint256) public m_weiBalances;\r\n\r\n    /// @dev list of unique investors\r\n    address[] public m_investors;\r\n\r\n    address public m_owner80;\r\n    address public m_owner20;\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"m_owner80\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newState\",\"type\":\"uint8\"}],\"name\":\"changeState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"payee\",\"type\":\"address\"}],\"name\":\"withdrawPayments\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"m_weiBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalInvested\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"invested\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_state\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_owner20\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"m_investors\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInvestorsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"owner80\",\"type\":\"address\"},{\"name\":\"owner20\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_state\",\"type\":\"uint8\"}],\"name\":\"StateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Invested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"EtherSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"RefundSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"LightFundsRegistry","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000d9ab6c63ae5dc8b4d766352b9f666f6e02dba26e000000000000000000000000a46e5704057f9432d10919196c3c671cfafa2030","Library":"","SwarmSource":"bzzr://3d52d975e3dada9e8d4d46497748cbcd737ec3de44f8273a8ce5a4d7e3042ee3"}]}