{"status":"1","message":"OK","result":[{"SourceCode":"/*******************************************************************************\r\n*********************    BATTLE OF THERMOPYLAE v1.1  ***************************\r\n********************************************************************************\r\n\r\nBattle smart contract is a platform/ecosystem for gaming built on top of a\r\ndecentralized smart contract, allowing anyone to use a Warrior tokens: entities\r\nwhich exists on the Ethereum Network, which can be traded or used to enter the\r\nbattle with other Warrior tokens holders, for profit or just for fun!\r\n\r\n********************************************************************************\r\n**************************           RULES           ***************************\r\n********************************************************************************\r\n\r\n- This first battle contract accepts Persians, Spartans (300 Tokens), Immortals\r\n  and Athenians as warriors.\r\n- Every warrior token has a proper value in **Battle Point (BP)** that represent\r\n  his strength on the battle contract.\r\n- Persians and Immortals represent the Persian faction, Spartans and Athenians\r\n  the Greek one.\r\n- During the first phase players send tokens to the battle contract\r\n  (NOTE: before calling the proper contract's function that assigning warriors\r\n  to the battlefiled, players NEED TO CALL APPROVE on their token contract to\r\n  allow Battle contract to move their tokens.\r\n- Once sent, troops can't be retired form the battlefield\r\n- The battle will last for several days\r\n- When the battle period is over, following results can happpen:\r\n    -- When the battle ends in a draw:\r\n        (*) 10% of main troops of both sides lie on the ground\r\n        (*) 90% of them can be retrieved by each former owner\r\n        (*) No slaves are assigned\r\n    -- When the battle ends with a winning factions:\r\n        (*) 10% of main troops of both sides lie on the ground\r\n        (*) 90% of them can be retrieved by each former owner\r\n        (*) Surviving warriors of the loosing faction are assigned as slaves\r\n            to winners\r\n        (*) Slaves are computed based on the BP contributed by each sender\r\n- Persians and Spartans are main troops.\r\n- Immortals and Athenians are support troops: there will be no casualties in\r\n  their row, and they will be retrieved without losses by original senders.\r\n- Only Persians and Spartans can be slaves. Immortals and Athenians WILL NOT\r\n  be sent back as slaves to winners.\r\n\r\n********************************************************************************\r\n**************************      TOKEN ADDRESSES      ***************************\r\n********************************************************************************\r\n\r\n        Persians    (PRS)   0x163733bcc28dbf26B41a8CfA83e369b5B3af741b\r\n        Immortals   (IMT)   0x22E5F62D0FA19974749faa194e3d3eF6d89c08d7\r\n        Spartans    (300)   0xaEc98A708810414878c3BCDF46Aad31dEd4a4557\r\n        Athenians   (ATH)   0x17052d51E954592C1046320c2371AbaB6C73Ef10\r\n        Battles     (BTL)   Set after the deployment of this contract\r\n\r\n*******************************************************************************/\r\npragma solidity ^0.4.15;\r\n\r\ncontract TokenEIP20 {\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\ncontract Timed {\r\n    \r\n    uint256 public startTime;           //seconds since Unix epoch time\r\n    uint256 public endTime;             //seconds since Unix epoch time\r\n    uint256 public avarageBlockTime;    //seconds\r\n\r\n    // This check is an helper function for ÐApp to check the effect of the NEXT transaction, NOT simply the current state of the contract\r\n    function isInTime() constant returns (bool inTime) {\r\n        return block.timestamp >= (startTime - avarageBlockTime) && !isTimeExpired();\r\n    }\r\n\r\n    // This check is an helper function for ÐApp to check the effect of the NEXT transacion, NOT simply the current state of the contract\r\n    function isTimeExpired() constant returns (bool timeExpired) {\r\n        return block.timestamp + avarageBlockTime >= endTime;\r\n    }\r\n\r\n    modifier onlyIfInTime {\r\n        require(block.timestamp >= startTime && block.timestamp <= endTime); _;\r\n    }\r\n\r\n    modifier onlyIfTimePassed {\r\n        require(block.timestamp > endTime); _;\r\n    }\r\n\r\n    function Timed(uint256 _startTime, uint256 life, uint8 _avarageBlockTime) {\r\n        startTime = _startTime;\r\n        endTime = _startTime + life;\r\n        avarageBlockTime = _avarageBlockTime;\r\n    }\r\n}\r\n\r\nlibrary SafeMathLib {\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function add(uint x, uint y) internal returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n\r\n    function sub(uint x, uint y) internal returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n\r\n    function mul(uint x, uint y) internal returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    function per(uint x, uint y) internal constant returns (uint z) {\r\n        return mul((x / 100), y);\r\n    }\r\n\r\n    function min(uint x, uint y) internal returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n\r\n    function max(uint x, uint y) internal returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    function imin(int x, int y) internal returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n\r\n    function imax(int x, int y) internal returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    function wmul(uint x, uint y) internal returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n\r\n    function rmul(uint x, uint y) internal returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n\r\n    function wdiv(uint x, uint y) internal returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n\r\n    function rdiv(uint x, uint y) internal returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    function wper(uint x, uint y) internal constant returns (uint z) {\r\n        return wmul(wdiv(x, 100), y);\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint x, uint n) internal returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\ncontract Owned {\r\n\r\n    address owner;\r\n    \r\n    function Owned() { owner = msg.sender; }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n}\r\n\r\ncontract Upgradable is Owned {\r\n\r\n    string  public VERSION;\r\n    bool    public deprecated;\r\n    string  public newVersion;\r\n    address public newAddress;\r\n\r\n    function Upgradable(string _version) {\r\n        VERSION = _version;\r\n    }\r\n\r\n    function setDeprecated(string _newVersion, address _newAddress) onlyOwner returns (bool success) {\r\n        require(!deprecated);\r\n        deprecated = true;\r\n        newVersion = _newVersion;\r\n        newAddress = _newAddress;\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract BattleOfThermopylae is Timed, Upgradable {\r\n    using SafeMathLib for uint;\r\n  \r\n    uint    public constant MAX_PERSIANS            = 300000 * 10**18;  // 300.000\r\n    uint    public constant MAX_SPARTANS            = 300 * 10**18;     // 300\r\n    uint    public constant MAX_IMMORTALS           = 100;              // 100\r\n    uint    public constant MAX_ATHENIANS           = 100 * 10**18;     // 100\r\n\r\n    uint8   public constant BP_PERSIAN              = 1;                // Each Persian worths 1 Battle Point\r\n    uint8   public constant BP_IMMORTAL             = 100;              // Each Immortal worths 100 Battle Points\r\n    uint16  public constant BP_SPARTAN              = 1000;             // Each Spartan worths 1000 Battle Points\r\n    uint8   public constant BP_ATHENIAN             = 100;              // Each Athenians worths 100 Battle Points\r\n\r\n    uint8   public constant BTL_PERSIAN              = 1;               // Each Persian worths 1 Battle Token\r\n    uint16  public constant BTL_IMMORTAL             = 2000;            // Each Immortal worths 2000 Battle Tokens\r\n    uint16  public constant BTL_SPARTAN              = 1000;            // Each Spartan worths 1000 Battle Tokens\r\n    uint16  public constant BTL_ATHENIAN             = 2000;            // Each Athenians worths 2000 Battle Tokens\r\n\r\n    uint    public constant WAD                     = 10**18;           // Shortcut for 1.000.000.000.000.000.000\r\n    uint8   public constant BATTLE_POINT_DECIMALS   = 18;               // Battle points decimal positions\r\n    uint8   public constant BATTLE_CASUALTIES       = 10;               // Percentage of Persian and Spartan casualties\r\n    \r\n    address public persians;                                            // Address of the Persian Tokens\r\n    address public immortals;                                           // Address of the Immortal Tokens\r\n    address public spartans;                                            // Address of the 300 Tokens\r\n    address public athenians;                                           // Address of the Athenian Tokens\r\n    address public battles;                                             // Address of the Battle Tokens\r\n    address public battlesOwner;                                        // Owner of the Battle Token contract\r\n\r\n    mapping (address => mapping (address => uint))   public  warriorsByPlayer;               // Troops currently allocated by each player\r\n    mapping (address => uint)                        public  warriorsOnTheBattlefield;       // Total troops fighting in the battle\r\n\r\n    event WarriorsAssignedToBattlefield (address indexed _from, address _faction, uint _battlePointsIncrementForecast);\r\n    event WarriorsBackToHome            (address indexed _to, address _faction, uint _survivedWarriors);\r\n\r\n    function BattleOfThermopylae(uint _startTime, uint _life, uint8 _avarageBlockTime, address _persians, address _immortals, address _spartans, address _athenians) Timed(_startTime, _life, _avarageBlockTime) Upgradable(\"1.0.0\") {\r\n        persians = _persians;\r\n        immortals = _immortals;\r\n        spartans = _spartans;\r\n        athenians = _athenians;\r\n    }\r\n\r\n    function setBattleTokenAddress(address _battleTokenAddress, address _battleTokenOwner) onlyOwner {\r\n        battles = _battleTokenAddress;\r\n        battlesOwner = _battleTokenOwner;\r\n    }\r\n\r\n    function assignPersiansToBattle(uint _warriors) onlyIfInTime external returns (bool success) {\r\n        assignWarriorsToBattle(msg.sender, persians, _warriors, MAX_PERSIANS);\r\n        sendBattleTokens(msg.sender, _warriors.mul(BTL_PERSIAN));\r\n        // Persians are divisible with 18 decimals and their value is 1 BP\r\n        WarriorsAssignedToBattlefield(msg.sender, persians, _warriors / WAD);\r\n        return true;\r\n    }\r\n\r\n    function assignImmortalsToBattle(uint _warriors) onlyIfInTime external returns (bool success) {\r\n        assignWarriorsToBattle(msg.sender, immortals, _warriors, MAX_IMMORTALS);\r\n        sendBattleTokens(msg.sender, _warriors.mul(WAD).mul(BTL_IMMORTAL));\r\n        // Immortals are not divisible and their value is 100 BP\r\n        WarriorsAssignedToBattlefield(msg.sender, immortals, _warriors.mul(BP_IMMORTAL));\r\n        return true;\r\n    }\r\n\r\n    function assignSpartansToBattle(uint _warriors) onlyIfInTime external returns (bool success) {\r\n        assignWarriorsToBattle(msg.sender, spartans, _warriors, MAX_SPARTANS);\r\n        sendBattleTokens(msg.sender, _warriors.mul(BTL_SPARTAN));\r\n        // Spartans are divisible with 18 decimals and their value is 1.000 BP\r\n        WarriorsAssignedToBattlefield(msg.sender, spartans, (_warriors / WAD).mul(BP_SPARTAN));\r\n        return true;\r\n    }\r\n\r\n    function assignAtheniansToBattle(uint _warriors) onlyIfInTime external returns (bool success) {\r\n        assignWarriorsToBattle(msg.sender, athenians, _warriors, MAX_ATHENIANS);\r\n        sendBattleTokens(msg.sender, _warriors.mul(BTL_ATHENIAN));\r\n        // Athenians are divisible with 18 decimals and their value is 100 BP\r\n        WarriorsAssignedToBattlefield(msg.sender, athenians, (_warriors / WAD).mul(BP_ATHENIAN));\r\n        return true;\r\n    }\r\n\r\n    function redeemWarriors() onlyIfTimePassed external returns (bool success) {\r\n        if (getPersiansBattlePoints() > getGreeksBattlePoints()) {\r\n            // Persians won, compute slaves\r\n            uint spartanSlaves = computeSlaves(msg.sender, spartans);\r\n            if (spartanSlaves > 0) {\r\n                // Send back Spartan slaves to winner\r\n                sendWarriors(msg.sender, spartans, spartanSlaves);\r\n            }\r\n            // Send back Persians but casualties\r\n            retrieveWarriors(msg.sender, persians, BATTLE_CASUALTIES);\r\n        } else if (getPersiansBattlePoints() < getGreeksBattlePoints()) {\r\n            //Greeks won, send back Persian slaves\r\n            uint persianSlaves = computeSlaves(msg.sender, persians);\r\n            if (persianSlaves > 0) {\r\n                // Send back Persians slaves to winner\r\n                sendWarriors(msg.sender, persians, persianSlaves);                \r\n            }\r\n            // Send back Spartans but casualties\r\n            retrieveWarriors(msg.sender, spartans, BATTLE_CASUALTIES);\r\n        } else {\r\n            // It's a draw, send back Persians and Spartans but casualties\r\n            retrieveWarriors(msg.sender, persians, BATTLE_CASUALTIES);\r\n            retrieveWarriors(msg.sender, spartans, BATTLE_CASUALTIES);\r\n        }\r\n        // Send back Immortals untouched\r\n        retrieveWarriors(msg.sender, immortals, 0);\r\n        // Send back Athenians untouched\r\n        retrieveWarriors(msg.sender, athenians, 0);\r\n        return true;\r\n    }\r\n\r\n    function assignWarriorsToBattle(address _player, address _faction, uint _warriors, uint _maxWarriors) private {\r\n        require(warriorsOnTheBattlefield[_faction].add(_warriors) <= _maxWarriors);\r\n        require(TokenEIP20(_faction).transferFrom(_player, address(this), _warriors));\r\n        warriorsByPlayer[_player][_faction] = warriorsByPlayer[_player][_faction].add(_warriors);\r\n        warriorsOnTheBattlefield[_faction] = warriorsOnTheBattlefield[_faction].add(_warriors);\r\n    }\r\n\r\n    function retrieveWarriors(address _player, address _faction, uint8 _deadPercentage) private {\r\n        if (warriorsByPlayer[_player][_faction] > 0) {\r\n            uint _warriors = warriorsByPlayer[_player][_faction];\r\n            if (_deadPercentage > 0) {\r\n                _warriors = _warriors.sub(_warriors.wper(_deadPercentage));\r\n            }\r\n            warriorsByPlayer[_player][_faction] = 0;\r\n            sendWarriors(_player, _faction, _warriors);\r\n            WarriorsBackToHome(_player, _faction, _warriors);\r\n        }\r\n    }\r\n\r\n    function sendWarriors(address _player, address _faction, uint _warriors) private {\r\n        require(TokenEIP20(_faction).transfer(_player, _warriors));\r\n    }\r\n\r\n    function sendBattleTokens(address _player, uint _value) private {\r\n        require(TokenEIP20(battles).transferFrom(battlesOwner, _player, _value));\r\n    }\r\n\r\n    function getPersiansOnTheBattlefield(address _player) constant returns (uint persiansOnTheBattlefield) {\r\n        return warriorsByPlayer[_player][persians];\r\n    }\r\n\r\n    function getImmortalsOnTheBattlefield(address _player) constant returns (uint immortalsOnTheBattlefield) {\r\n        return warriorsByPlayer[_player][immortals];\r\n    }\r\n\r\n    function getSpartansOnTheBattlefield(address _player) constant returns (uint spartansOnTheBattlefield) {\r\n        return warriorsByPlayer[_player][spartans];\r\n    }\r\n\r\n    function getAtheniansOnTheBattlefield(address _player) constant returns (uint atheniansOnTheBattlefield) {\r\n        return warriorsByPlayer[_player][athenians];\r\n    }\r\n\r\n    function getPersiansBattlePoints() constant returns (uint persiansBattlePoints) {\r\n        return (warriorsOnTheBattlefield[persians].mul(BP_PERSIAN) + warriorsOnTheBattlefield[immortals].mul(WAD).mul(BP_IMMORTAL));\r\n    }\r\n\r\n    function getGreeksBattlePoints() constant returns (uint greeksBattlePoints) {\r\n        return (warriorsOnTheBattlefield[spartans].mul(BP_SPARTAN) + warriorsOnTheBattlefield[athenians].mul(BP_ATHENIAN));\r\n    }\r\n\r\n    function getPersiansBattlePointsBy(address _player) constant returns (uint playerBattlePoints) {\r\n        return (getPersiansOnTheBattlefield(_player).mul(BP_PERSIAN) + getImmortalsOnTheBattlefield(_player).mul(WAD).mul(BP_IMMORTAL));\r\n    }\r\n\r\n    function getGreeksBattlePointsBy(address _player) constant returns (uint playerBattlePoints) {\r\n        return (getSpartansOnTheBattlefield(_player).mul(BP_SPARTAN) + getAtheniansOnTheBattlefield(_player).mul(BP_ATHENIAN));\r\n    }\r\n\r\n    function computeSlaves(address _player, address _loosingMainTroops) constant returns (uint slaves) {\r\n        if (_loosingMainTroops == spartans) {\r\n            return getPersiansBattlePointsBy(_player).wdiv(getPersiansBattlePoints()).wmul(getTotalSlaves(spartans));\r\n        } else {\r\n            return getGreeksBattlePointsBy(_player).wdiv(getGreeksBattlePoints()).wmul(getTotalSlaves(persians));\r\n        }\r\n    }\r\n\r\n    function getTotalSlaves(address _faction) constant returns (uint slaves) {\r\n        return warriorsOnTheBattlefield[_faction].sub(warriorsOnTheBattlefield[_faction].wper(BATTLE_CASUALTIES));\r\n    }\r\n\r\n    function isInProgress() constant returns (bool inProgress) {\r\n        return !isTimeExpired();\r\n    }\r\n\r\n    function isEnded() constant returns (bool ended) {\r\n        return isTimeExpired();\r\n    }\r\n\r\n    function isDraw() constant returns (bool draw) {\r\n        return (getPersiansBattlePoints() == getGreeksBattlePoints());\r\n    }\r\n\r\n    function getTemporaryWinningFaction() constant returns (string temporaryWinningFaction) {\r\n        if (isDraw()) {\r\n            return \"It's currently a draw, but the battle is still in progress!\";\r\n        }\r\n        return getPersiansBattlePoints() > getGreeksBattlePoints() ?\r\n            \"Persians are winning, but the battle is still in progress!\" : \"Greeks are winning, but the battle is still in progress!\";\r\n    }\r\n\r\n    function getWinningFaction() constant returns (string winningFaction) {\r\n        if (isInProgress()) {\r\n            return \"The battle is still in progress\";\r\n        }\r\n        if (isDraw()) {\r\n            return \"The battle ended in a draw!\";\r\n        }\r\n        return getPersiansBattlePoints() > getGreeksBattlePoints() ? \"Persians\" : \"Greeks\";\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getGreeksBattlePoints\",\"outputs\":[{\"name\":\"greeksBattlePoints\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_ATHENIANS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_warriors\",\"type\":\"uint256\"}],\"name\":\"assignAtheniansToBattle\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"immortals\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deprecated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BTL_IMMORTAL\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_player\",\"type\":\"address\"}],\"name\":\"getImmortalsOnTheBattlefield\",\"outputs\":[{\"name\":\"immortalsOnTheBattlefield\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BTL_PERSIAN\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newVersion\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_faction\",\"type\":\"address\"}],\"name\":\"getTotalSlaves\",\"outputs\":[{\"name\":\"slaves\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_warriors\",\"type\":\"uint256\"}],\"name\":\"assignImmortalsToBattle\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"athenians\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BATTLE_POINT_DECIMALS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTemporaryWinningFaction\",\"outputs\":[{\"name\":\"temporaryWinningFaction\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"battles\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_player\",\"type\":\"address\"}],\"name\":\"getPersiansOnTheBattlefield\",\"outputs\":[{\"name\":\"persiansOnTheBattlefield\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isInTime\",\"outputs\":[{\"name\":\"inTime\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_battleTokenAddress\",\"type\":\"address\"},{\"name\":\"_battleTokenOwner\",\"type\":\"address\"}],\"name\":\"setBattleTokenAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BTL_SPARTAN\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WAD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isInProgress\",\"outputs\":[{\"name\":\"inProgress\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"redeemWarriors\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BTL_ATHENIAN\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isTimeExpired\",\"outputs\":[{\"name\":\"timeExpired\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BP_ATHENIAN\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"avarageBlockTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"persians\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_player\",\"type\":\"address\"}],\"name\":\"getAtheniansOnTheBattlefield\",\"outputs\":[{\"name\":\"atheniansOnTheBattlefield\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"warriorsOnTheBattlefield\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_player\",\"type\":\"address\"}],\"name\":\"getGreeksBattlePointsBy\",\"outputs\":[{\"name\":\"playerBattlePoints\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_player\",\"type\":\"address\"},{\"name\":\"_loosingMainTroops\",\"type\":\"address\"}],\"name\":\"computeSlaves\",\"outputs\":[{\"name\":\"slaves\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isEnded\",\"outputs\":[{\"name\":\"ended\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"warriorsByPlayer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"spartans\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPersiansBattlePoints\",\"outputs\":[{\"name\":\"persiansBattlePoints\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_player\",\"type\":\"address\"}],\"name\":\"getPersiansBattlePointsBy\",\"outputs\":[{\"name\":\"playerBattlePoints\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_player\",\"type\":\"address\"}],\"name\":\"getSpartansOnTheBattlefield\",\"outputs\":[{\"name\":\"spartansOnTheBattlefield\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BATTLE_CASUALTIES\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_PERSIANS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newVersion\",\"type\":\"string\"},{\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"setDeprecated\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_SPARTANS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWinningFaction\",\"outputs\":[{\"name\":\"winningFaction\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BP_PERSIAN\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_IMMORTALS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"battlesOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BP_IMMORTAL\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BP_SPARTAN\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_warriors\",\"type\":\"uint256\"}],\"name\":\"assignSpartansToBattle\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isDraw\",\"outputs\":[{\"name\":\"draw\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_warriors\",\"type\":\"uint256\"}],\"name\":\"assignPersiansToBattle\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_life\",\"type\":\"uint256\"},{\"name\":\"_avarageBlockTime\",\"type\":\"uint8\"},{\"name\":\"_persians\",\"type\":\"address\"},{\"name\":\"_immortals\",\"type\":\"address\"},{\"name\":\"_spartans\",\"type\":\"address\"},{\"name\":\"_athenians\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_faction\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_battlePointsIncrementForecast\",\"type\":\"uint256\"}],\"name\":\"WarriorsAssignedToBattlefield\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_faction\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_survivedWarriors\",\"type\":\"uint256\"}],\"name\":\"WarriorsBackToHome\",\"type\":\"event\"}]","ContractName":"BattleOfThermopylae","CompilerVersion":"v0.4.17+commit.bdeb9e52","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000059ee828000000000000000000000000000000000000000000000000000000000000a8c00000000000000000000000000000000000000000000000000000000000000000f000000000000000000000000163733bcc28dbf26b41a8cfa83e369b5b3af741b00000000000000000000000022e5f62d0fa19974749faa194e3d3ef6d89c08d7000000000000000000000000aec98a708810414878c3bcdf46aad31ded4a455700000000000000000000000017052d51e954592c1046320c2371abab6c73ef10","Library":"","SwarmSource":"bzzr://a4086f431589d9f590f38c7b1c48830270196564a6f198aa5ddf681a4b20ca87"}]}