{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n    }\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) constant returns (uint256);\r\n  function transfer(address to, uint256 value) returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) returns (bool);\r\n  function approve(address spender, uint256 value) returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\ncontract Drainable is Ownable {\r\n\tfunction withdrawToken(address tokenaddr) \r\n\t\tonlyOwner \r\n\t{\r\n\t\tERC20 token = ERC20(tokenaddr);\r\n\t\tuint bal = token.balanceOf(address(this));\r\n\t\ttoken.transfer(msg.sender, bal);\r\n\t}\r\n\r\n\tfunction withdrawEther() \r\n\t\tonlyOwner\r\n\t{\r\n\t    require(msg.sender.send(this.balance));\r\n\t}\r\n}\r\n\r\n\r\ncontract ADXRegistry is Ownable, Drainable {\r\n\tstring public name = \"AdEx Registry\";\r\n\r\n\t// Structure:\r\n\t// AdUnit (advertiser) - a unit of a single advertisement\r\n\t// AdSlot (publisher) - a particular property (slot) that can display an ad unit\r\n\t// Campaign (advertiser) - group of ad units ; not vital\r\n\t// Channel (publisher) - group of properties ; not vital\r\n\t// Each Account is linked to all the items they own through the Account struct\r\n\r\n\tmapping (address => Account) public accounts;\r\n\r\n\t// XXX: mostly unused, because solidity does not allow mapping with enum as primary type.. :( we just use uint\r\n\tenum ItemType { AdUnit, AdSlot, Campaign, Channel }\r\n\r\n\t// uint here corresponds to the ItemType\r\n\tmapping (uint => uint) public counts;\r\n\tmapping (uint => mapping (uint => Item)) public items;\r\n\r\n\t// Publisher or Advertiser (could be both)\r\n\tstruct Account {\t\t\r\n\t\taddress addr;\r\n\t\taddress wallet;\r\n\r\n\t\tbytes32 ipfs; // ipfs addr for additional (larger) meta\r\n\t\tbytes32 name; // name\r\n\t\tbytes32 meta; // metadata, can be JSON, can be other format, depends on the high-level implementation\r\n\r\n\t\tbytes32 signature; // signature in the off-blockchain state channel\r\n\t\t\r\n\t\t// Items, by type, then in an array of numeric IDs\t\r\n\t\tmapping (uint => uint[]) items;\r\n\t}\r\n\r\n\t// Sub-item, such as AdUnit, AdSlot, Campaign, Channel\r\n\tstruct Item {\r\n\t\tuint id;\r\n\t\taddress owner;\r\n\r\n\t\tItemType itemType;\r\n\r\n\t\tbytes32 ipfs; // ipfs addr for additional (larger) meta\r\n\t\tbytes32 name; // name\r\n\t\tbytes32 meta; // metadata, can be JSON, can be other format, depends on the high-level implementation\r\n\t}\r\n\r\n\tmodifier onlyRegistered() {\r\n\t\tvar acc = accounts[msg.sender];\r\n\t\trequire(acc.addr != 0);\r\n\t\t_;\r\n\t}\r\n\r\n\t// can be called over and over to update the data\r\n\t// XXX consider entrance barrier, such as locking in some ADX\r\n\tfunction register(bytes32 _name, address _wallet, bytes32 _ipfs, bytes32 _sig, bytes32 _meta)\r\n\t\texternal\r\n\t{\r\n\t\trequire(_wallet != 0);\r\n\t\t// XXX should we ensure _sig is not 0? if so, also add test\r\n\t\t\r\n\t\trequire(_name != 0);\r\n\r\n\t\tvar isNew = accounts[msg.sender].addr == 0;\r\n\r\n\t\tvar acc = accounts[msg.sender];\r\n\r\n\t\tif (!isNew) require(acc.signature == _sig);\r\n\t\telse acc.signature = _sig;\r\n\r\n\t\tacc.addr = msg.sender;\r\n\t\tacc.wallet = _wallet;\r\n\t\tacc.ipfs = _ipfs;\r\n\t\tacc.name = _name;\r\n\t\tacc.meta = _meta;\r\n\r\n\t\tif (isNew) LogAccountRegistered(acc.addr, acc.wallet, acc.ipfs, acc.name, acc.meta, acc.signature);\r\n\t\telse LogAccountModified(acc.addr, acc.wallet, acc.ipfs, acc.name, acc.meta, acc.signature);\r\n\t}\r\n\r\n\t// use _id = 0 to create a new item, otherwise modify existing\r\n\tfunction registerItem(uint _type, uint _id, bytes32 _ipfs, bytes32 _name, bytes32 _meta)\r\n\t\tonlyRegistered\r\n\t{\r\n\t\t// XXX _type sanity check?\r\n\t\tvar item = items[_type][_id];\r\n\r\n\t\tif (_id != 0)\r\n\t\t\trequire(item.owner == msg.sender);\r\n\t\telse {\r\n\t\t\t// XXX: what about overflow here?\r\n\t\t\tvar newId = ++counts[_type];\r\n\r\n\t\t\titem = items[_type][newId];\r\n\t\t\titem.id = newId;\r\n\t\t\titem.itemType = ItemType(_type);\r\n\t\t\titem.owner = msg.sender;\r\n\r\n\t\t\taccounts[msg.sender].items[_type].push(item.id);\r\n\t\t}\r\n\r\n\t\titem.name = _name;\r\n\t\titem.meta = _meta;\r\n\t\titem.ipfs = _ipfs;\r\n\r\n\t\tif (_id == 0) LogItemRegistered(\r\n\t\t\titem.owner, uint(item.itemType), item.id, item.ipfs, item.name, item.meta\r\n\t\t);\r\n\t\telse LogItemModified(\r\n\t\t\titem.owner, uint(item.itemType), item.id, item.ipfs, item.name, item.meta\r\n\t\t);\r\n\t}\r\n\r\n\t// NOTE\r\n\t// There's no real point of un-registering items\r\n\t// Campaigns need to be kept anyway, as well as ad units\r\n\t// END NOTE\r\n\r\n\t//\r\n\t// Constant functions\r\n\t//\r\n\tfunction isRegistered(address who)\r\n\t\tpublic \r\n\t\tconstant\r\n\t\treturns (bool)\r\n\t{\r\n\t\tvar acc = accounts[who];\r\n\t\treturn acc.addr != 0;\r\n\t}\r\n\r\n\t// Functions exposed for web3 interface\r\n\t// NOTE: this is sticking to the policy of keeping static-sized values at the left side of tuples\r\n\tfunction getAccount(address _acc)\r\n\t\tconstant\r\n\t\tpublic\r\n\t\treturns (address, bytes32, bytes32, bytes32)\r\n\t{\r\n\t\tvar acc = accounts[_acc];\r\n\t\trequire(acc.addr != 0);\r\n\t\treturn (acc.wallet, acc.ipfs, acc.name, acc.meta);\r\n\t}\r\n\r\n\tfunction getAccountItems(address _acc, uint _type)\r\n\t\tconstant\r\n\t\tpublic\r\n\t\treturns (uint[])\r\n\t{\r\n\t\tvar acc = accounts[_acc];\r\n\t\trequire(acc.addr != 0);\r\n\t\treturn acc.items[_type];\r\n\t}\r\n\r\n\tfunction getItem(uint _type, uint _id) \r\n\t\tconstant\r\n\t\tpublic\r\n\t\treturns (address, bytes32, bytes32, bytes32)\r\n\t{\r\n\t\tvar item = items[_type][_id];\r\n\t\trequire(item.id != 0);\r\n\t\treturn (item.owner, item.ipfs, item.name, item.meta);\r\n\t}\r\n\r\n\tfunction hasItem(uint _type, uint _id)\r\n\t\tconstant\r\n\t\tpublic\r\n\t\treturns (bool)\r\n\t{\r\n\t\tvar item = items[_type][_id];\r\n\t\treturn item.id != 0;\r\n\t}\r\n\r\n\t// Events\r\n\tevent LogAccountRegistered(address addr, address wallet, bytes32 ipfs, bytes32 accountName, bytes32 meta, bytes32 signature);\r\n\tevent LogAccountModified(address addr, address wallet, bytes32 ipfs, bytes32 accountName, bytes32 meta, bytes32 signature);\r\n\t\r\n\tevent LogItemRegistered(address owner, uint itemType, uint id, bytes32 ipfs, bytes32 itemName, bytes32 meta);\r\n\tevent LogItemModified(address owner, uint itemType, uint id, bytes32 ipfs, bytes32 itemName, bytes32 meta);\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"items\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"itemType\",\"type\":\"uint8\"},{\"name\":\"ipfs\",\"type\":\"bytes32\"},{\"name\":\"name\",\"type\":\"bytes32\"},{\"name\":\"meta\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_type\",\"type\":\"uint256\"},{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getItem\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"accounts\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"ipfs\",\"type\":\"bytes32\"},{\"name\":\"name\",\"type\":\"bytes32\"},{\"name\":\"meta\",\"type\":\"bytes32\"},{\"name\":\"signature\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenaddr\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_acc\",\"type\":\"address\"},{\"name\":\"_type\",\"type\":\"uint256\"}],\"name\":\"getAccountItems\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"bytes32\"},{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_ipfs\",\"type\":\"bytes32\"},{\"name\":\"_sig\",\"type\":\"bytes32\"},{\"name\":\"_meta\",\"type\":\"bytes32\"}],\"name\":\"register\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_type\",\"type\":\"uint256\"},{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_ipfs\",\"type\":\"bytes32\"},{\"name\":\"_name\",\"type\":\"bytes32\"},{\"name\":\"_meta\",\"type\":\"bytes32\"}],\"name\":\"registerItem\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"isRegistered\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"counts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_type\",\"type\":\"uint256\"},{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"hasItem\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_acc\",\"type\":\"address\"}],\"name\":\"getAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ipfs\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"accountName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"meta\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"signature\",\"type\":\"bytes32\"}],\"name\":\"LogAccountRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ipfs\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"accountName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"meta\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"signature\",\"type\":\"bytes32\"}],\"name\":\"LogAccountModified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"itemType\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ipfs\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"itemName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"meta\",\"type\":\"bytes32\"}],\"name\":\"LogItemRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"itemType\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ipfs\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"itemName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"meta\",\"type\":\"bytes32\"}],\"name\":\"LogItemModified\",\"type\":\"event\"}]","ContractName":"ADXRegistry","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://ca22573b208cc5210edb52499b7246ccfcdc9bb77cf811ed9fb1a7b2bd9a4f0e"}]}