{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n\r\n    ,----..      \r\n   /   /   \\            *********************************\r\n  /   .     :           *Qwoyn Digital Investments, LLC *\r\n .   /   ;.  \\          *Cornerstone version 0.1        *\r\n.   ;   /  ` ;          *Daniel Pittman, CEO            *\r\n;   |  ; \\ ; |          *December 2017                  *\r\n|   :  | ; | '          *********************************\r\n.   |  ' ' ' :   \r\n'   ;  \\; /  |   \r\n \\   \\  ',  . \\  \r\n  ;   :      ; | \r\n   \\   \\ .'`--\" \r\n\r\n\r\nTokenized Company Equity Right Transfer Agreement\r\n\r\n\r\n\r\nSubject to an existing Right of Ownership Token Transfer Agreement or otherwise proclaimed possession of ownership of the underlying \r\n\r\nasset (\"the Company Equity\"), referenced hereafter as \"P003_25793\", Qwoyn Digital Investments, LLC, (hereafter the “Token Issuer”) \r\n\r\n(the “Purchaser” or the “lien holder”) hereby agrees to tokenize his ownership of  the Company Equity Right granted under the \r\n\r\nAgreement P003_25793, (the “Tokenized Right to Company Equity Revenue”). \r\n\r\nUploading this Agreement on the blockchain will be hashed and referred in code of a Smart Contract generated by the Token Issuer. \r\n\r\n1. SALE OF THE TOKENIZED RIGHT. \r\n\r\n1.1. The Token Issuer hereby agrees to issue 1000000 Token(s) at the price of as .1 ether 2017-12-06 on the blockchain of the Token \r\n\r\nIssuer’s choice (Ethereum). \r\n\r\n1.2  The Token Issuer hereby reserves the right to issue more tokens dependent on market demand.\r\n\r\n2. TOKEN BUYER’S PAYMENT AS CONDITION PRECEDENT. \r\n\r\n2.1. Token Buyer’s (defined in Section 14) payment for the Token(s) issued by Token Issuer under Section 1 is a condition precedent to \r\n\r\nthe formation of this Agreement. There will no binding Agreement until the payment from the Token Buyer is appeared in the Token \r\n\r\nIssuer’s ethereum-wallet account. \r\n\r\n2.2. Likewise, there will be no binding agreement with any subsequent token buyer unless the payment for the Token created hereunder \r\n\r\nmade to the Token Holder at the moment of selling the Token. \r\n\r\n3. SMART CONTRACT. For the purpose of recording the ownership of the Company Equity Right created under the Agreement P003_25793, \r\n\r\nToken Issuer generates a Smart Contract. This Smart Contract facilitates the direct transfer of the Company Equity Right created to an \r\n\r\nindividual or an entity that makes the payment for the Token representing the ownership of the Company Equity Right created under the \r\n\r\nAgreement K003-2017 (the “Token Holder”). \r\n\r\n4. TOKEN HOLDER’S RIGHT. \r\n\r\n4.1. Subject to the Agreement P003_25793, all Token Holder(s) will be granted the right to set a new price for the purchased token \r\n\r\nhereunder, provided that he/she cannot interfere or enforce in the Company Equity Owner’s decision regarding the Company Equity \r\n\r\nsubject to the Agreement P003_25793. \r\n\r\n4.2. Subject to the Agreement P003_25793, Token Holder(s)’s Company Equity Right does not create any type of a lien on the Company \r\n\r\nEquity subject to the Agreement P003_25793. Token Holder’s Company Equity Right will be limited to the Right to claim the amount of \r\n\r\nthe Company Equity Income promised by the Company Equity Owner to Token Issuer under the Agreement P003_25793. \r\n\r\n5. RIGHT OWNER’S WARRANTIES AND DUTIES. Token Issuer and subsequent Token Holder hereby represent and warrant that, to the best of \r\n\r\nhis/her knowledge, he/she is the sole lawful owner of the tokenized Company Equity Right created under the Agreement P003_25793 and \r\n\r\nfree and clear of any liens and encumbrances except the ones disclosed to Token Issuer from the Company Equity Owner under the \r\n\r\nAgreement P003_25793. Token Issuer and each subsequent Token Holder(s) have full right, power and authority to sell and transfer \r\n\r\nhis/her Right created under the Agreement P003_25793. Token Issuer and each subsequent Token Holder also warrant that he/she does not \r\n\r\ncurrently know of and has no reason to know of any third party claim to any right, title, or use of the Right created under the \r\n\r\nAgreement P003_25793 except the ones disclosed to Token Issuer from the Company Equity Owner under the Agreement P003_25793. Token \r\n\r\nIssuer and each subsequent Token Holder did not and will not execute any agreement in conflict with this Agreement. Once a token \r\n\r\npurchaser makes the full payment pursuant to Section 1, Token Issuer will take any actions that may be necessary or desirable to \r\n\r\nprotect and perfect the Purchaser’s Company Equity Right created under the Agreement P003_25793. \r\n\r\n6. ASSUMPTION OF RISK. \r\n\r\nEach Token Holder bears the risk of loss when purchasing a Token representing the ownership of the Company Equity Right created under \r\n\r\nthe Agreement P003_25793. Token Issuer will not be responsible for and will not be liable for any loss arising from: (a) failure or \r\n\r\nmalfunction of hardware, software, server, and internet connections; (b) malicious software introduction; (c) the third party may \r\n\r\nobtain unauthorized access to information stored within buyer’s account, including, but not limited to Buyer’s storage address and \r\n\r\nprivate key; (d) forgotten passwords; and (e) incorrectly constructed transactions or mistyped account address. \r\n\r\n7. DISCLAIMER.\r\n\r\nThis Tokenized Company Equity Right subject to the Agreement P003_25793 is not a consumer good and sold on an “as is” and \r\n\r\n“as-available” basis. Token Holder(s) bears the entire risk, Token Issuer sells the tokenized Company Equity Right to Token Holder(s) \r\n\r\nwithout any warranty of fitness for a particular purpose, and Token Holder(s) acknowledges that no warrant of fitness could be offered\r\n\r\nbecause of the many future technical and legal uncertainties regarding the Tokenized Company Equity Right. \r\n\r\n8. TAX.\r\n\r\nToken Issuer is not responsible for any taxes or any other costs related to purchasing the Tokenized Company Equity Right created \r\n\r\nunder the Agreement P003_25793. \r\n\r\n9. NO DAMAGES.\r\n\r\nToken Issuer will never be liable to Token Holder(s) for consequential and any kind of damages, including but not limited to lost \r\n\r\nprofits. \r\n\r\n10. MARKET RISK.\r\n\r\nAll Token Holder(s) understands that this Tokenized Company Equity Right is a new and relatively untested exchange medium. Token \r\n\r\nHolder(s) therefore understands that Token Issuer cannot predict how the value of the Tokenized Right will change, the consumer \r\n\r\ndemand for the Tokenized Right, technical difficulties in or modification to the peer-to-peer blockchain network, change of \r\n\r\nregulations, and all other obstacles that a peer-to-peer blockchain network might face. All Token Holder(s) affirmatively represents \r\n\r\nthat he/she is a sophisticated blockchain users and therefore knowingly assumes all known and unknown risk of loss. All Token Holder(s)\r\n\r\nhas not recourse whatsoever against Token Issuer for damages or liability suffered by Token Holder(s) due to the market condition or \r\n\r\nwhatsoever causes. \r\n\r\n11. RISK OF FINANCIAL REGULATION.\r\n\r\nAll Token Holder(s) understands that the Tokenized Company Equity Right is a relatively new technology and no one can predict how the \r\n\r\ngovernment for each country may apply and enforce the existing laws or regulate the Tokenized Right or other peer-to-peer blockchain \r\n\r\nbased exchange technologies in the future. All Token Holder(s) understands that there is a high level of uncertainty, and all Token \r\n\r\nHolder(s) assumes that all financial regulatory risk inherent in operating and transferring the Tokenized Right. \r\n\r\nAll Token Holder(s) has no recourse whatsoever against Token Issuer for damages, civil and criminal, suffered by each Token Holder(s) \r\n\r\ndue to regulatory enforcement. Token Issuer does not and cannot warrant that the exercise or transfer of the Tokenized Company Equity \r\n\r\nRight is legal in all specific jurisdiction of each country. Token Issuer has not duty to advise or warn to each Token Holder(s) and \r\n\r\neach Token Holder(s) will not advise or warn Token Issuer about any particular legal or regulatory requirement(s). Each Token Holder(s)\r\n\r\nis solely obligated to understand the laws and regulations of its local jurisdiction before exercising, selling, or purchasing the \r\n\r\nTokenized Right, and Token Holder(s) is solely responsible for any of its actions that may be unlawful. \r\n\r\n12. DEFINITIONS. \r\n\r\n“Tokenized Right to Company Equity Revenue” means a digitized portion or unit of the syndicated ownership of the Company Equity Right \r\n\r\ncreated under the Agreement P003_25793. “Token Holder(s)” means a buyer(s) of the tokenized Right representing an ownership of the \r\n\r\nCompany Equity Right through the Smart Contract created by the Token Issuer hereunder. “Smart Contract” means terms and conditions \r\n\r\nfor a legally effective Instrument written in programming language or asset protocol into the blockchain of Token Issuer’s choice. \r\n\r\n“Token Buyer” means that a party (an individual, legal entity, or authorized person representing an organization) that intends to buy \r\n\r\nthe Tokenized Company Equity Right initially issued by Token Issuer hereunder. \r\n\r\n13. DISPUTE RESOLTUION.\r\n\r\nInformal Resolution. If either Token Issuer or Token Holder has any concerns regarding a breach under this Agreement, the complaining \r\n\r\nparty must first notify the other and allow the other party at least 30 days to remedy the claimed breach. Binding Arbitration. Any \r\n\r\ndispute arising out of or relating to this Agreement, or the breach thereof, shall finally settled under the Rules of Arbitration of \r\n\r\nthe International Chamber of Commerce by one or three arbitrator, and judgement upon the award rendered the arbitrators may be \r\n\r\nentered in a court in United States jurisdiction. The arbitration will be conducted in the English language, in accordance with the \r\n\r\ninternational Arbitration Rules of the United States Commercial Arbitration Board. \r\n\r\n14. MISCELLANEOUS.\r\n\r\n14.1. No Conditions to Effectiveness; Entire Agreement. There are no conditions to the effectiveness of this Agreement. This Agreement \r\n\r\ncontains the entire agreement and understanding of the Parties hereto, and supersedes any prior agreements or understandings between \r\n\r\nor among the Parties hereto, which respect to the subject matter hereof. \r\n\r\n14.2. Governing Law. This Agreement, and the right of the Parties hereto, shall be governed by, construed and enforced in accordance \r\n\r\nwith the laws of United States regardless of the conflict of laws principle. Any action in respect of, or concerning, this Agreement \r\n\r\nshall be litigated solely in United States and both Parties consent to jurisdiction of the person and venue solely in United States . \r\n\r\n14.3. Amendment and Waivers. This Agreement may be amended only by an instrument in writing signed by the Parties hereto. No waivers \r\n\r\nof or exceptions to any term, condition or provision of this Agreement, in any one or more instances, shall be deemed to be, or \r\n\r\nconstrued as, a further or continuing waiver of any such term, condition or provision. \r\n\r\n14.4. Severability. If any provision of this Agreement is held to be invalid or unenforceable, the validity and enforceability of the \r\n\r\nremaining provisions of this Agreement shall not be affected thereby. \r\n\r\n14.5. Each party, in entering into this Agreement, acts as an independent party and nothing herein shall be construed to create a \r\n\r\npartnership or joint venture between the Parties or to constitute agency of an sort. Neither party shall have the authority to bind the other. \r\n\r\n14.6. Force Majeure. A party is not liable for failure to perform the party’s obligations if such failure is as a result of Acts of \r\n\r\nGod including: fire, flood, earthquake, storm, hurricane or other natural disaster), war, invasion, act of foreign enemies, \r\n\r\nhostilities (regardless of whether war is declared), civil war, rebellion, revolution, insurrection, military or usurped power or \r\n\r\nconfiscation, terrorist activities, nationalization, government sanction, or government prohibition or regulation preventing the \r\n\r\ntrade of blockchain-backed token(s). \r\n\r\nIN WITNESS WHEREOF, the Token Issuer, Qwoyn Digital Investments, LLC hereto have executed this Agreement as of the date first written \r\n\r\nabove. \r\n\r\nToken Issuer/Token Holder\r\n\r\nDaniel Pittman, CEO\r\n_____________________________ \r\nQwoyn Digital Investments, LLC \r\n2017-12-06                                                                                                                          */\r\n\r\n\r\n/********************\r\n * SMART CONTRACT   *\r\n * CODE BEGINS HERE *\r\n *******************/ \r\n\r\n/*ERC20*/         \r\npragma solidity ^0.4.18;\r\n \r\n//TOKEN SECURITY//\r\n \r\n /**\r\n * @title Math\r\n * @dev Assorted math operations\r\n */\r\n\r\nlibrary Math {\r\n  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n}\r\n \r\n /**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n \r\n /*\r\n * @title MerkleProof\r\n * @dev Merkle proof verification\r\n * @note Based on https://github.com/ameensol/merkle-tree-solidity/blob/master/src/MerkleProof.sol\r\n */\r\nlibrary MerkleProof {\r\n  /*\r\n   * @dev Verifies a Merkle proof proving the existence of a leaf in a Merkle tree. Assumes that each pair of leaves\r\n   * and each pair of pre-images is sorted.\r\n   * @param _proof Merkle proof containing sibling hashes on the branch from the leaf to the root of the Merkle tree\r\n   * @param _root Merkle root\r\n   * @param _leaf Leaf of Merkle tree\r\n   */\r\n  function verifyProof(bytes _proof, bytes32 _root, bytes32 _leaf) public pure returns (bool) {\r\n    // Check if proof length is a multiple of 32\r\n    if (_proof.length % 32 != 0) return false;\r\n\r\n    bytes32 proofElement;\r\n    bytes32 computedHash = _leaf;\r\n\r\n    for (uint256 i = 32; i <= _proof.length; i += 32) {\r\n      assembly {\r\n        // Load the current element of the proof\r\n        proofElement := mload(add(_proof, i))\r\n      }\r\n\r\n      if (computedHash < proofElement) {\r\n        // Hash(current computed hash + current element of the proof)\r\n        computedHash = keccak256(computedHash, proofElement);\r\n      } else {\r\n        // Hash(current element of the proof + current computed hash)\r\n        computedHash = keccak256(proofElement, computedHash);\r\n      }\r\n    }\r\n\r\n    // Check if the computed hash (root) is equal to the provided root\r\n    return computedHash == _root;\r\n  }\r\n}\r\n\r\n /**\r\n * @title Helps contracts guard agains rentrancy attacks.\r\n * @author Remco Bloemen <remco@2p.com>\r\n * @notice If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n\r\n  /**\r\n   * @dev We use a single lock for the whole contract.\r\n   */\r\n  bool private rentrancy_lock = false;\r\n\r\n  /**\r\n   * @dev Prevents a contract from calling itself, directly or indirectly.\r\n   * @notice If you mark a function `nonReentrant`, you should also\r\n   * mark it `external`. Calling one nonReentrant function from\r\n   * another is not supported. Instead, you can implement a\r\n   * `private` function doing the actual work, and a `external`\r\n   * wrapper marked as `nonReentrant`.\r\n   */\r\n  modifier nonReentrant() {\r\n    require(!rentrancy_lock);\r\n    rentrancy_lock = true;\r\n    _;\r\n    rentrancy_lock = false;\r\n  }\r\n\r\n}\r\n\r\n//Cornerstone TOKEN//\r\n\r\n/*Contract to Declare Owner*/\r\ncontract owned {\r\n    address public owner;\r\n\r\n    function owned() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) onlyOwner public {\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n/* Interfaces */\r\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }\r\n\r\n//Cornerstone Contract//\r\n\r\n/* Cornerstone Token Contract */\r\ncontract Cornerstone is owned{\r\n    // Public variables of the token\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    // 18 decimals is the strongly suggested default, avoid changing it\r\n    uint256 public totalSupply;\r\n\r\n    // This creates an array with all balances\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n    \r\n    // This creates an arroy for accounts to freeze\r\n    mapping (address => bool) public frozenAccount;\r\n\r\n    // This generates a public event on the blockchain that will notify clients\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    // This notifies clients about the amount burnt\r\n    event Burn(address indexed from, uint256 value);\r\n    \r\n    // This notifies clients of frozen account\r\n    event FrozenFunds(address target, bool frozen);\r\n\r\n    /**\r\n     * Constrctor function\r\n     *\r\n     * Initializes contract with initial supply tokens to the creator of the contract\r\n     */\r\n    function Cornerstone(\r\n        uint256 initialSupply,\r\n        string tokenName,\r\n        string tokenSymbol\r\n    ) public {\r\n        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount  // Update total supply with the decimal amount\r\n        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\r\n        name = tokenName;                                   // Set the name for display purposes\r\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\r\n    }\r\n    \r\n    function freezeAccount(address target, bool freeze) onlyOwner public{\r\n        frozenAccount[target] = freeze;\r\n        FrozenFunds(target, freeze);\r\n    }\r\n    \r\n    /**\r\n     * Internal transfer, only can be called by this contract\r\n     */\r\n    function _transfer(address _from, address _to, uint _value) internal {\r\n        // Prevent transfer to 0x0 address. Use burn() instead\r\n        require(_to != 0x0);\r\n        // Check if the sender has enough\r\n        require(balanceOf[_from] >= _value);\r\n        // Check for overflows\r\n        require(balanceOf[_to] + _value > balanceOf[_to]);\r\n        // Save this for an assertion in the future\r\n        // Check if sender is frozen\r\n        require(!frozenAccount[_from]);        \r\n        // Check if recipient is frozen\r\n        require(!frozenAccount[_to]);                      \r\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\r\n        // Subtract from the sender\r\n        balanceOf[_from] -= _value;\r\n        // Add the same to the recipient\r\n        balanceOf[_to] += _value;\r\n        Transfer(_from, _to, _value);\r\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\r\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\r\n    }\r\n\r\n    /**\r\n     * Transfer tokens\r\n     *\r\n     * Send `_value` tokens to `_to` from your account\r\n     *\r\n     * @param _to The address of the recipient\r\n     * @param _value the amount to send\r\n     */\r\n    function transfer(address _to, uint256 _value) public {\r\n        _transfer(msg.sender, _to, _value);\r\n    }\r\n\r\n    /**\r\n     * Transfer tokens from other address\r\n     *\r\n     * Send `_value` tokens to `_to` in behalf of `_from`\r\n     *\r\n     * @param _from The address of the sender\r\n     * @param _to The address of the recipient\r\n     * @param _value the amount to send\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\r\n        allowance[_from][msg.sender] -= _value;\r\n        _transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set allowance for other address\r\n     *\r\n     * Allows `_spender` to spend no more than `_value` tokens in your behalf\r\n     *\r\n     * @param _spender The address authorized to spend\r\n     * @param _value the max amount they can spend\r\n     */\r\n    function approve(address _spender, uint256 _value) public\r\n        returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set allowance for other address and notify\r\n     *\r\n     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\r\n     *\r\n     * @param _spender The address authorized to spend\r\n     * @param _value the max amount they can spend\r\n     * @param _extraData some extra information to send to the approved contract\r\n     */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\r\n        public\r\n        returns (bool success) {\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Destroy tokens\r\n     *\r\n     * Remove `_value` tokens from the system irreversibly\r\n     *\r\n     * @param _value the amount of money to burn\r\n     */\r\n    function burn(uint256 _value) public returns (bool success) {\r\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\r\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\r\n        totalSupply -= _value;                      // Updates totalSupply\r\n        Burn(msg.sender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Destroy tokens from other account\r\n     *\r\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\r\n     *\r\n     * @param _from the address of the sender\r\n     * @param _value the amount of money to burn\r\n     */\r\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\r\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\r\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\r\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\r\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\r\n        totalSupply -= _value;                              // Update totalSupply\r\n        Burn(_from, _value);\r\n        return true;\r\n    }\r\n}\r\n\r\n/* ADVANCED TOKEN  */\r\n\r\ncontract MyAdvancedToken is owned, Cornerstone {\r\n\r\n    uint256 public sellPrice;\r\n    uint256 public buyPrice;\r\n\r\n    mapping (address => bool) public frozenAccount;\r\n\r\n    /* This generates a public event on the blockchain that will notify clients */\r\n    event FrozenFunds(address target, bool frozen);\r\n\r\n    /* Initializes contract with initial supply tokens to the creator of the contract */\r\n    function MyAdvancedToken(\r\n        uint256 initialSupply,\r\n        string tokenName,\r\n        string tokenSymbol\r\n    ) Cornerstone(initialSupply, tokenName, tokenSymbol) public {}\r\n\r\n    /* Internal transfer, only can be called by this contract */\r\n    function _transfer(address _from, address _to, uint _value) internal {\r\n        require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead\r\n        require (balanceOf[_from] >= _value);               // Check if the sender has enough\r\n        require (balanceOf[_to] + _value > balanceOf[_to]); // Check for overflows\r\n        require(!frozenAccount[_from]);                     // Check if sender is frozen\r\n        require(!frozenAccount[_to]);                       // Check if recipient is frozen\r\n        balanceOf[_from] -= _value;                         // Subtract from the sender\r\n        balanceOf[_to] += _value;                           // Add the same to the recipient\r\n        Transfer(_from, _to, _value);\r\n    }\r\n\r\n    /// @notice Create `mintedAmount` tokens and send it to `target`\r\n    /// @param target Address to receive the tokens\r\n    /// @param mintedAmount the amount of tokens it will receive\r\n    function mintToken(address target, uint256 mintedAmount) onlyOwner public {\r\n        balanceOf[target] += mintedAmount;\r\n        totalSupply += mintedAmount;\r\n        Transfer(0, this, mintedAmount);\r\n        Transfer(this, target, mintedAmount);\r\n    }\r\n\r\n    /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens\r\n    /// @param target Address to be frozen\r\n    /// @param freeze either to freeze it or not\r\n    function freezeAccount(address target, bool freeze) onlyOwner public {\r\n        frozenAccount[target] = freeze;\r\n        FrozenFunds(target, freeze);\r\n    }\r\n\r\n    /// @notice Allow users to buy tokens for `newBuyPrice` eth and sell tokens for `newSellPrice` eth\r\n    /// @param newSellPrice Price the users can sell to the contract\r\n    /// @param newBuyPrice Price users can buy from the contract\r\n    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {\r\n        sellPrice = newSellPrice;\r\n        buyPrice = newBuyPrice;\r\n    }\r\n\r\n    /// @notice Buy tokens from contract by sending ether\r\n    function buy() payable public {\r\n        uint amount = msg.value / buyPrice;               // calculates the amount\r\n        _transfer(this, msg.sender, amount);              // makes the transfers\r\n    }\r\n\r\n    /// @notice Sell `amount` tokens to contract\r\n    /// @param amount amount of tokens to be sold\r\n    function sell(uint256 amount) public {\r\n        require(this.balance >= amount * sellPrice);      // checks if the contract has enough ether to buy\r\n        _transfer(msg.sender, this, amount);              // makes the transfers\r\n        msg.sender.transfer(amount * sellPrice);          // sends ether to the seller. It's important to do this last to avoid recursion attacks\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"frozenAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"freeze\",\"type\":\"bool\"}],\"name\":\"freezeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"initialSupply\",\"type\":\"uint256\"},{\"name\":\"tokenName\",\"type\":\"string\"},{\"name\":\"tokenSymbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"FrozenFunds\",\"type\":\"event\"}]","ContractName":"Cornerstone","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000989680000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000b436f726e657273746f6e65000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000343514e0000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://7a3849289cd9237fc4a7400825671541927ceeb34c94bdef4f098d91e4a500ee"}]}