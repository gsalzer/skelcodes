{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\n/**\r\n * EIP-20 token whose price (in ether terms) is always raising.\r\n * Hurry to invest early!\r\n */\r\ncontract RaisingToken {\r\n    /**\r\n     * Total number of tokens in circulation.\r\n     */\r\n    uint256 public totalSupply;\r\n\r\n    /**\r\n     * Maps address of token holder to the number of tokens currently belonging\r\n     * to this token holder.\r\n     */\r\n    mapping (address => uint256) public balanceOf;\r\n\r\n    /**\r\n     * Maps address of token holder and address of spender to the number of\r\n     * tokens this spender is allowed to transfer from this token holder.\r\n     */\r\n    mapping (address => mapping (address => uint256)) allowance;\r\n\r\n    /**\r\n     * Deploy RaisingToken smart contract, issue one token and sell it to\r\n     * message sender for ether provided.\r\n     */\r\n    function RaisingToken () public payable {\r\n        // Make sure some ether was provided\r\n        require (msg.value > 0);\r\n\r\n        // Issue one token...\r\n        totalSupply = 1;\r\n\r\n        // ... and give it to message sender\r\n        balanceOf [msg.sender] = 1;\r\n\r\n        // Log token creation\r\n        Transfer (address (0), msg.sender, 1);\r\n    }\r\n\r\n    /**\r\n     * Issue and buy more tokens.\r\n     */\r\n    function buy() public payable {\r\n        // Calculate number of token that could be bought for ether provided\r\n        uint256 count = msg.value * totalSupply / this.balance;\r\n\r\n        // Proceed only if some tokens could actually be bought.\r\n        require (count > 0);\r\n\r\n        // Issue tokens ...        \r\n        totalSupply += count;\r\n\r\n        // ... and give them to message sender\r\n        balanceOf [msg.sender] += count;\r\n\r\n        // Log token creation\r\n        Transfer (address (0), msg.sender, count);\r\n    }\r\n\r\n    /**\r\n     * Sell and burn given number of tokens.\r\n     *\r\n     * @param _value number of tokens to sell\r\n     * @return true if tokens were sold successfully, false otherwise\r\n     */\r\n    function sell(uint256 _value) public returns (bool) {\r\n        // Proceed only if\r\n        // 1. Number of tokens to be sold is non-zero\r\n        // 2. Some tokens will still exist after burning tokens to be sold\r\n        // 3. Message sender has enough tokens to sell\r\n        if (_value > 0 &&\r\n            _value < totalSupply &&\r\n            _value <= balanceOf [msg.sender]) {\r\n            // Calculate amount of ether to be sent to seller\r\n            uint256 toSend = _value * this.balance / totalSupply;\r\n\r\n            // If we failed to send ether to seller ...\r\n            if (!msg.sender.send (toSend))\r\n                return false; // ... report failure\r\n\r\n            // Take tokens from seller ...\r\n            balanceOf [msg.sender] -= _value;\r\n\r\n            // ... and burn them\r\n            totalSupply -= _value;\r\n\r\n            // Log token burning\r\n            Transfer (msg.sender, address (0), _value);\r\n\r\n            // Report success\r\n            return true;\r\n        } else return false; // Report failure\r\n    }\r\n\r\n    /**\r\n     * Get token name.\r\n     * \r\n     * @return token name\r\n     */\r\n    function name() public pure returns (string) {\r\n        return \"RaisingToken\";\r\n    }\r\n\r\n    /**\r\n     * Get token symbol.\r\n     * \r\n     * @return token symbol\r\n     */\r\n    function symbol() public pure returns (string) {\r\n        return \"RAT\";\r\n    }\r\n\r\n    /**\r\n     * Get token decimals.\r\n     * \r\n     * @return token decimals\r\n     */\r\n    function decimals() public pure returns (uint8) {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Transfer given number of tokens from message sender to the owner of given\r\n     * address.  Charge commission of 1 token and burn it.\r\n     *\r\n     * @param _to address to send tokens to the owner of\r\n     * @param _value number of token to send (recepient will get one less)\r\n     * @return true if tokens were sent successfully, false otherwise\r\n     */\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        // Proceed only if\r\n        // 1. There are more than 1 tokens being transferred\r\n        // 2. Message sender has enough tokens\r\n        if (_value > 1 && _value >= balanceOf [msg.sender]) {\r\n            // Take tokens from message sender\r\n            balanceOf [msg.sender] -= _value;\r\n\r\n            // Decrement transfer value by one\r\n            _value -= 1;\r\n\r\n            // Give tokens to recipient\r\n            balanceOf [_to] += _value;\r\n\r\n            // Burn commission\r\n            totalSupply -= 1;\r\n\r\n            // Log token transfer\r\n            Transfer (msg.sender, _to, _value);\r\n\r\n            // Log token burning\r\n            Transfer (msg.sender, address (0), 1);\r\n\r\n            // Report success\r\n            return true;\r\n        } else return false; // Report failure\r\n    }\r\n\r\n    /**\r\n     * Transfer given number of tokens from the owner of given sender address to\r\n     * the owner of given destination address.  Owner of sender address should\r\n     * approve transfer in advance.  Charge commission of 1 token and burn it.\r\n     *\r\n     * @param _from source address\r\n     * @param _to destination address\r\n     * @param _value number of tokens to transfer (recipient will receive one\r\n     *        less)\r\n     * @return true if tokens were sent successfully, false otherwise\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value)\r\n        public returns (bool) {\r\n        // Proceed only If\r\n        // 1. There are more than 1 tokens being transferred\r\n        // 2. Transfer is approved by the owner of source address\r\n        // 3. The owner of source address has enough tokens\r\n        if (_value > 1 &&\r\n            _value >= allowance [_from][msg.sender] &&\r\n            _value >= balanceOf [_from]) {\r\n            // Reduce number of tokens message sender is allowed to transfer\r\n            // from the owner of source address\r\n            allowance [_from][msg.sender] -= _value;\r\n\r\n            // Take tokens from the owner of source address\r\n            balanceOf [_from] -= _value;\r\n\r\n            // Decrement transfer value by one\r\n            _value -= 1;\r\n\r\n            // Give tokens to the owner of destination address\r\n            balanceOf [_to] += _value;\r\n    \r\n            // Burn commission\r\n            totalSupply -= 1;\r\n    \r\n            // Log token transfer\r\n            Transfer (_from, _to, _value);\r\n\r\n            // Log token burning\r\n            Transfer (_from, address (0), 1);\r\n    \r\n            // Report success\r\n            return true;\r\n        } else return false; // Report failure\r\n    }\r\n\r\n    /**\r\n     * Allow owher of given spender address to transfer at most given number of\r\n     * tokens from message sender.\r\n     *\r\n     * @param _spender address to allow transfer for the owner of\r\n     * @param _value number of tokens to allow transfer of\r\n     * @return true if transfer was approved successfully, false otherwise\r\n     */\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        // Approve token transfer\r\n        allowance [msg.sender][_spender] = _value;\r\n\r\n        // Log transfer approval\r\n        Approval (msg.sender, _spender, _value);\r\n    }\r\n\r\n    /**\r\n     * Logged when tokens were transferred, created, or burned.\r\n     *\r\n     * @param _from address tokens were transferred from or zero if tokens were\r\n     *        created\r\n     * @param _to address tokens were transferred to or zero if tokens were\r\n     *        burned\r\n     * @param _value number of tokens transferred, created, or burned\r\n     */\r\n    event Transfer(\r\n        address indexed _from, address indexed _to, uint256 _value);\r\n\r\n    /**\r\n     * Logged when token transfer was approved.\r\n     *\r\n     * @param _owner address of the owner of tokens approved to be transferred\r\n     * @param _spender spender approved to transfer tokens\r\n     * @param _value number of tokens approved to be trasferred\r\n     */\r\n    event Approval(\r\n        address indexed _owner, address indexed _spender, uint256 _value);\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"RaisingToken","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://b3409931ea26ff8067e77b7ab6671c6dd32974ef2533905b1461cc6ce1972adb"}]}