{"status":"1","message":"OK","result":[{"SourceCode":"contract SafeMath {\r\n    \r\n    uint256 constant MAX_UINT256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n    function safeAdd(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        require(x <= MAX_UINT256 - y);\r\n        return x + y;\r\n    }\r\n\r\n    function safeSub(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        require(x >= y);\r\n        return x - y;\r\n    }\r\n\r\n    function safeMul(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        if (y == 0) {\r\n            return 0;\r\n        }\r\n        require(x <= (MAX_UINT256 / y));\r\n        return x * y;\r\n    }\r\n}\r\n\r\ncontract ReentrancyHandlingContract{\r\n\r\n    bool locked;\r\n\r\n    modifier noReentrancy() {\r\n        require(!locked);\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n}\r\n\r\ncontract Owned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    function Owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != owner);\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = 0x0;\r\n    }\r\n\r\n    event OwnerUpdate(address _prevOwner, address _newOwner);\r\n}\r\n\r\ncontract Lockable is Owned {\r\n\r\n    uint256 public lockedUntilBlock;\r\n\r\n    event ContractLocked(uint256 _untilBlock, string _reason);\r\n\r\n    modifier lockAffected {\r\n        require(block.number > lockedUntilBlock);\r\n        _;\r\n    }\r\n\r\n    function lockFromSelf(uint256 _untilBlock, string _reason) internal {\r\n        lockedUntilBlock = _untilBlock;\r\n        ContractLocked(_untilBlock, _reason);\r\n    }\r\n\r\n\r\n    function lockUntil(uint256 _untilBlock, string _reason) onlyOwner public {\r\n        lockedUntilBlock = _untilBlock;\r\n        ContractLocked(_untilBlock, _reason);\r\n    }\r\n}\r\n\r\ncontract ERC20TokenInterface {\r\n  function totalSupply() public constant returns (uint256 _totalSupply);\r\n  function balanceOf(address _owner) public constant returns (uint256 balance);\r\n  function transfer(address _to, uint256 _value) public returns (bool success);\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n  function approve(address _spender, uint256 _value) public returns (bool success);\r\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract InsurePalTokenInterface {\r\n    function mint(address _to, uint256 _amount) public;\r\n}\r\n\r\ncontract tokenRecipientInterface {\r\n  function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData);\r\n}\r\n\r\ncontract KycContractInterface {\r\n    function isAddressVerified(address _address) public view returns (bool);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract KycContract is Owned {\r\n    \r\n    mapping (address => bool) verifiedAddresses;\r\n    \r\n    function isAddressVerified(address _address) public view returns (bool) {\r\n        return verifiedAddresses[_address];\r\n    }\r\n    \r\n    function addAddress(address _newAddress) public onlyOwner {\r\n        require(!verifiedAddresses[_newAddress]);\r\n        \r\n        verifiedAddresses[_newAddress] = true;\r\n    }\r\n    \r\n    function removeAddress(address _oldAddress) public onlyOwner {\r\n        require(verifiedAddresses[_oldAddress]);\r\n        \r\n        verifiedAddresses[_oldAddress] = false;\r\n    }\r\n    \r\n    function batchAddAddresses(address[] _addresses) public onlyOwner {\r\n        for (uint cnt = 0; cnt < _addresses.length; cnt++) {\r\n            assert(!verifiedAddresses[_addresses[cnt]]);\r\n            verifiedAddresses[_addresses[cnt]] = true;\r\n        }\r\n    }\r\n    \r\n    function salvageTokensFromContract(address _tokenAddress, address _to, uint _amount) public onlyOwner{\r\n        ERC20TokenInterface(_tokenAddress).transfer(_to, _amount);\r\n    }\r\n    \r\n    function killContract() public onlyOwner {\r\n        selfdestruct(owner);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Crowdsale is ReentrancyHandlingContract, Owned {\r\n\r\n  struct ContributorData {\r\n    uint contributionAmount;\r\n    uint tokensIssued;\r\n  }\r\n\r\n  mapping(address => ContributorData) public contributorList;\r\n  uint nextContributorIndex;\r\n  mapping(uint => address) contributorIndexes;\r\n\r\n  state public crowdsaleState = state.pendingStart;\r\n  enum state { pendingStart, crowdsale, crowdsaleEnded }\r\n\r\n  uint public crowdsaleStartBlock;\r\n  uint public crowdsaleEndedBlock;\r\n\r\n  event CrowdsaleStarted(uint blockNumber);\r\n  event CrowdsaleEnded(uint blockNumber);\r\n  event ErrorSendingETH(address to, uint amount);\r\n  event MinCapReached(uint blockNumber);\r\n  event MaxCapReached(uint blockNumber);\r\n\r\n  address tokenAddress = 0x0;\r\n  address kycAddress = 0x0;\r\n  uint decimals = 18;\r\n\r\n  uint public minCap; //InTokens\r\n  uint public maxCap; //InTokens\r\n  uint public ethRaised;\r\n  uint public tokenTotalSupply = 300000000 * 10**decimals;\r\n  uint public tokensIssued = 0;\r\n\r\n  address public multisigAddress;\r\n  uint blocksInADay;\r\n\r\n  uint nextContributorToClaim;\r\n  mapping(address => bool) hasClaimedEthWhenFail;\r\n\r\n  uint crowdsaleTokenCap =          201000000 * 10**decimals;\r\n  uint founders =                    30000000 * 10**decimals;\r\n  uint insurePalTeam =               18000000 * 10**decimals;\r\n  uint tcsSupportTeam =              18000000 * 10**decimals;\r\n  uint advisorsAndAmbassadors =      18000000 * 10**decimals;\r\n  uint incentives =                   9000000 * 10**decimals;\r\n  uint earlyInvestors =               6000000 * 10**decimals;\r\n  bool foundersTokensClaimed = false;\r\n  bool insurePalTeamTokensClaimed = false;\r\n  bool tcsSupportTeamTokensClaimed = false;\r\n  bool advisorsAndAmbassadorsTokensClaimed = false;\r\n  bool incentivesTokensClaimed = false;\r\n  bool earlyInvestorsTokensClaimed = false;\r\n\r\n  //\r\n  // Unnamed function that runs when eth is sent to the contract\r\n  //\r\n  function() noReentrancy payable public {\r\n    require(msg.value != 0);                        // Throw if value is 0\r\n    require(crowdsaleState != state.crowdsaleEnded);// Check if crowdsale has ended\r\n    require(KycContractInterface(kycAddress).isAddressVerified(msg.sender));\r\n\r\n    bool stateChanged = checkCrowdsaleState();      // Check blocks and calibrate crowdsale state\r\n\r\n    if (crowdsaleState == state.crowdsale) {\r\n      processTransaction(msg.sender, msg.value);    // Process transaction and issue tokens\r\n    } else {\r\n      refundTransaction(stateChanged);              // Set state and return funds or throw\r\n    }\r\n  }\r\n\r\n  //\r\n  // Check crowdsale state and calibrate it\r\n  //\r\n  function checkCrowdsaleState() internal returns (bool) {\r\n    if (tokensIssued == maxCap && crowdsaleState != state.crowdsaleEnded) {                     // Check if max cap is reached\r\n      crowdsaleState = state.crowdsaleEnded;\r\n      CrowdsaleEnded(block.number);                                                             // Raise event\r\n      return true;\r\n    }\r\n\r\n    if (block.number >= crowdsaleStartBlock && block.number <= crowdsaleEndedBlock) {            // Check if we are in crowdsale state\r\n      if (crowdsaleState != state.crowdsale) {                                                  // Check if state needs to be changed\r\n        crowdsaleState = state.crowdsale;                                                       // Set new state\r\n        CrowdsaleStarted(block.number);                                                         // Raise event\r\n        return true;\r\n      }\r\n    } else {\r\n      if (crowdsaleState != state.crowdsaleEnded && block.number > crowdsaleEndedBlock) {       // Check if crowdsale is over\r\n        crowdsaleState = state.crowdsaleEnded;                                                  // Set new state\r\n        CrowdsaleEnded(block.number);                                                           // Raise event\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  //\r\n  // Decide if throw or only return ether\r\n  //\r\n  function refundTransaction(bool _stateChanged) internal {\r\n    if (_stateChanged) {\r\n      msg.sender.transfer(msg.value);\r\n    } else {\r\n      revert();\r\n    }\r\n  }\r\n\r\n  function calculateEthToToken(uint _eth, uint _blockNumber) constant public returns(uint) {\r\n    if (_blockNumber < crowdsaleStartBlock + blocksInADay * 4) {\r\n      return _eth * 12817;\r\n    }\r\n    if (_eth >= 50*10**decimals) {\r\n      return _eth * 12817;\r\n    }\r\n    if (_blockNumber > crowdsaleStartBlock) {\r\n      return _eth * 11652;\r\n    }\r\n  }\r\n\r\n  function calculateTokenToEth(uint _token, uint _blockNumber) constant public returns(uint) {\r\n    if (_blockNumber < crowdsaleStartBlock + blocksInADay * 4) {\r\n      return _token * 10000 / 12817;\r\n    }\r\n    if (_token >= 50*12817*10**decimals) {\r\n      return _token * 10000 / 12817;\r\n    }\r\n    if (_blockNumber > crowdsaleStartBlock) {\r\n      return _token * 10000 / 11652;\r\n    }\r\n  }\r\n\r\n  //\r\n  // Issue tokens and return if there is overflow\r\n  //\r\n\r\n  function processTransaction(address _contributor, uint _amount) internal {\r\n    uint contributionAmount = _amount;\r\n    uint returnAmount = 0;\r\n    uint tokensToGive = calculateEthToToken(contributionAmount, block.number);\r\n\r\n    if (tokensToGive > (maxCap - tokensIssued)) {                                     // Check if max contribution is lower than _amount sent\r\n      contributionAmount = calculateTokenToEth(maxCap - tokensIssued, block.number) / 10000;  // Set that user contibutes his maximum alowed contribution\r\n      returnAmount = _amount - contributionAmount;                                    // Calculate howmuch he must get back\r\n      tokensToGive = maxCap - tokensIssued;\r\n      MaxCapReached(block.number);\r\n    }\r\n\r\n    if (contributorList[_contributor].contributionAmount == 0) {\r\n        contributorIndexes[nextContributorIndex] = _contributor;\r\n        nextContributorIndex += 1;\r\n    }\r\n\r\n    contributorList[_contributor].contributionAmount += contributionAmount;\r\n    ethRaised += contributionAmount;                                              // Add to eth raised\r\n\r\n    if (tokensToGive > 0) {\r\n      InsurePalTokenInterface(tokenAddress).mint(_contributor, tokensToGive);       // Issue new tokens\r\n      contributorList[_contributor].tokensIssued += tokensToGive;                  // log token issuance\r\n      tokensIssued += tokensToGive;\r\n    }\r\n    if (returnAmount != 0) {\r\n      _contributor.transfer(returnAmount);\r\n    } \r\n  }\r\n\r\n  function pushAngelInvestmentData(address _address, uint _ethContributed) onlyOwner public {\r\n      processTransaction(_address, _ethContributed);\r\n  }\r\n\r\n  function depositAngelInvestmentEth() payable onlyOwner public {}\r\n  \r\n\r\n  //\r\n  // Method is needed for recovering tokens accedentaly sent to token address\r\n  //\r\n  function salvageTokensFromContract(address _tokenAddress, address _to, uint _amount) onlyOwner public {\r\n    ERC20TokenInterface(_tokenAddress).transfer(_to, _amount);\r\n  }\r\n\r\n  //\r\n  // withdrawEth when minimum cap is reached\r\n  //\r\n  function withdrawEth() onlyOwner public {\r\n    require(this.balance != 0);\r\n    require(tokensIssued >= minCap);\r\n\r\n    multisigAddress.transfer(this.balance);\r\n  }\r\n\r\n  //\r\n  // Users can claim their contribution if min cap is not raised\r\n  //\r\n  function claimEthIfFailed() public {\r\n    require(block.number > crowdsaleEndedBlock && tokensIssued < minCap);    // Check if crowdsale has failed\r\n    require(contributorList[msg.sender].contributionAmount > 0);          // Check if contributor has contributed to crowdsaleEndedBlock\r\n    require(!hasClaimedEthWhenFail[msg.sender]);                          // Check if contributor has already claimed his eth\r\n\r\n    uint ethContributed = contributorList[msg.sender].contributionAmount; // Get contributors contribution\r\n    hasClaimedEthWhenFail[msg.sender] = true;                             // Set that he has claimed\r\n    if (!msg.sender.send(ethContributed)) {                                // Refund eth\r\n      ErrorSendingETH(msg.sender, ethContributed);                        // If there is an issue raise event for manual recovery\r\n    }\r\n  }\r\n\r\n  //\r\n  // Owner can batch return contributors contributions(eth)\r\n  //\r\n  function batchReturnEthIfFailed(uint _numberOfReturns) onlyOwner public {\r\n    require(block.number > crowdsaleEndedBlock && tokensIssued < minCap);                // Check if crowdsale has failed\r\n    address currentParticipantAddress;\r\n    uint contribution;\r\n    for (uint cnt = 0; cnt < _numberOfReturns; cnt++) {\r\n      currentParticipantAddress = contributorIndexes[nextContributorToClaim];         // Get next unclaimed participant\r\n      if (currentParticipantAddress == 0x0) {\r\n        return;                                                                       // Check if all the participants were compensated\r\n      }\r\n      if (!hasClaimedEthWhenFail[currentParticipantAddress]) {                        // Check if participant has already claimed\r\n        contribution = contributorList[currentParticipantAddress].contributionAmount; // Get contribution of participant\r\n        hasClaimedEthWhenFail[currentParticipantAddress] = true;                      // Set that he has claimed\r\n        if (!currentParticipantAddress.send(contribution)) {                          // Refund eth\r\n          ErrorSendingETH(currentParticipantAddress, contribution);                   // If there is an issue raise event for manual recovery\r\n        }\r\n      }\r\n      nextContributorToClaim += 1;                                                    // Repeat\r\n    }\r\n  }\r\n\r\n  //\r\n  // If there were any issue/attach with refund owner can withraw eth at the end for manual recovery\r\n  //\r\n  function withdrawRemainingBalanceForManualRecovery() onlyOwner public {\r\n    require(this.balance != 0);                                  // Check if there are any eth to claim\r\n    require(block.number > crowdsaleEndedBlock);                 // Check if crowdsale is over\r\n    require(contributorIndexes[nextContributorToClaim] == 0x0);  // Check if all the users were refunded\r\n    multisigAddress.transfer(this.balance);                      // Withdraw to multisig\r\n  }\r\n\r\n  function claimTeamTokens(address _to, uint _choice) onlyOwner public {\r\n    require(crowdsaleState == state.crowdsaleEnded);\r\n    require(tokensIssued >= minCap);\r\n\r\n    uint mintAmount;\r\n    if (_choice == 1) {\r\n      assert(!insurePalTeamTokensClaimed);\r\n      mintAmount = insurePalTeam;\r\n      insurePalTeamTokensClaimed = true;\r\n    } else if (_choice == 2) {\r\n      assert(!tcsSupportTeamTokensClaimed);\r\n      mintAmount = tcsSupportTeam;\r\n      tcsSupportTeamTokensClaimed = true;\r\n    } else if (_choice == 3) {\r\n      assert(!advisorsAndAmbassadorsTokensClaimed);\r\n      mintAmount = advisorsAndAmbassadors;\r\n      advisorsAndAmbassadorsTokensClaimed = true;\r\n    } else if (_choice == 4) {\r\n      assert(!incentivesTokensClaimed);\r\n      mintAmount = incentives;\r\n      incentivesTokensClaimed = true;\r\n    } else if (_choice == 5) {\r\n      assert(!earlyInvestorsTokensClaimed);\r\n      mintAmount = earlyInvestors;\r\n      earlyInvestorsTokensClaimed = true;\r\n    } else if (_choice == 6) {\r\n      assert(!foundersTokensClaimed);\r\n      assert(insurePalTeamTokensClaimed);\r\n      assert(tcsSupportTeamTokensClaimed);\r\n      assert(advisorsAndAmbassadorsTokensClaimed);\r\n      assert(incentivesTokensClaimed);\r\n      assert(earlyInvestorsTokensClaimed);\r\n      assert(tokenTotalSupply > ERC20TokenInterface(tokenAddress).totalSupply());\r\n      mintAmount = tokenTotalSupply - ERC20TokenInterface(tokenAddress).totalSupply();\r\n      foundersTokensClaimed = true;\r\n    } else {\r\n      revert();\r\n    }\r\n    InsurePalTokenInterface(tokenAddress).mint(_to, mintAmount);\r\n  }\r\n\r\n  //\r\n  // Owner can set multisig address for crowdsale\r\n  //\r\n  function setMultisigAddress(address _newAddress) onlyOwner public {\r\n    multisigAddress = _newAddress;\r\n  }\r\n\r\n  //\r\n  // Owner can set token address where mints will happen\r\n  //\r\n  function setToken(address _newAddress) onlyOwner public {\r\n    tokenAddress = _newAddress;\r\n  }\r\n\r\n  function setKycAddress(address _newAddress) onlyOwner public {\r\n    kycAddress = _newAddress;\r\n  }\r\n\r\n  function getTokenAddress() constant public returns(address) {\r\n    return tokenAddress;\r\n  }\r\n\r\n  function investorCount() constant public returns(uint) {\r\n    return nextContributorIndex;\r\n  }\r\n\r\n  function setCrowdsaleStartBlock(uint _block) onlyOwner public {\r\n    crowdsaleStartBlock = _block;\r\n  }\r\n}\r\n\r\n\r\n\r\ncontract InsurePalCrowdsale is Crowdsale {\r\n  \r\n  function InsurePalCrowdsale() {\r\n\r\n    crowdsaleStartBlock = 4918135;\r\n    crowdsaleEndedBlock = 5031534; \r\n\r\n    minCap = 50000000 * 10**18;\r\n    maxCap = 201000000 * 10**18;\r\n\r\n    blocksInADay = 5400;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"setMultisigAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleEndedBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawRemainingBalanceForManualRecovery\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_eth\",\"type\":\"uint256\"},{\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"calculateEthToToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multisigAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensIssued\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimEthIfFailed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_numberOfReturns\",\"type\":\"uint256\"}],\"name\":\"batchReturnEthIfFailed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"setKycAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"uint256\"},{\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"calculateTokenToEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_choice\",\"type\":\"uint256\"}],\"name\":\"claimTeamTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"contributorList\",\"outputs\":[{\"name\":\"contributionAmount\",\"type\":\"uint256\"},{\"name\":\"tokensIssued\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"salvageTokensFromContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"setCrowdsaleStartBlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleStartBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investorCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"depositAngelInvestmentEth\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_ethContributed\",\"type\":\"uint256\"}],\"name\":\"pushAngelInvestmentData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenTotalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"CrowdsaleStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"CrowdsaleEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ErrorSendingETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"MinCapReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"MaxCapReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_prevOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdate\",\"type\":\"event\"}]","ContractName":"InsurePalCrowdsale","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://d0035428eba954ed9ee18e0b920bc947cbf23c730c23939aaf4b9975e7f48c62"}]}