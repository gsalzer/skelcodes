{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.15;\r\n\r\ncontract MultiOwner {\r\n    /* Constructor */\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n\tevent RequirementChanged(uint256 newRequirement);\r\n\t\r\n    uint256 public ownerRequired;\r\n    mapping (address => bool) public isOwner;\r\n\tmapping (address => bool) public RequireDispose;\r\n\taddress[] owners;\r\n\t\r\n\tfunction MultiOwner(address[] _owners, uint256 _required) public {\r\n        ownerRequired = _required;\r\n        isOwner[msg.sender] = true;\r\n        owners.push(msg.sender);\r\n        \r\n        for (uint256 i = 0; i < _owners.length; ++i){\r\n\t\t\trequire(!isOwner[_owners[i]]);\r\n\t\t\tisOwner[_owners[i]] = true;\r\n\t\t\towners.push(_owners[i]);\r\n        }\r\n    }\r\n    \r\n\tmodifier onlyOwner {\r\n\t    require(isOwner[msg.sender]);\r\n        _;\r\n    }\r\n    \r\n\tmodifier ownerDoesNotExist(address owner) {\r\n\t\trequire(!isOwner[owner]);\r\n        _;\r\n    }\r\n\r\n    modifier ownerExists(address owner) {\r\n\t\trequire(isOwner[owner]);\r\n        _;\r\n    }\r\n    \r\n    function addOwner(address owner) onlyOwner ownerDoesNotExist(owner) external{\r\n        isOwner[owner] = true;\r\n        owners.push(owner);\r\n        OwnerAdded(owner);\r\n    }\r\n    \r\n\tfunction numberOwners() public constant returns (uint256 NumberOwners){\r\n\t    NumberOwners = owners.length;\r\n\t}\r\n\t\r\n    function removeOwner(address owner) onlyOwner ownerExists(owner) external{\r\n\t\trequire(owners.length > 2);\r\n        isOwner[owner] = false;\r\n\t\tRequireDispose[owner] = false;\r\n        for (uint256 i=0; i<owners.length - 1; i++){\r\n            if (owners[i] == owner) {\r\n\t\t\t\towners[i] = owners[owners.length - 1];\r\n                break;\r\n            }\r\n\t\t}\r\n\t\towners.length -= 1;\r\n        OwnerRemoved(owner);\r\n    }\r\n    \r\n\tfunction changeRequirement(uint _newRequired) onlyOwner external {\r\n\t\trequire(_newRequired >= owners.length);\r\n        ownerRequired = _newRequired;\r\n        RequirementChanged(_newRequired);\r\n    }\r\n\t\r\n\tfunction ConfirmDispose() onlyOwner() constant returns (bool){\r\n\t\tuint count = 0;\r\n\t\tfor (uint i=0; i<owners.length - 1; i++)\r\n            if (RequireDispose[owners[i]])\r\n                count += 1;\r\n            if (count == ownerRequired)\r\n                return true;\r\n\t}\r\n\t\r\n\tfunction kill() onlyOwner(){\r\n\t\tRequireDispose[msg.sender] = true;\r\n\t\tif(ConfirmDispose()){\r\n\t\t\tselfdestruct(msg.sender);\r\n\t\t}\r\n    }\r\n}\r\n\r\ncontract VVToken is MultiOwner{\r\n\tevent SubmitTransaction(bytes32 transactionHash);\r\n\tevent Confirmation(address sender, bytes32 transactionHash);\r\n\tevent Execution(bytes32 transactionHash);\r\n\tevent FrozenFunds(address target, bool frozen);\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\tevent VoidAccount(address indexed from, address indexed to, uint256 value);\r\n\t\r\n\tstring public name = \"VV Coin\";\r\n\tstring public symbol = \"VVC\";\r\n\tuint8 public decimals = 8;\r\n\tuint256 public totalSupply = 3000000000 * 10 ** uint256(decimals);\r\n\tuint256 public EthPerToken = 300;\r\n\t\r\n\tmapping(address => uint256) public balanceOf;\r\n\tmapping(address => bool) public frozenAccount;\r\n\tmapping (bytes32 => mapping (address => bool)) public Confirmations;\r\n\tmapping (bytes32 => Transaction) public Transactions;\r\n\t\r\n\tstruct Transaction {\r\n\t\taddress destination;\r\n\t\tuint value;\r\n\t\tbytes data;\r\n\t\tbool executed;\r\n    }\r\n\t\r\n\tmodifier notNull(address destination) {\r\n\t\trequire (destination != 0x0);\r\n        _;\r\n    }\r\n\t\r\n\tmodifier confirmed(bytes32 transactionHash) {\r\n\t\trequire (Confirmations[transactionHash][msg.sender]);\r\n        _;\r\n    }\r\n\r\n    modifier notConfirmed(bytes32 transactionHash) {\r\n\t\trequire (!Confirmations[transactionHash][msg.sender]);\r\n        _;\r\n    }\r\n\t\r\n\tmodifier notExecuted(bytes32 TransHash) {\r\n\t\trequire (!Transactions[TransHash].executed);\r\n        _;\r\n    }\r\n    \r\n\tfunction VVToken(address[] _owners, uint256 _required) MultiOwner(_owners, _required) public {\r\n\t\tbalanceOf[msg.sender] = totalSupply;                    \r\n    }\r\n\t\r\n\t/* Internal transfer, only can be called by this contract */\r\n    function _transfer(address _from, address _to, uint256 _value) internal {\r\n        require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead\r\n        require (balanceOf[_from] >= _value);                // Check if the sender has enough\r\n        require (balanceOf[_to] + _value >= balanceOf[_to]); // Check for overflows\r\n        require(!frozenAccount[_from]);                     // Check if sender is frozen\r\n\t\tuint256 previousBalances = balanceOf[_from] + balanceOf[_to];\r\n        balanceOf[_from] -= _value;                         // Subtract from the sender\r\n        balanceOf[_to] += _value;                           // Add the same to the recipient\r\n        Transfer(_from, _to, _value);\r\n\t\tassert(balanceOf[_from] + balanceOf[_to] == previousBalances);\r\n    }\r\n\t\r\n\tfunction transfer(address _to, uint256 _value) public {\r\n\t\t_transfer(msg.sender, _to, _value);\r\n\t}\r\n\t\r\n\tfunction setPrices(uint256 newValue) onlyOwner public {\r\n        EthPerToken = newValue;\r\n    }\r\n    \r\n    function freezeAccount(address target, bool freeze) onlyOwner public {\r\n        frozenAccount[target] = freeze;\r\n        FrozenFunds(target, freeze);\r\n    }\r\n\t\r\n\tfunction() payable {\r\n\t\trevert();\r\n    }\r\n\t\r\n\tfunction remainBalanced() public constant returns (uint256){\r\n        return balanceOf[this];\r\n    }\r\n\t\r\n\t/*Transfer Eth */\r\n\tfunction execute(address _to, uint _value, bytes _data) notNull(_to) onlyOwner external returns (bytes32 _r) {\r\n\t\t_r = addTransaction(_to, _value, _data);\r\n\t\tconfirmTransaction(_r);\r\n    }\r\n\t\r\n\tfunction addTransaction(address destination, uint value, bytes data) private notNull(destination) returns (bytes32 TransHash){\r\n        TransHash = sha3(destination, value, data);\r\n        if (Transactions[TransHash].destination == 0) {\r\n            Transactions[TransHash] = Transaction({\r\n                destination: destination,\r\n                value: value,\r\n                data: data,\r\n                executed: false\r\n            });\r\n            SubmitTransaction(TransHash);\r\n        }\r\n    }\r\n\t\r\n\tfunction addConfirmation(bytes32 TransHash) private onlyOwner notConfirmed(TransHash){\r\n        Confirmations[TransHash][msg.sender] = true;\r\n        Confirmation(msg.sender, TransHash);\r\n    }\r\n\t\r\n\tfunction isConfirmed(bytes32 TransHash) public constant returns (bool){\r\n        uint count = 0;\r\n        for (uint i=0; i<owners.length; i++)\r\n            if (Confirmations[TransHash][owners[i]])\r\n                count += 1;\r\n            if (count == ownerRequired)\r\n                return true;\r\n    }\r\n\t\r\n\tfunction confirmationCount(bytes32 TransHash) external constant returns (uint count){\r\n        for (uint i=0; i<owners.length; i++)\r\n            if (Confirmations[TransHash][owners[i]])\r\n                count += 1;\r\n    }\r\n    \r\n    function confirmTransaction(bytes32 TransHash) public onlyOwner(){\r\n        addConfirmation(TransHash);\r\n        executeTransaction(TransHash);\r\n    }\r\n    \r\n    function executeTransaction(bytes32 TransHash) public notExecuted(TransHash){\r\n        if (isConfirmed(TransHash)) {\r\n\t\t\tTransactions[TransHash].executed = true;\r\n            require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data));\r\n            Execution(TransHash);\r\n        }\r\n    }\r\n\t\r\n\tfunction AccountVoid(address _from) onlyOwner public{\r\n\t\trequire (balanceOf[_from] > 0); \r\n\t\tuint256 CurrentBalances = balanceOf[_from];\r\n\t\tuint256 previousBalances = balanceOf[_from] + balanceOf[msg.sender];\r\n        balanceOf[_from] -= CurrentBalances;                         \r\n        balanceOf[msg.sender] += CurrentBalances;\r\n\t\tVoidAccount(_from, msg.sender, CurrentBalances);\r\n\t\tassert(balanceOf[_from] + balanceOf[msg.sender] == previousBalances);\t\r\n\t}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"AccountVoid\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ConfirmDispose\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"Transactions\",\"outputs\":[{\"name\":\"destination\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"executed\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"TransHash\",\"type\":\"bytes32\"}],\"name\":\"confirmationCount\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"TransHash\",\"type\":\"bytes32\"}],\"name\":\"isConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOwners\",\"outputs\":[{\"name\":\"NumberOwners\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"TransHash\",\"type\":\"bytes32\"}],\"name\":\"confirmTransaction\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"remainBalanced\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"setPrices\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerRequired\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"RequireDispose\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"frozenAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"TransHash\",\"type\":\"bytes32\"}],\"name\":\"executeTransaction\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"Confirmations\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"freeze\",\"type\":\"bool\"}],\"name\":\"freezeAccount\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"EthPerToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"transactionHash\",\"type\":\"bytes32\"}],\"name\":\"SubmitTransaction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"transactionHash\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"transactionHash\",\"type\":\"bytes32\"}],\"name\":\"Execution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"FrozenFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"VoidAccount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"}]","ContractName":"VVToken","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://3c8d2d268c04642e8e4953fd4b3e7690c178100557c834e3cc18df661b96ed4e"}]}