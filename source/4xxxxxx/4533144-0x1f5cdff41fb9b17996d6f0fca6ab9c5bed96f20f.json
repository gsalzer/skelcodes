{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n// sets support up to 2^256-2 members\r\n// memberIndices stores the index of members + 1, not their actual index\r\nlibrary Sets {\r\n    // address set\r\n    struct addressSet {\r\n        address[] members;\r\n        mapping(address => uint) memberIndices;\r\n    }\r\n\r\n    function insert(addressSet storage self, address other) public {\r\n        if (!contains(self, other)) {\r\n            assert(length(self) < 2**256-1);\r\n            self.members.push(other);\r\n            self.memberIndices[other] = length(self);\r\n        }\r\n    }\r\n\r\n    function remove(addressSet storage self, address other) public {\r\n        if (contains(self, other)) {\r\n            uint replaceIndex = self.memberIndices[other];\r\n            address lastMember = self.members[length(self)-1];\r\n            // overwrite other with the last member and remove last member\r\n            self.members[replaceIndex-1] = lastMember;\r\n            self.members.length--;\r\n            // reflect this change in the indices\r\n            self.memberIndices[lastMember] = replaceIndex;\r\n            delete self.memberIndices[other];\r\n        }\r\n    }\r\n\r\n    function contains(addressSet storage self, address other) public view returns (bool) {\r\n        return self.memberIndices[other] > 0;\r\n    }\r\n\r\n    function length(addressSet storage self) public view returns (uint) {\r\n        return self.members.length;\r\n    }\r\n\r\n\r\n    // uint set\r\n    struct uintSet {\r\n        uint[] members;\r\n        mapping(uint => uint) memberIndices;\r\n    }\r\n\r\n    function insert(uintSet storage self, uint other) public {\r\n        if (!contains(self, other)) {\r\n            assert(length(self) < 2**256-1);\r\n            self.members.push(other);\r\n            self.memberIndices[other] = length(self);\r\n        }\r\n    }\r\n\r\n    function remove(uintSet storage self, uint other) public {\r\n        if (contains(self, other)) {\r\n            uint replaceIndex = self.memberIndices[other];\r\n            uint lastMember = self.members[length(self)-1];\r\n            // overwrite other with the last member and remove last member\r\n            self.members[replaceIndex-1] = lastMember;\r\n            self.members.length--;\r\n            // reflect this change in the indices\r\n            self.memberIndices[lastMember] = replaceIndex;\r\n            delete self.memberIndices[other];\r\n        }\r\n    }\r\n\r\n    function contains(uintSet storage self, uint other) public view returns (bool) {\r\n        return self.memberIndices[other] > 0;\r\n    }\r\n\r\n    function length(uintSet storage self) public view returns (uint) {\r\n        return self.members.length;\r\n    }\r\n\r\n\r\n    // uint8 set\r\n    struct uint8Set {\r\n        uint8[] members;\r\n        mapping(uint8 => uint) memberIndices;\r\n    }\r\n\r\n    function insert(uint8Set storage self, uint8 other) public {\r\n        if (!contains(self, other)) {\r\n            assert(length(self) < 2**256-1);\r\n            self.members.push(other);\r\n            self.memberIndices[other] = length(self);\r\n        }\r\n    }\r\n\r\n    function remove(uint8Set storage self, uint8 other) public {\r\n        if (contains(self, other)) {\r\n            uint replaceIndex = self.memberIndices[other];\r\n            uint8 lastMember = self.members[length(self)-1];\r\n            // overwrite other with the last member and remove last member\r\n            self.members[replaceIndex-1] = lastMember;\r\n            self.members.length--;\r\n            // reflect this change in the indices\r\n            self.memberIndices[lastMember] = replaceIndex;\r\n            delete self.memberIndices[other];\r\n        }\r\n    }\r\n\r\n    function contains(uint8Set storage self, uint8 other) public view returns (bool) {\r\n        return self.memberIndices[other] > 0;\r\n    }\r\n\r\n    function length(uint8Set storage self) public view returns (uint) {\r\n        return self.members.length;\r\n    }\r\n\r\n\r\n    // int set\r\n    struct intSet {\r\n        int[] members;\r\n        mapping(int => uint) memberIndices;\r\n    }\r\n\r\n    function insert(intSet storage self, int other) public {\r\n        if (!contains(self, other)) {\r\n            assert(length(self) < 2**256-1);\r\n            self.members.push(other);\r\n            self.memberIndices[other] = length(self);\r\n        }\r\n    }\r\n\r\n    function remove(intSet storage self, int other) public {\r\n        if (contains(self, other)) {\r\n            uint replaceIndex = self.memberIndices[other];\r\n            int lastMember = self.members[length(self)-1];\r\n            // overwrite other with the last member and remove last member\r\n            self.members[replaceIndex-1] = lastMember;\r\n            self.members.length--;\r\n            // reflect this change in the indices\r\n            self.memberIndices[lastMember] = replaceIndex;\r\n            delete self.memberIndices[other];\r\n        }\r\n    }\r\n\r\n    function contains(intSet storage self, int other) public view returns (bool) {\r\n        return self.memberIndices[other] > 0;\r\n    }\r\n\r\n    function length(intSet storage self) public view returns (uint) {\r\n        return self.members.length;\r\n    }\r\n\r\n\r\n    // int8 set\r\n    struct int8Set {\r\n        int8[] members;\r\n        mapping(int8 => uint) memberIndices;\r\n    }\r\n\r\n    function insert(int8Set storage self, int8 other) public {\r\n        if (!contains(self, other)) {\r\n            assert(length(self) < 2**256-1);\r\n            self.members.push(other);\r\n            self.memberIndices[other] = length(self);\r\n        }\r\n    }\r\n\r\n    function remove(int8Set storage self, int8 other) public {\r\n        if (contains(self, other)) {\r\n            uint replaceIndex = self.memberIndices[other];\r\n            int8 lastMember = self.members[length(self)-1];\r\n            // overwrite other with the last member and remove last member\r\n            self.members[replaceIndex-1] = lastMember;\r\n            self.members.length--;\r\n            // reflect this change in the indices\r\n            self.memberIndices[lastMember] = replaceIndex;\r\n            delete self.memberIndices[other];\r\n        }\r\n    }\r\n\r\n    function contains(int8Set storage self, int8 other) public view returns (bool) {\r\n        return self.memberIndices[other] > 0;\r\n    }\r\n\r\n    function length(int8Set storage self) public view returns (uint) {\r\n        return self.members.length;\r\n    }\r\n\r\n\r\n    // byte set\r\n    struct byteSet {\r\n        byte[] members;\r\n        mapping(byte => uint) memberIndices;\r\n    }\r\n\r\n    function insert(byteSet storage self, byte other) public {\r\n        if (!contains(self, other)) {\r\n            assert(length(self) < 2**256-1);\r\n            self.members.push(other);\r\n            self.memberIndices[other] = length(self);\r\n        }\r\n    }\r\n\r\n    function remove(byteSet storage self, byte other) public {\r\n        if (contains(self, other)) {\r\n            uint replaceIndex = self.memberIndices[other];\r\n            byte lastMember = self.members[length(self)-1];\r\n            // overwrite other with the last member and remove last member\r\n            self.members[replaceIndex-1] = lastMember;\r\n            self.members.length--;\r\n            // reflect this change in the indices\r\n            self.memberIndices[lastMember] = replaceIndex;\r\n            delete self.memberIndices[other];\r\n        }\r\n    }\r\n\r\n    function contains(byteSet storage self, byte other) public view returns (bool) {\r\n        return self.memberIndices[other] > 0;\r\n    }\r\n\r\n    function length(byteSet storage self) public view returns (uint) {\r\n        return self.members.length;\r\n    }\r\n\r\n\r\n    // bytes32 set\r\n    struct bytes32Set {\r\n        bytes32[] members;\r\n        mapping(bytes32 => uint) memberIndices;\r\n    }\r\n\r\n    function insert(bytes32Set storage self, bytes32 other) public {\r\n        if (!contains(self, other)) {\r\n            assert(length(self) < 2**256-1);\r\n            self.members.push(other);\r\n            self.memberIndices[other] = length(self);\r\n        }\r\n    }\r\n\r\n    function remove(bytes32Set storage self, bytes32 other) public {\r\n        if (contains(self, other)) {\r\n            uint replaceIndex = self.memberIndices[other];\r\n            bytes32 lastMember = self.members[length(self)-1];\r\n            // overwrite other with the last member and remove last member\r\n            self.members[replaceIndex-1] = lastMember;\r\n            self.members.length--;\r\n            // reflect this change in the indices\r\n            self.memberIndices[lastMember] = replaceIndex;\r\n            delete self.memberIndices[other];\r\n        }\r\n    }\r\n\r\n    function contains(bytes32Set storage self, bytes32 other) public view returns (bool) {\r\n        return self.memberIndices[other] > 0;\r\n    }\r\n\r\n    function length(bytes32Set storage self) public view returns (uint) {\r\n        return self.members.length;\r\n    }\r\n}\r\n\r\ncontract Prover {\r\n    // attach library\r\n    using Sets for Sets.addressSet;\r\n    using Sets for Sets.bytes32Set;\r\n\r\n    // storage vars\r\n    address owner;\r\n    Sets.addressSet users;\r\n    mapping(address => Account) internal accounts;\r\n\r\n    // structs\r\n    struct Account {\r\n        Sets.bytes32Set entries;\r\n        mapping(bytes32 => Entry) values;\r\n    }\r\n\r\n    struct Entry {\r\n        uint time;\r\n        uint staked;\r\n    }\r\n\r\n    // constructor\r\n    function Prover() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // fallback: allow internal calls\r\n    function() internal {\r\n        if (! this.delegatecall(msg.data)) {\r\n            revert();\r\n        }\r\n    }\r\n\r\n\r\n    // modifier to check if a target address has a particular entry\r\n    modifier entryExists(address target, bytes32 dataHash, bool exists) {\r\n        assert(accounts[target].entries.contains(dataHash) == exists);\r\n        _;\r\n    }\r\n\r\n    // external functions\r\n    // allow access to our structs via functions with convenient return values\r\n    function registeredUsers()\r\n        external\r\n        view\r\n        returns (uint number_unique_addresses, address[] unique_addresses) {\r\n        return (users.length(), users.members);\r\n    }\r\n    function userEntries(address target)\r\n        external\r\n        view\r\n        returns (bytes32[]) {\r\n        return accounts[target].entries.members;\r\n    }\r\n    function entryInformation(address target, bytes32 dataHash)\r\n        external\r\n        view\r\n        returns (bool proved, uint time, uint staked) {\r\n        return (accounts[target].entries.contains(dataHash),\r\n                accounts[target].values[dataHash].time,\r\n                accounts[target].values[dataHash].staked);\r\n    }\r\n\r\n    // public functions\r\n    // adding entries\r\n    function addEntry(bytes32 dataHash)\r\n        public\r\n        payable\r\n        entryExists(msg.sender, dataHash, false){\r\n        users.insert(msg.sender);\r\n        accounts[msg.sender].entries.insert(dataHash);\r\n        accounts[msg.sender].values[dataHash] = Entry(now, msg.value);\r\n    }\r\n\r\n    // deleting entries\r\n    function deleteEntry(bytes32 dataHash)\r\n        public\r\n        entryExists(msg.sender, dataHash, true) {\r\n        uint rebate = accounts[msg.sender].values[dataHash].staked;\r\n        // update user account\r\n        delete accounts[msg.sender].values[dataHash];\r\n        accounts[msg.sender].entries.remove(dataHash);\r\n        // delete from users if this was the user's last entry\r\n        if (accounts[msg.sender].entries.length() == 0) {\r\n            users.remove(msg.sender);\r\n        }\r\n        // send the rebate\r\n        if (rebate > 0) msg.sender.transfer(rebate);\r\n    }\r\n\r\n    // allow owner to delete contract if no accounts exist\r\n    function selfDestruct() public {\r\n        if ((msg.sender == owner) && (users.length() == 0)) {\r\n            selfdestruct(owner);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"entryInformation\",\"outputs\":[{\"name\":\"proved\",\"type\":\"bool\"},{\"name\":\"time\",\"type\":\"uint256\"},{\"name\":\"staked\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"addEntry\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registeredUsers\",\"outputs\":[{\"name\":\"number_unique_addresses\",\"type\":\"uint256\"},{\"name\":\"unique_addresses\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"selfDestruct\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"}],\"name\":\"userEntries\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"deleteEntry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"}]","ContractName":"Prover","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":":Sets:fA5e85584c895483aF162b6B87b6e8730bD41183","SwarmSource":"bzzr://3f56770eee917cd2f73977a15381c5171f39ebb258d8095141414cc4d5d77393"}]}