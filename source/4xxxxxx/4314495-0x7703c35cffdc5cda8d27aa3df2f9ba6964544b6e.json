{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\r\n\r\ncontract owned {\r\n    address public owner;\r\n\r\n    function owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) onlyOwner {\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract PylonToken is owned {\r\n    // Public variables of the token\r\n    string public standard = \"Pylon Token - The first decentralized energy exchange platform powered by renewable energy\";\r\n    string public name = 'Pylon Token';\r\n    string public symbol = 'PYLNT';\r\n    uint8 public decimals = 18;\r\n    uint256 public totalSupply = 3750000000000000000000000;\r\n\r\n    // This creates an array with all balances\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => bool) public frozenAccount;\r\n\r\n    // This notifies about accounts locked\r\n    event FrozenFunds(address target, bool frozen);\r\n\r\n    // This generates a public event on the blockchain that will notify clients\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    // This notifies clients about the amount burnt\r\n    event Burn(address indexed from, uint256 value);\r\n\r\n    using SafeMath for uint256;\r\n\r\n    address public beneficiary = 0xAE0151Ca8C9b6A1A7B50Ce80Bf7436400E22b535;  //Chip-chap Klenergy Address of ether beneficiary account\r\n    uint256 public fundingGoal = 21230434782608700000000;     // Foundig goal in weis = 21230,434782608700000000 Ethers\r\n    uint256 public amountRaised;    // Quantity of weis investeds\r\n    uint256 public deadline; // durationInMinutes * 60 / 17 + 5000;        // Last moment to invest\r\n    uint256 public price = 6608695652173910;           // Ether cost of each token in weis 0,006608695652173910 ethers\r\n\r\n    uint256 public totalTokensToSend = 3250000000000000000000000; // Total tokens offered in the total ICO\r\n\r\n    uint256 public maxEtherInvestment = 826086956521739000000; //Ethers. To mofify the day when starts crowdsale, equivalent to 190.000€ = 826,086956521739000000 ether\r\n    uint256 public maxTokens = 297619047619048000000000; // 297,619.047619048000000000 PYLNT = 190.000 € + 56% bonus\r\n\r\n    uint256 public bonusCap = 750000000000000000000000; // 750,000.000000000000000000 PYLNT last day before Crowdsale as 1,52€/token\r\n    uint256 public pylonSelled = 0;\r\n\r\n    uint256 public startBlockBonus;\r\n\r\n    uint256 public endBlockBonus1;\r\n\r\n    uint256 public endBlockBonus2;\r\n\r\n    uint256 public endBlockBonus3;\r\n\r\n    uint256 public qnt10k = 6578947368421050000000; // 6,578.947368421050000000 PYLNT = 10.000 €\r\n\r\n    bool fundingGoalReached = false; // If founding goal is reached or not\r\n    bool crowdsaleClosed = false;    // If crowdsale is closed or open\r\n\r\n    event GoalReached(address deposit, uint256 amountDeposited);\r\n    event FundTransfer(address backer, uint256 amount, bool isContribution);\r\n    event LogQuantity(uint256 _amount, string _message);\r\n\r\n    // Chequear\r\n    uint256 public startBlock = getBlockNumber();\r\n\r\n    bool public paused = false;\r\n\r\n    //uint256 public balanceInvestor;\r\n    //uint256 public ultimosTokensEntregados;\r\n\r\n    modifier contributionOpen() {\r\n        require(getBlockNumber() >= startBlock && getBlockNumber() <= deadline);\r\n        _;\r\n    }\r\n\r\n    modifier notPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    function crowdsale() onlyOwner{\r\n        paused = false;\r\n    }\r\n\r\n    /**\r\n     * event for token purchase logging\r\n     * @param purchaser who paid for the tokens\r\n     * @param investor who got the tokens\r\n     * @param value weis paid for purchase\r\n     * @param amount amount of tokens purchased\r\n     */\r\n    event TokenPurchase(address indexed purchaser, address indexed investor, uint256 value, uint256 amount);\r\n\r\n    /**\r\n     * Constrctor function\r\n     *\r\n     * Initializes contract with initial supply tokens to the creator of the contract\r\n     */\r\n    function PylonToken(\r\n        uint256 initialSupply,\r\n        string tokenName,\r\n        uint8 decimalUnits,\r\n        string tokenSymbol,\r\n        address centralMinter,\r\n        address ifSuccessfulSendTo,\r\n        uint256 fundingGoalInWeis,\r\n        uint256 durationInMinutes,\r\n        uint256 weisCostOfEachToken\r\n    ) {\r\n        if (centralMinter != 0) owner = centralMinter;\r\n\r\n        balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens\r\n        totalSupply = initialSupply;                        // Update total supply\r\n        name = tokenName;                                   // Set the name for display purposes\r\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\r\n        decimals = decimalUnits;                            // Amount of decimals for display purposes\r\n\r\n        beneficiary = ifSuccessfulSendTo;\r\n        fundingGoal = fundingGoalInWeis;\r\n        startBlock = getBlockNumber();\r\n        startBlockBonus = getBlockNumber();\r\n        endBlockBonus1 = getBlockNumber() + 15246 + 12600 + 500;    // 3 days + 35,5h + margen error = 15246 + 12600 + 500\r\n        endBlockBonus2 = getBlockNumber() + 30492 + 12600 + 800;    // 6 days + 35,5h + margen error = 30492 + 12600 + 800\r\n        endBlockBonus3 = getBlockNumber() + 45738 + 12600 + 1100;   // 9 days + 35,5h + margen error = 45738 + 12600 + 1100\r\n        deadline = getBlockNumber() + (durationInMinutes * 60 / 17) + 5000; // durationInMinutes * 60 / 17 + 12600 + 5000 = Calculo bloques + margen error\r\n        price = weisCostOfEachToken;\r\n    }\r\n\r\n    /**\r\n     * Internal transfer, only can be called by this contract\r\n     */\r\n    function _transfer(address _from, address _to, uint _value) internal {\r\n        require(_to != 0x0);                                // Prevent transfer to 0x0 address. Use burn() instead\r\n        require(balanceOf[_from] >= _value);                // Check if the sender has enough\r\n        require(balanceOf[_to] + _value > balanceOf[_to]);  // Check for overflows\r\n        require(!frozenAccount[_from]);                     // Check if sender is frozen\r\n        require(!frozenAccount[_to]);                       // Check if recipient is frozen\r\n        balanceOf[_from] -= _value;                         // Subtract from the sender\r\n        balanceOf[_to] += _value;                           // Add the same to the recipient\r\n        Transfer(_from, _to, _value);\r\n    }\r\n\r\n    /**\r\n     * Transfer tokens\r\n     *\r\n     * Send `_value` tokens to `_to` from your account\r\n     *\r\n     * @param _to The address of the recipient\r\n     * @param _value the amount to send\r\n     */\r\n    function transfer(address _to, uint256 _value) {\r\n        _transfer(msg.sender, _to, _value);\r\n    }\r\n\r\n    /**\r\n     * Destroy tokens\r\n     *\r\n     * Remove `_value` tokens from the system irreversibly\r\n     *\r\n     * @param _value the amount of money to burn\r\n     */\r\n    function burn(uint256 _value) onlyOwner returns (bool success) {\r\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\r\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\r\n        totalSupply -= _value;                      // Updates totalSupply\r\n        Burn(msg.sender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Destroy tokens from other ccount\r\n     *\r\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\r\n     *\r\n     * @param _from the address of the sender\r\n     * @param _value the amount of money to burn\r\n     */\r\n    function burnFrom(address _from, uint256 _value) onlyOwner returns (bool success) {\r\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\r\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\r\n        totalSupply -= _value;                              // Update totalSupply\r\n        Burn(_from, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Mine new tokens\r\n     *\r\n     * Mine `mintedAmount` tokens from the system to send to the `target`.\r\n     * This function will only be used from a future contract to invest in new renewable installations\r\n     *\r\n     * @param target the address of the recipient\r\n     * @param mintedAmount the amount of money to send\r\n     */\r\n    function mintToken(address target, uint256 mintedAmount) onlyOwner {\r\n        balanceOf[target] += mintedAmount;\r\n        totalSupply += mintedAmount;\r\n        Transfer(0, owner, mintedAmount);\r\n        Transfer(owner, target, mintedAmount);\r\n    }\r\n\r\n    /**\r\n     * Lock or unlock accounts\r\n     *\r\n     * Lock or unlock `target` accounts which don't use the token correctly.\r\n     *\r\n     * @param target the address of the locked or unlicked account\r\n     * @param freeze if this account has to be freeze or not\r\n     */\r\n    function freezeAccount(address target, bool freeze) onlyOwner {\r\n        frozenAccount[target] = freeze;\r\n        FrozenFunds(target, freeze);\r\n    }\r\n\r\n    /**\r\n     * Fallback function\r\n     *\r\n     * The function without name is the default function that is called whenever anyone sends funds to a contract\r\n     */\r\n    function () payable notPaused{\r\n        buyTokens(msg.sender);\r\n    }\r\n\r\n    // low level token purchase function\r\n    function buyTokens(address investor) payable notPaused {\r\n        require (!crowdsaleClosed); // Check if crowdsale is open or not\r\n        require(investor != 0x0);  // Check the address\r\n        require(validPurchase()); //Validate the transfer\r\n        require(maxEtherInvestment >= msg.value); //Check if It's more than maximum to invest\r\n        require(balanceOf[investor] <= maxTokens); // Check if the investor has more tokens than 5% of total supply\r\n        require(amountRaised <= fundingGoal); // Check if fundingGoal is rised\r\n        require(pylonSelled <= totalTokensToSend); //Check if pylons we have sell is more or equal than total tokens ew have\r\n\r\n\r\n        //Check if It's time for pre ICO or ICO\r\n        if(startBlockBonus <= getBlockNumber() && startBlock <= getBlockNumber() && endBlockBonus3 >= getBlockNumber() && pylonSelled <= bonusCap){\r\n          buyPreIco(investor);\r\n        } else if(deadline >= getBlockNumber()){\r\n          buyIco(investor);\r\n        }\r\n\r\n    }\r\n\r\n    function buyIco(address investor) internal{\r\n      uint256 weiAmount = msg.value;\r\n\r\n      // calculate token amount to be sent\r\n      uint256 tokens = weiAmount.mul(10**18).div(price);\r\n\r\n      require((balanceOf[investor] + tokens) <= maxTokens);         // Check if the investor has more tokens than 5% of total supply\r\n      require(balanceOf[this] >= tokens);             // checks if it has enough to sell\r\n      require(pylonSelled + tokens <= totalTokensToSend); //Overflow - Check if pylons we have sell is more or equal than total tokens ew have\r\n\r\n      balanceOf[this] -= tokens;\r\n      balanceOf[investor] += tokens;\r\n      amountRaised += weiAmount; // update state amount raised\r\n      pylonSelled += tokens; // Total tokens selled\r\n\r\n      beneficiary.transfer(weiAmount); //Transfer ethers to beneficiary\r\n\r\n      frozenAccount[investor] = true;\r\n      FrozenFunds(investor, true);\r\n\r\n      TokenPurchase(msg.sender, investor, weiAmount, tokens);\r\n    }\r\n\r\n    function buyPreIco(address investor) internal{\r\n      uint256 weiAmount = msg.value;\r\n\r\n      uint256 bonusPrice = 0;\r\n      uint256 tokens = weiAmount.mul(10**18).div(price);\r\n\r\n      if(endBlockBonus1 >= getBlockNumber()){\r\n        if(tokens == qnt10k.mul(19) ){\r\n          bonusPrice = 2775652173913040;\r\n        }else if(tokens >= qnt10k.mul(18) && tokens < qnt10k.mul(19)){\r\n          bonusPrice = 2907826086956520;\r\n        }else if(tokens >= qnt10k.mul(17) && tokens < qnt10k.mul(18)){\r\n          bonusPrice = 3040000000000000;\r\n        }else if(tokens >= qnt10k.mul(16) && tokens < qnt10k.mul(17)){\r\n          bonusPrice = 3172173913043480;\r\n        }else if(tokens >= qnt10k.mul(15) && tokens < qnt10k.mul(16)){\r\n          bonusPrice = 3304347826086960;\r\n        }else if(tokens >= qnt10k.mul(14) && tokens < qnt10k.mul(15)){\r\n          bonusPrice = 3436521739130430;\r\n        }else if(tokens >= qnt10k.mul(13) && tokens < qnt10k.mul(14)){\r\n          bonusPrice = 3568695652173910;\r\n        }else if(tokens >= qnt10k.mul(12) && tokens < qnt10k.mul(13)){\r\n          bonusPrice = 3700869565217390;\r\n        }else if(tokens >= qnt10k.mul(11) && tokens < qnt10k.mul(12)){\r\n          bonusPrice = 3833043478260870;\r\n        }else if(tokens >= qnt10k.mul(10) && tokens < qnt10k.mul(11)){\r\n          bonusPrice = 3965217391304350;\r\n        }else if(tokens >= qnt10k.mul(9) && tokens < qnt10k.mul(10)){\r\n          bonusPrice = 4097391304347830;\r\n        }else if(tokens >= qnt10k.mul(8) && tokens < qnt10k.mul(9)){\r\n          bonusPrice = 4229565217391300;\r\n        }else if(tokens >= qnt10k.mul(7) && tokens < qnt10k.mul(8)){\r\n          bonusPrice = 4361739130434780;\r\n        }else if(tokens >= qnt10k.mul(6) && tokens < qnt10k.mul(7)){\r\n          bonusPrice = 4493913043478260;\r\n        }else if(tokens >= qnt10k.mul(5) && tokens < qnt10k.mul(6)){\r\n          bonusPrice = 4626086956521740;\r\n        }else{\r\n          bonusPrice = 5286956521739130;\r\n        }\r\n      }else if(endBlockBonus2 >= getBlockNumber()){\r\n        if(tokens == qnt10k.mul(19) ){\r\n          bonusPrice = 3436521739130430;\r\n        }else if(tokens >= qnt10k.mul(18) && tokens < qnt10k.mul(19)){\r\n          bonusPrice = 3568695652173910;\r\n        }else if(tokens >= qnt10k.mul(17) && tokens < qnt10k.mul(18)){\r\n          bonusPrice = 3700869565217390;\r\n        }else if(tokens >= qnt10k.mul(16) && tokens < qnt10k.mul(17)){\r\n          bonusPrice = 3833043478260870;\r\n        }else if(tokens >= qnt10k.mul(15) && tokens < qnt10k.mul(16)){\r\n          bonusPrice = 3965217391304350;\r\n        }else if(tokens >= qnt10k.mul(14) && tokens < qnt10k.mul(15)){\r\n          bonusPrice = 4097391304347830;\r\n        }else if(tokens >= qnt10k.mul(13) && tokens < qnt10k.mul(14)){\r\n          bonusPrice = 4229565217391300;\r\n        }else if(tokens >= qnt10k.mul(12) && tokens < qnt10k.mul(13)){\r\n          bonusPrice = 4361739130434780;\r\n        }else if(tokens >= qnt10k.mul(11) && tokens < qnt10k.mul(12)){\r\n          bonusPrice = 4493913043478260;\r\n        }else if(tokens >= qnt10k.mul(10) && tokens < qnt10k.mul(11)){\r\n          bonusPrice = 4626086956521740;\r\n        }else if(tokens >= qnt10k.mul(9) && tokens < qnt10k.mul(10)){\r\n          bonusPrice = 4758260869565220;\r\n        }else if(tokens >= qnt10k.mul(8) && tokens < qnt10k.mul(9)){\r\n          bonusPrice = 4890434782608700;\r\n        }else if(tokens >= qnt10k.mul(7) && tokens < qnt10k.mul(8)){\r\n          bonusPrice = 5022608695652170;\r\n        }else if(tokens >= qnt10k.mul(6) && tokens < qnt10k.mul(7)){\r\n          bonusPrice = 5154782608695650;\r\n        }else if(tokens >= qnt10k.mul(5) && tokens < qnt10k.mul(6)){\r\n          bonusPrice = 5286956521739130;\r\n        }else{\r\n          bonusPrice = 5947826086956520;\r\n        }\r\n      }else{\r\n        if(tokens == qnt10k.mul(19) ){\r\n          bonusPrice = 3766956521739130;\r\n        }else if(tokens >= qnt10k.mul(18) && tokens < qnt10k.mul(19)){\r\n          bonusPrice = 3899130434782610;\r\n        }else if(tokens >= qnt10k.mul(17) && tokens < qnt10k.mul(18)){\r\n          bonusPrice = 4031304347826090;\r\n        }else if(tokens >= qnt10k.mul(16) && tokens < qnt10k.mul(17)){\r\n          bonusPrice = 4163478260869570;\r\n        }else if(tokens >= qnt10k.mul(15) && tokens < qnt10k.mul(16)){\r\n          bonusPrice = 4295652173913040;\r\n        }else if(tokens >= qnt10k.mul(14) && tokens < qnt10k.mul(15)){\r\n          bonusPrice = 4427826086956520;\r\n        }else if(tokens >= qnt10k.mul(13) && tokens < qnt10k.mul(14)){\r\n          bonusPrice = 4560000000000000;\r\n        }else if(tokens >= qnt10k.mul(12) && tokens < qnt10k.mul(13)){\r\n          bonusPrice = 4692173913043480;\r\n        }else if(tokens >= qnt10k.mul(11) && tokens < qnt10k.mul(12)){\r\n          bonusPrice = 4824347826086960;\r\n        }else if(tokens >= qnt10k.mul(10) && tokens < qnt10k.mul(11)){\r\n          bonusPrice = 4956521739130430;\r\n        }else if(tokens >= qnt10k.mul(9) && tokens < qnt10k.mul(10)){\r\n          bonusPrice = 5088695652173910;\r\n        }else if(tokens >= qnt10k.mul(8) && tokens < qnt10k.mul(9)){\r\n          bonusPrice = 5220869565217390;\r\n        }else if(tokens >= qnt10k.mul(7) && tokens < qnt10k.mul(8)){\r\n          bonusPrice = 5353043478260870;\r\n        }else if(tokens >= qnt10k.mul(6) && tokens < qnt10k.mul(7)){\r\n          bonusPrice = 5485217391304350;\r\n        }else if(tokens >= qnt10k.mul(5) && tokens < qnt10k.mul(6)){\r\n          bonusPrice = 5617391304347830;\r\n        }else{\r\n          bonusPrice = 6278260869565220;\r\n        }\r\n      }\r\n\r\n      tokens = weiAmount.mul(10**18).div(bonusPrice);\r\n\r\n      require(pylonSelled + tokens <= bonusCap); // Check if want to sell more than total tokens for pre-ico\r\n      require(balanceOf[investor] + tokens <= maxTokens); // Check if the investor has more tokens than 5% of total supply\r\n      require(balanceOf[this] >= tokens);             // checks if it has enough to sell\r\n\r\n      balanceOf[this] -= tokens;\r\n      balanceOf[investor] += tokens;\r\n      amountRaised += weiAmount; // update state amount raised\r\n      pylonSelled += tokens; // Total tokens selled\r\n\r\n      beneficiary.transfer(weiAmount); //Transfer ethers to beneficiary\r\n\r\n      frozenAccount[investor] = true;\r\n      FrozenFunds(investor, true);\r\n\r\n      TokenPurchase(msg.sender, investor, weiAmount, tokens);\r\n\r\n    }\r\n\r\n    modifier afterDeadline() { if (now >= deadline) _; }\r\n\r\n    /**\r\n     * Check if goal was reached\r\n     *\r\n     * Checks if the goal or time limit has been reached and ends the campaign\r\n     */\r\n    function checkGoalReached() afterDeadline onlyOwner {\r\n        if (amountRaised >= fundingGoal){\r\n            fundingGoalReached = true;\r\n            GoalReached(beneficiary, amountRaised);\r\n        }\r\n        crowdsaleClosed = true;\r\n    }\r\n\r\n\r\n    // @return true if the transaction can buy tokens\r\n    function validPurchase() internal constant returns (bool) {\r\n        uint256 current = getBlockNumber();\r\n        bool withinPeriod = current >= startBlock && current <= deadline;\r\n        bool nonZeroPurchase = msg.value != 0;\r\n        return withinPeriod && nonZeroPurchase;\r\n    }\r\n\r\n    //////////\r\n    // Testing specific methods\r\n    //////////\r\n\r\n    /// @notice This function is overridden by the test Mocks.\r\n    function getBlockNumber() internal constant returns (uint256) {\r\n        return block.number;\r\n    }\r\n\r\n    /// @notice Pauses the contribution if there is any issue\r\n    function pauseContribution() onlyOwner {\r\n        paused = true;\r\n    }\r\n\r\n    /// @notice Resumes the contribution\r\n    function resumeContribution() onlyOwner {\r\n        paused = false;\r\n    }\r\n}\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"checkGoalReached\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endBlockBonus2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensToSend\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deadline\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"qnt10k\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startBlockBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pauseContribution\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxEtherInvestment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"standard\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pylonSelled\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"mintedAmount\",\"type\":\"uint256\"}],\"name\":\"mintToken\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingGoal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amountRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"crowdsale\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endBlockBonus1\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"frozenAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resumeContribution\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endBlockBonus3\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"freeze\",\"type\":\"bool\"}],\"name\":\"freezeAccount\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"initialSupply\",\"type\":\"uint256\"},{\"name\":\"tokenName\",\"type\":\"string\"},{\"name\":\"decimalUnits\",\"type\":\"uint8\"},{\"name\":\"tokenSymbol\",\"type\":\"string\"},{\"name\":\"centralMinter\",\"type\":\"address\"},{\"name\":\"ifSuccessfulSendTo\",\"type\":\"address\"},{\"name\":\"fundingGoalInWeis\",\"type\":\"uint256\"},{\"name\":\"durationInMinutes\",\"type\":\"uint256\"},{\"name\":\"weisCostOfEachToken\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"FrozenFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"deposit\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountDeposited\",\"type\":\"uint256\"}],\"name\":\"GoalReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"backer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"isContribution\",\"type\":\"bool\"}],\"name\":\"FundTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_message\",\"type\":\"string\"}],\"name\":\"LogQuantity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"}]","ContractName":"PylonToken","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000031a17e847807b1bc000000000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000001600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ae0151ca8c9b6a1a7b50ce80bf7436400e22b53500000000000000000000000000000000000000000000047ee7780f1e490cc700000000000000000000000000000000000000000000000000000000000000b6b200000000000000000000000000000000000000000000000000177a92dcc6c856000000000000000000000000000000000000000000000000000000000000000b50796c6f6e20546f6b656e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000550594c4e54000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://71569dc0d85e380ec703e8af094a3cc551e21702df831d6bd5fa7b3866606f4a"}]}