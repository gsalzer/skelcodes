{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\ncontract Blockeds {\r\n  mapping (address => bool) blocked;\r\n\r\n  event Blocked(address _addr);\r\n  event Unblocked(address _addr);\r\n\r\n  function blockAddress(address _addr) public {\r\n    require(!blocked[_addr]);\r\n    blocked[_addr] = true;\r\n\r\n    Blocked(_addr);\r\n  }\r\n\r\n  function unblockAddress(address _addr) public {\r\n    require(blocked[_addr]);\r\n    blocked[_addr] = false;\r\n\r\n    Unblocked(_addr);\r\n  }\r\n}\r\n\r\n/*\r\n    저작권 2016, Jordi Baylina\r\n\r\n    이 프로그램은 무료 소프트웨어입니다.\r\n    이 프로그램은 Free Soft ware Foundation에서\r\n    게시하는 GNU General Public License의\r\n    조건에 따라 라이센스의 버전 3또는(선택 사항으로)\r\n    이후 버전으로 재배포 및 또는 수정할 수 있습니다.\r\n\r\n    이 프로그램은 유용할 것을 기대하여 배포되지만,\r\n    상품성이나 특정 목적에 대한 적합성의 묵시적\r\n    보증도 없이 모든 보증 없이 제공됩니다.\r\n    자세한 내용은 GNU General Public License를 참조하십시오.\r\n\r\n    이 프로그램과 함께 GNU General Public License 사본을 받아야합니다.\r\n    그렇지 않으면, 참조 : <http://www.gnu.org/licenses/>\r\n */\r\n\r\n/*\r\n * @title MiniMeToken\r\n * @author Jordi Baylina\r\n * @dev 이 토큰 계약의 목표는 이 토큰을 손쉽게 복제하는 것입니다.\r\n *      토큰을 사용하면 지정된 블록에서 DAO 및 DApps가 원래 토큰에 영향을 주지 않고 기능을 분산된 방식으로 업그레이드할 수 있습니다.\r\n * @dev ERC20과 호환되지만 추가 테스트를 진행해야합니다.\r\n*/\r\ncontract Controlled {\r\n    // 컨트롤러의 주소는 이 수정 프로그램으로 함수를 호출할 수 있는 유일한 주소입니다.\r\n    modifier onlyController { require(msg.sender == controller); _; }\r\n\r\n    address public controller;\r\n\r\n    function Controlled() public { controller = msg.sender;}\r\n\r\n    //                계약 당사자\r\n    // _newController 새로운 계약자\r\n    function changeController(address _newController) public onlyController {\r\n        controller = _newController;\r\n    }\r\n}\r\n\r\n\r\n\r\n// 토큰 컨트롤러 계약에서 이러한 기능을 구현해야 합니다.\r\ncontract TokenController {\r\n    // @notice `_owner`가 이더리움을 MiniMeToken 계약에 보낼 때 호출됩니다.\r\n    // @param   _owner 토큰을 생성하기 위해 이더리움을 보낸 주소\r\n    // @return         이더리움이 정상 전송되는 경우는 true, 아닌 경우는 false\r\n    function proxyPayment(address _owner) public payable returns(bool);\r\n\r\n    // @notice         컨트롤러에 토큰 전송에 대해 알립니다.\r\n    //                 원하는 경우 반응하는 컨트롤러\r\n    // @param _from    전송의 출처\r\n    // @param _to      전송 목적지\r\n    // @param _amount  전송 금액\r\n    // @return         컨트롤러가 전송을 승인하지 않는 경우 거짓\r\n    function onTransfer(address _from, address _to, uint _amount) public returns(bool);\r\n\r\n    // @notice                     컨트롤러에 승인 사실을 알리고, 필요한 경우 컨트롤러가 대응하도록 합니다.\r\n    // @param _owner `approve ()`  를 호출하는 주소.\r\n    // @param _spender `approve()` 호출하는 전송자\r\n    // @param _amount `approve ()` 호출의 양\r\n    // @return                     컨트롤러가 승인을 허가하지 않는 경우 거짓\r\n    function onApprove(address _owner, address _spender, uint _amount) public\r\n        returns(bool);\r\n}\r\n\r\ncontract ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 _amount, address _token, bytes _data) public;\r\n}\r\n\r\n// 실제 토큰 계약인 기본 컨트롤러는 계약서를 배포하는 msg.sender이므로\r\n// 이 토큰은 대개 토큰 컨트롤러 계약에 의해 배포되며,\r\n// Giveth는 \"Campaign\"을 호출합니다.\r\ncontract MiniMeToken is Controlled {\r\n    string public name;                // 토큰 이름 : EX DigixDAO token\r\n    uint8 public decimals;             // 최소 단위의 소수 자릿수\r\n    string public symbol;              // 식별자 EX : e.g. REP\r\n    string public version = 'MMT_0.2'; // 버전 관리 방식\r\n\r\n\r\n    // @dev `Checkpoint` 블록 번호를 지정된 값에 연결하는 구조이며,\r\n    //                    첨부된 블록 번호는 마지막으로 값을 변경한 번호입니다.\r\n    struct  Checkpoint {\r\n\r\n        // `fromBlock` 값이 생성된 블록 번호입니다.\r\n        uint128 fromBlock;\r\n\r\n        // `value` 특정 블록 번호의 토큰 양입니다.\r\n        uint128 value;\r\n    }\r\n\r\n    // `parentToken` 이 토큰을 생성하기 위해 복제 된 토큰 주소입니다.\r\n    //               복제되지 않은 토큰의 경우 0x0이 됩니다.\r\n    MiniMeToken public parentToken;\r\n\r\n    // `parentSnapShotBlock` 상위 토큰의 블록 번호로,\r\n    //                       복제 토큰의 초기 배포를 결정하는 데 사용됨\r\n    uint public parentSnapShotBlock;\r\n\r\n    // `creationBlock` 복제 토큰이 생성된 블록 번호입니다.\r\n    uint public creationBlock;\r\n\r\n    // `balances` 이 계약에서 잔액이 변경될 때 변경 사항이 발생한\r\n    //            블록 번호도 맵에 포함되어 있으며 각 주소의 잔액을 추적하는 맵입니다.\r\n    mapping (address => Checkpoint[]) balances;\r\n\r\n    // `allowed` 모든 ERC20 토큰에서와 같이 추가 전송 권한을 추적합니다.\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    // 토큰의 `totalSupply` 기록을 추적합니다.\r\n    Checkpoint[] totalSupplyHistory;\r\n\r\n    // 토큰이 전송 가능한지 여부를 결정하는 플래그 입니다.\r\n    bool public transfersEnabled;\r\n\r\n    // 새 복제 토큰을 만드는 데 사용 된 팩토리\r\n    MiniMeTokenFactory public tokenFactory;\r\n\r\n    /*\r\n     * 건설자\r\n     */\r\n    // @notice MiniMeToken을 생성하는 생성자\r\n    // @param _tokenFactory MiniMeTokenFactory 계약의 주소\r\n    //                               복제 토큰 계약을 생성하는 MiniMeTokenFactory 계약의 주소,\r\n    //                               먼저 토큰 팩토리를 배포해야합니다.\r\n    // @param _parentToken           상위 토큰의 ParentTokerut 주소 (새 토큰인 경우 0x0으로 설정됨)\r\n    // @param _parentSnapShotBlock   복제 토큰의 초기 배포를 결정할 상위 토큰의 블록(새 토큰인 경우 0으로 설정됨)\r\n    // @param _tokenName             새 토큰의 이름\r\n    // @param _decimalUnits          새 토큰의 소수 자릿수\r\n    // @param _tokenSymbol           새 토큰에 대한 토큰 기호\r\n    // @param _transfersEnabled true 이면 토큰을 전송할 수 있습니다.\r\n    function MiniMeToken(\r\n        address _tokenFactory,\r\n        address _parentToken,\r\n        uint _parentSnapShotBlock,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol,\r\n        bool _transfersEnabled\r\n    ) public {\r\n        tokenFactory = MiniMeTokenFactory(_tokenFactory);\r\n        name = _tokenName;                                 // 이름 설정\r\n        decimals = _decimalUnits;                          // 십진수 설정\r\n        symbol = _tokenSymbol;                             // 기호 설정 (심볼)\r\n        parentToken = MiniMeToken(_parentToken);\r\n        parentSnapShotBlock = _parentSnapShotBlock;\r\n        transfersEnabled = _transfersEnabled;\r\n        creationBlock = block.number;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _amount) public returns (bool success) {\r\n        require(transfersEnabled);\r\n        doTransfer(msg.sender, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _amount\r\n    ) public returns (bool success) {\r\n        if (msg.sender != controller) {\r\n            require(transfersEnabled);\r\n\r\n            require(allowed[_from][msg.sender] >= _amount);\r\n            allowed[_from][msg.sender] -= _amount;\r\n        }\r\n        doTransfer(_from, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    function doTransfer(address _from, address _to, uint _amount\r\n    ) internal {\r\n\r\n           if (_amount == 0) {\r\n               Transfer(_from, _to, _amount);\r\n               return;\r\n           }\r\n\r\n           require(parentSnapShotBlock < block.number);\r\n\r\n           require((_to != 0) && (_to != address(this)));\r\n\r\n           var previousBalanceFrom = balanceOfAt(_from, block.number);\r\n\r\n           require(previousBalanceFrom >= _amount);\r\n\r\n           if (isContract(controller)) {\r\n               require(TokenController(controller).onTransfer(_from, _to, _amount));\r\n           }\r\n\r\n           updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\r\n\r\n           var previousBalanceTo = balanceOfAt(_to, block.number);\r\n           require(previousBalanceTo + _amount >= previousBalanceTo);\r\n           updateValueAtNow(balances[_to], previousBalanceTo + _amount);\r\n\r\n           Transfer(_from, _to, _amount);\r\n\r\n    }\r\n\r\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n        return balanceOfAt(_owner, block.number);\r\n    }\r\n\r\n    function approve(address _spender, uint256 _amount) public returns (bool success) {\r\n        require(transfersEnabled);\r\n\r\n        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n        // 승인 기능 호출의 토큰 컨트롤러에 알림\r\n        if (isContract(controller)) {\r\n            require(TokenController(controller).onApprove(msg.sender, _spender, _amount));\r\n        }\r\n\r\n        allowed[msg.sender][_spender] = _amount;\r\n        Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender\r\n    ) public constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    function approveAndCall(address _spender, uint256 _amount, bytes _extraData\r\n    ) public returns (bool success) {\r\n        require(approve(_spender, _amount));\r\n\r\n        ApproveAndCallFallBack(_spender).receiveApproval(\r\n            msg.sender,\r\n            _amount,\r\n            this,\r\n            _extraData\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    function totalSupply() public constant returns (uint) {\r\n        return totalSupplyAt(block.number);\r\n    }\r\n\r\n    /*\r\n     * 히스토리 내 쿼리 균형 및 총 공급\r\n     */\r\n    function balanceOfAt(address _owner, uint _blockNumber) public constant\r\n        returns (uint) {\r\n\r\n        if ((balances[_owner].length == 0)\r\n            || (balances[_owner][0].fromBlock > _blockNumber)) {\r\n            if (address(parentToken) != 0) {\r\n                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\r\n            } else {\r\n                // 상위토큰이 없다.\r\n                return 0;\r\n            }\r\n        } else {\r\n            return getValueAt(balances[_owner], _blockNumber);\r\n        }\r\n    }\r\n\r\n    function totalSupplyAt(uint _blockNumber) public constant returns(uint) {\r\n        if ((totalSupplyHistory.length == 0)\r\n            || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\r\n            if (address(parentToken) != 0) {\r\n                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\r\n            } else {\r\n                return 0;\r\n            }\r\n        } else {\r\n            return getValueAt(totalSupplyHistory, _blockNumber);\r\n        }\r\n    }\r\n\r\n    /*\r\n     * 토큰 복제 방법\r\n     */\r\n    function createCloneToken(\r\n        string _cloneTokenName,\r\n        uint8 _cloneDecimalUnits,\r\n        string _cloneTokenSymbol,\r\n        uint _snapshotBlock,\r\n        bool _transfersEnabled\r\n        ) public returns(address) {\r\n        if (_snapshotBlock == 0) _snapshotBlock = block.number;\r\n        MiniMeToken cloneToken = tokenFactory.createCloneToken(\r\n            this,\r\n            _snapshotBlock,\r\n            _cloneTokenName,\r\n            _cloneDecimalUnits,\r\n            _cloneTokenSymbol,\r\n            _transfersEnabled\r\n            );\r\n\r\n        cloneToken.changeController(msg.sender);\r\n\r\n        NewCloneToken(address(cloneToken), _snapshotBlock);\r\n        return address(cloneToken);\r\n    }\r\n\r\n    /*\r\n     * 토큰 생성 및 소각\r\n     */\r\n    function generateTokens(address _owner, uint _amount\r\n    ) public onlyController returns (bool) {\r\n        uint curTotalSupply = totalSupply();\r\n        require(curTotalSupply + _amount >= curTotalSupply);\r\n        uint previousBalanceTo = balanceOf(_owner);\r\n        require(previousBalanceTo + _amount >= previousBalanceTo);\r\n        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\r\n        updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\r\n        Transfer(0, _owner, _amount);\r\n        return true;\r\n    }\r\n\r\n    function destroyTokens(address _owner, uint _amount\r\n    ) onlyController public returns (bool) {\r\n        uint curTotalSupply = totalSupply();\r\n        require(curTotalSupply >= _amount);\r\n        uint previousBalanceFrom = balanceOf(_owner);\r\n        require(previousBalanceFrom >= _amount);\r\n        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\r\n        updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\r\n        Transfer(_owner, 0, _amount);\r\n        return true;\r\n    }\r\n\r\n    /*\r\n     * 토큰 전송 사용\r\n     */\r\n    function enableTransfers(bool _transfersEnabled) public onlyController {\r\n        transfersEnabled = _transfersEnabled;\r\n    }\r\n\r\n    /*\r\n     * 스냅 샷 배열에서 값을 쿼리하고 설정하는 내부 도우미 함수\r\n     */\r\n    function getValueAt(Checkpoint[] storage checkpoints, uint _block\r\n    ) constant internal returns (uint) {\r\n        if (checkpoints.length == 0) return 0;\r\n\r\n        // 실제 값 바로 가기\r\n        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\r\n            return checkpoints[checkpoints.length-1].value;\r\n        if (_block < checkpoints[0].fromBlock) return 0;\r\n\r\n        // 배열의 값을 2진 검색\r\n        uint min = 0;\r\n        uint max = checkpoints.length-1;\r\n        while (max > min) {\r\n            uint mid = (max + min + 1)/ 2;\r\n            if (checkpoints[mid].fromBlock<=_block) {\r\n                min = mid;\r\n            } else {\r\n                max = mid-1;\r\n            }\r\n        }\r\n        return checkpoints[min].value;\r\n    }\r\n\r\n    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value\r\n    ) internal  {\r\n        if ((checkpoints.length == 0)\r\n        || (checkpoints[checkpoints.length -1].fromBlock < block.number)) {\r\n               Checkpoint storage newCheckPoint = checkpoints[ checkpoints.length++ ];\r\n               newCheckPoint.fromBlock =  uint128(block.number);\r\n               newCheckPoint.value = uint128(_value);\r\n           } else {\r\n               Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length-1];\r\n               oldCheckPoint.value = uint128(_value);\r\n           }\r\n    }\r\n\r\n    function isContract(address _addr) constant internal returns(bool) {\r\n        uint size;\r\n        if (_addr == 0) return false;\r\n        assembly {\r\n            size := extcodesize(_addr)\r\n        }\r\n        return size>0;\r\n    }\r\n\r\n    function min(uint a, uint b) pure internal returns (uint) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function () public payable {\r\n        require(isContract(controller));\r\n        require(TokenController(controller).proxyPayment.value(msg.value)(msg.sender));\r\n    }\r\n\r\n    /*\r\n     * 안전 방법\r\n     */\r\n    function claimTokens(address _token) public onlyController {\r\n        if (_token == 0x0) {\r\n            controller.transfer(this.balance);\r\n            return;\r\n        }\r\n\r\n        MiniMeToken token = MiniMeToken(_token);\r\n        uint balance = token.balanceOf(this);\r\n        token.transfer(controller, balance);\r\n        ClaimedTokens(_token, controller, balance);\r\n    }\r\n\r\n    /*\r\n     * 이벤트\r\n     */\r\n    event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\r\n    event NewCloneToken(address indexed _cloneToken, uint _snapshotBlock);\r\n    event Approval(\r\n        address indexed _owner,\r\n        address indexed _spender,\r\n        uint256 _amount\r\n        );\r\n}\r\n\r\n/*\r\n * MiniMeTokenFactory\r\n */\r\n// 이 계약은 계약에서 복제 계약을 생성하는 데 사용됩니다.\r\ncontract MiniMeTokenFactory {\r\n    //                      새로운 기능으로 새로운 토큰을 만들어 DApp를 업데이트하십시오.\r\n    //  msg.sender          는 이 복제 토큰의 컨트롤러가됩니다.\r\n    // _parentToken         복제 될 토큰의 주소\r\n    // _snapshotBlock       상위 토큰 블록\r\n    //                      복제 토큰의 초기 배포 결정\r\n    // _tokenName           새 토큰의 이름\r\n    // @param _decimalUnits 새 토큰의 소수 자릿수\r\n    // @param _tokenSymbol  새 토큰에 대한 토큰 기호\r\n    // @param _transfersEnabled true 이면 토큰을 전송할 수 있습니다.\r\n    // @return              새 토큰 계약의 주소\r\n    function createCloneToken(\r\n        address _parentToken,\r\n        uint _snapshotBlock,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol,\r\n        bool _transfersEnabled\r\n    ) public returns (MiniMeToken) {\r\n        MiniMeToken newToken = new MiniMeToken(\r\n            this,\r\n            _parentToken,\r\n            _snapshotBlock,\r\n            _tokenName,\r\n            _decimalUnits,\r\n            _tokenSymbol,\r\n            _transfersEnabled\r\n            );\r\n\r\n        newToken.changeController(msg.sender);\r\n        return newToken;\r\n    }\r\n}\r\n\r\n/**\r\n * @title LEN\r\n * @dev LEN는 MiniMeToken을 상속받은 ERC20 토큰 계약입니다.\r\n */\r\ncontract LEN is MiniMeToken, Blockeds {\r\n  bool public StorageEnabled = true;\r\n\r\n  modifier onlyStorageEnabled() {\r\n    require(StorageEnabled);\r\n    _;\r\n  }\r\n\r\n  modifier onlyNotBlocked(address _addr) {\r\n    require(!blocked[_addr]);\r\n    _;\r\n  }\r\n\r\n  event StorageEnabled(bool _StorageEnabled);\r\n\r\n  function LEN(address _tokenFactory) MiniMeToken(\r\n    _tokenFactory,\r\n    0x0,                  // 부모 토큰 없음\r\n    0,                    // 상위의 스냅 샷 블록 번호 없음\r\n    \"Lending Token\",      // 토큰 이름\r\n    18,                   // 십진법\r\n    \"LEN\",                // 상징(심볼)\r\n    false                 // 전송 사용\r\n  ) public {}\r\n\r\n  function transfer(address _to, uint256 _amount) public onlyNotBlocked(msg.sender) returns (bool success) {\r\n    return super.transfer(_to, _amount);\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint256 _amount) public onlyNotBlocked(_from) returns (bool success) {\r\n    return super.transferFrom(_from, _to, _amount);\r\n  }\r\n\r\n  // 아래의 4개 기능은 'Storagersabled(하위 설정됨)'로만 활성화됩니다.\r\n  // ALL : 3 개의 Storage 레벨\r\n  function generateTokens(address _owner, uint _amount) public onlyController onlyStorageEnabled returns (bool) {\r\n    return super.generateTokens(_owner, _amount);\r\n  }\r\n\r\n  function destroyTokens(address _owner, uint _amount) public onlyController onlyStorageEnabled returns (bool) {\r\n    return super.destroyTokens(_owner, _amount);\r\n  }\r\n\r\n  function blockAddress(address _addr) public onlyController onlyStorageEnabled {\r\n    super.blockAddress(_addr);\r\n  }\r\n\r\n  function unblockAddress(address _addr) public onlyController onlyStorageEnabled {\r\n    super.unblockAddress(_addr);\r\n  }\r\n\r\n  function enableStorage(bool _StorageEnabled) public onlyController {\r\n    StorageEnabled = _StorageEnabled;\r\n    StorageEnabled(_StorageEnabled);\r\n  }\r\n\r\n  // byList 함수\r\n  function generateTokensByList(address[] _owners, uint[] _amounts) public onlyController onlyStorageEnabled returns (bool) {\r\n    require(_owners.length == _amounts.length);\r\n\r\n    for(uint i = 0; i < _owners.length; i++) {\r\n      generateTokens(_owners[i], _amounts[i]);\r\n    }\r\n\r\n    return true;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"creationBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"unblockAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newController\",\"type\":\"address\"}],\"name\":\"changeController\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"balanceOfAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cloneTokenName\",\"type\":\"string\"},{\"name\":\"_cloneDecimalUnits\",\"type\":\"uint8\"},{\"name\":\"_cloneTokenSymbol\",\"type\":\"string\"},{\"name\":\"_snapshotBlock\",\"type\":\"uint256\"},{\"name\":\"_transfersEnabled\",\"type\":\"bool\"}],\"name\":\"createCloneToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"generateTokensByList\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"parentToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"generateTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"totalSupplyAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_StorageEnabled\",\"type\":\"bool\"}],\"name\":\"enableStorage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"blockAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"StorageEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transfersEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"parentSnapShotBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"destroyTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"claimTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenFactory\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_transfersEnabled\",\"type\":\"bool\"}],\"name\":\"enableTransfers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenFactory\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_StorageEnabled\",\"type\":\"bool\"}],\"name\":\"StorageEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"Blocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"Unblocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_controller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ClaimedTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_cloneToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_snapshotBlock\",\"type\":\"uint256\"}],\"name\":\"NewCloneToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"LEN","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000001b45bf188714e2da4c8b09ec0ddf32e05c2abb9d","Library":"","SwarmSource":"bzzr://107d7582d7dfe7e316986bd3dfcc7df972de8a5f0bdbc68f6d333119355d15d4"}]}