{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * Edgeless Casino Proxy Contract. Serves as a proxy for game functionality.\r\n * Allows the players to deposit and withdraw funds.\r\n * Allows authorized addresses to make game transactions.\r\n * author: Julia Altenried\r\n **/\r\n\r\npragma solidity ^ 0.4 .17;\r\n\r\n\r\ncontract token {\r\n\tfunction transferFrom(address sender, address receiver, uint amount) public returns(bool success) {}\r\n\r\n\tfunction transfer(address receiver, uint amount) public returns(bool success) {}\r\n\r\n\tfunction balanceOf(address holder) public constant returns(uint) {}\r\n}\r\n\r\ncontract owned {\r\n\taddress public owner;\r\n\tmodifier onlyOwner {\r\n\t\trequire(msg.sender == owner);\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction owned() public {\r\n\t\towner = msg.sender;\r\n\t}\r\n\r\n\tfunction changeOwner(address newOwner) onlyOwner public {\r\n\t\towner = newOwner;\r\n\t}\r\n}\r\n\r\ncontract safeMath {\r\n\t//internals\r\n\tfunction safeSub(uint a, uint b) constant internal returns(uint) {\r\n\t\tassert(b <= a);\r\n\t\treturn a - b;\r\n\t}\r\n\r\n\tfunction safeAdd(uint a, uint b) constant internal returns(uint) {\r\n\t\tuint c = a + b;\r\n\t\tassert(c >= a && c >= b);\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction safeMul(uint a, uint b) constant internal returns(uint) {\r\n\t\tuint c = a * b;\r\n\t\tassert(a == 0 || c / a == b);\r\n\t\treturn c;\r\n\t}\r\n}\r\n\r\ncontract casinoBank is owned, safeMath {\r\n\t/** the total balance of all players with 4 virtual decimals **/\r\n\tuint public playerBalance;\r\n\t/** the balance per player in edgeless tokens with 4 virtual decimals */\r\n\tmapping(address => uint) public balanceOf;\r\n\t/** in case the user wants/needs to call the withdraw function from his own wallet, he first needs to request a withdrawal */\r\n\tmapping(address => uint) public withdrawAfter;\r\n\t/** the price per kgas in tokens (4 decimals) */\r\n\tuint public gasPrice = 20;\r\n\t/** the edgeless token contract */\r\n\ttoken edg;\r\n\t/** owner should be able to close the contract is nobody has been using it for at least 30 days */\r\n\tuint public closeAt;\r\n\t/** informs listeners how many tokens were deposited for a player */\r\n\tevent Deposit(address _player, uint _numTokens, bool _chargeGas);\r\n\t/** informs listeners how many tokens were withdrawn from the player to the receiver address */\r\n\tevent Withdrawal(address _player, address _receiver, uint _numTokens);\r\n\r\n\tfunction casinoBank(address tokenContract) public {\r\n\t\tedg = token(tokenContract);\r\n\t}\r\n\r\n\t/**\r\n\t * accepts deposits for an arbitrary address.\r\n\t * retrieves tokens from the message sender and adds them to the balance of the specified address.\r\n\t * edgeless tokens do not have any decimals, but are represented on this contract with 4 decimals.\r\n\t * @param receiver  address of the receiver\r\n\t *        numTokens number of tokens to deposit (0 decimals)\r\n\t *\t\t\t\t chargeGas indicates if the gas cost is subtracted from the user's edgeless token balance\r\n\t **/\r\n\tfunction deposit(address receiver, uint numTokens, bool chargeGas) public isAlive {\r\n\t\trequire(numTokens > 0);\r\n\t\tuint value = safeMul(numTokens, 10000);\r\n\t\tif (chargeGas) value = safeSub(value, msg.gas / 1000 * gasPrice);\r\n\t\tassert(edg.transferFrom(msg.sender, address(this), numTokens));\r\n\t\tbalanceOf[receiver] = safeAdd(balanceOf[receiver], value);\r\n\t\tplayerBalance = safeAdd(playerBalance, value);\r\n\t\tDeposit(receiver, numTokens, chargeGas);\r\n\t}\r\n\r\n\t/**\r\n\t * If the user wants/needs to withdraw his funds himself, he needs to request the withdrawal first.\r\n\t * This method sets the earliest possible withdrawal date to 7 minutes from now. \r\n\t * Reason: The user should not be able to withdraw his funds, while the the last game methods have not yet been mined.\r\n\t **/\r\n\tfunction requestWithdrawal() public {\r\n\t\twithdrawAfter[msg.sender] = now + 7 minutes;\r\n\t}\r\n\r\n\t/**\r\n\t * In case the user requested a withdrawal and changes his mind.\r\n\t * Necessary to be able to continue playing.\r\n\t **/\r\n\tfunction cancelWithdrawalRequest() public {\r\n\t\twithdrawAfter[msg.sender] = 0;\r\n\t}\r\n\r\n\t/**\r\n\t * withdraws an amount from the user balance if 7 minutes passed since the request.\r\n\t * @param amount the amount of tokens to withdraw\r\n\t **/\r\n\tfunction withdraw(uint amount) public keepAlive {\r\n\t\trequire(withdrawAfter[msg.sender] > 0 && now > withdrawAfter[msg.sender]);\r\n\t\twithdrawAfter[msg.sender] = 0;\r\n\t\tuint value = safeMul(amount, 10000);\r\n\t\tbalanceOf[msg.sender] = safeSub(balanceOf[msg.sender], value);\r\n\t\tplayerBalance = safeSub(playerBalance, value);\r\n\t\tassert(edg.transfer(msg.sender, amount));\r\n\t\tWithdrawal(msg.sender, msg.sender, amount);\r\n\t}\r\n\r\n\t/**\r\n\t * lets the owner withdraw from the bankroll\r\n\t * @param numTokens the number of tokens to withdraw (0 decimals)\r\n\t **/\r\n\tfunction withdrawBankroll(uint numTokens) public onlyOwner {\r\n\t\trequire(numTokens <= bankroll());\r\n\t\tassert(edg.transfer(owner, numTokens));\r\n\t}\r\n\r\n\t/**\r\n\t * returns the current bankroll in tokens with 0 decimals\r\n\t **/\r\n\tfunction bankroll() constant public returns(uint) {\r\n\t\treturn safeSub(edg.balanceOf(address(this)), playerBalance / 10000);\r\n\t}\r\n\r\n\t/** \r\n\t * lets the owner close the contract if there are no player funds on it or if nobody has been using it for at least 30 days \r\n\t */\r\n\tfunction close() onlyOwner public {\r\n\t\tif (playerBalance == 0) selfdestruct(owner);\r\n\t\tif (closeAt == 0) closeAt = now + 30 days;\r\n\t\telse if (closeAt < now) selfdestruct(owner);\r\n\t}\r\n\r\n\t/**\r\n\t * in case close has been called accidentally.\r\n\t **/\r\n\tfunction open() onlyOwner public {\r\n\t\tcloseAt = 0;\r\n\t}\r\n\r\n\t/**\r\n\t * make sure the contract is not in process of being closed.\r\n\t **/\r\n\tmodifier isAlive {\r\n\t\trequire(closeAt == 0);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * delays the time of closing.\r\n\t **/\r\n\tmodifier keepAlive {\r\n\t\tif (closeAt > 0) closeAt = now + 30 days;\r\n\t\t_;\r\n\t}\r\n}\r\n\r\ncontract casinoProxy is casinoBank {\r\n\t/** indicates if an address is authorized to call game functions  */\r\n\tmapping(address => bool) public authorized;\r\n\t/** list of casino game contract addresses */\r\n\taddress[] public casinoGames;\r\n\t/** a number to count withdrawal signatures to ensure each signature is different even if withdrawing the same amount to the same address */\r\n\tmapping(address => uint) public count;\r\n\r\n\tmodifier onlyAuthorized {\r\n\t\trequire(authorized[msg.sender]);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier onlyCasinoGames {\r\n\t\tbool isCasino;\r\n\t\tfor (uint i = 0; i < casinoGames.length; i++) {\r\n\t\t\tif (msg.sender == casinoGames[i]) {\r\n\t\t\t\tisCasino = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\trequire(isCasino);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * creates a new casino wallet.\r\n\t * @param authorizedAddress the address which may send transactions to the Edgeless Casino\r\n\t *        blackjackAddress  the address of the Edgeless blackjack contract\r\n\t *\t\t\t\t tokenContract     the address of the Edgeless token contract\r\n\t **/\r\n\tfunction casinoProxy(address authorizedAddress, address blackjackAddress, address tokenContract) casinoBank(tokenContract) public {\r\n\t\tauthorized[authorizedAddress] = true;\r\n\t\tcasinoGames.push(blackjackAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * shifts tokens from the contract balance to the receiver.\r\n\t * only callable from an edgeless casino contract.\r\n\t * @param receiver the address of the receiver\r\n\t *        numTokens the amount of tokens to shift with 4 decimals\r\n\t **/\r\n\tfunction shift(address receiver, uint numTokens) public onlyCasinoGames {\r\n\t\tbalanceOf[receiver] = safeAdd(balanceOf[receiver], numTokens);\r\n\t\tplayerBalance = safeAdd(playerBalance, numTokens);\r\n\t}\r\n\r\n\t/**\r\n\t * transfers an amount from the contract balance to the owner's wallet.\r\n\t * @param receiver the receiver address\r\n\t *\t\t\t\t amount   the amount of tokens to withdraw (0 decimals)\r\n\t *\t\t\t\t v,r,s \t\tthe signature of the player\r\n\t **/\r\n\tfunction withdrawFor(address receiver, uint amount, uint8 v, bytes32 r, bytes32 s) public onlyAuthorized keepAlive {\r\n\t\tuint gasCost = msg.gas / 1000 * gasPrice;\r\n\t\tvar player = ecrecover(keccak256(receiver, amount, count[receiver]), v, r, s);\r\n\t\tcount[receiver]++;\r\n\t\tuint value = safeAdd(safeMul(amount, 10000), gasCost);\r\n\t\tbalanceOf[player] = safeSub(balanceOf[player], value);\r\n\t\tplayerBalance = safeSub(playerBalance, value);\r\n\t\tassert(edg.transfer(receiver, amount));\r\n\t\tWithdrawal(player, receiver, amount);\r\n\t}\r\n\r\n\t/**\r\n\t * update a casino game address in case of a new contract or a new casino game\r\n\t * @param game       the index of the game \r\n\t *        newAddress the new address of the game\r\n\t **/\r\n\tfunction setGameAddress(uint8 game, address newAddress) public onlyOwner {\r\n\t\tif (game < casinoGames.length) casinoGames[game] = newAddress;\r\n\t\telse casinoGames.push(newAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * authorize a address to call game functions.\r\n\t * @param addr the address to be authorized\r\n\t **/\r\n\tfunction authorize(address addr) public onlyOwner {\r\n\t\tauthorized[addr] = true;\r\n\t}\r\n\r\n\t/**\r\n\t * deauthorize a address to call game functions.\r\n\t * @param addr the address to be deauthorized\r\n\t **/\r\n\tfunction deauthorize(address addr) public onlyOwner {\r\n\t\tauthorized[addr] = false;\r\n\t}\r\n\r\n\t/**\r\n\t * updates the price per 1000 gas in EDG.\r\n\t * @param price the new gas price (4 decimals, max 0.0256 EDG)\r\n\t **/\r\n\tfunction setGasPrice(uint8 price) public onlyOwner {\r\n\t\tgasPrice = price;\r\n\t}\r\n\r\n\t/**\r\n\t * Forwards a move to the corresponding game contract if the data has been signed by the client.\r\n\t * The casino contract ensures it is no duplicate move.\r\n\t * @param game  specifies which game contract to call\r\n\t *        value the value to send to the contract in tokens with 4 decimals\r\n\t *        data  the function call\r\n\t *        v,r,s the player's signature of the data\r\n\t **/\r\n\tfunction move(uint8 game, uint value, bytes data, uint8 v, bytes32 r, bytes32 s) public onlyAuthorized isAlive {\r\n\t\trequire(game < casinoGames.length);\r\n\t\trequire(safeMul(bankroll(), 10000) > value * 8); //make sure, the casino can always pay out the player\r\n\t\tvar player = ecrecover(keccak256(data), v, r, s);\r\n\t\trequire(withdrawAfter[player] == 0 || now < withdrawAfter[player]);\r\n\t\tvalue = safeAdd(value, msg.gas / 1000 * gasPrice);\r\n\t\tbalanceOf[player] = safeSub(balanceOf[player], value);\r\n\t\tplayerBalance = safeSub(playerBalance, value);\r\n\t\tassert(casinoGames[game].call(data));\r\n\t}\r\n\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"count\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bankroll\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"numTokens\",\"type\":\"uint256\"}],\"name\":\"withdrawBankroll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"deauthorize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"price\",\"type\":\"uint8\"}],\"name\":\"setGasPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"numTokens\",\"type\":\"uint256\"},{\"name\":\"chargeGas\",\"type\":\"bool\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"close\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"withdrawAfter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"playerBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"withdrawFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closeAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"authorize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"game\",\"type\":\"uint8\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"move\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"numTokens\",\"type\":\"uint256\"}],\"name\":\"shift\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"casinoGames\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"requestWithdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cancelWithdrawalRequest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"game\",\"type\":\"uint8\"},{\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setGameAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"open\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gasPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"authorizedAddress\",\"type\":\"address\"},{\"name\":\"blackjackAddress\",\"type\":\"address\"},{\"name\":\"tokenContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_numTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_chargeGas\",\"type\":\"bool\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_numTokens\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"}]","ContractName":"casinoProxy","CompilerVersion":"v0.4.17+commit.bdeb9e52","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000007ab5dfc486af477c19055d0e34ba0436b32c5e540000000000000000000000007450f90f3e020e964829187697fcbc6d8273564400000000000000000000000008711d3b02c8758f2fb3ab4e80228418a7f8e39c","Library":"","SwarmSource":"bzzr://750daf42e6018e94761eadcbd54957bdca6589a8e705c5d0419a808ac38738ed"}]}