{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.4.10;\r\n\r\n/*  ----------------------------------------------------------------------------------------\r\n\r\n    Dev:    \"Owned\" to ensure control of contracts\r\n\r\n            Identical to https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/ownership/Ownable.sol\r\n\r\n    ---------------------------------------------------------------------------------------- */\r\ncontract Owned {\r\n    address public owner;\r\n\r\n    function Owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) onlyOwner {\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n/*  ----------------------------------------------------------------------------------------\r\n\r\n    Dev:    SafeMath library\r\n\r\n            Identical to https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\r\n\r\n    ---------------------------------------------------------------------------------------- */\r\nlibrary SafeMath {\r\n  function safeMul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeDiv(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a); // Ensuring no negatives\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a && c>=b);\r\n    return c;\r\n  }\r\n}\r\n\r\n/*  ----------------------------------------------------------------------------------------\r\n\r\n    Dev:    ESG Asset Holder is called when the token \"burn\" function is called\r\n\r\n    Sum:    Locked to false so users cannot burn their tokens until the Asset Contract is\r\n            put in place with value.\r\n\r\n    ---------------------------------------------------------------------------------------- */\r\ncontract ESGAssetHolder {\r\n    \r\n    function burn(address _holder, uint _amount) returns (bool result) {\r\n\r\n        _holder = 0x0;                              // To avoid variable not used issue on deployment\r\n        _amount = 0;                                // To avoid variable not used issue on deployment\r\n        return false;\r\n    }\r\n}\r\n\r\n\r\n/*  ----------------------------------------------------------------------------------------\r\n\r\n    Dev:    The Esports Gold Token:  ERC20 standard token with MINT and BURN functions\r\n\r\n    Func:   Mint, Approve, Transfer, TransferFrom  \r\n\r\n    Note:   Mint function takes UNITS of tokens to mint as ICO event is set to have a minimum\r\n            contribution of 1 token. All other functions (transfer etc), the value to transfer\r\n            is the FULL DECIMAL value\r\n            The user is only ever presented with the latter option, therefore should avoid\r\n            any confusion.\r\n    ---------------------------------------------------------------------------------------- */\r\ncontract ESGToken is Owned {\r\n        \r\n    string public name = \"ESG Token\";               // Name of token\r\n    string public symbol = \"ESG\";                   // Token symbol\r\n    uint256 public decimals = 3;                    // Decimals for the token\r\n    uint256 public currentSupply;                   // Current supply of tokens\r\n    uint256 public supplyCap;                       // Hard cap on supply of tokens\r\n    address public ICOcontroller;                   // Controlling contract from ICO\r\n    address public timelockTokens;                  // Address for locked management tokens\r\n    bool public tokenParametersSet;                        // Ensure that parameters required are set\r\n    bool public controllerSet;                             // Ensure that ICO controller is set\r\n\r\n    mapping (address => uint256) public balanceOf;                      // Balances of addresses\r\n    mapping (address => mapping (address => uint)) public allowance;    // Allowances from addresses\r\n    mapping (address => bool) public frozenAccount;                     // Safety mechanism\r\n\r\n\r\n    modifier onlyControllerOrOwner() {            // Ensures that only contracts can manage key functions\r\n        require(msg.sender == ICOcontroller || msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Mint(address owner, uint amount);\r\n    event FrozenFunds(address target, bool frozen);\r\n    event Burn(address coinholder, uint amount);\r\n    \r\n    /*  ----------------------------------------------------------------------------------------\r\n\r\n    Dev:    Constructor\r\n\r\n    param:  Owner:  Address of owner\r\n            Name:   Esports Gold Token\r\n            Sym:    ESG_TKN\r\n            Dec:    3\r\n            Cap:    Hard coded cap to ensure excess tokens cannot be minted\r\n\r\n    Other parameters have been set up as a separate function to help lower initial gas deployment cost.\r\n\r\n    ---------------------------------------------------------------------------------------- */\r\n    function ESGToken() {\r\n        currentSupply = 0;                      // Starting supply is zero\r\n        supplyCap = 0;                          // Hard cap supply in Tokens set by ICO\r\n        tokenParametersSet = false;             // Ensure parameters are set\r\n        controllerSet = false;                  // Ensure controller is set\r\n    }\r\n\r\n    /*  ----------------------------------------------------------------------------------------\r\n\r\n    Dev:    Key parameters to setup for ICO event\r\n\r\n    Param:  _ico    Address of the ICO Event contract to ensure the ICO event can control\r\n                    the minting function\r\n    \r\n    ---------------------------------------------------------------------------------------- */\r\n    function setICOController(address _ico) onlyOwner {     // ICO event address is locked in\r\n        require(_ico != 0x0);\r\n        ICOcontroller = _ico;\r\n        controllerSet = true;\r\n    }\r\n\r\n\r\n    /*  ----------------------------------------------------------------------------------------\r\n    NEW\r\n    Dev:    Address for the timelock tokens to be held\r\n\r\n    Param:  _timelockAddr   Address of the timelock contract that will hold the locked tokens\r\n    \r\n    ---------------------------------------------------------------------------------------- */\r\n    function setParameters(address _timelockAddr) onlyOwner {\r\n        require(_timelockAddr != 0x0);\r\n\r\n        timelockTokens = _timelockAddr;\r\n\r\n        tokenParametersSet = true;\r\n    }\r\n\r\n    function parametersAreSet() constant returns (bool) {\r\n        return tokenParametersSet && controllerSet;\r\n    }\r\n\r\n    /*  ----------------------------------------------------------------------------------------\r\n\r\n    Dev:    Set the total number of Tokens that can be minted\r\n\r\n    Param:  _supplyCap  The number of tokens (in whole units) that can be minted. This number then\r\n                        gets increased by the decimal number\r\n   \r\n    ---------------------------------------------------------------------------------------- */\r\n    function setTokenCapInUnits(uint256 _supplyCap) onlyControllerOrOwner {   // Supply cap in UNITS\r\n        assert(_supplyCap > 0);\r\n        \r\n        supplyCap = SafeMath.safeMul(_supplyCap, (10**decimals));\r\n    }\r\n\r\n    /*  ----------------------------------------------------------------------------------------\r\n\r\n    Dev:    Mint the number of tokens for the timelock contract\r\n\r\n    Param:  _mMentTkns  Number of tokens in whole units that need to be locked into the Timelock\r\n    \r\n    ---------------------------------------------------------------------------------------- */\r\n    function mintLockedTokens(uint256 _mMentTkns) onlyControllerOrOwner {\r\n        assert(_mMentTkns > 0);\r\n        assert(tokenParametersSet);\r\n\r\n        mint(timelockTokens, _mMentTkns);  \r\n    }\r\n\r\n    /*  ----------------------------------------------------------------------------------------\r\n\r\n    Dev:    Gets the balance of the address owner\r\n\r\n    Param:  _owner  Address of the owner querying their balance\r\n    \r\n    ---------------------------------------------------------------------------------------- */\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balanceOf[_owner];\r\n    }\r\n\r\n    /*  ----------------------------------------------------------------------------------------\r\n\r\n    Dev:    Mint ESG Tokens by controller\r\n\r\n    Control:            OnlyControllers. ICO event needs to be able to control the minting\r\n                        function\r\n\r\n    Param:  Address     Address for tokens to be minted to\r\n            Amount      Number of tokens to be minted (in whole UNITS. Min minting is 1 token)\r\n                        Minimum ETH contribution in ICO event is 0.01ETH at 100 tokens per ETH\r\n    \r\n    ---------------------------------------------------------------------------------------- */\r\n    function mint(address _address, uint _amount) onlyControllerOrOwner {\r\n        require(_address != 0x0);\r\n        uint256 amount = SafeMath.safeMul(_amount, (10**decimals));             // Tokens minted using unit parameter supplied\r\n\r\n        // Ensure that supplyCap is set and that new tokens don't breach cap\r\n        assert(supplyCap > 0 && amount > 0 && SafeMath.safeAdd(currentSupply, amount) <= supplyCap);\r\n        \r\n        balanceOf[_address] = SafeMath.safeAdd(balanceOf[_address], amount);    // Add tokens to address\r\n        currentSupply = SafeMath.safeAdd(currentSupply, amount);                // Add to supply\r\n        \r\n        Mint(_address, amount);\r\n    }\r\n    \r\n    /*  ----------------------------------------------------------------------------------------\r\n\r\n    Dev:    ERC20 standard transfer function\r\n\r\n    Param:  _to         Address to send to\r\n            _value      Number of tokens to be sent - in FULL decimal length\r\n    \r\n    Ref:    https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/BasicToken.sol\r\n    ---------------------------------------------------------------------------------------- */\r\n    function transfer(address _to, uint _value) returns (bool success) {\r\n        require(!frozenAccount[msg.sender]);        // Ensure account is not frozen\r\n\r\n        /* \r\n            Update balances from \"from\" and \"to\" addresses with the tokens transferred\r\n            safeSub method ensures that address sender has enough tokens to send\r\n        */\r\n        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);    \r\n        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                  \r\n        Transfer(msg.sender, _to, _value);\r\n        \r\n        return true;\r\n    }\r\n    \r\n    /*  ----------------------------------------------------------------------------------------\r\n\r\n    Dev:    ERC20 standard transferFrom function\r\n\r\n    Param:  _from       Address to send from\r\n            _to         Address to send to\r\n            Amount      Number of tokens to be sent - in FULL decimal length\r\n\r\n    ---------------------------------------------------------------------------------------- */\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {   \r\n        require(!frozenAccount[_from]);                         // Check account is not frozen\r\n        \r\n        /* \r\n            Ensure sender has been authorised to send the required number of tokens\r\n        */\r\n        if (allowance[_from][msg.sender] < _value)\r\n            return false;\r\n\r\n        /* \r\n            Update allowance of sender to reflect tokens sent\r\n        */\r\n        allowance[_from][msg.sender] = SafeMath.safeSub(allowance[_from][msg.sender], _value); \r\n\r\n        /* \r\n            Update balances from \"from\" and \"to\" addresses with the tokens transferred\r\n            safeSub method ensures that address sender has enough tokens to send\r\n        */\r\n        balanceOf[_from] = SafeMath.safeSub(balanceOf[_from], _value);\r\n        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);\r\n\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n    \r\n    /*  ----------------------------------------------------------------------------------------\r\n\r\n    Dev:    ERC20 standard approve function\r\n\r\n    Param:  _spender        Address of sender who is approved\r\n            _value          The number of tokens (full decimals) that are approved\r\n\r\n    ---------------------------------------------------------------------------------------- */\r\n    function approve(address _spender, uint256 _value)      // FULL DECIMALS OF TOKENS\r\n        returns (bool success)\r\n    {\r\n        require(!frozenAccount[msg.sender]);                // Check account is not frozen\r\n\r\n        /* Requiring the user to set to zero before resetting to nonzero */\r\n        if ((_value != 0) && (allowance[msg.sender][_spender] != 0)) {\r\n           return false;\r\n        }\r\n\r\n        allowance[msg.sender][_spender] = _value;\r\n        \r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /*  ----------------------------------------------------------------------------------------\r\n\r\n    Dev:    Function to check the amount of tokens that the owner has allowed the \"spender\" to\r\n            transfer\r\n\r\n    Param:  _owner          Address of the authoriser who owns the tokens\r\n            _spender        Address of sender who will be authorised to spend the tokens\r\n\r\n    ---------------------------------------------------------------------------------------- */\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return allowance[_owner][_spender];\r\n    }\r\n    \r\n    /*  ----------------------------------------------------------------------------------------\r\n\r\n    Dev:    As ESG is aiming to be a regulated betting operator. Regulatory hurdles may require\r\n            this function if an account on the betting platform, using the token, breaches\r\n            a regulatory requirement.\r\n\r\n            ESG can then engage with the account holder to get it unlocked\r\n\r\n            This does not stop the token accruing value from its share of the Asset Contract\r\n\r\n    Param:  _target         Address of account\r\n            _freeze         Boolean to lock/unlock account\r\n\r\n    Ref:    This is a replica of the code as per https://ethereum.org/token\r\n    ---------------------------------------------------------------------------------------- */\r\n    function freezeAccount(address target, bool freeze) onlyOwner {\r\n        frozenAccount[target] = freeze;\r\n        FrozenFunds(target, freeze);\r\n    }\r\n\r\n    /*  ----------------------------------------------------------------------------------------\r\n\r\n    Dev:    Burn function: User is able to burn their token for a share of the ESG Asset Contract\r\n\r\n    Note:   Deployed with the ESG Asset Contract set to false to ensure token holders cannot\r\n            accidentally burn their tokens for zero value\r\n\r\n    Param:  _amount         Number of tokens (full decimals) that should be burnt\r\n\r\n    Ref:    Based on the open source TokenCard Burn function. A copy can be found at\r\n            https://github.com/bokkypoobah/TokenCardICOAnalysis\r\n    ---------------------------------------------------------------------------------------- */\r\n    function burn(uint _amount) returns (bool result) {\r\n\r\n        if (_amount > balanceOf[msg.sender])\r\n            return false;       // If owner has enough to burn\r\n\r\n        /* \r\n            Remove tokens from circulation\r\n            Update sender's balance of tokens\r\n        */\r\n        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _amount);\r\n        currentSupply = SafeMath.safeSub(currentSupply, _amount);\r\n\r\n        // Call burn function\r\n        result = esgAssetHolder.burn(msg.sender, _amount);\r\n        require(result);\r\n\r\n        Burn(msg.sender, _amount);\r\n    }\r\n\r\n    /*  ----------------------------------------------------------------------------------------\r\n\r\n    Dev:    Section of the contract that links to the ESG Asset Contract\r\n\r\n    Note:   Deployed with the ESG Asset Contract set to false to ensure token holders cannot\r\n            accidentally burn their tokens for zero value\r\n\r\n    Param:  _amount         Number of tokens (full decimals) that should be burnt\r\n\r\n    Ref:    Based on the open source TokenCard Burn function. A copy can be found at\r\n            https://github.com/bokkypoobah/TokenCardICOAnalysis\r\n    ---------------------------------------------------------------------------------------- */\r\n\r\n    ESGAssetHolder esgAssetHolder;              // Holds the accumulated asset contract\r\n    bool lockedAssetHolder;                     // Will be locked to stop tokenholder to be upgraded\r\n\r\n    function lockAssetHolder() onlyOwner {      // Locked once deployed\r\n        lockedAssetHolder = true;\r\n    }\r\n\r\n    function setAssetHolder(address _assetAdress) onlyOwner {   // Used to lock in the Asset Contract\r\n        assert(!lockedAssetHolder);             // Check that we haven't locked the asset holder yet\r\n        esgAssetHolder = ESGAssetHolder(_assetAdress);\r\n    }    \r\n}\r\n\r\n    /*  ----------------------------------------------------------------------------------------\r\n\r\n    Dev:    Vested token option for management - locking in account holders for 2 years\r\n\r\n    Ref:    Identical to OpenZeppelin open source contract except releaseTime is locked in\r\n            https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/TokenTimelock.sol\r\n\r\n    ---------------------------------------------------------------------------------------- */\r\ncontract TokenTimelock {\r\n\r\n    // ERC20 basic token contract being held\r\n    ESGToken token;\r\n\r\n    // beneficiary of tokens after they are released\r\n    address public beneficiary;\r\n\r\n    // timestamp when token release is enabled\r\n    uint256 public releaseTime;\r\n\r\n    function TokenTimelock(address _token, address _beneficiary) {\r\n        require(_token != 0x0);\r\n        require(_beneficiary != 0x0);\r\n\r\n        token = ESGToken(_token);\r\n        //token = _token;\r\n        beneficiary = _beneficiary;\r\n        releaseTime = now + 2 years;\r\n    }\r\n\r\n    /* \r\n        Show the balance in the timelock for transparency\r\n        Therefore transparent view of the whitepaper allotted management tokens\r\n    */\r\n    function lockedBalance() public constant returns (uint256) {\r\n        return token.balanceOf(this);\r\n    }\r\n\r\n    /* \r\n        Transfers tokens held by timelock to beneficiary\r\n    */\r\n    function release() {\r\n        require(now >= releaseTime);\r\n\r\n        uint256 amount = token.balanceOf(this);\r\n        require(amount > 0);\r\n\r\n        token.transfer(beneficiary, amount);\r\n    }\r\n}\r\n\r\n    /*  ----------------------------------------------------------------------------------------\r\n\r\n    Dev:    ICO Controller event\r\n\r\n            ICO Controller manages the ICO event including payable functions that trigger mint,\r\n            Refund collections, Base target and ICO discount rates for deposits before Base\r\n            Target\r\n\r\n    Ref:    Modified version of crowdsale contract with refund option (if base target not reached)\r\n            https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/crowdsale/Crowdsale.sol\r\n            https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/crowdsale/RefundVault.sol           \r\n    ---------------------------------------------------------------------------------------- */\r\ncontract ICOEvent is Owned {\r\n\r\n    ESGToken public token;                              // ESG TOKEN used for Deposit, Claims, Set Address\r\n\r\n    uint256 public startTime = 0;                       // StartTime default\r\n    uint256 public endTime;                             // End time is start + duration\r\n    uint256 duration;                                   // Duration in days for ICO\r\n    bool parametersSet;                                 // Ensure paramaters are locked in before starting ICO\r\n    bool supplySet;                                     // Ensure token supply set\r\n\r\n    address holdingAccount = 0x0;                       // Address for successful closing of ICO\r\n    uint256 public totalTokensMinted;                   // To record total number of tokens minted\r\n\r\n    // For purchasing tokens\r\n    uint256 public rate_toTarget;                       // Rate of tokens per 1 ETH contributed to the base target\r\n    uint256 public rate_toCap;                          // Rate of tokens from base target to cap per 1 ETH\r\n    uint256 public totalWeiContributed = 0;             // Tracks total Ether contributed in WEI\r\n    uint256 public minWeiContribution = 0.01 ether;     // At 100:1ETH means 1 token = the minimum contribution\r\n    uint256 constant weiEtherConversion = 10**18;       // To allow inputs for setup in ETH for simplicity\r\n\r\n    // Cap parameters\r\n    uint256 public baseTargetInWei;                     // Target for bonus rate of tokens\r\n    uint256 public icoCapInWei;                         // Max cap of the ICO in Wei\r\n\r\n    event logPurchase (address indexed purchaser, uint value, uint256 tokens);\r\n\r\n    enum State { Active, Refunding, Closed }            // Allows control of the ICO state\r\n    State public state;\r\n    mapping (address => uint256) public deposited;      // Mapping for address deposit amounts\r\n    mapping (address => uint256) public tokensIssued;   // Mapping for address token amounts\r\n\r\n    /*  ----------------------------------------------------------------------------------------\r\n\r\n    Dev:    Constructor\r\n\r\n    param:  Parameters are set individually after construction to lower initial deployment gas\r\n            State:  set default state to active\r\n\r\n    ---------------------------------------------------------------------------------------- */\r\n    function ICOEvent() {\r\n        state = State.Active;\r\n        totalTokensMinted = 0;\r\n        parametersSet = false;\r\n        supplySet = false;\r\n    }\r\n\r\n    /*  ----------------------------------------------------------------------------------------\r\n\r\n    Dev:    This section is to set parameters for the ICO control by the owner\r\n\r\n    Param:  _tokenAddress   Address of the ESG Token contract that has been deployed\r\n            _target_rate    Number of tokens (in units, excl token decimals) per 1 ETH contribution\r\n                            up to the ETH base target\r\n            _cap_rate       Number of tokens (in units, excl token decimals) per 1 ETH contribution\r\n                            from the base target to the ICO cap\r\n            _baseTarget     Number of ETH to reach the base target. ETH is refunded if base target\r\n                            is not reached\r\n            _cap            Total ICO cap in ETH. No further ETH can be deposited beyond this\r\n            _holdingAccount Address of the beneficiary account on a successful ICO\r\n            _duration       Duration of ICO in days\r\n    ---------------------------------------------------------------------------------------- */ \r\n    function ICO_setParameters(address _tokenAddress, uint256 _target_rate, uint256 _cap_rate, uint256 _baseTarget, uint256 _cap, address _holdingAccount, uint256 _duration) onlyOwner {\r\n        require(_target_rate > 0 && _cap_rate > 0);\r\n        require(_baseTarget >= 0);\r\n        require(_cap > 0);\r\n        require(_duration > 0);\r\n        require(_holdingAccount != 0x0);\r\n        require(_tokenAddress != 0x0);\r\n\r\n        rate_toTarget = _target_rate;\r\n        rate_toCap = _cap_rate;\r\n        token = ESGToken(_tokenAddress);\r\n        baseTargetInWei = SafeMath.safeMul(_baseTarget, weiEtherConversion);\r\n        icoCapInWei = SafeMath.safeMul(_cap, weiEtherConversion);\r\n        holdingAccount = _holdingAccount;\r\n        duration = SafeMath.safeMul(_duration, 1 days);\r\n        parametersSet = true;\r\n    }\r\n\r\n    /*  ----------------------------------------------------------------------------------------\r\n\r\n    Dev:    Ensure the ICO parameters are set before initialising start of ICO\r\n\r\n    ---------------------------------------------------------------------------------------- */\r\n    function eventConfigured() internal constant returns (bool) {\r\n        return parametersSet && supplySet;\r\n    }\r\n\r\n    /*  ----------------------------------------------------------------------------------------\r\n\r\n    Dev:    Starts the ICO. Initialises starttime at now - current block timestamp\r\n\r\n    ---------------------------------------------------------------------------------------- */ \r\n    function ICO_start() onlyOwner {\r\n        assert (eventConfigured());\r\n        startTime = now;\r\n        endTime = SafeMath.safeAdd(startTime, duration);\r\n    }\r\n\r\n    function ICO_start_future(uint _startTime) onlyOwner {\r\n        assert(eventConfigured());\r\n        require(_startTime > now);\r\n        startTime = _startTime;\r\n        endTime = SafeMath.safeAdd(startTime, duration);\r\n    }\r\n\r\n    function ICO_token_supplyCap() onlyOwner {\r\n        require(token.parametersAreSet());                          // Ensure parameters are set in the token\r\n\r\n        // Method to calculate number of tokens required to base target\r\n        uint256 targetTokens = SafeMath.safeMul(baseTargetInWei, rate_toTarget);         \r\n        targetTokens = SafeMath.safeDiv(targetTokens, weiEtherConversion);\r\n\r\n        // Method to calculate number of tokens required between base target and cap\r\n        uint256 capTokens = SafeMath.safeSub(icoCapInWei, baseTargetInWei);\r\n        capTokens = SafeMath.safeMul(capTokens, rate_toCap);\r\n        capTokens = SafeMath.safeDiv(capTokens, weiEtherConversion);\r\n\r\n        /*\r\n            Hard setting for 10% of base target tokens as per Whitepaper as M'ment incentive\r\n            This is set to only a percentage of the base target, not overall cap\r\n            Don't need to divide by weiEtherConversion as already in tokens\r\n        */\r\n        uint256 mmentTokens = SafeMath.safeMul(targetTokens, 10);\r\n        mmentTokens = SafeMath.safeDiv(mmentTokens, 100);\r\n\r\n        // Total supply for the ICO will be available tokens + m'ment reserve\r\n        uint256 tokens_available = SafeMath.safeAdd(capTokens, targetTokens); \r\n\r\n        uint256 total_Token_Supply = SafeMath.safeAdd(tokens_available, mmentTokens); // Tokens in UNITS\r\n\r\n        token.setTokenCapInUnits(total_Token_Supply);          // Set supply cap and mint to timelock\r\n        token.mintLockedTokens(mmentTokens);                   // Lock in the timelock tokens\r\n        supplySet = true;\r\n    }\r\n\r\n    /*  ----------------------------------------------------------------------------------------\r\n\r\n    Dev:    Fallback payable function if ETH is transferred to the ICO contract\r\n\r\n    param:  No parameters - calls deposit(Address) with msg.sender\r\n\r\n    ---------------------------------------------------------------------------------------- */\r\n    function () payable {\r\n        deposit(msg.sender);\r\n    }\r\n\r\n    /*  ----------------------------------------------------------------------------------------\r\n\r\n    Dev:    Deposit function. User needs to ensure that the purchase is within ICO cap range\r\n\r\n            Function checks that the ICO is still active, that the cap hasn't been reached and\r\n            the address provided is != 0x0.\r\n\r\n    Calls:  getPreTargetContribution(value)\r\n                This function calculates how much (if any) of the value transferred falls within\r\n                the base target goal and qualifies for the target rate of tokens\r\n\r\n            Token.mint(address, number)\r\n                Calls the token mint function in the ESGToken contract\r\n\r\n    param: _for     Address of the sender for tokens\r\n            \r\n    ---------------------------------------------------------------------------------------- */\r\n    function deposit(address _for) payable {\r\n\r\n        /* \r\n            Checks to ensure purchase is valid. A purchase that breaches the cap is not allowed\r\n        */\r\n        require(validPurchase(msg.value));           // Checks time, value purchase is within Cap and address != 0x0\r\n        require(state == State.Active);     // IE not in refund or closed\r\n        require(!ICO_Ended());              // Checks time closed or cap reached\r\n\r\n        /* \r\n            Calculates if any of the value falls before the base target so that the correct\r\n            Token : ETH rate can be applied to the value transferred\r\n        */\r\n        uint256 targetContribution = getPreTargetContribution(msg.value);               // Contribution before base target\r\n        uint256 capContribution = SafeMath.safeSub(msg.value, targetContribution);      // Contribution above base target\r\n        totalWeiContributed = SafeMath.safeAdd(totalWeiContributed, msg.value);         // Update total contribution\r\n\r\n        /* \r\n            Calculate total tokens earned by rate * contribution (in Wei)\r\n            Multiplication first ensures that dividing back doesn't truncate/round\r\n        */\r\n        uint256 targetTokensToMint = SafeMath.safeMul(targetContribution, rate_toTarget);   // Discount rate tokens\r\n        uint256 capTokensToMint = SafeMath.safeMul(capContribution, rate_toCap);            // Standard rate tokens\r\n        uint256 tokensToMint = SafeMath.safeAdd(targetTokensToMint, capTokensToMint);       // Total tokens\r\n        \r\n        tokensToMint = SafeMath.safeDiv(tokensToMint, weiEtherConversion);                  // Get tokens in units\r\n        totalTokensMinted = SafeMath.safeAdd(totalTokensMinted, tokensToMint);              // Update total tokens minted\r\n\r\n        deposited[_for] = SafeMath.safeAdd(deposited[_for], msg.value);                     // Log deposit and inc of refunds\r\n        tokensIssued[_for] = SafeMath.safeAdd(tokensIssued[_for], tokensToMint);            // Log tokens issued\r\n\r\n        token.mint(_for, tokensToMint);                                                     // Mint tokens from Token Mint\r\n        logPurchase(_for, msg.value, tokensToMint);\r\n    }\r\n\r\n    /*  ----------------------------------------------------------------------------------------\r\n\r\n    Dev:    Calculates how much of the ETH contributed falls before the base target cap to therefore\r\n            calculate the correct rates of Token to be issued\r\n\r\n    param:      _valueSent  The value of ETH transferred on the payable function\r\n\r\n    returns:    uint256     The value that falls before the base target\r\n            \r\n    ---------------------------------------------------------------------------------------- */\r\n    function getPreTargetContribution(uint256 _valueSent) internal returns (uint256) {\r\n        \r\n        uint256 targetContribution = 0;                                                     // Default return\r\n\r\n        if (totalWeiContributed < baseTargetInWei) {                                             \r\n            if (SafeMath.safeAdd(totalWeiContributed, _valueSent) > baseTargetInWei) {           // Contribution straddles baseTarget\r\n                targetContribution = SafeMath.safeSub(baseTargetInWei, totalWeiContributed);     // IF #1 means always +ve\r\n            } else {\r\n                targetContribution = _valueSent;\r\n            }\r\n        }\r\n        return targetContribution;    \r\n    }\r\n\r\n    /*  ----------------------------------------------------------------------------------------\r\n\r\n    Dev:    Public viewable functions to show key parameters\r\n\r\n    ---------------------------------------------------------------------------------------- */\r\n\r\n    // Is the ICO Live: time live, state Active\r\n    function ICO_Live() public constant returns (bool) {\r\n        return (now >= startTime && now < endTime && state == State.Active);\r\n    }\r\n\r\n    // Time is valid, purchase isn't zero and cap won't be breached\r\n    function validPurchase(uint256 _value) payable returns (bool) {          // Known true\r\n        bool validTime = (now >= startTime && now < endTime);           // Must be true    \r\n        bool validAmount = (_value >= minWeiContribution);\r\n        bool withinCap = SafeMath.safeAdd(totalWeiContributed, _value) <= icoCapInWei;\r\n\r\n        return validTime && validAmount && withinCap;\r\n    }\r\n\r\n    // ICO has ended\r\n    function ICO_Ended() public constant returns (bool) {\r\n        bool capReached = (totalWeiContributed >= icoCapInWei);\r\n        bool stateValid = state == State.Closed;\r\n\r\n        return (now >= endTime) || capReached || stateValid;\r\n    }\r\n\r\n    // Wei remaining until ICO is capped\r\n    function Wei_Remaining_To_ICO_Cap() public constant returns (uint256) {\r\n        return (icoCapInWei - totalWeiContributed);\r\n    }\r\n\r\n    // Shows if the base target cap has been reached\r\n    function baseTargetReached() public constant returns (bool) {\r\n    \r\n        return totalWeiContributed >= baseTargetInWei;\r\n    }\r\n\r\n    // Shows if the cap has been reached\r\n    function capReached() public constant returns (bool) {\r\n    \r\n        return totalWeiContributed == icoCapInWei;\r\n    }\r\n\r\n    /*  ----------------------------------------------------------------------------------------\r\n\r\n    Dev:    This section controls closing of the ICO. The state is set to closed so that the ICO\r\n            is shown as ended.\r\n\r\n            Based on the function from open zeppelin contracts: RefundVault + RefundableCrowdsale\r\n\r\n    Ref:    https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/crowdsale/RefundableCrowdsale.sol\r\n            https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/crowdsale/RefundVault.sol\r\n    ---------------------------------------------------------------------------------------- */\r\n\r\n    event Closed();\r\n\r\n    // Set closed ICO and transfer balance to holding account\r\n    function close() onlyOwner {\r\n        require((now >= endTime) || (totalWeiContributed >= icoCapInWei));\r\n        require(state==State.Active);\r\n        state = State.Closed;\r\n        Closed();\r\n\r\n        holdingAccount.transfer(this.balance);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"ICO_Live\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minWeiContribution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"baseTargetReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"close\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"baseTargetInWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"capReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"ICO_start\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"ICO_token_supplyCap\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_target_rate\",\"type\":\"uint256\"},{\"name\":\"_cap_rate\",\"type\":\"uint256\"},{\"name\":\"_baseTarget\",\"type\":\"uint256\"},{\"name\":\"_cap\",\"type\":\"uint256\"},{\"name\":\"_holdingAccount\",\"type\":\"address\"},{\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"ICO_setParameters\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensMinted\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate_toTarget\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokensIssued\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalWeiContributed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startTime\",\"type\":\"uint256\"}],\"name\":\"ICO_start_future\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"validPurchase\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"deposited\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate_toCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Wei_Remaining_To_ICO_Cap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ICO_Ended\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_for\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoCapInWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"logPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Closed\",\"type\":\"event\"}]","ContractName":"ICOEvent","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://4dd75424fde09eec8e0165e9804d39bf0f0f0076ddbb6cc958a9c98fea0c096e"}]}