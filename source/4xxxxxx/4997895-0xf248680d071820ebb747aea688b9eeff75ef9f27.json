{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.17;\r\n\r\ninterface ERC20Token {\r\n\tfunction balanceOf(address tokenOwner)\r\n\t\tpublic view returns (uint balance);\r\n \tfunction transfer(address to, uint tokens)\r\n\t\tpublic returns (bool success);\r\n\tfunction symbol() public view returns (string);\r\n\tfunction name() public view returns (string);\r\n\tfunction decimals() public view returns (uint8);\r\n}\r\n\r\ncontract MultiKeyDailyLimitWallet {\r\n\tuint constant LIMIT_PRECISION = 1000000;\r\n\t// Fractional daily limits per key. In units of 1/LIMIT_PRECISION.\r\n\tmapping(address=>uint) public credentials;\r\n\t// Timestamp of last withdrawal, by token (0x0 is ether).\r\n\tmapping(address=>uint) public lastWithdrawalTime;\r\n\t// Total withdrawn in last 24-hours, by token (0x0 is ether).\r\n\t// Resets if 24 hours passes with no activity.\r\n\tmapping(address=>uint) public dailyCount;\r\n\tuint public nonce;\r\n\r\n\tevent OnWithdrawTo(\r\n\t\taddress indexed token,\r\n\t\taddress indexed from,\r\n\t\taddress indexed to,\r\n\t\tuint amount,\r\n\t\tuint64 timestamp);\r\n\r\n\tfunction MultiKeyDailyLimitWallet(address[] keys, uint[] limits) public {\r\n\t\trequire(keys.length == limits.length);\r\n\t\tfor (uint i = 0; i < keys.length; i++) {\r\n\t\t\tvar limit = limits[i];\r\n\t\t\t// limit should be in range 1-LIMIT_PRECISION\r\n\t\t\trequire (limit > 0 && limit <= LIMIT_PRECISION);\r\n\t\t\tcredentials[keys[i]] = limit;\r\n\t\t}\r\n\t}\r\n\r\n\t/* #IF TESTING\r\n\tfunction setLastWithdrawalTime(address token, uint time) external {\r\n\t\tlastWithdrawalTime[token] = time;\r\n\t}\r\n\tfunction setDailyCount(address token, uint count) external {\r\n\t\tdailyCount[token] = count;\r\n\t}\r\n\t #FI */\r\n\r\n\tfunction getAdjustedDailyCount(address token)\r\n\t\t\tprivate view returns (uint) {\r\n\r\n\t\tvar _dailyCount = dailyCount[token];\r\n\t\tif ((block.timestamp - lastWithdrawalTime[token]) >= 1 days)\r\n\t\t\t_dailyCount = 0;\r\n\t\treturn _dailyCount;\r\n\t}\r\n\r\n\tfunction getRemainingLimit(address token, address key)\r\n\t\t\tpublic view returns (uint) {\r\n\r\n\t\tvar pct = credentials[key];\r\n\t\tif (pct == 0)\r\n\t\t\treturn 0;\r\n\r\n\t\tvar _dailyCount = getAdjustedDailyCount(token);\r\n\t\tvar balance = getBalance(token);\r\n\t\tvar amt = ((balance + _dailyCount) * pct) / LIMIT_PRECISION;\r\n\t\tif (amt == 0 && balance > 0)\r\n\t\t\tamt = 1;\r\n\t\tif (_dailyCount >= amt)\r\n\t\t\treturn 0;\r\n\t\treturn amt - _dailyCount;\r\n\t}\r\n\r\n\tfunction withdrawTo(\r\n\t\t\taddress token,\r\n\t\t\tuint amount,\r\n\t\t\taddress to,\r\n\t\t\tbytes signature) external {\r\n\r\n\t\trequire(amount > 0 && to != address(this));\r\n\t\tassert(block.timestamp >= lastWithdrawalTime[token]);\r\n\r\n\t\tvar limit = getSignatureRemainingLimit(\r\n\t\t\tsignature,\r\n\t\t\tkeccak256(address(this), token, nonce, amount, to),\r\n\t\t\ttoken);\r\n\r\n\t\trequire(limit >= amount);\r\n\t\trequire(getBalance(token) >= amount);\r\n\r\n\t\tdailyCount[token] = getAdjustedDailyCount(token) + amount;\r\n\t\tlastWithdrawalTime[token] = block.timestamp;\r\n\t\tnonce++;\r\n\t\t_transfer(token, to, amount);\r\n\t\tOnWithdrawTo(token, msg.sender, to, amount, uint64(block.timestamp));\r\n\t}\r\n\r\n\tfunction getBalance(address token) public view returns (uint) {\r\n\t\tif (token != 0x0) {\r\n\t\t\t// Token.\r\n\t\t\treturn ERC20Token(token).balanceOf(address(this));\r\n\t\t}\r\n\t\treturn this.balance;\r\n\t}\r\n\r\n\tfunction _transfer(address token, address to, uint amount)\r\n\t \t\tprivate {\r\n\r\n\t\tif (token != 0x0) {\r\n\t\t\t// Transfering a token.\r\n\t\t\trequire(ERC20Token(token).transfer(to, amount));\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tto.transfer(amount);\r\n\t}\r\n\r\n\tfunction getSignatureRemainingLimit(\r\n\t\t\tbytes signature,\r\n\t\t\tbytes32 payload,\r\n\t\t\taddress token)\r\n\t\t\tprivate view returns (uint) {\r\n\r\n\t\tvar addr = extractSignatureAddress(signature, payload);\r\n\t\treturn getRemainingLimit(token, addr);\r\n\t}\r\n\r\n\tfunction extractSignatureAddress(bytes signature, bytes32 payload)\r\n\t\t\tprivate pure returns (address) {\r\n\r\n\t\tpayload = keccak256(\"\\x19Ethereum Signed Message:\\n32\", payload);\r\n\t\tbytes32 r;\r\n\t\tbytes32 s;\r\n\t\tuint8 v;\r\n\t\tassembly {\r\n\t\t\tr := mload(add(signature, 32))\r\n\t\t\ts := mload(add(signature, 64))\r\n\t\t\tv := and(mload(add(signature, 65)), 255)\r\n\t\t}\r\n\t\tif (v < 27)\r\n\t\t\tv += 27;\r\n\t\trequire(v == 27 || v == 28);\r\n\t\treturn ecrecover(payload, v, r, s);\r\n\t}\r\n\r\n\tfunction() public payable {}\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"withdrawTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastWithdrawalTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"credentials\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"dailyCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"key\",\"type\":\"address\"}],\"name\":\"getRemainingLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nonce\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"keys\",\"type\":\"address[]\"},{\"name\":\"limits\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint64\"}],\"name\":\"OnWithdrawTo\",\"type\":\"event\"}]","ContractName":"MultiKeyDailyLimitWallet","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000500000000000000000000000071e85326be32a79dd06e74eb4625e1487e8d8a83000000000000000000000000f1debe48c8dd97a6ec9689ee3b8c8d550ddbf705000000000000000000000000c4d6391e285d9fc0881ed6712a7cf974de2846dc000000000000000000000000e06d3abd908b532b914f157677a955a9f285cb7b000000000000000000000000062012cde08a4dbb4caff00534588b1a8388c43d0000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000010a0000000000000000000000000000000000000000000000000000000000000271000000000000000000000000000000000000000000000000000000000001898c00000000000000000000000000000000000000000000000000000000000f424000000000000000000000000000000000000000000000000000000000000025bb","Library":"","SwarmSource":"bzzr://d312d0aa272b4283b759fd80a95fa533f678c79f9a7ffe6078983f194db99d3c"}]}