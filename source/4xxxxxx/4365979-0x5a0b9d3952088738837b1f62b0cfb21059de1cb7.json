{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.16;\r\n//https://github.com/genkifs/staticoin\r\n\r\ncontract owned  {\r\n  address owner;\r\n  function owned() {\r\n    owner = msg.sender;\r\n  }\r\n  function changeOwner(address newOwner) onlyOwner {\r\n    owner = newOwner;\r\n  }\r\n  modifier onlyOwner() {\r\n    if (msg.sender==owner) \r\n    _;\r\n  }\r\n}\r\n\r\ncontract mortal is owned() {\r\n  function kill() onlyOwner {\r\n    if (msg.sender == owner) selfdestruct(owner);\r\n  }\r\n}\r\n\r\nlibrary ERC20Lib {\r\n//Inspired by https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736\r\n  struct TokenStorage {\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 totalSupply;\r\n  }\r\n  \r\n\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n\tmodifier onlyPayloadSize(uint numwords) {\r\n\t\t/**\r\n\t\t* @dev  Checks for short addresses  \r\n\t\t* @param numwords number of parameters passed \r\n\t\t*/\r\n        assert(msg.data.length >= numwords * 32 + 4);\r\n        _;\r\n\t}\r\n  \r\n\tmodifier validAddress(address _address) { \r\n\t\t/**\r\n\t\t* @dev  validates an address.  \r\n\t\t* @param _address checks that it isn't null or this contract address\r\n\t\t*/\t\t\r\n        require(_address != 0x0); \r\n        require(_address != address(msg.sender)); \r\n        _; \r\n    } \r\n\t\r\n\tmodifier IsWallet(address _address) {\r\n\t\t/**\r\n\t\t* @dev Transfer tokens from msg.sender to another address.  \r\n\t\t* Cannot Allows execution if the transfer to address code size is 0\r\n\t\t* @param _address address to check that its not a contract\r\n\t\t*/\t\t\r\n\t\tuint codeLength;\r\n\t\tassembly {\r\n            // Retrieve the size of the code on target address, this needs assembly .\r\n            codeLength := extcodesize(_address)\r\n        }\r\n\t\tassert(codeLength==0);\t\t\r\n        _; \r\n    } \r\n\r\n   function safeMul(uint a, uint b) returns (uint) { \r\n     uint c = a * b; \r\n     assert(a == 0 || c / a == b); \r\n     return c; \r\n   } \r\n \r\n   function safeSub(uint a, uint b) returns (uint) { \r\n     assert(b <= a); \r\n     return a - b; \r\n   }  \r\n \r\n   function safeAdd(uint a, uint b) returns (uint) { \r\n     uint c = a + b; \r\n     assert(c>=a && c>=b); \r\n     return c; \r\n   } \r\n\t\r\n\tfunction init(TokenStorage storage self, uint _initial_supply) {\r\n\t\tself.totalSupply = _initial_supply;\r\n\t\tself.balances[msg.sender] = _initial_supply;\r\n\t}\r\n  \r\n\tfunction transfer(TokenStorage storage self, address _to, uint256 _value) \r\n\t\tonlyPayloadSize(3)\r\n\t\tIsWallet(_to)\t\t\r\n\t\treturns (bool success) {\t\t\t\t\r\n\t\t/**\r\n\t\t* @dev Transfer tokens from msg.sender to another address.  \r\n\t\t* Cannot be used to send tokens to a contract, this means contracts cannot mint coins to themselves\r\n\t\t* Contracts have to use the approve and transfer method\r\n\t\t* this is based on https://github.com/Dexaran/ERC223-token-standard\r\n\t\t* @param _to address The address where the coin is to be transfered\r\n\t\t* @param _value uint256 the amount of tokens to be transferred\r\n\t\t*/\r\n       if (self.balances[msg.sender] >= _value && self.balances[_to] + _value > self.balances[_to]) {\r\n            self.balances[msg.sender] = safeSub(self.balances[msg.sender], _value);\r\n            self.balances[_to] = safeAdd(self.balances[_to], _value);\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n  \r\n\tfunction transferFrom(TokenStorage storage self, address _from, address _to, uint256 _value) \r\n\t\tonlyPayloadSize(4) \r\n\t\tvalidAddress(_from)\r\n\t\tvalidAddress(_to)\r\n\t\treturns (bool success) {\r\n\t\t/**\r\n\t\t* @dev Transfer tokens from one address to another.  Requires allowance to be set.\r\n\t\t* @param _from address The address which you want to send tokens from\r\n\t\t* @param _to address The address which you want to transfer to\r\n\t\t* @param _value uint256 the amount of tokens to be transferred\r\n\t\t*/\r\n        if (self.balances[_from] >= _value && self.allowed[_from][msg.sender] >= _value && self.balances[_to] + _value > self.balances[_to]) {\r\n\t\t\tvar _allowance = self.allowed[_from][msg.sender];\r\n            self.balances[_to] = safeAdd(self.balances[_to], _value);\r\n            self.balances[_from] = safeSub(self.balances[_from], _value);\r\n            self.allowed[_from][msg.sender] = safeSub(_allowance, _value);\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n     \r\n    function balanceOf(TokenStorage storage self, address _owner) constant \r\n\t\tonlyPayloadSize(2) \r\n\t\tvalidAddress(_owner)\r\n\t\treturns (uint256 balance) {\r\n\t\t/**\r\n\t\t* @dev returns the amount given to an account\r\n\t\t* @param _owner The address to be queried\r\n\t\t* @return Balance of _owner.\r\n\t\t*/\r\n        return self.balances[_owner];\r\n    }\r\n\t \r\n    function approve(TokenStorage storage self, address _spender, uint256 _value) \r\n\t\tonlyPayloadSize(3) \r\n\t\tvalidAddress(_spender)\t\r\n\t\treturns (bool success) {\r\n\t/**\r\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _value The amount of tokens to be spent.\r\n    */\r\n\t\t//require user to set to zero before resetting to nonzero\r\n\t\tif ((_value != 0) && (self.allowed[msg.sender][_spender] != 0)) { \r\n           return false; \r\n        } else {\r\n\t\t\tself.allowed[msg.sender][_spender] = _value;\r\n\t\t\tApproval(msg.sender, _spender, _value);\r\n\t\t\treturn true;\r\n\t\t}\r\n    }\r\n\t\t\r\n\tfunction allowance(TokenStorage storage self, address _owner, address _spender) constant \r\n\t\tonlyPayloadSize(3) \r\n\t\tvalidAddress(_owner)\t\r\n\t\tvalidAddress(_spender)\t\r\n\t\treturns (uint256 remaining) {\r\n\t\t\t/**\r\n\t\t\t* @dev allows queries of how much a given address is allowed to spend on behalf of another account\r\n\t\t\t* @param _owner address The address which owns the funds.\r\n\t\t\t* @param _spender address The address which will spend the funds.\r\n\t\t\t* @return remaining uint256 specifying the amount of tokens still available for the spender.\r\n\t\t\t*/\r\n        return self.allowed[_owner][_spender];\r\n    }\r\n\t\r\n\tfunction increaseApproval(TokenStorage storage self, address _spender, uint256 _addedValue)  \r\n\t\tonlyPayloadSize(3) \r\n\t\tvalidAddress(_spender)\t\r\n\t\treturns (bool success) { \r\n\t\t/**\r\n\t\t* @dev Allows to increment allowed value\r\n\t\t* better to use this function to avoid 2 calls\r\n\t\t* @param _spender address The address which will spend the funds.\r\n\t\t* @param _addedValue amount to increase alowance by.\r\n\t\t* @return True if allowance increased\r\n\t\t*/\r\n        uint256 oldValue = self.allowed[msg.sender][_spender]; \r\n        self.allowed[msg.sender][_spender] = safeAdd(oldValue, _addedValue); \r\n        return true; \r\n    } \r\n\t\r\n\tfunction decreaseApproval(TokenStorage storage self,address _spender, uint256 _subtractedValue)  \r\n\t\tonlyPayloadSize(3) \r\n\t\tvalidAddress(_spender)\t\r\n\t\treturns (bool success) { \r\n\t\t/**\r\n\t\t* @dev Allows to decrement allowed value\r\n\t\t* better to use this function to avoid 2 calls\r\n\t\t* @param _spender address The address which will spend the funds.\r\n\t\t* @param _subtractedValue amount to decrease allowance by.\r\n\t\t* @return True if allowance decreased\r\n\t\t*/\r\n\t\tuint256 oldValue = self.allowed[msg.sender][_spender]; \r\n\t\tif (_subtractedValue > oldValue) { \r\n\t\t\tself.allowed[msg.sender][_spender] = 0; \r\n\t\t} else { \r\n\t\t\tself.allowed[msg.sender][_spender] = safeSub(oldValue, _subtractedValue); \r\n\t\t} \r\n\t\treturn true; \r\n\t} \r\n\r\n    /* Approves and then calls the receiving contract with any additional paramteres*/\r\n    function approveAndCall(TokenStorage storage self, address _spender, uint256 _value, bytes _extraData)\r\n\t\tonlyPayloadSize(4) \r\n\t\tvalidAddress(_spender)   \r\n\t\treturns (bool success) {\r\n\t//require user to set to zero before resetting to nonzero\r\n\t\t\t/**\r\n\t\t\t* @dev Approves and then calls the receiving contract with any additional paramteres\r\n\t\t\t* @param _owner address The address which owns the funds.\r\n\t\t\t* @param _spender address The address which will spend the funds.\r\n\t\t\t* @param _value address The address which will spend the funds.\r\n\t\t\t* @param _extraData is the additional paramters passed\r\n\t\t\t* @return True if successful.\r\n\t\t\t*/\r\n\t\tif ((_value != 0) && (self.allowed[msg.sender][_spender] != 0)) { \r\n\t\t\t\treturn false; \r\n\t\t\t} else {\r\n\t\t\tself.allowed[msg.sender][_spender] = _value;\r\n\t\t\tApproval(msg.sender, _spender, _value);\r\n\t\t\t//call the receiveApproval function on the contract you want to be notified. \r\n\t\t\t//This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n\t\t\t//it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n\t\t\tif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\r\n\t\t\treturn true;\r\n\t\t}\r\n    }\t\r\n\t\r\n\tfunction mintCoin(TokenStorage storage self, address target, uint256 mintedAmount, address owner) \r\n\t\tinternal\r\n\t\treturns (bool success) {\r\n\t\t\t/**\r\n\t\t\t* @dev Approves and then calls the receiving contract with any additional paramteres\r\n\t\t\t* @param target address the address which will receive the funds.\r\n\t\t\t* @param mintedAmount the amount of funds to be sent.\r\n\t\t\t* @param owner the contract responsable for controling the amount of funds.\r\n\t\t\t* @return True if successful.\r\n\t\t\t*/\r\n        self.balances[target] = safeAdd(self.balances[target], mintedAmount);//balances[target] += mintedAmount;\r\n        self.totalSupply = safeAdd(self.totalSupply, mintedAmount);//totalSupply += mintedAmount;\r\n        Transfer(0, owner, mintedAmount); // Deliver coin to the mint\r\n        Transfer(owner, target, mintedAmount); // mint delivers to address\r\n\t\treturn true;\r\n    }\r\n\r\n    function meltCoin(TokenStorage storage self, address target, uint256 meltedAmount, address owner) \r\n\t\tinternal\r\n\t\treturns (bool success) {\r\n\t\t\t/**\r\n\t\t\t* @dev Approves and then calls the receiving contract with any additional paramteres\r\n\t\t\t* @param target address the address which will return the funds.\r\n\t\t\t* @param meltedAmount the amount of funds to be returned.\r\n\t\t\t* @param owner the contract responsable for controling the amount of funds.\r\n\t\t\t* @return True if successful.\r\n\t\t\t*/\r\n        if(self.balances[target]<meltedAmount){\r\n            return false;\r\n        }\r\n\t\tself.balances[target] = safeSub(self.balances[target], meltedAmount); //balances[target] -= meltedAmount;\r\n\t\tself.totalSupply = safeSub(self.totalSupply, meltedAmount); //totalSupply -= meltedAmount;\r\n\t\tTransfer(target, owner, meltedAmount); // address delivers to minter\r\n\t\tTransfer(owner, 0, meltedAmount); // minter delivers coin to the burn address\r\n\t\treturn true;\r\n    }\r\n}\r\n\r\n/** @title StandardToken. */\r\ncontract StandardToken is owned{\r\n    using ERC20Lib for ERC20Lib.TokenStorage;\r\n    ERC20Lib.TokenStorage public token;\r\n\r\n\tstring public name;                   //Long token name\r\n    uint8 public decimals=18;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n    uint public INITIAL_SUPPLY = 0;\t\t// mintable coin has zero inital supply (and can fall back to zero)\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);   \r\n   \r\n    function StandardToken() {\r\n\t\ttoken.init(INITIAL_SUPPLY);\r\n    }\r\n\r\n    function totalSupply() constant returns (uint) {\r\n\t\treturn token.totalSupply;\r\n    }\r\n\r\n    function balanceOf(address who) constant returns (uint) {\r\n\t\treturn token.balanceOf(who);\r\n    }\r\n\r\n    function allowance(address owner, address _spender) constant returns (uint) {\r\n\t\treturn token.allowance(owner, _spender);\r\n    }\r\n\r\n\tfunction transfer(address to, uint value) returns (bool ok) {\r\n\t\treturn token.transfer(to, value);\r\n\t}\r\n\r\n\tfunction transferFrom(address _from, address _to, uint _value) returns (bool ok) {\r\n\t\treturn token.transferFrom(_from, _to, _value);\r\n\t}\r\n\r\n\tfunction approve(address _spender, uint value) returns (bool ok) {\r\n\t\treturn token.approve(_spender, value);\r\n\t}\r\n   \r\n\tfunction increaseApproval(address _spender, uint256 _addedValue) returns (bool ok) {  \r\n\t\treturn token.increaseApproval(_spender, _addedValue);\r\n\t}    \r\n \r\n\tfunction decreaseApproval(address _spender, uint256 _subtractedValue) returns (bool ok) {  \r\n\t\treturn token.decreaseApproval(_spender, _subtractedValue);\r\n\t}\r\n\r\n\tfunction approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool ok){\r\n\t\treturn token.approveAndCall(_spender,_value,_extraData);\r\n    }\r\n\t\r\n\tfunction mintCoin(address target, uint256 mintedAmount) onlyOwner returns (bool ok) {\r\n\t\treturn token.mintCoin(target,mintedAmount,owner);\r\n    }\r\n\r\n    function meltCoin(address target, uint256 meltedAmount) onlyOwner returns (bool ok) {\r\n\t\treturn token.meltCoin(target,meltedAmount,owner);\r\n    }\r\n}\r\n\r\n/** @title Coin. */\r\ncontract Coin is StandardToken, mortal{\r\n    I_minter public mint;\t\t\t\t  //Minter interface  \r\n    event EventClear();\r\n\r\n    function Coin(string _tokenName, string _tokenSymbol) { \r\n        name = _tokenName;                                   // Set the name for display purposes\r\n        symbol = _tokenSymbol;                               // Set the symbol for display purposes\r\n    }\r\n\r\n    function setMinter(address _minter) external onlyOwner {\r\n\t\t/**\r\n\t\t* @dev Transfer tokens from one address to another.  Requires allowance to be set.\r\n\t\t* once set this can't be changed (the minter contract doesn't have a changeOwner function)\r\n\t\t* @param _minter Address of the minter contract\r\n\t\t*/\r\n\t\r\n        changeOwner(_minter);\r\n        mint=I_minter(_minter);    \r\n    }   \r\n}\r\n\r\n/** @title RiskCoin. */\r\ncontract RiskCoin is Coin{\r\n    function RiskCoin(string _tokenName, string _tokenSymbol) \r\n\tCoin(_tokenName,_tokenSymbol) {} \r\n\t\r\n    function() payable {\r\n\t\t/** @dev direct any ETH sent to this RiskCoin address to the minter.NewRisk function\r\n\t\t*/\r\n        mint.NewRiskAdr.value(msg.value)(msg.sender);\r\n    }  \r\n}\r\n\r\n/** @title StatiCoin. */\r\ncontract StatiCoin is Coin{\r\n    function StatiCoin(string _tokenName, string _tokenSymbol) \r\n\tCoin(_tokenName,_tokenSymbol) {} \r\n\r\n    function() payable {        \r\n\t\t/** @dev direct any ETH sent to this StatiCoin address to the minter.NewStatic function\r\n        */\r\n        mint.NewStaticAdr.value(msg.value)(msg.sender);\r\n    }  \r\n}\r\n\r\n/** @title I_coin. */\r\ncontract I_coin is mortal {\r\n\r\n    event EventClear();\r\n\r\n\tI_minter public mint;\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals=18;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = '';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\t\r\n    function mintCoin(address target, uint256 mintedAmount) returns (bool success) {}\r\n    function meltCoin(address target, uint256 meltedAmount) returns (bool success) {}\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData){}\r\n\r\n    function setMinter(address _minter) {}   \r\n\tfunction increaseApproval (address _spender, uint256 _addedValue) returns (bool success) {}    \r\n\tfunction decreaseApproval (address _spender, uint256 _subtractedValue) \treturns (bool success) {} \r\n\r\n    // @param _owner The address from which the balance will be retrieved\r\n    // @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}    \r\n\r\n\r\n    // @notice send `_value` token to `_to` from `msg.sender`\r\n    // @param _to The address of the recipient\r\n    // @param _value The amount of token to be transferred\r\n    // @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n\r\n    // @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    // @param _from The address of the sender\r\n    // @param _to The address of the recipient\r\n    // @param _value The amount of token to be transferred\r\n    // @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    // @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    // @param _spender The address of the account able to transfer the tokens\r\n    // @param _value The amount of wei to be approved for transfer\r\n    // @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\t\r\n\t// @param _owner The address of the account owning tokens\r\n    // @param _spender The address of the account able to transfer the tokens\r\n    // @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\t\r\n\tmapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n\t// @return total amount of tokens\r\n    uint256 public totalSupply;\r\n}\r\n\r\n/** @title I_minter. */\r\ncontract I_minter { \r\n    event EventCreateStatic(address indexed _from, uint128 _value, uint _transactionID, uint _Price); \r\n    event EventRedeemStatic(address indexed _from, uint128 _value, uint _transactionID, uint _Price); \r\n    event EventCreateRisk(address indexed _from, uint128 _value, uint _transactionID, uint _Price); \r\n    event EventRedeemRisk(address indexed _from, uint128 _value, uint _transactionID, uint _Price); \r\n    event EventBankrupt();\r\n\t\r\n    function Leverage() constant returns (uint128)  {}\r\n    function RiskPrice(uint128 _currentPrice,uint128 _StaticTotal,uint128 _RiskTotal, uint128 _ETHTotal) constant returns (uint128 price)  {}\r\n    function RiskPrice(uint128 _currentPrice) constant returns (uint128 price)  {}     \r\n    function PriceReturn(uint _TransID,uint128 _Price) {}\r\n    function NewStatic() external payable returns (uint _TransID)  {}\r\n    function NewStaticAdr(address _Risk) external payable returns (uint _TransID)  {}\r\n    function NewRisk() external payable returns (uint _TransID)  {}\r\n    function NewRiskAdr(address _Risk) external payable returns (uint _TransID)  {}\r\n    function RetRisk(uint128 _Quantity) external payable returns (uint _TransID)  {}\r\n    function RetStatic(uint128 _Quantity) external payable returns (uint _TransID)  {}\r\n    function Strike() constant returns (uint128)  {}\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"ERC20Lib.TokenStorage storage\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"ERC20Lib.TokenStorage storage\"},{\"name\":\"_initial_supply\",\"type\":\"uint256\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"ERC20Lib.TokenStorage storage\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"ERC20Lib.TokenStorage storage\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"ERC20Lib.TokenStorage storage\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"self\",\"type\":\"ERC20Lib.TokenStorage storage\"},{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeSub\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"ERC20Lib.TokenStorage storage\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeMul\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"ERC20Lib.TokenStorage storage\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"self\",\"type\":\"ERC20Lib.TokenStorage storage\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeAdd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"ERC20Lib","CompilerVersion":"v0.4.16+commit.d7661dd9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://f4b4cd3431e044bb2432970ff25e355965dfd7a84a9a687f492a4c06643f8691"}]}