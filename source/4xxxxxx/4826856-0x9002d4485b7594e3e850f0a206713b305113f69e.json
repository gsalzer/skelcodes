{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.4;\r\n\r\ncontract SafeMath {\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeDiv(uint a, uint b) internal returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a / b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) {\r\n      throw;\r\n    }\r\n  }\r\n}\r\n\r\n\r\n\r\ncontract Token is SafeMath {\r\n\r\n    function totalSupply()public constant returns (uint256 supply) {}\r\n\r\n    function balanceOf(address _owner)public constant returns (uint256 balance) {}\r\n    \r\n   \r\n    \r\n    function transfer(address _to, uint256 _value)public returns (bool success) {}\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value)public returns (bool success) {}\r\n\r\n    function approve(address _spender, uint256 _value)public returns (bool success) {}\r\n\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n//ERC20 Compliant\r\ncontract StandardToken is Token {\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function transfer(address _to, uint256 _value) public  returns (bool success) {\r\n        if (balances[msg.sender] >= _value && _value > 0)\r\n        {\r\n            if(inflation_complete)\r\n            {\r\n              \r\n                uint256 CalculatedFee = safeMul(safeDiv(transactionfeeAmount,100000000000000),transactionfeeAmount);\r\n                balances[msg.sender] = safeSub(balances[msg.sender],_value);\r\n               _value = safeSub(_value,CalculatedFee);\r\n                totalFeeCollected = safeAdd(totalFeeCollected,CalculatedFee);\r\n                balances[_to] = safeAdd(balances[_to],_value);\r\n                Transfer(msg.sender, _to, _value);\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                balances[msg.sender] = safeSub(balances[msg.sender],_value);\r\n                balances[_to] = safeAdd(balances[_to],_value);\r\n                Transfer(msg.sender, _to, _value);\r\n                return true;\r\n                \r\n            }\r\n            \r\n        }\r\n        else\r\n        {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] =safeAdd(balances[_to],_value);\r\n            balances[_from] =safeSub(balances[_from],_value);\r\n            allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender],_value); \r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n   \r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n   \r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply=   0;\r\n    uint256 public initialSupply= 2500000*10**12;\r\n    uint256 public rewardsupply= 4500000*10**12;\r\n    bool public inflation_complete;\r\n    uint256 public transactionfeeAmount; // This is the percentage per transaction Hawala.Today shall be collecting \r\n    uint256 public totalFeeCollected;\r\n}\r\n\r\n\r\n\r\ncontract HawalaToken is StandardToken {\r\n\r\n    \r\n    uint256 public  totalstakeamount;\r\n    uint256 public HawalaKickoffTime;\r\n    address _contractOwner;\r\n    uint256 public totalFeeCollected;\r\n  \r\n    string public name;                  \r\n    uint8 public decimals;               \r\n    string public symbol;\r\n    string public version = 'HAT';       \r\n\r\n  mapping (address => IFSBalance) public IFSBalances;\r\n   struct IFSBalance\r\n    {\r\n        \r\n         uint256 TotalRewardsCollected; \r\n        uint256 Amount; \r\n        uint256 IFSLockTime;\r\n        uint256 LastCollectedReward;\r\n    }\r\n    \r\n   \r\n    event IFSActive(address indexed _owner, uint256 _value,uint256 _locktime);\r\n    \r\n    function () public {\r\n        //if ether is sent to this address, send it back.\r\n    \r\n        throw;\r\n    }\r\n\r\n  \r\n\r\n      \r\n\r\n      function CalculateReward(uint256 stakingamount,uint256 initialLockTime,uint256 _currenttime) public returns (uint256 _amount) {\r\n         \r\n        \r\n         uint _timesinceStaking =(uint(_currenttime)-uint(initialLockTime))/ 1 days;\r\n         _timesinceStaking = safeDiv(_timesinceStaking,3);//exploiting non-floating point division\r\n         _timesinceStaking = safeMul(_timesinceStaking,3);//get to number of days reward shall be distributed\r\n        \r\n      \r\n        \r\n         if(safeSub(_currenttime,HawalaKickoffTime) <= 1 years)\r\n         {\r\n             //_amount = 1;//safeMul(safeDiv(stakingamount,100),15));\r\n              \r\n             _amount = safeMul(safeDiv(stakingamount,1000000000000),410958904) ;//15% safeDiv(4,100);//safeMul(stakingamount,safeDiv(4,100));\r\n             _amount = safeMul(_timesinceStaking,_amount);\r\n          \r\n         }\r\n        else if(safeSub(_currenttime,HawalaKickoffTime) <= 2 years)\r\n         {\r\n             _amount = safeMul(safeDiv(stakingamount,1000000000000),410958904) ;//15% safeDiv(4,100);//safeMul(stakingamount,safeDiv(4,100));\r\n             _amount = safeMul(_timesinceStaking,_amount);\r\n             \r\n         }\r\n        else  if(safeSub(_currenttime,HawalaKickoffTime) <= 3 years)\r\n         {\r\n             _amount = safeMul(safeDiv(stakingamount,1000000000000),328767123) ;//12% safeDiv(4,100);//safeMul(stakingamount,safeDiv(4,100));\r\n             _amount = safeMul(_timesinceStaking,_amount);\r\n             \r\n         }\r\n        else  if(safeSub(_currenttime,HawalaKickoffTime) <= 4 years)\r\n         {\r\n             _amount = safeMul(safeDiv(stakingamount,1000000000000),328767123) ;//12% safeDiv(4,100);//safeMul(stakingamount,safeDiv(4,100));\r\n             _amount = safeMul(_timesinceStaking,_amount);\r\n             \r\n         }\r\n       else   if(safeSub(_currenttime,HawalaKickoffTime) <= 5 years)\r\n         {\r\n             _amount = safeMul(safeDiv(stakingamount,1000000000000),328767123) ;//12% safeDiv(4,100);//safeMul(stakingamount,safeDiv(4,100));\r\n             _amount = safeMul(_timesinceStaking,_amount);\r\n             \r\n         }\r\n       else   if(safeSub(_currenttime,HawalaKickoffTime) <= 6 years)\r\n         {\r\n             _amount = safeMul(safeDiv(stakingamount,1000000000000),273972602) ;//10% safeDiv(4,100);//safeMul(stakingamount,safeDiv(4,100));\r\n             _amount = safeMul(_timesinceStaking,_amount);\r\n             \r\n         }\r\n      else    if(safeSub(_currenttime,HawalaKickoffTime) <= 7 years)\r\n         {\r\n             _amount = safeMul(safeDiv(stakingamount,1000000000000),273972602) ;//10%  safeDiv(4,100);//safeMul(stakingamount,safeDiv(4,100));\r\n             _amount = safeMul(_timesinceStaking,_amount);\r\n             \r\n         }\r\n       else   if(safeSub(_currenttime,HawalaKickoffTime) <= 8 years)\r\n         {\r\n             _amount = safeMul(safeDiv(stakingamount,1000000000000),219178082) ;//8% safeDiv(4,100);//safeMul(stakingamount,safeDiv(4,100));\r\n             _amount = safeMul(_timesinceStaking,_amount);\r\n             \r\n         }\r\n      else    if(safeSub(_currenttime,HawalaKickoffTime) <= 9 years)\r\n         {\r\n             _amount = safeMul(safeDiv(stakingamount,1000000000000),205479452) ;//7.50% safeDiv(4,100);//safeMul(stakingamount,safeDiv(4,100));\r\n             _amount = safeMul(_timesinceStaking,_amount);\r\n             \r\n         }\r\n       else   if(safeSub(_currenttime,HawalaKickoffTime) <= 10 years)\r\n         {\r\n             _amount = safeMul(safeDiv(stakingamount,1000000000000),198630136) ;//7.25% safeDiv(4,100);//safeMul(stakingamount,safeDiv(4,100));\r\n             _amount = safeMul(_timesinceStaking,_amount);\r\n             \r\n         }\r\n        else   if(safeSub(_currenttime,HawalaKickoffTime) > 10 years)\r\n         {\r\n             _amount = safeMul(safeDiv(stakingamount,1000000000000),198630136) ;//7.25% safeDiv(4,100);//safeMul(stakingamount,safeDiv(4,100));\r\n             _amount = safeMul(_timesinceStaking,_amount);\r\n             \r\n         }\r\n         return _amount;\r\n         //extract ony the quotient from _timesinceStaking\r\n        \r\n     }\r\n     \r\n     function changeTransactionFee(uint256 amount) public returns (bool success)\r\n     {\r\n          if (msg.sender == _contractOwner) {\r\n              \r\n              transactionfeeAmount = amount;\r\n            return true;\r\n          }\r\n       else{\r\n             return false;\r\n         }\r\n     }\r\n     \r\n     function canExecute(uint initialLockTime,uint256 _currenttime) public returns (bool success)\r\n     {\r\n          if (_currenttime >= initialLockTime + 3 days) {\r\n              \r\n            return true;\r\n          }\r\n       else{\r\n             return false;\r\n         }\r\n     }\r\n     \r\n     \r\n      function disperseRewards(address toaddress ,uint256 amount) public returns (bool success){\r\n      \r\n          if(msg.sender==_contractOwner)\r\n          {\r\n             if(inflation_complete)\r\n              {\r\n                  if(totalFeeCollected>0 && totalFeeCollected>amount)\r\n                  {\r\n                    totalFeeCollected = safeSub(totalFeeCollected,amount);\r\n                     balances[toaddress] = safeAdd(balances[toaddress],amount);\r\n                     Transfer(msg.sender, toaddress, amount);\r\n                     return true;\r\n                  }\r\n              \r\n              }\r\n              else\r\n              {\r\n                  return false;\r\n                  \r\n              }\r\n          }\r\n          return false;\r\n          \r\n      }\r\n       function claimIFSReward(address _sender) public returns (bool success){\r\n     \r\n       \r\n        if(msg.sender!=_sender)//Make sure only authorize owner of account could trigger IFS and he/she must have enough balance to trigger IFS\r\n        {\r\n            return false;\r\n        }\r\n        else\r\n        {\r\n            if(IFSBalances[_sender].Amount<=0)\r\n            {\r\n                return false;\r\n                \r\n            }\r\n            else{\r\n                // is IFS balance age minimum 3 day?\r\n                uint256 _currenttime = now;\r\n                if(canExecute(IFSBalances[_sender].IFSLockTime,_currenttime))\r\n                {\r\n                    //Get Total number of days in multiple of 3's.. Suppose if the staking lock was done 10 days ago\r\n                    //but the reward shall be allocated and calculated for 9 Days.\r\n                    uint256 calculatedreward = CalculateReward(IFSBalances[_sender].Amount,IFSBalances[_sender].IFSLockTime,_currenttime);\r\n                    \r\n                   if(!inflation_complete)\r\n                   {\r\n                    if(rewardsupply>=calculatedreward)\r\n                    {\r\n                   \r\n                   \r\n                         rewardsupply = safeSub(rewardsupply,calculatedreward);\r\n                         balances[_sender] =safeAdd(balances[_sender], calculatedreward);\r\n                         IFSBalances[_sender].IFSLockTime = _currenttime;//reset the clock\r\n                         IFSBalances[_sender].TotalRewardsCollected = safeAdd( IFSBalances[_sender].TotalRewardsCollected,calculatedreward);\r\n                          IFSBalances[_sender].LastCollectedReward = rewardsupply;//Set this to see last collected reward\r\n                    }\r\n                    else{\r\n                        \r\n                        if(rewardsupply>0)//whatever remaining in the supply hand it out to last staking account\r\n                        {\r\n                              \r\n                           balances[_sender] =safeAdd(balances[_sender], rewardsupply);\r\n                           rewardsupply = 0;\r\n                            \r\n                        }\r\n                        inflation_complete = true;\r\n                        \r\n                    }\r\n                    \r\n                   }\r\n                    \r\n                }\r\n                else{\r\n                    \r\n                    // Not time yet to process staking reward \r\n                    return false;\r\n                }\r\n                \r\n                \r\n                \r\n            }\r\n            return true;\r\n        }\r\n        \r\n    }\r\n   \r\n    function setIFS(address _sender,uint256 _amount) public returns (bool success){\r\n        if(msg.sender!=_sender || balances[_sender]<_amount || rewardsupply==0)//Make sure only authorize owner of account could trigger IFS and he/she must have enough balance to trigger IFS\r\n        {\r\n            return false;\r\n        }\r\n        balances[_sender] = safeSub(balances[_sender],_amount);\r\n        IFSBalances[_sender].Amount = safeAdd(IFSBalances[_sender].Amount,_amount);\r\n        IFSBalances[_sender].IFSLockTime = now;\r\n        IFSActive(_sender,_amount,IFSBalances[_sender].IFSLockTime);\r\n        totalstakeamount =  safeAdd(totalstakeamount,_amount);\r\n        return true;\r\n        \r\n    }\r\n    function reClaimIFS(address _sender)public returns (bool success){\r\n        if(msg.sender!=_sender || IFSBalances[_sender].Amount<=0 )//Make sure only authorize owner of account and > 0 staking could trigger reClaimIFS  \r\n        {\r\n            return false;\r\n        }\r\n        \r\n            balances[_sender] = safeAdd(balances[_sender],IFSBalances[_sender].Amount);\r\n            totalstakeamount =  safeSub(totalstakeamount,IFSBalances[_sender].Amount);\r\n            IFSBalances[_sender].Amount = 0;\r\n            IFSBalances[_sender].IFSLockTime = 0;// \r\n            IFSActive(_sender,0,IFSBalances[_sender].IFSLockTime);//Broadcast event ... Our mobile hooks should be listening to release time\r\n            \r\n            return true; \r\n        \r\n        \r\n    }\r\n    \r\n    \r\n    function HawalaToken(\r\n        )public {\r\n        //Add initial supply to total supply to make  7M. remaining 4.5M locked in for reward distribution        \r\n        totalSupply=safeAdd(initialSupply,rewardsupply);\r\n        balances[msg.sender] = initialSupply;               \r\n        name = \"HawalaToken\";                              \r\n        decimals = 12;                            \r\n        symbol = \"HAT\";  \r\n        inflation_complete = false;\r\n        HawalaKickoffTime=now;\r\n        totalstakeamount=0;\r\n        totalFeeCollected=0;\r\n        transactionfeeAmount=100000000000;// Initialized with 0.10 Percent per transaction after 10 years\r\n        _contractOwner = msg.sender;\r\n    }\r\n\r\n   \r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"stakingamount\",\"type\":\"uint256\"},{\"name\":\"initialLockTime\",\"type\":\"uint256\"},{\"name\":\"_currenttime\",\"type\":\"uint256\"}],\"name\":\"CalculateReward\",\"outputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"toaddress\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"disperseRewards\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"initialLockTime\",\"type\":\"uint256\"},{\"name\":\"_currenttime\",\"type\":\"uint256\"}],\"name\":\"canExecute\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setIFS\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalstakeamount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"changeTransactionFee\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"inflation_complete\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"claimIFSReward\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"IFSBalances\",\"outputs\":[{\"name\":\"TotalRewardsCollected\",\"type\":\"uint256\"},{\"name\":\"Amount\",\"type\":\"uint256\"},{\"name\":\"IFSLockTime\",\"type\":\"uint256\"},{\"name\":\"LastCollectedReward\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transactionfeeAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalFeeCollected\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardsupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"HawalaKickoffTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"reClaimIFS\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_locktime\",\"type\":\"uint256\"}],\"name\":\"IFSActive\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"HawalaToken","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://3f81fe4f382b54a34fd0ee3c1610a63771aee68e9cc62bea04f8a23a0fd0c91c"}]}