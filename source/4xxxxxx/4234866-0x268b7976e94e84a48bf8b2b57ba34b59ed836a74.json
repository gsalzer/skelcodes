{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n/*******************************************************************************\r\n * ERC Token Standard #20 Interface\r\n * https://github.com/ethereum/EIPs/issues/20\r\n *******************************************************************************/\r\ncontract ERC20Interface {\r\n  // Get the total token supply\r\n  function totalSupply() constant returns (uint256 totalSupply);\r\n\r\n  // Get the account balance of another account with address _owner\r\n  function balanceOf(address _owner) constant returns (uint256 balance);\r\n\r\n  // Send _value amount of tokens to address _to\r\n  function transfer(address _to, uint256 _value) returns (bool success);\r\n\r\n  // Send _value amount of tokens from address _from to address _to\r\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n\r\n  // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\r\n  // If this function is called again it overwrites the current allowance with _value.\r\n  // this function is required for some DEX functionality.\r\n  function approve(address _spender, uint256 _value) returns (bool success);\r\n\r\n  // Returns the amount which _spender is still allowed to withdraw from _owner\r\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n\r\n  // Triggered when tokens are transferred.\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n  // Triggered whenever approve(address _spender, uint256 _value) is called.\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n/*******************************************************************************\r\n * AICoin - Smart Contract with token and ballot handling\r\n *******************************************************************************/\r\ncontract AICoin is ERC20Interface {\r\n\r\n  /* ******************************\r\n   * COIN data / functions\r\n   * ******************************/\r\n\r\n  /* Token constants */\r\n  string public constant name = 'AICoin';\r\n  string public constant symbol = 'XAI';\r\n  uint8 public constant decimals = 8;\r\n  string public constant smallestUnit = 'Hofstadter';\r\n\r\n  /* Token internal data */\r\n  address m_administrator;\r\n  uint256 m_totalSupply;\r\n\r\n  /* Current balances for each account */\r\n  mapping(address => uint256) balances;\r\n\r\n  /* Account holder approves the transfer of an amount to another account */\r\n  mapping(address => mapping (address => uint256)) allowed;\r\n\r\n  /* One-time create function: initialize the supply and set the admin address */\r\n  function AICoin (uint256 _initialSupply) {\r\n    m_administrator = msg.sender;\r\n    m_totalSupply = _initialSupply;\r\n    balances[msg.sender] = _initialSupply;\r\n  }\r\n\r\n  /* Get the admin address */\r\n  function administrator() constant returns (address adminAddress) {\r\n    return m_administrator;\r\n  }\r\n\r\n  /* Get the total coin supply */\r\n  function totalSupply() constant returns (uint256 totalSupply) {\r\n    return m_totalSupply;\r\n  }\r\n\r\n  /* Get the balance of a specific account by its address */\r\n  function balanceOf(address _owner) constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  /* Transfer an amount from the owner's account to an indicated account */\r\n  function transfer(address _to, uint256 _amount) returns (bool success) {\r\n    if (balances[msg.sender] >= _amount\r\n        && _amount > 0\r\n        && balances[_to] + _amount > balances[_to]\r\n        && (! accountHasCurrentVote(msg.sender))) {\r\n      balances[msg.sender] -= _amount;\r\n      balances[_to] += _amount;\r\n      Transfer(msg.sender, _to, _amount);\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /* Send _value amount of tokens from address _from to address _to\r\n   * The transferFrom method is used for a withdraw workflow, allowing contracts to send\r\n   * tokens on your behalf, for example to \"deposit\" to a contract address and/or to charge\r\n   * fees in sub-currencies; the command should fail unless the _from account has\r\n   * deliberately authorized the sender of the message via some mechanism; we propose\r\n   * these standardized APIs for approval:\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _amount) returns (bool success) {\r\n    if (balances[_from] >= _amount\r\n        && allowed[_from][msg.sender] >= _amount\r\n        && _amount > 0\r\n        && balances[_to] + _amount > balances[_to]\r\n        && (! accountHasCurrentVote(_from))) {\r\n      balances[_from] -= _amount;\r\n      allowed[_from][msg.sender] -= _amount;\r\n      balances[_to] += _amount;\r\n      Transfer(_from, _to, _amount);\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /* Pre-authorize an address to withdraw from your account, up to the _value amount.\r\n   * Doing so (using transferFrom) reduces the remaining authorized amount,\r\n   * as well as the actual account balance)\r\n   * Subsequent calls to this function overwrite any existing authorized amount.\r\n   * Therefore, to cancel an authorization, simply write a zero amount.\r\n   */\r\n  function approve(address _spender, uint256 _amount) returns (bool success) {\r\n    allowed[msg.sender][_spender] = _amount;\r\n    Approval(msg.sender, _spender, _amount);\r\n    return true;\r\n  }\r\n\r\n  /* Get the currently authorized that can be withdrawn by account _spender from account _owner */\r\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /* ******************************\r\n   * BALLOT data / functions\r\n   * ******************************/\r\n\r\n  /* Dev Note: creating a struct that contained a string, uint values and\r\n   * an array of option structs, etc, would consistently fail.\r\n   * So the ballot details are held in separate mappings with a common integer\r\n   * key for each ballot. The IDs are 1-indexed, sequential and contiguous.\r\n   */\r\n\r\n  /* Basic ballot details: time frame and number of options */\r\n  struct BallotDetails {\r\n    uint256 start;\r\n    uint256 end;\r\n    uint32 numOptions; // 1-indexed for readability\r\n    bool sealed;\r\n  }\r\n\r\n  uint32 public numBallots = 0; // 1-indexed for readability\r\n  mapping (uint32 => string) public ballotNames;\r\n  mapping (uint32 => BallotDetails) public ballotDetails;\r\n  mapping (uint32 => mapping (uint32 => string) ) public ballotOptions;\r\n\r\n  /* Create a new ballot and set the basic details (proposal description, dates)\r\n   * The ballot still need to have options added and then to be sealed\r\n   */\r\n  function adminAddBallot(string _proposal, uint256 _start, uint256 _end) {\r\n\r\n    /* Admin functions must be called by the contract creator. */\r\n    require(msg.sender == m_administrator);\r\n\r\n    /* Create and store the new ballot objects */\r\n    numBallots++;\r\n    uint32 ballotId = numBallots;\r\n    ballotNames[ballotId] = _proposal;\r\n    ballotDetails[ballotId] = BallotDetails(_start, _end, 0, false);\r\n  }\r\n\r\n  /* Create a new ballot and set the basic details (proposal description, dates)\r\n   * The ballot still need to have options added and then to be sealed\r\n   */\r\n  function adminAmendBallot(uint32 _ballotId, string _proposal, uint256 _start, uint256 _end) {\r\n\r\n    /* Admin functions must be called by the contract creator. */\r\n    require(msg.sender == m_administrator);\r\n\r\n    /* verify that the ballot exists */\r\n    require(_ballotId > 0 && _ballotId <= numBallots);\r\n\r\n    /* update the ballot object */\r\n    ballotNames[_ballotId] = _proposal;\r\n    ballotDetails[_ballotId].start = _start;\r\n    ballotDetails[_ballotId].end = _end;\r\n  }\r\n\r\n  /* Add an option to an existing Ballot\r\n   */\r\n  function adminAddBallotOption(uint32 _ballotId, string _option) {\r\n\r\n    /* Admin functions must be called by the contract creator. */\r\n    require(msg.sender == m_administrator);\r\n\r\n    /* verify that the ballot exists */\r\n    require(_ballotId > 0 && _ballotId <= numBallots);\r\n\r\n    /* cannot change a ballot once it is sealed */\r\n    if(isBallotSealed(_ballotId)) {\r\n      revert();\r\n    }\r\n\r\n    /* store the new ballot option */\r\n    ballotDetails[_ballotId].numOptions += 1;\r\n    uint32 optionId = ballotDetails[_ballotId].numOptions;\r\n    ballotOptions[_ballotId][optionId] = _option;\r\n  }\r\n\r\n  /* Amend and option in an existing Ballot\r\n   */\r\n  function adminEditBallotOption(uint32 _ballotId, uint32 _optionId, string _option) {\r\n\r\n    /* Admin functions must be called by the contract creator. */\r\n    require(msg.sender == m_administrator);\r\n\r\n    /* verify that the ballot exists */\r\n    require(_ballotId > 0 && _ballotId <= numBallots);\r\n\r\n    /* cannot change a ballot once it is sealed */\r\n    if(isBallotSealed(_ballotId)) {\r\n      revert();\r\n    }\r\n\r\n    /* validate the ballot option */\r\n    require(_optionId > 0 && _optionId <= ballotDetails[_ballotId].numOptions);\r\n\r\n    /* update the ballot option */\r\n    ballotOptions[_ballotId][_optionId] = _option;\r\n  }\r\n\r\n  /* Seal a ballot - after this the ballot is official and no changes can be made.\r\n   */\r\n  function adminSealBallot(uint32 _ballotId) {\r\n\r\n    /* Admin functions must be called by the contract creator. */\r\n    require(msg.sender == m_administrator);\r\n\r\n    /* verify that the ballot exists */\r\n    require(_ballotId > 0 && _ballotId <= numBallots);\r\n\r\n    /* cannot change a ballot once it is sealed */\r\n    if(isBallotSealed(_ballotId)) {\r\n      revert();\r\n    }\r\n\r\n    /* set the ballot seal flag */\r\n    ballotDetails[_ballotId].sealed = true;\r\n  }\r\n\r\n  /* Function to determine if a ballot is currently in progress, based on its\r\n   * start and end dates, and that it has been sealed.\r\n   */\r\n  function isBallotInProgress(uint32 _ballotId) private constant returns (bool) {\r\n    return (isBallotSealed(_ballotId)\r\n            && ballotDetails[_ballotId].start <= now\r\n            && ballotDetails[_ballotId].end >= now);\r\n  }\r\n\r\n  /* Function to determine if a ballot has ended, based on its end date */\r\n  function hasBallotEnded(uint32 _ballotId) private constant returns (bool) {\r\n    return (ballotDetails[_ballotId].end < now);\r\n  }\r\n\r\n  /* Function to determine if a ballot has been sealed, which means it has been\r\n   * authorized by the administrator and can no longer be changed.\r\n   */\r\n  function isBallotSealed(uint32 _ballotId) private returns (bool) {\r\n    return ballotDetails[_ballotId].sealed;\r\n  }\r\n\r\n  /* ******************************\r\n   * VOTING data / functions\r\n   * ******************************/\r\n\r\n  mapping (uint32 => mapping (address => uint256) ) public ballotVoters;\r\n  mapping (uint32 => mapping (uint32 => uint256) ) public ballotVoteCount;\r\n\r\n  /* function to allow a coin holder add to the vote count of an option in an\r\n   * active ballot. The votes added equals the balance of the account. Once this is called successfully\r\n   * the coins cannot be transferred out of the account until the end of the ballot.\r\n   *\r\n   * NB: The timing of the start and end of the voting period is determined by\r\n   * the timestamp of the block in which the transaction is included. As given by\r\n   * the current Ethereum standard this is *NOT* guaranteed to be accurate to any\r\n   * given external time source. Therefore, votes should be placed well in advance\r\n   * of the UTC end time of the Ballot.\r\n   */\r\n  function vote(uint32 _ballotId, uint32 _selectedOptionId) {\r\n\r\n    /* verify that the ballot exists */\r\n    require(_ballotId > 0 && _ballotId <= numBallots);\r\n\r\n    /* Ballot must be in progress in order to vote */\r\n    require(isBallotInProgress(_ballotId));\r\n\r\n    /* Calculate the balance which which the coin holder has not yet voted, which is the difference between\r\n     * the current balance for the senders address and the amount they already voted in this ballot.\r\n     * If the difference is zero, this attempt to vote will fail.\r\n     */\r\n    uint256 votableBalance = balanceOf(msg.sender) - ballotVoters[_ballotId][msg.sender];\r\n    require(votableBalance > 0);\r\n\r\n    /* validate the ballot option */\r\n    require(_selectedOptionId > 0 && _selectedOptionId <= ballotDetails[_ballotId].numOptions);\r\n\r\n    /* update the vote count and record the voter */\r\n    ballotVoteCount[_ballotId][_selectedOptionId] += votableBalance;\r\n    ballotVoters[_ballotId][msg.sender] += votableBalance;\r\n  }\r\n\r\n  /* function to determine if an address has already voted in a given ballot */\r\n  function hasAddressVotedInBallot(uint32 _ballotId, address _voter) constant returns (bool hasVoted) {\r\n    return ballotVoters[_ballotId][_voter] > 0;\r\n  }\r\n\r\n  /* function to determine if an account has voted in any current ballot */\r\n  function accountHasCurrentVote(address _voter) constant returns (bool) {\r\n    for(uint32 id = 1; id <= numBallots; id++) {\r\n      if (isBallotInProgress(id) && hasAddressVotedInBallot(id, _voter)) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ballotId\",\"type\":\"uint32\"}],\"name\":\"adminSealBallot\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numBallots\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint32\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"ballotVoters\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposal\",\"type\":\"string\"},{\"name\":\"_start\",\"type\":\"uint256\"},{\"name\":\"_end\",\"type\":\"uint256\"}],\"name\":\"adminAddBallot\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ballotId\",\"type\":\"uint32\"},{\"name\":\"_optionId\",\"type\":\"uint32\"},{\"name\":\"_option\",\"type\":\"string\"}],\"name\":\"adminEditBallotOption\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"smallestUnit\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"ballotNames\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_voter\",\"type\":\"address\"}],\"name\":\"accountHasCurrentVote\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ballotId\",\"type\":\"uint32\"},{\"name\":\"_option\",\"type\":\"string\"}],\"name\":\"adminAddBallotOption\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint32\"},{\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"ballotOptions\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_ballotId\",\"type\":\"uint32\"},{\"name\":\"_voter\",\"type\":\"address\"}],\"name\":\"hasAddressVotedInBallot\",\"outputs\":[{\"name\":\"hasVoted\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"ballotDetails\",\"outputs\":[{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"},{\"name\":\"numOptions\",\"type\":\"uint32\"},{\"name\":\"sealed\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ballotId\",\"type\":\"uint32\"},{\"name\":\"_selectedOptionId\",\"type\":\"uint32\"}],\"name\":\"vote\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ballotId\",\"type\":\"uint32\"},{\"name\":\"_proposal\",\"type\":\"string\"},{\"name\":\"_start\",\"type\":\"uint256\"},{\"name\":\"_end\",\"type\":\"uint256\"}],\"name\":\"adminAmendBallot\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint32\"},{\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"ballotVoteCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"administrator\",\"outputs\":[{\"name\":\"adminAddress\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_initialSupply\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"AICoin","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000001b751d3558960c","Library":"","SwarmSource":"bzzr://2ddfb56690bcb419a0e6e5929f5558b1cdc4df000de325a956fa787217bb6063"}]}