{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\n/**\r\n * Math operations with safety checks\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint a, uint b) internal returns (uint) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint a, uint b) internal constant returns (uint) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint a, uint b) internal constant returns (uint) {\r\n    return a < b ? a : b;\r\n  }\r\n}\r\n\r\n/**\r\n * Interface for defining crowdsale ceiling.\r\n */\r\ncontract CeilingStrategy {\r\n\r\n  /** Interface declaration. */\r\n  function isCeilingStrategy() public constant returns (bool) {\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * When somebody tries to buy tokens for X wei, calculate how many weis they are allowed to use.\r\n   *\r\n   *\r\n   * @param _value - What is the value of the transaction sent in as wei.\r\n   * @param _weiRaised - How much money has been raised so far.\r\n   * @param _weiInvestedBySender - the investment made by the address that is sending the transaction.\r\n   * @param _weiFundingCap - the caller's declared total cap. May be reinterpreted by the implementation of the CeilingStrategy.\r\n   * @return Amount of wei the crowdsale can receive.\r\n   */\r\n  function weiAllowedToReceive(uint _value, uint _weiRaised, uint _weiInvestedBySender, uint _weiFundingCap) public constant returns (uint amount);\r\n\r\n  function isCrowdsaleFull(uint _weiRaised, uint _weiFundingCap) public constant returns (bool);\r\n\r\n  /**\r\n   * Calculate a new cap if the provided one is not above the amount already raised.\r\n   *\r\n   *\r\n   * @param _newCap - The potential new cap.\r\n   * @param _weiRaised - How much money has been raised so far.\r\n   * @return The adjusted cap.\r\n   */\r\n  function relaxFundingCap(uint _newCap, uint _weiRaised) public constant returns (uint);\r\n\r\n}\r\n\r\n/**\r\n * Fixed cap investment per address and crowdsale\r\n */\r\ncontract FixedCeiling is CeilingStrategy {\r\n    using SafeMath for uint;\r\n\r\n    /* When relaxing a cap is necessary, we use this multiple to determine the relaxed cap */\r\n    uint public chunkedWeiMultiple;\r\n    /* The limit an individual address can invest */\r\n    uint public weiLimitPerAddress;\r\n\r\n    function FixedCeiling(uint multiple, uint limit) {\r\n        chunkedWeiMultiple = multiple;\r\n        weiLimitPerAddress = limit;\r\n    }\r\n\r\n    function weiAllowedToReceive(uint tentativeAmount, uint weiRaised, uint weiInvestedBySender, uint weiFundingCap) public constant returns (uint) {\r\n        // First, we limit per address investment\r\n        uint totalOfSender = tentativeAmount.add(weiInvestedBySender);\r\n        if (totalOfSender > weiLimitPerAddress) tentativeAmount = weiLimitPerAddress.sub(weiInvestedBySender);\r\n        // Then, we check the funding cap\r\n        if (weiFundingCap == 0) return tentativeAmount;\r\n        uint total = tentativeAmount.add(weiRaised);\r\n        if (total < weiFundingCap) return tentativeAmount;\r\n        else return weiFundingCap.sub(weiRaised);\r\n    }\r\n\r\n    function isCrowdsaleFull(uint weiRaised, uint weiFundingCap) public constant returns (bool) {\r\n        return weiFundingCap > 0 && weiRaised >= weiFundingCap;\r\n    }\r\n\r\n    /* If the new target cap has not been reached yet, it's fine as it is */\r\n    function relaxFundingCap(uint newCap, uint weiRaised) public constant returns (uint) {\r\n        if (newCap > weiRaised) return newCap;\r\n        else return weiRaised.div(chunkedWeiMultiple).add(1).mul(chunkedWeiMultiple);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"weiLimitPerAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"chunkedWeiMultiple\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isCeilingStrategy\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tentativeAmount\",\"type\":\"uint256\"},{\"name\":\"weiRaised\",\"type\":\"uint256\"},{\"name\":\"weiInvestedBySender\",\"type\":\"uint256\"},{\"name\":\"weiFundingCap\",\"type\":\"uint256\"}],\"name\":\"weiAllowedToReceive\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"newCap\",\"type\":\"uint256\"},{\"name\":\"weiRaised\",\"type\":\"uint256\"}],\"name\":\"relaxFundingCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"weiRaised\",\"type\":\"uint256\"},{\"name\":\"weiFundingCap\",\"type\":\"uint256\"}],\"name\":\"isCrowdsaleFull\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"multiple\",\"type\":\"uint256\"},{\"name\":\"limit\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"constructor\"}]","ContractName":"FixedCeiling","CompilerVersion":"v0.4.13+commit.fb4cb1a","OptimizationUsed":"1","Runs":"0","ConstructorArguments":"0000000000000000000000000000000000000000000003cfc82e37e9a740000000000000000000000000000000000000000000000000152d02c7e14af6800000","Library":"","SwarmSource":"bzzr://a52c9bca7cbc4d524dfd6b63f6c5ae8f01cbffb0e33ed72a9dd41acb49de0e18"}]}