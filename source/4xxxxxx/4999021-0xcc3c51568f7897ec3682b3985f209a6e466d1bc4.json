{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\ncontract OraclizeI {\r\n    address public cbAddress;\r\n    function query(uint _timestamp, string _datasource, string _arg) public payable returns (bytes32 _id);\r\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) public  payable returns (bytes32 _id);\r\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) public  payable returns (bytes32 _id);\r\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) public payable returns (bytes32 _id);\r\n    function queryN(uint _timestamp, string _datasource, bytes _argN) public payable returns (bytes32 _id);\r\n    function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) public payable returns (bytes32 _id);\r\n    function getPrice(string _datasource) public returns (uint _dsprice);\r\n    function getPrice(string _datasource, uint gaslimit) public returns (uint _dsprice);\r\n    function setProofType(byte _proofType) public;\r\n    function setConfig(bytes32 _config) public;\r\n    function setCustomGasPrice(uint _gasPrice) public;\r\n    function randomDS_getSessionPubKeyHash() public returns(bytes32);\r\n}\r\n\r\nlibrary Math {\r\n  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n}\r\n\r\ncontract OraclizeAddrResolverI {\r\n    function getAddress() public returns (address _addr);\r\n}\r\n\r\ncontract Priceable {\r\n    modifier costsExactly(uint price) {\r\n        if (msg.value == price) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier costs(uint price) {\r\n        if (msg.value >= price) {\r\n            _;\r\n        }\r\n    }\r\n}\r\n\r\ncontract RewardDistributable {\r\n    event TokensRewarded(address indexed player, address rewardToken, uint rewards, address requester, uint gameId, uint block);\r\n    event ReferralRewarded(address indexed referrer, address indexed player, address rewardToken, uint rewards, uint gameId, uint block);\r\n    event ReferralRegistered(address indexed player, address indexed referrer);\r\n\r\n    /// @dev Calculates and transfers the rewards to the player.\r\n    function transferRewards(address player, uint entryAmount, uint gameId) public;\r\n\r\n    /// @dev Returns the total number of tokens, across all approvals.\r\n    function getTotalTokens(address tokenAddress) public constant returns(uint);\r\n\r\n    /// @dev Returns the total number of supported reward token contracts.\r\n    function getRewardTokenCount() public constant returns(uint);\r\n\r\n    /// @dev Gets the total number of approvers.\r\n    function getTotalApprovers() public constant returns(uint);\r\n\r\n    /// @dev Gets the reward rate inclusive of referral bonus.\r\n    function getRewardRate(address player, address tokenAddress) public constant returns(uint);\r\n\r\n    /// @dev Adds a requester to the whitelist.\r\n    /// @param requester The address of a contract which will request reward transfers\r\n    function addRequester(address requester) public;\r\n\r\n    /// @dev Removes a requester from the whitelist.\r\n    /// @param requester The address of a contract which will request reward transfers\r\n    function removeRequester(address requester) public;\r\n\r\n    /// @dev Adds a approver address.  Approval happens with the token contract.\r\n    /// @param approver The approver address to add to the pool.\r\n    function addApprover(address approver) public;\r\n\r\n    /// @dev Removes an approver address. \r\n    /// @param approver The approver address to remove from the pool.\r\n    function removeApprover(address approver) public;\r\n\r\n    /// @dev Updates the reward rate\r\n    function updateRewardRate(address tokenAddress, uint newRewardRate) public;\r\n\r\n    /// @dev Updates the token address of the payment type.\r\n    function addRewardToken(address tokenAddress, uint newRewardRate) public;\r\n\r\n    /// @dev Updates the token address of the payment type.\r\n    function removeRewardToken(address tokenAddress) public;\r\n\r\n    /// @dev Updates the referral bonus rate\r\n    function updateReferralBonusRate(uint newReferralBonusRate) public;\r\n\r\n    /// @dev Registers the player with the given referral code\r\n    /// @param player The address of the player\r\n    /// @param referrer The address of the referrer\r\n    function registerReferral(address player, address referrer) public;\r\n\r\n    /// @dev Transfers any tokens to the owner\r\n    function destroyRewards() public;\r\n}\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\nlibrary OraclizeLib {\r\n   \r\n    struct OraclizeData {\r\n        OraclizeAddrResolverI oraclizeAddressResolver;\r\n        OraclizeI oraclize;\r\n        mapping(bytes32=>bytes32) oraclizeRandomDSArgs;\r\n        mapping(bytes32=>bool) oraclizeRandomDsSessionKeyHashVerified;\r\n        string oraclizeNetworkName;\r\n    }\r\n\r\n    function initializeOraclize(OraclizeData storage self) internal {\r\n       self.oraclizeAddressResolver = oraclize_setNetwork(self);\r\n       if (self.oraclizeAddressResolver != address(0)) {\r\n           self.oraclize = OraclizeI(self.oraclizeAddressResolver.getAddress());\r\n       }\r\n    }\r\n\r\n    function oraclize_setNetwork(OraclizeData storage self) public returns(OraclizeAddrResolverI) {\r\n        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0) { //mainnet\r\n            oraclize_setNetworkName(self, \"eth_mainnet\");\r\n            return OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\r\n        }\r\n        if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0) { //ropsten testnet\r\n            oraclize_setNetworkName(self, \"eth_ropsten3\");\r\n            return OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\r\n        }\r\n        if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0) { //kovan testnet\r\n            oraclize_setNetworkName(self, \"eth_kovan\");\r\n            return OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\r\n        }\r\n        if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0) { //rinkeby testnet\r\n            oraclize_setNetworkName(self, \"eth_rinkeby\");\r\n            return OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\r\n        }\r\n        if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0) { //ethereum-bridge\r\n            return OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\r\n        }\r\n        if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0) { //ether.camp ide\r\n            return OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\r\n        }\r\n        if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0) { //browser-solidity\r\n            return OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\r\n        }\r\n    }\r\n\r\n    function oraclize_setNetworkName(OraclizeData storage self, string _network_name) internal {\r\n        self.oraclizeNetworkName = _network_name;\r\n    }\r\n    \r\n    function oraclize_getNetworkName(OraclizeData storage self) internal constant returns (string) {\r\n        return self.oraclizeNetworkName;\r\n    }\r\n\r\n    function oraclize_getPrice(OraclizeData storage self, string datasource) public returns (uint) {\r\n        return self.oraclize.getPrice(datasource);\r\n    }\r\n\r\n    function oraclize_getPrice(OraclizeData storage self, string datasource, uint gaslimit) public returns (uint) {\r\n        return self.oraclize.getPrice(datasource, gaslimit);\r\n    }\r\n\r\n    function oraclize_query(OraclizeData storage self, string datasource, string arg) public returns (bytes32 id) {\r\n        return oraclize_query(self, 0, datasource, arg);\r\n    }\r\n\r\n    function oraclize_query(OraclizeData storage self, uint timestamp, string datasource, string arg) public returns (bytes32 id) {\r\n        uint price = self.oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) {\r\n            return 0; // unexpectedly high price\r\n        }\r\n        return self.oraclize.query.value(price)(timestamp, datasource, arg);\r\n    }\r\n\r\n    function oraclize_query(OraclizeData storage self, string datasource, string arg, uint gaslimit) public returns (bytes32 id) {\r\n        return oraclize_query(self, 0, datasource, arg, gaslimit);\r\n    }\r\n\r\n    function oraclize_query(OraclizeData storage self, uint timestamp, string datasource, string arg, uint gaslimit) public returns (bytes32 id) {\r\n        uint price = self.oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) {\r\n            return 0; // unexpectedly high price\r\n        }\r\n        return self.oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\r\n    }\r\n\r\n    function oraclize_query(OraclizeData storage self, string datasource, string arg1, string arg2) public returns (bytes32 id) {\r\n        return oraclize_query(self, 0, datasource, arg1, arg2);\r\n    }\r\n\r\n    function oraclize_query(OraclizeData storage self, uint timestamp, string datasource, string arg1, string arg2) public returns (bytes32 id) {\r\n        uint price = self.oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) {\r\n            return 0; // unexpectedly high price\r\n        }\r\n        return self.oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\r\n    }\r\n\r\n    function oraclize_query(OraclizeData storage self, string datasource, string arg1, string arg2, uint gaslimit) public returns (bytes32 id) {\r\n        return oraclize_query(self, 0, datasource, arg1, arg2, gaslimit);\r\n    }\r\n\r\n    function oraclize_query(OraclizeData storage self, uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) public returns (bytes32 id) {\r\n        uint price = self.oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) {\r\n            return 0; // unexpectedly high price\r\n        }\r\n        return self.oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\r\n    }\r\n\r\n    function oraclize_query(OraclizeData storage self, string datasource, string[] argN) internal returns (bytes32 id) {\r\n        return oraclize_query(self, 0, datasource, argN);\r\n    }\r\n\r\n    function oraclize_query(OraclizeData storage self, uint timestamp, string datasource, string[] argN) internal returns (bytes32 id) {\r\n        uint price = self.oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) {\r\n            return 0; // unexpectedly high price\r\n        }\r\n        bytes memory args = stra2cbor(argN);\r\n        return self.oraclize.queryN.value(price)(timestamp, datasource, args);\r\n    }\r\n\r\n    function oraclize_query(OraclizeData storage self, string datasource, string[] argN, uint gaslimit) internal returns (bytes32 id) {\r\n        return oraclize_query(self, 0, datasource, argN, gaslimit);\r\n    }\r\n\r\n    function oraclize_query(OraclizeData storage self, uint timestamp, string datasource, string[] argN, uint gaslimit) internal returns (bytes32 id){\r\n        uint price = self.oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) {\r\n            return 0; // unexpectedly high price\r\n        }\r\n        bytes memory args = stra2cbor(argN);\r\n        return self.oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\r\n    }\r\n\r\n     function oraclize_query(OraclizeData storage self, uint timestamp, string datasource, bytes[] argN, uint gaslimit) internal returns (bytes32 id){\r\n        uint price = self.oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) {\r\n            return 0; // unexpectedly high price\r\n        }\r\n        bytes memory args = ba2cbor(argN);\r\n        return self.oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\r\n    }\r\n\r\n    function oraclize_newRandomDSQuery(OraclizeData storage self, uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32) {\r\n        assert((_nbytes > 0) && (_nbytes <= 32));\r\n        bytes memory nbytes = new bytes(1);\r\n        nbytes[0] = byte(_nbytes);\r\n        bytes memory unonce = new bytes(32);\r\n        bytes memory sessionKeyHash = new bytes(32);\r\n        bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash(self);\r\n        assembly {\r\n            mstore(unonce, 0x20)\r\n            mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\r\n            mstore(sessionKeyHash, 0x20)\r\n            mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\r\n        }\r\n        bytes[] memory args = new bytes[](3);\r\n        args[0] = unonce;\r\n        args[1] = nbytes;\r\n        args[2] = sessionKeyHash; \r\n        bytes32 queryId = oraclize_query(self, _delay, \"random\", args, _customGasLimit);\r\n        oraclize_randomDS_setCommitment(self, queryId, keccak256(bytes8(_delay), args[1], sha256(args[0]), args[2]));\r\n        return queryId;\r\n    }\r\n\r\n     function oraclize_randomDS_proofVerify__main(OraclizeData storage self, bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\r\n        bool checkok;\r\n        \r\n        // Step 2: the unique keyhash has to match with the sha256 of (context name + queryId)\r\n        uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;\r\n        bytes memory keyhash = new bytes(32);\r\n        copyBytes(proof, ledgerProofLength, 32, keyhash, 0);\r\n        checkok = (keccak256(keyhash) == keccak256(sha256(context_name, queryId)));\r\n        if (checkok == false) {\r\n            return false;\r\n        }\r\n        \r\n        bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);\r\n        copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);\r\n        \r\n        // Step 3: we assume sig1 is valid (it will be verified during step 5) and we verify if 'result' is the prefix of sha256(sig1)\r\n        checkok = matchBytes32Prefix(sha256(sig1), result);\r\n        if (checkok == false) {\r\n            return false;\r\n        }\r\n        \r\n        // Step 4: commitment match verification, keccak256(delay, nbytes, unonce, sessionKeyHash) == commitment in storage.\r\n        // This is to verify that the computed args match with the ones specified in the query.\r\n        bytes memory commitmentSlice1 = new bytes(8+1+32);\r\n        copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);\r\n        \r\n        bytes memory sessionPubkey = new bytes(64);\r\n        uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;\r\n        copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);\r\n        \r\n        bytes32 sessionPubkeyHash = sha256(sessionPubkey);\r\n        if (self.oraclizeRandomDSArgs[queryId] == keccak256(commitmentSlice1, sessionPubkeyHash)) {\r\n            delete self.oraclizeRandomDSArgs[queryId]; //unonce, nbytes and sessionKeyHash match\r\n        } else {\r\n            return false;\r\n        }\r\n\r\n        // Step 5: validity verification for sig1 (keyhash and args signed with the sessionKey)\r\n        bytes memory tosign1 = new bytes(32+8+1+32);\r\n        copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);\r\n        checkok = verifySig(sha256(tosign1), sig1, sessionPubkey);\r\n        if (checkok == false) {\r\n            return false;\r\n        }\r\n\r\n        // verify if sessionPubkeyHash was verified already, if not.. let's do it!\r\n        if (self.oraclizeRandomDsSessionKeyHashVerified[sessionPubkeyHash] == false) {\r\n            self.oraclizeRandomDsSessionKeyHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);\r\n        }\r\n        \r\n        return self.oraclizeRandomDsSessionKeyHashVerified[sessionPubkeyHash];\r\n    }\r\n\r\n    function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {\r\n        bool sigok;\r\n        \r\n        // Step 6: verify the attestation signature, APPKEY1 must sign the sessionKey from the correct ledger app (CODEHASH)\r\n        bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);\r\n        copyBytes(proof, sig2offset, sig2.length, sig2, 0);\r\n        \r\n        bytes memory appkey1_pubkey = new bytes(64);\r\n        copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);\r\n        \r\n        bytes memory tosign2 = new bytes(1+65+32);\r\n        tosign2[0] = 1; //role\r\n        copyBytes(proof, sig2offset-65, 65, tosign2, 1);\r\n        bytes memory CODEHASH = hex\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\";\r\n        copyBytes(CODEHASH, 0, 32, tosign2, 1+65);\r\n        sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);\r\n        \r\n        if (sigok == false) {\r\n            return false;\r\n        }\r\n        \r\n        // Step 7: verify the APPKEY1 provenance (must be signed by Ledger)\r\n        bytes memory LEDGERKEY = hex\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\";\r\n        \r\n        bytes memory tosign3 = new bytes(1+65);\r\n        tosign3[0] = 0xFE;\r\n        copyBytes(proof, 3, 65, tosign3, 1);\r\n        \r\n        bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);\r\n        copyBytes(proof, 3+65, sig3.length, sig3, 0);\r\n        \r\n        sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);\r\n        \r\n        return sigok;\r\n    }\r\n\r\n    function oraclize_randomDS_proofVerify__returnCode(OraclizeData storage self, bytes32 _queryId, string _result, bytes _proof) internal returns (uint8) {\r\n        // Step 1: the prefix has to match 'LP\\x01' (Ledger Proof version 1)\r\n        if ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) {\r\n            return 1;\r\n        }\r\n        bool proofVerified = oraclize_randomDS_proofVerify__main(self, _proof, _queryId, bytes(_result), oraclize_getNetworkName(self));\r\n        if (proofVerified == false) {\r\n            return 2;\r\n        }\r\n        return 0;\r\n    }\r\n    \r\n    function oraclize_randomDS_setCommitment(OraclizeData storage self, bytes32 queryId, bytes32 commitment) internal {\r\n        self.oraclizeRandomDSArgs[queryId] = commitment;\r\n    }\r\n    \r\n    function matchBytes32Prefix(bytes32 content, bytes prefix) internal pure returns (bool) {\r\n        bool match_ = true;\r\n        \r\n        for (uint i=0; i<prefix.length; i++) {\r\n            if (content[i] != prefix[i]) {\r\n                match_ = false;\r\n            }\r\n        }\r\n        \r\n        return match_;\r\n    }\r\n\r\n    function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool) {\r\n        bool sigok;\r\n        address signer;\r\n        \r\n        bytes32 sigr;\r\n        bytes32 sigs;\r\n        \r\n        bytes memory sigr_ = new bytes(32);\r\n        uint offset = 4+(uint(dersig[3]) - 0x20);\r\n        sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);\r\n        bytes memory sigs_ = new bytes(32);\r\n        offset += 32 + 2;\r\n        sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);\r\n\r\n        assembly {\r\n            sigr := mload(add(sigr_, 32))\r\n            sigs := mload(add(sigs_, 32))\r\n        }\r\n        \r\n        \r\n        (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);\r\n        if (address(keccak256(pubkey)) == signer) {\r\n            return true;\r\n        } else {\r\n            (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);\r\n            return (address(keccak256(pubkey)) == signer);\r\n        }\r\n    }\r\n\r\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\r\n    // Duplicate Solidity's ecrecover, but catching the CALL return value\r\n    function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\r\n        // We do our own memory management here. Solidity uses memory offset\r\n        // 0x40 to store the current end of memory. We write past it (as\r\n        // writes are memory extensions), but don't update the offset so\r\n        // Solidity will reuse it. The memory used here is only needed for\r\n        // this context.\r\n\r\n        // FIXME: inline assembly can't access return values\r\n        bool ret;\r\n        address addr;\r\n\r\n        assembly {\r\n            let size := mload(0x40)\r\n            mstore(size, hash)\r\n            mstore(add(size, 32), v)\r\n            mstore(add(size, 64), r)\r\n            mstore(add(size, 96), s)\r\n\r\n            // NOTE: we can reuse the request memory because we deal with\r\n            //       the return code\r\n            ret := call(3000, 1, 0, size, 128, size, 32)\r\n            addr := mload(size)\r\n        }\r\n  \r\n        return (ret, addr);\r\n    }\r\n    \r\n    function oraclize_cbAddress(OraclizeData storage self) public constant returns (address) {\r\n        return self.oraclize.cbAddress();\r\n    }\r\n\r\n    function oraclize_setProof(OraclizeData storage self, byte proofP) public {\r\n        return self.oraclize.setProofType(proofP);\r\n    }\r\n\r\n    function oraclize_setCustomGasPrice(OraclizeData storage self, uint gasPrice) public {\r\n        return self.oraclize.setCustomGasPrice(gasPrice);\r\n    }\r\n\r\n    function oraclize_setConfig(OraclizeData storage self, bytes32 config) public {\r\n        return self.oraclize.setConfig(config);\r\n    }\r\n\r\n    function getCodeSize(address _addr) public constant returns(uint _size) {\r\n        assembly {\r\n            _size := extcodesize(_addr)\r\n        }\r\n    }\r\n    \r\n    function oraclize_randomDS_getSessionPubKeyHash(OraclizeData storage self) internal returns (bytes32){\r\n        return self.oraclize.randomDS_getSessionPubKeyHash();\r\n    }\r\n\r\n    function stra2cbor(string[] arr) internal pure returns (bytes) {\r\n        uint arrlen = arr.length;\r\n\r\n        // get correct cbor output length\r\n        uint outputlen = 0;\r\n        bytes[] memory elemArray = new bytes[](arrlen);\r\n        for (uint i = 0; i < arrlen; i++) {\r\n            elemArray[i] = (bytes(arr[i]));\r\n            outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types\r\n        }\r\n        uint ctr = 0;\r\n        uint cborlen = arrlen + 0x80;\r\n        outputlen += byte(cborlen).length;\r\n        bytes memory res = new bytes(outputlen);\r\n\r\n        while (byte(cborlen).length > ctr) {\r\n            res[ctr] = byte(cborlen)[ctr];\r\n            ctr++;\r\n        }\r\n        for (i = 0; i < arrlen; i++) {\r\n            res[ctr] = 0x5F;\r\n            ctr++;\r\n            for (uint x = 0; x < elemArray[i].length; x++) {\r\n                // if there's a bug with larger strings, this may be the culprit\r\n                if (x % 23 == 0) {\r\n                    uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\r\n                    elemcborlen += 0x40;\r\n                    uint lctr = ctr;\r\n                    while (byte(elemcborlen).length > ctr - lctr) {\r\n                        res[ctr] = byte(elemcborlen)[ctr - lctr];\r\n                        ctr++;\r\n                    }\r\n                }\r\n                res[ctr] = elemArray[i][x];\r\n                ctr++;\r\n            }\r\n            res[ctr] = 0xFF;\r\n            ctr++;\r\n        }\r\n        return res;\r\n    }\r\n\r\n    function ba2cbor(bytes[] arr) internal pure returns (bytes) {\r\n            uint arrlen = arr.length;\r\n\r\n            // get correct cbor output length\r\n            uint outputlen = 0;\r\n            bytes[] memory elemArray = new bytes[](arrlen);\r\n            for (uint i = 0; i < arrlen; i++) {\r\n                elemArray[i] = (bytes(arr[i]));\r\n                outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types\r\n            }\r\n            uint ctr = 0;\r\n            uint cborlen = arrlen + 0x80;\r\n            outputlen += byte(cborlen).length;\r\n            bytes memory res = new bytes(outputlen);\r\n\r\n            while (byte(cborlen).length > ctr) {\r\n                res[ctr] = byte(cborlen)[ctr];\r\n                ctr++;\r\n            }\r\n            for (i = 0; i < arrlen; i++) {\r\n                res[ctr] = 0x5F;\r\n                ctr++;\r\n                for (uint x = 0; x < elemArray[i].length; x++) {\r\n                    // if there's a bug with larger strings, this may be the culprit\r\n                    if (x % 23 == 0) {\r\n                        uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\r\n                        elemcborlen += 0x40;\r\n                        uint lctr = ctr;\r\n                        while (byte(elemcborlen).length > ctr - lctr) {\r\n                            res[ctr] = byte(elemcborlen)[ctr - lctr];\r\n                            ctr++;\r\n                        }\r\n                    }\r\n                    res[ctr] = elemArray[i][x];\r\n                    ctr++;\r\n                }\r\n                res[ctr] = 0xFF;\r\n                ctr++;\r\n            }\r\n            return res;\r\n        }\r\n\r\n    function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) {\r\n        uint minLength = length + toOffset;\r\n\r\n        assert (to.length >= minLength);\r\n\r\n        // NOTE: the offset 32 is added to skip the `size` field of both bytes variables\r\n        uint i = 32 + fromOffset;\r\n        uint j = 32 + toOffset;\r\n\r\n        while (i < (32 + fromOffset + length)) {\r\n            assembly {\r\n                let tmp := mload(add(from, i))\r\n                mstore(add(to, j), tmp)\r\n            }\r\n            i += 32;\r\n            j += 32;\r\n        }\r\n\r\n        return to;\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\ncontract Cascading is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    struct Cascade {\r\n        address cascade;\r\n        uint16 percentage;\r\n    }\r\n\r\n    uint public totalCascadingPercentage;\r\n    Cascade[] public cascades;    \r\n\r\n    /// @dev Adds an address and associated percentage for transfer.\r\n    /// @param newAddress The new address\r\n    function addCascade(address newAddress, uint newPercentage) public onlyOwner {\r\n        cascades.push(Cascade(newAddress, uint16(newPercentage)));\r\n        totalCascadingPercentage += newPercentage;\r\n    }\r\n\r\n    /// @dev Deletes an address and associated percentage at the given index.\r\n    /// @param index The index of the cascade to be deleted.\r\n    function deleteCascade(uint index) public onlyOwner {\r\n        require(index < cascades.length);\r\n        \r\n        totalCascadingPercentage -= cascades[index].percentage;\r\n\r\n        cascades[index] = cascades[cascades.length - 1];\r\n        delete cascades[cascades.length - 1];\r\n        cascades.length--;\r\n    }\r\n\r\n    /// @dev Transfers the cascade values to the assigned addresses\r\n    /// @param totalJackpot the total jackpot amount\r\n    function transferCascades(uint totalJackpot) internal {\r\n        for (uint i = 0; i < cascades.length; i++) {\r\n            uint cascadeTotal = getCascadeTotal(cascades[i].percentage, totalJackpot);\r\n\r\n            // Should be safe from re-entry given gas limit of 2300.\r\n            cascades[i].cascade.transfer(cascadeTotal);\r\n        }\r\n    }\r\n\r\n    /// @dev Gets the cascade total for the given percentage\r\n    /// @param percentage the percentage of the total pot as a uint\r\n    /// @param totalJackpot the total jackpot amount\r\n    /// @return the total amount the percentage represents\r\n    function getCascadeTotal(uint percentage, uint totalJackpot) internal pure returns(uint) {\r\n        return totalJackpot.mul(percentage).div(100);        \r\n    }\r\n   \r\n    /// A utility method to calculate the total after cascades have been applied.\r\n    /// @param totalJackpot the total jackpot amount\r\n    /// @return the total amount after the cascades have been applied\r\n    function getTotalAfterCascades(uint totalJackpot) internal constant returns (uint) {\r\n        uint cascadeTotal = getCascadeTotal(totalCascadingPercentage, totalJackpot);\r\n        return totalJackpot.sub(cascadeTotal);\r\n    }\r\n}\r\n\r\ncontract SafeWinner is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => uint) public pendingPayments;\r\n    address[] public pendingWinners;\r\n    uint public totalPendingPayments;\r\n\r\n    event WinnerWithdrew(address indexed winner, uint amount, uint block);\r\n\r\n    /// @dev records the winner so that a transfer or withdraw can occur at \r\n    /// a later date.\r\n    function addPendingWinner(address winner, uint amount) internal {\r\n        pendingPayments[winner] = pendingPayments[winner].add(amount);\r\n        totalPendingPayments = totalPendingPayments.add(amount);\r\n        pendingWinners.push(winner);\r\n    }\r\n\r\n    /// @dev allows a winner to withdraw their rightful jackpot.\r\n    function withdrawWinnings() public {\r\n        address winner = msg.sender;\r\n        uint payment = pendingPayments[winner];\r\n\r\n        require(payment > 0);\r\n        require(this.balance >= payment);\r\n\r\n        transferPending(winner, payment);\r\n    }\r\n\r\n    /// @dev Retries all pending winners\r\n    function retryWinners() public onlyOwner {\r\n        for (uint i = 0; i < pendingWinners.length; i++) {\r\n            retryWinner(i);\r\n        }\r\n\r\n        pendingWinners.length = 0;\r\n    }\r\n\r\n    function retryWinner(uint index) public onlyOwner {\r\n        address winner = pendingWinners[index];\r\n        uint payment = pendingPayments[winner];\r\n        require(this.balance >= payment);\r\n        if (payment != 0) {\r\n            transferPending(winner, payment);\r\n        }\r\n    }\r\n\r\n    function transferPending(address winner, uint256 payment) internal {\r\n        totalPendingPayments = totalPendingPayments.sub(payment);\r\n        pendingPayments[winner] = 0;\r\n        winner.transfer(payment);        \r\n        WinnerWithdrew(winner, payment, block.number);\r\n    }\r\n}\r\n\r\ncontract Raffle is Ownable, Priceable, SafeWinner, Cascading {\r\n  using SafeMath for uint256;\r\n  using OraclizeLib for OraclizeLib.OraclizeData;\r\n\r\n  enum RaffleState { Active, InActive, PendingInActive }\r\n  enum RandomSource { RandomDS, Qrng }\r\n\r\n  struct Jackpot {\r\n    uint absoluteTotal;\r\n    uint feeTotal;\r\n    uint cascadeTotal;\r\n    uint winnerTotal;\r\n  }\r\n\r\n  struct TicketHolder {\r\n    address purchaser;\r\n    uint16 count;\r\n    uint80 runningTotal;\r\n  }\r\n  \r\n  // public\r\n  RaffleState public raffleState;\r\n  RandomSource public randomSource;\r\n  uint public ticketPrice;\r\n  uint public gameId;\r\n  uint public fee;\r\n  \r\n\r\n  // internal\r\n  TicketHolder[] internal ticketHolders;\r\n  uint internal randomBytes;\r\n  uint internal randomQueried;\r\n  uint internal callbackGas;\r\n  RewardDistributable internal rewardDistributor;\r\n\r\n  // oraclize\r\n  OraclizeLib.OraclizeData oraclizeData;\r\n\r\n  // events\r\n  event TicketPurchased(address indexed ticketPurchaser, uint indexed id, uint numTickets, uint totalCost, uint block);\r\n  event WinnerSelected(address indexed winner, uint indexed id, uint winnings, uint block);\r\n  event RandomProofFailed(bytes32 queryId, uint indexed id, uint block);\r\n\r\n  function Raffle(uint _ticketPrice, address _rewardDistributor) public {\r\n    ticketPrice = _ticketPrice;\r\n    raffleState = RaffleState.Active;\r\n    callbackGas = 200000;\r\n    randomBytes = 8;\r\n    fee = 5 finney;\r\n    rewardDistributor = RewardDistributable(_rewardDistributor);\r\n    oraclizeData.initializeOraclize();\r\n    randomSource = RandomSource.Qrng;\r\n    resetRaffle();\r\n  }\r\n\r\n  /// @dev Returns whether the game is active.\r\n  function isActive() public constant returns (bool) {\r\n    return raffleState == RaffleState.Active || raffleState == RaffleState.PendingInActive;\r\n  }\r\n  \r\n  /// @dev Fallback function to purchase a single ticket.\r\n  function () public payable {\r\n  }\r\n   \r\n  /// @dev Gets the projected jackpot.\r\n  /// @return The projected jackpot amount.\r\n  function getProjectedJackpot() public constant returns (uint) {\r\n    uint jackpot = getAbsoluteProjectedJackpot();\r\n    Jackpot memory totals = getJackpotTotals(jackpot);\r\n    return totals.winnerTotal;\r\n  }\r\n\r\n  /// @dev Gets the actual jackpot\r\n  /// @return The actual jackpot amount.\r\n  function getJackpot() public constant returns (uint) {\r\n    uint jackpot = getAbsoluteJackpot();\r\n    Jackpot memory totals = getJackpotTotals(jackpot);\r\n    return totals.winnerTotal;\r\n  }\r\n\r\n  /// @dev Gets the ticket holder count\r\n  /// @return The total ticket holder count\r\n  function getTicketHolderCount() public constant returns (uint) {\r\n    return getTotalTickets();\r\n  }\r\n\r\n  /// @dev Updates the ticket price.\r\n  function updateTicketPrice(uint updatedPrice) public onlyOwner {\r\n    require(raffleState == RaffleState.InActive);\r\n    require(updatedPrice > 0);\r\n    ticketPrice = updatedPrice;\r\n  }\r\n\r\n  /// @dev Updates the ticket price.\r\n  function updateFee(uint updatedFee) public onlyOwner {\r\n    require(updatedFee > 0);\r\n    fee = updatedFee;\r\n  }\r\n\r\n  /// @dev Deactivates the raffle after the next game.\r\n  function deactivate() public onlyOwner {\r\n    require(raffleState == RaffleState.Active);\r\n    raffleState = ticketHolders.length == 0 ? RaffleState.InActive : RaffleState.PendingInActive;\r\n  }\r\n\r\n  /// @dev Activates the raffle, if inactivated.\r\n  function activate() public onlyOwner {\r\n    require(raffleState == RaffleState.InActive);\r\n    raffleState = RaffleState.Active;\r\n  }\r\n\r\n  /// The oraclize callback function.\r\n  function __callback(bytes32 queryId, string result, bytes proof) public {\r\n    require(msg.sender == oraclizeData.oraclize_cbAddress());\r\n    \r\n    // We only expect this for this callback\r\n    if (oraclizeData.oraclize_randomDS_proofVerify__returnCode(queryId, result, proof) != 0) {\r\n      RandomProofFailed(queryId, gameId, now);\r\n      randomQueried = 0;\r\n      return;\r\n    }\r\n\r\n    __callback(queryId, result);\r\n  }\r\n\r\n  /// The oraclize callback function.\r\n  function __callback(bytes32 queryId, string result) public {\r\n    require(msg.sender == oraclizeData.oraclize_cbAddress());\r\n    \r\n    // Guard against the case where oraclize is triggered, or calls back multiple times.\r\n    if (!shouldChooseWinner()) {\r\n      return;\r\n    }\r\n\r\n    uint maxRange = 2**(8*randomBytes); \r\n    uint randomNumber = uint(keccak256(result)) % maxRange; \r\n    winnerSelected(randomNumber);\r\n  }\r\n\r\n  /// @dev An administrative function to allow in case the proof fails or \r\n  /// a random winner needs to be chosen again.\r\n  function forceChooseRandomWinner() public onlyOwner {\r\n    require(raffleState != RaffleState.InActive);\r\n    executeRandomQuery();\r\n  }\r\n\r\n  /// @dev Forces a refund for all participants and deactivates the contract\r\n  /// This offers a full refund, so it will be up to the owner to ensure a full balance.\r\n  function forceRefund() public onlyOwner {\r\n    raffleState = RaffleState.PendingInActive;\r\n\r\n    uint total = getTotalTickets() * ticketPrice;\r\n    require(this.balance > total);\r\n\r\n    for (uint i = 0; i < ticketHolders.length; i++) {\r\n      TicketHolder storage holder = ticketHolders[i];\r\n      holder.purchaser.transfer(uint256(holder.count).mul(ticketPrice));\r\n    }\r\n\r\n    resetRaffle();\r\n  }\r\n\r\n  /// @dev Destroys the current contract and moves all ETH back to  \r\n  function updateRewardDistributor(address newRewardDistributor) public onlyOwner {\r\n    rewardDistributor = RewardDistributable(newRewardDistributor);\r\n  }\r\n\r\n  /// @dev Destroys the current contract and moves all ETH back to\r\n  /// owner. Only can occur after state has been set to inactive.\r\n  function destroy() public onlyOwner {\r\n    require(raffleState == RaffleState.InActive);\r\n    selfdestruct(owner);\r\n  }\r\n\r\n  /// Gets the projected jackpot prior to any fees\r\n  /// @return The projected jackpot prior to any fees\r\n  function getAbsoluteProjectedJackpot() internal constant returns (uint);\r\n\r\n  /// Gets the actual jackpot prior to any fees\r\n  /// @return The actual jackpot amount prior to any fees.\r\n  function getAbsoluteJackpot() internal constant returns (uint);\r\n  \r\n  /// An abstract function which determines whether a it is appropriate to choose a winner.\r\n  /// @return True if it is appropriate to choose the winner, false otherwise.\r\n  function shouldChooseWinner() internal returns (bool);\r\n\r\n  function executeRandomQuery() internal {\r\n    if (randomSource == RandomSource.RandomDS) {\r\n      oraclizeData.oraclize_newRandomDSQuery(0, randomBytes, callbackGas);\r\n    }\r\n    else {\r\n      oraclizeData.oraclize_query(\"URL\",\"json(https://qrng.anu.edu.au/API/jsonI.php?length=1&type=hex16&size=32).data[0]\", callbackGas);\r\n    }\r\n  }\r\n\r\n  /// Chooses the winner at random.\r\n  function chooseWinner() internal {\r\n    // We build in a buffer of 20 blocks.  Approx 1 block per 15 secs ~ 5 mins\r\n    // the last time random was queried, we'll execute again.\r\n    if (randomQueried < (block.number.sub(20))) {\r\n      executeRandomQuery();\r\n      randomQueried = block.number;\r\n    }\r\n  }\r\n\r\n  /// Internal function for when a winner is chosen.\r\n  function winnerSelected(uint randomNumber) internal {\r\n    TicketHolder memory winner = getWinningTicketHolder(randomNumber);\r\n    uint jackpot = getAbsoluteJackpot();\r\n    Jackpot memory jackpotTotals = getJackpotTotals(jackpot);\r\n\r\n    WinnerSelected(winner.purchaser, gameId, jackpotTotals.winnerTotal, now);    \r\n    transferJackpot(winner.purchaser, jackpotTotals.winnerTotal);\r\n    transferCascades(jackpotTotals.absoluteTotal);\r\n    resetRaffle();\r\n  }\r\n\r\n  function getWinningTicketHolder(uint randomNumber) internal view returns(TicketHolder) {\r\n    assert(ticketHolders.length > 0);\r\n    uint totalTickets = getTotalTickets();\r\n    uint winner = (randomNumber % totalTickets) + 1;\r\n\r\n    uint min = 0;\r\n    uint max = ticketHolders.length-1;\r\n    while (max > min) {\r\n        uint mid = (max + min + 1) / 2;\r\n        if (ticketHolders[mid].runningTotal >= winner &&\r\n         (ticketHolders[mid].runningTotal-ticketHolders[mid].count) < winner) {\r\n           return ticketHolders[mid];\r\n        }\r\n\r\n        if (ticketHolders[mid].runningTotal <= winner) {\r\n            min = mid;\r\n        } else {\r\n            max = mid-1;\r\n        }\r\n    }\r\n\r\n    return ticketHolders[min];\r\n  }\r\n\r\n  /// Transfers the jackpot to the winner triggering the event\r\n  function transferJackpot(address winner, uint jackpot) internal returns(uint) {\r\n    // We explicitly do not use transfer here because if the \r\n    // the call fails, the oraclize contract will not retry.\r\n    bool sendSuccessful = winner.send(jackpot);\r\n    if (!sendSuccessful) {\r\n      addPendingWinner(winner, jackpot);\r\n    }\r\n\r\n    return jackpot;\r\n  }\r\n\r\n  /// Resets the raffle game state.\r\n  function resetRaffle() internal {\r\n    if (raffleState == RaffleState.PendingInActive) {\r\n      raffleState = RaffleState.InActive;\r\n    }\r\n    ticketHolders.length = 0;\r\n    gameId = block.number;\r\n    randomQueried = 0;\r\n  }\r\n\r\n  /// Gets the jackpot after fees\r\n  function getJackpotTotals(uint jackpot) internal constant returns(Jackpot) {\r\n    if (jackpot < fee) {\r\n      return Jackpot(0, 0, 0, 0);\r\n    }\r\n\r\n    uint cascadeTotal = getCascadeTotal(totalCascadingPercentage, jackpot);\r\n    return Jackpot(jackpot, fee, cascadeTotal, jackpot.sub(fee).sub(cascadeTotal));\r\n  }\r\n\r\n  function updateRandomSource(uint newRandomSource) public onlyOwner {\r\n    if (newRandomSource == 1) {\r\n      randomSource = RandomSource.RandomDS;\r\n    } else {\r\n      randomSource = RandomSource.Qrng;\r\n    }\r\n\r\n    setProof();\r\n  }\r\n\r\n\r\n  function setProof() internal {\r\n      if (randomSource == RandomSource.RandomDS) {\r\n        // proofType_Ledger = 0x30;\r\n        oraclizeData.oraclize_setProof(0x30);\r\n      }\r\n      else {\r\n        oraclizeData.oraclize_setProof(0x00);\r\n      }\r\n  }\r\n\r\n  function getTotalTickets() internal view returns(uint) {\r\n    return ticketHolders.length == 0 ? 0 : ticketHolders[ticketHolders.length-1].runningTotal;\r\n  }\r\n\r\n  function updateOraclizeGas(uint newCallbackGas, uint customGasPrice) public onlyOwner {\r\n    callbackGas = newCallbackGas;\r\n    updateCustomGasPrice(customGasPrice);\r\n  }\r\n\r\n  function updateCustomGasPrice(uint customGasPrice) internal {\r\n    oraclizeData.oraclize_setCustomGasPrice(customGasPrice);\r\n  }\r\n}\r\n\r\ncontract CountBasedRaffle is Raffle {\r\n  \r\n  uint public drawTicketCount;\r\n\r\n  /// @dev Constructor for conventional raffle\r\n  /// @param _ticketPrice The ticket price.\r\n  /// @param _drawTicketCount The number of tickets for a draw to take place.\r\n  function CountBasedRaffle(uint _ticketPrice, uint _drawTicketCount, address _rewardDistributor) Raffle(_ticketPrice, _rewardDistributor) public {\r\n    drawTicketCount = _drawTicketCount;\r\n  }\r\n\r\n  /// @dev Gets the projected jackpot.\r\n  function getAbsoluteProjectedJackpot() internal constant returns (uint) {\r\n    uint totalTicketCount = getTotalTickets();\r\n    uint ticketCount = drawTicketCount > totalTicketCount ? drawTicketCount : totalTicketCount;\r\n    return ticketCount.mul(ticketPrice); \r\n  }\r\n\r\n  /// @dev Gets the actual jackpot\r\n  function getAbsoluteJackpot() internal constant returns (uint) {\r\n    if (ticketHolders.length == 0) {\r\n      return 0;\r\n    }\r\n\r\n    return this.balance.sub(totalPendingPayments);\r\n  }\r\n\r\n    /* @dev Purchases tickets to the raffle.\r\n  * @param numTickets Number of tickets to purchase.\r\n  * @param referrer The address of the referrer.\r\n  */\r\n  function purchaseTicket(uint numTickets, address referrer) public payable costsExactly(numTickets.mul(ticketPrice)) {\r\n    require(raffleState != RaffleState.InActive);\r\n    require(numTickets < drawTicketCount);\r\n\r\n    // Add the address to the ticketHolders.\r\n    uint totalTickets = getTotalTickets();\r\n    ticketHolders.push(TicketHolder(msg.sender, uint16(numTickets), uint80(totalTickets.add(numTickets))));\r\n    TicketPurchased(msg.sender, gameId, numTickets, ticketPrice.mul(numTickets), now);\r\n    if (rewardDistributor != address(0)) {\r\n      rewardDistributor.registerReferral(msg.sender, referrer);\r\n      rewardDistributor.transferRewards(msg.sender, msg.value, gameId);\r\n    }\r\n\r\n    if (shouldChooseWinner()) {\r\n      chooseWinner();\r\n    }\r\n  }\r\n  \r\n  /// An abstract function which determines whether a it is appropriate to choose a winner.\r\n  /// @return True if it is appropriate to choose the winner, false otherwise.\r\n  function shouldChooseWinner() internal returns (bool) {\r\n    return getTotalTickets() >= drawTicketCount;\r\n  }\r\n}\r\n\r\ncontract BronzeRaffle is CountBasedRaffle {\r\n\r\n  /// @dev Constructor for conventional raffle\r\n  /// Should total jackpot of ~ 0.4 ETH\r\n  function BronzeRaffle(address _rewardDistributor) CountBasedRaffle(20 finney, 15, _rewardDistributor) public {\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"randomSource\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"activate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ticketPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"queryId\",\"type\":\"bytes32\"},{\"name\":\"result\",\"type\":\"string\"}],\"name\":\"__callback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getProjectedJackpot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"queryId\",\"type\":\"bytes32\"},{\"name\":\"result\",\"type\":\"string\"},{\"name\":\"proof\",\"type\":\"bytes\"}],\"name\":\"__callback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalCascadingPercentage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"numTickets\",\"type\":\"uint256\"},{\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"purchaseTicket\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newRewardDistributor\",\"type\":\"address\"}],\"name\":\"updateRewardDistributor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deactivate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"raffleState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"cascades\",\"outputs\":[{\"name\":\"cascade\",\"type\":\"address\"},{\"name\":\"percentage\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTicketHolderCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pendingPayments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"forceChooseRandomWinner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"drawTicketCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalPendingPayments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"updatedFee\",\"type\":\"uint256\"}],\"name\":\"updateFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pendingWinners\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getJackpot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"retryWinners\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"forceRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"deleteCascade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawWinnings\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gameId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newRandomSource\",\"type\":\"uint256\"}],\"name\":\"updateRandomSource\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAddress\",\"type\":\"address\"},{\"name\":\"newPercentage\",\"type\":\"uint256\"}],\"name\":\"addCascade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"updatedPrice\",\"type\":\"uint256\"}],\"name\":\"updateTicketPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"retryWinner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCallbackGas\",\"type\":\"uint256\"},{\"name\":\"customGasPrice\",\"type\":\"uint256\"}],\"name\":\"updateOraclizeGas\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_rewardDistributor\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"ticketPurchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"numTickets\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalCost\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"block\",\"type\":\"uint256\"}],\"name\":\"TicketPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winnings\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"block\",\"type\":\"uint256\"}],\"name\":\"WinnerSelected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"queryId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"block\",\"type\":\"uint256\"}],\"name\":\"RandomProofFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"block\",\"type\":\"uint256\"}],\"name\":\"WinnerWithdrew\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"BronzeRaffle","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000a3db4b373b39301f6e1fdf9167349636d693406b","Library":"OraclizeLib:e3e29e4e9c7cdb68ce73dd7bbe06fe395757a769","SwarmSource":"bzzr://d30eac14867b401db2a55436cbdfcb9f400da12f577c007cf49777a2bd1e7109"}]}