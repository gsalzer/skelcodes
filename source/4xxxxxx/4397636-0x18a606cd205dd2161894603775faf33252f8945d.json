{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.2;\r\n/*'pragma' indique au compileur dans quelle version de Solidity ce code est écrit */\r\ncontract storer {\r\n/*'contract' indique le début du contrat a proprement parler 'contract' est similaire\r\nà 'class' dans d'autres langages (class variables, inheritance, etc.)*/\r\naddress public owner;\r\nstring public log;\r\n/* 29979245621189875516790\r\nfunction storer() {\r\n    owner = msg.sender ;\r\n}\r\n/* 'storer' est une fonction un peu particulière, il s'agit du constructeur du contrat.\r\nCette fonction s'exécute une seule fois au moment de la création du contrat.\r\nLa création du contrat est une transaction et comme toute transaction elle est\r\nreprésentée en Solidity par \"msg\", \"msg.sender\" correspond  à l'adresse qui\r\német cette transaction.  \r\nA la création du contrat la variable owner reçoit l'adresse qui a déployé le\r\ncontrat */\r\nmodifier onlyOwner {\r\n        if (msg.sender != owner)\r\n            throw;\r\n        _;\r\n    }\r\n/* le 'modifier' permet de poser des conditions à l'exécution des fonctions.\r\nIci, 'onlyOwner' sera ajouté à la syntaxe des fonctions que l'on\r\nveut réserver au 'owner'. Le modifier teste la condion msg.sender != owner\r\nsi le requêteur de la fonction n'est pas le owner alors l'exécution\r\ns'interrompt, c'est le sens du 'throw'; s'il s'agit bien du owner alors\r\nla fonction s'exécute. Notez le '_' underscore après le test, il signifie\r\nà la fonction de continuer son exécution.*/    \r\nfunction store(string _log) onlyOwner() {\r\n    log = _log;\r\n}\r\n/*La fonction 'store' reçoit une chaîne de caractères qu'elle associe à une\r\nvariable d'état '_log'. Cette fonction n'est utilisable que par l'adresse qui\r\nest 'owner', si c'est bien cette adresse qui fait la requête alors la variable\r\n'log' devient '_log'.*/\r\nfunction kill() onlyOwner() {\r\n  selfdestruct(owner); }\r\n/* Cette dernière fonction permet de \"nettoyer\" la blockchain en supprimant le\r\ncontrat. Il est important de la faire figurer pour libérer de l'espace sur\r\nla blockchain mais aussi pour supprimer un contrat buggé. En précisant une\r\nadresse selfdestruct(address), tous les ethers stockés par le contrat y sont\r\nenvoyés. Attention si une transaction envoie des ethers à un contrat qui s'est\r\n\"selfdestruct\" ces ethers seront perdus*/\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_log\",\"type\":\"string\"}],\"name\":\"store\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"log\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"storer","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://9f60807d6430ce081f576e24914e28f06601a056eb9d9e151e41ce1fc993aa73"}]}