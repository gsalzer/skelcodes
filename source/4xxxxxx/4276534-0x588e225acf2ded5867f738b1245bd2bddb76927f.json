{"status":"1","message":"OK","result":[{"SourceCode":"// ----------------------------------------------------------------------------------------------\r\n// Developer Nechesov Andrey: Facebook.com/Nechesov   \r\n// Enjoy. (c) PRCR.org ICO Business Platform 2017. The PRCR Licence.\r\n// Eth address: 0x788C45Dd60aE4dBE5055b5Ac02384D5dc84677b0\r\n// ----------------------------------------------------------------------------------------------\r\n// ERC Token Standard #20 Interface\r\n// https://github.com/ethereum/EIPs/issues/20\r\n\r\npragma solidity ^0.4.16;    \r\n\r\n/**\r\n* Math operations with safety checks\r\n*/\r\n\r\nlibrary SafeMath {\r\n  function mul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint a, uint b) internal returns (uint) {\r\n    assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint c = a / b;\r\n    assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) {\r\n      throw;\r\n    }\r\n  }\r\n}\r\n\r\n  contract ERC20Interface {\r\n      // Get the total token supply\r\n      function totalSupply() constant returns (uint256 totalSupply);\r\n   \r\n      // Get the account balance of another account with address _owner\r\n      function balanceOf(address _owner) constant returns (uint256 balance);\r\n   \r\n      // Send _value amount of tokens to address _to\r\n      function transfer(address _to, uint256 _value) returns (bool success);\r\n   \r\n      // Send _value amount of tokens from address _from to address _to\r\n      function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n   \r\n      // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\r\n      // If this function is called again it overwrites the current allowance with _value.\r\n      // this function is required for some DEX functionality\r\n      function approve(address _spender, uint256 _value) returns (bool success);\r\n   \r\n      // Returns the amount which _spender is still allowed to withdraw from _owner\r\n      function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n   \r\n      // Triggered when tokens are transferred.\r\n      event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n   \r\n      // Triggered whenever approve(address _spender, uint256 _value) is called.\r\n      event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n  }  \r\n   \r\n  contract Bqt_Token is ERC20Interface {\r\n\r\n      string public constant symbol = \"BQT\";\r\n      string public constant name = \"BQT token\";\r\n      uint8 public constant decimals = 18; \r\n           \r\n      uint256 public constant maxTokens = 200*10**6*10**18; \r\n      uint256 public constant ownerSupply = maxTokens*51/100;\r\n      uint256 _totalSupply = ownerSupply;  \r\n\r\n      uint256 public constant token_price = 10**18*1/250; \r\n      uint256 public pre_ico_start = 1506729600;\r\n      uint256 public ico_start = 1512691200;\r\n      uint256 public ico_finish = 1518134400; \r\n      uint public constant minValuePre = 10**18*1/1000000; \r\n      uint public constant minValue = 10**18*1/1000000; \r\n      uint public constant maxValue = 3000*10**18;\r\n\r\n      uint8 public constant exchange_coefficient = 102;\r\n\r\n      using SafeMath for uint;\r\n      \r\n      // Owner of this contract\r\n      address public owner;\r\n   \r\n      // Balances for each account\r\n      mapping(address => uint256) balances;\r\n   \r\n      // Owner of account approves the transfer of an amount to another account\r\n      mapping(address => mapping (address => uint256)) allowed;\r\n\r\n      // Orders holders who wish sell tokens, save amount\r\n      mapping(address => uint256) public orders_sell_amount;\r\n\r\n      // Orders holders who wish sell tokens, save price\r\n      mapping(address => uint256) public orders_sell_price;\r\n\r\n      //orders list\r\n      address[] public orders_sell_list;\r\n\r\n      // Triggered on set SELL order\r\n      event Order_sell(address indexed _owner, uint256 _max_amount, uint256 _price);      \r\n\r\n      // Triggered on execute SELL order\r\n      event Order_execute(address indexed _from, address indexed _to, uint256 _amount, uint256 _price);      \r\n   \r\n      // Functions with this modifier can only be executed by the owner\r\n      modifier onlyOwner() {\r\n          if (msg.sender != owner) {\r\n              throw;\r\n          }\r\n          _;\r\n      }      \r\n   \r\n      // Constructor\r\n      function Bqt_Token() {\r\n          //owner = msg.sender;\r\n          owner = 0x2eee6534bfa5512ded7f700d8d26e88c1688c854;\r\n          balances[owner] = ownerSupply;\r\n      }\r\n      \r\n      //default function      \r\n      function() payable {        \r\n          tokens_buy();        \r\n      }\r\n      \r\n      function totalSupply() constant returns (uint256 totalSupply) {\r\n          totalSupply = _totalSupply;\r\n      }\r\n\r\n      //Withdraw money from contract balance to owner\r\n      function withdraw(uint256 _amount) onlyOwner returns (bool result) {\r\n          uint256 balance;\r\n          balance = this.balance;\r\n          if(_amount > 0) balance = _amount;\r\n          owner.send(balance);\r\n          return true;\r\n      }\r\n\r\n      //Change ico_start date\r\n      function change_ico_start(uint256 _ico_start) onlyOwner returns (bool result) {\r\n          ico_start = _ico_start;\r\n          return true;\r\n      }\r\n\r\n      //Change ico_finish date\r\n      function change_ico_finish(uint256 _ico_finish) onlyOwner returns (bool result) {\r\n          ico_finish = _ico_finish;\r\n          return true;\r\n      }\r\n   \r\n      // Total tokens on user address\r\n      function balanceOf(address _owner) constant returns (uint256 balance) {\r\n          return balances[_owner];\r\n      }\r\n   \r\n      // Transfer the balance from owner's account to another account\r\n      function transfer(address _to, uint256 _amount) returns (bool success) {          \r\n\r\n          if (balances[msg.sender] >= _amount \r\n              && _amount > 0\r\n              && balances[_to] + _amount > balances[_to]) {\r\n              balances[msg.sender] -= _amount;\r\n              balances[_to] += _amount;\r\n              Transfer(msg.sender, _to, _amount);\r\n              return true;\r\n          } else {\r\n              return false;\r\n          }\r\n      }\r\n   \r\n      // Send _value amount of tokens from address _from to address _to\r\n      // The transferFrom method is used for a withdraw workflow, allowing contracts to send\r\n      // tokens on your behalf, for example to \"deposit\" to a contract address and/or to charge\r\n      // fees in sub-currencies; the command should fail unless the _from account has\r\n      // deliberately authorized the sender of the message via some mechanism; we propose\r\n      // these standardized APIs for approval:\r\n      function transferFrom(\r\n          address _from,\r\n          address _to,\r\n          uint256 _amount\r\n     ) returns (bool success) {         \r\n\r\n         if (balances[_from] >= _amount\r\n             && allowed[_from][msg.sender] >= _amount\r\n             && _amount > 0\r\n             && balances[_to] + _amount > balances[_to]) {\r\n             balances[_from] -= _amount;\r\n             allowed[_from][msg.sender] -= _amount;\r\n             balances[_to] += _amount;\r\n             Transfer(_from, _to, _amount);\r\n             return true;\r\n         } else {\r\n             return false;\r\n         }\r\n     }\r\n  \r\n     // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\r\n     // If this function is called again it overwrites the current allowance with _value.\r\n     function approve(address _spender, uint256 _amount) returns (bool success) {\r\n         allowed[msg.sender][_spender] = _amount;\r\n         Approval(msg.sender, _spender, _amount);\r\n         return true;\r\n     }\r\n    \r\n     //Return param, how many tokens can send _spender from _owner account  \r\n     function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n         return allowed[_owner][_spender];\r\n     } \r\n\r\n      /**\r\n      * Buy tokens on pre-ico and ico with bonuses on time boundaries\r\n      */\r\n      function tokens_buy() payable returns (bool) { \r\n\r\n        uint256 tnow = now;\r\n        \r\n        //if(tnow < pre_ico_start) throw;\r\n        if(tnow > ico_finish) throw;\r\n        if(_totalSupply >= maxTokens) throw;\r\n        if(!(msg.value >= token_price)) throw;\r\n        if(!(msg.value >= minValue)) throw;\r\n        if(msg.value > maxValue) throw;\r\n\r\n        uint tokens_buy = (msg.value*10**18).div(token_price);\r\n        uint tokens_buy_total;\r\n\r\n        if(!(tokens_buy > 0)) throw;   \r\n        \r\n        //Bonus for total tokens amount for all contract\r\n        uint b1 = 0;\r\n        //Time bonus on Pre-ICO && ICO\r\n        uint b2 = 0;\r\n        //Individual bonus for tokens amount\r\n        uint b3 = 0;\r\n\r\n        if(_totalSupply <= 5*10**6*10**18) {\r\n          b1 = tokens_buy*30/100;\r\n        }\r\n        if((5*10**6*10**18 < _totalSupply)&&(_totalSupply <= 10*10**6*10**18)) {\r\n          b1 = tokens_buy*25/100;\r\n        }\r\n        if((10*10**6*10**18 < _totalSupply)&&(_totalSupply <= 15*10**6*10**18)) {\r\n          b1 = tokens_buy*20/100;\r\n        }\r\n        if((15*10**6*10**18 < _totalSupply)&&(_totalSupply <= 20*10**6*10**18)) {\r\n          b1 = tokens_buy*15/100;\r\n        }\r\n        if((20*10**6*10**18 < _totalSupply)&&(_totalSupply <= 25*10**6*10**18)) {\r\n          b1 = tokens_buy*10/100;\r\n        }\r\n        if(25*10**6*10**18 <= _totalSupply) {\r\n          b1 = tokens_buy*5/100;\r\n        }        \r\n\r\n        if(tnow < ico_start) {\r\n          b2 = tokens_buy*50/100;\r\n        }\r\n        if((ico_start + 86400*0 <= tnow)&&(tnow < ico_start + 86400*5)){\r\n          b2 = tokens_buy*10/100;\r\n        } \r\n        if((ico_start + 86400*5 <= tnow)&&(tnow < ico_start + 86400*10)){\r\n          b2 = tokens_buy*8/100;        \r\n        } \r\n        if((ico_start + 86400*10 <= tnow)&&(tnow < ico_start + 86400*20)){\r\n          b2 = tokens_buy*6/100;        \r\n        } \r\n        if((ico_start + 86400*20 <= tnow)&&(tnow < ico_start + 86400*30)){\r\n          b2 = tokens_buy*4/100;        \r\n        } \r\n        if(ico_start + 86400*30 <= tnow){\r\n          b2 = tokens_buy*2/100;        \r\n        }\r\n        \r\n\r\n        if((1000*10**18 <= tokens_buy)&&(5000*10**18 <= tokens_buy)) {\r\n          b3 = tokens_buy*5/100;\r\n        }\r\n        if((5001*10**18 <= tokens_buy)&&(10000*10**18 < tokens_buy)) {\r\n          b3 = tokens_buy*10/100;\r\n        }\r\n        if((10001*10**18 <= tokens_buy)&&(15000*10**18 < tokens_buy)) {\r\n          b3 = tokens_buy*15/100;\r\n        }\r\n        if((15001*10**18 <= tokens_buy)&&(20000*10**18 < tokens_buy)) {\r\n          b3 = tokens_buy*20/100;\r\n        }\r\n        if(20001*10**18 <= tokens_buy) {\r\n          b3 = tokens_buy*25/100;\r\n        }\r\n\r\n        tokens_buy_total = tokens_buy.add(b1);\r\n        tokens_buy_total = tokens_buy_total.add(b2);\r\n        tokens_buy_total = tokens_buy_total.add(b3);        \r\n\r\n        if(_totalSupply.add(tokens_buy_total) > maxTokens) throw;\r\n        _totalSupply = _totalSupply.add(tokens_buy_total);\r\n        balances[msg.sender] = balances[msg.sender].add(tokens_buy_total);         \r\n\r\n        return true;\r\n      }\r\n      \r\n      /**\r\n      * Get total SELL orders\r\n      */      \r\n      function orders_sell_total () constant returns (uint256) {\r\n        return orders_sell_list.length;\r\n      } \r\n\r\n      /**\r\n      * Get how many tokens can buy from this SELL order\r\n      */\r\n      function get_orders_sell_amount(address _from) constant returns(uint) {\r\n\r\n        uint _amount_max = 0;\r\n\r\n        if(!(orders_sell_amount[_from] > 0)) return _amount_max;\r\n\r\n        if(balanceOf(_from) > 0) _amount_max = balanceOf(_from);\r\n        if(orders_sell_amount[_from] < _amount_max) _amount_max = orders_sell_amount[_from];\r\n\r\n        return _amount_max;\r\n      }\r\n\r\n      /**\r\n      * User create SELL order.  \r\n      */\r\n      function order_sell(uint256 _max_amount, uint256 _price) returns (bool) {\r\n\r\n        if(!(_max_amount > 0)) throw;\r\n        if(!(_price > 0)) throw;        \r\n\r\n        orders_sell_amount[msg.sender] = _max_amount;\r\n        orders_sell_price[msg.sender] = (_price*exchange_coefficient).div(100);\r\n        orders_sell_list.push(msg.sender);        \r\n\r\n        Order_sell(msg.sender, _max_amount, orders_sell_price[msg.sender]);      \r\n\r\n        return true;\r\n      }\r\n\r\n      /**\r\n      * Order Buy tokens - it's order search sell order from user _from and if all ok, send token and money \r\n      */\r\n      function order_buy(address _from, uint256 _max_price) payable returns (bool) {\r\n        \r\n        if(!(msg.value > 0)) throw;\r\n        if(!(_max_price > 0)) throw;        \r\n        if(!(orders_sell_amount[_from] > 0)) throw;\r\n        if(!(orders_sell_price[_from] > 0)) throw; \r\n        if(orders_sell_price[_from] > _max_price) throw;\r\n\r\n        uint _amount = (msg.value*10**18).div(orders_sell_price[_from]);\r\n        uint _amount_from = get_orders_sell_amount(_from);\r\n\r\n        if(_amount > _amount_from) _amount = _amount_from;        \r\n        if(!(_amount > 0)) throw;        \r\n\r\n        uint _total_money = (orders_sell_price[_from]*_amount).div(10**18);\r\n        if(_total_money > msg.value) throw;\r\n\r\n        uint _seller_money = (_total_money*100).div(exchange_coefficient);\r\n        uint _buyer_money = msg.value - _total_money;\r\n\r\n        if(_seller_money > msg.value) throw;\r\n        if(_seller_money + _buyer_money > msg.value) throw;\r\n\r\n        if(_seller_money > 0) _from.send(_seller_money);\r\n        if(_buyer_money > 0) msg.sender.send(_buyer_money);\r\n\r\n        orders_sell_amount[_from] -= _amount;        \r\n        balances[_from] -= _amount;\r\n        balances[msg.sender] += _amount; \r\n\r\n        Order_execute(_from, msg.sender, _amount, orders_sell_price[_from]);\r\n\r\n      }\r\n      \r\n }","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ico_finish\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"orders_sell_list\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"result\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"orders_sell_amount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pre_ico_start\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"orders_sell_price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"tokens_buy\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_max_price\",\"type\":\"uint256\"}],\"name\":\"order_buy\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ico_start\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token_price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ico_start\",\"type\":\"uint256\"}],\"name\":\"change_ico_start\",\"outputs\":[{\"name\":\"result\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minValuePre\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchange_coefficient\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_max_amount\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"order_sell\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ico_finish\",\"type\":\"uint256\"}],\"name\":\"change_ico_finish\",\"outputs\":[{\"name\":\"result\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"get_orders_sell_amount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"orders_sell_total\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_max_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"Order_sell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"Order_execute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"Bqt_Token","CompilerVersion":"v0.4.16+commit.d7661dd9","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://fee4e151d865524a39e92e935ed628f2767fddd2f8f411ff7a2f465c356955fa"}]}