{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\ncontract owned { \r\n    address public owner;\r\n    \r\n    function owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) onlyOwner {\r\n        owner = newOwner;\r\n    }\r\n}\r\ncontract doftManaged { \r\n    address public doftManager;\r\n    \r\n    function doftManaged() {\r\n        doftManager = msg.sender;\r\n    }\r\n\r\n    modifier onlyDoftManager {\r\n        require(msg.sender == doftManager);\r\n        _;\r\n    }\r\n\r\n    function transferDoftManagment(address newDoftManager) onlyDoftManager {\r\n        doftManager = newDoftManager;\r\n\t//coins for mining should be transferred after transferring of doftManagment\r\n    }\r\n}\r\n\r\ncontract ERC20 {\r\n    function totalSupply() constant returns (uint totalSupply);\r\n    function balanceOf(address _owner) constant returns (uint balance);\r\n    function transfer(address _to, uint _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool success);\r\n    function approve(address _spender, uint _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\ncontract BasicToken is ERC20 { \r\n    uint256 _totalSupply;\r\n    \r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint totalSupply){\r\n\ttotalSupply = _totalSupply;\r\n    }\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint balance){\r\n        return balanceOf[_owner];\r\n    }\r\n\r\n    /* Internal transfer, only can be called by this contract */\r\n    function _transfer(address _from, address _to, uint _value) internal {\r\n        require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead\r\n        require (balanceOf[_from] > _value);                // Check if the sender has enough\r\n        require (balanceOf[_to] + _value > balanceOf[_to]); // Check for overflows\r\n\r\n        balanceOf[_from] -= _value;                         // Subtract from the sender\r\n        balanceOf[_to] += _value;                           // Add the same to the recipient\r\n        Transfer(_from, _to, _value);\r\n    }\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint _value) returns (bool success) {\r\n        _transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool success) {\r\n        require (_value <= allowance[_from][msg.sender]);     // Check allowance\r\n        allowance[_from][msg.sender] -= _value;\r\n        _transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint _value) returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n\t    Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n    \r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n        return allowance[_owner][_spender];\r\n    }\r\n}\r\n\r\ncontract Doftcoin is BasicToken, owned, doftManaged { \r\n    string public name; \r\n    string public symbol; \r\n    uint256 public decimals; \r\n    uint256 public sellPrice;\r\n    uint256 public buyPrice;\r\n    uint256 public miningStorage;\r\n    string public version; \r\n\r\n    event Mine(address target, uint256 minedAmount);\r\n\r\n    function Doftcoin() {\r\n        decimals = 18;\r\n        _totalSupply = 5000000 * (10 ** decimals);  // Update total supply\r\n        miningStorage = _totalSupply / 2;\r\n        name = \"Doftcoin\";                                   // Set the name for display purposes\r\n        symbol = \"DFC\";                               // Set the symbol for display purposes\r\n\r\n        balanceOf[msg.sender] = _totalSupply;              // Give the creator all initial tokens\r\n\tversion = \"1.0\";\r\n    }\r\n\r\n    /// @notice Create `_mintedAmount` tokens and send it to `_target`\r\n    /// @param _target Address to receive the tokens\r\n    /// @param _mintedAmount the amount of tokens it will receive\r\n    function mintToken(address _target, uint256 _mintedAmount) onlyOwner {\r\n        require (_target != 0x0);\r\n\r\n\t//ownership will be given to ICO after creation\r\n        balanceOf[_target] += _mintedAmount;\r\n        _totalSupply += _mintedAmount;\r\n        Transfer(0, this, _mintedAmount);\r\n        Transfer(this, _target, _mintedAmount);\r\n    }\r\n\r\n    /// @notice Buy tokens from contract by sending ether\r\n    function buy() payable {\r\n\t    require(buyPrice > 0);\r\n        uint amount = msg.value / buyPrice;               // calculates the amount\r\n        _transfer(this, msg.sender, amount);              // makes the transfers\r\n    }\r\n\r\n    /// @notice Sell `_amount` tokens to contract\r\n    /// @param _amount Amount of tokens to be sold\r\n    function sell(uint256 _amount) {\r\n\t    require(sellPrice > 0);\r\n        require(this.balance >= _amount * sellPrice);      // checks if the contract has enough ether to buy\r\n        _transfer(msg.sender, this, _amount);              // makes the transfers\r\n        msg.sender.transfer(_amount * sellPrice);          // sends ether to the seller. It's important to do this last to avoid recursion attacks\r\n    }\r\n\r\n    /// @notice Allow users to buy tokens for `_newBuyPrice` eth and sell tokens for `_newSellPrice` eth\r\n    /// @param _newSellPrice Price the users can sell to the contract\r\n    /// @param _newBuyPrice Price users can buy from the contract\r\n    function setPrices(uint256 _newSellPrice, uint256 _newBuyPrice) onlyDoftManager {\r\n        sellPrice = _newSellPrice;\r\n        buyPrice = _newBuyPrice;\r\n    }\r\n\r\n    /// @notice Send `_minedAmount` to `_target` as a reward for mining\r\n    /// @param _target The address of the recipient\r\n    /// @param _minedAmount The amount of reward tokens\r\n    function mine(address _target, uint256 _minedAmount) onlyDoftManager {\r\n\trequire (_minedAmount > 0);\r\n        require (_target != 0x0);\r\n        require (miningStorage - _minedAmount >= 0);\r\n        require (balanceOf[doftManager] >= _minedAmount);                // Check if the sender has enough\r\n        require (balanceOf[_target] + _minedAmount > balanceOf[_target]); // Check for overflows\r\n\r\n\t    balanceOf[doftManager] -= _minedAmount;\r\n\t    balanceOf[_target] += _minedAmount;\r\n\t    miningStorage -= _minedAmount;\r\n\r\n\t    Mine(_target, _minedAmount);\r\n    } \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_newSellPrice\",\"type\":\"uint256\"},{\"name\":\"_newBuyPrice\",\"type\":\"uint256\"}],\"name\":\"setPrices\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newDoftManager\",\"type\":\"address\"}],\"name\":\"transferDoftManagment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"},{\"name\":\"_mintedAmount\",\"type\":\"uint256\"}],\"name\":\"mintToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"doftManager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"miningStorage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"},{\"name\":\"_minedAmount\",\"type\":\"uint256\"}],\"name\":\"mine\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"minedAmount\",\"type\":\"uint256\"}],\"name\":\"Mine\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"Doftcoin","CompilerVersion":"v0.4.17+commit.bdeb9e52","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://663099fd3927452a8f11f2a0f74fb744e243f20025a651de4a39689b9624aed1"}]}