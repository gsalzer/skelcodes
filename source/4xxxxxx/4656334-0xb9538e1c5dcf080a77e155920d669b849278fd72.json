{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.15;\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n}\r\n\r\n\r\ncontract Contactable is Ownable{\r\n\r\n    string public contactInformation;\r\n\r\n    /**\r\n     * @dev Allows the owner to set a string with their contact information.\r\n     * @param info The contact information to attach to the contract.\r\n     */\r\n    function setContactInformation(string info) onlyOwner public {\r\n         contactInformation = info;\r\n     }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public constant returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract LockableToken is ERC20 {\r\n    function addToTimeLockedList(address addr) external returns (bool);\r\n}\r\n\r\ncontract PricingStrategy {\r\n\r\n    using SafeMath for uint;\r\n\r\n    uint[6] public limits;\r\n    uint[6] public rates;\r\n\r\n    function PricingStrategy(\r\n        uint[6] _limits,\r\n        uint[6] _rates\r\n    ) public \r\n    {\r\n        require(_limits.length == _rates.length);\r\n        \r\n        limits = _limits;\r\n        rates = _rates;\r\n    }\r\n\r\n    /** Interface declaration. */\r\n    function isPricingStrategy() public constant returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    /** Calculate the current price for buy in amount. */\r\n    function calculateTokenAmount(uint weiAmount, uint tokensSold) public constant returns (uint tokenAmount) {\r\n        uint rate = 0;\r\n\r\n        for (uint8 i = 0; i < limits.length; i++) {\r\n            if (tokensSold >= limits[i]) {\r\n                rate = rates[i];\r\n            }\r\n        }\r\n\r\n        return weiAmount.mul(rate);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Preico\r\n * @dev Preico is a contract for managing a token crowdsale.\r\n * Preicos have a start and end timestamps, where investors can make\r\n * token purchases and the crowdsale will assign them tokens based\r\n * on a token per ETH rate. Funds collected are forwarded to a wallet\r\n * as they arrive.\r\n */\r\ncontract Preico is Pausable, Contactable {\r\n    using SafeMath for uint;\r\n  \r\n    // The token being sold\r\n    LockableToken public token;\r\n  \r\n    // start and end timestamps where investments are allowed (both inclusive)\r\n    uint public startTime;\r\n    uint public endTime;\r\n  \r\n    // address where funds are collected\r\n    address public wallet;\r\n  \r\n    // the contract, which determine how many token units a buyer gets per wei\r\n    PricingStrategy public pricingStrategy;\r\n  \r\n    // amount of raised money in wei\r\n    uint public weiRaised;\r\n\r\n    // amount of tokens that was sold on the crowdsale\r\n    uint public tokensSold;\r\n\r\n    // maximum amount of wei in total, that can be invested\r\n    uint public weiMaximumGoal;\r\n\r\n    // if weiMinimumGoal will not be reached till endTime, investors will be able to refund ETH\r\n    uint public weiMinimumGoal;\r\n\r\n    // How many distinct addresses have invested\r\n    uint public investorCount;\r\n\r\n    // how much wei we have returned back to the contract after a failed crowdfund\r\n    uint public loadedRefund;\r\n\r\n    // how much wei we have given back to investors\r\n    uint public weiRefunded;\r\n\r\n    //How much ETH each address has invested to this crowdsale\r\n    mapping (address => uint) public investedAmountOf;\r\n\r\n    // Addresses that are allowed to invest before ICO offical opens\r\n    mapping (address => bool) public earlyParticipantWhitelist;\r\n  \r\n    /**\r\n     * event for token purchase logging\r\n     * @param purchaser who paid for the tokens\r\n     * @param beneficiary who got the tokens\r\n     * @param value weis paid for purchase\r\n     * @param tokenAmount amount of tokens purchased\r\n     */\r\n    event TokenPurchase(\r\n        address indexed purchaser,\r\n        address indexed beneficiary,\r\n        uint value,\r\n        uint tokenAmount\r\n    );\r\n\r\n    // a refund was processed for an investor\r\n    event Refund(address investor, uint weiAmount);\r\n\r\n    function Preico(\r\n        uint _startTime,\r\n        uint _endTime,\r\n        PricingStrategy _pricingStrategy,\r\n        LockableToken _token,\r\n        address _wallet,\r\n        uint _weiMaximumGoal,\r\n        uint _weiMinimumGoal,\r\n        uint _tokensSold\r\n    ) {\r\n        require(_startTime >= now);\r\n        require(_endTime >= _startTime);\r\n        require(_pricingStrategy.isPricingStrategy());\r\n        require(address(_token) != 0x0);\r\n        require(_wallet != 0x0);\r\n        require(_weiMaximumGoal > 0);\r\n        require(_weiMinimumGoal > 0);\r\n\r\n        startTime = _startTime;\r\n        endTime = _endTime;\r\n        pricingStrategy = _pricingStrategy;\r\n        token = _token;\r\n        wallet = _wallet;\r\n        weiMaximumGoal = _weiMaximumGoal;\r\n        weiMinimumGoal = _weiMinimumGoal;\r\n        tokensSold = _tokensSold;\r\n}\r\n\r\n    // fallback function can be used to buy tokens\r\n    function () external payable {\r\n        buyTokens(msg.sender);\r\n    }\r\n\r\n    // low level token purchase function\r\n    function buyTokens(address beneficiary) public whenNotPaused payable returns (bool) {\r\n        require(beneficiary != 0x0);\r\n        require(validPurchase());\r\n    \r\n        uint weiAmount = msg.value;\r\n    \r\n        // calculate token amount to be created\r\n        uint tokenAmount = pricingStrategy.calculateTokenAmount(weiAmount, tokensSold);\r\n    \r\n        // update state\r\n        if (investedAmountOf[beneficiary] == 0) {\r\n            // A new investor\r\n            investorCount++;\r\n        }\r\n        investedAmountOf[beneficiary] = investedAmountOf[beneficiary].add(weiAmount);\r\n        weiRaised = weiRaised.add(weiAmount);\r\n        tokensSold = tokensSold.add(tokenAmount);\r\n    \r\n        token.transferFrom(owner, beneficiary, tokenAmount);\r\n        TokenPurchase(msg.sender, beneficiary, weiAmount, tokenAmount);\r\n\r\n        wallet.transfer(msg.value);\r\n\r\n        return true;\r\n    }\r\n\r\n    // return true if the transaction can buy tokens\r\n    function validPurchase() internal constant returns (bool) {\r\n        bool withinPeriod = (now >= startTime || earlyParticipantWhitelist[msg.sender]) && now <= endTime;\r\n        bool nonZeroPurchase = msg.value != 0;\r\n        bool withinCap = weiRaised.add(msg.value) <= weiMaximumGoal;\r\n\r\n        return withinPeriod && nonZeroPurchase && withinCap;\r\n    }\r\n\r\n    // return true if crowdsale event has ended\r\n    function hasEnded() external constant returns (bool) {\r\n        bool capReached = weiRaised >= weiMaximumGoal;\r\n        bool afterEndTime = now > endTime;\r\n        \r\n        return capReached || afterEndTime;\r\n    }\r\n\r\n    // get the amount of unsold tokens allocated to this contract;\r\n    function getWeiLeft() external constant returns (uint) {\r\n        return weiMaximumGoal - weiRaised;\r\n    }\r\n\r\n    // return true if the crowdsale has raised enough money to be a successful.\r\n    function isMinimumGoalReached() public constant returns (bool) {\r\n        return weiRaised >= weiMinimumGoal;\r\n    }\r\n    \r\n    /**\r\n     * allows to add and exclude addresses from earlyParticipantWhitelist for owner\r\n     * @param isWhitelisted is true for adding address into whitelist, false - to exclude\r\n     */\r\n    function editEarlyParicipantWhitelist(address addr, bool isWhitelisted) external onlyOwner returns (bool) {\r\n        earlyParticipantWhitelist[addr] = isWhitelisted;\r\n        return true;\r\n    }\r\n\r\n    // allows to update tokens rate for owner\r\n    function setPricingStrategy(PricingStrategy _pricingStrategy) external onlyOwner returns (bool) {\r\n        pricingStrategy = _pricingStrategy;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * Allow load refunds back on the contract for the refunding.\r\n    *\r\n    * The team can transfer the funds back on the smart contract in the case the minimum goal was not reached..\r\n    */\r\n    function loadRefund() external payable {\r\n        require(msg.value > 0);\r\n        require(!isMinimumGoalReached());\r\n        \r\n        loadedRefund = loadedRefund.add(msg.value);\r\n    }\r\n\r\n    /**\r\n    * Investors can claim refund.\r\n    *\r\n    * Note that any refunds from proxy buyers should be handled separately,\r\n    * and not through this contract.\r\n    */\r\n    function refund() external {\r\n        require(!isMinimumGoalReached() && loadedRefund > 0);\r\n        uint256 weiValue = investedAmountOf[msg.sender];\r\n        require(weiValue > 0);\r\n        \r\n        investedAmountOf[msg.sender] = 0;\r\n        weiRefunded = weiRefunded.add(weiValue);\r\n        Refund(msg.sender, weiValue);\r\n        msg.sender.transfer(weiValue);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"isWhitelisted\",\"type\":\"bool\"}],\"name\":\"editEarlyParicipantWhitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWeiLeft\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"investedAmountOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contactInformation\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pricingStrategy\",\"type\":\"address\"}],\"name\":\"setPricingStrategy\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiMaximumGoal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRefunded\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pricingStrategy\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"loadedRefund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isMinimumGoalReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiMinimumGoal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"loadRefund\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"info\",\"type\":\"string\"}],\"name\":\"setContactInformation\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"earlyParticipantWhitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investorCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasEnded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"},{\"name\":\"_pricingStrategy\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_weiMaximumGoal\",\"type\":\"uint256\"},{\"name\":\"_weiMinimumGoal\",\"type\":\"uint256\"},{\"name\":\"_tokensSold\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Preico","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000005a216060000000000000000000000000000000000000000000000000000000005a3fb2e00000000000000000000000003e978168a6d0c58df641c5826581bc022af417ef000000000000000000000000f3e014fe81267870624132ef3a646b8e83853a960000000000000000000000007d5669ee2b8e9935849fae55b74d05184f9e3867000000000000000000000000000000000000000000000055ec4b2e4f62240000000000000000000000000000000000000000000000000055ec4b2e4f6224000000000000000000000000000000000000000000000000357727f2f596376e2000","Library":"","SwarmSource":"bzzr://6f8776b763c447395f7a9e5e5f4065cb4edaaf93d656ee89b84977d93137336f"}]}