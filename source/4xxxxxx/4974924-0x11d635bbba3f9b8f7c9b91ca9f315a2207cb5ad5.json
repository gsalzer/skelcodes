{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n * Library easily handles the cases of overflow as well as underflow. \r\n * Also ensures that balance does nto get naegative\r\n */\r\nlibrary SafeMath {\r\n\t// multiplies two values safely and returns result\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tif (a == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tuint256 c = a * b;\r\n\t\tassert(c / a == b);\r\n\t\treturn c;\r\n\t}\r\n\r\n\t// devides two values safely and returns result\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\r\n\t\tuint256 c = a / b;\r\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\t\treturn c;\r\n\t}\r\n\r\n\t// subtracts two values safely and returns result\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tassert(b <= a);\r\n\t\treturn a - b;\r\n\t}\r\n\r\n\t// adds two values safely and returns result\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tuint256 c = a + b;\r\n\t\tassert(c >= a);\r\n\t\treturn c;\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n\taddress public owner;\r\n\r\n\t// Event to log whenever the ownership is tranferred\r\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n\t/**\r\n\t * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n\t * account.\r\n\t */\r\n\tfunction Ownable() public {\r\n\t\towner = msg.sender;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @dev Throws if called by any account other than the owner.\r\n\t */\r\n\tmodifier onlyOwner() {\r\n\t\trequire(msg.sender == owner);\r\n\t\t_;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n\t * @param newOwner The address to transfer ownership to.\r\n\t */\r\n\tfunction transferOwnership(address newOwner) public onlyOwner {\r\n\t\trequire(newOwner != address(0));\r\n\t\tOwnershipTransferred(owner, newOwner);\r\n\t\towner = newOwner;\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * @title Timestamped\r\n * @dev The Timestamped contract has sets dummy timestamp for method calls\r\n */\r\ncontract Timestamped is Ownable {\r\n\tuint256 public ts = 0;\r\n\tuint256 public plus = 0;\r\n\r\n\tfunction getBlockTime() public view returns (uint256) {\r\n\t\tif(ts > 0) {\r\n\t\t\treturn ts + plus;\r\n\t\t} else {\r\n\t\t\treturn block.timestamp + plus; \r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n\tuint256 public totalSupply;\r\n\tfunction balanceOf(address who) public view returns (uint256);\r\n\tfunction transfer(address to, uint256 value) public returns (bool);\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value, bytes data);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n\tfunction allowance(address owner, address spender) public view returns (uint256);\r\n\tfunction transferFrom(address from, address to, uint256 value) public returns (bool);\r\n\tfunction approve(address spender, uint256 value) public returns (bool);\r\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n\tusing SafeMath for uint256;\r\n\r\n\tmapping(address => uint256) balances;\r\n\r\n\t/**\r\n\t* @dev transfer token for a specified address\r\n\t* @param _to The address to transfer to.\r\n\t* @param _value The amount to be transferred.\r\n\t*/\r\n\tfunction transfer(address _to, uint256 _value) public returns (bool) {\r\n\t\trequire(_to != address(0));\r\n\t\trequire(_value <= balances[msg.sender]);\r\n\r\n\t\t// SafeMath.sub will throw if there is not enough balance.\r\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\r\n\t\tbalances[_to] = balances[_to].add(_value);\r\n\r\n\t\tbytes memory empty;\r\n\t\tTransfer(msg.sender, _to, _value, empty);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Gets the balance of the specified address.\r\n\t* @param _owner The address to query the the balance of.\r\n\t* @return An uint256 representing the amount owned by the passed address.\r\n\t*/\r\n\tfunction balanceOf(address _owner) public view returns (uint256 balance) {\r\n\t\treturn balances[_owner];\r\n\t}\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n\t// tracks the allowance of address. \r\n\tmapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n\t/**\r\n\t * @dev Transfer tokens from one address to another\r\n\t * @param _from address The address which you want to send tokens from\r\n\t * @param _to address The address which you want to transfer to\r\n\t * @param _value uint256 the amount of tokens to be transferred\r\n\t */\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n\t\trequire(_to != address(0));\r\n\t\trequire(_value <= balances[_from]);\r\n\t\trequire(_value <= allowed[_from][msg.sender]);\r\n\r\n\t\tbalances[_from] = balances[_from].sub(_value);\r\n\t\tbalances[_to] = balances[_to].add(_value);\r\n\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n\r\n\t\tbytes memory empty;\r\n\t\tTransfer(_from, _to, _value, empty);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n\t *\r\n\t * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n\t * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n\t * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n\t * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n\t * @param _spender The address which will spend the funds.\r\n\t * @param _value The amount of tokens to be spent.\r\n\t */\r\n\tfunction approve(address _spender, uint256 _value) public returns (bool) {\r\n\t\tallowed[msg.sender][_spender] = _value;\r\n\t\tApproval(msg.sender, _spender, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n\t * @param _owner address The address which owns the funds.\r\n\t * @param _spender address The address which will spend the funds.\r\n\t * @return A uint256 specifying the amount of tokens still available for the spender.\r\n\t */\r\n\tfunction allowance(address _owner, address _spender) public view returns (uint256) {\r\n\t\treturn allowed[_owner][_spender];\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n\t *\r\n\t * approve should be called when allowed[_spender] == 0. To increment\r\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\r\n\t * the first transaction is mined)\r\n\t * From MonolithDAO Token.sol\r\n\t * @param _spender The address which will spend the funds.\r\n\t * @param _addedValue The amount of tokens to increase the allowance by.\r\n\t */\r\n\tfunction increaseApproval(address _spender, uint256 _addedValue) public returns (bool) {\r\n\t\tallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n\t\tApproval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n\t *\r\n\t * approve should be called when allowed[_spender] == 0. To decrement\r\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\r\n\t * the first transaction is mined)\r\n\t * From MonolithDAO Token.sol\r\n\t * @param _spender The address which will spend the funds.\r\n\t * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n\t */\r\n\tfunction decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool) {\r\n\t\tuint256 oldValue = allowed[msg.sender][_spender];\r\n\t\tif (_subtractedValue > oldValue) {\r\n\t\t\tallowed[msg.sender][_spender] = 0;\r\n\t\t} else {\r\n\t\t\tallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n\t\t}\r\n\t\tApproval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n\t\treturn true;\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * @title ERC23Receiver interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/223\r\n */\r\ncontract ERC223Receiver {\r\n\t \r\n\tstruct TKN {\r\n\t\taddress sender;\r\n\t\tuint256 value;\r\n\t\tbytes data;\r\n\t\tbytes4 sig;\r\n\t}\r\n\t\r\n\t/**\r\n\t * @dev Fallback function. Our ICO contract should implement this contract to receve ERC23 compatible tokens.\r\n\t * ERC23 protocol checks if contract has implemented this fallback method or not. \r\n\t * If this method is not implemented then tokens are not sent.\r\n\t * This method is introduced to avoid loss of tokens \r\n\t *\r\n\t * @param _from The address which will transfer the tokens.\r\n\t * @param _value Amount of tokens received.\r\n\t * @param _data Data sent along with transfer request.\r\n\t */\r\n\tfunction tokenFallback(address _from, uint256 _value, bytes _data) public pure {\r\n\t\tTKN memory tkn;\r\n\t\ttkn.sender = _from;\r\n\t\ttkn.value = _value;\r\n\t\ttkn.data = _data;\r\n\t\t// uint32 u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24);\r\n\t\t// tkn.sig = bytes4(u);\r\n\t  \r\n\t\t/* tkn variable is analogue of msg variable of Ether transaction\r\n\t\t*  tkn.sender is person who initiated this token transaction   (analogue of msg.sender)\r\n\t\t*  tkn.value the number of tokens that were sent   (analogue of msg.value)\r\n\t\t*  tkn.data is data of token transaction   (analogue of msg.data)\r\n\t\t*  tkn.sig is 4 bytes signature of function\r\n\t\t*  if data of token transaction is a function execution\r\n\t\t*/\r\n\t}\r\n}\r\n\r\n/**\r\n * @title ERC23 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/223\r\n */\r\ncontract ERC223 {\r\n\tuint256 public totalSupply;\r\n\tfunction balanceOf(address who) public view returns (uint256);\r\n\tfunction transfer(address to, uint256 value) public returns (bool);\r\n\tfunction transfer(address to, uint256 value, bytes data) public returns (bool);\r\n\tfunction transfer(address to, uint256 value, bytes data, string custom_fallback) public returns (bool);\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value, bytes indexed data);\r\n}\r\n\r\n/**\r\n * @title Standard ERC223Token token\r\n *\r\n * @dev Implementation of the ERC23 token.\r\n * @dev https://github.com/ethereum/EIPs/issues/223\r\n */\r\n\r\ncontract ERC223Token is ERC223, StandardToken {\r\n\tusing SafeMath for uint256;\r\n\r\n\t/**\r\n\t * @dev Function that is called when a user or another contract wants to transfer funds .\r\n\t * This is method where you can supply fallback function name and that function will be triggered.\r\n\t * This method is added as part of ERC23 standard\r\n\t *\r\n\t * @param _to The address which will receive the tokens.\r\n\t * @param _value Amount of tokens received.\r\n\t * @param _data Data sent along with transfer request.\r\n\t * @param _custom_fallback Name of the method which should be called after transfer happens. If this method does not exists on contract then transaction will fail\r\n\t */\r\n\tfunction transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) public returns (bool success) {\r\n\t\t// check if receiving is contract\r\n\t\tif(isContract(_to)) {\r\n\t\t\t// validate the address and balance\r\n\t\t\trequire(_to != address(0));\r\n\t\t\trequire(_value <= balances[msg.sender]);\r\n\r\n\t\t\t// SafeMath.sub will throw if there is not enough balance.\r\n\t\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\r\n\t\t\tbalances[_to] = balances[_to].add(_value);\r\n\t\r\n\t\t\t// invoke custom fallback function\t\t\t\r\n\t\t\tassert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));\r\n\t\t\tTransfer(msg.sender, _to, _value, _data);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// receiver is not a contract so perform normal transfer to address\r\n\t\t\treturn transferToAddress(_to, _value, _data);\r\n\t\t}\r\n\t}\r\n  \r\n\r\n\t/**\r\n\t * @dev Function that is called when a user or another contract wants to transfer funds .\r\n\t * You can pass extra data which can be tracked in event.\r\n\t * This method is added as part of ERC23 standard\r\n\t *\r\n\t * @param _to The address which will receive the tokens.\r\n\t * @param _value Amount of tokens received.\r\n\t * @param _data Data sent along with transfer request.\r\n\t */\r\n\tfunction transfer(address _to, uint256 _value, bytes _data) public returns (bool success) {\r\n\t\t// check if receiver is contract address\r\n\t\tif(isContract(_to)) {\r\n\t\t\t// invoke transfer request to contract\r\n\t\t\treturn transferToContract(_to, _value, _data);\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// invoke transfer request to normal user wallet address\r\n\t\t\treturn transferToAddress(_to, _value, _data);\r\n\t\t}\r\n\t}\r\n  \r\n\t/**\r\n\t * @dev Standard function transfer similar to ERC20 transfer with no _data .\r\n\t * Added due to backwards compatibility reasons .\r\n\t *\r\n\t * @param _to The address which will receive the tokens.\r\n\t * @param _value Amount of tokens received.\r\n\t */\r\n\tfunction transfer(address _to, uint256 _value) public returns (bool success) {\r\n\t\t//standard function transfer similar to ERC20 transfer with no _data\r\n\t\t//added due to backwards compatibility reasons\r\n\t\tbytes memory empty;\r\n\r\n\t\t// check if receiver is contract address\r\n\t\tif(isContract(_to)) {\r\n\t\t\t// invoke transfer request to contract\r\n\t\t\treturn transferToContract(_to, _value, empty);\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// invoke transfer request to normal user wallet address\r\n\t\t\treturn transferToAddress(_to, _value, empty);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev assemble the given address bytecode. If bytecode exists then the _addr is a contract.\r\n\t *\r\n\t * @param _addr The address which need to be checked if contract address or wallet address\r\n\t */\r\n\tfunction isContract(address _addr) private view returns (bool is_contract) {\r\n\t\tuint256 length;\r\n\t\tassembly {\r\n\t\t\t//retrieve the size of the code on target address, this needs assembly\r\n\t\t\tlength := extcodesize(_addr)\r\n\t\t}\r\n\t\treturn (length > 0);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Function that is called when transaction target is an address. This is private method.\r\n\t *\r\n\t * @param _to The address which will receive the tokens.\r\n\t * @param _value Amount of tokens received.\r\n\t * @param _data Data sent along with transfer request.\r\n\t */\r\n\tfunction transferToAddress(address _to, uint256 _value, bytes _data) private returns (bool success) {\r\n\t\t// validate the address and balance\r\n\t\trequire(_to != address(0));\r\n\t\trequire(_value <= balances[msg.sender]);\r\n\r\n\t\t// SafeMath.sub will throw if there is not enough balance.\r\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\r\n\t\tbalances[_to] = balances[_to].add(_value);\r\n\r\n\t\t// Log the transfer event\r\n\t\tTransfer(msg.sender, _to, _value, _data);\r\n\t\treturn true;\r\n\t}\r\n  \r\n\t/**\r\n\t * @dev Function that is called when transaction target is a contract. This is private method.\r\n\t *\r\n\t * @param _to The address which will receive the tokens.\r\n\t * @param _value Amount of tokens received.\r\n\t * @param _data Data sent along with transfer request.\r\n\t */\r\n\tfunction transferToContract(address _to, uint256 _value, bytes _data) private returns (bool success) {\r\n\t\t// validate the address and balance\r\n\t\trequire(_to != address(0));\r\n\t\trequire(_value <= balances[msg.sender]);\r\n\r\n\t\t// SafeMath.sub will throw if there is not enough balance.\r\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\r\n\t\tbalances[_to] = balances[_to].add(_value);\r\n\r\n\t\t// call fallback function of contract\r\n\t\tERC223Receiver receiver = ERC223Receiver(_to);\r\n\t\treceiver.tokenFallback(msg.sender, _value, _data);\r\n\t\t\r\n\t\t// Log the transfer event\r\n\t\tTransfer(msg.sender, _to, _value, _data);\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\n/**\r\n* @title dHealthToken\r\n* @dev Very simple ERC23 Token example, where all tokens are pre-assigned to the creator.\r\n*/\r\ncontract dHealthToken is ERC223Token, Ownable {\r\n\r\n\tstring public constant name = \"dHealth\";\r\n\tstring public constant symbol = \"dHt\";\r\n\tuint256 public constant decimals = 18;\r\n\r\n\tuint256 constant INITIAL_SUPPLY = 500000000 * 1E18;\r\n\t\r\n\t/**\r\n\t* @dev Constructor that gives msg.sender all of existing tokens.\r\n\t*/\r\n\tfunction dHealthToken() public {\r\n\t\ttotalSupply = INITIAL_SUPPLY;\r\n\t\tbalances[msg.sender] = INITIAL_SUPPLY;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev if ether is sent to this address, send it back.\r\n\t*/\r\n\tfunction() public payable {\r\n\t\trevert();\r\n\t}\r\n}\r\n\r\n/**\r\n * @title dHealthTokenDistributor\r\n * @dev The Distributor contract has an list of team member addresses and their share, \r\n * and provides method which can be called to distribute available smart contract balance across users.\r\n */\r\ncontract dHealthTokenDistributor is Ownable, Timestamped {\r\n\tusing SafeMath for uint256;\r\n\r\n\t// The token being sold, this holds reference to main token contract\r\n\tdHealthToken public token;\r\n\r\n\t// token vesting contract addresses\r\n\taddress public communityContract;\r\n\taddress public foundersContract;\r\n\taddress public technicalContract;\r\n\taddress public managementContract;\r\n\r\n\t// token vesting contract amounts\r\n\tuint256 public communityAmount;\r\n\tuint256 public foundersAmount;\r\n\tuint256 public technicalAmount;\r\n\tuint256 public managementAmount;\r\n\r\n\t/**\r\n\t* @dev Constructor that initializes team and share\r\n\t*/\r\n\tfunction dHealthTokenDistributor(address _token, address _communityContract, address _foundersContract, address _technicalContract, address _managementContract) public {\r\n\t\t// set token\r\n\t\ttoken = dHealthToken(_token);\r\n\r\n\t\t// initialize contract addresses\r\n\t\tcommunityContract = _communityContract;\r\n\t\tfoundersContract = _foundersContract;\r\n\t\ttechnicalContract = _technicalContract;\r\n\t\tmanagementContract = _managementContract;\r\n\r\n\t\t// initialize precentage share\r\n\t\tcommunityAmount = 10000000 * 1E18;\r\n\t\tfoundersAmount = 15000000 * 1E18;\r\n\t\ttechnicalAmount = 55000000 * 1E18;\r\n\t\tmanagementAmount = 60000000 * 1E18;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev distribute funds.\r\n\t*/\t\r\n\tfunction distribute() onlyOwner public payable {\r\n\t\tbytes memory empty;\r\n\r\n\t\t// distribute funds to community \t\t\r\n\t\ttoken.transfer(communityContract, communityAmount, empty);\r\n\r\n\t\t// distribute funds to founders \t\t\r\n\t\ttoken.transfer(foundersContract, foundersAmount, empty);\r\n\r\n\t\t// distribute funds to technical \t\t\r\n\t\ttoken.transfer(technicalContract, technicalAmount, empty);\r\n\r\n\t\t// distribute funds to management \t\t\r\n\t\ttoken.transfer(managementContract, managementAmount, empty);\r\n\t}\r\n}\r\n\r\n/**\r\n * @title dHealthEtherDistributor\r\n * @dev The Distributor contract has an list of team member addresses and their share, \r\n * and provides method which can be called to distribute available smart contract balance across users.\r\n */\r\ncontract dHealthEtherDistributor is Ownable, Timestamped {\r\n\tusing SafeMath for uint256;\r\n\r\n\taddress public projectContract;\t\r\n\taddress public technologyContract;\t\r\n\taddress public founderContract;\t\r\n\r\n\tuint256 public projectShare;\r\n\tuint256 public technologyShare;\r\n\tuint256 public founderShare;\r\n\r\n\t/**\r\n\t* @dev Constructor that initializes team and share\r\n\t*/\r\n\tfunction dHealthEtherDistributor(address _projectContract, address _technologyContract, address _founderContract) public {\r\n\r\n\t\t// initialize contract addresses\r\n\t\tprojectContract = _projectContract;\t\r\n\t\ttechnologyContract = _technologyContract;\t\r\n\t\tfounderContract = _founderContract;\t\r\n\r\n\t\t// initialize precentage share\r\n\t\tprojectShare = 72;\r\n\t\ttechnologyShare = 18;\r\n\t\tfounderShare = 10;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev distribute funds.\r\n\t*/\t\r\n\tfunction distribute() onlyOwner public payable {\r\n\t\tuint256 balance = this.balance;\r\n\t\t\r\n\t\t// distribute funds to founders \t\t\r\n\t\tuint256 founderPart = balance.mul(founderShare).div(100);\r\n\t\tif(founderPart > 0) {\r\n\t\t\tfounderContract.transfer(founderPart);\r\n\t\t}\r\n\r\n\t\t// distribute funds to technology \t\t\r\n\t\tuint256 technologyPart = balance.mul(technologyShare).div(100);\r\n\t\tif(technologyPart > 0) {\r\n\t\t\ttechnologyContract.transfer(technologyPart);\r\n\t\t}\r\n\r\n\t\t// distribute left balance to project\r\n\t\tuint256 projectPart = this.balance;\r\n\t\tif(projectPart > 0) {\r\n\t\t\tprojectContract.transfer(projectPart);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n* @title dHealthTokenIncentive\r\n* @dev This is token incentive contract it receives tokens and holds it for certain period of time\r\n*/\r\ncontract dHealthTokenIncentive is dHealthTokenDistributor, ERC223Receiver {\r\n\tusing SafeMath for uint256;\r\n\r\n\t// The token being sold, this holds reference to main token contract\r\n\tdHealthToken public token;\r\n\r\n\t// amount of token on hold\r\n\tuint256 public maxTokenForHold = 140000000 * 1E18;\r\n\r\n\t// contract timeout \r\n\tuint256 public contractTimeout = 1555286400; // Monday, 15 April 2019 00:00:00\r\n\r\n\t/**\r\n\t* @dev Constructor that initializes vesting contract with contract addresses in parameter\r\n\t*/\r\n\tfunction dHealthTokenIncentive(address _token, address _communityContract, address _foundersContract, address _technicalContract, address _managementContract) \r\n\t\tdHealthTokenDistributor(_token, _communityContract, _foundersContract, _technicalContract, _managementContract)\r\n\t\tpublic {\r\n\t\t// set token\r\n\t\ttoken = dHealthToken(_token);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Method called by owner of contract to withdraw all tokens after timeout has reached\r\n\t*/\r\n\tfunction withdraw() onlyOwner public {\r\n\t\trequire(contractTimeout <= getBlockTime());\r\n\t\t\r\n\t\t// send remaining tokens back to owner.\r\n\t\tuint256 tokens = token.balanceOf(this); \r\n\t\tbytes memory empty;\r\n\t\ttoken.transfer(owner, tokens, empty);\r\n\t}\r\n}\r\n\r\n/**\r\n* @title dHealthTokenGrowth\r\n* @dev This is token growth contract it receives tokens and holds it for certain period of time\r\n*/\r\ncontract dHealthTokenGrowth is Ownable, ERC223Receiver, Timestamped {\r\n\tusing SafeMath for uint256;\r\n\r\n\t// The token being sold, this holds reference to main token contract\r\n\tdHealthToken public token;\r\n\r\n\t// amount of token on hold\r\n\tuint256 public maxTokenForHold = 180000000 * 1E18;\r\n\r\n\t// exchanges wallet address\r\n\taddress public exchangesWallet;\r\n\tuint256 public exchangesTokens = 45000000 * 1E18;\r\n\tuint256 public exchangesLockEndingAt = 1523750400; // Sunday, 15 April 2018 00:00:00\r\n\tbool public exchangesStatus = false;\r\n\r\n\t// countries wallet address\r\n\taddress public countriesWallet;\r\n\tuint256 public countriesTokens = 45000000 * 1E18;\r\n\tuint256 public countriesLockEndingAt = 1525132800; // Tuesday, 1 May 2018 00:00:00\r\n\tbool public countriesStatus = false;\r\n\r\n\t// acquisitions wallet address\r\n\taddress public acquisitionsWallet;\r\n\tuint256 public acquisitionsTokens = 45000000 * 1E18;\r\n\tuint256 public acquisitionsLockEndingAt = 1526342400; // Tuesday, 15 May 2018 00:00:00\r\n\tbool public acquisitionsStatus = false;\r\n\r\n\t// coindrops wallet address\r\n\taddress public coindropsWallet;\r\n\tuint256 public coindropsTokens = 45000000 * 1E18;\r\n\tuint256 public coindropsLockEndingAt = 1527811200; // Friday, 1 June 2018 00:00:00\r\n\tbool public coindropsStatus = false;\r\n\r\n\t// contract timeout \r\n\tuint256 public contractTimeout = 1555286400; // Monday, 15 April 2019 00:00:00\r\n\r\n\t/**\r\n\t* @dev Constructor that initializes vesting contract with contract addresses in parameter\r\n\t*/\r\n\tfunction dHealthTokenGrowth(address _token, address _exchangesWallet, address _countriesWallet, address _acquisitionsWallet, address _coindropsWallet) public {\r\n\t\t// set token\r\n\t\ttoken = dHealthToken(_token);\r\n\r\n\t\t// setup wallet addresses\r\n\t\texchangesWallet = _exchangesWallet;\r\n\t\tcountriesWallet = _countriesWallet;\r\n\t\tacquisitionsWallet = _acquisitionsWallet;\r\n\t\tcoindropsWallet = _coindropsWallet;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Method called by anyone to withdraw funds to exchanges wallet after locking period\r\n\t*/\r\n\tfunction withdrawExchangesToken() public {\r\n\t\t// check if time has reached\r\n\t\trequire(exchangesLockEndingAt <= getBlockTime());\r\n\t\t// ensure that tokens are not already transferred\r\n\t\trequire(exchangesStatus == false);\r\n\t\t\r\n\t\t// transfer tokens to wallet and change status to prevent double transfer\t\t\r\n\t\tbytes memory empty;\r\n\t\ttoken.transfer(exchangesWallet, exchangesTokens, empty);\r\n\t\texchangesStatus = true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Method called by anyone to withdraw funds to countries wallet after locking period\r\n\t*/\r\n\tfunction withdrawCountriesToken() public {\r\n\t\t// check if time has reached\r\n\t\trequire(countriesLockEndingAt <= getBlockTime());\r\n\t\t// ensure that tokens are not already transferred\r\n\t\trequire(countriesStatus == false);\r\n\t\t\r\n\t\t// transfer tokens to wallet and change status to prevent double transfer\t\t\r\n\t\tbytes memory empty;\r\n\t\ttoken.transfer(countriesWallet, countriesTokens, empty);\r\n\t\tcountriesStatus = true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Method called by anyone to withdraw funds to acquisitions wallet after locking period\r\n\t*/\r\n\tfunction withdrawAcquisitionsToken() public {\r\n\t\t// check if time has reached\r\n\t\trequire(acquisitionsLockEndingAt <= getBlockTime());\r\n\t\t// ensure that tokens are not already transferred\r\n\t\trequire(acquisitionsStatus == false);\r\n\t\t\r\n\t\t// transfer tokens to wallet and change status to prevent double transfer\t\t\r\n\t\tbytes memory empty;\r\n\t\ttoken.transfer(acquisitionsWallet, acquisitionsTokens, empty);\r\n\t\tacquisitionsStatus = true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Method called by anyone to withdraw funds to coindrops wallet after locking period\r\n\t*/\r\n\tfunction withdrawCoindropsToken() public {\r\n\t\t// check if time has reached\r\n\t\trequire(coindropsLockEndingAt <= getBlockTime());\r\n\t\t// ensure that tokens are not already transferred\r\n\t\trequire(coindropsStatus == false);\r\n\t\t\r\n\t\t// transfer tokens to wallet and change status to prevent double transfer\t\t\r\n\t\tbytes memory empty;\r\n\t\ttoken.transfer(coindropsWallet, coindropsTokens, empty);\r\n\t\tcoindropsStatus = true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Method called by owner of contract to withdraw all tokens after timeout has reached\r\n\t*/\r\n\tfunction withdraw() onlyOwner public {\r\n\t\trequire(contractTimeout <= getBlockTime());\r\n\t\t\r\n\t\t// send remaining tokens back to owner.\r\n\t\tuint256 tokens = token.balanceOf(this); \r\n\t\tbytes memory empty;\r\n\t\ttoken.transfer(owner, tokens, empty);\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n* @title dHealthTokenSale\r\n* @dev This is ICO Contract. \r\n* This class accepts the token address as argument to talk with contract.\r\n* Once contract is deployed, funds are transferred to ICO smart contract address and then distributed with investor.\r\n* Sending funds to this ensures that no more than desired tokens are sold.\r\n*/\r\ncontract dHealthTokenSale is dHealthEtherDistributor, ERC223Receiver {\r\n\tusing SafeMath for uint256;\r\n\r\n\t// The token being sold, this holds reference to main token contract\r\n\tdHealthToken public token;\r\n\r\n\t// amount of token to be sold on sale\r\n\tuint256 public maxTokenForSale = 180000000 * 1E18;\r\n\r\n\t// timestamp when phase 1 starts\r\n\tuint256 public phase1StartingAt = 1516924800; // Friday, 26 January 2018 00:00:00\r\n\tuint256 public phase1EndingAt = 1518134399; // Thursday, 8 February 2018 23:59:59\r\n\tuint256 public phase1MaxTokenForSale = maxTokenForSale * 1 / 3;\r\n\tuint256 public phase1TokenPriceInEth = 0.0005 ether;\r\n\tuint256 public phase1TokenSold = 0;\r\n\r\n\t// timestamp when phase 2 starts\r\n\tuint256 public phase2StartingAt = 1518134400; // Friday, 9 February 2018 00:00:00\r\n\tuint256 public phase2EndingAt = 1519343999; // Thursday, 22 February 2018 23:59:59\r\n\tuint256 public phase2MaxTokenForSale = maxTokenForSale * 2 / 3;\r\n\tuint256 public phase2TokenPriceInEth = 0.000606060606 ether;\r\n\tuint256 public phase2TokenSold = 0;\r\n\r\n\t// timestamp when phase 3 starts\r\n\tuint256 public phase3StartingAt = 1519344000; // Friday, 23 February 2018 00:00:00\r\n\tuint256 public phase3EndingAt = 1520553599; // Thursday, 8 March 2018 23:59:59\r\n\tuint256 public phase3MaxTokenForSale = maxTokenForSale;\r\n\tuint256 public phase3TokenPriceInEth = 0.000769230769 ether;\r\n\tuint256 public phase3TokenSold = 0;\r\n\r\n\t// contract timeout to initiate left funds and token transfer\r\n\tuint256 public contractTimeout = 1520553600; // Friday, 9 March 2018 00:00:00\r\n\r\n\t// growth contract address\r\n\taddress public growthContract;\r\n\r\n\t// maximum ether invested per transaction\r\n\tuint256 public maxEthPerTransaction = 1000 ether;\r\n\r\n\t// minimum ether invested per transaction\r\n\tuint256 public minEthPerTransaction = 0.01 ether;\r\n\r\n\t// amount of token sold so far\r\n\tuint256 public totalTokenSold;\r\n\r\n\t// amount of ether raised in sale\r\n\tuint256 public totalEtherRaised;\r\n\r\n\t// ether raised per wallet\r\n\tmapping(address => uint256) public etherRaisedPerWallet;\r\n\r\n\t// is contract close and ended\r\n\tbool public isClose = false;\r\n\r\n\t// is contract paused\r\n\tbool public isPaused = false;\r\n\r\n\t// token purchsae event\r\n\tevent TokenPurchase(address indexed _purchaser, address indexed _beneficiary, uint256 _value, uint256 _amount, uint256 _timestamp);\r\n\r\n\t// manual transfer by admin for external purchase\r\n\tevent TransferManual(address indexed _from, address indexed _to, uint256 _value, string _message);\r\n\r\n\t/**\r\n\t* @dev Constructor that initializes token contract with token address in parameter\r\n\t*/\r\n\tfunction dHealthTokenSale(address _token, address _projectContract, address _technologyContract, address _founderContract, address _growthContract)\r\n\t\tdHealthEtherDistributor(_projectContract, _technologyContract, _founderContract)\r\n\t\tpublic {\r\n\t\t// set token\r\n\t\ttoken = dHealthToken(_token);\r\n\r\n\t\t// set growth contract address\r\n\t\tgrowthContract = _growthContract;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Function that validates if the purchase is valid by verifying the parameters\r\n\t *\r\n\t * @param value Amount of ethers sent\r\n\t * @param amount Total number of tokens user is trying to buy.\r\n\t *\r\n\t * @return checks various conditions and returns the bool result indicating validity.\r\n\t */\r\n\tfunction validate(uint256 value, uint256 amount) internal constant returns (bool) {\r\n\t\t// check if timestamp and amount is falling in the range\r\n\t\tbool validTimestamp = false;\r\n\t\tbool validAmount = false;\r\n\r\n\t\t// check if phase 1 is running\t\r\n\t\tif(phase1StartingAt <= getBlockTime() && getBlockTime() <= phase1EndingAt) {\r\n\t\t\t// check if tokens is falling in timerange\r\n\t\t\tvalidTimestamp = true;\r\n\r\n\t\t\t// check if token amount is falling in limit\r\n\t\t\tvalidAmount = phase1MaxTokenForSale.sub(totalTokenSold) >= amount;\r\n\t\t}\r\n\r\n\t\t// check if phase 2 is running\t\r\n\t\tif(phase2StartingAt <= getBlockTime() && getBlockTime() <= phase2EndingAt) {\r\n\t\t\t// check if tokens is falling in timerange\r\n\t\t\tvalidTimestamp = true;\r\n\r\n\t\t\t// check if token amount is falling in limit\r\n\t\t\tvalidAmount = phase2MaxTokenForSale.sub(totalTokenSold) >= amount;\r\n\t\t}\r\n\r\n\t\t// check if phase 3 is running\t\r\n\t\tif(phase3StartingAt <= getBlockTime() && getBlockTime() <= phase3EndingAt) {\r\n\t\t\t// check if tokens is falling in timerange\r\n\t\t\tvalidTimestamp = true;\r\n\r\n\t\t\t// check if token amount is falling in limit\r\n\t\t\tvalidAmount = phase3MaxTokenForSale.sub(totalTokenSold) >= amount;\r\n\t\t}\r\n\r\n\t\t// check if value of the ether is valid\r\n\t\tbool validValue = value != 0;\r\n\r\n\t\t// check if the tokens available in contract for sale\r\n\t\tbool validToken = amount != 0;\r\n\r\n\t\t// validate if all conditions are met\r\n\t\treturn validTimestamp && validAmount && validValue && validToken && !isClose && !isPaused;\r\n\t}\r\n\r\n\tfunction calculate(uint256 value) internal constant returns (uint256) {\r\n\t\tuint256 amount = 0;\r\n\t\t\t\r\n\t\t// check if phase 1 is running\t\r\n\t\tif(phase1StartingAt <= getBlockTime() && getBlockTime() <= phase1EndingAt) {\r\n\t\t\t// calculate the amount of tokens\r\n\t\t\tamount = value.mul(1E18).div(phase1TokenPriceInEth);\r\n\t\t}\r\n\r\n\t\t// check if phase 2 is running\t\r\n\t\tif(phase2StartingAt <= getBlockTime() && getBlockTime() <= phase2EndingAt) {\r\n\t\t\t// calculate the amount of tokens\r\n\t\t\tamount = value.mul(1E18).div(phase2TokenPriceInEth);\r\n\t\t}\r\n\r\n\t\t// check if phase 3 is running\t\r\n\t\tif(phase3StartingAt <= getBlockTime() && getBlockTime() <= phase3EndingAt) {\r\n\t\t\t// calculate the amount of tokens\r\n\t\t\tamount = value.mul(1E18).div(phase3TokenPriceInEth);\r\n\t\t}\r\n\r\n\t\treturn amount;\r\n\t}\r\n\r\n\tfunction update(uint256 value, uint256 amount) internal returns (bool) {\r\n\r\n\t\t// update the state to log the sold tokens and raised ethers.\r\n\t\ttotalTokenSold = totalTokenSold.add(amount);\r\n\t\ttotalEtherRaised = totalEtherRaised.add(value);\r\n\t\tetherRaisedPerWallet[msg.sender] = etherRaisedPerWallet[msg.sender].add(value);\r\n\r\n\t\t// check if phase 1 is running\t\r\n\t\tif(phase1StartingAt <= getBlockTime() && getBlockTime() <= phase1EndingAt) {\r\n\t\t\t// add tokens to phase1 counts\r\n\t\t\tphase1TokenSold = phase1TokenSold.add(amount);\r\n\t\t}\r\n\r\n\t\t// check if phase 2 is running\t\r\n\t\tif(phase2StartingAt <= getBlockTime() && getBlockTime() <= phase2EndingAt) {\r\n\t\t\t// add tokens to phase2 counts\r\n\t\t\tphase2TokenSold = phase2TokenSold.add(amount);\r\n\t\t}\r\n\r\n\t\t// check if phase 3 is running\t\r\n\t\tif(phase3StartingAt <= getBlockTime() && getBlockTime() <= phase3EndingAt) {\r\n\t\t\t// add tokens to phase3 counts\r\n\t\t\tphase3TokenSold = phase3TokenSold.add(amount);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Default fallback method which will be called when any ethers are sent to contract\r\n\t */\r\n\tfunction() public payable {\r\n\t\tbuy(msg.sender);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Function that is called either externally or by default payable method\r\n\t *\r\n\t * @param beneficiary who should receive tokens\r\n\t */\r\n\tfunction buy(address beneficiary) public payable {\r\n\t\trequire(beneficiary != address(0));\r\n\r\n\t\t// amount of ethers sent\r\n\t\tuint256 value = msg.value;\r\n\r\n\t\t// throw error if not enough ethers sent\r\n\t\trequire(value >= minEthPerTransaction);\r\n\r\n\t\t// refund the extra ethers if sent more than allowed\r\n\t\tif(value > maxEthPerTransaction) {\r\n\t\t\t// more ethers are sent so refund extra\r\n\t\t\tmsg.sender.transfer(value.sub(maxEthPerTransaction));\r\n\t\t\tvalue = maxEthPerTransaction;\r\n\t\t}\r\n\t\t\r\n\t\t// calculate tokens\r\n\t\tuint256 tokens = calculate(value);\r\n\r\n\t\t// validate the purchase\r\n\t\trequire(validate(value , tokens));\r\n\r\n\t\t// update current state \r\n\t\tupdate(value , tokens);\r\n\t\t\r\n\t\t// transfer tokens from contract balance to beneficiary account. calling ERC223 method\r\n\t\tbytes memory empty;\r\n\t\ttoken.transfer(beneficiary, tokens, empty);\r\n\t\t\r\n\t\t// log event for token purchase\r\n\t\tTokenPurchase(msg.sender, beneficiary, value, tokens, now);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev transmit token for a specified address. \r\n\t* This is owner only method and should be called using web3.js if someone is trying to buy token using bitcoin or any other altcoin.\r\n\t* \r\n\t* @param _to The address to transmit to.\r\n\t* @param _value The amount to be transferred.\r\n\t* @param _message message to log after transfer.\r\n\t*/\r\n\tfunction transferManual(address _to, uint256 _value, string _message) onlyOwner public returns (bool) {\r\n\t\trequire(_to != address(0));\r\n\r\n\t\t// transfer tokens manually from contract balance\r\n\t\ttoken.transfer(_to , _value);\r\n\t\tTransferManual(msg.sender, _to, _value, _message);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev sendToGrowthContract  \r\n\t* This will send remaining tokens to growth contract\r\n\t*/\t\r\n\tfunction sendToGrowthContract() onlyOwner public {\r\n\t\trequire(contractTimeout <= getBlockTime());\r\n\r\n\t\t// send remaining tokens to growth contract.\r\n\t\tuint256 tokens = token.balanceOf(this); \r\n\t\tbytes memory empty;\r\n\t\ttoken.transfer(growthContract, tokens, empty);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev sendToVestingContract  \r\n\t* This will transfer any available ethers to vesting contracts\r\n\t*/\t\r\n\tfunction sendToVestingContract() onlyOwner public {\r\n\t\t// distribute funds \r\n\t\tdistribute();\r\n\t}\r\n\r\n\t/**\r\n\t* @dev withdraw funds and tokens \r\n\t* This will send remaining token balance to growth contract\r\n\t* This will distribute available funds across team members\r\n\t*/\t\r\n\tfunction withdraw() onlyOwner public {\r\n\t\trequire(contractTimeout <= getBlockTime());\r\n\r\n\t\t// send remaining tokens to growth contract.\r\n\t\tuint256 tokens = token.balanceOf(this); \r\n\t\tbytes memory empty;\r\n\t\ttoken.transfer(growthContract, tokens, empty);\r\n\r\n\t\t// distribute funds \r\n\t\tdistribute();\r\n\t}\r\n\r\n\t/**\r\n\t* @dev close contract \r\n\t* This will mark contract as closed\r\n\t*/\t\r\n\tfunction close() onlyOwner public {\r\n\t\t// mark the flag to indicate closure of the contract\r\n\t\tisClose = true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev pause contract \r\n\t* This will mark contract as paused\r\n\t*/\t\r\n\tfunction pause() onlyOwner public {\r\n\t\t// mark the flag to indicate pause of the contract\r\n\t\tisPaused = true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev resume contract \r\n\t* This will mark contract as resumed\r\n\t*/\t\r\n\tfunction resume() onlyOwner public {\r\n\t\t// mark the flag to indicate resume of the contract\r\n\t\tisPaused = false;\r\n\t}\r\n}\r\n\r\n/**\r\n* @title dHealthEtherVesting\r\n* @dev This is vesting contract it receives funds and those are used to release funds to fixed address\r\n*/\r\ncontract dHealthEtherVesting is Ownable, Timestamped {\r\n\tusing SafeMath for uint256;\r\n\r\n\t// wallet address which will receive funds on pay\r\n\taddress public wallet;\r\n\r\n\t// timestamp when vesting contract starts, this timestamp matches with sale contract\r\n\tuint256 public startingAt = 1516924800; // Friday, 26 January 2018 00:00:00\r\n\r\n\t// timestamp when vesting ends\r\n\tuint256 public endingAt = startingAt + 540 days;\r\n\r\n\t// how many % of ethers to vest on each call\r\n\tuint256 public vestingAmount = 20;\r\n\r\n\t// timestamp when vesting starts\r\n\tuint256 public vestingPeriodLength = 30 days;\r\n\r\n\t// time after which owner can withdraw all available funds\r\n\tuint256 public contractTimeout = startingAt + 2 years;\r\n\r\n\t// mapping that defines vesting structure\r\n\tstruct VestingStruct {\r\n\t\tuint256 period; \r\n\t\tbool status;\r\n\t\taddress wallet;\r\n\t\tuint256 amount;\r\n\t\tuint256 timestamp;\r\n\t}\r\n\r\n\t// vesting that tracks vestings done against the period.\r\n\tmapping (uint256 => VestingStruct) public vestings;\r\n\r\n\t// Event to log whenever the payment is done\r\n\tevent Payouts(uint256 indexed period, bool status, address wallet, uint256 amount, uint256 timestamp);\r\n\r\n\t/**\r\n\t* @dev Constructor that does nothing \r\n\t*/\r\n\tfunction dHealthEtherVesting(address _wallet) public {\r\n\t\twallet = _wallet;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev default payable method to receive funds\r\n\t*/\r\n\tfunction() public payable {\r\n\t\t\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Method called by owner of contract to withdraw funds\r\n\t*/\r\n\tfunction pay(uint256 percentage) public payable {\r\n\t\t// requested amount should always be less than vestingAmount variable\r\n\t\tpercentage = percentage <= vestingAmount ? percentage : vestingAmount;\r\n\r\n\t\t// calculate amount allowed\r\n\t\tvar (period, amount) = calculate(getBlockTime() , this.balance , percentage);\r\n\r\n\t\t// payment should not be done if period is zero\r\n\t\trequire(period > 0);\r\n\t\t// payment should not be done already\r\n\t\trequire(vestings[period].status == false);\r\n\t\t// wallet should not be set already.\r\n\t\trequire(vestings[period].wallet == address(0));\r\n\t\t// there should be amount to pay\r\n\t\trequire(amount > 0);\r\n\r\n\t\t// set period for storage\r\n\t\tvestings[period].period = period;\r\n\t\t// set status to avoid double payment\r\n\t\tvestings[period].status = true;\r\n\t\t// set wallet to track where payment was sent\r\n\t\tvestings[period].wallet = wallet;\r\n\t\t// set wallet to track how much amount sent\r\n\t\tvestings[period].amount = amount;\r\n\t\t// set timestamp of payment\r\n\t\tvestings[period].timestamp = getBlockTime();\r\n\r\n\t\t// transfer amount to wallet address\r\n\t\twallet.transfer(amount);\r\n\r\n\t\t// log event\r\n\t\tPayouts(period, vestings[period].status, vestings[period].wallet, vestings[period].amount, vestings[period].timestamp);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Internal method called to current vesting period\r\n\t*/\r\n\tfunction getPeriod(uint256 timestamp) public view returns (uint256) {\r\n\t\tfor(uint256 i = 1 ; i <= 18 ; i ++) {\r\n\t\t\t// calculate timestamp range\r\n\t\t\tuint256 startTime = startingAt + (vestingPeriodLength * (i - 1));\r\n\t\t\tuint256 endTime = startingAt + (vestingPeriodLength * (i));\r\n\r\n\t\t\tif(startTime <= timestamp && timestamp < endTime) {\r\n\t\t\t\treturn i;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// calculate timestamp of last period\r\n\t\tuint256 lastEndTime = startingAt + (vestingPeriodLength * (18));\r\n\t\tif(lastEndTime <= timestamp) {\r\n\t\t\treturn 18;\r\n\t\t}\r\n\r\n\t\treturn 0;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Internal method called to current vesting period range\r\n\t*/\r\n\tfunction getPeriodRange(uint256 timestamp) public view returns (uint256 , uint256) {\r\n\t\tfor(uint256 i = 1 ; i <= 18 ; i ++) {\r\n\t\t\t// calculate timestamp range\r\n\t\t\tuint256 startTime = startingAt + (vestingPeriodLength * (i - 1));\r\n\t\t\tuint256 endTime = startingAt + (vestingPeriodLength * (i));\r\n\r\n\t\t\tif(startTime <= timestamp && timestamp < endTime) {\r\n\t\t\t\treturn (startTime , endTime);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// calculate timestamp of last period\r\n\t\tuint256 lastStartTime = startingAt + (vestingPeriodLength * (17));\r\n\t\tuint256 lastEndTime = startingAt + (vestingPeriodLength * (18));\r\n\t\tif(lastEndTime <= timestamp) {\r\n\t\t\treturn (lastStartTime , lastEndTime);\r\n\t\t}\r\n\r\n\t\treturn (0 , 0);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Internal method called to calculate withdrawal amount\r\n\t*/\r\n\tfunction calculate(uint256 timestamp, uint256 balance , uint256 percentage) public view returns (uint256 , uint256) {\r\n\t\t// find out current vesting period\r\n\t\tuint256 period = getPeriod(timestamp);\r\n\t\tif(period == 0) {\r\n\t\t\t// if period is not found then return zero;\r\n\t\t\treturn (0 , 0);\r\n\t\t}\r\n\r\n\t\t// get vesting object for period\r\n\t\tVestingStruct memory vesting = vestings[period];\t\r\n\t\t\r\n\t\t// check if payment is already done\r\n\t\tif(vesting.status == false) {\r\n\t\t\t// payment is not done yet\r\n\t\t\tuint256 amount;\r\n\r\n\t\t\t// if it is last month then send all remaining balance\r\n\t\t\tif(period == 18) {\r\n\t\t\t\t// send all\r\n\t\t\t\tamount = balance;\r\n\t\t\t} else {\r\n\t\t\t\t// calculate percentage and send\r\n\t\t\t\tamount = balance.mul(percentage).div(100);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn (period, amount);\r\n\t\t} else {\r\n\t\t\t// payment is already done \r\n\t\t\treturn (period, 0);\r\n\t\t}\t\t\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Method called by owner to change the wallet address\r\n\t*/\r\n\tfunction setWallet(address _wallet) onlyOwner public {\r\n\t\twallet = _wallet;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Method called by owner of contract to withdraw funds after timeout has reached\r\n\t*/\r\n\tfunction withdraw() onlyOwner public payable {\r\n\t\trequire(contractTimeout <= getBlockTime());\r\n\t\towner.transfer(this.balance);\r\n\t}\t\r\n}\r\n\r\n\r\n/**\r\n* @title dHealthTokenVesting\r\n* @dev This is vesting contract it receives tokens and those are used to release tokens to fixed address\r\n*/\r\ncontract dHealthTokenVesting is Ownable, Timestamped {\r\n\tusing SafeMath for uint256;\r\n\r\n\t// The token being sold, this holds reference to main token contract\r\n\tdHealthToken public token;\r\n\r\n\t// wallet address which will receive tokens on pay\r\n\taddress public wallet;\r\n\r\n\t// amount of token to be hold\r\n\tuint256 public maxTokenForHold;\r\n\r\n\t// timestamp when vesting contract starts, this timestamp matches with sale contract\r\n\tuint256 public startingAt = 1522281600; // Thursday, 29 March 2018 00:00:00\r\n\r\n\t// timestamp when vesting ends\r\n\tuint256 public endingAt = startingAt + 540 days;\r\n\r\n\t// how many % of ethers to vest on each call\r\n\tuint256 public vestingAmount = 20;\r\n\r\n\t// timestamp when vesting starts\r\n\tuint256 public vestingPeriodLength = 30 days;\r\n\r\n\t// time after which owner can withdraw all available funds\r\n\tuint256 public contractTimeout = startingAt + 2 years;\r\n\r\n\t// mapping that defines vesting structure\r\n\tstruct VestingStruct {\r\n\t\tuint256 period; \r\n\t\tbool status;\r\n\t\taddress wallet;\r\n\t\tuint256 amount;\r\n\t\tuint256 timestamp;\r\n\t}\r\n\r\n\t// vesting that tracks vestings done against the period.\r\n\tmapping (uint256 => VestingStruct) public vestings;\r\n\r\n\t// Event to log whenever the payment is done\r\n\tevent Payouts(uint256 indexed period, bool status, address wallet, uint256 amount, uint256 timestamp);\r\n\r\n\t/**\r\n\t* @dev Constructor that initializes token contract with token address in parameter\r\n\t*/\r\n\tfunction dHealthTokenVesting(address _token, address _wallet, uint256 _maxTokenForHold, uint256 _startingAt) public {\r\n\t\t// set token\r\n\t\ttoken = dHealthToken(_token);\r\n\r\n\t\t// set wallet address\r\n\t\twallet = _wallet;\r\n\r\n\t\t// set parameter specific to contract\r\n\t\tmaxTokenForHold = _maxTokenForHold;\t\r\n\t\t\r\n\t\t// setup timestamp\r\n\t\tstartingAt = _startingAt;\r\n\t\tendingAt = startingAt + 540 days;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev default payable method to receive funds\r\n\t*/\r\n\tfunction() public payable {\r\n\t\t\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Method called by owner of contract to withdraw funds\r\n\t*/\r\n\tfunction pay(uint256 percentage) public {\r\n\t\t// requested amount should always be less than vestingAmount variable\r\n\t\tpercentage = percentage <= vestingAmount ? percentage : vestingAmount;\r\n\r\n\t\t// get current token balance\r\n\t\tuint256 balance = token.balanceOf(this); \r\n\t\t\r\n\t\t// calculate amount allowed\r\n\t\tvar (period, amount) = calculate(getBlockTime() , balance , percentage);\r\n\r\n\t\t// payment should not be done if period is zero\r\n\t\trequire(period > 0);\r\n\t\t// payment should not be done already\r\n\t\trequire(vestings[period].status == false);\r\n\t\t// wallet should not be set already.\r\n\t\trequire(vestings[period].wallet == address(0));\r\n\t\t// there should be amount to pay\r\n\t\trequire(amount > 0);\r\n\r\n\t\t// set period for storage\r\n\t\tvestings[period].period = period;\r\n\t\t// set status to avoid double payment\r\n\t\tvestings[period].status = true;\r\n\t\t// set wallet to track where payment was sent\r\n\t\tvestings[period].wallet = wallet;\r\n\t\t// set wallet to track how much amount sent\r\n\t\tvestings[period].amount = amount;\r\n\t\t// set timestamp of payment\r\n\t\tvestings[period].timestamp = getBlockTime();\r\n\r\n\t\t// transfer amount to wallet address\r\n\t\tbytes memory empty;\r\n\t\ttoken.transfer(wallet, amount, empty);\r\n\r\n\t\t// log event\r\n\t\tPayouts(period, vestings[period].status, vestings[period].wallet, vestings[period].amount, vestings[period].timestamp);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Internal method called to current vesting period\r\n\t*/\r\n\tfunction getPeriod(uint256 timestamp) public view returns (uint256) {\r\n\t\tfor(uint256 i = 1 ; i <= 18 ; i ++) {\r\n\t\t\t// calculate timestamp range\r\n\t\t\tuint256 startTime = startingAt + (vestingPeriodLength * (i - 1));\r\n\t\t\tuint256 endTime = startingAt + (vestingPeriodLength * (i));\r\n\r\n\t\t\tif(startTime <= timestamp && timestamp < endTime) {\r\n\t\t\t\treturn i;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// calculate timestamp of last period\r\n\t\tuint256 lastEndTime = startingAt + (vestingPeriodLength * (18));\r\n\t\tif(lastEndTime <= timestamp) {\r\n\t\t\treturn 18;\r\n\t\t}\r\n\r\n\t\treturn 0;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Internal method called to current vesting period range\r\n\t*/\r\n\tfunction getPeriodRange(uint256 timestamp) public view returns (uint256 , uint256) {\r\n\t\tfor(uint256 i = 1 ; i <= 18 ; i ++) {\r\n\t\t\t// calculate timestamp range\r\n\t\t\tuint256 startTime = startingAt + (vestingPeriodLength * (i - 1));\r\n\t\t\tuint256 endTime = startingAt + (vestingPeriodLength * (i));\r\n\r\n\t\t\tif(startTime <= timestamp && timestamp < endTime) {\r\n\t\t\t\treturn (startTime , endTime);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// calculate timestamp of last period\r\n\t\tuint256 lastStartTime = startingAt + (vestingPeriodLength * (17));\r\n\t\tuint256 lastEndTime = startingAt + (vestingPeriodLength * (18));\r\n\t\tif(lastEndTime <= timestamp) {\r\n\t\t\treturn (lastStartTime , lastEndTime);\r\n\t\t}\r\n\r\n\t\treturn (0 , 0);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Internal method called to calculate withdrawal amount\r\n\t*/\r\n\tfunction calculate(uint256 timestamp, uint256 balance , uint256 percentage) public view returns (uint256 , uint256) {\r\n\t\t// find out current vesting period\r\n\t\tuint256 period = getPeriod(timestamp);\r\n\t\tif(period == 0) {\r\n\t\t\t// if period is not found then return zero;\r\n\t\t\treturn (0 , 0);\r\n\t\t}\r\n\r\n\t\t// get vesting object for period\r\n\t\tVestingStruct memory vesting = vestings[period];\t\r\n\t\t\r\n\t\t// check if payment is already done\r\n\t\tif(vesting.status == false) {\r\n\t\t\t// payment is not done yet\r\n\t\t\tuint256 amount;\r\n\r\n\t\t\t// if it is last month then send all remaining balance\r\n\t\t\tif(period == 18) {\r\n\t\t\t\t// send all\r\n\t\t\t\tamount = balance;\r\n\t\t\t} else {\r\n\t\t\t\t// calculate percentage and send\r\n\t\t\t\tamount = balance.mul(percentage).div(100);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn (period, amount);\r\n\t\t} else {\r\n\t\t\t// payment is already done \r\n\t\t\treturn (period, 0);\r\n\t\t}\t\t\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Method called by owner to change the wallet address\r\n\t*/\r\n\tfunction setWallet(address _wallet) onlyOwner public {\r\n\t\twallet = _wallet;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Method called by owner of contract to withdraw funds after timeout has reached\r\n\t*/\r\n\tfunction withdraw() onlyOwner public payable {\r\n\t\trequire(contractTimeout <= getBlockTime());\r\n\t\t\r\n\t\t// send remaining tokens back to owner.\r\n\t\tuint256 tokens = token.balanceOf(this); \r\n\t\tbytes memory empty;\r\n\t\ttoken.transfer(owner, tokens, empty);\r\n\t}\t\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"},{\"name\":\"_custom_fallback\",\"type\":\"string\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"dHealthToken","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://a8eb347fcd24462fa58c8df25e82934d80ae9fc64c324c4858d27f4419e7b2a5"}]}