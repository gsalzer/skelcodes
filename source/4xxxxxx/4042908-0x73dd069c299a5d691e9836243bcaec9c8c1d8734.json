{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract ReentrancyGuard {\r\n\r\n  /**\r\n   * @dev We use a single lock for the whole contract. \r\n   */\r\n  bool private rentrancy_lock = false;\r\n\r\n  /**\r\n   * @dev Prevents a contract from calling itself, directly or indirectly.\r\n   * @notice If you mark a function `nonReentrant`, you should also\r\n   * mark it `external`. Calling one nonReentrant function from\r\n   * another is not supported. Instead, you can implement a\r\n   * `private` function doing the actual work, and a `external`\r\n   * wrapper marked as `nonReentrant`.\r\n   */\r\n  modifier nonReentrant() {\r\n    require(!rentrancy_lock);\r\n    rentrancy_lock = true;\r\n    _;\r\n    rentrancy_lock = false;\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) constant returns (uint256);\r\n  function transfer(address to, uint256 value);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value);\r\n  function approve(address spender, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) {\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of. \r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amout of tokens to be transfered\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) {\r\n    var _allowance = allowed[_from][msg.sender];\r\n\r\n    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n    // if (_value > _allowance) throw;\r\n\r\n    balances[_to] = balances[_to].add(_value);\r\n    balances[_from] = balances[_from].sub(_value);\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\n    Transfer(_from, _to, _value);\r\n  }\r\n\r\n  /**\r\n   * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) {\r\n\r\n    // To change the approve amount you first have to reduce the addresses`\r\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n    //  already 0 to mitigate the race condition described here:\r\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    if (_value != 0) require(allowed[msg.sender][_spender] == 0);\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifing the amount of tokens still avaible for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n}\r\n\r\ncontract Transmutable {\r\n  function transmute(address to, uint256 value) returns (bool, uint256);\r\n  event Transmuted(address indexed who, address baseContract, address transmutedContract, uint256 sourceQuantity, uint256 destQuantity);\r\n}\r\n\r\n// Contracts that can be transmuted to should implement this\r\ncontract TransmutableInterface {\r\n  function transmuted(uint256 _value) returns (bool, uint256);\r\n}\r\n\r\n\r\n\r\ncontract ERC20Mineable is StandardToken, ReentrancyGuard  {\r\n\r\n   uint256 public constant divisible_units = 10000000;\r\n   uint256 public constant decimals = 8;\r\n\r\n   uint256 public constant initial_reward = 100;\r\n\r\n   /** totalSupply in StandardToken refers to currently available supply\r\n   * maximumSupply refers to the cap on mining.\r\n   * When mining is finished totalSupply == maximumSupply\r\n   */\r\n   uint256 public maximumSupply;\r\n\r\n   // Current mining difficulty in Wei\r\n   uint256 public currentDifficultyWei;\r\n\r\n   // Minimum difficulty\r\n   uint256 public minimumDifficultyThresholdWei;\r\n\r\n   /** Block creation rate as number of Ethereum blocks per mining cycle\r\n   * 10 minutes at 12 seconds a block would be an internal block\r\n   * generated every 50 Ethereum blocks\r\n   */\r\n   uint256 public blockCreationRate;\r\n\r\n   /* difficultyAdjustmentPeriod should be every two weeks, or\r\n   * 2016 internal blocks.\r\n   */\r\n   uint256 public difficultyAdjustmentPeriod;\r\n\r\n   /* When was the last time we did a difficulty adjustment.\r\n   * In case mining ceases for indeterminate duration\r\n   */\r\n   uint256 public lastDifficultyAdjustmentEthereumBlock;\r\n\r\n   // Scale multiplier limit for difficulty adjustment\r\n   uint256 public constant difficultyScaleMultiplierLimit = 4;\r\n\r\n   // Total blocks mined helps us calculate the current reward\r\n   uint256 public totalBlocksMined;\r\n\r\n   // Reward adjustment period in Bitcoineum native blocks\r\n\r\n   uint256 public rewardAdjustmentPeriod; \r\n\r\n   // Total amount of Wei put into mining during current period\r\n   uint256 public totalWeiCommitted;\r\n   // Total amount of Wei expected for this mining period\r\n   uint256 public totalWeiExpected;\r\n\r\n   // Where to burn Ether\r\n   address public burnAddress;\r\n\r\n   /** Each block is created on a mining attempt if\r\n   * it does not already exist.\r\n   * this keeps track of the target difficulty at the time of creation\r\n   */\r\n\r\n   struct InternalBlock {\r\n      uint256 targetDifficultyWei;\r\n      uint256 blockNumber;\r\n      uint256 totalMiningWei;\r\n      uint256 totalMiningAttempts;\r\n      uint256 currentAttemptOffset;\r\n      bool payed;\r\n      address payee;\r\n      bool isCreated;\r\n   }\r\n\r\n   /** Mining attempts are given a projected offset to minimize\r\n   * keyspace overlap to increase fairness by reducing the redemption\r\n   * race condition\r\n   * This does not remove the possibility that two or more miners will\r\n   * be competing for the same award, especially if subsequent increases in\r\n   * wei from a single miner increase overlap\r\n   */\r\n   struct MiningAttempt {\r\n      uint256 projectedOffset;\r\n      uint256 value;\r\n      bool isCreated;\r\n   }\r\n\r\n   // Each guess gets assigned to a block\r\n   mapping (uint256 => InternalBlock) public blockData;\r\n   mapping (uint256 => mapping (address => MiningAttempt)) public miningAttempts;\r\n\r\n   // Utility related\r\n\r\n   function resolve_block_hash(uint256 _blockNum) public constant returns (bytes32) {\r\n       return block.blockhash(_blockNum);\r\n   }\r\n\r\n   function current_external_block() public constant returns (uint256) {\r\n       return block.number;\r\n   }\r\n\r\n   function external_to_internal_block_number(uint256 _externalBlockNum) public constant returns (uint256) {\r\n      // blockCreationRate is > 0\r\n      return _externalBlockNum / blockCreationRate;\r\n   }\r\n\r\n   // For the test harness verification\r\n   function get_internal_block_number() public constant returns (uint256) {\r\n     return external_to_internal_block_number(current_external_block());\r\n   }\r\n\r\n   // Initial state related\r\n   /** Dapps need to grab the initial state of the contract\r\n   * in order to properly initialize mining or tracking\r\n   * this is a single atomic function for getting state\r\n   * rather than scattering it across multiple public calls\r\n   * also returns the current blocks parameters\r\n   * or default params if it hasn't been created yet\r\n   * This is only called externally\r\n   */\r\n\r\n   function getContractState() external constant\r\n     returns (uint256,  // currentDifficultyWei\r\n              uint256,  // minimumDifficultyThresholdWei\r\n              uint256,  // blockNumber\r\n              uint256,  // blockCreationRate\r\n              uint256,  // difficultyAdjustmentPeriod\r\n              uint256,  // rewardAdjustmentPeriod\r\n              uint256,  // lastDifficultyAdustmentEthereumBlock\r\n              uint256,  // totalBlocksMined\r\n              uint256,  // totalWeiCommitted\r\n              uint256,  // totalWeiExpected\r\n              uint256,  // b.targetDifficultyWei\r\n              uint256,  // b.totalMiningWei\r\n              uint256  // b.currentAttemptOffset\r\n              ) {\r\n    InternalBlock memory b;\r\n    uint256 _blockNumber = external_to_internal_block_number(current_external_block());\r\n    if (!blockData[_blockNumber].isCreated) {\r\n        b = InternalBlock(\r\n                       {targetDifficultyWei: currentDifficultyWei,\r\n                       blockNumber: _blockNumber,\r\n                       totalMiningWei: 0,\r\n                       totalMiningAttempts: 0,\r\n                       currentAttemptOffset: 0,\r\n                       payed: false,\r\n                       payee: 0,\r\n                       isCreated: true\r\n                       });\r\n    } else {\r\n         b = blockData[_blockNumber];\r\n    }\r\n    return (currentDifficultyWei,\r\n            minimumDifficultyThresholdWei,\r\n            _blockNumber,\r\n            blockCreationRate,\r\n            difficultyAdjustmentPeriod,\r\n            rewardAdjustmentPeriod,\r\n            lastDifficultyAdjustmentEthereumBlock,\r\n            totalBlocksMined,\r\n            totalWeiCommitted,\r\n            totalWeiExpected,\r\n            b.targetDifficultyWei,\r\n            b.totalMiningWei,\r\n            b.currentAttemptOffset);\r\n   }\r\n\r\n   function getBlockData(uint256 _blockNum) public constant returns (uint256, uint256, uint256, uint256, uint256, bool, address, bool) {\r\n    InternalBlock memory iBlock = blockData[_blockNum];\r\n    return (iBlock.targetDifficultyWei,\r\n    iBlock.blockNumber,\r\n    iBlock.totalMiningWei,\r\n    iBlock.totalMiningAttempts,\r\n    iBlock.currentAttemptOffset,\r\n    iBlock.payed,\r\n    iBlock.payee,\r\n    iBlock.isCreated);\r\n   }\r\n\r\n   function getMiningAttempt(uint256 _blockNum, address _who) public constant returns (uint256, uint256, bool) {\r\n     if (miningAttempts[_blockNum][_who].isCreated) {\r\n        return (miningAttempts[_blockNum][_who].projectedOffset,\r\n        miningAttempts[_blockNum][_who].value,\r\n        miningAttempts[_blockNum][_who].isCreated);\r\n     } else {\r\n        return (0, 0, false);\r\n     }\r\n   }\r\n\r\n   // Mining Related\r\n\r\n   modifier blockCreated(uint256 _blockNum) {\r\n     require(blockData[_blockNum].isCreated);\r\n     _;\r\n   }\r\n\r\n   modifier blockRedeemed(uint256 _blockNum) {\r\n     require(_blockNum != current_external_block());\r\n     /* Should capture if the blockdata is payed\r\n     *  or if it does not exist in the blockData mapping\r\n     */\r\n     require(blockData[_blockNum].isCreated);\r\n     require(!blockData[_blockNum].payed);\r\n     _;\r\n   }\r\n\r\n   modifier initBlock(uint256 _blockNum) {\r\n     require(_blockNum != current_external_block());\r\n\r\n     if (!blockData[_blockNum].isCreated) {\r\n       // This is a new block, adjust difficulty\r\n       adjust_difficulty();\r\n\r\n       // Create new block for tracking\r\n       blockData[_blockNum] = InternalBlock(\r\n                                     {targetDifficultyWei: currentDifficultyWei,\r\n                                      blockNumber: _blockNum,\r\n                                      totalMiningWei: 0,\r\n                                      totalMiningAttempts: 0,\r\n                                      currentAttemptOffset: 0,\r\n                                      payed: false,\r\n                                      payee: 0,\r\n                                      isCreated: true\r\n                                      });\r\n     }\r\n     _;\r\n   }\r\n\r\n   modifier isValidAttempt() {\r\n     /* If the Ether for this mining attempt is less than minimum\r\n     * 0.0000001 % of total difficulty\r\n     */\r\n     uint256 minimum_wei = currentDifficultyWei / divisible_units; \r\n     require (msg.value >= minimum_wei);\r\n\r\n     /* Let's bound the value to guard against potential overflow\r\n     * i.e max int, or an underflow bug\r\n     * This is a single attempt\r\n     */\r\n     require(msg.value <= (1000000 ether));\r\n     _;\r\n   }\r\n\r\n   modifier alreadyMined(uint256 blockNumber, address sender) {\r\n     require(blockNumber != current_external_block()); \r\n    /* We are only going to allow one mining attempt per block per account\r\n    *  This prevents stuffing and make it easier for us to track boundaries\r\n    */\r\n    \r\n    // This user already made a mining attempt for this block\r\n    require(!checkMiningAttempt(blockNumber, sender));\r\n    _;\r\n   }\r\n\r\n   function checkMiningActive() public constant returns (bool) {\r\n      return (totalSupply < maximumSupply);\r\n   }\r\n\r\n   modifier isMiningActive() {\r\n      require(checkMiningActive());\r\n      _;\r\n   }\r\n\r\n   function burn(uint256 value) internal {\r\n      /* We don't really care if the burn fails for some\r\n      *  weird reason.\r\n      */\r\n      bool ret = burnAddress.send(value);\r\n      /* If we cannot burn this ether, than the contract might\r\n      *  be under some kind of stack attack.\r\n      *  Even though it shouldn't matter, let's err on the side of\r\n      *  caution and throw in case there is some invalid state.\r\n      */\r\n      require (ret);\r\n   }\r\n\r\n   event MiningAttemptEvent(\r\n       address indexed _from,\r\n       uint256 _value,\r\n       uint256 indexed _blockNumber,\r\n       uint256 _totalMinedWei,\r\n       uint256 _targetDifficultyWei\r\n   );\r\n\r\n   event LogEvent(\r\n       string _info\r\n   );\r\n\r\n   /**\r\n   * @dev Add a mining attempt for the current internal block\r\n   * Initialize an empty block if not created\r\n   * Invalidate this mining attempt if the block has been paid out\r\n   */\r\n\r\n   function mine() external payable \r\n                           nonReentrant\r\n                           isValidAttempt\r\n                           isMiningActive\r\n                           initBlock(external_to_internal_block_number(current_external_block()))\r\n                           blockRedeemed(external_to_internal_block_number(current_external_block()))\r\n                           alreadyMined(external_to_internal_block_number(current_external_block()), msg.sender) returns (bool) {\r\n      /* Let's immediately adjust the difficulty\r\n      *  In case an abnormal period of time has elapsed\r\n      *  nobody has been mining etc.\r\n      *  Will let us recover the network even if the\r\n      * difficulty spikes to some absurd amount\r\n      * this should only happen on the first attempt on a block\r\n      */\r\n      uint256 internalBlockNum = external_to_internal_block_number(current_external_block());\r\n      miningAttempts[internalBlockNum][msg.sender] =\r\n                     MiningAttempt({projectedOffset: blockData[internalBlockNum].currentAttemptOffset,\r\n                                    value: msg.value,\r\n                                    isCreated: true});\r\n\r\n      // Increment the mining attempts for this block\r\n      blockData[internalBlockNum].totalMiningAttempts += 1;\r\n      blockData[internalBlockNum].totalMiningWei += msg.value;\r\n      totalWeiCommitted += msg.value;\r\n\r\n      /* We are trying to stack mining attempts into their relative\r\n      *  positions in the key space.\r\n      */\r\n      blockData[internalBlockNum].currentAttemptOffset += msg.value;\r\n      MiningAttemptEvent(msg.sender,\r\n                         msg.value,\r\n                         internalBlockNum,\r\n                         blockData[internalBlockNum].totalMiningWei,\r\n                         blockData[internalBlockNum].targetDifficultyWei\r\n                         );\r\n      // All mining attempt Ether is burned\r\n      burn(msg.value);\r\n      return true;\r\n   }\r\n\r\n   // Redemption Related\r\n\r\n   modifier userMineAttempted(uint256 _blockNum, address _user) {\r\n      require(checkMiningAttempt(_blockNum, _user));\r\n      _;\r\n   }\r\n   \r\n   modifier isBlockMature(uint256 _blockNumber) {\r\n      require(_blockNumber != current_external_block());\r\n      require(checkBlockMature(_blockNumber, current_external_block()));\r\n      require(checkRedemptionWindow(_blockNumber, current_external_block()));\r\n      _;\r\n   }\r\n\r\n   // Just in case this block falls outside of the available\r\n   // block range, possibly because of a change in network params\r\n   modifier isBlockReadable(uint256 _blockNumber) {\r\n      InternalBlock memory iBlock = blockData[_blockNumber];\r\n      uint256 targetBlockNum = targetBlockNumber(_blockNumber);\r\n      require(resolve_block_hash(targetBlockNum) != 0);\r\n      _;\r\n   }\r\n\r\n   function calculate_difficulty_attempt(uint256 targetDifficultyWei,\r\n                                         uint256 totalMiningWei,\r\n                                         uint256 value) public constant returns (uint256) {\r\n      // The total amount of Wei sent for this mining attempt exceeds the difficulty level\r\n      // So the calculation of percentage keyspace should be done on the total wei.\r\n      uint256 selectedDifficultyWei = 0;\r\n      if (totalMiningWei > targetDifficultyWei) {\r\n         selectedDifficultyWei = totalMiningWei;\r\n      } else {\r\n         selectedDifficultyWei = targetDifficultyWei; \r\n      }\r\n\r\n      /* normalize the value against the entire key space\r\n       * Multiply it out because we do not have floating point\r\n       * 10000000 is .0000001 % increments\r\n      */\r\n\r\n      uint256 intermediate = ((value * divisible_units) / selectedDifficultyWei);\r\n      uint256 max_int = 0;\r\n      // Underflow to maxint\r\n      max_int = max_int - 1;\r\n\r\n      if (intermediate >= divisible_units) {\r\n         return max_int;\r\n      } else {\r\n         return intermediate * (max_int / divisible_units);\r\n      }\r\n   }\r\n\r\n   function calculate_range_attempt(uint256 difficulty, uint256 offset) public constant returns (uint256, uint256) {\r\n       /* Both the difficulty and offset should be normalized\r\n       * against the difficulty scale.\r\n       * If they are not we might have an integer overflow\r\n       */\r\n       require(offset + difficulty >= offset);\r\n       return (offset, offset+difficulty);\r\n   }\r\n\r\n   // Total allocated reward is proportional to burn contribution to limit incentive for\r\n   // hash grinding attacks\r\n   function calculate_proportional_reward(uint256 _baseReward, uint256 _userContributionWei, uint256 _totalCommittedWei) public constant returns (uint256) {\r\n   require(_userContributionWei <= _totalCommittedWei);\r\n   require(_userContributionWei > 0);\r\n   require(_totalCommittedWei > 0);\r\n      uint256 intermediate = ((_userContributionWei * divisible_units) / _totalCommittedWei);\r\n\r\n      if (intermediate >= divisible_units) {\r\n         return _baseReward;\r\n      } else {\r\n         return intermediate * (_baseReward / divisible_units);\r\n      }\r\n   }\r\n\r\n   function calculate_base_mining_reward(uint256 _totalBlocksMined) public constant returns (uint256) {\r\n      /* Block rewards starts at initial_reward\r\n      *  Every 10 minutes\r\n      *  Block reward decreases by 50% every 210000 blocks\r\n      */\r\n      uint256 mined_block_period = 0;\r\n      if (_totalBlocksMined < 210000) {\r\n           mined_block_period = 210000;\r\n      } else {\r\n           mined_block_period = _totalBlocksMined;\r\n      }\r\n\r\n      // Again we have to do this iteratively because of floating\r\n      // point limitations in solidity.\r\n      uint256 total_reward = initial_reward * (10 ** decimals); \r\n      uint256 i = 1;\r\n      uint256 rewardperiods = mined_block_period / 210000;\r\n      if (mined_block_period % 210000 > 0) {\r\n         rewardperiods += 1;\r\n      }\r\n      for (i=1; i < rewardperiods; i++) {\r\n          total_reward = total_reward / 2;\r\n      }\r\n      return total_reward;\r\n   }\r\n\r\n   // Break out the expected wei calculation\r\n   // for easy external testing\r\n   function calculate_next_expected_wei(uint256 _totalWeiCommitted,\r\n                                        uint256 _totalWeiExpected,\r\n                                        uint256 _minimumDifficultyThresholdWei,\r\n                                        uint256 _difficultyScaleMultiplierLimit) public constant\r\n                                        returns (uint256) {\r\n          \r\n          /* The adjustment window has been fulfilled\r\n          *  The new difficulty should be bounded by the total wei actually spent\r\n          * capped at difficultyScaleMultiplierLimit times\r\n          */\r\n          uint256 lowerBound = _totalWeiExpected / _difficultyScaleMultiplierLimit;\r\n          uint256 upperBound = _totalWeiExpected * _difficultyScaleMultiplierLimit;\r\n\r\n          if (_totalWeiCommitted < lowerBound) {\r\n              _totalWeiExpected = lowerBound;\r\n          } else if (_totalWeiCommitted > upperBound) {\r\n              _totalWeiExpected = upperBound;\r\n          } else {\r\n              _totalWeiExpected = _totalWeiCommitted;\r\n          }\r\n\r\n          /* If difficulty drops too low lets set it to our minimum.\r\n          *  This may halt coin creation, but obviously does not affect\r\n          *  token transactions.\r\n          */\r\n          if (_totalWeiExpected < _minimumDifficultyThresholdWei) {\r\n              _totalWeiExpected = _minimumDifficultyThresholdWei;\r\n          }\r\n\r\n          return _totalWeiExpected;\r\n    }\r\n\r\n   function adjust_difficulty() internal {\r\n      /* Total blocks mined might not be increasing if the \r\n      *  difficulty is too high. So we should instead base the adjustment\r\n      * on the progression of the Ethereum network.\r\n      * So that the difficulty can increase/deflate regardless of sparse\r\n      * mining attempts\r\n      */\r\n\r\n      if ((current_external_block() - lastDifficultyAdjustmentEthereumBlock) > (difficultyAdjustmentPeriod * blockCreationRate)) {\r\n\r\n          // Get the new total wei expected via static function\r\n          totalWeiExpected = calculate_next_expected_wei(totalWeiCommitted, totalWeiExpected, minimumDifficultyThresholdWei * difficultyAdjustmentPeriod, difficultyScaleMultiplierLimit);\r\n\r\n          currentDifficultyWei = totalWeiExpected / difficultyAdjustmentPeriod;\r\n\r\n          // Regardless of difficulty adjustment, let us zero totalWeiCommited\r\n          totalWeiCommitted = 0;\r\n\r\n          // Lets reset the difficulty adjustment block target\r\n          lastDifficultyAdjustmentEthereumBlock = current_external_block();\r\n\r\n      }\r\n   }\r\n\r\n   event BlockClaimedEvent(\r\n       address indexed _from,\r\n       address indexed _forCreditTo,\r\n       uint256 _reward,\r\n       uint256 indexed _blockNumber\r\n   );\r\n\r\n   modifier onlyWinner(uint256 _blockNumber) {\r\n      require(checkWinning(_blockNumber));\r\n      _;\r\n   }\r\n\r\n\r\n   // Helper function to avoid stack issues\r\n   function calculate_reward(uint256 _totalBlocksMined, address _sender, uint256 _blockNumber) public constant returns (uint256) {\r\n      return calculate_proportional_reward(calculate_base_mining_reward(_totalBlocksMined), miningAttempts[_blockNumber][_sender].value, blockData[_blockNumber].totalMiningWei); \r\n   }\r\n\r\n   /** \r\n   * @dev Claim the mining reward for a given block\r\n   * @param _blockNumber The internal block that the user is trying to claim\r\n   * @param forCreditTo When the miner account is different from the account\r\n   * where we want to deliver the redeemed Bitcoineum. I.e Hard wallet.\r\n   */\r\n   function claim(uint256 _blockNumber, address forCreditTo)\r\n                  nonReentrant\r\n                  blockRedeemed(_blockNumber)\r\n                  isBlockMature(_blockNumber)\r\n                  isBlockReadable(_blockNumber)\r\n                  userMineAttempted(_blockNumber, msg.sender)\r\n                  onlyWinner(_blockNumber)\r\n                  external returns (bool) {\r\n      /* If attempt is valid, invalidate redemption\r\n      *  Difficulty is adjusted here\r\n      *  and on bidding, in case bidding stalls out for some\r\n      *  unusual period of time.\r\n      *  Do everything, then adjust supply and balance\r\n      */\r\n      blockData[_blockNumber].payed = true;\r\n      blockData[_blockNumber].payee = msg.sender;\r\n      totalBlocksMined = totalBlocksMined + 1;\r\n\r\n      uint256 proportional_reward = calculate_reward(totalBlocksMined, msg.sender, _blockNumber);\r\n      balances[forCreditTo] = balances[forCreditTo].add(proportional_reward);\r\n      totalSupply += proportional_reward;\r\n      BlockClaimedEvent(msg.sender, forCreditTo,\r\n                        proportional_reward,\r\n                        _blockNumber);\r\n      // Mining rewards should show up as ERC20 transfer events\r\n      // So that ERC20 scanners will see token creation.\r\n      Transfer(this, forCreditTo, proportional_reward);\r\n      return true;\r\n   }\r\n\r\n   /** \r\n   * @dev Claim the mining reward for a given block\r\n   * @param _blockNum The internal block that the user is trying to claim\r\n   */\r\n   function isBlockRedeemed(uint256 _blockNum) constant public returns (bool) {\r\n     if (!blockData[_blockNum].isCreated) {\r\n         return false;\r\n     } else {\r\n         return blockData[_blockNum].payed;\r\n     }\r\n   }\r\n\r\n   /** \r\n   * @dev Get the target block in the winning equation \r\n   * @param _blockNum is the internal block number to get the target block for\r\n   */\r\n   function targetBlockNumber(uint256 _blockNum) constant public returns (uint256) {\r\n      return ((_blockNum + 1) * blockCreationRate);\r\n   }\r\n\r\n   /** \r\n   * @dev Check whether a given block is mature \r\n   * @param _blockNum is the internal block number to check \r\n   */\r\n   function checkBlockMature(uint256 _blockNum, uint256 _externalblock) constant public returns (bool) {\r\n     return (_externalblock >= targetBlockNumber(_blockNum));\r\n   }\r\n\r\n   /**\r\n   * @dev Check the redemption window for a given block\r\n   * @param _blockNum is the internal block number to check\r\n   */\r\n\r\n   function checkRedemptionWindow(uint256 _blockNum, uint256 _externalblock) constant public returns (bool) {\r\n       uint256 _targetblock = targetBlockNumber(_blockNum);\r\n       return _externalblock >= _targetblock && _externalblock < (_targetblock + 256);\r\n   }\r\n\r\n   /** \r\n   * @dev Check whether a mining attempt was made by sender for this block\r\n   * @param _blockNum is the internal block number to check\r\n   */\r\n   function checkMiningAttempt(uint256 _blockNum, address _sender) constant public returns (bool) {\r\n       return miningAttempts[_blockNum][_sender].isCreated;\r\n   }\r\n\r\n   /** \r\n   * @dev Did the user win a specific block and can claim it?\r\n   * @param _blockNum is the internal block number to check\r\n   */\r\n   function checkWinning(uint256 _blockNum) constant public returns (bool) {\r\n     if (checkMiningAttempt(_blockNum, msg.sender) && checkBlockMature(_blockNum, current_external_block())) {\r\n\r\n      InternalBlock memory iBlock = blockData[_blockNum];\r\n      uint256 targetBlockNum = targetBlockNumber(iBlock.blockNumber);\r\n      MiningAttempt memory attempt = miningAttempts[_blockNum][msg.sender];\r\n\r\n      uint256 difficultyAttempt = calculate_difficulty_attempt(iBlock.targetDifficultyWei, iBlock.totalMiningWei, attempt.value);\r\n      uint256 beginRange;\r\n      uint256 endRange;\r\n      uint256 targetBlockHashInt;\r\n\r\n      (beginRange, endRange) = calculate_range_attempt(difficultyAttempt,\r\n          calculate_difficulty_attempt(iBlock.targetDifficultyWei, iBlock.totalMiningWei, attempt.projectedOffset)); \r\n      targetBlockHashInt = uint256(keccak256(resolve_block_hash(targetBlockNum)));\r\n   \r\n      // This is the winning condition\r\n      if ((beginRange < targetBlockHashInt) && (endRange >= targetBlockHashInt))\r\n      {\r\n        return true;\r\n      }\r\n     \r\n     }\r\n\r\n     return false;\r\n     \r\n   }\r\n\r\n}\r\n\r\n\r\n\r\ncontract Bitcoineum is ERC20Mineable, Transmutable {\r\n\r\n string public constant name = \"Bitcoineum\";\r\n string public constant symbol = \"BTE\";\r\n uint256 public constant decimals = 8;\r\n uint256 public constant INITIAL_SUPPLY = 0;\r\n\r\n // 21 Million coins at 8 decimal places\r\n uint256 public constant MAX_SUPPLY = 21000000 * (10**8);\r\n \r\n function Bitcoineum() {\r\n\r\n    totalSupply = INITIAL_SUPPLY;\r\n    maximumSupply = MAX_SUPPLY;\r\n\r\n    // 0.0001 Ether per block\r\n    // Difficulty is so low because it doesn't include\r\n    // gas prices for execution\r\n    currentDifficultyWei = 100 szabo;\r\n    minimumDifficultyThresholdWei = 100 szabo;\r\n    \r\n    // Ethereum blocks to internal blocks\r\n    // Roughly 10 minute windows\r\n    blockCreationRate = 50;\r\n\r\n    // Adjust difficulty x claimed internal blocks\r\n    difficultyAdjustmentPeriod = 2016;\r\n\r\n    // Reward adjustment\r\n\r\n    rewardAdjustmentPeriod = 210000;\r\n\r\n    // This is the effective block counter, since block windows are discontinuous\r\n    totalBlocksMined = 0;\r\n\r\n    totalWeiExpected = difficultyAdjustmentPeriod * currentDifficultyWei;\r\n\r\n    // Balance of this address can be used to determine total burned value\r\n    // not including fees spent.\r\n    burnAddress = 0xdeaDDeADDEaDdeaDdEAddEADDEAdDeadDEADDEaD;\r\n\r\n    lastDifficultyAdjustmentEthereumBlock = block.number; \r\n }\r\n\r\n\r\n   /**\r\n   * @dev Bitcoineum can extend proof of burn into convertable units\r\n   * that have token specific properties\r\n   * @param to is the address of the contract that Bitcoineum is converting into\r\n   * @param value is the quantity of Bitcoineum to attempt to convert\r\n   */\r\n\r\n  function transmute(address to, uint256 value) nonReentrant returns (bool, uint256) {\r\n    require(value > 0);\r\n    require(balances[msg.sender] >= value);\r\n    require(totalSupply >= value);\r\n    balances[msg.sender] = balances[msg.sender].sub(value);\r\n    totalSupply = totalSupply.sub(value);\r\n    TransmutableInterface target = TransmutableInterface(to);\r\n    bool _result = false;\r\n    uint256 _total = 0;\r\n    (_result, _total) = target.transmuted(value);\r\n    require (_result);\r\n    Transmuted(msg.sender, this, to, value, _total);\r\n    return (_result, _total);\r\n  }\r\n\r\n }","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"current_external_block\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maximumSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalWeiCommitted\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_totalBlocksMined\",\"type\":\"uint256\"}],\"name\":\"calculate_base_mining_reward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_blockNum\",\"type\":\"uint256\"}],\"name\":\"getBlockData\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastDifficultyAdjustmentEthereumBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumDifficultyThresholdWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_totalWeiCommitted\",\"type\":\"uint256\"},{\"name\":\"_totalWeiExpected\",\"type\":\"uint256\"},{\"name\":\"_minimumDifficultyThresholdWei\",\"type\":\"uint256\"},{\"name\":\"_difficultyScaleMultiplierLimit\",\"type\":\"uint256\"}],\"name\":\"calculate_next_expected_wei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INITIAL_SUPPLY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_SUPPLY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_blockNum\",\"type\":\"uint256\"},{\"name\":\"_externalblock\",\"type\":\"uint256\"}],\"name\":\"checkBlockMature\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_blockNum\",\"type\":\"uint256\"}],\"name\":\"targetBlockNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBlocksMined\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"difficulty\",\"type\":\"uint256\"},{\"name\":\"offset\",\"type\":\"uint256\"}],\"name\":\"calculate_range_attempt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"divisible_units\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkMiningActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_blockNum\",\"type\":\"uint256\"}],\"name\":\"resolve_block_hash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_totalBlocksMined\",\"type\":\"uint256\"},{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"calculate_reward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"burnAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"blockData\",\"outputs\":[{\"name\":\"targetDifficultyWei\",\"type\":\"uint256\"},{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"totalMiningWei\",\"type\":\"uint256\"},{\"name\":\"totalMiningAttempts\",\"type\":\"uint256\"},{\"name\":\"currentAttemptOffset\",\"type\":\"uint256\"},{\"name\":\"payed\",\"type\":\"bool\"},{\"name\":\"payee\",\"type\":\"address\"},{\"name\":\"isCreated\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getContractState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initial_reward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_blockNum\",\"type\":\"uint256\"},{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"checkMiningAttempt\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"targetDifficultyWei\",\"type\":\"uint256\"},{\"name\":\"totalMiningWei\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"calculate_difficulty_attempt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"mine\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_blockNum\",\"type\":\"uint256\"},{\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"getMiningAttempt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"miningAttempts\",\"outputs\":[{\"name\":\"projectedOffset\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"isCreated\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"difficultyScaleMultiplierLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blockCreationRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentDifficultyWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_baseReward\",\"type\":\"uint256\"},{\"name\":\"_userContributionWei\",\"type\":\"uint256\"},{\"name\":\"_totalCommittedWei\",\"type\":\"uint256\"}],\"name\":\"calculate_proportional_reward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_blockNum\",\"type\":\"uint256\"},{\"name\":\"_externalblock\",\"type\":\"uint256\"}],\"name\":\"checkRedemptionWindow\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalWeiExpected\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"get_internal_block_number\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_blockNum\",\"type\":\"uint256\"}],\"name\":\"checkWinning\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_blockNumber\",\"type\":\"uint256\"},{\"name\":\"forCreditTo\",\"type\":\"address\"}],\"name\":\"claim\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"difficultyAdjustmentPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transmute\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_blockNum\",\"type\":\"uint256\"}],\"name\":\"isBlockRedeemed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_externalBlockNum\",\"type\":\"uint256\"}],\"name\":\"external_to_internal_block_number\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardAdjustmentPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"baseContract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"transmutedContract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"sourceQuantity\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"destQuantity\",\"type\":\"uint256\"}],\"name\":\"Transmuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_blockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_totalMinedWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_targetDifficultyWei\",\"type\":\"uint256\"}],\"name\":\"MiningAttemptEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_info\",\"type\":\"string\"}],\"name\":\"LogEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_forCreditTo\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_reward\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"BlockClaimedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"Bitcoineum","CompilerVersion":"v0.4.13+commit.fb4cb1a","OptimizationUsed":"1","Runs":"0","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://23a5ec9c898790009860a99e7c78ae01613b6e446e79605bfbb8d51649f2cb4e"}]}