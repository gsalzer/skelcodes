{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.18;\r\n\r\ninterface KyberReserveInterface {\r\n\r\n    function trade(\r\n        ERC20 srcToken,\r\n        uint srcAmount,\r\n        ERC20 destToken,\r\n        address destAddress,\r\n        uint conversionRate,\r\n        bool validate\r\n    )\r\n        public\r\n        payable\r\n        returns(bool);\r\n\r\n    function getConversionRate(ERC20 src, ERC20 dest, uint srcQty, uint blockNumber) public view returns(uint);\r\n}\r\n\r\ncontract Utils {\r\n\r\n    ERC20 constant internal ETH_TOKEN_ADDRESS = ERC20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\r\n    uint  constant internal PRECISION = (10**18);\r\n    uint  constant internal MAX_QTY   = (10**28); // 10B tokens\r\n    uint  constant internal MAX_RATE  = (PRECISION * 10**6); // up to 1M tokens per ETH\r\n    uint  constant internal MAX_DECIMALS = 18;\r\n    uint  constant internal ETH_DECIMALS = 18;\r\n    mapping(address=>uint) internal decimals;\r\n\r\n    function setDecimals(ERC20 token) internal {\r\n        if (token == ETH_TOKEN_ADDRESS) decimals[token] = ETH_DECIMALS;\r\n        else decimals[token] = token.decimals();\r\n    }\r\n\r\n    function getDecimals(ERC20 token) internal view returns(uint) {\r\n        if (token == ETH_TOKEN_ADDRESS) return ETH_DECIMALS; // save storage access\r\n        uint tokenDecimals = decimals[token];\r\n        // technically, there might be token with decimals 0\r\n        // moreover, very possible that old tokens have decimals 0\r\n        // these tokens will just have higher gas fees.\r\n        if(tokenDecimals == 0) return token.decimals();\r\n\r\n        return tokenDecimals;\r\n    }\r\n\r\n    function calcDstQty(uint srcQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\r\n        require(srcQty <= MAX_QTY);\r\n        require(rate <= MAX_RATE);\r\n\r\n        if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\r\n        }\r\n    }\r\n\r\n    function calcSrcQty(uint dstQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\r\n        require(dstQty <= MAX_QTY);\r\n        require(rate <= MAX_RATE);\r\n\r\n        //source quantity is rounded up. to avoid dest quantity being too low.\r\n        uint numerator;\r\n        uint denominator;\r\n        if (srcDecimals >= dstDecimals) {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\r\n            denominator = rate;\r\n        } else {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            numerator = (PRECISION * dstQty);\r\n            denominator = (rate * (10**(dstDecimals - srcDecimals)));\r\n        }\r\n        return (numerator + denominator - 1) / denominator; //avoid rounding down errors\r\n    }\r\n}\r\n\r\ninterface FeeBurnerInterface {\r\n    function handleFees (uint tradeWeiAmount, address reserve, address wallet) public returns(bool);\r\n}\r\n\r\ninterface ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address _owner) public view returns (uint balance);\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n    function approve(address _spender, uint _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public view returns (uint remaining);\r\n    function decimals() public view returns(uint digits);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\ncontract WhiteListInterface {\r\n    function getUserCapInWei(address user) external view returns (uint userCapWei);\r\n}\r\n\r\ncontract PermissionGroups {\r\n\r\n    address public admin;\r\n    address public pendingAdmin;\r\n    mapping(address=>bool) internal operators;\r\n    mapping(address=>bool) internal alerters;\r\n    address[] internal operatorsGroup;\r\n    address[] internal alertersGroup;\r\n\r\n    function PermissionGroups() public {\r\n        admin = msg.sender;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOperator() {\r\n        require(operators[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    modifier onlyAlerter() {\r\n        require(alerters[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    function getOperators () external view returns(address[]) {\r\n        return operatorsGroup;\r\n    }\r\n\r\n    function getAlerters () external view returns(address[]) {\r\n        return alertersGroup;\r\n    }\r\n\r\n    event TransferAdminPending(address pendingAdmin);\r\n\r\n    /**\r\n     * @dev Allows the current admin to set the pendingAdmin address.\r\n     * @param newAdmin The address to transfer ownership to.\r\n     */\r\n    function transferAdmin(address newAdmin) public onlyAdmin {\r\n        require(newAdmin != address(0));\r\n        TransferAdminPending(pendingAdmin);\r\n        pendingAdmin = newAdmin;\r\n    }\r\n\r\n    event AdminClaimed( address newAdmin, address previousAdmin);\r\n\r\n    /**\r\n     * @dev Allows the pendingAdmin address to finalize the change admin process.\r\n     */\r\n    function claimAdmin() public {\r\n        require(pendingAdmin == msg.sender);\r\n        AdminClaimed(pendingAdmin, admin);\r\n        admin = pendingAdmin;\r\n        pendingAdmin = address(0);\r\n    }\r\n\r\n    event AlerterAdded (address newAlerter, bool isAdd);\r\n\r\n    function addAlerter(address newAlerter) public onlyAdmin {\r\n        require(!alerters[newAlerter]); // prevent duplicates.\r\n        AlerterAdded(newAlerter, true);\r\n        alerters[newAlerter] = true;\r\n        alertersGroup.push(newAlerter);\r\n    }\r\n\r\n    function removeAlerter (address alerter) public onlyAdmin {\r\n        require(alerters[alerter]);\r\n        alerters[alerter] = false;\r\n\r\n        for (uint i = 0; i < alertersGroup.length; ++i) {\r\n            if (alertersGroup[i] == alerter) {\r\n                alertersGroup[i] = alertersGroup[alertersGroup.length - 1];\r\n                alertersGroup.length--;\r\n                AlerterAdded(alerter, false);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    event OperatorAdded(address newOperator, bool isAdd);\r\n\r\n    function addOperator(address newOperator) public onlyAdmin {\r\n        require(!operators[newOperator]); // prevent duplicates.\r\n        OperatorAdded(newOperator, true);\r\n        operators[newOperator] = true;\r\n        operatorsGroup.push(newOperator);\r\n    }\r\n\r\n    function removeOperator (address operator) public onlyAdmin {\r\n        require(operators[operator]);\r\n        operators[operator] = false;\r\n\r\n        for (uint i = 0; i < operatorsGroup.length; ++i) {\r\n            if (operatorsGroup[i] == operator) {\r\n                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\r\n                operatorsGroup.length -= 1;\r\n                OperatorAdded(operator, false);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract Withdrawable is PermissionGroups {\r\n\r\n    event TokenWithdraw(ERC20 token, uint amount, address sendTo);\r\n\r\n    /**\r\n     * @dev Withdraw all ERC20 compatible tokens\r\n     * @param token ERC20 The address of the token contract\r\n     */\r\n    function withdrawToken(ERC20 token, uint amount, address sendTo) external onlyAdmin {\r\n        require(token.transfer(sendTo, amount));\r\n        TokenWithdraw(token, amount, sendTo);\r\n    }\r\n\r\n    event EtherWithdraw(uint amount, address sendTo);\r\n\r\n    /**\r\n     * @dev Withdraw Ethers\r\n     */\r\n    function withdrawEther(uint amount, address sendTo) external onlyAdmin {\r\n        sendTo.transfer(amount);\r\n        EtherWithdraw(amount, sendTo);\r\n    }\r\n}\r\n\r\ninterface ExpectedRateInterface {\r\n    function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty) public view\r\n        returns (uint expectedRate, uint slippageRate);\r\n}\r\n\r\ncontract ExpectedRate is Withdrawable, ExpectedRateInterface {\r\n\r\n    KyberNetwork public kyberNetwork;\r\n    uint public quantityFactor = 2;\r\n    uint public minSlippageFactorInBps = 50;\r\n\r\n    function ExpectedRate(KyberNetwork _kyberNetwork, address _admin) public {\r\n        require(_admin != address(0));\r\n        require(_kyberNetwork != address(0));\r\n        kyberNetwork = _kyberNetwork;\r\n        admin = _admin;\r\n    }\r\n\r\n    event QuantityFactorSet (uint newFactor, uint oldFactor, address sender);\r\n\r\n    function setQuantityFactor(uint newFactor) public onlyOperator {\r\n        QuantityFactorSet(quantityFactor, newFactor, msg.sender);\r\n        quantityFactor = newFactor;\r\n    }\r\n\r\n    event MinSlippageFactorSet (uint newMin, uint oldMin, address sender);\r\n\r\n    function setMinSlippageFactor(uint bps) public onlyOperator {\r\n        MinSlippageFactorSet(bps, minSlippageFactorInBps, msg.sender);\r\n        minSlippageFactorInBps = bps;\r\n    }\r\n\r\n    function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty)\r\n        public view\r\n        returns (uint expectedRate, uint slippageRate)\r\n    {\r\n        require(quantityFactor != 0);\r\n\r\n        uint bestReserve;\r\n        uint minSlippage;\r\n\r\n        (bestReserve, expectedRate) = kyberNetwork.findBestRate(src, dest, srcQty);\r\n        (bestReserve, slippageRate) = kyberNetwork.findBestRate(src, dest, (srcQty * quantityFactor));\r\n\r\n        minSlippage = ((10000 - minSlippageFactorInBps) * expectedRate) / 10000;\r\n        if (slippageRate >= minSlippage) {\r\n            slippageRate = minSlippage;\r\n        }\r\n\r\n        return (expectedRate, slippageRate);\r\n    }\r\n}\r\n\r\ncontract KyberNetwork is Withdrawable, Utils {\r\n\r\n    uint public negligibleRateDiff = 10; // basic rate steps will be in 0.01%\r\n    KyberReserveInterface[] public reserves;\r\n    mapping(address=>bool) public isReserve;\r\n    WhiteListInterface public whiteListContract;\r\n    ExpectedRateInterface public expectedRateContract;\r\n    FeeBurnerInterface    public feeBurnerContract;\r\n    uint                  public maxGasPrice = 50 * 1000 * 1000 * 1000; // 50 gwei\r\n    bool                  public enabled = false; // network is enabled\r\n    mapping(address=>mapping(bytes32=>bool)) public perReserveListedPairs;\r\n\r\n    function KyberNetwork(address _admin) public {\r\n        require(_admin != address(0));\r\n        admin = _admin;\r\n    }\r\n\r\n    event EtherReceival(address indexed sender, uint amount);\r\n\r\n    /* solhint-disable no-complex-fallback */\r\n    function() public payable {\r\n        require(isReserve[msg.sender]);\r\n        EtherReceival(msg.sender, msg.value);\r\n    }\r\n    /* solhint-enable no-complex-fallback */\r\n\r\n    event ExecuteTrade(address indexed sender, ERC20 src, ERC20 dest, uint actualSrcAmount, uint actualDestAmount);\r\n\r\n    /// @notice use token address ETH_TOKEN_ADDRESS for ether\r\n    /// @dev makes a trade between src and dest token and send dest token to destAddress\r\n    /// @param src Src token\r\n    /// @param srcAmount amount of src tokens\r\n    /// @param dest   Destination token\r\n    /// @param destAddress Address to send tokens to\r\n    /// @param maxDestAmount A limit on the amount of dest tokens\r\n    /// @param minConversionRate The minimal conversion rate. If actual rate is lower, trade is canceled.\r\n    /// @param walletId is the wallet ID to send part of the fees\r\n    /// @return amount of actual dest tokens\r\n    function trade(\r\n        ERC20 src,\r\n        uint srcAmount,\r\n        ERC20 dest,\r\n        address destAddress,\r\n        uint maxDestAmount,\r\n        uint minConversionRate,\r\n        address walletId\r\n    )\r\n        public\r\n        payable\r\n        returns(uint)\r\n    {\r\n        require(enabled);\r\n\r\n        uint userSrcBalanceBefore;\r\n        uint userSrcBalanceAfter;\r\n        uint userDestBalanceBefore;\r\n        uint userDestBalanceAfter;\r\n\r\n        userSrcBalanceBefore = getBalance(src, msg.sender);\r\n        if (src == ETH_TOKEN_ADDRESS)\r\n            userSrcBalanceBefore += msg.value;\r\n        userDestBalanceBefore = getBalance(dest, destAddress);\r\n\r\n        uint actualDestAmount = doTrade(src,\r\n                                        srcAmount,\r\n                                        dest,\r\n                                        destAddress,\r\n                                        maxDestAmount,\r\n                                        minConversionRate,\r\n                                        walletId\r\n                                        );\r\n        require(actualDestAmount > 0);\r\n\r\n        userSrcBalanceAfter = getBalance(src, msg.sender);\r\n        userDestBalanceAfter = getBalance(dest, destAddress);\r\n\r\n        require(userSrcBalanceAfter <= userSrcBalanceBefore);\r\n        require(userDestBalanceAfter >= userDestBalanceBefore);\r\n\r\n        require((userDestBalanceAfter - userDestBalanceBefore) >=\r\n            calcDstQty((userSrcBalanceBefore - userSrcBalanceAfter), getDecimals(src), getDecimals(dest),\r\n                minConversionRate));\r\n\r\n        return actualDestAmount;\r\n    }\r\n\r\n    event AddReserveToNetwork(KyberReserveInterface reserve, bool add);\r\n\r\n    /// @notice can be called only by admin\r\n    /// @dev add or deletes a reserve to/from the network.\r\n    /// @param reserve The reserve address.\r\n    /// @param add If true, the add reserve. Otherwise delete reserve.\r\n    function addReserve(KyberReserveInterface reserve, bool add) public onlyAdmin {\r\n\r\n        if (add) {\r\n            require(!isReserve[reserve]);\r\n            reserves.push(reserve);\r\n            isReserve[reserve] = true;\r\n            AddReserveToNetwork(reserve, true);\r\n        } else {\r\n            isReserve[reserve] = false;\r\n            // will have trouble if more than 50k reserves...\r\n            for (uint i = 0; i < reserves.length; i++) {\r\n                if (reserves[i] == reserve) {\r\n                    reserves[i] = reserves[reserves.length - 1];\r\n                    reserves.length--;\r\n                    AddReserveToNetwork(reserve, false);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    event ListReservePairs(address reserve, ERC20 src, ERC20 dest, bool add);\r\n\r\n    /// @notice can be called only by admin\r\n    /// @dev allow or prevent a specific reserve to trade a pair of tokens\r\n    /// @param reserve The reserve address.\r\n    /// @param src Src token\r\n    /// @param dest Destination token\r\n    /// @param add If true then enable trade, otherwise delist pair.\r\n    function listPairForReserve(address reserve, ERC20 src, ERC20 dest, bool add) public onlyAdmin {\r\n        (perReserveListedPairs[reserve])[keccak256(src, dest)] = add;\r\n\r\n        if (src != ETH_TOKEN_ADDRESS) {\r\n            if (add) {\r\n                src.approve(reserve, 2**255); // approve infinity\r\n            } else {\r\n                src.approve(reserve, 0);\r\n            }\r\n        }\r\n\r\n        setDecimals(src);\r\n        setDecimals(dest);\r\n\r\n        ListReservePairs(reserve, src, dest, add);\r\n    }\r\n\r\n    function setParams(\r\n        WhiteListInterface    _whiteList,\r\n        ExpectedRateInterface _expectedRate,\r\n        FeeBurnerInterface    _feeBurner,\r\n        uint                  _maxGasPrice,\r\n        uint                  _negligibleRateDiff\r\n    )\r\n        public\r\n        onlyAdmin\r\n    {\r\n        require(_whiteList != address(0));\r\n        require(_feeBurner != address(0));\r\n        require(_expectedRate != address(0));\r\n        whiteListContract = _whiteList;\r\n        expectedRateContract = _expectedRate;\r\n        feeBurnerContract = _feeBurner;\r\n        maxGasPrice = _maxGasPrice;\r\n        negligibleRateDiff = _negligibleRateDiff;\r\n    }\r\n\r\n    function setEnable(bool _enable) public onlyAdmin {\r\n        if (_enable) {\r\n            require(whiteListContract != address(0));\r\n            require(feeBurnerContract != address(0));\r\n            require(expectedRateContract != address(0));\r\n        }\r\n        enabled = _enable;\r\n    }\r\n\r\n    /// @dev returns number of reserves\r\n    /// @return number of reserves\r\n    function getNumReserves() public view returns(uint) {\r\n        return reserves.length;\r\n    }\r\n\r\n    /// @notice should be called off chain with as much gas as needed\r\n    /// @dev get an array of all reserves\r\n    /// @return An array of all reserves\r\n    function getReserves() public view returns(KyberReserveInterface[]) {\r\n        return reserves;\r\n    }\r\n\r\n    /// @dev get the balance of a user.\r\n    /// @param token The token type\r\n    /// @return The balance\r\n    function getBalance(ERC20 token, address user) public view returns(uint) {\r\n        if (token == ETH_TOKEN_ADDRESS)\r\n            return user.balance;\r\n        else\r\n            return token.balanceOf(user);\r\n    }\r\n\r\n    /// @notice use token address ETH_TOKEN_ADDRESS for ether\r\n    /// @dev best conversion rate for a pair of tokens, if number of reserves have small differences. randomize\r\n    /// @param src Src token\r\n    /// @param dest Destination token\r\n    /* solhint-disable code-complexity */\r\n    function findBestRate(ERC20 src, ERC20 dest, uint srcQty) public view returns(uint, uint) {\r\n        uint bestRate = 0;\r\n        uint bestReserve = 0;\r\n        uint numRelevantReserves = 0;\r\n        uint numReserves = reserves.length;\r\n        uint[] memory rates = new uint[](numReserves);\r\n        uint[] memory reserveCandidates = new uint[](numReserves);\r\n\r\n        for (uint i = 0; i < numReserves; i++) {\r\n            //list all reserves that have this token.\r\n            if (!(perReserveListedPairs[reserves[i]])[keccak256(src, dest)]) continue;\r\n\r\n            rates[i] = reserves[i].getConversionRate(src, dest, srcQty, block.number);\r\n\r\n            if (rates[i] > bestRate) {\r\n                //best rate is highest rate\r\n                bestRate = rates[i];\r\n            }\r\n        }\r\n\r\n        if (bestRate > 0) {\r\n            uint random = 0;\r\n            uint smallestRelevantRate = (bestRate * 10000) / (10000 + negligibleRateDiff);\r\n\r\n            for (i = 0; i < numReserves; i++) {\r\n                if (rates[i] >= smallestRelevantRate) {\r\n                    reserveCandidates[numRelevantReserves++] = i;\r\n                }\r\n            }\r\n\r\n            if (numRelevantReserves > 1) {\r\n                //when encountering small rate diff from bestRate. draw from relevant reserves\r\n                random = uint(block.blockhash(block.number-1)) % numRelevantReserves;\r\n            }\r\n\r\n            bestReserve = reserveCandidates[random];\r\n            bestRate = rates[bestReserve];\r\n        }\r\n\r\n        return (bestReserve, bestRate);\r\n    }\r\n    /* solhint-enable code-complexity */\r\n\r\n    function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty)\r\n        public view\r\n        returns (uint expectedRate, uint slippageRate)\r\n    {\r\n        require(expectedRateContract != address(0));\r\n        return expectedRateContract.getExpectedRate(src, dest, srcQty);\r\n    }\r\n\r\n    function getUserCapInWei(address user) public view returns(uint) {\r\n        return whiteListContract.getUserCapInWei(user);\r\n    }\r\n\r\n    function doTrade(\r\n        ERC20 src,\r\n        uint srcAmount,\r\n        ERC20 dest,\r\n        address destAddress,\r\n        uint maxDestAmount,\r\n        uint minConversionRate,\r\n        address walletId\r\n    )\r\n        internal\r\n        returns(uint)\r\n    {\r\n        require(tx.gasprice <= maxGasPrice);\r\n        require(validateTradeInput(src, srcAmount, destAddress));\r\n\r\n        uint reserveInd;\r\n        uint rate;\r\n\r\n        (reserveInd, rate) = findBestRate(src, dest, srcAmount);\r\n        KyberReserveInterface theReserve = reserves[reserveInd];\r\n        require(rate > 0);\r\n        require(rate < MAX_RATE);\r\n        require(rate >= minConversionRate);\r\n\r\n        uint actualSrcAmount = srcAmount;\r\n        uint actualDestAmount = calcDestAmount(src, dest, actualSrcAmount, rate);\r\n        if (actualDestAmount > maxDestAmount) {\r\n            actualDestAmount = maxDestAmount;\r\n            actualSrcAmount = calcSrcAmount(src, dest, actualDestAmount, rate);\r\n            require(actualSrcAmount <= srcAmount);\r\n        }\r\n\r\n        // do the trade\r\n        // verify trade size is smaller than user cap\r\n        uint ethAmount;\r\n        if (src == ETH_TOKEN_ADDRESS) {\r\n            ethAmount = actualSrcAmount;\r\n        } else {\r\n            ethAmount = actualDestAmount;\r\n        }\r\n\r\n        require(ethAmount <= getUserCapInWei(msg.sender));\r\n        require(doReserveTrade(\r\n                src,\r\n                actualSrcAmount,\r\n                dest,\r\n                destAddress,\r\n                actualDestAmount,\r\n                theReserve,\r\n                rate,\r\n                true));\r\n\r\n        if ((actualSrcAmount < srcAmount) && (src == ETH_TOKEN_ADDRESS)) {\r\n            msg.sender.transfer(srcAmount - actualSrcAmount);\r\n        }\r\n\r\n        require(feeBurnerContract.handleFees(ethAmount, theReserve, walletId));\r\n\r\n        ExecuteTrade(msg.sender, src, dest, actualSrcAmount, actualDestAmount);\r\n        return actualDestAmount;\r\n    }\r\n\r\n    /// @notice use token address ETH_TOKEN_ADDRESS for ether\r\n    /// @dev do one trade with a reserve\r\n    /// @param src Src token\r\n    /// @param amount amount of src tokens\r\n    /// @param dest   Destination token\r\n    /// @param destAddress Address to send tokens to\r\n    /// @param reserve Reserve to use\r\n    /// @param validate If true, additional validations are applicable\r\n    /// @return true if trade is successful\r\n    function doReserveTrade(\r\n        ERC20 src,\r\n        uint amount,\r\n        ERC20 dest,\r\n        address destAddress,\r\n        uint expectedDestAmount,\r\n        KyberReserveInterface reserve,\r\n        uint conversionRate,\r\n        bool validate\r\n    )\r\n        internal\r\n        returns(bool)\r\n    {\r\n        uint callValue = 0;\r\n\r\n        if (src == ETH_TOKEN_ADDRESS) {\r\n            callValue = amount;\r\n        } else {\r\n            // take src tokens to this contract\r\n            src.transferFrom(msg.sender, this, amount);\r\n        }\r\n\r\n        // reserve sends tokens/eth to network. network sends it to destination\r\n        require(reserve.trade.value(callValue)(src, amount, dest, this, conversionRate, validate));\r\n\r\n        if (dest == ETH_TOKEN_ADDRESS) {\r\n            destAddress.transfer(expectedDestAmount);\r\n        } else {\r\n            require(dest.transfer(destAddress, expectedDestAmount));\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function calcDestAmount(ERC20 src, ERC20 dest, uint srcAmount, uint rate) internal view returns(uint) {\r\n        return calcDstQty(srcAmount, getDecimals(src), getDecimals(dest), rate);\r\n    }\r\n\r\n    function calcSrcAmount(ERC20 src, ERC20 dest, uint destAmount, uint rate) internal view returns(uint) {\r\n        return calcSrcQty(destAmount, getDecimals(src), getDecimals(dest), rate);\r\n    }\r\n\r\n    /// @notice use token address ETH_TOKEN_ADDRESS for ether\r\n    /// @dev checks that user sent ether/tokens to contract before trade\r\n    /// @param src Src token\r\n    /// @param srcAmount amount of src tokens\r\n    /// @return true if input is valid\r\n    function validateTradeInput(ERC20 src, uint srcAmount, address destAddress) internal view returns(bool) {\r\n        if ((srcAmount >= MAX_QTY) || (srcAmount == 0) || (destAddress == 0))\r\n            return false;\r\n\r\n        if (src == ETH_TOKEN_ADDRESS) {\r\n            if (msg.value != srcAmount)\r\n                return false;\r\n        } else {\r\n            if ((msg.value != 0) || (src.allowance(msg.sender, this) < srcAmount))\r\n                return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"alerter\",\"type\":\"address\"}],\"name\":\"removeAlerter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOperators\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAlerter\",\"type\":\"address\"}],\"name\":\"addAlerter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newFactor\",\"type\":\"uint256\"}],\"name\":\"setQuantityFactor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAlerters\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"src\",\"type\":\"address\"},{\"name\":\"dest\",\"type\":\"address\"},{\"name\":\"srcQty\",\"type\":\"uint256\"}],\"name\":\"getExpectedRate\",\"outputs\":[{\"name\":\"expectedRate\",\"type\":\"uint256\"},{\"name\":\"slippageRate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"bps\",\"type\":\"uint256\"}],\"name\":\"setMinSlippageFactor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"addOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"quantityFactor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"removeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kyberNetwork\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minSlippageFactorInBps\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_kyberNetwork\",\"type\":\"address\"},{\"name\":\"_admin\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newFactor\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"oldFactor\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"QuantityFactorSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newMin\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"oldMin\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"MinSlippageFactorSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"TokenWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"EtherWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"pendingAdmin\",\"type\":\"address\"}],\"name\":\"TransferAdminPending\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newAdmin\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"previousAdmin\",\"type\":\"address\"}],\"name\":\"AdminClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newAlerter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"isAdd\",\"type\":\"bool\"}],\"name\":\"AlerterAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOperator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"isAdd\",\"type\":\"bool\"}],\"name\":\"OperatorAdded\",\"type\":\"event\"}]","ContractName":"ExpectedRate","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000002e3090c13a545d37f3d8c1158040e6b6dc229e580000000000000000000000001e1fc48948be993828a1a1e1f7e41d0a7be28930","Library":"","SwarmSource":"bzzr://2bc3fadf411e52e83f394dc20ed68bf450f4005c0eb921283f3df7289d885365"}]}