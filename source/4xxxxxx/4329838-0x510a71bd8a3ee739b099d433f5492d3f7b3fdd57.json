{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.16;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\ncontract ERC20 {\r\n\tfunction totalSupply() constant returns (uint totalSupply);\r\n\tfunction balanceOf(address _owner) constant returns (uint balance);\r\n\tfunction transfer(address _to, uint _value) returns (bool success);\r\n\tfunction transferFrom(address _from, address _to, uint _value) returns (bool success);\r\n\tfunction approve(address _spender, uint _value) returns (bool success);\r\n\tfunction allowance(address _owner, address _spender) constant returns (uint remaining);\r\n    // This generates a public event on the blockchain that will notify clients\r\n\tevent Transfer(address indexed _from, address indexed _to, uint _value);\r\n\tevent Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\n//Token with owner (admin)\r\ncontract OwnedToken {\r\n\taddress public owner; //contract owner (admin) address\r\n\tfunction OwnedToken () public {\r\n\t\towner = msg.sender;\r\n\t}\r\n\t//Check if owner initiate call\r\n    modifier onlyOwner()\r\n    {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Transfer ownership\r\n     *\r\n     * @param newOwner The address of the new contract owner\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n//Contract with name\r\ncontract NamedOwnedToken is OwnedToken {\r\n\tstring public name; //the name for display purposes\r\n\tstring public symbol; //the symbol for display purposes\r\n\tfunction NamedOwnedToken(string tokenName, string tokenSymbol) public\r\n\t{\r\n        name = tokenName;                                   // Set the name for display purposes\r\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\r\n\t}\r\n\r\n    /**\r\n     * Change name and symbol\r\n     *\r\n     * @param newName The new contract name\r\n     * @param newSymbol The new contract symbol \r\n     */\r\n    function changeName(string newName, string newSymbol)public onlyOwner {\r\n\t\tname = newName;\r\n\t\tsymbol = newSymbol;\r\n    }\r\n}\r\n\r\ncontract TSBToken is ERC20, NamedOwnedToken {\r\n\tusing SafeMath for uint256;\r\n\r\n    // Public variables of the token\r\n\r\n    uint256 public _totalSupply = 0; //Total number of token issued (1 token = 10^decimals)\r\n\tuint8 public decimals = 18; //Decimals, each 1 token = 10^decimals\r\n\r\n    \r\n    mapping (address => uint256) public balances; // A map with all balances\r\n    mapping (address => mapping (address => uint256)) public allowed; //Implement allowence to support ERC20\r\n\r\n    mapping (address => uint256) public paidETH; //The sum have already been paid to token owner\r\n\tuint256 public accrueDividendsPerXTokenETH = 0;\r\n\tuint256 public tokenPriceETH = 0;\r\n\r\n    mapping (address => uint256) public paydCouponsETH;\r\n\tuint256 public accrueCouponsPerXTokenETH = 0;\r\n\tuint256 public totalCouponsUSD = 0;\r\n\tuint256 public MaxCouponsPaymentUSD = 150000;\r\n\r\n\tmapping (address => uint256) public rebuySum;\r\n\tmapping (address => uint256) public rebuyInformTime;\r\n\r\n\r\n\tuint256 public endSaleTime;\r\n\tuint256 public startRebuyTime;\r\n\tuint256 public reservedSum;\r\n\tbool public rebuyStarted = false;\r\n\r\n\tuint public tokenDecimals;\r\n\tuint public tokenDecimalsLeft;\r\n\r\n    /**\r\n     * Constructor function\r\n     *\r\n     * Initializes contract\r\n     */\r\n    function TSBToken(\r\n        string tokenName,\r\n        string tokenSymbol\r\n    ) NamedOwnedToken(tokenName, tokenSymbol) public {\r\n\t\ttokenDecimals = 10**uint256(decimals - 5);\r\n\t\ttokenDecimalsLeft = 10**5;\r\n\t\tstartRebuyTime = now + 1 years;\r\n\t\tendSaleTime = now;\r\n    }\r\n\r\n    /**\r\n     * Internal function, calc dividends to transfer when tokens are transfering to another wallet\r\n     */\r\n\tfunction transferDiv(uint startTokens, uint fromTokens, uint toTokens, uint sumPaydFrom, uint sumPaydTo, uint acrued) internal constant returns (uint, uint) {\r\n\t\tuint sumToPayDividendsFrom = fromTokens.mul(acrued);\r\n\t\tuint sumToPayDividendsTo = toTokens.mul(acrued);\r\n\t\tuint sumTransfer = sumPaydFrom.div(startTokens);\r\n\t\tsumTransfer = sumTransfer.mul(startTokens-fromTokens);\r\n\t\tif (sumPaydFrom > sumTransfer) {\r\n\t\t\tsumPaydFrom -= sumTransfer;\r\n\t\t\tif (sumPaydFrom > sumToPayDividendsFrom) {\r\n\t\t\t\tsumTransfer += sumPaydFrom - sumToPayDividendsFrom;\r\n\t\t\t\tsumPaydFrom = sumToPayDividendsFrom;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tsumTransfer = sumPaydFrom;\r\n\t\t\tsumPaydFrom = 0;\r\n\t\t}\r\n\t\tsumPaydTo = sumPaydTo.add(sumTransfer);\r\n\t\tif (sumPaydTo > sumToPayDividendsTo) {\r\n\t\t\tuint differ = sumPaydTo - sumToPayDividendsTo;\r\n\t\t\tsumPaydTo = sumToPayDividendsTo;\r\n\t\t\tsumPaydFrom = sumPaydFrom.add(differ);\r\n\t\t\tif (sumPaydFrom > sumToPayDividendsFrom) {\r\n\t\t\t\tsumPaydFrom = sumToPayDividendsFrom;\r\n\t\t\t} \r\n\t\t}\r\n\t\treturn (sumPaydFrom, sumPaydTo);\r\n\t}\r\n\r\n\r\n\r\n    /**\r\n     * Internal transfer, only can be called by this contract\r\n     */\r\n    function _transfer(address _from, address _to, uint _value) internal {\r\n        require(_to != address(0));                               // Prevent transfer to 0x0 address. Use burn() instead\r\n        require(balances[_from] >= _value);                // Check if the sender has enough\r\n        require(balances[_to] + _value > balances[_to]); // Check for overflows\r\n\t\tuint startTokens = balances[_from].div(tokenDecimals);\r\n        balances[_from] -= _value;                         // Subtract from the sender\r\n        balances[_to] += _value;                           // Add the same to the recipient\r\n\r\n\t\tif (balances[_from] == 0) {\r\n\t\t\tpaidETH[_to] = paidETH[_to].add(paidETH[_from]);\r\n\t\t} else {\r\n\t\t\tuint fromTokens = balances[_from].div(tokenDecimals);\r\n\t\t\tuint toTokens = balances[_to].div(tokenDecimals);\r\n\t\t\t(paidETH[_from], paidETH[_to]) = transferDiv(startTokens, fromTokens, toTokens, paidETH[_from], paidETH[_to], accrueDividendsPerXTokenETH+accrueCouponsPerXTokenETH);\r\n\t\t}\r\n        Transfer(_from, _to, _value);\r\n    }\r\n\r\n    /**\r\n     * Transfer tokens\r\n     *\r\n     * Send `_value` tokens to `_to` from your account\r\n     *\r\n     * @param _to The address of the recipient\r\n     * @param _value the amount to send\r\n     */\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        _transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Balance of tokens\r\n     *\r\n     * @param _owner The address of token wallet\r\n     */\r\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance) {\r\n\t\treturn balances[_owner];\r\n\t}\r\n\r\n    /**\r\n     * Returns total issued tokens number\r\n     *\r\n\t*/\r\n\tfunction totalSupply() public constant returns (uint totalSupply) {\r\n\t\treturn _totalSupply;\r\n\t}\r\n\r\n\r\n    /**\r\n     * Transfer tokens from other address\r\n     *\r\n     * Send `_value` tokens to `_to` in behalf of `_from`\r\n     *\r\n     * @param _from The address of the sender\r\n     * @param _to The address of the recipient\r\n     * @param _value the amount to send\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        require(_value <= allowed[_from][msg.sender]);     // Check allowance\r\n        allowed[_from][msg.sender] -= _value;\r\n        _transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set allowance for other address\r\n     *\r\n     * Allows `_spender` to spend no more than `_value` tokens in your behalf\r\n     *\r\n     * @param _spender The address authorized to spend\r\n     * @param _value the max amount they can spend\r\n     */\r\n    function approve(address _spender, uint256 _value) public\r\n        returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Check allowance for address\r\n     *\r\n     * @param _owner The address who authorize to spend\r\n     * @param _spender The address authorized to spend\r\n     */\r\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n\t\treturn allowed[_owner][_spender];\r\n\t}\r\n\r\n\r\n\t// This notifies clients about the amount burnt\r\n    event Burn(address indexed from, uint256 value);\r\n\r\n    /**\r\n     * Internal function destroy tokens\r\n     */\r\n    function burnTo(uint256 _value, address adr) internal returns (bool success) {\r\n        require(balances[adr] >= _value);   // Check if the sender has enough\r\n        require(_value > 0);   // Check if the sender has enough\r\n\t\tuint startTokens = balances[adr].div(tokenDecimals);\r\n        balances[adr] -= _value;            // Subtract from the sender\r\n\t\tuint endTokens = balances[adr].div(tokenDecimals);\r\n\r\n\t\tuint sumToPayFrom = endTokens.mul(accrueDividendsPerXTokenETH + accrueCouponsPerXTokenETH);\r\n\t\tuint divETH = paidETH[adr].div(startTokens);\r\n\t\tdivETH = divETH.mul(endTokens);\r\n\t\tif (divETH > sumToPayFrom) {\r\n\t\t\tpaidETH[adr] = sumToPayFrom;\r\n\t\t} else {\r\n\t\t\tpaidETH[adr] = divETH;\r\n\t\t}\r\n\r\n\t\t_totalSupply -= _value;                      // Updates totalSupply\r\n        Burn(adr, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Delete tokens tokens during the end of croudfunding \r\n     * (in case of errors made by crowdfnuding participants)\r\n     * Only owner could call\r\n     */\r\n    function deleteTokens(address adr, uint256 amount) public onlyOwner canMint {\r\n        burnTo(amount, adr);\r\n    }\r\n\r\n\tbool public mintingFinished = false;\r\n\tevent Mint(address indexed to, uint256 amount);\r\n\tevent MintFinished();\r\n\r\n\t//Check if it is possible to mint new tokens (mint allowed only during croudfunding)\r\n\tmodifier canMint() {\r\n\t\trequire(!mintingFinished);\r\n\t\t_;\r\n\t}\r\n\t\r\n\tfunction () public payable {\r\n\t}\r\n\r\n\t//Withdraw unused ETH from contract to owner\r\n\tfunction WithdrawLeftToOwner(uint sum) public onlyOwner {\r\n\t    owner.transfer(sum);\r\n\t}\r\n\t\r\n    /**\r\n     * Mint additional tokens at the end of croudfunding\r\n     */\r\n\tfunction mintToken(address target, uint256 mintedAmount) public onlyOwner canMint  {\r\n\t\tbalances[target] += mintedAmount;\r\n\t\tuint tokensInX = mintedAmount.div(tokenDecimals);\r\n\t\tpaidETH[target] += tokensInX.mul(accrueDividendsPerXTokenETH + accrueCouponsPerXTokenETH);\r\n\t\t_totalSupply += mintedAmount;\r\n\t\tMint(owner, mintedAmount);\r\n\t\tTransfer(0x0, target, mintedAmount);\r\n\t}\r\n\r\n    /**\r\n     * Finish minting\r\n     */\r\n\tfunction finishMinting() public onlyOwner returns (bool) {\r\n\t\tmintingFinished = true;\r\n\t\tendSaleTime = now;\r\n\t\tstartRebuyTime = endSaleTime + (180 * 1 days);\r\n\t\tMintFinished();\r\n\t\treturn true;\r\n\t}\r\n\r\n    /**\r\n     * Withdraw accrued dividends and coupons\r\n     */\r\n\tfunction WithdrawDividendsAndCoupons() public {\r\n\t\twithdrawTo(msg.sender,0);\r\n\t}\r\n\r\n    /**\r\n     * Owner could initiate a withdrawal of accrued dividends and coupons to some address (in purpose to help users)\r\n     */\r\n\tfunction WithdrawDividendsAndCouponsTo(address _sendadr) public onlyOwner {\r\n\t\twithdrawTo(_sendadr, tx.gasprice * block.gaslimit);\r\n\t}\r\n\r\n    /**\r\n     * Internal function to withdraw accrued dividends and coupons\r\n     */\r\n\tfunction withdrawTo(address _sendadr, uint comiss) internal {\r\n\t\tuint tokensPerX = balances[_sendadr].div(tokenDecimals);\r\n\t\tuint sumPayd = paidETH[_sendadr];\r\n\t\tuint sumToPayRes = tokensPerX.mul(accrueCouponsPerXTokenETH+accrueDividendsPerXTokenETH);\r\n\t\tuint sumToPay = sumToPayRes.sub(comiss);\r\n\t\trequire(sumToPay>sumPayd);\r\n\t\tsumToPay = sumToPay.sub(sumPayd);\r\n\t\t_sendadr.transfer(sumToPay);\r\n\t\tpaidETH[_sendadr] = sumToPayRes;\r\n\t}\r\n\r\n    /**\r\n     * Owner accrue new sum of dividends and coupons (once per month)\r\n     */\r\n\tfunction accrueDividendandCoupons(uint sumDivFinney, uint sumFinneyCoup) public onlyOwner {\r\n\t\tsumDivFinney = sumDivFinney * 1 finney;\r\n\t\tsumFinneyCoup = sumFinneyCoup * 1 finney;\r\n\t\tuint tokens = _totalSupply.div(tokenDecimals);\r\n\t\taccrueDividendsPerXTokenETH = accrueDividendsPerXTokenETH.add(sumDivFinney.div(tokens));\r\n\t\taccrueCouponsPerXTokenETH = accrueCouponsPerXTokenETH.add(sumFinneyCoup.div(tokens));\r\n\t}\r\n\r\n    /**\r\n     * Set a price of token to rebuy\r\n     */\r\n\tfunction setTokenPrice(uint priceFinney) public onlyOwner {\r\n\t\ttokenPriceETH = priceFinney * 1 finney;\r\n\t}\r\n\r\n\tevent RebuyInformEvent(address indexed adr, uint256 amount);\r\n\r\n    /**\r\n     * Inform owner that someone whant to sell tokens\r\n     * The rebuy proccess allowed in 2 weeks after inform\r\n     * Only after half a year after croudfunding\r\n     */\r\n\tfunction InformRebuy(uint sum) public {\r\n\t\t_informRebuyTo(sum, msg.sender);\r\n\t}\r\n\r\n\tfunction InformRebuyTo(uint sum, address adr) public onlyOwner{\r\n\t\t_informRebuyTo(sum, adr);\r\n\t}\r\n\r\n\tfunction _informRebuyTo(uint sum, address adr) internal{\r\n\t\trequire (rebuyStarted || (now >= startRebuyTime));\r\n\t\trequire (sum <= balances[adr]);\r\n\t\trebuyInformTime[adr] = now;\r\n\t\trebuySum[adr] = sum;\r\n\t\tRebuyInformEvent(adr, sum);\r\n\t}\r\n\r\n    /**\r\n     * Owner could allow rebuy proccess early\r\n     */\r\n\tfunction StartRebuy() public onlyOwner{\r\n\t\trebuyStarted = true;\r\n\t}\r\n\r\n    /**\r\n    * Sell tokens after 2 weeks from information\r\n    */\r\n\tfunction doRebuy() public {\r\n\t\t_doRebuyTo(msg.sender, 0);\r\n\t}\r\n    /**\r\n    * Contract owner would perform tokens rebuy after 2 weeks from information\r\n    */\r\n\tfunction doRebuyTo(address adr) public onlyOwner {\r\n\t\t_doRebuyTo(adr, tx.gasprice * block.gaslimit);\r\n\t}\r\n\tfunction _doRebuyTo(address adr, uint comiss) internal {\r\n\t\trequire (rebuyStarted || (now >= startRebuyTime));\r\n\t\trequire (now >= rebuyInformTime[adr].add(14 days));\r\n\t\tuint sum = rebuySum[adr];\r\n\t\trequire (sum <= balances[adr]);\r\n\t\twithdrawTo(adr, 0);\r\n\t\tif (burnTo(sum, adr)) {\r\n\t\t\tsum = sum.div(tokenDecimals);\r\n\t\t\tsum = sum.mul(tokenPriceETH);\r\n\t\t\tsum = sum.div(tokenDecimalsLeft);\r\n\t\t\tsum = sum.sub(comiss);\r\n\t\t\tadr.transfer(sum);\r\n\t\t\trebuySum[adr] = 0;\r\n\t\t}\r\n\t}\r\n\r\n}\r\n\r\ncontract TSBCrowdFundingContract is NamedOwnedToken{\r\n\tusing SafeMath for uint256;\r\n\r\n\r\n\tenum CrowdSaleState {NotFinished, Success, Failure}\r\n\tCrowdSaleState public crowdSaleState = CrowdSaleState.NotFinished;\r\n\r\n\r\n    uint public fundingGoalUSD = 200000; //Min cap\r\n    uint public fundingMaxCapUSD = 500000; //Max cap\r\n    uint public priceUSD = 1; //Price in USD per 1 token\r\n\tuint public USDDecimals = 1 ether;\r\n\r\n\tuint public startTime; //crowdfunding start time\r\n    uint public endTime; //crowdfunding end time\r\n    uint public bonusEndTime; //crowdfunding end of bonus time\r\n    uint public selfDestroyTime = 2 weeks;\r\n    TSBToken public tokenReward; //TSB Token to send\r\n\t\r\n\tuint public ETHPrice = 30000; //Current price of one ETH in USD cents\r\n\tuint public BTCPrice = 400000; //Current price of one BTC in USD cents\r\n\tuint public PriceDecimals = 100;\r\n\r\n\tuint public ETHCollected = 0; //Collected sum of ETH\r\n\tuint public BTCCollected = 0; //Collected sum of BTC\r\n\tuint public amountRaisedUSD = 0; //Collected sum in USD\r\n\tuint public TokenAmountToPay = 0; //Number of tokens to distribute (excluding bonus tokens)\r\n\r\n\tmapping(address => uint256) public balanceMapPos;\r\n\tstruct mapStruct {\r\n\t\taddress mapAddress;\r\n\t\tuint mapBalanceETH;\r\n\t\tuint mapBalanceBTC;\r\n\t\tuint bonusTokens;\r\n\t}\r\n\tmapStruct[] public balanceList; //Array of struct with information about invested sums\r\n\r\n    uint public bonusCapUSD = 100000; //Bonus cap\r\n\tmapping(bytes32 => uint256) public bonusesMapPos;\r\n\tstruct bonusStruct {\r\n\t\tuint balancePos;\r\n\t\tbool notempty;\r\n\t\tuint maxBonusETH;\r\n\t\tuint maxBonusBTC;\r\n\t\tuint bonusETH;\r\n\t\tuint bonusBTC;\r\n\t\tuint8 bonusPercent;\r\n\t}\r\n\tbonusStruct[] public bonusesList; //Array of struct with information about bonuses\r\n\t\r\n    bool public fundingGoalReached = false; \r\n    bool public crowdsaleClosed = false;\r\n\r\n    event GoalReached(address beneficiary, uint amountRaised);\r\n    event FundTransfer(address backer, uint amount, bool isContribution);\r\n\r\n\tfunction TSBCrowdFundingContract( \r\n\t\tuint _startTime,\r\n        uint durationInHours,\r\n        string tokenName,\r\n        string tokenSymbol\r\n\t) NamedOwnedToken(tokenName, tokenSymbol) public {\r\n\t//\trequire(_startTime >= now);\r\n\t    SetStartTime(_startTime, durationInHours);\r\n\t\tbonusCapUSD = bonusCapUSD * USDDecimals;\r\n\t}\r\n\r\n    function SetStartTime(uint startT, uint durationInHours) public onlyOwner {\r\n        startTime = startT;\r\n        bonusEndTime = startT+ 24 hours;\r\n        endTime = startT + (durationInHours * 1 hours);\r\n    }\r\n\r\n\tfunction assignTokenContract(address tok) public onlyOwner   {\r\n\t\ttokenReward = TSBToken(tok);\r\n\t\ttokenReward.transferOwnership(address(this));\r\n\t}\r\n\r\n\tfunction () public payable {\r\n\t\tbool withinPeriod = now >= startTime && now <= endTime;\r\n\t\tbool nonZeroPurchase = msg.value != 0;\r\n\t\trequire( withinPeriod && nonZeroPurchase && (crowdSaleState == CrowdSaleState.NotFinished));\r\n\t\tuint bonuspos = 0;\r\n\t\tif (now <= bonusEndTime) {\r\n//\t\t    lastdata = msg.data;\r\n\t\t\tbytes32 code = sha3(msg.data);\r\n\t\t\tbonuspos = bonusesMapPos[code];\r\n\t\t}\r\n\t\tReceiveAmount(msg.sender, msg.value, 0, now, bonuspos);\r\n\r\n\t}\r\n\r\n\tfunction CheckBTCtransaction() internal constant returns (bool) {\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction AddBTCTransactionFromArray (address[] ETHadress, uint[] BTCnum, uint[] TransTime, bytes4[] bonusdata) public onlyOwner {\r\n        require(ETHadress.length == BTCnum.length); \r\n        require(TransTime.length == bonusdata.length);\r\n        require(ETHadress.length == bonusdata.length);\r\n        for (uint i = 0; i < ETHadress.length; i++) {\r\n            AddBTCTransaction(ETHadress[i], BTCnum[i], TransTime[i], bonusdata[i]);\r\n        }\r\n\t}\r\n    /**\r\n     * Add transfered BTC, only owner could call\r\n     *\r\n     * @param ETHadress The address of ethereum wallet of sender \r\n     * @param BTCnum the received amount in BTC * 10^18\r\n     * @param TransTime the original (BTC) transaction time\r\n     */\r\n\tfunction AddBTCTransaction (address ETHadress, uint BTCnum, uint TransTime, bytes4 bonusdata) public onlyOwner {\r\n\t\trequire(CheckBTCtransaction());\r\n\t\trequire((TransTime >= startTime) && (TransTime <= endTime));\r\n\t\trequire(BTCnum != 0);\r\n\t\tuint bonuspos = 0;\r\n\t\tif (TransTime <= bonusEndTime) {\r\n//\t\t    lastdata = bonusdata;\r\n\t\t\tbytes32 code = sha3(bonusdata);\r\n\t\t\tbonuspos = bonusesMapPos[code];\r\n\t\t}\r\n\t\tReceiveAmount(ETHadress, 0, BTCnum, TransTime, bonuspos);\r\n\t}\r\n\r\n\tmodifier afterDeadline() { if (now >= endTime) _; }\r\n\r\n    /**\r\n     * Set price for ETH and BTC, only owner could call\r\n     *\r\n     * @param _ETHPrice ETH price in USD cents\r\n     * @param _BTCPrice BTC price in USD cents\r\n     */\r\n\tfunction SetCryptoPrice(uint _ETHPrice, uint _BTCPrice) public onlyOwner {\r\n\t\tETHPrice = _ETHPrice;\r\n\t\tBTCPrice = _BTCPrice;\r\n\t}\r\n\r\n    /**\r\n     * Convert sum in ETH plus BTC to USD\r\n     *\r\n     * @param ETH ETH sum in wei\r\n     * @param BTC BTC sum in 10^18\r\n     */\r\n\tfunction convertToUSD(uint ETH, uint BTC) public constant returns (uint) {\r\n\t\tuint _ETH = ETH.mul(ETHPrice);\r\n\t\tuint _BTC = BTC.mul(BTCPrice);\r\n\t\treturn (_ETH+_BTC).div(PriceDecimals);\r\n\t}\r\n\r\n    /**\r\n     * Calc collected sum in USD\r\n     */\r\n\tfunction collectedSum() public constant returns (uint) {\r\n\t\treturn convertToUSD(ETHCollected,BTCCollected);\r\n\t}\r\n\r\n    /**\r\n     * Check if min cap was reached (only after finish of crowdfunding)\r\n     */\r\n    function checkGoalReached() public afterDeadline {\r\n\t\tamountRaisedUSD = collectedSum();\r\n        if (amountRaisedUSD >= (fundingGoalUSD * USDDecimals) ){\r\n\t\t\tcrowdSaleState = CrowdSaleState.Success;\r\n\t\t\tTokenAmountToPay = amountRaisedUSD;\r\n            GoalReached(owner, amountRaisedUSD);\r\n        } else {\r\n\t\t\tcrowdSaleState = CrowdSaleState.Failure;\r\n\t\t}\r\n    }\r\n\r\n    /**\r\n     * Check if max cap was reached\r\n     */\r\n    function checkMaxCapReached() public {\r\n\t\tamountRaisedUSD = collectedSum();\r\n        if (amountRaisedUSD >= (fundingMaxCapUSD * USDDecimals) ){\r\n\t        crowdSaleState = CrowdSaleState.Success;\r\n\t\t\tTokenAmountToPay = amountRaisedUSD;\r\n            GoalReached(owner, amountRaisedUSD);\r\n        }\r\n    }\r\n\r\n\tfunction ReceiveAmount(address investor, uint sumETH, uint sumBTC, uint TransTime, uint bonuspos) internal {\r\n\t\trequire(investor != 0x0);\r\n\r\n\t\tuint pos = balanceMapPos[investor];\r\n\t\tif (pos>0) {\r\n\t\t\tpos--;\r\n\t\t\tassert(pos < balanceList.length);\r\n\t\t\tassert(balanceList[pos].mapAddress == investor);\r\n\t\t\tbalanceList[pos].mapBalanceETH = balanceList[pos].mapBalanceETH.add(sumETH);\r\n\t\t\tbalanceList[pos].mapBalanceBTC = balanceList[pos].mapBalanceBTC.add(sumBTC);\r\n\t\t} else {\r\n\t\t\tmapStruct memory newStruct;\r\n\t\t\tnewStruct.mapAddress = investor;\r\n\t\t\tnewStruct.mapBalanceETH = sumETH;\r\n\t\t\tnewStruct.mapBalanceBTC = sumBTC;\r\n\t\t\tnewStruct.bonusTokens = 0;\r\n\t\t\tpos = balanceList.push(newStruct);\t\t\r\n\t\t\tbalanceMapPos[investor] = pos;\r\n\t\t\tpos--;\r\n\t\t}\r\n\t\t\r\n\t\t// update state\r\n\t\tETHCollected = ETHCollected.add(sumETH);\r\n\t\tBTCCollected = BTCCollected.add(sumBTC);\r\n\t\t\r\n\t\tcheckBonus(pos, sumETH, sumBTC, TransTime, bonuspos);\r\n\t\tcheckMaxCapReached();\r\n\t}\r\n\r\n\tuint public DistributionNextPos = 0;\r\n\r\n    /**\r\n     * Distribute tokens to next N participants, only owner could call\r\n     */\r\n\tfunction DistributeNextNTokens(uint n) public payable onlyOwner {\r\n\t\trequire(BonusesDistributed);\r\n\t\trequire(DistributionNextPos<balanceList.length);\r\n\t\tuint nextpos;\r\n\t\tif (n == 0) {\r\n\t\t    nextpos = balanceList.length;\r\n\t\t} else {\r\n    \t\tnextpos = DistributionNextPos.add(n);\r\n    \t\tif (nextpos > balanceList.length) {\r\n    \t\t\tnextpos = balanceList.length;\r\n    \t\t}\r\n\t\t}\r\n\t\tuint TokenAmountToPay_local = TokenAmountToPay;\r\n\t\tfor (uint i = DistributionNextPos; i < nextpos; i++) {\r\n\t\t\tuint USDbalance = convertToUSD(balanceList[i].mapBalanceETH, balanceList[i].mapBalanceBTC);\r\n\t\t\tuint tokensCount = USDbalance.mul(priceUSD);\r\n\t\t\ttokenReward.mintToken(balanceList[i].mapAddress, tokensCount + balanceList[i].bonusTokens);\r\n\t\t\tTokenAmountToPay_local = TokenAmountToPay_local.sub(tokensCount);\r\n\t\t\tbalanceList[i].mapBalanceETH = 0;\r\n\t\t\tbalanceList[i].mapBalanceBTC = 0;\r\n\t\t}\r\n\t\tTokenAmountToPay = TokenAmountToPay_local;\r\n\t\tDistributionNextPos = nextpos;\r\n\t}\r\n\r\n\tfunction finishDistribution()  onlyOwner {\r\n\t\trequire ((TokenAmountToPay == 0)||(DistributionNextPos >= balanceList.length));\r\n//\t\ttokenReward.finishMinting();\r\n\t\ttokenReward.transferOwnership(owner);\r\n\t\tselfdestruct(owner);\r\n\t}\r\n\r\n    /**\r\n     * Withdraw the funds\r\n     *\r\n     * Checks to see if goal was not reached, each contributor can withdraw\r\n     * the amount they contributed.\r\n     */\r\n    function safeWithdrawal() public afterDeadline {\r\n        require(crowdSaleState == CrowdSaleState.Failure);\r\n\t\tuint pos = balanceMapPos[msg.sender];\r\n\t\trequire((pos>0)&&(pos<=balanceList.length));\r\n\t\tpos--;\r\n        uint amount = balanceList[pos].mapBalanceETH;\r\n        balanceList[pos].mapBalanceETH = 0;\r\n        if (amount > 0) {\r\n            msg.sender.transfer(amount);\r\n            FundTransfer(msg.sender, amount, false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * If something goes wrong owner could destroy the contract after 2 weeks from the crowdfunding end\r\n     * In this case the token distribution or sum refund will be performed in mannual\r\n     */\r\n\tfunction killContract() public onlyOwner {\r\n\t\trequire(now >= endTime + selfDestroyTime);\r\n\t\ttokenReward.transferOwnership(owner);\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    /**\r\n     * Add a new bonus code, only owner could call\r\n     */\r\n\tfunction AddBonusToListFromArray(bytes32[] bonusCode, uint[] ETHsumInFinney, uint[] BTCsumInFinney) public onlyOwner {\r\n\t    require(bonusCode.length == ETHsumInFinney.length);\r\n\t    require(bonusCode.length == BTCsumInFinney.length);\r\n\t    for (uint i = 0; i < bonusCode.length; i++) {\r\n\t        AddBonusToList(bonusCode[i], ETHsumInFinney[i], BTCsumInFinney[i] );\r\n\t    }\r\n\t}\r\n    /**\r\n     * Add a new bonus code, only owner could call\r\n     */\r\n\tfunction AddBonusToList(bytes32 bonusCode, uint ETHsumInFinney, uint BTCsumInFinney) public onlyOwner {\r\n\t\tuint pos = bonusesMapPos[bonusCode];\r\n\r\n\t\tif (pos > 0) {\r\n\t\t\tpos -= 1;\r\n\t\t\tbonusesList[pos].maxBonusETH = ETHsumInFinney * 1 finney;\r\n\t\t\tbonusesList[pos].maxBonusBTC = BTCsumInFinney * 1 finney;\r\n\t\t} else {\r\n\t\t\tbonusStruct memory newStruct;\r\n\t\t\tnewStruct.balancePos = 0;\r\n\t\t\tnewStruct.notempty = false;\r\n\t\t\tnewStruct.maxBonusETH = ETHsumInFinney * 1 finney;\r\n\t\t\tnewStruct.maxBonusBTC = BTCsumInFinney * 1 finney;\r\n\t\t\tnewStruct.bonusETH = 0;\r\n\t\t\tnewStruct.bonusBTC = 0;\r\n\t\t\tnewStruct.bonusPercent = 20;\r\n\t\t\tpos = bonusesList.push(newStruct);\t\t\r\n\t\t\tbonusesMapPos[bonusCode] = pos;\r\n\t\t}\r\n\t}\r\n\tbool public BonusesDistributed = false;\r\n\tuint public BonusCalcPos = 0;\r\n//    bytes public lastdata;\r\n\tfunction checkBonus(uint newBalancePos, uint sumETH, uint sumBTC, uint TransTime, uint pos) internal {\r\n\t\t\tif (pos > 0) {\r\n\t\t\t\tpos--;\r\n\t\t\t\tif (!bonusesList[pos].notempty) {\r\n\t\t\t\t\tbonusesList[pos].balancePos = newBalancePos;\r\n\t\t\t\t\tbonusesList[pos].notempty = true;\r\n\t\t\t\t} else {\r\n\t\t\t\t    if (bonusesList[pos].balancePos != newBalancePos) return;\r\n\t\t\t\t}\r\n\t\t\t\tbonusesList[pos].bonusETH = bonusesList[pos].bonusETH.add(sumETH);\r\n\t\t\t\t// if (bonusesList[pos].bonusETH > bonusesList[pos].maxBonusETH)\r\n\t\t\t\t// \tbonusesList[pos].bonusETH = bonusesList[pos].maxBonusETH;\r\n\t\t\t\tbonusesList[pos].bonusBTC = bonusesList[pos].bonusBTC.add(sumBTC);\r\n\t\t\t\t// if (bonusesList[pos].bonusBTC > bonusesList[pos].maxBonusBTC)\r\n\t\t\t\t// \tbonusesList[pos].bonusBTC = bonusesList[pos].maxBonusBTC;\r\n\t\t\t}\r\n\t}\r\n\r\n    /**\r\n     * Calc the number of bonus tokens for N next bonus participants, only owner could call\r\n     */\r\n\tfunction calcNextNBonuses(uint N) public onlyOwner {\r\n\t\trequire(crowdSaleState == CrowdSaleState.Success);\r\n\t\trequire(!BonusesDistributed);\r\n\t\tuint nextPos = BonusCalcPos + N;\r\n\t\tif (nextPos > bonusesList.length) \r\n\t\t\tnextPos = bonusesList.length;\r\n        uint bonusCapUSD_local = bonusCapUSD;    \r\n\t\tfor (uint i = BonusCalcPos; i < nextPos; i++) {\r\n\t\t\tif  ((bonusesList[i].notempty) && (bonusesList[i].balancePos < balanceList.length)) {\r\n\t\t\t\tuint maxbonus = convertToUSD(bonusesList[i].maxBonusETH, bonusesList[i].maxBonusBTC);\r\n\t\t\t\tuint bonus = convertToUSD(bonusesList[i].bonusETH, bonusesList[i].bonusBTC);\r\n\t\t\t\tif (maxbonus < bonus)\r\n\t\t\t\t    bonus = maxbonus;\r\n\t\t\t\tbonus = bonus.mul(priceUSD);\r\n\t\t\t\tif (bonusCapUSD_local >= bonus) {\r\n\t\t\t\t\tbonusCapUSD_local = bonusCapUSD_local - bonus;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbonus = bonusCapUSD_local;\r\n\t\t\t\t\tbonusCapUSD_local = 0;\r\n\t\t\t\t}\r\n\t\t\t\tbonus = bonus.mul(bonusesList[i].bonusPercent) / 100;\r\n\t\t\t\tbalanceList[bonusesList[i].balancePos].bonusTokens = bonus;\r\n\t\t\t\tif (bonusCapUSD_local == 0) {\r\n\t\t\t\t\tBonusesDistributed = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n        bonusCapUSD = bonusCapUSD_local;    \r\n\t\tBonusCalcPos = nextPos;\r\n\t\tif (nextPos >= bonusesList.length) {\r\n\t\t\tBonusesDistributed = true;\r\n\t\t}\r\n\t}\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"checkGoalReached\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amountRaisedUSD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BonusCalcPos\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"N\",\"type\":\"uint256\"}],\"name\":\"calcNextNBonuses\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"killContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"startT\",\"type\":\"uint256\"},{\"name\":\"durationInHours\",\"type\":\"uint256\"}],\"name\":\"SetStartTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ETHadress\",\"type\":\"address\"},{\"name\":\"BTCnum\",\"type\":\"uint256\"},{\"name\":\"TransTime\",\"type\":\"uint256\"},{\"name\":\"bonusdata\",\"type\":\"bytes4\"}],\"name\":\"AddBTCTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETHPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ETHadress\",\"type\":\"address[]\"},{\"name\":\"BTCnum\",\"type\":\"uint256[]\"},{\"name\":\"TransTime\",\"type\":\"uint256[]\"},{\"name\":\"bonusdata\",\"type\":\"bytes4[]\"}],\"name\":\"AddBTCTransactionFromArray\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BonusesDistributed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bonusesList\",\"outputs\":[{\"name\":\"balancePos\",\"type\":\"uint256\"},{\"name\":\"notempty\",\"type\":\"bool\"},{\"name\":\"maxBonusETH\",\"type\":\"uint256\"},{\"name\":\"maxBonusBTC\",\"type\":\"uint256\"},{\"name\":\"bonusETH\",\"type\":\"uint256\"},{\"name\":\"bonusBTC\",\"type\":\"uint256\"},{\"name\":\"bonusPercent\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ETH\",\"type\":\"uint256\"},{\"name\":\"BTC\",\"type\":\"uint256\"}],\"name\":\"convertToUSD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"balanceList\",\"outputs\":[{\"name\":\"mapAddress\",\"type\":\"address\"},{\"name\":\"mapBalanceETH\",\"type\":\"uint256\"},{\"name\":\"mapBalanceBTC\",\"type\":\"uint256\"},{\"name\":\"bonusTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingMaxCapUSD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceMapPos\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tok\",\"type\":\"address\"}],\"name\":\"assignTokenContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenReward\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"bonusCode\",\"type\":\"bytes32\"},{\"name\":\"ETHsumInFinney\",\"type\":\"uint256\"},{\"name\":\"BTCsumInFinney\",\"type\":\"uint256\"}],\"name\":\"AddBonusToList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"bonusCode\",\"type\":\"bytes32[]\"},{\"name\":\"ETHsumInFinney\",\"type\":\"uint256[]\"},{\"name\":\"BTCsumInFinney\",\"type\":\"uint256[]\"}],\"name\":\"AddBonusToListFromArray\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingGoalUSD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BTCCollected\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusCapUSD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newName\",\"type\":\"string\"},{\"name\":\"newSymbol\",\"type\":\"string\"}],\"name\":\"changeName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"checkMaxCapReached\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceUSD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishDistribution\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TokenAmountToPay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PriceDecimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BTCPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"DistributeNextNTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleClosed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"selfDestroyTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ETHPrice\",\"type\":\"uint256\"},{\"name\":\"_BTCPrice\",\"type\":\"uint256\"}],\"name\":\"SetCryptoPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"bonusesMapPos\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingGoalReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETHCollected\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DistributionNextPos\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"USDDecimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"collectedSum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusEndTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdSaleState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"safeWithdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"durationInHours\",\"type\":\"uint256\"},{\"name\":\"tokenName\",\"type\":\"string\"},{\"name\":\"tokenSymbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountRaised\",\"type\":\"uint256\"}],\"name\":\"GoalReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"backer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"isContribution\",\"type\":\"bool\"}],\"name\":\"FundTransfer\",\"type\":\"event\"}]","ContractName":"TSBCrowdFundingContract","CompilerVersion":"v0.4.17+commit.bdeb9e52","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000059d200100000000000000000000000000000000000000000000000000000000000000150000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000001654656e736f72426f782063726f776466756e64696e670000000000000000000000000000000000000000000000000000000000000000000000000000000000045453424300000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://0ec10878accb76757b2eec5e5fc03d42331e2ff1d34b4a9b0e2e167e9393d84e"}]}