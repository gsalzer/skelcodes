{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.14;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() constant returns (uint supply);\r\n    function balanceOf( address who ) constant returns (uint value);\r\n    function allowance( address owner, address spender ) constant returns (uint _allowance);\r\n\r\n    function transfer( address to, uint value) returns (bool ok);\r\n    function transferFrom( address from, address to, uint value) returns (bool ok);\r\n    function approve( address spender, uint value ) returns (bool ok);\r\n\r\n    event Transfer( address indexed from, address indexed to, uint value);\r\n    event Approval( address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract DSMath {\r\n    \r\n    /*\r\n    standard uint256 functions\r\n     */\r\n\r\n    function add(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        assert((z = x + y) >= x);\r\n    }\r\n\r\n    function sub(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        assert((z = x - y) <= x);\r\n    }\r\n\r\n    function mul(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        assert((z = x * y) >= x);\r\n    }\r\n\r\n    function div(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        z = x / y;\r\n    }\r\n\r\n    function min(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    /*\r\n    uint128 functions (h is for half)\r\n     */\r\n\r\n\r\n    function hadd(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        assert((z = x + y) >= x);\r\n    }\r\n\r\n    function hsub(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        assert((z = x - y) <= x);\r\n    }\r\n\r\n    function hmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        assert((z = x * y) >= x);\r\n    }\r\n\r\n    function hdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        z = x / y;\r\n    }\r\n\r\n    function hmin(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function hmax(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n\r\n    /*\r\n    int256 functions\r\n     */\r\n\r\n    function imin(int256 x, int256 y) constant internal returns (int256 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int256 x, int256 y) constant internal returns (int256 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    /*\r\n    WAD math\r\n     */\r\n\r\n    uint128 constant WAD = 10 ** 18;\r\n\r\n    function wadd(uint128 x, uint128 y) constant internal returns (uint128) {\r\n        return hadd(x, y);\r\n    }\r\n\r\n    function wsub(uint128 x, uint128 y) constant internal returns (uint128) {\r\n        return hsub(x, y);\r\n    }\r\n\r\n    function wmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        z = cast((uint256(x) * y + WAD / 2) / WAD);\r\n    }\r\n\r\n    function wdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        z = cast((uint256(x) * WAD + y / 2) / y);\r\n    }\r\n\r\n    function wmin(uint128 x, uint128 y) constant internal returns (uint128) {\r\n        return hmin(x, y);\r\n    }\r\n    function wmax(uint128 x, uint128 y) constant internal returns (uint128) {\r\n        return hmax(x, y);\r\n    }\r\n\r\n    /*\r\n    RAY math\r\n     */\r\n\r\n    uint128 constant RAY = 10 ** 27;\r\n\r\n    function radd(uint128 x, uint128 y) constant internal returns (uint128) {\r\n        return hadd(x, y);\r\n    }\r\n\r\n    function rsub(uint128 x, uint128 y) constant internal returns (uint128) {\r\n        return hsub(x, y);\r\n    }\r\n\r\n    function rmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        z = cast((uint256(x) * y + RAY / 2) / RAY);\r\n    }\r\n\r\n    function rdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        z = cast((uint256(x) * RAY + y / 2) / y);\r\n    }\r\n\r\n    function rpow(uint128 x, uint64 n) constant internal returns (uint128 z) {\r\n        // This famous algorithm is called \"exponentiation by squaring\"\r\n        // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n        //\r\n        // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n        //\r\n        // These facts are why it works:\r\n        //\r\n        //  If n is even, then x^n = (x^2)^(n/2).\r\n        //  If n is odd,  then x^n = x * x^(n-1),\r\n        //   and applying the equation for even x gives\r\n        //    x^n = x * (x^2)^((n-1) / 2).\r\n        //\r\n        //  Also, EVM division is flooring and\r\n        //    floor[(n-1) / 2] = floor[n / 2].\r\n\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n\r\n    function rmin(uint128 x, uint128 y) constant internal returns (uint128) {\r\n        return hmin(x, y);\r\n    }\r\n    function rmax(uint128 x, uint128 y) constant internal returns (uint128) {\r\n        return hmax(x, y);\r\n    }\r\n\r\n    function cast(uint256 x) constant internal returns (uint128 z) {\r\n        assert((z = uint128(x)) == x);\r\n    }\r\n\r\n}\r\n\r\ncontract TokenBase is ERC20, DSMath {\r\n    uint256                                            _supply;\r\n    mapping (address => uint256)                       _balances;\r\n    mapping (address => mapping (address => uint256))  _approvals;\r\n\r\n    function totalSupply() constant returns (uint256) {\r\n        return _supply;\r\n    }\r\n    function balanceOf(address addr) constant returns (uint256) {\r\n        return _balances[addr];\r\n    }\r\n    function allowance(address from, address to) constant returns (uint256) {\r\n        return _approvals[from][to];\r\n    }\r\n    \r\n    function transfer(address to, uint value) returns (bool) {\r\n        assert(_balances[msg.sender] >= value);\r\n        \r\n        _balances[msg.sender] = sub(_balances[msg.sender], value);\r\n        _balances[to] = add(_balances[to], value);\r\n        \r\n        Transfer(msg.sender, to, value);\r\n        \r\n        return true;\r\n    }\r\n    \r\n    function transferFrom(address from, address to, uint value) returns (bool) {\r\n        assert(_balances[from] >= value);\r\n        assert(_approvals[from][msg.sender] >= value);\r\n        \r\n        _approvals[from][msg.sender] = sub(_approvals[from][msg.sender], value);\r\n        _balances[from] = sub(_balances[from], value);\r\n        _balances[to] = add(_balances[to], value);\r\n        \r\n        Transfer(from, to, value);\r\n        \r\n        return true;\r\n    }\r\n    \r\n    function approve(address to, uint256 value) returns (bool) {\r\n        _approvals[msg.sender][to] = value;\r\n        \r\n        Approval(msg.sender, to, value);\r\n        \r\n        return true;\r\n    }\r\n\r\n}\r\n\r\ncontract Owned\r\n{\r\n    address public owner;\r\n    \r\n    function Owned()\r\n    {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    modifier onlyOwner()\r\n    {\r\n        if (msg.sender != owner) revert();\r\n        _;\r\n    }\r\n}\r\n\r\ncontract Migrable is TokenBase, Owned\r\n{\r\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\r\n    address public migrationAgent;\r\n    uint256 public totalMigrated;\r\n\r\n\r\n    function migrate() external {\r\n        migrate_participant(msg.sender);\r\n    }\r\n    \r\n    function migrate_participant(address _participant) internal\r\n    {\r\n        // Abort if not in Operational Migration state.\r\n        if (migrationAgent == 0)  revert();\r\n        if (_balances[_participant] == 0)  revert();\r\n        \r\n        uint256 _value = _balances[_participant];\r\n        _balances[_participant] = 0;\r\n        _supply = sub(_supply, _value);\r\n        totalMigrated = add(totalMigrated, _value);\r\n        MigrationAgent(migrationAgent).migrateFrom(_participant, _value);\r\n        Migrate(_participant, migrationAgent, _value);\r\n        \r\n    }\r\n\r\n    function setMigrationAgent(address _agent) onlyOwner external {\r\n        if (migrationAgent != 0)  revert();\r\n        migrationAgent = _agent;\r\n    }\r\n}\r\n\r\ncontract ProspectorsGoldToken is TokenBase, Owned, Migrable {\r\n    string public constant name = \"Prospectors Gold\";\r\n    string public constant symbol = \"PGL\";\r\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\r\n\r\n    address private game_address = 0xb1; // Address 0xb1 is provably non-transferrable. Game tokens will be moved to game platform after developing\r\n    uint public constant game_allocation = 110000000 * WAD; // Base allocation of tokens owned by game (50%). Not saled tokens will be moved to game balance.\r\n    uint public constant dev_allocation = 45000000 * WAD; //tokens allocated to prospectors team and developers (~20.5%)\r\n    uint public constant crowdfunding_allocation = 60000000 * WAD; //tokens allocated to crowdsale (~27.2%)\r\n    uint public constant bounty_allocation = 500000 * WAD; //tokens allocated to bounty program (~0.2%)\r\n    uint public constant presale_allocation = 4500000 * WAD; //tokens allocated to very early investors (~2%)\r\n\r\n    bool public locked = true; //token non transfarable yet. it can be unlocked after success crowdsale\r\n\r\n    address public bounty; //bounty tokens manager contract address\r\n    address public prospectors_dev_allocation; //prospectors team and developers tokens holder. Contract allows to get tokens in 5 periods (180, 360 days, 1, 2, 3 and 4 years)\r\n    ProspectorsCrowdsale public crowdsale; //crowdsale contract address\r\n\r\n    function ProspectorsGoldToken() {\r\n        _supply = 220000000 * WAD;\r\n        _balances[this] = _supply;\r\n        mint_for(game_address, game_allocation);\r\n    }\r\n    \r\n    //override and prevent transfer if crowdsale fails\r\n    function transfer(address to, uint value) returns (bool)\r\n    {\r\n        if (locked == true && msg.sender != address(crowdsale)) revert();\r\n        return super.transfer(to, value);\r\n    }\r\n    \r\n    //override and prevent transfer if crowdsale fails\r\n    function transferFrom(address from, address to, uint value)  returns (bool)\r\n    {\r\n        if (locked == true) revert();\r\n        return super.transferFrom(from, to, value);\r\n    }\r\n    \r\n    //unlock transfers if crowdsale success\r\n    function unlock() returns (bool)\r\n    {\r\n        if (locked == true && crowdsale.is_success() == true)\r\n        {\r\n            locked = false;\r\n            return true;\r\n        }\r\n        else\r\n        {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    //mint tokens for crowdsale\r\n    function init_crowdsale(address _crowdsale) onlyOwner\r\n    {\r\n        if (address(0) != address(crowdsale)) revert();\r\n        crowdsale = ProspectorsCrowdsale(_crowdsale);\r\n        mint_for(crowdsale, crowdfunding_allocation);\r\n    }\r\n    \r\n    //mint tokens for bounty contract.\r\n    function init_bounty_program(address _bounty) onlyOwner\r\n    {\r\n        if (address(0) != address(bounty)) revert();\r\n        bounty = _bounty;\r\n        mint_for(bounty, bounty_allocation);\r\n    }\r\n    \r\n    //mint tokens for dev. Also mint tokens for very early investors.\r\n    function init_dev_and_presale_allocation(address presale_token_address, address _prospectors_dev_allocation) onlyOwner\r\n    {\r\n        if (address(0) != prospectors_dev_allocation) revert();\r\n        prospectors_dev_allocation = _prospectors_dev_allocation;\r\n        mint_for(prospectors_dev_allocation, dev_allocation);\r\n        mint_for(presale_token_address, presale_allocation);\r\n    }\r\n    \r\n    //this function will be called after game release\r\n    function migrate_game_balance() onlyOwner\r\n    {\r\n        migrate_participant(game_address);\r\n    }\r\n    \r\n    //adding tokens to crowdsale, bounty, game and prospectors team\r\n    function mint_for(address addr, uint amount) private\r\n    {\r\n        if (_balances[this] >= amount)\r\n        {\r\n            _balances[this] = sub(_balances[this], amount);\r\n            _balances[addr] = add(_balances[addr], amount);\r\n            Transfer(this, addr, amount);\r\n        }\r\n    }\r\n}\r\n\r\ncontract ProspectorsCrowdsale {\r\n    function is_success() returns (bool);\r\n}\r\n\r\ncontract MigrationAgent {\r\n    function migrateFrom(address _from, uint256 _value);\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bounty\",\"type\":\"address\"}],\"name\":\"init_bounty_program\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presale_allocation\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdfunding_allocation\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bounty_allocation\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dev_allocation\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"presale_token_address\",\"type\":\"address\"},{\"name\":\"_prospectors_dev_allocation\",\"type\":\"address\"}],\"name\":\"init_dev_and_presale_allocation\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"prospectors_dev_allocation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_agent\",\"type\":\"address\"}],\"name\":\"setMigrationAgent\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"migrationAgent\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"migrate\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"migrate_game_balance\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bounty\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalMigrated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsale\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unlock\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"game_allocation\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"locked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_crowdsale\",\"type\":\"address\"}],\"name\":\"init_crowdsale\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Migrate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"ProspectorsGoldToken","CompilerVersion":"v0.4.14+commit.c2215d46","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://404cb49844ec2598d97cd3674f93f64bce506e05a00cbc8e95608b205d23b54f"}]}