{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.10;\r\n\r\ncontract Token {\r\n    \r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (uint256 => address) public addresses;\r\n    mapping (address => bool) public addressExists;\r\n    mapping (address => uint256) public addressIndex;\r\n    uint256 public numberOfAddress = 0;\r\n    \r\n    string public physicalString;\r\n    string public cryptoString;\r\n    \r\n    bool public isSecured;\r\n    string public name;\r\n    string public symbol;\r\n    uint256 public totalSupply;\r\n    bool public canMintBurn;\r\n    uint256 public txnTax;\r\n    uint256 public holdingTax;\r\n    //In Weeks, on Fridays\r\n    uint256 public holdingTaxInterval;\r\n    uint256 public lastHoldingTax;\r\n    uint256 public holdingTaxDecimals = 2;\r\n    bool public isPrivate;\r\n    \r\n    address public owner;\r\n    \r\n    function Token(string n, string a, uint256 totalSupplyToUse, bool isSecured, bool cMB, string physical, string crypto, uint256 txnTaxToUse, uint256 holdingTaxToUse, uint256 holdingTaxIntervalToUse, bool isPrivateToUse) {\r\n        name = n;\r\n        symbol = a;\r\n        totalSupply = totalSupplyToUse;\r\n        balanceOf[msg.sender] = totalSupplyToUse;\r\n        isSecured = isSecured;\r\n        physicalString = physical;\r\n        cryptoString = crypto;\r\n        canMintBurn = cMB;\r\n        owner = msg.sender;\r\n        txnTax = txnTaxToUse;\r\n        holdingTax = holdingTaxToUse;\r\n        holdingTaxInterval = holdingTaxIntervalToUse;\r\n        if(holdingTaxInterval!=0) {\r\n            lastHoldingTax = now;\r\n            while(getHour(lastHoldingTax)!=21) {\r\n                lastHoldingTax -= 1 hours;\r\n            }\r\n            while(getWeekday(lastHoldingTax)!=5) {\r\n                lastHoldingTax -= 1 days;\r\n            }\r\n            lastHoldingTax -= getMinute(lastHoldingTax) * (1 minutes) + getSecond(lastHoldingTax) * (1 seconds);\r\n        }\r\n        isPrivate = isPrivateToUse;\r\n        \r\n        addAddress(owner);\r\n    }\r\n    \r\n    function transfer(address _to, uint256 _value) payable {\r\n        chargeHoldingTax();\r\n        if (balanceOf[msg.sender] < _value) throw;\r\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;\r\n        if (msg.sender != owner && _to != owner && txnTax != 0) {\r\n            if(!owner.send(txnTax)) {\r\n                throw;\r\n            }\r\n        }\r\n        if(isPrivate && msg.sender != owner && !addressExists[_to]) {\r\n            throw;\r\n        }\r\n        balanceOf[msg.sender] -= _value;\r\n        balanceOf[_to] += _value;\r\n        addAddress(_to);\r\n        Transfer(msg.sender, _to, _value);\r\n    }\r\n    \r\n    function changeTxnTax(uint256 _newValue) {\r\n        if(msg.sender != owner) throw;\r\n        txnTax = _newValue;\r\n    }\r\n    \r\n    function mint(uint256 _value) {\r\n        if(canMintBurn && msg.sender == owner) {\r\n            if (balanceOf[msg.sender] + _value < balanceOf[msg.sender]) throw;\r\n            balanceOf[msg.sender] += _value;\r\n            totalSupply += _value;\r\n            Transfer(0, msg.sender, _value);\r\n        }\r\n    }\r\n    \r\n    function burn(uint256 _value) {\r\n        if(canMintBurn && msg.sender == owner) {\r\n            if (balanceOf[msg.sender] < _value) throw;\r\n            balanceOf[msg.sender] -= _value;\r\n            totalSupply -= _value;\r\n            Transfer(msg.sender, 0, _value);\r\n        }\r\n    }\r\n    \r\n    function chargeHoldingTax() {\r\n        if(holdingTaxInterval!=0) {\r\n            uint256 dateDif = now - lastHoldingTax;\r\n            bool changed = false;\r\n            while(dateDif >= holdingTaxInterval * (1 weeks)) {\r\n                changed=true;\r\n                dateDif -= holdingTaxInterval * (1 weeks);\r\n                for(uint256 i = 0;i<numberOfAddress;i++) {\r\n                    if(addresses[i]!=owner) {\r\n                        uint256 amtOfTaxToPay = ((balanceOf[addresses[i]]) * holdingTax)  / (10**holdingTaxDecimals)/ (10**holdingTaxDecimals);\r\n                        balanceOf[addresses[i]] -= amtOfTaxToPay;\r\n                        balanceOf[owner] += amtOfTaxToPay;\r\n                    }\r\n                }\r\n            }\r\n            if(changed) {\r\n                lastHoldingTax = now;\r\n                while(getHour(lastHoldingTax)!=21) {\r\n                    lastHoldingTax -= 1 hours;\r\n                }\r\n                while(getWeekday(lastHoldingTax)!=5) {\r\n                    lastHoldingTax -= 1 days;\r\n                }\r\n                lastHoldingTax -= getMinute(lastHoldingTax) * (1 minutes) + getSecond(lastHoldingTax) * (1 seconds);\r\n            }\r\n        }\r\n    }\r\n    \r\n    function changeHoldingTax(uint256 _newValue) {\r\n        if(msg.sender != owner) throw;\r\n        holdingTax = _newValue;\r\n    }\r\n    \r\n    function changeHoldingTaxInterval(uint256 _newValue) {\r\n        if(msg.sender != owner) throw;\r\n        holdingTaxInterval = _newValue;\r\n    }\r\n    \r\n    function addAddress (address addr) private {\r\n        if(!addressExists[addr]) {\r\n            addressIndex[addr] = numberOfAddress;\r\n            addresses[numberOfAddress++] = addr;\r\n            addressExists[addr] = true;\r\n        }\r\n    }\r\n    \r\n    function addAddressManual (address addr) {\r\n        if(msg.sender == owner && isPrivate) {\r\n            addAddress(addr);\r\n        } else {\r\n            throw;\r\n        }\r\n    }\r\n    \r\n    function removeAddress (address addr) private {\r\n        if(addressExists[addr]) {\r\n            numberOfAddress--;\r\n            addresses[addressIndex[addr]] = 0x0;\r\n            addressExists[addr] = false;\r\n        }\r\n    }\r\n    \r\n    function removeAddressManual (address addr) {\r\n        if(msg.sender == owner && isPrivate) {\r\n            removeAddress(addr);\r\n        } else {\r\n            throw;\r\n        }\r\n    }\r\n    \r\n    function getWeekday(uint timestamp) returns (uint8) {\r\n            return uint8((timestamp / 86400 + 4) % 7);\r\n    }\r\n    \r\n    function getHour(uint timestamp) returns (uint8) {\r\n            return uint8((timestamp / 60 / 60) % 24);\r\n    }\r\n\r\n    function getMinute(uint timestamp) returns (uint8) {\r\n            return uint8((timestamp / 60) % 60);\r\n    }\r\n\r\n    function getSecond(uint timestamp) returns (uint8) {\r\n            return uint8(timestamp % 60);\r\n    }\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n}\r\n\r\ncontract presale {\r\n    \r\n    Token public token;\r\n    uint256 public totalSupply;\r\n    uint256 public numberOfTokens;\r\n    uint256 public numberOfTokensLeft;\r\n    uint256 public pricePerToken;\r\n    uint256 public tokensFromPresale = 0;\r\n    \r\n    address public owner;\r\n    string public name;\r\n    string public symbol;\r\n    \r\n    address public finalAddress = 0x5904957d25D0c6213491882a64765967F88BCCC7;\r\n    \r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => bool) public addressExists;\r\n    mapping (uint256 => address) public addresses;\r\n    mapping (address => uint256) public addressIndex;\r\n    uint256 public numberOfAddress = 0;\r\n    \r\n    mapping (uint256 => uint256) public dates;\r\n    mapping (uint256 => uint256) public percents;\r\n    uint256 public numberOfDates = 8;\r\n    \r\n    presale ps = presale(0xa67d97d75eE175e05BB1FB17529FD772eE8E9030);\r\n    \r\n    function presale(address tokenAddress, uint256 noOfTokens, uint256 prPerToken) {\r\n        dates[0] = 1505520000;\r\n        dates[1] = 1506038400;\r\n        dates[2] = 1506124800;\r\n        dates[3] = 1506816000;\r\n        dates[4] = 1507420800;\r\n        dates[5] = 1508112000;\r\n        dates[6] = 1508630400;\r\n        dates[7] = 1508803200;\r\n        percents[0] = 350;\r\n        percents[1] = 200;\r\n        percents[2] = 100;\r\n        percents[3] = 50;\r\n        percents[4] = 25;\r\n        percents[5] = 0;\r\n        percents[6] = 9001;\r\n        percents[7] = 9001;\r\n        token = Token(tokenAddress);\r\n        numberOfTokens = noOfTokens;\r\n        totalSupply = noOfTokens;\r\n        numberOfTokensLeft = noOfTokens;\r\n        pricePerToken = prPerToken;\r\n        owner = msg.sender;\r\n        name = \"Autonio ICO\";\r\n        symbol = \"NIO\";\r\n        updatePresaleNumbers();\r\n    }\r\n    \r\n    function addAddress (address addr) private {\r\n        if(!addressExists[addr]) {\r\n            addressIndex[addr] = numberOfAddress;\r\n            addresses[numberOfAddress++] = addr;\r\n            addressExists[addr] = true;\r\n        }\r\n    }\r\n    \r\n    function endPresale() {\r\n        if(msg.sender == owner) {\r\n            if(now > dates[numberOfDates-1]) {\r\n                finish();\r\n            } else if(numberOfTokensLeft == 0) {\r\n                finish();\r\n            } else {\r\n                throw;\r\n            }\r\n        } else {\r\n            throw;\r\n        }\r\n    }\r\n    \r\n    function finish() private {\r\n        if(token.balanceOf(this)>=numberOfTokens){\r\n            if(!finalAddress.send(this.balance)) {\r\n                throw;\r\n            }\r\n        } else {\r\n            throw;\r\n        }\r\n    }\r\n    \r\n    function updatePresaleNumbers() {\r\n        if(msg.sender == owner) {\r\n            uint256 prevTokensFromPresale = tokensFromPresale;\r\n            tokensFromPresale = ps.numberOfTokens() - ps.numberOfTokensLeft();\r\n            uint256 dif = tokensFromPresale - prevTokensFromPresale;\r\n            numberOfTokensLeft -= dif;\r\n        } else {\r\n            throw;\r\n        }\r\n    }\r\n    \r\n    function () payable {\r\n        uint256 prevTokensFromPresale = tokensFromPresale;\r\n        tokensFromPresale = ps.numberOfTokens() - ps.numberOfTokensLeft();\r\n        uint256 dif = tokensFromPresale - prevTokensFromPresale;\r\n        numberOfTokensLeft -= dif;\r\n        uint256 weiSent = msg.value;\r\n        if(weiSent==0) {\r\n            throw;\r\n        }\r\n        uint256 weiLeftOver = 0;\r\n        if(numberOfTokensLeft<=0 || now<dates[0] || now>dates[numberOfDates-1]) {\r\n            throw;\r\n        }\r\n        uint256 percent = 9001;\r\n        for(uint256 i=0;i<numberOfDates-1;i++) {\r\n            if(now>=dates[i] && now<=dates[i+1] ) {\r\n                percent = percents[i];\r\n                i=numberOfDates-1;\r\n            }\r\n        }\r\n        if(percent==9001) {\r\n            throw;\r\n        }\r\n        uint256 tokensToGive = weiSent / pricePerToken;\r\n        if(tokensToGive * pricePerToken > weiSent) tokensToGive--;\r\n        tokensToGive=(tokensToGive*(1000+percent))/1000;\r\n        if(tokensToGive>numberOfTokensLeft) {\r\n            weiLeftOver = (tokensToGive - numberOfTokensLeft) * pricePerToken;\r\n            tokensToGive = numberOfTokensLeft;\r\n        }\r\n        numberOfTokensLeft -= tokensToGive;\r\n        if(addressExists[msg.sender]) {\r\n            balanceOf[msg.sender] += tokensToGive;\r\n        } else {\r\n            addAddress(msg.sender);\r\n            balanceOf[msg.sender] = tokensToGive;\r\n        }\r\n        Transfer(0x0,msg.sender,tokensToGive);\r\n        if(weiLeftOver>0)msg.sender.send(weiLeftOver);\r\n    }\r\n    \r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfTokensLeft\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfDates\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dates\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updatePresaleNumbers\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pricePerToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"percents\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensFromPresale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endPresale\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressExists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"addresses\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"noOfTokens\",\"type\":\"uint256\"},{\"name\":\"prPerToken\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"presale","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000081f5e44c050a535f2f23fde37b39e55745a378f9000000000000000000000000000000000000000000000000000000000aae60000000000000000000000000000000000000000000000000000000af19187eb400","Library":"","SwarmSource":"bzzr://74e7ce11c719804fa749c578ae505955bb42a6429667ab6906d64578fa5f614c"}]}