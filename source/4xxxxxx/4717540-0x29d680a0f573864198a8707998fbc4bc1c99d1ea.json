{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.4.10;\r\n\r\ncontract Token {\r\n    function transferFrom(address from, address to, uint amount) returns(bool);\r\n    function transfer(address to, uint amount) returns(bool);\r\n    function balanceOf(address addr) constant returns(uint);\r\n}\r\n\r\ncontract Owned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    /**\r\n     * Events\r\n     */\r\n    event ChangedOwner(address indexed new_owner);\r\n\r\n    /**\r\n     * Functionality\r\n     */\r\n\r\n    function Owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function changeOwner(address _newOwner) onlyOwner external {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() external {\r\n        if (msg.sender == newOwner) {\r\n            owner = newOwner;\r\n            newOwner = 0x0;\r\n            ChangedOwner(owner);\r\n        }\r\n    }\r\n}\r\n\r\ncontract IOwned {\r\n    function owner() returns (address);\r\n    function changeOwner(address);\r\n    function acceptOwnership();\r\n}\r\n\r\n/**\r\n * Savings is a contract that releases Tokens on a predefined\r\n * schedule, and allocates bonus tokens upon withdrawal on a\r\n * proportional basis, determined by the ratio of deposited tokens\r\n * to total owned tokens.\r\n *\r\n * The distribution schedule consists of a monthly withdrawal schedule\r\n * responsible for distribution 75% of the total savings, and a\r\n * one-off withdrawal event available before or at the start of the\r\n * withdrawal schedule, distributing 25% of the total savings.\r\n *\r\n * To be exact, upon contract deployment there may be a period of time in which\r\n * only the one-off withdrawal event is available, define this period of time as:\r\n * [timestamp(start), timestamp(startBlockTimestamp)),\r\n *\r\n * Then the periodic withdrawal range is defined as:\r\n * [timestamp(startBlockTimestamp), +inf)\r\n *\r\n * DO NOT SEND TOKENS TO THIS CONTRACT. Use the deposit() or depositTo() method.\r\n * As an exception, tokens transferred to this contract before locking are the\r\n * bonus tokens that are distributed.\r\n */\r\ncontract Savings is Owned {\r\n    /**\r\n     * Periods is the total monthly withdrawable amount, not counting the\r\n     * special withdrawal.\r\n     */\r\n    uint public periods;\r\n\r\n    /**\r\n     * t0special is an additional multiplier that determines what\r\n     * fraction of the total distribution is distributed in the\r\n     * one-off withdrawal event. It is used in conjunction with\r\n     * a periodic multiplier (p) to determine the total savings withdrawable\r\n     * to the user at that point in time.\r\n     *\r\n     * The value is not set, it is calculated based on periods\r\n     */\r\n    uint public t0special;\r\n\r\n    uint constant public intervalSecs = 30 days;\r\n    uint constant public precision = 10 ** 18;\r\n\r\n\r\n    /**\r\n     * Events\r\n     */\r\n    event Withdraws(address indexed who, uint amount);\r\n    event Deposit(address indexed who, uint amount);\r\n\r\n    bool public inited;\r\n    bool public locked;\r\n    uint public startBlockTimestamp = 0;\r\n\r\n    Token public token;\r\n\r\n    // face value deposited by an address before locking\r\n    mapping (address => uint) public deposited;\r\n\r\n    // total face value deposited; sum of deposited\r\n    uint public totalfv;\r\n\r\n    // the total remaining value\r\n    uint public remainder;\r\n\r\n    /**\r\n     * Total tokens owned by the contract after locking, and possibly\r\n     * updated by the foundation after subsequent sales.\r\n     */\r\n    uint public total;\r\n\r\n    // the total value withdrawn\r\n    mapping (address => uint256) public withdrawn;\r\n\r\n    bool public nullified;\r\n\r\n    modifier isParticipant() {\r\n        require(\r\n            msg.sender == 0x4778bE92Dd5c51035bf80Fca564ba5E7Fad5FB6d ||\r\n            msg.sender == 0x8567462b8E8303637F0004B2E664993314e58BD7 ||\r\n            msg.sender == 0x0e24D8Fcdf0c319dF03998Cc53F4FBA035D9a4f9 ||\r\n            msg.sender == 0xb493c9C0C0aBfd9847baB53231774f13BF882eE9\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier notNullified() { require(!nullified); _; }\r\n\r\n    modifier preLock() { require(!locked && startBlockTimestamp == 0); _; }\r\n\r\n    /**\r\n     * Lock called, deposits no longer available.\r\n     */\r\n    modifier postLock() { require(locked); _; }\r\n\r\n    /**\r\n     * Prestart, state is after lock, before start\r\n     */\r\n    modifier preStart() { require(locked && startBlockTimestamp == 0); _; }\r\n\r\n    /**\r\n     * Start called, the savings contract is now finalized, and withdrawals\r\n     * are now permitted.\r\n     */\r\n    modifier postStart() { require(locked && startBlockTimestamp != 0); _; }\r\n\r\n    /**\r\n     * Uninitialized state, before init is called. Mainly used as a guard to\r\n     * finalize periods and t0special.\r\n     */\r\n    modifier notInitialized() { require(!inited); _; }\r\n\r\n    /**\r\n     * Post initialization state, mainly used to guarantee that\r\n     * periods and t0special have been set properly before starting\r\n     * the withdrawal process.\r\n     */\r\n    modifier initialized() { require(inited); _; }\r\n\r\n    /**\r\n     * Revert under all conditions for fallback, cheaper mistakes\r\n     * in the future?\r\n     */\r\n    function() {\r\n        revert();\r\n    }\r\n\r\n    /**\r\n     * Nullify functionality is intended to disable the contract.\r\n     */\r\n    function nullify() onlyOwner {\r\n        nullified = true;\r\n    }\r\n\r\n    /**\r\n     * Initialization function, should be called after contract deployment. The\r\n     * addition of this function allows contract compilation to be simplified\r\n     * to one contract, instead of two.\r\n     *\r\n     * periods and t0special are finalized, and effectively invariant, after\r\n     * init is called for the first time.\r\n     */\r\n    function init(uint _periods, uint _t0special) onlyOwner notInitialized {\r\n        require(_periods != 0);\r\n        periods = _periods;\r\n        t0special = _t0special;\r\n    }\r\n\r\n    function finalizeInit() onlyOwner notInitialized {\r\n        inited = true;\r\n    }\r\n\r\n    function setToken(address tok) onlyOwner {\r\n        token = Token(tok);\r\n    }\r\n\r\n    /**\r\n     * Lock is called by the owner to lock the savings contract\r\n     * so that no more deposits may be made.\r\n     */\r\n    function lock() onlyOwner {\r\n        locked = true;\r\n    }\r\n\r\n    /**\r\n     * Starts the distribution of savings, it should be called\r\n     * after lock(), once all of the bonus tokens are send to this contract,\r\n     * and multiMint has been called.\r\n     */\r\n    function start(uint _startBlockTimestamp) onlyOwner initialized preStart {\r\n        startBlockTimestamp = _startBlockTimestamp;\r\n        uint256 tokenBalance = token.balanceOf(this);\r\n        total = tokenBalance;\r\n        remainder = tokenBalance;\r\n    }\r\n\r\n    /**\r\n     * Check withdrawal is live, useful for checking whether\r\n     * the savings contract is \"live\", withdrawal enabled, started.\r\n     */\r\n    function isStarted() constant returns(bool) {\r\n        return locked && startBlockTimestamp != 0;\r\n    }\r\n\r\n    // if someone accidentally transfers tokens to this contract,\r\n    // the owner can return them as long as distribution hasn't started\r\n\r\n    /**\r\n     * Used to refund users who accidentaly transferred tokens to this\r\n     * contract, only available before contract is locked\r\n     */\r\n    function refundTokens(address addr, uint amount) onlyOwner preLock {\r\n        token.transfer(addr, amount);\r\n    }\r\n\r\n\r\n    /**\r\n     * Update the total balance, to be called in case of subsequent sales. Updates\r\n     * the total recorded balance of the contract by the difference in expected\r\n     * remainder and the current balance. This means any positive difference will\r\n     * be \"recorded\" into the contract, and distributed within the remaining\r\n     * months of the TRS.\r\n     */\r\n    function updateTotal() onlyOwner postLock {\r\n        uint current = token.balanceOf(this);\r\n        require(current >= remainder); // for sanity\r\n\r\n        uint difference = (current - remainder);\r\n        total += difference;\r\n        remainder = current;\r\n    }\r\n\r\n    /**\r\n     * Calculates the monthly period, starting after the startBlockTimestamp,\r\n     * periodAt will return 0 for all timestamps before startBlockTimestamp.\r\n     *\r\n     * Therefore period 0 is the range of time in which we have called start(),\r\n     * but have not yet passed startBlockTimestamp. Period 1 is the\r\n     * first monthly period, and so-forth all the way until the last\r\n     * period == periods.\r\n     *\r\n     * NOTE: not guarded since no state modifications are made. However,\r\n     * it will return invalid data before the postStart state. It is\r\n     * up to the user to manually check that the contract is in\r\n     * postStart state.\r\n     */\r\n    function periodAt(uint _blockTimestamp) constant returns(uint) {\r\n        /**\r\n         * Lower bound, consider period 0 to be the time between\r\n         * start() and startBlockTimestamp\r\n         */\r\n        if (startBlockTimestamp > _blockTimestamp)\r\n            return 0;\r\n\r\n        /**\r\n         * Calculate the appropriate period, and set an upper bound of\r\n         * periods - 1.\r\n         */\r\n        uint p = ((_blockTimestamp - startBlockTimestamp) / intervalSecs) + 1;\r\n        if (p > periods)\r\n            p = periods;\r\n        return p;\r\n    }\r\n\r\n    // what withdrawal period are we in?\r\n    // returns the period number from [0, periods)\r\n    function period() constant returns(uint) {\r\n        return periodAt(block.timestamp);\r\n    }\r\n\r\n    // deposit your tokens to be saved\r\n    //\r\n    // the despositor must have approve()'d the tokens\r\n    // to be transferred by this contract\r\n    function deposit(uint tokens) notNullified {\r\n        depositTo(msg.sender, tokens);\r\n    }\r\n\r\n\r\n    function depositTo(address beneficiary, uint tokens) isParticipant preLock notNullified {\r\n        require(token.transferFrom(msg.sender, this, tokens));\r\n        deposited[beneficiary] += tokens;\r\n        totalfv += tokens;\r\n        Deposit(beneficiary, tokens);\r\n    }\r\n\r\n    // convenience function for owner: deposit on behalf of many\r\n    function bulkDepositTo(uint256[] bits) onlyOwner {\r\n        uint256 lomask = (1 << 96) - 1;\r\n        for (uint i=0; i<bits.length; i++) {\r\n            address a = address(bits[i]>>96);\r\n            uint val = bits[i]&lomask;\r\n            depositTo(a, val);\r\n        }\r\n    }\r\n\r\n    // withdraw withdraws tokens to the sender\r\n    // withdraw can be called at most once per redemption period\r\n    function withdraw() notNullified returns(bool) {\r\n        return withdrawTo(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * Calculates the fraction of total (one-off + monthly) withdrawable\r\n     * given the current timestamp. No guards due to function being constant.\r\n     * Will output invalid data until the postStart state. It is up to the user\r\n     * to manually confirm contract is in postStart state.\r\n     */\r\n    function availableForWithdrawalAt(uint256 blockTimestamp) constant returns (uint256) {\r\n        /**\r\n         * Calculate the total withdrawable, giving a numerator with range:\r\n         * [0.25 * 10 ** 18, 1 * 10 ** 18]\r\n         */\r\n        return ((t0special + periodAt(blockTimestamp)) * precision) / (t0special + periods);\r\n    }\r\n\r\n    /**\r\n     * Business logic of _withdrawTo, the code is separated this way mainly for\r\n     * testing. We can inject and test parameters freely without worrying about the\r\n     * blockchain model.\r\n     *\r\n     * NOTE: Since function is constant, no guards are applied. This function will give\r\n     * invalid outputs unless in postStart state. It is up to user to manually check\r\n     * that the correct state is given (isStart() == true)\r\n     */\r\n    function _withdrawTo(uint _deposit, uint _withdrawn, uint _blockTimestamp, uint _total) constant returns (uint) {\r\n        uint256 fraction = availableForWithdrawalAt(_blockTimestamp);\r\n\r\n        /**\r\n         * There are concerns that the multiplication could possibly\r\n         * overflow, however this should not be the case if we calculate\r\n         * the upper bound based on our known parameters:\r\n         *\r\n         * Lets assume the minted token amount to be 500 million (reasonable),\r\n         * given a precision of 8 decimal places, we get:\r\n         * deposited[addr] = 5 * (10 ** 8) * (10 ** 8) = 5 * (10 ** 16)\r\n         *\r\n         * The max for fraction = 10 ** 18, and the max for total is\r\n         * also 5 * (10 ** 16).\r\n         *\r\n         * Therefore:\r\n         * deposited[addr] * fraction * total = 2.5 * (10 ** 51)\r\n         *\r\n         * The maximum for a uint256 is = 1.15 * (10 ** 77)\r\n         */\r\n        uint256 withdrawable = ((_deposit * fraction * _total) / totalfv) / precision;\r\n\r\n        // check that we can withdraw something\r\n        if (withdrawable > _withdrawn) {\r\n            return withdrawable - _withdrawn;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Public facing withdrawTo, injects business logic with\r\n     * the correct model.\r\n     */\r\n    function withdrawTo(address addr) postStart notNullified returns (bool) {\r\n        uint _d = deposited[addr];\r\n        uint _w = withdrawn[addr];\r\n\r\n        uint diff = _withdrawTo(_d, _w, block.timestamp, total);\r\n\r\n        // no withdrawal could be made\r\n        if (diff == 0) {\r\n            return false;\r\n        }\r\n\r\n        // check that we cannot withdraw more than max\r\n        require((diff + _w) <= ((_d * total) / totalfv));\r\n\r\n        // transfer and increment\r\n        require(token.transfer(addr, diff));\r\n\r\n        withdrawn[addr] += diff;\r\n        remainder -= diff;\r\n        Withdraws(addr, diff);\r\n        return true;\r\n    }\r\n\r\n    // force withdrawal to many addresses\r\n    function bulkWithdraw(address[] addrs) notNullified {\r\n        for (uint i=0; i<addrs.length; i++)\r\n            withdrawTo(addrs[i]);\r\n    }\r\n\r\n    // Code off the chain informs this contract about\r\n    // tokens that were minted to it on behalf of a depositor.\r\n    //\r\n    // Note: the function signature here is known to New Alchemy's\r\n    // tooling, which is why it is arguably misnamed.\r\n    uint public mintingNonce;\r\n    function multiMint(uint nonce, uint256[] bits) onlyOwner preLock {\r\n\r\n        if (nonce != mintingNonce) return;\r\n        mintingNonce += 1;\r\n        uint256 lomask = (1 << 96) - 1;\r\n        uint sum = 0;\r\n        for (uint i=0; i<bits.length; i++) {\r\n            address a = address(bits[i]>>96);\r\n            uint value = bits[i]&lomask;\r\n            deposited[a] += value;\r\n            sum += value;\r\n            Deposit(a, value);\r\n        }\r\n        totalfv += sum;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"tok\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"blockTimestamp\",\"type\":\"uint256\"}],\"name\":\"availableForWithdrawalAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"total\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"bulkWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"inited\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"intervalSecs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isStarted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"refundTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"withdrawn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalizeInit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"withdrawTo\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"bits\",\"type\":\"uint256[]\"}],\"name\":\"multiMint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"t0special\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startBlockTimestamp\",\"type\":\"uint256\"}],\"name\":\"start\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"remainder\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_deposit\",\"type\":\"uint256\"},{\"name\":\"_withdrawn\",\"type\":\"uint256\"},{\"name\":\"_blockTimestamp\",\"type\":\"uint256\"},{\"name\":\"_total\",\"type\":\"uint256\"}],\"name\":\"_withdrawTo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"periods\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_periods\",\"type\":\"uint256\"},{\"name\":\"_t0special\",\"type\":\"uint256\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startBlockTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"bits\",\"type\":\"uint256[]\"}],\"name\":\"bulkDepositTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateTotal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalfv\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"deposited\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"locked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"precision\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"nullify\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"period\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nullified\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintingNonce\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_blockTimestamp\",\"type\":\"uint256\"}],\"name\":\"periodAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"depositTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraws\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"new_owner\",\"type\":\"address\"}],\"name\":\"ChangedOwner\",\"type\":\"event\"}]","ContractName":"Savings","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://47d31ba4c49323230d938860f536c83494a8b523e5aaad8e4485c715657f8893"}]}