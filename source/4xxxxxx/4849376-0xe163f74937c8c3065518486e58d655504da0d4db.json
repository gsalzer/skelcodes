{"status":"1","message":"OK","result":[{"SourceCode":"// AID tokensale smart contract.\r\n// Developed by Phenom.Team <info@phenom.team>\r\n\r\npragma solidity ^ 0.4.15;\r\n\r\n/**\r\n *   @title SafeMath\r\n *   @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal constant returns(uint256) {\r\n        assert(b > 0);\r\n        uint256 c = a / b;\r\n        assert(a == b * c + a % b);\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal constant returns(uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal constant returns(uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n *   @title ERC20\r\n *   @dev Standart ERC20 token interface\r\n */\r\ncontract ERC20 {\r\n    uint256 public totalSupply = 0;\r\n    mapping(address => uint256) balances;\r\n    mapping(address => mapping(address => uint256)) allowed;\r\n    function balanceOf(address _owner) public constant returns(uint256);\r\n    function transfer(address _to, uint256 _value) public returns(bool);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns(bool);\r\n    function approve(address _spender, uint256 _value) public returns(bool);\r\n    function allowance(address _owner, address _spender) public constant returns(uint256);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n/**\r\n *   @title AidaICO contract  - takes funds from users and issues tokens\r\n *   @dev AidaICO - it's the first ever contract for ICO which allows users to\r\n *                  return their investments.\r\n */\r\ncontract AidaICO {\r\n    // AID - Aida token contract\r\n    AidaToken public AID = new AidaToken(this);\r\n    using SafeMath for uint256;\r\n\r\n    // Token price parameters\r\n    // These parameters can be changed only by oracle of contract\r\n    uint256 public Rate_Eth = 920; // Rate USD per ETH\r\n    uint256 public Tokens_Per_Dollar = 4; // Aida token per dollar\r\n    uint256 public Token_Price = Tokens_Per_Dollar.mul(Rate_Eth); // Aida token per ETH\r\n\r\n    uint256 constant bountyPart = 10; // 1% of TotalSupply for BountyFund\r\n    uint256 constant partnersPart = 30; //3% f TotalSupply for PartnersFund\r\n    uint256 constant teamPart = 200; //20% of TotalSupply for TeamFund\r\n    uint256 constant icoAndPOfPart = 760; // 76% of TotalSupply for PublicICO and PrivateOffer\r\n    bool public returnPeriodExpired = false;\r\n    uint256 finishTime = 0;\r\n\r\n    // Output ethereum addresses\r\n    address public Company;\r\n    address public BountyFund;\r\n    address public PartnersFund;\r\n    address public TeamFund;\r\n    address public Manager; // Manager controls contract\r\n    address public Controller_Address1; // First address that is used to buy tokens for other cryptos\r\n    address public Controller_Address2; // Second address that is used to buy tokens for other cryptos\r\n    address public Controller_Address3; // Third address that is used to buy tokens for other cryptos\r\n    address public Oracle; // Oracle address\r\n    address public RefundManager; // Refund manager address\r\n\r\n    // Possible ICO statuses\r\n    enum StatusICO {\r\n        Created,\r\n        PreIcoStarted,\r\n        PreIcoPaused,\r\n        PreIcoFinished,\r\n        IcoStarted,\r\n        IcoPaused,\r\n        IcoFinished\r\n    }\r\n\r\n    StatusICO statusICO = StatusICO.Created;\r\n\r\n    // Mappings\r\n    mapping(address => uint256) public ethPreIco; // Mapping for remembering eth of investors who paid at PreICO\r\n    mapping(address => uint256) public ethIco; // Mapping for remembering eth of investors who paid at ICO\r\n    mapping(address => bool) public used; // Users can return their funds one time\r\n    mapping(address => uint256) public tokensPreIco; // Mapping for remembering tokens of investors who paid at preICO in ether\r\n    mapping(address => uint256) public tokensIco; // Mapping for remembering tokens of investors who paid at ICO in ethre\r\n    mapping(address => uint256) public tokensPreIcoInOtherCrypto; // Mapping for remembering tokens of investors who paid at preICO in other crypto currencies\r\n    mapping(address => uint256) public tokensIcoInOtherCrypto; // Mapping for remembering tokens of investors who paid at ICO in other crypto currencies\r\n\r\n    // Events Log\r\n    event LogStartPreICO();\r\n    event LogPausePreICO();\r\n    event LogFinishPreICO();\r\n    event LogStartICO();\r\n    event LogPauseICO();\r\n    event LogFinishICO(address bountyFund, address partnersFund, address teamFund);\r\n    event LogBuyForInvestor(address investor, uint256 aidValue, string txHash);\r\n    event LogReturnEth(address investor, uint256 eth);\r\n    event LogReturnOtherCrypto(address investor, string logString);\r\n\r\n    // Modifiers\r\n    // Allows execution by the refund manager only\r\n    modifier refundManagerOnly {\r\n        require(msg.sender == RefundManager);\r\n        _;\r\n    }\r\n    // Allows execution by the oracle only\r\n    modifier oracleOnly {\r\n        require(msg.sender == Oracle);\r\n        _;\r\n    }\r\n    // Allows execution by the contract manager only\r\n    modifier managerOnly {\r\n        require(msg.sender == Manager);\r\n        _;\r\n    }\r\n    // Allows execution by the one of controllers only\r\n    modifier controllersOnly {\r\n      require((msg.sender == Controller_Address1)\r\n           || (msg.sender == Controller_Address2)\r\n           || (msg.sender == Controller_Address3));\r\n      _;\r\n    }\r\n\r\n\r\n   /**\r\n    *   @dev Contract constructor function\r\n    */\r\n    function AidaICO(\r\n        address _Company,\r\n        address _BountyFund,\r\n        address _PartnersFund,\r\n        address _TeamFund,\r\n        address _Manager,\r\n        address _Controller_Address1,\r\n        address _Controller_Address2,\r\n        address _Controller_Address3,\r\n        address _Oracle,\r\n        address _RefundManager\r\n    )\r\n        public {\r\n        Company = _Company;\r\n        BountyFund = _BountyFund;\r\n        PartnersFund = _PartnersFund;\r\n        TeamFund = _TeamFund;\r\n        Manager = _Manager;\r\n        Controller_Address1 = _Controller_Address1;\r\n        Controller_Address2 = _Controller_Address2;\r\n        Controller_Address3 = _Controller_Address3;\r\n        Oracle = _Oracle;\r\n        RefundManager = _RefundManager;\r\n    }\r\n\r\n   /**\r\n    *   @dev Set rate of ETH and update token price\r\n    *   @param _RateEth       current ETH rate\r\n    */\r\n    function setRate(uint256 _RateEth) external oracleOnly {\r\n        Rate_Eth = _RateEth;\r\n        Token_Price = Tokens_Per_Dollar.mul(Rate_Eth);\r\n    }\r\n\r\n   /**\r\n    *   @dev Start PreIco\r\n    *   Set ICO status to PreIcoStarted\r\n    */\r\n    function startPreIco() external managerOnly {\r\n        require(statusICO == StatusICO.Created || statusICO == StatusICO.PreIcoPaused);\r\n        statusICO = StatusICO.PreIcoStarted;\r\n        LogStartPreICO();\r\n    }\r\n\r\n   /**\r\n    *   @dev Pause PreIco\r\n    *   Set Ico status to PreIcoPaused\r\n    */\r\n    function pausePreIco() external managerOnly {\r\n        require(statusICO == StatusICO.PreIcoStarted);\r\n        statusICO = StatusICO.PreIcoPaused;\r\n        LogPausePreICO();\r\n    }\r\n   /**\r\n    *   @dev Finish PreIco\r\n    *   Set Ico status to PreIcoFinished\r\n    */\r\n    function finishPreIco() external managerOnly {\r\n        require(statusICO == StatusICO.PreIcoStarted || statusICO == StatusICO.PreIcoPaused);\r\n        statusICO = StatusICO.PreIcoFinished;\r\n        LogFinishPreICO();\r\n    }\r\n\r\n   /**\r\n    *   @dev Start ICO\r\n    *   Set ICO status to IcoStarted\r\n    */\r\n    function startIco() external managerOnly {\r\n        require(statusICO == StatusICO.PreIcoFinished || statusICO == StatusICO.IcoPaused);\r\n        statusICO = StatusICO.IcoStarted;\r\n        LogStartICO();\r\n    }\r\n\r\n   /**\r\n    *   @dev Pause Ico\r\n    *   Set Ico status to IcoPaused\r\n    */\r\n    function pauseIco() external managerOnly {\r\n        require(statusICO == StatusICO.IcoStarted);\r\n        statusICO = StatusICO.IcoPaused;\r\n        LogPauseICO();\r\n    }\r\n\r\n   /**\r\n    *   @dev Finish ICO and emit tokens for bounty company, partners and team\r\n    */\r\n    function finishIco() external managerOnly {\r\n        require(statusICO == StatusICO.IcoStarted || statusICO == StatusICO.IcoPaused);\r\n        uint256 alreadyMinted = AID.totalSupply(); // = PublicICO\r\n        uint256 totalAmount = alreadyMinted.mul(1000).div(icoAndPOfPart);\r\n        AID.mintTokens(BountyFund, bountyPart.mul(totalAmount).div(1000));\r\n        AID.mintTokens(PartnersFund, partnersPart.mul(totalAmount).div(1000));\r\n        AID.mintTokens(TeamFund, teamPart.mul(totalAmount).div(1000));\r\n        statusICO = StatusICO.IcoFinished;\r\n        finishTime = now;\r\n        LogFinishICO(BountyFund, PartnersFund, TeamFund);\r\n    }\r\n\r\n\r\n   /**\r\n    *   @dev Unfreeze tokens(enable token transfers)\r\n    */\r\n    function enableTokensTransfer() external managerOnly {\r\n        AID.defrostTokens();\r\n    }\r\n\r\n    /**\r\n    *   @dev Freeze tokens(disable token transfers)\r\n    */\r\n    function disableTokensTransfer() external managerOnly {\r\n        require((statusICO != StatusICO.IcoFinished) || (now <= finishTime + 21 days));\r\n        AID.frostTokens();\r\n    }\r\n\r\n   /**\r\n    *   @dev Fallback function calls createTokensForEth() function to create tokens\r\n    *        when investor sends ETH to address of ICO contract\r\n    */\r\n    function() external payable {\r\n        require(statusICO == StatusICO.PreIcoStarted || statusICO == StatusICO.IcoStarted);\r\n        createTokensForEth(msg.sender, msg.value.mul(Token_Price));\r\n        rememberEther(msg.value, msg.sender);\r\n    }\r\n\r\n   /**\r\n    *   @dev Store how many eth were invested by investor\r\n    *   @param _value        amount of invested ether in Wei\r\n    *   @param _investor     address of investor\r\n    */\r\n    function rememberEther(uint256 _value, address _investor) internal {\r\n        if (statusICO == StatusICO.PreIcoStarted) {\r\n            ethPreIco[_investor] = ethPreIco[_investor].add(_value);\r\n        }\r\n        if (statusICO == StatusICO.IcoStarted) {\r\n            ethIco[_investor] = ethIco[_investor].add(_value);\r\n        }\r\n    }\r\n\r\n   /**\r\n    *   @dev Writes how many tokens investor received(for payments in ETH)\r\n    *   @param _value        amount of tokens\r\n    *   @param _investor     address of investor\r\n    */\r\n    function rememberTokensEth(uint256 _value, address _investor) internal {\r\n        if (statusICO == StatusICO.PreIcoStarted) {\r\n            tokensPreIco[_investor] = tokensPreIco[_investor].add(_value);\r\n        }\r\n        if (statusICO == StatusICO.IcoStarted) {\r\n            tokensIco[_investor] = tokensIco[_investor].add(_value);\r\n        }\r\n    }\r\n\r\n   /**\r\n    *   @dev Writes how many tokens investor received(for payments in other cryptocurrencies)\r\n    *   @param _value        amount of tokens\r\n    *   @param _investor     address of investor\r\n    */\r\n    function rememberTokensOtherCrypto(uint256 _value, address _investor) internal {\r\n        if (statusICO == StatusICO.PreIcoStarted) {\r\n            tokensPreIcoInOtherCrypto[_investor] = tokensPreIcoInOtherCrypto[_investor].add(_value);\r\n        }\r\n        if (statusICO == StatusICO.IcoStarted) {\r\n            tokensIcoInOtherCrypto[_investor] = tokensIcoInOtherCrypto[_investor].add(_value);\r\n        }\r\n    }\r\n\r\n   /**\r\n    *   @dev Issues tokens for users who made purchases in other cryptocurrencies\r\n    *   @param _investor     address the tokens will be issued to\r\n    *   @param _txHash       transaction hash of investor's payment\r\n    *   @param _aidValue     number of Aida tokens\r\n    */\r\n    function buyForInvestor(\r\n        address _investor,\r\n        uint256 _aidValue,\r\n        string _txHash\r\n    )\r\n        external\r\n        controllersOnly {\r\n        require(statusICO == StatusICO.PreIcoStarted || statusICO == StatusICO.IcoStarted);\r\n        createTokensForOtherCrypto(_investor, _aidValue);\r\n        LogBuyForInvestor(_investor, _aidValue, _txHash);\r\n    }\r\n\r\n   /**\r\n    *   @dev Issue tokens for investors who paid in other cryptocurrencies\r\n    *   @param _investor     address which the tokens will be issued to\r\n    *   @param _aidValue     number of Aida tokens\r\n    */\r\n    function createTokensForOtherCrypto(address _investor, uint256 _aidValue) internal {\r\n        require(_aidValue > 0);\r\n        uint256 bonus = getBonus(_aidValue);\r\n        uint256 total = _aidValue.add(bonus);\r\n        rememberTokensOtherCrypto(total, _investor);\r\n        AID.mintTokens(_investor, total);\r\n    }\r\n\r\n   /**\r\n    *   @dev Issue tokens for investors who paid in ether\r\n    *   @param _investor     address which the tokens will be issued to\r\n    *   @param _aidValue     number of Aida tokens\r\n    */\r\n    function createTokensForEth(address _investor, uint256 _aidValue) internal {\r\n        require(_aidValue > 0);\r\n        uint256 bonus = getBonus(_aidValue);\r\n        uint256 total = _aidValue.add(bonus);\r\n        rememberTokensEth(total, _investor);\r\n        AID.mintTokens(_investor, total);\r\n    }\r\n\r\n   /**\r\n    *   @dev Calculates bonus if PreIco sales still not over\r\n    *   @param _value        amount of tokens\r\n    *   @return              bonus value\r\n    */\r\n    function getBonus(uint256 _value)\r\n        public\r\n        constant\r\n        returns(uint256)\r\n    {\r\n        uint256 bonus = 0;\r\n        if (statusICO == StatusICO.PreIcoStarted) {\r\n            bonus = _value.mul(15).div(100);\r\n        }\r\n        return bonus;\r\n    }\r\n\r\n\r\n  /**\r\n   *   @dev Enable returns of investments\r\n   */\r\n   function startRefunds() external managerOnly {\r\n        returnPeriodExpired = false;\r\n   }\r\n\r\n  /**\r\n   *   @dev Disable returns of investments\r\n   */\r\n   function stopRefunds() external managerOnly {\r\n        returnPeriodExpired = true;\r\n   }\r\n\r\n\r\n   /**\r\n    *   @dev Allows investors to return their investments(in ETH)\r\n    *   if preICO or ICO return duration is not over yet\r\n    *   and burns tokens\r\n    */\r\n    function returnEther() public {\r\n        require(!used[msg.sender]);\r\n        require(!returnPeriodExpired);\r\n        uint256 eth = 0;\r\n        uint256 tokens = 0;\r\n        if (statusICO == StatusICO.PreIcoStarted) {\r\n            require(ethPreIco[msg.sender] > 0);\r\n            eth = ethPreIco[msg.sender];\r\n            tokens = tokensPreIco[msg.sender];\r\n            ethPreIco[msg.sender] = 0;\r\n            tokensPreIco[msg.sender] = 0;\r\n        }\r\n        if (statusICO == StatusICO.IcoStarted) {\r\n            require(ethIco[msg.sender] > 0);\r\n            eth = ethIco[msg.sender];\r\n            tokens = tokensIco[msg.sender];\r\n            ethIco[msg.sender] = 0;\r\n            tokensIco[msg.sender] = 0;\r\n        }\r\n        used[msg.sender] = true;\r\n        msg.sender.transfer(eth);\r\n        AID.burnTokens(msg.sender, tokens);\r\n        LogReturnEth(msg.sender, eth);\r\n    }\r\n\r\n   /**\r\n    *   @dev Burn tokens of investors who paid in other cryptocurrencies\r\n    *   if preICO or ICO return duration is not over yet\r\n    *   @param _investor     address which tokens will be burnt\r\n    *   @param _logString    string which contains payment information\r\n    */\r\n    function returnOtherCrypto(\r\n        address _investor,\r\n        string _logString\r\n    )\r\n        external\r\n        refundManagerOnly {\r\n        uint256 tokens = 0;\r\n        require(!returnPeriodExpired);\r\n        if (statusICO == StatusICO.PreIcoStarted) {\r\n            tokens = tokensPreIcoInOtherCrypto[_investor];\r\n            tokensPreIcoInOtherCrypto[_investor] = 0;\r\n        }\r\n        if (statusICO == StatusICO.IcoStarted) {\r\n            tokens = tokensIcoInOtherCrypto[_investor];\r\n            tokensIcoInOtherCrypto[_investor] = 0;\r\n        }\r\n        AID.burnTokens(_investor, tokens);\r\n        LogReturnOtherCrypto(_investor, _logString);\r\n    }\r\n\r\n   /**\r\n    *   @dev Allows Company withdraw investments\r\n    */\r\n    function withdrawEther() external managerOnly {\r\n        require(statusICO == StatusICO.PreIcoFinished || statusICO == StatusICO.IcoFinished);\r\n        Company.transfer(this.balance);\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n *   @title AidaToken\r\n *   @dev Aida token contract\r\n */\r\ncontract AidaToken is ERC20 {\r\n    using SafeMath for uint256;\r\n    string public name = \"Aida TOKEN\";\r\n    string public symbol = \"AID\";\r\n    uint256 public decimals = 18;\r\n\r\n    // Ico contract address\r\n    address public ico;\r\n    event Burn(address indexed from, uint256 value);\r\n\r\n    // Disables/enables token transfers\r\n    bool public tokensAreFrozen = true;\r\n\r\n    // Allows execution by the owner only\r\n    modifier icoOnly {\r\n        require(msg.sender == ico);\r\n        _;\r\n    }\r\n\r\n   /**\r\n    *   @dev Contract constructor function sets Ico address\r\n    *   @param _ico          ico address\r\n    */\r\n    function AidaToken(address _ico) public {\r\n        ico = _ico;\r\n    }\r\n\r\n   /**\r\n    *   @dev Mint tokens\r\n    *   @param _holder       beneficiary address the tokens will be issued to\r\n    *   @param _value        number of tokens to issue\r\n    */\r\n    function mintTokens(address _holder, uint256 _value) external icoOnly {\r\n        require(_value > 0);\r\n        balances[_holder] = balances[_holder].add(_value);\r\n        totalSupply = totalSupply.add(_value);\r\n        Transfer(0x0, _holder, _value);\r\n    }\r\n\r\n   /**\r\n    *   @dev Enables token transfers\r\n    */\r\n    function defrostTokens() external icoOnly {\r\n      tokensAreFrozen = false;\r\n    }\r\n\r\n   /**\r\n    *   @dev Disables token transfers\r\n    */\r\n    function frostTokens() external icoOnly {\r\n      tokensAreFrozen = true;\r\n    }\r\n\r\n   /**\r\n    *   @dev Burn Tokens\r\n    *   @param _investor     token holder address which the tokens will be burnt\r\n    *   @param _value        number of tokens to burn\r\n    */\r\n    function burnTokens(address _investor, uint256 _value) external icoOnly {\r\n        require(balances[_investor] > 0);\r\n        totalSupply = totalSupply.sub(_value);\r\n        balances[_investor] = balances[_investor].sub(_value);\r\n        Burn(_investor, _value);\r\n    }\r\n\r\n   /**\r\n    *   @dev Get balance of investor\r\n    *   @param _owner        investor's address\r\n    *   @return              balance of investor\r\n    */\r\n    function balanceOf(address _owner) public constant returns(uint256) {\r\n      return balances[_owner];\r\n    }\r\n\r\n   /**\r\n    *   @dev Send coins\r\n    *   throws on any error rather then return a false flag to minimize\r\n    *   user errors\r\n    *   @param _to           target address\r\n    *   @param _amount       transfer amount\r\n    *\r\n    *   @return true if the transfer was successful\r\n    */\r\n    function transfer(address _to, uint256 _amount) public returns(bool) {\r\n        require(!tokensAreFrozen);\r\n        balances[msg.sender] = balances[msg.sender].sub(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        Transfer(msg.sender, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n   /**\r\n    *   @dev An account/contract attempts to get the coins\r\n    *   throws on any error rather then return a false flag to minimize user errors\r\n    *\r\n    *   @param _from         source address\r\n    *   @param _to           target address\r\n    *   @param _amount       transfer amount\r\n    *\r\n    *   @return true if the transfer was successful\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _amount) public returns(bool) {\r\n        require(!tokensAreFrozen);\r\n        balances[_from] = balances[_from].sub(_amount);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        Transfer(_from, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n   /**\r\n    *   @dev Allows another account/contract to spend some tokens on its behalf\r\n    *   throws on any error rather then return a false flag to minimize user errors\r\n    *\r\n    *   also, to minimize the risk of the approve/transferFrom attack vector\r\n    *   approve has to be called twice in 2 separate transactions - once to\r\n    *   change the allowance to 0 and secondly to change it to the new allowance\r\n    *   value\r\n    *\r\n    *   @param _spender      approved address\r\n    *   @param _amount       allowance amount\r\n    *\r\n    *   @return true if the approval was successful\r\n    */\r\n    function approve(address _spender, uint256 _amount) public returns(bool) {\r\n        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\r\n        allowed[msg.sender][_spender] = _amount;\r\n        Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n   /**\r\n    *   @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n    *\r\n    *   @param _owner        the address which owns the funds\r\n    *   @param _spender      the address which will spend the funds\r\n    *\r\n    *   @return              the amount of tokens still avaible for the spender\r\n    */\r\n    function allowance(address _owner, address _spender) public constant returns(uint256) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_aidValue\",\"type\":\"uint256\"},{\"name\":\"_txHash\",\"type\":\"string\"}],\"name\":\"buyForInvestor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"AID\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"returnPeriodExpired\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokensIcoInOtherCrypto\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Controller_Address1\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pausePreIco\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishPreIco\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startRefunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokensPreIco\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_RateEth\",\"type\":\"uint256\"}],\"name\":\"setRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Controller_Address3\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PartnersFund\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RefundManager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BountyFund\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TeamFund\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"getBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Company\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Token_Price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enableTokensTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Manager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokensIco\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startIco\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"ethPreIco\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Tokens_Per_Dollar\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_logString\",\"type\":\"string\"}],\"name\":\"returnOtherCrypto\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokensPreIcoInOtherCrypto\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableTokensTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startPreIco\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Controller_Address2\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"used\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pauseIco\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"ethIco\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Rate_Eth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stopRefunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"returnEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishIco\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Oracle\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_Company\",\"type\":\"address\"},{\"name\":\"_BountyFund\",\"type\":\"address\"},{\"name\":\"_PartnersFund\",\"type\":\"address\"},{\"name\":\"_TeamFund\",\"type\":\"address\"},{\"name\":\"_Manager\",\"type\":\"address\"},{\"name\":\"_Controller_Address1\",\"type\":\"address\"},{\"name\":\"_Controller_Address2\",\"type\":\"address\"},{\"name\":\"_Controller_Address3\",\"type\":\"address\"},{\"name\":\"_Oracle\",\"type\":\"address\"},{\"name\":\"_RefundManager\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogStartPreICO\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogPausePreICO\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogFinishPreICO\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogStartICO\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogPauseICO\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"bountyFund\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"partnersFund\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"teamFund\",\"type\":\"address\"}],\"name\":\"LogFinishICO\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"aidValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"txHash\",\"type\":\"string\"}],\"name\":\"LogBuyForInvestor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"eth\",\"type\":\"uint256\"}],\"name\":\"LogReturnEth\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"logString\",\"type\":\"string\"}],\"name\":\"LogReturnOtherCrypto\",\"type\":\"event\"}]","ContractName":"AidaICO","CompilerVersion":"v0.4.20-nightly.2017.12.20+commit.efc198d5","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000470de00943787c7d8ac9810045f55d9a52e34ba400000000000000000000000022a2f9f553dcf48b61ecb7bf34e7d72671cf3c6d0000000000000000000000002e47bf669e50e42b80e1d1a6bdedb0e59a03f73a0000000000000000000000007ee98363def3d2798708eccfc1e1e4a19dee719c000000000000000000000000a09913e7e13dd67ef0bbd861bd92ce35c2a70f600000000000000000000000007d70babb5ca244cde05fba405d0b556d9312ce36000000000000000000000000d2118eff522be6af4cd72c2fa0b415cfbee3a3ab0000000000000000000000003de8c08b7955158f69500a260ac8c06430c335d4000000000000000000000000dea0ab96c2b90479dddb0b6fd97f889169d529de00000000000000000000000096711497d611499744c8073bc7c91b8656fed86d","Library":"","SwarmSource":"bzzr://e33af2bea11739665576641467a4a3ba0880abc3f6a254510c37ad420a4cef6b"}]}