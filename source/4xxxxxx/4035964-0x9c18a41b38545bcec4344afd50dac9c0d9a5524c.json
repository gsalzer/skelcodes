{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n// SafeMath Taken From FirstBlood\r\ncontract SafeMath {\r\n    function safeMul(uint a, uint b) internal returns (uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function safeDiv(uint a, uint b) internal returns (uint) {\r\n        assert(b > 0);\r\n        uint c = a / b;\r\n        assert(a == b * c + a % b);\r\n        return c;\r\n    }\r\n\r\n    function safeSub(uint a, uint b) internal returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function safeAdd(uint a, uint b) internal returns (uint) {\r\n        uint c = a + b;\r\n        assert(c>=a && c>=b);\r\n        return c;\r\n    }\r\n}\r\n\r\n// ERC20 Interface\r\ncontract ERC20 {\r\n    function totalSupply() constant returns (uint totalSupply);\r\n    function balanceOf(address _owner) constant returns (uint balance);\r\n    function transfer(address _to, uint _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool success);\r\n    function approve(address _spender, uint _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\n// ERC20Token\r\ncontract ERC20Token is ERC20, SafeMath {\r\n\r\n    mapping(address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalTokens; \r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n            balances[_to] = safeAdd(balances[_to], _value);\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        var _allowance = allowed[_from][msg.sender];\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] = safeAdd(balances[_to], _value);\r\n            balances[_from] = safeSub(balances[_from], _value);\r\n            allowed[_from][msg.sender] = safeSub(_allowance, _value);\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function totalSupply() constant returns (uint256) {\r\n        return totalTokens;\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n}\r\n\r\ncontract Wolk is ERC20Token {\r\n\r\n    // TOKEN INFO\r\n    string  public constant name = \"Wolk Protocol Token\";\r\n    string  public constant symbol = \"WOLK\";\r\n    uint256 public constant decimals = 18;\r\n\r\n    // RESERVE\r\n    uint256 public reserveBalance = 0; \r\n    uint16  public constant percentageETHReserve = 20;\r\n\r\n    // CONTRACT OWNER\r\n    address public owner = msg.sender;      \r\n    address public multisigWallet;\r\n    modifier onlyOwner { assert(msg.sender == owner); _; }\r\n\r\n    // TOKEN GENERATION EVENT\r\n    mapping (address => uint256) contribution;\r\n    uint256 public constant tokenGenerationMin = 50 * 10**6 * 10**decimals;\r\n    uint256 public constant tokenGenerationMax = 500 * 10**6 * 10**decimals;\r\n    uint256 public start_block; \r\n    uint256 public end_block;\r\n    bool    public saleCompleted = false;\r\n    modifier isTransferable { assert(saleCompleted); _; }\r\n\r\n    // WOLK SETTLERS\r\n    mapping (address => bool) settlers;\r\n    modifier onlySettler { assert(settlers[msg.sender] == true); _; }\r\n\r\n    // TOKEN GENERATION EVENTLOG\r\n    event WolkCreated(address indexed _to, uint256 _tokenCreated);\r\n    event WolkDestroyed(address indexed _from, uint256 _tokenDestroyed);\r\n    event LogRefund(address indexed _to, uint256 _value);\r\n\r\n    // @param _startBlock\r\n    // @param _endBlock\r\n    // @param _wolkWallet\r\n    // @return success\r\n    // @dev Wolk Genesis Event [only accessible by Contract Owner]\r\n    function wolkGenesis(uint256 _startBlock, uint256 _endBlock, address _wolkWallet) onlyOwner returns (bool success){\r\n        require( (totalTokens < 1) && (!settlers[msg.sender]) && (_endBlock > _startBlock) );\r\n        start_block = _startBlock;\r\n        end_block = _endBlock;\r\n        multisigWallet = _wolkWallet;\r\n        settlers[msg.sender] = true;\r\n        return true;\r\n    }\r\n\r\n    // @param _newOwner\r\n    // @return success\r\n    // @dev Transfering Contract Ownership. [only accessible by current Contract Owner]\r\n    function changeOwner(address _newOwner) onlyOwner returns (bool success){\r\n        owner = _newOwner;\r\n        settlers[_newOwner] = true;\r\n        return true;\r\n    }\r\n\r\n    // @dev Token Generation Event for Wolk Protocol Token. TGE Participant send Eth into this func in exchange of Wolk Protocol Token\r\n    function tokenGenerationEvent() payable external {\r\n        require(!saleCompleted);\r\n        require( (block.number >= start_block) && (block.number <= end_block) );\r\n        uint256 tokens = safeMul(msg.value, 5*10**9); //exchange rate\r\n        uint256 checkedSupply = safeAdd(totalTokens, tokens);\r\n        require(checkedSupply <= tokenGenerationMax);\r\n        totalTokens = checkedSupply;\r\n        balances[msg.sender] = safeAdd(balances[msg.sender], tokens);  \r\n        contribution[msg.sender] = safeAdd(contribution[msg.sender], msg.value);  \r\n        WolkCreated(msg.sender, tokens); // logs token creation\r\n    }\r\n\r\n    // @dev If Token Generation Minimum is Not Met, TGE Participants can call this func and request for refund\r\n    function refund() external {\r\n        require( (contribution[msg.sender] > 0) && (!saleCompleted) && (totalTokens < tokenGenerationMin) && (block.number > end_block) );\r\n        uint256 tokenBalance = balances[msg.sender];\r\n        uint256 refundBalance = contribution[msg.sender];\r\n        balances[msg.sender] = 0;\r\n        contribution[msg.sender] = 0;\r\n        totalTokens = safeSub(totalTokens, tokenBalance);\r\n        WolkDestroyed(msg.sender, tokenBalance);\r\n        LogRefund(msg.sender, refundBalance);\r\n        msg.sender.transfer(refundBalance); \r\n    }\r\n\r\n    // @dev Finalizing the Token Generation Event. 20% of Eth will be kept in contract to provide liquidity\r\n    function finalize() onlyOwner {\r\n        require( (!saleCompleted) && (totalTokens >= tokenGenerationMin) );\r\n        saleCompleted = true;\r\n        end_block = block.number;\r\n        reserveBalance = safeDiv(safeMul(this.balance, percentageETHReserve), 100);\r\n        var withdrawalBalance = safeSub(this.balance, reserveBalance);\r\n        msg.sender.transfer(withdrawalBalance);\r\n    }\r\n}\r\n\r\ncontract WolkProtocol is Wolk {\r\n\r\n    // WOLK NETWORK PROTOCOL\r\n    uint256 public burnBasisPoints = 500;  // Burn rate (in BP) when Service Provider withdraws from data buyers' accounts\r\n    mapping (address => mapping (address => bool)) authorized; // holds which accounts have approved which Service Providers\r\n    mapping (address => uint256) feeBasisPoints;   // Fee (in BP) earned by Service Provider when depositing to data seller \r\n\r\n    // WOLK PROTOCOL Events:\r\n    event AuthorizeServiceProvider(address indexed _owner, address _serviceProvider);\r\n    event DeauthorizeServiceProvider(address indexed _owner, address _serviceProvider);\r\n    event SetServiceProviderFee(address indexed _serviceProvider, uint256 _feeBasisPoints);\r\n    event BurnTokens(address indexed _from, address indexed _serviceProvider, uint256 _value);\r\n\r\n    // @param  _burnBasisPoints\r\n    // @return success\r\n    // @dev Set BurnRate on Wolk Protocol -- only Wolk Foundation can set this, affects Service Provider settleBuyer\r\n    function setBurnRate(uint256 _burnBasisPoints) onlyOwner returns (bool success) {\r\n        require( (_burnBasisPoints > 0) && (_burnBasisPoints <= 1000) );\r\n        burnBasisPoints = _burnBasisPoints;\r\n        return true;\r\n    }\r\n\r\n    // @param  _serviceProvider\r\n    // @param  _feeBasisPoints\r\n    // @return success\r\n    // @dev Set Service Provider fee -- only Contract Owner can do this, affects Service Provider settleSeller\r\n    function setServiceFee(address _serviceProvider, uint256 _feeBasisPoints) onlyOwner returns (bool success) {\r\n        if ( _feeBasisPoints <= 0 || _feeBasisPoints > 4000){\r\n            // revoke Settler privilege\r\n            settlers[_serviceProvider] = false;\r\n            feeBasisPoints[_serviceProvider] = 0;\r\n            return false;\r\n        }else{\r\n            feeBasisPoints[_serviceProvider] = _feeBasisPoints;\r\n            settlers[_serviceProvider] = true;\r\n            SetServiceProviderFee(_serviceProvider, _feeBasisPoints);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    // @param  _serviceProvider\r\n    // @return _feeBasisPoints\r\n    // @dev Check service ee (in BP) for a given provider\r\n    function checkServiceFee(address _serviceProvider) constant returns (uint256 _feeBasisPoints) {\r\n        return feeBasisPoints[_serviceProvider];\r\n    }\r\n\r\n    // @param  _buyer\r\n    // @param  _value\r\n    // @return success\r\n    // @dev Service Provider Settlement with Buyer: a small percent is burnt (set in setBurnRate, stored in burnBasisPoints) when funds are transferred from buyer to Service Provider [only accessible by settlers]\r\n    function settleBuyer(address _buyer, uint256 _value) onlySettler returns (bool success) {\r\n        require( (burnBasisPoints > 0) && (burnBasisPoints <= 1000) && authorized[_buyer][msg.sender] ); // Buyer must authorize Service Provider \r\n        if ( balances[_buyer] >= _value && _value > 0) {\r\n            var burnCap = safeDiv(safeMul(_value, burnBasisPoints), 10000);\r\n            var transferredToServiceProvider = safeSub(_value, burnCap);\r\n            balances[_buyer] = safeSub(balances[_buyer], _value);\r\n            balances[msg.sender] = safeAdd(balances[msg.sender], transferredToServiceProvider);\r\n            totalTokens = safeSub(totalTokens, burnCap);\r\n            Transfer(_buyer, msg.sender, transferredToServiceProvider);\r\n            BurnTokens(_buyer, msg.sender, burnCap);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    } \r\n\r\n    // @param  _seller\r\n    // @param  _value\r\n    // @return success\r\n    // @dev Service Provider Settlement with Seller: a small percent is kept by Service Provider (set in setServiceFee, stored in feeBasisPoints) when funds are transferred from Service Provider to seller [only accessible by settlers]\r\n    function settleSeller(address _seller, uint256 _value) onlySettler returns (bool success) {\r\n        // Service Providers have a % fee for Sellers (e.g. 20%)\r\n        var serviceProviderBP = feeBasisPoints[msg.sender];\r\n        require( (serviceProviderBP > 0) && (serviceProviderBP <= 4000) );\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            var fee = safeDiv(safeMul(_value, serviceProviderBP), 10000);\r\n            var transferredToSeller = safeSub(_value, fee);\r\n            balances[_seller] = safeAdd(balances[_seller], transferredToSeller);\r\n            Transfer(msg.sender, _seller, transferredToSeller);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // @param _providerToAdd\r\n    // @return success\r\n    // @dev Buyer authorizes the Service Provider (to call settleBuyer). For security reason, _providerToAdd needs to be whitelisted by Wolk Foundation first\r\n    function authorizeProvider(address _providerToAdd) returns (bool success) {\r\n        require(settlers[_providerToAdd]);\r\n        authorized[msg.sender][_providerToAdd] = true;\r\n        AuthorizeServiceProvider(msg.sender, _providerToAdd);\r\n        return true;\r\n    }\r\n\r\n    // @param _providerToRemove\r\n    // @return success\r\n    // @dev Buyer deauthorizes the Service Provider (from calling settleBuyer)\r\n    function deauthorizeProvider(address _providerToRemove) returns (bool success) {\r\n        authorized[msg.sender][_providerToRemove] = false;\r\n        DeauthorizeServiceProvider(msg.sender, _providerToRemove);\r\n        return true;\r\n    }\r\n\r\n    // @param _owner\r\n    // @param _serviceProvider\r\n    // @return authorizationStatus\r\n    // @dev Check authorization between account and Service Provider\r\n    function checkAuthorization(address _owner, address _serviceProvider) constant returns (bool authorizationStatus) {\r\n        return authorized[_owner][_serviceProvider];\r\n    }\r\n\r\n    // @param _owner\r\n    // @param _providerToAdd\r\n    // @return authorizationStatus\r\n    // @dev Grant authorization between account and Service Provider on buyers' behalf [only accessible by Contract Owner]\r\n    // @note Explicit permission from balance owner MUST be obtained beforehand\r\n    function grantService(address _owner, address _providerToAdd) onlyOwner returns (bool authorizationStatus) {\r\n        var isPreauthorized = authorized[_owner][msg.sender];\r\n        if (isPreauthorized && settlers[_providerToAdd] ) {\r\n            authorized[_owner][_providerToAdd] = true;\r\n            AuthorizeServiceProvider(msg.sender, _providerToAdd);\r\n            return true;\r\n        }else{\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // @param _owner\r\n    // @param _providerToRemove\r\n    // @return authorization_status\r\n    // @dev Revoke authorization between account and Service Provider on buyers' behalf [only accessible by Contract Owner]\r\n    // @note Explicit permission from balance owner are NOT required for disabling ill-intent Service Provider\r\n    function removeService(address _owner, address _providerToRemove) onlyOwner returns (bool authorizationStatus) {\r\n        authorized[_owner][_providerToRemove] = false;\r\n        DeauthorizeServiceProvider(_owner, _providerToRemove);\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract BancorFormula is SafeMath {\r\n\r\n    // Taken from https://github.com/bancorprotocol/contracts/blob/master/solidity/contracts/BancorFormula.sol\r\n    uint8 constant PRECISION   = 32;  // fractional bits\r\n    uint256 constant FIXED_ONE = uint256(1) << PRECISION; // 0x100000000\r\n    uint256 constant FIXED_TWO = uint256(2) << PRECISION; // 0x200000000\r\n    uint256 constant MAX_VAL   = uint256(1) << (256 - PRECISION); // 0x0000000100000000000000000000000000000000000000000000000000000000\r\n\r\n    /**\r\n        @dev given a token supply, reserve, CRR and a deposit amount (in the reserve token), calculates the return for a given change (in the main token)\r\n\r\n        Formula:\r\n        Return = _supply * ((1 + _depositAmount / _reserveBalance) ^ (_reserveRatio / 100) - 1)\r\n\r\n        @param _supply             token total supply\r\n        @param _reserveBalance     total reserve\r\n        @param _reserveRatio       constant reserve ratio, 1-100\r\n        @param _depositAmount      deposit amount, in reserve token\r\n\r\n        @return purchase return amount\r\n    */\r\n    function calculatePurchaseReturn(uint256 _supply, uint256 _reserveBalance, uint16 _reserveRatio, uint256 _depositAmount) public constant returns (uint256) {\r\n        // validate input\r\n        require(_supply != 0 && _reserveBalance != 0 && _reserveRatio > 0 && _reserveRatio <= 100);\r\n\r\n        // special case for 0 deposit amount\r\n        if (_depositAmount == 0)\r\n            return 0;\r\n\r\n        uint256 baseN = safeAdd(_depositAmount, _reserveBalance);\r\n        uint256 temp;\r\n\r\n        // special case if the CRR = 100\r\n        if (_reserveRatio == 100) {\r\n            temp = safeMul(_supply, baseN) / _reserveBalance;\r\n            return safeSub(temp, _supply); \r\n        }\r\n\r\n        uint256 resN = power(baseN, _reserveBalance, _reserveRatio, 100);\r\n\r\n        temp = safeMul(_supply, resN) / FIXED_ONE;\r\n\r\n        uint256 result =  safeSub(temp, _supply);\r\n        // from the result, we deduct the minimal increment, which is a         \r\n        // function of S and precision.       \r\n        return safeSub(result, _supply / 0x100000000);\r\n     }\r\n\r\n    /**\r\n        @dev given a token supply, reserve, CRR and a sell amount (in the main token), calculates the return for a given change (in the reserve token)\r\n\r\n        Formula:\r\n        Return = _reserveBalance * (1 - (1 - _sellAmount / _supply) ^ (1 / (_reserveRatio / 100)))\r\n\r\n        @param _supply             token total supply\r\n        @param _reserveBalance     total reserve\r\n        @param _reserveRatio       constant reserve ratio, 1-100\r\n        @param _sellAmount         sell amount, in the token itself\r\n\r\n        @return sale return amount\r\n    */\r\n    function calculateSaleReturn(uint256 _supply, uint256 _reserveBalance, uint16 _reserveRatio, uint256 _sellAmount) public constant returns (uint256) {\r\n        // validate input\r\n        require(_supply != 0 && _reserveBalance != 0 && _reserveRatio > 0 && _reserveRatio <= 100 && _sellAmount <= _supply);\r\n\r\n        // special case for 0 sell amount\r\n        if (_sellAmount == 0)\r\n            return 0;\r\n\r\n        uint256 baseN = safeSub(_supply, _sellAmount);\r\n        uint256 temp1;\r\n        uint256 temp2;\r\n\r\n        // special case if the CRR = 100\r\n        if (_reserveRatio == 100) {\r\n            temp1 = safeMul(_reserveBalance, _supply);\r\n            temp2 = safeMul(_reserveBalance, baseN);\r\n            return safeSub(temp1, temp2) / _supply;\r\n        }\r\n\r\n        // special case for selling the entire supply\r\n        if (_sellAmount == _supply)\r\n            return _reserveBalance;\r\n\r\n        uint256 resN = power(_supply, baseN, 100, _reserveRatio);\r\n\r\n        temp1 = safeMul(_reserveBalance, resN);\r\n        temp2 = safeMul(_reserveBalance, FIXED_ONE);\r\n\r\n        uint256 result = safeSub(temp1, temp2) / resN;\r\n\r\n        // from the result, we deduct the minimal increment, which is a         \r\n        // function of R and precision.       \r\n        return safeSub(result, _reserveBalance / 0x100000000);\r\n    }\r\n\r\n    /**\r\n        @dev Calculate (_baseN / _baseD) ^ (_expN / _expD)\r\n        Returns result upshifted by PRECISION\r\n\r\n        This method is overflow-safe\r\n    */ \r\n    function power(uint256 _baseN, uint256 _baseD, uint32 _expN, uint32 _expD) internal returns (uint256 resN) {\r\n        uint256 logbase = ln(_baseN, _baseD);\r\n        // Not using safeDiv here, since safeDiv protects against\r\n        // precision loss. It’s unavoidable, however\r\n        // Both `ln` and `fixedExp` are overflow-safe. \r\n        resN = fixedExp(safeMul(logbase, _expN) / _expD);\r\n        return resN;\r\n    }\r\n    \r\n    /**\r\n        input range: \r\n            - numerator: [1, uint256_max >> PRECISION]    \r\n            - denominator: [1, uint256_max >> PRECISION]\r\n        output range:\r\n            [0, 0x9b43d4f8d6]\r\n\r\n        This method asserts outside of bounds\r\n\r\n    */\r\n    function ln(uint256 _numerator, uint256 _denominator) internal returns (uint256) {\r\n        // denominator > numerator: less than one yields negative values. Unsupported\r\n        assert(_denominator <= _numerator);\r\n\r\n        // log(1) is the lowest we can go\r\n        assert(_denominator != 0 && _numerator != 0);\r\n\r\n        // Upper 32 bits are scaled off by PRECISION\r\n        assert(_numerator < MAX_VAL);\r\n        assert(_denominator < MAX_VAL);\r\n\r\n        return fixedLoge( (_numerator * FIXED_ONE) / _denominator);\r\n    }\r\n\r\n    /**\r\n        input range: \r\n            [0x100000000,uint256_max]\r\n        output range:\r\n            [0, 0x9b43d4f8d6]\r\n\r\n        This method asserts outside of bounds\r\n\r\n    */\r\n    function fixedLoge(uint256 _x) internal returns (uint256 logE) {\r\n        /*\r\n        Since `fixedLog2_min` output range is max `0xdfffffffff` \r\n        (40 bits, or 5 bytes), we can use a very large approximation\r\n        for `ln(2)`. This one is used since it’s the max accuracy \r\n        of Python `ln(2)`\r\n\r\n        0xb17217f7d1cf78 = ln(2) * (1 << 56)\r\n        \r\n        */\r\n        //Cannot represent negative numbers (below 1)\r\n        assert(_x >= FIXED_ONE);\r\n\r\n        uint256 log2 = fixedLog2(_x);\r\n        logE = (log2 * 0xb17217f7d1cf78) >> 56;\r\n    }\r\n\r\n    /**\r\n        Returns log2(x >> 32) << 32 [1]\r\n        So x is assumed to be already upshifted 32 bits, and \r\n        the result is also upshifted 32 bits. \r\n        \r\n        [1] The function returns a number which is lower than the \r\n        actual value\r\n\r\n        input-range : \r\n            [0x100000000,uint256_max]\r\n        output-range: \r\n            [0,0xdfffffffff]\r\n\r\n        This method asserts outside of bounds\r\n\r\n    */\r\n    function fixedLog2(uint256 _x) internal returns (uint256) {\r\n        // Numbers below 1 are negative. \r\n        assert( _x >= FIXED_ONE);\r\n\r\n        uint256 hi = 0;\r\n        while (_x >= FIXED_TWO) {\r\n            _x >>= 1;\r\n            hi += FIXED_ONE;\r\n        }\r\n\r\n        for (uint8 i = 0; i < PRECISION; ++i) {\r\n            _x = (_x * _x) / FIXED_ONE;\r\n            if (_x >= FIXED_TWO) {\r\n                _x >>= 1;\r\n                hi += uint256(1) << (PRECISION - 1 - i);\r\n            }\r\n        }\r\n\r\n        return hi;\r\n    }\r\n\r\n    /**\r\n        fixedExp is a ‘protected’ version of `fixedExpUnsafe`, which \r\n        asserts instead of overflows\r\n    */\r\n    function fixedExp(uint256 _x) internal returns (uint256) {\r\n        assert(_x <= 0x386bfdba29);\r\n        return fixedExpUnsafe(_x);\r\n    }\r\n\r\n    /**\r\n        fixedExp \r\n        Calculates e^x according to maclauren summation:\r\n\r\n        e^x = 1+x+x^2/2!...+x^n/n!\r\n\r\n        and returns e^(x>>32) << 32, that is, upshifted for accuracy\r\n\r\n        Input range:\r\n            - Function ok at    <= 242329958953 \r\n            - Function fails at >= 242329958954\r\n\r\n        This method is is visible for testcases, but not meant for direct use. \r\n \r\n        The values in this method been generated via the following python snippet: \r\n\r\n        def calculateFactorials():\r\n            “”\"Method to print out the factorials for fixedExp”“”\r\n\r\n            ni = []\r\n            ni.append( 295232799039604140847618609643520000000) # 34!\r\n            ITERATIONS = 34\r\n            for n in range( 1,  ITERATIONS,1 ) :\r\n                ni.append(math.floor(ni[n - 1] / n))\r\n            print( “\\n        “.join([“xi = (xi * _x) >> PRECISION;\\n        res += xi * %s;” % hex(int(x)) for x in ni]))\r\n\r\n    */\r\n    function fixedExpUnsafe(uint256 _x) internal returns (uint256) {\r\n    \r\n        uint256 xi = FIXED_ONE;\r\n        uint256 res = 0xde1bc4d19efcac82445da75b00000000 * xi;\r\n\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0xde1bc4d19efcb0000000000000000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x6f0de268cf7e58000000000000000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x2504a0cd9a7f72000000000000000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x9412833669fdc800000000000000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x1d9d4d714865f500000000000000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x4ef8ce836bba8c0000000000000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0xb481d807d1aa68000000000000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x16903b00fa354d000000000000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x281cdaac677b3400000000000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x402e2aad725eb80000000000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x5d5a6c9f31fe24000000000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x7c7890d442a83000000000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x9931ed540345280000000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0xaf147cf24ce150000000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0xbac08546b867d000000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0xbac08546b867d00000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0xafc441338061b8000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x9c3cabbc0056e000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x839168328705c80000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x694120286c04a0000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x50319e98b3d2c400;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x3a52a1e36b82020;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x289286e0fce002;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x1b0c59eb53400;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x114f95b55400;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0xaa7210d200;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x650139600;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x39b78e80;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x1fd8080;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x10fbc0;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x8c40;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x462;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x22;\r\n\r\n        return res / 0xde1bc4d19efcac82445da75b00000000;\r\n    }  \r\n}\r\n\r\ncontract WolkExchange is WolkProtocol, BancorFormula {\r\n\r\n    uint256 public maxPerExchangeBP = 50;\r\n\r\n    // @param  _maxPerExchange\r\n    // @return success\r\n    // @dev Set max sell token amount per transaction -- only Wolk Foundation can set this\r\n    function setMaxPerExchange(uint256 _maxPerExchange) onlyOwner returns (bool success) {\r\n        require( (_maxPerExchange >= 10) && (_maxPerExchange <= 100) );\r\n        maxPerExchangeBP = _maxPerExchange;\r\n        return true;\r\n    }\r\n\r\n    // @return Estimated Liquidation Cap\r\n    // @dev Liquidation Cap per transaction is used to ensure proper price discovery for Wolk Exchange \r\n    function EstLiquidationCap() public constant returns (uint256) {\r\n        if (saleCompleted){\r\n            var liquidationMax  = safeDiv(safeMul(totalTokens, maxPerExchangeBP), 10000);\r\n            if (liquidationMax < 100 * 10**decimals){ \r\n                liquidationMax = 100 * 10**decimals;\r\n            }\r\n            return liquidationMax;   \r\n        }else{\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    // @param _wolkAmount\r\n    // @return ethReceivable\r\n    // @dev send Wolk into contract in exchange for eth, at an exchange rate based on the Bancor Protocol derivation and decrease totalSupply accordingly\r\n    function sellWolk(uint256 _wolkAmount) isTransferable() external returns(uint256) {\r\n        uint256 sellCap = EstLiquidationCap();\r\n        uint256 ethReceivable = calculateSaleReturn(totalTokens, reserveBalance, percentageETHReserve, _wolkAmount);\r\n        require( (sellCap >= _wolkAmount) && (balances[msg.sender] >= _wolkAmount) && (this.balance > ethReceivable) );\r\n        balances[msg.sender] = safeSub(balances[msg.sender], _wolkAmount);\r\n        totalTokens = safeSub(totalTokens, _wolkAmount);\r\n        reserveBalance = safeSub(this.balance, ethReceivable);\r\n        WolkDestroyed(msg.sender, _wolkAmount);\r\n        msg.sender.transfer(ethReceivable);\r\n        return ethReceivable;     \r\n    }\r\n\r\n    // @return wolkReceivable    \r\n    // @dev send eth into contract in exchange for Wolk tokens, at an exchange rate based on the Bancor Protocol derivation and increase totalSupply accordingly\r\n    function purchaseWolk() isTransferable() payable external returns(uint256){\r\n        uint256 wolkReceivable = calculatePurchaseReturn(totalTokens, reserveBalance, percentageETHReserve, msg.value);\r\n        totalTokens = safeAdd(totalTokens, wolkReceivable);\r\n        balances[msg.sender] = safeAdd(balances[msg.sender], wolkReceivable);\r\n        reserveBalance = safeAdd(reserveBalance, msg.value);\r\n        WolkCreated(msg.sender, wolkReceivable);\r\n        return wolkReceivable;\r\n    }\r\n\r\n    // @param _exactWolk\r\n    // @return ethRefundable\r\n    // @dev send eth into contract in exchange for exact amount of Wolk tokens with margin of error of no more than 1 Wolk. \r\n    // @note Purchase with the insufficient eth will be cancelled and returned; exceeding eth balanance from purchase, if any, will be returned.     \r\n    function purchaseExactWolk(uint256 _exactWolk) isTransferable() payable external returns(uint256){\r\n        uint256 wolkReceivable = calculatePurchaseReturn(totalTokens, reserveBalance, percentageETHReserve, msg.value);\r\n        if (wolkReceivable < _exactWolk){\r\n            // Cancel Insufficient Purchase\r\n            revert();\r\n            return msg.value;\r\n        }else {\r\n            var wolkDiff = safeSub(wolkReceivable, _exactWolk);\r\n            uint256 ethRefundable = 0;\r\n            // Refund if wolkDiff exceeds 1 Wolk\r\n            if (wolkDiff < 10**decimals){\r\n                // Credit Buyer Full amount if within margin of error\r\n                totalTokens = safeAdd(totalTokens, wolkReceivable);\r\n                balances[msg.sender] = safeAdd(balances[msg.sender], wolkReceivable);\r\n                reserveBalance = safeAdd(reserveBalance, msg.value);\r\n                WolkCreated(msg.sender, wolkReceivable);\r\n                return 0;     \r\n            }else{\r\n                ethRefundable = calculateSaleReturn( safeAdd(totalTokens, wolkReceivable) , safeAdd(reserveBalance, msg.value), percentageETHReserve, wolkDiff);\r\n                totalTokens = safeAdd(totalTokens, _exactWolk);\r\n                balances[msg.sender] = safeAdd(balances[msg.sender], _exactWolk);\r\n                reserveBalance = safeAdd(reserveBalance, safeSub(msg.value, ethRefundable));\r\n                WolkCreated(msg.sender, _exactWolk);\r\n                msg.sender.transfer(ethRefundable);\r\n                return ethRefundable;\r\n            }\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_wolkAmount\",\"type\":\"uint256\"}],\"name\":\"sellWolk\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_providerToAdd\",\"type\":\"address\"}],\"name\":\"authorizeProvider\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_burnBasisPoints\",\"type\":\"uint256\"}],\"name\":\"setBurnRate\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"settleBuyer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"end_block\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"settleSeller\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenGenerationMin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_providerToRemove\",\"type\":\"address\"}],\"name\":\"deauthorizeProvider\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_serviceProvider\",\"type\":\"address\"}],\"name\":\"checkAuthorization\",\"outputs\":[{\"name\":\"authorizationStatus\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_serviceProvider\",\"type\":\"address\"}],\"name\":\"checkServiceFee\",\"outputs\":[{\"name\":\"_feeBasisPoints\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxPerExchangeBP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_providerToAdd\",\"type\":\"address\"}],\"name\":\"grantService\",\"outputs\":[{\"name\":\"authorizationStatus\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleCompleted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"percentageETHReserve\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"EstLiquidationCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_providerToRemove\",\"type\":\"address\"}],\"name\":\"removeService\",\"outputs\":[{\"name\":\"authorizationStatus\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multisigWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startBlock\",\"type\":\"uint256\"},{\"name\":\"_endBlock\",\"type\":\"uint256\"},{\"name\":\"_wolkWallet\",\"type\":\"address\"}],\"name\":\"wolkGenesis\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"tokenGenerationEvent\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"burnBasisPoints\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserveBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_supply\",\"type\":\"uint256\"},{\"name\":\"_reserveBalance\",\"type\":\"uint256\"},{\"name\":\"_reserveRatio\",\"type\":\"uint16\"},{\"name\":\"_depositAmount\",\"type\":\"uint256\"}],\"name\":\"calculatePurchaseReturn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxPerExchange\",\"type\":\"uint256\"}],\"name\":\"setMaxPerExchange\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenGenerationMax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"start_block\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"purchaseWolk\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_supply\",\"type\":\"uint256\"},{\"name\":\"_reserveBalance\",\"type\":\"uint256\"},{\"name\":\"_reserveRatio\",\"type\":\"uint16\"},{\"name\":\"_sellAmount\",\"type\":\"uint256\"}],\"name\":\"calculateSaleReturn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_exactWolk\",\"type\":\"uint256\"}],\"name\":\"purchaseExactWolk\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_serviceProvider\",\"type\":\"address\"},{\"name\":\"_feeBasisPoints\",\"type\":\"uint256\"}],\"name\":\"setServiceFee\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_serviceProvider\",\"type\":\"address\"}],\"name\":\"AuthorizeServiceProvider\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_serviceProvider\",\"type\":\"address\"}],\"name\":\"DeauthorizeServiceProvider\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_serviceProvider\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_feeBasisPoints\",\"type\":\"uint256\"}],\"name\":\"SetServiceProviderFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_serviceProvider\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"BurnTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenCreated\",\"type\":\"uint256\"}],\"name\":\"WolkCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenDestroyed\",\"type\":\"uint256\"}],\"name\":\"WolkDestroyed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"LogRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"WolkExchange","CompilerVersion":"v0.4.13+commit.fb4cb1a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://8731e89f25865fe44f68b5fb892da37debb9504ae05a41204badcd2c31765c7c"}]}