{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n/* The authentication manager details user accounts that have access to certain priviledges and keeps a permanent ledger of who has and has had these rights. */\r\ncontract AuthenticationManager {\r\n    /* Map addresses to admins */\r\n    mapping (address => bool) adminAddresses;\r\n\r\n    /* Map addresses to account readers */\r\n    mapping (address => bool) accountReaderAddresses;\r\n\r\n    /* Details of all admins that have ever existed */\r\n    address[] adminAudit;\r\n\r\n    /* Details of all account readers that have ever existed */\r\n    address[] accountReaderAudit;\r\n\r\n    /* Fired whenever an admin is added to the contract. */\r\n    event AdminAdded(address addedBy, address admin);\r\n\r\n    /* Fired whenever an admin is removed from the contract. */\r\n    event AdminRemoved(address removedBy, address admin);\r\n\r\n    /* Fired whenever an account-reader contract is added. */\r\n    event AccountReaderAdded(address addedBy, address account);\r\n\r\n    /* Fired whenever an account-reader contract is removed. */\r\n    event AccountReaderRemoved(address removedBy, address account);\r\n\r\n    /* When this contract is first setup we use the creator as the first admin */    \r\n    function AuthenticationManager() {\r\n        /* Set the first admin to be the person creating the contract */\r\n        adminAddresses[msg.sender] = true;\r\n        AdminAdded(0, msg.sender);\r\n        adminAudit.length++;\r\n        adminAudit[adminAudit.length - 1] = msg.sender;\r\n    }\r\n\r\n    /* Gets the contract version for validation */\r\n    function contractVersion() constant returns(uint256) {\r\n        // Admin contract identifies as 100YYYYMMDDHHMM\r\n        return 100201707171503;\r\n    }\r\n\r\n    /* Gets whether or not the specified address is currently an admin */\r\n    function isCurrentAdmin(address _address) constant returns (bool) {\r\n        return adminAddresses[_address];\r\n    }\r\n\r\n    /* Gets whether or not the specified address has ever been an admin */\r\n    function isCurrentOrPastAdmin(address _address) constant returns (bool) {\r\n        for (uint256 i = 0; i < adminAudit.length; i++)\r\n            if (adminAudit[i] == _address)\r\n                return true;\r\n        return false;\r\n    }\r\n\r\n    /* Gets whether or not the specified address is currently an account reader */\r\n    function isCurrentAccountReader(address _address) constant returns (bool) {\r\n        return accountReaderAddresses[_address];\r\n    }\r\n\r\n    /* Gets whether or not the specified address has ever been an admin */\r\n    function isCurrentOrPastAccountReader(address _address) constant returns (bool) {\r\n        for (uint256 i = 0; i < accountReaderAudit.length; i++)\r\n            if (accountReaderAudit[i] == _address)\r\n                return true;\r\n        return false;\r\n    }\r\n\r\n    /* Adds a user to our list of admins */\r\n    function addAdmin(address _address) {\r\n        /* Ensure we're an admin */\r\n        if (!isCurrentAdmin(msg.sender))\r\n            throw;\r\n\r\n        // Fail if this account is already admin\r\n        if (adminAddresses[_address])\r\n            throw;\r\n        \r\n        // Add the user\r\n        adminAddresses[_address] = true;\r\n        AdminAdded(msg.sender, _address);\r\n        adminAudit.length++;\r\n        adminAudit[adminAudit.length - 1] = _address;\r\n    }\r\n\r\n    /* Removes a user from our list of admins but keeps them in the history audit */\r\n    function removeAdmin(address _address) {\r\n        /* Ensure we're an admin */\r\n        if (!isCurrentAdmin(msg.sender))\r\n            throw;\r\n\r\n        /* Don't allow removal of self */\r\n        if (_address == msg.sender)\r\n            throw;\r\n\r\n        // Fail if this account is already non-admin\r\n        if (!adminAddresses[_address])\r\n            throw;\r\n\r\n        /* Remove this admin user */\r\n        adminAddresses[_address] = false;\r\n        AdminRemoved(msg.sender, _address);\r\n    }\r\n\r\n    /* Adds a user/contract to our list of account readers */\r\n    function addAccountReader(address _address) {\r\n        /* Ensure we're an admin */\r\n        if (!isCurrentAdmin(msg.sender))\r\n            throw;\r\n\r\n        // Fail if this account is already in the list\r\n        if (accountReaderAddresses[_address])\r\n            throw;\r\n        \r\n        // Add the user\r\n        accountReaderAddresses[_address] = true;\r\n        AccountReaderAdded(msg.sender, _address);\r\n        accountReaderAudit.length++;\r\n        accountReaderAudit[adminAudit.length - 1] = _address;\r\n    }\r\n\r\n    /* Removes a user/contracts from our list of account readers but keeps them in the history audit */\r\n    function removeAccountReader(address _address) {\r\n        /* Ensure we're an admin */\r\n        if (!isCurrentAdmin(msg.sender))\r\n            throw;\r\n\r\n        // Fail if this account is already not in the list\r\n        if (!accountReaderAddresses[_address])\r\n            throw;\r\n\r\n        /* Remove this admin user */\r\n        accountReaderAddresses[_address] = false;\r\n        AccountReaderRemoved(msg.sender, _address);\r\n    }\r\n}\r\n\r\n/* The transparency relayer contract is responsible for keeping an immutable ledger of account balances that can be audited at a later time .*/\r\ncontract TransparencyRelayer {\r\n    /* Represents what SIFT administration report the fund as being worth at a snapshot moment in time. */\r\n    struct FundValueRepresentation {\r\n        uint256 usdValue;\r\n        uint256 etherEquivalent;\r\n        uint256 suppliedTimestamp;\r\n        uint256 blockTimestamp;\r\n    }\r\n\r\n    /* Represents a published balance of a particular account at a moment in time. */\r\n    struct AccountBalanceRepresentation {\r\n        string accountType; /* Bitcoin, USD, etc. */\r\n        string accountIssuer; /* Kraken, Bank of America, etc. */\r\n        uint256 balance; /* Rounded to appropriate for balance - i.e. full USD or full BTC */\r\n        string accountReference; /* Could be crypto address, bank account number, etc. */\r\n        string validationUrl; /* Some validation URL - i.e. base64 encoded notary */\r\n        uint256 suppliedTimestamp;\r\n        uint256 blockTimestamp;\r\n    }\r\n\r\n    /* An array defining all the fund values as supplied by SIFT over the time of the contract. */\r\n    FundValueRepresentation[] public fundValues;\r\n    \r\n    /* An array defining the history of account balances over time. */\r\n    AccountBalanceRepresentation[] public accountBalances;\r\n\r\n    /* Defines the admin contract we interface with for credentails. */\r\n    AuthenticationManager authenticationManager;\r\n\r\n    /* Fired when the fund value is updated by an administrator. */\r\n    event FundValue(uint256 usdValue, uint256 etherEquivalent, uint256 suppliedTimestamp, uint256 blockTimestamp);\r\n\r\n    /* Fired when an account balance is being supplied in some confirmed form for future validation on the blockchain. */\r\n    event AccountBalance(string accountType, string accountIssuer, uint256 balance, string accountReference, string validationUrl, uint256 timestamp, uint256 blockTimestamp);\r\n\r\n    /* This modifier allows a method to only be called by current admins */\r\n    modifier adminOnly {\r\n        if (!authenticationManager.isCurrentAdmin(msg.sender)) throw;\r\n        _;\r\n    }\r\n\r\n    /* Create our contract and specify the location of other addresses */\r\n    function TransparencyRelayer(address _authenticationManagerAddress) {\r\n        /* Setup access to our other contracts and validate their versions */\r\n        authenticationManager = AuthenticationManager(_authenticationManagerAddress);\r\n        if (authenticationManager.contractVersion() != 100201707171503)\r\n            throw;\r\n    }\r\n\r\n    /* Gets the contract version for validation */\r\n    function contractVersion() constant returns(uint256) {\r\n        /* Transparency contract identifies as 200YYYYMMDDHHMM */\r\n        return 200201707071127;\r\n    }\r\n\r\n    /* Returns how many fund values are present in the market. */\r\n    function fundValueCount() constant returns (uint256 _count) {\r\n        _count = fundValues.length;\r\n    }\r\n\r\n    /* Returns how account balances are present in the market. */\r\n    function accountBalanceCount() constant returns (uint256 _count) {\r\n        _count = accountBalances.length;\r\n    }\r\n\r\n    /* Defines the current value of the funds assets in USD and ETHER */\r\n    function fundValuePublish(uint256 _usdTotalFund, uint256 _etherTotalFund, uint256 _definedTimestamp) adminOnly {\r\n        /* Store values */\r\n        fundValues.length++;\r\n        fundValues[fundValues.length - 1] = FundValueRepresentation(_usdTotalFund, _etherTotalFund, _definedTimestamp, now);\r\n\r\n        /* Audit this */\r\n        FundValue(_usdTotalFund, _etherTotalFund, _definedTimestamp, now);\r\n    }\r\n\r\n    function accountBalancePublish(string _accountType, string _accountIssuer, uint256 _balance, string _accountReference, string _validationUrl, uint256 _timestamp) adminOnly {\r\n        /* Store values */\r\n        accountBalances.length++;\r\n        accountBalances[accountBalances.length - 1] = AccountBalanceRepresentation(_accountType, _accountIssuer, _balance, _accountReference, _validationUrl, _timestamp, now);\r\n\r\n        /* Audit this */\r\n        AccountBalance(_accountType, _accountIssuer, _balance, _accountReference, _validationUrl, _timestamp, now);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"accountBalanceCount\",\"outputs\":[{\"name\":\"_count\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_accountType\",\"type\":\"string\"},{\"name\":\"_accountIssuer\",\"type\":\"string\"},{\"name\":\"_balance\",\"type\":\"uint256\"},{\"name\":\"_accountReference\",\"type\":\"string\"},{\"name\":\"_validationUrl\",\"type\":\"string\"},{\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"accountBalancePublish\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundValueCount\",\"outputs\":[{\"name\":\"_count\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_usdTotalFund\",\"type\":\"uint256\"},{\"name\":\"_etherTotalFund\",\"type\":\"uint256\"},{\"name\":\"_definedTimestamp\",\"type\":\"uint256\"}],\"name\":\"fundValuePublish\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"fundValues\",\"outputs\":[{\"name\":\"usdValue\",\"type\":\"uint256\"},{\"name\":\"etherEquivalent\",\"type\":\"uint256\"},{\"name\":\"suppliedTimestamp\",\"type\":\"uint256\"},{\"name\":\"blockTimestamp\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"accountBalances\",\"outputs\":[{\"name\":\"accountType\",\"type\":\"string\"},{\"name\":\"accountIssuer\",\"type\":\"string\"},{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"accountReference\",\"type\":\"string\"},{\"name\":\"validationUrl\",\"type\":\"string\"},{\"name\":\"suppliedTimestamp\",\"type\":\"uint256\"},{\"name\":\"blockTimestamp\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractVersion\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_authenticationManagerAddress\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"usdValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"etherEquivalent\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"suppliedTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"blockTimestamp\",\"type\":\"uint256\"}],\"name\":\"FundValue\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"accountType\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"accountIssuer\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"accountReference\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"validationUrl\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"blockTimestamp\",\"type\":\"uint256\"}],\"name\":\"AccountBalance\",\"type\":\"event\"}]","ContractName":"TransparencyRelayer","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000c6a3746aa3fec176559f0865fd5240159402a81f","Library":"","SwarmSource":"bzzr://c0fe089ba7759bb6a009eb7cd70eb9ec7fc9aeaa3d2b0070628dc287eabe83bf"}]}