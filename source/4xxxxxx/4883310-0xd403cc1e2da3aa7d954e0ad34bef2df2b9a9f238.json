{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\ninterface ERC20 {\r\n    function balanceOf(address _owner) public constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n}\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\ncontract Distribution {\r\n  using SafeMath for uint256;\r\n\r\n  enum State {\r\n    AwaitingTokens,\r\n    DistributingNormally,\r\n    DistributingProRata,\r\n    Done\r\n  }\r\n \r\n  address admin;\r\n  ERC20 tokenContract;\r\n  State state;\r\n  uint256 actualTotalTokens;\r\n  uint256 tokensTransferred;\r\n\r\n  bytes32[] contributionHashes;\r\n  uint256 expectedTotalTokens;\r\n\r\n  function Distribution(address _admin, ERC20 _tokenContract,\r\n                        bytes32[] _contributionHashes, uint256 _expectedTotalTokens) public {\r\n    expectedTotalTokens = _expectedTotalTokens;\r\n    contributionHashes = _contributionHashes;\r\n    tokenContract = _tokenContract;\r\n    admin = _admin;\r\n\r\n    state = State.AwaitingTokens;\r\n  }\r\n\r\n  function handleTokensReceived() public {\r\n    require(state == State.AwaitingTokens);\r\n    uint256 totalTokens = tokenContract.balanceOf(this);\r\n    require(totalTokens > 0);\r\n\r\n    tokensTransferred = 0;\r\n    if (totalTokens == expectedTotalTokens) {\r\n      state = State.DistributingNormally;\r\n    } else {\r\n      actualTotalTokens = totalTokens;\r\n      state = State.DistributingProRata;\r\n    }\r\n  }\r\n\r\n  function _numTokensForContributor(uint256 contributorExpectedTokens, State _state)\r\n      internal view returns (uint256) {\r\n    if (_state == State.DistributingNormally) {\r\n      return contributorExpectedTokens;\r\n    } else if (_state == State.DistributingProRata) {\r\n      uint256 tokensRemaining = actualTotalTokens - tokensTransferred;\r\n      uint256 tokens = actualTotalTokens.mul(contributorExpectedTokens) / expectedTotalTokens;\r\n\r\n      // Handle roundoff on last contributor.\r\n      if (tokens < tokensRemaining) {\r\n        return tokens;\r\n      } else {\r\n        return tokensRemaining;\r\n      }\r\n    } else {\r\n      revert();\r\n    }\r\n  }\r\n\r\n  function doDistribution(uint256 contributorIndex, address contributor,\r\n                          uint256 contributorExpectedTokens)\r\n      public {\r\n    require(contributionHashes[contributorIndex] == keccak256(contributor, contributorExpectedTokens));\r\n\r\n    uint256 numTokens = _numTokensForContributor(contributorExpectedTokens, state);\r\n    contributionHashes[contributorIndex] = 0x00000000000000000000000000000000;\r\n    tokensTransferred += numTokens;\r\n    if (tokensTransferred == actualTotalTokens) {\r\n      state = State.Done;\r\n    }\r\n\r\n    require(tokenContract.transfer(contributor, numTokens));\r\n  }\r\n\r\n  function doDistributionRange(uint256 start, address[] contributors,\r\n                               uint256[] contributorExpectedTokens) public {\r\n    require(contributors.length == contributorExpectedTokens.length);\r\n\r\n    uint256 tokensTransferredThisCall = 0;\r\n    uint256 end = start + contributors.length;\r\n    State _state = state;\r\n    for (uint256 i = start; i < end; ++i) {\r\n      address contributor = contributors[i];\r\n      uint256 expectedTokens = contributorExpectedTokens[i];\r\n      require(contributionHashes[i] == keccak256(contributor, expectedTokens));\r\n      contributionHashes[i] = 0x00000000000000000000000000000000;\r\n\r\n      uint256 numTokens = _numTokensForContributor(expectedTokens, _state);\r\n      tokensTransferredThisCall += numTokens;\r\n      require(tokenContract.transfer(contributor, numTokens));\r\n    }\r\n\r\n    tokensTransferred += tokensTransferredThisCall;\r\n    if (tokensTransferred == actualTotalTokens) {\r\n      state = State.Done;\r\n    }\r\n  }\r\n\r\n  function numTokensForContributor(uint256 contributorExpectedTokens)\r\n      public view returns (uint256) {\r\n    return _numTokensForContributor(contributorExpectedTokens, state);\r\n  }\r\n\r\n  function temporaryEscapeHatch(address to, uint256 value, bytes data) public {\r\n    require(msg.sender == admin);\r\n    require(to.call.value(value)(data));\r\n  }\r\n\r\n  function temporaryKill(address to) public {\r\n    require(msg.sender == admin);\r\n    require(tokenContract.balanceOf(this) == 0);\r\n    selfdestruct(to);\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"contributors\",\"type\":\"address[]\"},{\"name\":\"contributorExpectedTokens\",\"type\":\"uint256[]\"}],\"name\":\"doDistributionRange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"contributorExpectedTokens\",\"type\":\"uint256\"}],\"name\":\"numTokensForContributor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"temporaryEscapeHatch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"}],\"name\":\"temporaryKill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contributorIndex\",\"type\":\"uint256\"},{\"name\":\"contributor\",\"type\":\"address\"},{\"name\":\"contributorExpectedTokens\",\"type\":\"uint256\"}],\"name\":\"doDistribution\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"handleTokensReceived\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"},{\"name\":\"_tokenContract\",\"type\":\"address\"},{\"name\":\"_contributionHashes\",\"type\":\"bytes32[]\"},{\"name\":\"_expectedTotalTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"Distribution","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000008ab0a7de69635082663a4450f1247b381dc6030000000000000000000000000558ec3152e2eb2174905cd19aea4e34a23de9ad60000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000d581222e5e0259a20000000000000000000000000000000000000000000000000000000000000001283df079e7acca5514f1a7c39c018084a5fceed7813f7a21418e2f88b8042875","Library":"","SwarmSource":"bzzr://df50b619dba81d72314fd495ad0a55ce3179d0a34c561f0ab2b7098edadb3700"}]}