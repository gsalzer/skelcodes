{"status":"1","message":"OK","result":[{"SourceCode":"/// @title SafeMath\r\n/// @dev Math operations with safety checks that throw on error\r\nlibrary SafeMath {\r\n    /// @dev Multiplies a times b\r\n    function mul(uint256 a, uint256 b) \r\n    internal \r\n    pure\r\n    returns (uint256) \r\n    {\r\n        uint256 c = a * b;\r\n        require(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /// @dev Divides a by b\r\n    function div(uint256 a, uint256 b) \r\n    internal \r\n    pure\r\n    returns (uint256) \r\n    {\r\n        // require(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // require(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /// @dev Subtracts a from b\r\n    function sub(uint256 a, uint256 b) \r\n    internal \r\n    pure\r\n    returns (uint256) \r\n    {\r\n        require(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /// @dev Adds a to b\r\n    function add(uint256 a, uint256 b) \r\n    internal \r\n    pure\r\n    returns (uint256) \r\n    {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\n\r\n/// Implements ERC 20 Token standard: https://github.com/ethereum/EIPs/issues/20\r\n/// @title Abstract token contract - Functions to be implemented by token contracts\r\ncontract Token {\r\n    /*\r\n     * Events\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /*\r\n     * Public functions\r\n     */\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    function balanceOf(address owner) public constant returns (uint256);\r\n    function allowance(address owner, address spender) public constant returns (uint256);\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n/// @title Standard token contract - Standard token interface implementation\r\ncontract StandardToken is Token {\r\n  using SafeMath for uint256;\r\n    /*\r\n     *  Storage\r\n     */\r\n    mapping (address => uint256) public balances;\r\n    mapping (address => mapping (address => uint256)) public allowances;\r\n    uint256 public totalSupply;\r\n\r\n    /*\r\n     *  Public functions\r\n     */\r\n    /// @dev Transfers sender's tokens to a given address. Returns success\r\n    /// @param to Address of token receiver\r\n    /// @param value Number of tokens to transfer\r\n    /// @return Returns success of function call\r\n    function transfer(address to, uint256 value)\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(to != address(0));\r\n        require(value <= balances[msg.sender]);\r\n        balances[msg.sender] = balances[msg.sender].sub(value);\r\n        balances[to] = balances[to].add(value);\r\n        Transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Allows allowances third party to transfer tokens from one address to another. Returns success\r\n    /// @param from Address from where tokens are withdrawn\r\n    /// @param to Address to where tokens are sent\r\n    /// @param value Number of tokens to transfer\r\n    /// @return Returns success of function call\r\n    function transferFrom(address from, address to, uint256 value)\r\n        public\r\n        returns (bool)\r\n    {\r\n        // if (balances[from] < value || allowances[from][msg.sender] < value)\r\n        //     // Balance or allowance too low\r\n        //     revert();\r\n        require(to != address(0));\r\n        require(value <= balances[from]);\r\n        require(value <= allowances[from][msg.sender]);\r\n        balances[to] = balances[to].add(value);\r\n        balances[from] = balances[from].sub(value);\r\n        allowances[from][msg.sender] = allowances[from][msg.sender].sub(value);\r\n        Transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Sets approved amount of tokens for spender. Returns success\r\n    /// @param _spender Address of allowances account\r\n    /// @param value Number of approved tokens\r\n    /// @return Returns success of function call\r\n    function approve(address _spender, uint256 value)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        require((value == 0) || (allowances[msg.sender][_spender] == 0));\r\n        allowances[msg.sender][_spender] = value;\r\n        Approval(msg.sender, _spender, value);\r\n        return true;\r\n    }\r\n\r\n /**\r\n   * approve should be called when allowances[_spender] == 0. To increment\r\n   * allowances value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   */\r\n    function increaseApproval(address _spender, uint _addedValue)\r\n        public\r\n        returns (bool)\r\n    {\r\n        allowances[msg.sender][_spender] = allowances[msg.sender][_spender].add(_addedValue);\r\n        Approval(msg.sender, _spender, allowances[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseApproval(address _spender, uint _subtractedValue)\r\n        public\r\n        returns (bool) \r\n    {\r\n        uint oldValue = allowances[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowances[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowances[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        Approval(msg.sender, _spender, allowances[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Returns number of allowances tokens for given address\r\n    /// @param _owner Address of token owner\r\n    /// @param _spender Address of token spender\r\n    /// @return Returns remaining allowance for spender\r\n    function allowance(address _owner, address _spender)\r\n        public\r\n        constant\r\n        returns (uint256)\r\n    {\r\n        return allowances[_owner][_spender];\r\n    }\r\n\r\n    /// @dev Returns number of tokens owned by given address\r\n    /// @param _owner Address of token owner\r\n    /// @return Returns balance of owner\r\n    function balanceOf(address _owner)\r\n        public\r\n        constant\r\n        returns (uint256)\r\n    {\r\n        return balances[_owner];\r\n    }\r\n}\r\n\r\n\r\ncontract Balehubuck is StandardToken {\r\n    using SafeMath for uint256;\r\n    /*\r\n     *  Constants\r\n     */\r\n    string public constant name = \"balehubuck\";\r\n    string public constant symbol = \"BUX\";\r\n    uint8 public constant decimals = 18;\r\n    uint256 public constant TOTAL_SUPPLY = 1000000000 * 10**18;\r\n    // Presale Allocation = 500 * (5000 + 4500 + 4000 + 3500 + 3250 + 3000)\r\n    // Main Sale Allocation = 75000 * 2500\r\n    // Token Sale Allocation = Presale Allocation + Main Sale Allocation\r\n    uint256 public constant TOKEN_SALE_ALLOCATION = 199125000 * 10**18;\r\n    uint256 public constant WALLET_ALLOCATION = 800875000 * 10**18;\r\n\r\n    function Balehubuck(address wallet)\r\n        public\r\n    {\r\n        totalSupply = TOTAL_SUPPLY;\r\n        balances[msg.sender] = TOKEN_SALE_ALLOCATION;\r\n        balances[wallet] = WALLET_ALLOCATION;\r\n        // Sanity check to make sure total allocations match total supply\r\n        require(TOKEN_SALE_ALLOCATION + WALLET_ALLOCATION == TOTAL_SUPPLY);\r\n    }\r\n}\r\n\r\n\r\ncontract TokenSale {\r\n    using SafeMath for uint256;\r\n    /*\r\n     *  Events\r\n     */\r\n    event PresaleStart(uint256 indexed presaleStartTime);\r\n    event AllocatePresale(address indexed receiver, uint256 tokenQuantity);\r\n    event PresaleEnd(uint256 indexed presaleEndTime);\r\n    event MainSaleStart(uint256 indexed startMainSaleTime);\r\n    event AllocateMainSale(address indexed receiver, uint256 etherAmount);\r\n    event MainSaleEnd(uint256 indexed endMainSaleTime);\r\n    event TradingStart(uint256 indexed startTradingTime);\r\n    event Refund(address indexed receiver, uint256 etherAmount);\r\n\r\n    /*\r\n     *  Constants\r\n     */\r\n    // Presale Allocation = 500 * (5000 + 4500 + 4000 + 3500 + 3250 + 3000) * 10**18\r\n    uint256 public constant PRESALE_TOKEN_ALLOCATION = 11625000 * 10**18;\r\n    uint256 public constant PRESALE_MAX_RAISE = 3000 * 10**18;\r\n\r\n    /*\r\n     *  Storage\r\n     */\r\n    mapping (address => uint256) public presaleAllocations;\r\n    mapping (address => uint256) public mainSaleAllocations;\r\n    address public wallet;\r\n    Balehubuck public token;\r\n    uint256 public presaleEndTime;\r\n    uint256 public mainSaleEndTime;\r\n    uint256 public minTradingStartTime;\r\n    uint256 public maxTradingStartTime;\r\n    uint256 public totalReceived;\r\n    uint256 public minimumMainSaleRaise;\r\n    uint256 public maximumMainSaleRaise;\r\n    uint256 public maximumAllocationPerParticipant;\r\n    uint256 public mainSaleExchangeRate;\r\n    Stages public stage;\r\n\r\n    enum Stages {\r\n        Deployed,\r\n        PresaleStarted,\r\n        PresaleEnded,\r\n        MainSaleStarted,\r\n        MainSaleEnded,\r\n        Refund,\r\n        Trading\r\n    }\r\n\r\n    /*\r\n     *  Modifiers\r\n     */\r\n    modifier onlyWallet() {\r\n        require(wallet == msg.sender);\r\n        _;\r\n    }\r\n\r\n    modifier atStage(Stages _stage) {\r\n        require(stage == _stage);\r\n        _;\r\n    }\r\n\r\n    /*\r\n     *  Fallback function\r\n     */\r\n    function ()\r\n        external\r\n        payable\r\n    {\r\n        buy(msg.sender);\r\n    }\r\n\r\n    /*\r\n     *  Constructor function\r\n     */\r\n    // @dev Constructor function that create the Balehubuck token and sets the initial variables\r\n    // @param _wallet sets the wallet state variable which will be used to start stages throughout the token sale\r\n    function TokenSale(address _wallet)\r\n        public\r\n    {\r\n        require(_wallet != 0x0);\r\n        wallet = _wallet;\r\n        token = new Balehubuck(wallet);\r\n        // Sets the default main sale values\r\n        minimumMainSaleRaise = 23000 * 10**18;\r\n        maximumMainSaleRaise = 78000 * 10**18;\r\n        maximumAllocationPerParticipant = 750 * 10**18;\r\n        mainSaleExchangeRate = 2500;\r\n        stage = Stages.Deployed;\r\n        totalReceived = 0;\r\n    }\r\n\r\n    /*\r\n     *  Public functions\r\n     */\r\n    // @ev Allows buyers to buy tokens, throws if neither the presale or main sale is happening\r\n    // @param _receiver The address the will receive the tokens\r\n    function buy(address _receiver)\r\n        public\r\n        payable\r\n    {\r\n        require(msg.value > 0);\r\n        address receiver = _receiver;\r\n        if (receiver == 0x0)\r\n            receiver = msg.sender;\r\n        if (stage == Stages.PresaleStarted) {\r\n            buyPresale(receiver);\r\n        } else if (stage == Stages.MainSaleStarted) {\r\n            buyMainSale(receiver);\r\n        } else {\r\n            revert();\r\n        }\r\n    }\r\n\r\n    /*\r\n     *  External functions\r\n     */\r\n    // @dev Starts the presale\r\n    function startPresale()\r\n        external\r\n        onlyWallet\r\n        atStage(Stages.Deployed)\r\n    {\r\n        stage = Stages.PresaleStarted;\r\n        presaleEndTime = now + 8 weeks;\r\n        PresaleStart(now);\r\n    }\r\n\r\n    // @dev Sets the maximum and minimum raise amounts prior to the main sale\r\n    // @dev Use this method with extreme caution!\r\n    // @param _minimumMainSaleRaise Sets the minimium main sale raise\r\n    // @param _maximumMainSaleRaise Sets the maximum main sale raise\r\n    // @param _maximumAllocationPerParticipant sets the maximum main sale allocation per participant\r\n    function changeSettings(uint256 _minimumMainSaleRaise,\r\n                            uint256 _maximumMainSaleRaise,\r\n                            uint256 _maximumAllocationPerParticipant,\r\n                            uint256 _mainSaleExchangeRate)\r\n        external\r\n        onlyWallet\r\n        atStage(Stages.PresaleEnded)\r\n    {\r\n        // Checks the inputs for null values\r\n        require(_minimumMainSaleRaise > 0 &&\r\n                _maximumMainSaleRaise > 0 &&\r\n                _maximumAllocationPerParticipant > 0 &&\r\n                _mainSaleExchangeRate > 0);\r\n        // Sanity check that requires the min raise to be less then the max\r\n        require(_minimumMainSaleRaise < _maximumMainSaleRaise);\r\n        // This check verifies that the token_sale contract has enough tokens to match the\r\n        // _maximumMainSaleRaiseAmount * _mainSaleExchangeRate (subtracts presale amounts first)\r\n        require(_maximumMainSaleRaise.sub(PRESALE_MAX_RAISE).mul(_mainSaleExchangeRate) <= token.balanceOf(this).sub(PRESALE_TOKEN_ALLOCATION));\r\n        minimumMainSaleRaise = _minimumMainSaleRaise;\r\n        maximumMainSaleRaise = _maximumMainSaleRaise;\r\n        mainSaleExchangeRate = _mainSaleExchangeRate;\r\n        maximumAllocationPerParticipant = _maximumAllocationPerParticipant;\r\n    }\r\n\r\n    // @dev Starts the main sale\r\n    // @dev Make sure the main sale variables are correct before calling\r\n    function startMainSale()\r\n        external\r\n        onlyWallet\r\n        atStage(Stages.PresaleEnded)\r\n    {\r\n        stage = Stages.MainSaleStarted;\r\n        mainSaleEndTime = now + 8 weeks;\r\n        MainSaleStart(now);\r\n    }\r\n\r\n    // @dev Starts the trading stage, allowing buyer to claim their tokens\r\n    function startTrading()\r\n        external\r\n        atStage(Stages.MainSaleEnded)\r\n    {\r\n        // Trading starts between two weeks (if called by the wallet) and two months (callable by anyone)\r\n        // after the main sale has ended\r\n        require((msg.sender == wallet && now >= minTradingStartTime) || now >= maxTradingStartTime);\r\n        stage = Stages.Trading;\r\n        TradingStart(now);\r\n    }\r\n\r\n    // @dev Allows buyer to be refunded their ETH if the minimum presale raise amount hasn't been met\r\n    function refund() \r\n        external\r\n        atStage(Stages.Refund)\r\n    {\r\n        uint256 amount = mainSaleAllocations[msg.sender];\r\n        mainSaleAllocations[msg.sender] = 0;\r\n        msg.sender.transfer(amount);\r\n        Refund(msg.sender, amount);\r\n    }\r\n\r\n    // @dev Allows buyers to claim the tokens they've purchased\r\n    function claimTokens()\r\n        external\r\n        atStage(Stages.Trading)\r\n    {\r\n        uint256 tokenAllocation = presaleAllocations[msg.sender].add(mainSaleAllocations[msg.sender].mul(mainSaleExchangeRate));\r\n        presaleAllocations[msg.sender] = 0;\r\n        mainSaleAllocations[msg.sender] = 0;\r\n        token.transfer(msg.sender, tokenAllocation);\r\n    }\r\n\r\n    /*\r\n     *  Private functions\r\n     */\r\n    // @dev Allocated tokens to the presale buyer at a rate based on the total received\r\n    // @param receiver The address presale balehubucks will be allocated to\r\n    function buyPresale(address receiver)\r\n        private\r\n    {\r\n        if (now >= presaleEndTime) {\r\n            endPresale();\r\n            return;\r\n        }\r\n        uint256 totalTokenAllocation = 0;\r\n        uint256 oldTotalReceived = totalReceived;\r\n        uint256 tokenAllocation = 0;\r\n        uint256 weiUsing = 0;\r\n        uint256 weiAmount = msg.value;\r\n        uint256 maxWeiForPresaleStage = 0;\r\n        uint256 buyerRefund = 0;\r\n        // Cycles through the presale phases conditional giving a different exchange rate for\r\n        // each phase of the presale until tokens have been allocated for all Ether sent or \r\n        // until the presale cap of 3,000 Ether has been reached\r\n        while (true) {\r\n            // The EVM deals with division by rounding down, causing the below statement to\r\n            // round down to the correct stage\r\n            // stageAmount = totalReceived.add(500 * 10**18).div(500 * 10**18).mul(500 * 10**18);\r\n            // maxWeiForPresaleStage = stageAmount - totalReceived\r\n            maxWeiForPresaleStage = (totalReceived.add(500 * 10**18).div(500 * 10**18).mul(500 * 10**18)).sub(totalReceived);\r\n            if (weiAmount > maxWeiForPresaleStage) {\r\n                weiUsing = maxWeiForPresaleStage;\r\n            } else {\r\n                weiUsing = weiAmount;\r\n            }\r\n            weiAmount = weiAmount.sub(weiUsing);\r\n            if (totalReceived < 500 * 10**18) {\r\n            // Stage 1: up to 500 Ether, exchange rate of 1 ETH for 5000 BUX\r\n                tokenAllocation = calcpresaleAllocations(weiUsing, 5000);\r\n            } else if (totalReceived < 1000 * 10**18) {\r\n            // Stage 2: up to 1000 Ether, exchange rate of 1 ETH for 4500 BUX\r\n                tokenAllocation = calcpresaleAllocations(weiUsing, 4500);\r\n            } else if (totalReceived < 1500 * 10**18) {\r\n            // Stage 3: up to 1500 Ether, exchange rate of 1 ETH for 4000 BUX\r\n                tokenAllocation = calcpresaleAllocations(weiUsing, 4000);\r\n            } else if (totalReceived < 2000 * 10**18) {\r\n            // Stage 4: up to 2000 Ether, exchange rate of 1 ETH for 3500 BUX\r\n                tokenAllocation = calcpresaleAllocations(weiUsing, 3500);\r\n            } else if (totalReceived < 2500 * 10**18) {\r\n            // Stage 5: up to 2500 Ether, exchange rate of 1 ETH for 3250 BUX\r\n                tokenAllocation = calcpresaleAllocations(weiUsing, 3250);\r\n            } else if (totalReceived < 3000 * 10**18) {\r\n            // Stage 6: up to 3000 Ether, exchange rate of 1 ETH for 3000 BUX\r\n                tokenAllocation = calcpresaleAllocations(weiUsing, 3000);\r\n            } \r\n            totalTokenAllocation = totalTokenAllocation.add(tokenAllocation);\r\n            totalReceived = totalReceived.add(weiUsing);\r\n            if (totalReceived >= PRESALE_MAX_RAISE) {\r\n                    buyerRefund = weiAmount;\r\n                    endPresale();\r\n            }\r\n            // Exits the for loops if the presale cap has been reached (changing the stage)\r\n            // or all of the wei send to the presale has been allocated\r\n            if (weiAmount == 0 || stage != Stages.PresaleStarted)\r\n                break;\r\n        }\r\n        presaleAllocations[receiver] = presaleAllocations[receiver].add(totalTokenAllocation);\r\n        wallet.transfer(totalReceived.sub(oldTotalReceived));\r\n        msg.sender.transfer(buyerRefund);\r\n        AllocatePresale(receiver, totalTokenAllocation);\r\n    }\r\n\r\n    // @dev Allocated tokens to the presale buyer at a rate based on the total received\r\n    // @param receiver The address main sale balehubucks will be allocated to\r\n    function buyMainSale(address receiver)\r\n        private\r\n    {\r\n        if (now >= mainSaleEndTime) {\r\n            endMainSale(msg.value);\r\n            msg.sender.transfer(msg.value);\r\n            return;\r\n        }\r\n        uint256 buyerRefund = 0;\r\n        uint256 weiAllocation = mainSaleAllocations[receiver].add(msg.value);\r\n        if (weiAllocation >= maximumAllocationPerParticipant) {\r\n            weiAllocation = maximumAllocationPerParticipant.sub(mainSaleAllocations[receiver]);\r\n            buyerRefund = msg.value.sub(weiAllocation);\r\n        }\r\n        uint256 potentialReceived = totalReceived.add(weiAllocation);\r\n        if (potentialReceived > maximumMainSaleRaise) {\r\n            weiAllocation = maximumMainSaleRaise.sub(totalReceived);\r\n            buyerRefund = buyerRefund.add(potentialReceived.sub(maximumMainSaleRaise));\r\n            endMainSale(buyerRefund);\r\n        }\r\n        totalReceived = totalReceived.add(weiAllocation);\r\n        mainSaleAllocations[receiver] = mainSaleAllocations[receiver].add(weiAllocation);\r\n        msg.sender.transfer(buyerRefund);\r\n        AllocateMainSale(receiver, weiAllocation);\r\n    }\r\n\r\n    // @dev Calculates the amount of presale tokens to allocate\r\n    // @param weiUsing The amount of wei being used to for the given token allocation\r\n    // @param rate The eth/token exchange rate, this changes based on how much the presale has received so far\r\n    function calcpresaleAllocations(uint256 weiUsing, uint256 rate)\r\n        private\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return weiUsing.mul(rate);\r\n    }\r\n\r\n    // @dev Ends the presale\r\n    function endPresale()\r\n        private\r\n    {\r\n        stage = Stages.PresaleEnded;\r\n        PresaleEnd(now);\r\n    }\r\n\r\n    // @dev Ends the main sale triggering a refund if the minimum sale raise has no been met \r\n    // @dev or passes funds raised to the wallet and starts the trading count down\r\n    function endMainSale(uint256 buyerRefund)\r\n        private\r\n    {\r\n        if (totalReceived < minimumMainSaleRaise) {\r\n            stage = Stages.Refund;\r\n        } else {\r\n            minTradingStartTime = now + 2 weeks;\r\n            maxTradingStartTime = now + 8 weeks;\r\n            stage = Stages.MainSaleEnded;\r\n            // Transfers all funds raised to the Balehu wallet minus the funds that need to be refunded\r\n            wallet.transfer(this.balance.sub(buyerRefund));\r\n            // All unsold tokens will remain within the token_sale contract\r\n            // and will be treated as burned\r\n        }\r\n        MainSaleEnd(now);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WALLET_ALLOCATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOTAL_SUPPLY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_SALE_ALLOCATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"Balehubuck","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000067ea4cacdb7eb10ef441ad5a76327f15b49c3af7","Library":"","SwarmSource":"bzzr://0692760ec1db61591d22a91dffec166a0b6a1575b73970edbeb3a305571151bf"}]}