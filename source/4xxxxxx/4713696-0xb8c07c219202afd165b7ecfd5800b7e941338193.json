{"status":"1","message":"OK","result":[{"SourceCode":"//Copyright Global Invest Place Ltd.\r\npragma solidity ^0.4.13;\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\ninterface GlobalToken {\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract Owned {\r\n    address public owner;\r\n    \r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    function Owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner) ;\r\n        _;\r\n    }\r\n\t\r\n\tmodifier onlyPayloadSize(uint numwords) {\r\n        assert(msg.data.length == numwords * 32 + 4);\r\n\t\t_;\r\n\t}\r\n\r\n    function transferOwnership(address newOwner) onlyOwner {\r\n        owner = newOwner;\r\n        OwnershipTransferred(owner, newOwner);\r\n    }\r\n  \r\n  function contractVersion() constant returns(uint256) {\r\n        /*  contractVersion identifies as 100YYYYMMDDHHMM */\r\n        return 100201712010000;\r\n    }\r\n}\r\n\r\n// GlobalToken Interface\r\ncontract GlobalCryptoFund is Owned, GlobalToken {\r\n    \r\n    using SafeMath for uint256;\r\n    \r\n    /* Public variables of the token */\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    uint256 public totalSupply;\r\n\t\r\n\taddress public minter;\r\n    \r\n    /* This creates an array with all balances */\r\n    mapping (address => uint256) public balanceOf;\r\n    \r\n\tmodifier onlyMinter {\r\n\t\trequire(msg.sender == minter);\r\n\t\t_;\r\n\t}\r\n\t\r\n\tfunction setMinter(address _addressMinter) onlyOwner {\r\n\t\tminter = _addressMinter;\r\n\t}\r\n    \r\n    /* Initializes contract with initial supply tokens to the creator of the contract */\r\n    function GlobalCryptoFund() {\r\n\t\tname = \"GlobalCryptoFund\";                    \t\t\t\t\t\t\t\t// Set the name for display purposes\r\n        symbol = \"GCF\";                \t\t\t\t\t\t\t\t\t\t\t\t// Set the symbol for display purposes\r\n        decimals = 18;                          \t\t\t\t\t\t\t\t\t// Amount of decimals for display purposes\r\n        totalSupply = 0;                \t\t\t\t\t\t\t\t\t// Update total supply\r\n        balanceOf[msg.sender] = totalSupply;       \t\t\t\t\t\t\t\t\t// Give the creator all initial tokens\r\n    }\r\n    \r\n    function balanceOf(address _owner) constant returns (uint256 balance){\r\n        return balanceOf[_owner];\r\n    }\r\n    \r\n    /* Internal transfer, only can be called by this contract */\r\n    function _transfer(address _from, address _to, uint256 _value) internal {\r\n        require (_to != 0x0);                               \t\t\t\t\t\t// Prevent transfer to 0x0 address. Use burn() instead\r\n        require (balanceOf[_from] >= _value);                \t\t\t\t\t\t// Check if the sender has enough\r\n        require (balanceOf[_to].add(_value) >= balanceOf[_to]); \t\t\t\t\t\t// Check for overflows\r\n        require(_to != address(this));\r\n        balanceOf[_from] = balanceOf[_from].sub(_value);                         \t// Subtract from the sender\r\n        balanceOf[_to] = balanceOf[_to].add(_value);                           \t\t// Add the same to the recipient\r\n        Transfer(_from, _to, _value);\r\n    }\r\n    \r\n    function transfer(address _to, uint256 _value) onlyPayloadSize(2) returns (bool) {\r\n        _transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n    \r\n\tevent Mint(address indexed from, uint256 value);\r\n    function mintToken(address target, uint256 mintedAmount) onlyMinter {\r\n        balanceOf[target] = balanceOf[target].add(mintedAmount);\r\n        totalSupply = totalSupply.add(mintedAmount);\r\n        Transfer(0, this, mintedAmount);\r\n        Transfer(this, target, mintedAmount);\r\n        Mint(target, mintedAmount);\r\n    }\r\n    \r\n\tevent Burn(address indexed from, uint256 value);\r\n    function burn(uint256 _value) onlyMinter returns (bool success) {\r\n        require (balanceOf[msg.sender] >= _value);            \t\t\t\t\t// Check if the sender has enough\r\n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);              // Subtract from the sender\r\n        totalSupply = totalSupply.sub(_value);                                \t// Updates totalSupply\r\n        Burn(msg.sender, _value);\r\n        return true;\r\n    }  \r\n\t\r\n\tfunction kill() onlyOwner {\r\n        selfdestruct(owner);\r\n    }\r\n    \r\n    function contractVersion() constant returns(uint256) {\r\n        /*  contractVersion identifies as 200YYYYMMDDHHMM */\r\n        return 200201712010000;\r\n    }\r\n}\r\n\r\ncontract ExchangeManager is Owned {\r\n\t\r\n\tusing SafeMath for uint256;\r\n\t \r\n    GlobalCryptoFund public gcf;\r\n    ActualInfo[] public periods;\r\n\taddress[] public accounts;\r\n    \r\n    struct ActualInfo {\r\n        uint256 ethAtThePeriod;\r\n        uint256 tokensAtThePeriod;\r\n        \r\n        uint256 price;\r\n        \r\n        uint256 ethForReederem;\r\n    }\r\n    \r\n    uint256 ethTax;\r\n    uint256 tokenTax;\r\n\tuint256 public currentPeriodPrice;\r\n\tuint256 public marketCap;\r\n\t\r\n    modifier onlyReg {\r\n        require(isReg[msg.sender]);\r\n        _;\r\n    }\r\n  \r\n    mapping (address => mapping (uint256 => uint256)) public buyTokens;\r\n    mapping (address => mapping (uint256 => uint256)) public sellTokens;\r\n\tmapping (address => address) public myUserWallet;\r\n    mapping (address => bool) public isReg;\r\n\t\r\n\r\n    function ExchangeManager() {\r\n        gcf = GlobalCryptoFund(0x26F45379d3f581e09719f1dC79c184302572AF00);\r\n        require(gcf.contractVersion() == 200201712010000);\r\n\t\t\r\n\t\tuint256 newPeriod = periods.length++;\r\n\t\tActualInfo storage info = periods[newPeriod];\r\n\t\tinfo.ethAtThePeriod = 0;\r\n\t\tinfo.tokensAtThePeriod = 0;\r\n\t\tinfo.price = 10000000000000000;\r\n\t\tinfo.ethForReederem = 0;\r\n    }\r\n\t\r\n\tevent TaxTillNow(uint256 _ethTx, uint256 _tokenTx);\r\n\tfunction taxTillNow() onlyOwner returns (uint256 _ethTax, uint256 _tokenTax) {\r\n\t\tTaxTillNow(ethTax, tokenTax);\r\n\t\treturn (ethTax, tokenTax);\r\n\t}\r\n\t\r\n\tevent RegisterEvent(address indexed _person, address indexed _userWallet);\r\n    function Register() returns (address _userWallet) {\r\n        _userWallet = address(new UserWallet(this, gcf));\r\n        accounts.push(_userWallet);\r\n        UserWallet(_userWallet).transferOwnership(msg.sender);\r\n       \r\n        isReg[_userWallet] = true;\r\n        myUserWallet[msg.sender] = _userWallet;\r\n        \r\n\t\tRegisterEvent(msg.sender, _userWallet);\r\n        return _userWallet;\r\n    }\r\n\t\r\n    function getActualPeriod() returns (uint256) {\r\n        return periods.length;\r\n    }\r\n\t\r\n\tevent ClosePeriodEvent(uint256 period, uint256 price, uint256 _marketCap, uint256 _ethForReederem);\r\n    function closePeriod(uint256 _price, uint256 _marketCap, uint256 _ethForReederem) onlyOwner {\r\n\t\tuint256 period = getActualPeriod();\r\n\t\tActualInfo storage info = periods[period.sub(1)];\r\n\t\tuint256 tokensAtThisPeriod = info.tokensAtThePeriod;\r\n        //set Prices at this period\r\n        info.price = _price;\r\n\t\t//calculate how much eth must have at the contract for reederem\r\n\t\tif(_ethForReederem != 0) {\r\n\t\t\tinfo.ethForReederem = _ethForReederem;\r\n\t\t} else {\r\n\t\t\tinfo.ethForReederem = ((info.tokensAtThePeriod).mul(_price)).div(1 ether);\r\n\t\t}\r\n\t\tcurrentPeriodPrice = _price;\r\n\t\t\r\n\t\tmarketCap = _marketCap;\r\n\t\t\r\n\t\tClosePeriodEvent(period, info.price, marketCap, info.ethForReederem);\r\n\t\t\r\n\t\tend();\r\n    }\r\n\r\n\tfunction end() internal {\r\n\t\tuint256 period = periods.length ++;\r\n\t\tActualInfo storage info = periods[period];\r\n\t\tinfo.ethAtThePeriod = 0;\r\n\t\tinfo.tokensAtThePeriod = 0;\r\n\t\tinfo.price = 0;\r\n\t\tinfo. ethForReederem = 0;\r\n\t}\r\n\t\r\n    function getPrices() public returns (uint256 _Price) {\r\n        return currentPeriodPrice;\r\n    }\r\n\t\r\n\tevent DepositEvent(address indexed _from, uint256 _amount);\r\n    function() payable {\r\n        DepositEvent(msg.sender, msg.value);\r\n    }\r\n\r\n\tevent BuyEvent(address indexed _from, uint256 period, uint256 _amountEthers, uint256 _ethAtThePeriod);\r\n    function buy(uint256 _amount) onlyReg returns (bool) {\r\n        require(_amount > 0.01 ether);\r\n\t\t\r\n        uint256 thisPeriod = getActualPeriod();\r\n        thisPeriod = thisPeriod.sub(1);\r\n\t\t\r\n\t\tuint256 tax = calculateTax(_amount);\r\n\t\tethTax = ethTax.add(tax);\r\n\t\tuint256 _ethValue = _amount.sub(tax);\r\n\t\t\r\n        buyTokens[msg.sender][thisPeriod] = buyTokens[msg.sender][thisPeriod].add(_ethValue);\r\n\t\t\r\n\t\tActualInfo storage info = periods[thisPeriod];\r\n\t\tinfo.ethAtThePeriod = info.ethAtThePeriod.add(_ethValue);\r\n\t\t\r\n\t\tBuyEvent(msg.sender, thisPeriod, _amount, info.ethAtThePeriod);\r\n\t\t\r\n\t\treturn true;\r\n    }\r\n\t\r\n\tevent ReederemEvent(address indexed _from, uint256 period, uint256 _amountTokens, uint256 _tokensAtThePeriod);\r\n    function Reederem(uint256 _amount) onlyReg returns (bool) {\r\n\t\trequire(_amount > 0);\r\n\t\t\r\n        uint256 thisPeriod = getActualPeriod();\r\n\t\tthisPeriod = thisPeriod.sub(1);\r\n\t\t\r\n\t\tuint256 tax = calculateTax(_amount);\r\n\t\ttokenTax = tokenTax.add(tax);\r\n\t\tuint256 _tokensValue = _amount.sub(tax);\r\n\t\t\r\n        sellTokens[msg.sender][thisPeriod] = sellTokens[msg.sender][thisPeriod].add(_tokensValue);\r\n\t\t\r\n\t\tActualInfo storage info = periods[thisPeriod];\r\n        info.tokensAtThePeriod = info.tokensAtThePeriod.add(_tokensValue);\r\n\t\t\r\n        ReederemEvent(msg.sender, thisPeriod, _amount, info.tokensAtThePeriod);\r\n\t\t\r\n        return true;\r\n    }\r\n\t\r\n\tevent Tax(uint256 _taxPayment);\r\n\tfunction calculateTax(uint256 _amount) internal returns (uint256 _tax) {\r\n\t\t_tax = (_amount.mul(5)).div(100);\r\n\t\tTax(_tax);\r\n\t\treturn _tax;\r\n\t}\r\n\t\r\n\tevent ClaimTokensEvent(address indexed _from, uint256 period, uint256 _tokensValue, uint256 _tokensPrice, uint256 _ethersAmount);\r\n    function claimTokens(uint256 _period) onlyReg returns (bool) {\r\n        require(periods.length > _period);\r\n\t\t\r\n        uint256 _ethValue = buyTokens[msg.sender][_period];\r\n\t\t\r\n\t\tActualInfo storage info = periods[_period];\r\n        uint256 tokenPrice = info.price;\r\n        uint256 amount = (_ethValue.mul(1 ether)).div(tokenPrice);\r\n        gcf.mintToken(this, amount);\r\n\t\t\r\n\t\tbuyTokens[msg.sender][_period] = 0;\r\n\t\t\t\t\r\n        ClaimTokensEvent(msg.sender, _period, _ethValue, tokenPrice, amount);\r\n\t\t\r\n\t\treturn GlobalToken(gcf).transfer(msg.sender, amount);\r\n    }\r\n\t\r\n\tevent ClaimEthersEvent(address indexed _from, uint256 period, uint256 _ethValue, uint256 _tokensPrice, uint256 _tokensAmount);\r\n    function claimEthers(uint256 _period) onlyReg returns (bool) {\r\n        require(periods.length > _period);\r\n\t\t\r\n        uint256 _tokensValue = sellTokens[msg.sender][_period];\r\n\t\t\r\n\t\tActualInfo storage info = periods[_period];\r\n        uint256 tokenPrice = info.price;\r\n        uint256 amount = (_tokensValue.mul(tokenPrice)).div(1 ether);\r\n        gcf.burn(_tokensValue);\r\n        msg.sender.transfer(amount);\r\n\t\t\t\t\r\n        sellTokens[msg.sender][_period] = 0;\r\n\t\t\r\n\t\tClaimEthersEvent(msg.sender, _period, _tokensValue, tokenPrice, amount);\r\n        \r\n        return true;\r\n    }\r\n\t\r\n\tevent claimTaxex (uint256 _eth, uint256 _tokens);\r\n    function claimTax() onlyOwner {\r\n\t\tif(ethTax != 0) {\r\n\t\t\ttransferEther(owner, ethTax);\r\n\t\t\tclaimTaxex(ethTax, 0);\r\n\t\t\tethTax = 0;\r\n\t\t}\r\n\t\t\r\n\t\tif(tokenTax != 0) {\r\n\t\t\ttransferTokens(owner, tokenTax);\r\n\t\t\tclaimTaxex(0, tokenTax);\r\n\t\t\ttokenTax = 0;\r\n\t\t}\r\n    }\r\n\t\r\n    function transferTokens(address _to, uint256 _amount) onlyOwner returns (bool) {\r\n        return GlobalToken(gcf).transfer(_to, _amount);\r\n    }\r\n\t\r\n    function transferEther(address _to, uint256 _amount) onlyOwner returns (bool) {\r\n\t\trequire(_amount <= (this.balance).sub(ethTax));\r\n        _to.transfer(_amount);\r\n        return true;\r\n    }\r\n    \r\n    function contractVersion() constant returns(uint256) {\r\n        /*  contractVersion identifies as 300YYYYMMDDHHMM */\r\n        return 300201712010000;\r\n    }\r\n    \r\n    function numAccounts() returns (uint256 _numAccounts) {\r\n        return accounts.length;\r\n    }\r\n\t\r\n    function kill() onlyOwner {\r\n        uint256 amount = GlobalToken(gcf).balanceOf(this);\r\n        transferTokens(owner, amount);\r\n        selfdestruct(owner);\r\n    }\r\n}\r\n\r\nlibrary ConvertStringToUint {\r\n\t\r\n\tfunction stringToUint(string _amount) internal constant returns (uint result) {\r\n        bytes memory b = bytes(_amount);\r\n        uint i;\r\n        uint counterBeforeDot;\r\n        uint counterAfterDot;\r\n        result = 0;\r\n        uint totNum = b.length;\r\n        totNum--;\r\n        bool hasDot = false;\r\n        \r\n        for (i = 0; i < b.length; i++) {\r\n            uint c = uint(b[i]);\r\n            \r\n            if (c >= 48 && c <= 57) {\r\n                result = result * 10 + (c - 48);\r\n                counterBeforeDot ++;\r\n                totNum--;\r\n            }\r\n            \r\n\t\t\tif(c == 46){\r\n\t\t\t    hasDot = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n        }\r\n        \r\n        if(hasDot) {\r\n            for (uint j = counterBeforeDot + 1; j < 18; j++) {\r\n                uint m = uint(b[j]);\r\n                \r\n                if (m >= 48 && m <= 57) {\r\n                    result = result * 10 + (m - 48);\r\n                    counterAfterDot ++;\r\n                    totNum--;\r\n                }\r\n                \r\n                if(totNum == 0){\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n         if(counterAfterDot < 18){\r\n             uint addNum = 18 - counterAfterDot;\r\n             uint multuply = 10 ** addNum;\r\n             return result = result * multuply;\r\n         }\r\n         \r\n         return result;\r\n\t}\r\n}\r\n\r\ncontract UserWallet is Owned {\r\n\tusing ConvertStringToUint for string;\r\n\tusing SafeMath for uint256;\r\n\t\r\n    ExchangeManager fund;\r\n    GlobalCryptoFund public gcf;\r\n    \r\n    uint256[] public investedPeriods;\r\n    uint256[] public reederemPeriods;\r\n    \r\n\tmapping (uint256 => bool) isInvested;\r\n\tmapping (uint256 => bool) isReederem;\r\n\t\r\n    function UserWallet(address _fund, address _token) {\r\n        fund = ExchangeManager(_fund);\r\n\t\trequire(fund.contractVersion() == 300201712010000);\r\n\t\t\r\n        gcf = GlobalCryptoFund(_token);\r\n        require(gcf.contractVersion() == 200201712010000);\r\n    }\r\n\t\r\n    function getPrices() onlyOwner returns (uint256 _Price) {\r\n\t\treturn fund.getPrices();\r\n\t}\r\n\t\r\n\tfunction getActualPeriod() onlyOwner returns (uint256) {\r\n\t\tuint256 period = fund.getActualPeriod();\r\n\t\treturn period.sub(1);\r\n\t}\r\n\t\r\n\tevent TokensSold(uint256 recivedEthers);\r\n    function() payable {\r\n        if(msg.sender == address(fund)) {\r\n            TokensSold(msg.value);\r\n        } else {\r\n            deposit(msg.value);\r\n        }\r\n    }\r\n\t\r\n    function deposit(uint256 _WeiAmount) payable returns (bool) {\r\n        fund.transfer(_WeiAmount);\r\n        fund.buy(_WeiAmount);\r\n\t\tuint256 period = fund.getActualPeriod();\r\n\t\tbool _isInvested = isInvest(period);\r\n\t\tif(!_isInvested) {\r\n\t\t\tinvestedPeriods.push(period.sub(1));\r\n\t\t\tisInvested[period] = true;\r\n\t\t}\r\n        return true;\r\n    }\r\n    \r\n    function Reederem(string _amount) onlyOwner returns (bool) {\r\n\t\tuint256 amount = _amount.stringToUint();\r\n        gcf.transfer(fund, amount);\r\n        uint256 period = fund.getActualPeriod();\r\n\t\tbool _isReederemed = isReederemed(period);\r\n\t\tif(!_isReederemed) {\r\n\t\t\treederemPeriods.push(period.sub(1));\r\n\t\t\tisReederem[period] = true;\r\n\t\t}\r\n        return fund.Reederem(amount);\r\n    }\r\n    \r\n    function transferTokens() onlyOwner returns (bool) {\r\n\t\tuint256 amount = GlobalToken(gcf).balanceOf(this);\r\n        return GlobalToken(gcf).transfer(owner, amount);\r\n    }\r\n    \r\n    event userWalletTransferEther(address indexed _from, address indexed _to, uint256 _ethersValue);\r\n    function transferEther() onlyOwner returns (bool) {\r\n\t\tuint256 amount = this.balance;\r\n        owner.transfer(amount);\r\n        userWalletTransferEther(this,owner,amount);\r\n        return true;\r\n    }\r\n    \r\n    function claimTokens() onlyOwner {\r\n        uint256 period;\r\n        for(uint256 i = 0; i < investedPeriods.length; i++) {\r\n            period = investedPeriods[i];\r\n            fund.claimTokens(period);\r\n        }\r\n        investedPeriods.length = 0;\r\n    }\r\n\r\n    function claimEthers() onlyOwner {\r\n        uint256 period;\r\n        for(uint256 i = 0; i < reederemPeriods.length; i++) {\r\n            period = reederemPeriods[i];\r\n            fund.claimEthers(period);\r\n        }\r\n        reederemPeriods.length = 0;\r\n    }\r\n  \r\n    function contractVersion() constant returns(uint256) {\r\n        /*  contractVersion identifies as 400YYYYMMDDHHMM */\r\n        return 400201712010000;\r\n    }\r\n    \r\n    function kill() onlyOwner {\r\n\t\ttransferTokens();\r\n\t\ttransferEther();\r\n        selfdestruct(owner);\r\n    }\r\n\t\r\n\tfunction isInvest(uint256 _per) internal returns (bool) {\r\n\t\treturn isInvested[_per];\r\n\t}\r\n\t\r\n\tfunction isReederemed(uint256 _per) internal returns (bool) {\r\n\t\treturn isReederem[_per];\r\n\t}\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferEther\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"buyTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"Register\",\"outputs\":[{\"name\":\"_userWallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_period\",\"type\":\"uint256\"}],\"name\":\"claimEthers\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"marketCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isReg\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"myUserWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimTax\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Reederem\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_period\",\"type\":\"uint256\"}],\"name\":\"claimTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"taxTillNow\",\"outputs\":[{\"name\":\"_ethTax\",\"type\":\"uint256\"},{\"name\":\"_tokenTax\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_marketCap\",\"type\":\"uint256\"},{\"name\":\"_ethForReederem\",\"type\":\"uint256\"}],\"name\":\"closePeriod\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gcf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"numAccounts\",\"outputs\":[{\"name\":\"_numAccounts\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractVersion\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getActualPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getPrices\",\"outputs\":[{\"name\":\"_Price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sellTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"periods\",\"outputs\":[{\"name\":\"ethAtThePeriod\",\"type\":\"uint256\"},{\"name\":\"tokensAtThePeriod\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"ethForReederem\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentPeriodPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"accounts\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_ethTx\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_tokenTx\",\"type\":\"uint256\"}],\"name\":\"TaxTillNow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_person\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_userWallet\",\"type\":\"address\"}],\"name\":\"RegisterEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"period\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_marketCap\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_ethForReederem\",\"type\":\"uint256\"}],\"name\":\"ClosePeriodEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"DepositEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"period\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_amountEthers\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_ethAtThePeriod\",\"type\":\"uint256\"}],\"name\":\"BuyEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"period\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_amountTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_tokensAtThePeriod\",\"type\":\"uint256\"}],\"name\":\"ReederemEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_taxPayment\",\"type\":\"uint256\"}],\"name\":\"Tax\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"period\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_tokensValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_tokensPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_ethersAmount\",\"type\":\"uint256\"}],\"name\":\"ClaimTokensEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"period\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_ethValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_tokensPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_tokensAmount\",\"type\":\"uint256\"}],\"name\":\"ClaimEthersEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_eth\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"claimTaxex\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"ExchangeManager","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://2f05ffb0ab821676021f8468716e08103b00902a17287efa380b8998d0d0ddd2"}]}