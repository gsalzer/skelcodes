{"status":"1","message":"OK","result":[{"SourceCode":"//A BurnableOpenPayment is instantiated with a specified payer and a commitThreshold.\r\n//The recipient is not set when the contract is instantiated.\r\n\r\n//The constructor is payable, so the contract can be instantiated with initial funds.\r\n//Only the payer can fund the Payment after instantiation.\r\n\r\n//All behavior of the contract is directed by the payer, but\r\n//the payer can never directly recover the payment unless he becomes the recipient.\r\n\r\n//Anyone can become the recipient by contributing the commitThreshold.\r\n//The recipient cannot change once it's been set.\r\n\r\n//The payer can at any time choose to burn or release to the recipient any amount of funds.\r\n\r\npragma solidity ^0.4.10;\r\n\r\ncontract BurnableOpenPayment {\r\n    //BOP will start with a payer but no recipient (recipient==0x0)\r\n    address public payer;\r\n    address public recipient;\r\n    address constant burnAddress = 0x0;\r\n    \r\n    //Note that these will track, but not influence the BOP logic.\r\n    uint public amountDeposited;\r\n    uint public amountBurned;\r\n    uint public amountReleased;\r\n    \r\n    //payerString and recipientString enable rudimentary communication/publishing.\r\n    //Although the two parties might quickly move to another medium with better privacy or convenience,\r\n    //beginning with this is nice because it's already trustless/transparent/signed/pseudonymous/etc.\r\n    string public payerString;\r\n    string public recipientString;\r\n    \r\n    //Amount of ether a prospective recipient must pay to become (permanently) the recipient. See commit().\r\n    uint public commitThreshold;\r\n    \r\n    //What if the payer falls off the face of the planet?\r\n    //A BOP is instantiated with a chosen defaultAction, and this cannot be changed.\r\n    enum DefaultAction {None, Release, Burn}\r\n    DefaultAction public defaultAction;\r\n    \r\n    //if defaultAction != None, how long should we wait before giving up?\r\n    //Set in constructor:\r\n    uint public defaultTimeoutLength;\r\n    \r\n    //Calculated from defaultTimeoutLength on a successful recipient commit(),\r\n    //as well as whenever the payer (or possibly the recipient) calls delayDefaultAction()\r\n    uint public defaultTriggerTime;\r\n    \r\n    //Most action happens in the Committed state.\r\n    enum State {Open, Committed, Expended}\r\n    State public state;\r\n    //Note that a BOP cannot go from Committed back to Open, but it can go from Expended back to Committed\r\n    //(this would retain the committed recipient). Search for Expended and Unexpended events to see how this works.\r\n    \r\n    modifier inState(State s) { if (s != state) throw; _; }\r\n    modifier onlyPayer() { if (msg.sender != payer) throw; _; }\r\n    modifier onlyRecipient() { if (msg.sender != recipient) throw; _; }\r\n    modifier onlyPayerOrRecipient() { if ((msg.sender != payer) && (msg.sender != recipient)) throw; _; }\r\n    \r\n    event FundsAdded(uint amount);//The payer has added funds to the BOP.\r\n    event PayerStringUpdated(string newPayerString);\r\n    event RecipientStringUpdated(string newRecipientString);\r\n    event FundsRecovered();\r\n    event Committed(address recipient);\r\n    event FundsBurned(uint amount);\r\n    event FundsReleased(uint amount);\r\n    event Expended();\r\n    event Unexpended();\r\n    event DefaultActionDelayed();\r\n    event DefaultActionCalled();\r\n    \r\n    function BurnableOpenPayment(address _payer, uint _commitThreshold, DefaultAction _defaultAction, uint _defaultTimeoutLength, string _payerString)\r\n    public\r\n    payable {\r\n        if (msg.value > 0) {\r\n            FundsAdded(msg.value);\r\n            amountDeposited += msg.value;\r\n        }\r\n            \r\n        state = State.Open;\r\n        payer = _payer;\r\n        \r\n        commitThreshold = _commitThreshold;\r\n        \r\n        defaultAction = _defaultAction;\r\n        if (defaultAction != DefaultAction.None) \r\n            defaultTimeoutLength = _defaultTimeoutLength;\r\n        \r\n        payerString = _payerString;\r\n    }\r\n    \r\n    function getFullState()\r\n    public\r\n    constant\r\n    returns (State, string, address, string, uint, uint, uint, uint) {\r\n        return (state, payerString, recipient, recipientString, amountDeposited, amountBurned, amountReleased, defaultTriggerTime);\r\n    }\r\n    \r\n    function addFunds()\r\n    public\r\n    onlyPayer()\r\n    payable {\r\n        if (msg.value == 0) throw;\r\n        \r\n        FundsAdded(msg.value);\r\n        amountDeposited += msg.value;\r\n        if (state == State.Expended) {\r\n            state = State.Committed;\r\n            Unexpended();\r\n        }\r\n    }\r\n    \r\n    function recoverFunds()\r\n    public\r\n    onlyPayer()\r\n    inState(State.Open)\r\n    {\r\n        FundsRecovered();\r\n        selfdestruct(payer);\r\n    }\r\n    \r\n    function commit()\r\n    public\r\n    inState(State.Open)\r\n    payable\r\n    {\r\n        if (msg.value < commitThreshold) throw;\r\n        \r\n        if (msg.value > 0) {\r\n            FundsAdded(msg.value);\r\n            amountDeposited += msg.value;\r\n        }\r\n        \r\n        recipient = msg.sender;\r\n        state = State.Committed;\r\n        Committed(recipient);\r\n        \r\n        if (defaultAction != DefaultAction.None) {\r\n            defaultTriggerTime = now + defaultTimeoutLength;\r\n        }\r\n    }\r\n    \r\n    function internalBurn(uint amount)\r\n    private\r\n    inState(State.Committed)\r\n    returns (bool)\r\n    {\r\n        bool success = burnAddress.send(amount);\r\n        if (success) {\r\n            FundsBurned(amount);\r\n            amountBurned += amount;\r\n        }\r\n        \r\n        if (this.balance == 0) {\r\n            state = State.Expended;\r\n            Expended();\r\n        }\r\n        \r\n        return success;\r\n    }\r\n    \r\n    function burn(uint amount)\r\n    public\r\n    inState(State.Committed)\r\n    onlyPayer()\r\n    returns (bool)\r\n    {\r\n        return internalBurn(amount);\r\n    }\r\n    \r\n    function internalRelease(uint amount)\r\n    private\r\n    inState(State.Committed)\r\n    returns (bool)\r\n    {\r\n        bool success = recipient.send(amount);\r\n        if (success) {\r\n            FundsReleased(amount);\r\n            amountReleased += amount;\r\n        }\r\n        \r\n        if (this.balance == 0) {\r\n            state = State.Expended;\r\n            Expended();\r\n        }\r\n        return success;\r\n    }\r\n    \r\n    function release(uint amount)\r\n    public\r\n    inState(State.Committed)\r\n    onlyPayer()\r\n    returns (bool)\r\n    {\r\n        return internalRelease(amount);\r\n    }\r\n    \r\n    function setPayerString(string _string)\r\n    public\r\n    onlyPayer()\r\n    {\r\n        payerString = _string;\r\n        PayerStringUpdated(payerString);\r\n    }\r\n    \r\n    function setRecipientString(string _string)\r\n    public\r\n    onlyRecipient()\r\n    {\r\n        recipientString = _string;\r\n        RecipientStringUpdated(recipientString);\r\n    }\r\n    \r\n    function delayDefaultAction()\r\n    public\r\n    onlyPayerOrRecipient()\r\n    inState(State.Committed)\r\n    {\r\n        if (defaultAction == DefaultAction.None) throw;\r\n        \r\n        DefaultActionDelayed();\r\n        defaultTriggerTime = now + defaultTimeoutLength;\r\n    }\r\n    \r\n    function callDefaultAction()\r\n    public\r\n    onlyPayerOrRecipient()\r\n    inState(State.Committed)\r\n    {\r\n        if (defaultAction == DefaultAction.None) throw;\r\n        if (now < defaultTriggerTime) throw;\r\n        \r\n        DefaultActionCalled();\r\n        if (defaultAction == DefaultAction.Burn) {\r\n            internalBurn(this.balance);\r\n        }\r\n        else if (defaultAction == DefaultAction.Release) {\r\n            internalRelease(this.balance);\r\n        }\r\n    }\r\n}\r\n\r\ncontract BurnableOpenPaymentFactory {\r\n    event NewBOP(address newBOPAddress, address payer, uint commitThreshold, BurnableOpenPayment.DefaultAction defaultAction, uint defaultTimeoutLength, string initialPayerString);\r\n    \r\n    function newBurnableOpenPayment(address payer, uint commitThreshold, BurnableOpenPayment.DefaultAction defaultAction, uint defaultTimeoutLength, string initialPayerString)\r\n    public\r\n    payable\r\n    returns (address) {\r\n        //pass along any ether to the constructor\r\n        address newBOPAddr = (new BurnableOpenPayment).value(msg.value)(payer, commitThreshold, defaultAction, defaultTimeoutLength, initialPayerString);\r\n        NewBOP(newBOPAddr, payer, commitThreshold, defaultAction, defaultTimeoutLength, initialPayerString);\r\n        return newBOPAddr;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"payer\",\"type\":\"address\"},{\"name\":\"commitThreshold\",\"type\":\"uint256\"},{\"name\":\"defaultAction\",\"type\":\"uint8\"},{\"name\":\"defaultTimeoutLength\",\"type\":\"uint256\"},{\"name\":\"initialPayerString\",\"type\":\"string\"}],\"name\":\"newBurnableOpenPayment\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":true,\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newBOPAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"payer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"commitThreshold\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"defaultAction\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"defaultTimeoutLength\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"initialPayerString\",\"type\":\"string\"}],\"name\":\"NewBOP\",\"type\":\"event\"}]","ContractName":"BurnableOpenPaymentFactory","CompilerVersion":"v0.4.13+commit.fb4cb1a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://dcf643ca2b1b0b3d6d45ecca51484b675a357d6cc28f2f3486989c9534c8236b"}]}