{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.15;\r\n\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) constant returns (uint256);\r\n  function transfer(address to, uint256 value) returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract DNNTDE {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    /////////////////////////\r\n    // DNN Token Contract  //\r\n    /////////////////////////\r\n    DNNToken public dnnToken;\r\n\r\n    //////////////////////////////////////////\r\n    // Addresses of the co-founders of DNN. //\r\n    //////////////////////////////////////////\r\n    address public cofounderA;\r\n    address public cofounderB;\r\n\r\n    ///////////////////////////\r\n    // DNN Holding Multisig //\r\n    //////////////////////////\r\n    address public dnnHoldingMultisig;\r\n\r\n    ///////////////////////////\r\n    // Start date of the TDE //\r\n    ///////////////////////////\r\n    uint256 public TDEStartDate;  // Epoch\r\n\r\n    /////////////////////////\r\n    // End date of the TDE //\r\n    /////////////////////////\r\n    uint256 public TDEEndDate;  // Epoch\r\n\r\n    /////////////////////////////////\r\n    // Amount of atto-DNN per wei //\r\n    /////////////////////////////////\r\n    uint256 public tokenExchangeRateBase = 3000; // 1 Wei = 3000 atto-DNN\r\n\r\n    /////////////////////////////////////////////////\r\n    // Number of tokens distributed (in atto-DNN) //\r\n    /////////////////////////////////////////////////\r\n    uint256 public tokensDistributed = 0;\r\n\r\n    ///////////////////////////////////////////////\r\n    // Minumum Contributions for pre-TDE and TDE //\r\n    ///////////////////////////////////////////////\r\n    uint256 public minimumTDEContributionInWei = 0.001 ether;\r\n    uint256 public minimumPRETDEContributionInWei = 5 ether;\r\n\r\n    //////////////////////\r\n    // Funding Hard cap //\r\n    //////////////////////\r\n    uint256 public maximumFundingGoalInETH;\r\n\r\n    //////////////////\r\n    // Funds Raised //\r\n    //////////////////\r\n    uint256 public fundsRaisedInWei = 0;\r\n    uint256 public presaleFundsRaisedInWei = 0;\r\n\r\n    ////////////////////////////////////////////\r\n    // Keep track of Wei contributed per user //\r\n    ////////////////////////////////////////////\r\n    mapping(address => uint256) ETHContributions;\r\n\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    // Keeps track of pre-tde contributors and how many tokens they are entitled to get based on their contribution //\r\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    mapping(address => uint256) PRETDEContributorTokensPendingRelease;\r\n    uint256 PRETDEContributorsTokensPendingCount = 0; // keep track of contributors waiting for tokens\r\n    uint256 TokensPurchasedDuringPRETDE = 0; // keep track of how many tokens need to be issued to presale contributors\r\n\r\n    ///////////////////////////////////////////////////////////////////\r\n    // Checks if all pre-tde contributors have received their tokens //\r\n    ///////////////////////////////////////////////////////////////////\r\n    modifier NoPRETDEContributorsAwaitingTokens() {\r\n\r\n        // Determine if all pre-tde contributors have received tokens\r\n        require(PRETDEContributorsTokensPendingCount == 0);\r\n\r\n        _;\r\n    }\r\n\r\n    ///////////////////////////////////////////////////////////////////////////////////////\r\n    // Checks if there are any pre-tde contributors that have not recieved their tokens  //\r\n    ///////////////////////////////////////////////////////////////////////////////////////\r\n    modifier PRETDEContributorsAwaitingTokens() {\r\n\r\n        // Determine if there pre-tde contributors that have not received tokens\r\n        require(PRETDEContributorsTokensPendingCount > 0);\r\n\r\n        _;\r\n    }\r\n\r\n    ////////////////////////////////////////////////////\r\n    // Checks if CoFounders are performing the action //\r\n    ////////////////////////////////////////////////////\r\n    modifier onlyCofounders() {\r\n        require (msg.sender == cofounderA || msg.sender == cofounderB);\r\n        _;\r\n    }\r\n\r\n    ////////////////////////////////////////////////////\r\n    // Checks if CoFounder A is performing the action //\r\n    ////////////////////////////////////////////////////\r\n    modifier onlyCofounderA() {\r\n        require (msg.sender == cofounderA);\r\n        _;\r\n    }\r\n\r\n    ////////////////////////////////////////////////////\r\n    // Checks if CoFounder B is performing the action //\r\n    ////////////////////////////////////////////////////\r\n    modifier onlyCofounderB() {\r\n        require (msg.sender == cofounderB);\r\n        _;\r\n    }\r\n\r\n    //////////////////////////////////////\r\n    // Check if the pre-tde is going on //\r\n    //////////////////////////////////////\r\n    modifier PRETDEHasNotEnded() {\r\n       require (now < TDEStartDate);\r\n       _;\r\n    }\r\n\r\n    ////////////////////////////////s\r\n    // Check if the tde has ended //\r\n    ////////////////////////////////\r\n    modifier TDEHasEnded() {\r\n       require (now >= TDEEndDate || fundsRaisedInWei >= maximumFundingGoalInETH);\r\n       _;\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////////////////////\r\n    // Checksto see if the contribution is at least the minimum allowed for tde //\r\n    //////////////////////////////////////////////////////////////////////////////\r\n    modifier ContributionIsAtLeastMinimum() {\r\n        require (msg.value >= minimumTDEContributionInWei);\r\n        _;\r\n    }\r\n\r\n    ///////////////////////////////////////////////////////////////\r\n    // Make sure max cap is not exceeded with added contribution //\r\n    ///////////////////////////////////////////////////////////////\r\n    modifier ContributionDoesNotCauseGoalExceedance() {\r\n       uint256 newFundsRaised = msg.value+fundsRaisedInWei;\r\n       require (newFundsRaised <= maximumFundingGoalInETH);\r\n       _;\r\n    }\r\n\r\n    /////////////////////////////////////////////////////////////////\r\n    // Check if the specified beneficiary has sent us funds before //\r\n    /////////////////////////////////////////////////////////////////\r\n    modifier HasPendingPRETDETokens(address _contributor) {\r\n        require (PRETDEContributorTokensPendingRelease[_contributor] !=  0);\r\n        _;\r\n    }\r\n\r\n    /////////////////////////////////////////////////////////////\r\n    // Check if pre-tde contributors is not waiting for tokens //\r\n    /////////////////////////////////////////////////////////////\r\n    modifier IsNotAwaitingPRETDETokens(address _contributor) {\r\n        require (PRETDEContributorTokensPendingRelease[_contributor] ==  0);\r\n        _;\r\n    }\r\n\r\n    ///////////////////////////////////////////////////////\r\n    //  @des Function to change founder A address.       //\r\n    //  @param newAddress Address of new founder A.      //\r\n    ///////////////////////////////////////////////////////\r\n    function changeCofounderA(address newAddress)\r\n        onlyCofounderA\r\n    {\r\n        cofounderA = newAddress;\r\n    }\r\n\r\n    //////////////////////////////////////////////////////\r\n    //  @des Function to change founder B address.      //\r\n    //  @param newAddress Address of new founder B.     //\r\n    //////////////////////////////////////////////////////\r\n    function changeCofounderB(address newAddress)\r\n        onlyCofounderB\r\n    {\r\n        cofounderB = newAddress;\r\n    }\r\n\r\n    ////////////////////////////////////////\r\n    //  @des Function to extend pre-tde   //\r\n    //  @param new crowdsale start date   //\r\n    ////////////////////////////////////////\r\n    function extendPRETDE(uint256 startDate)\r\n        onlyCofounders\r\n        PRETDEHasNotEnded\r\n        returns (bool)\r\n    {\r\n        // Make sure that the new date is past the existing date and\r\n        // is not in the past.\r\n        if (startDate > now && startDate > TDEStartDate) {\r\n            TDEEndDate = TDEEndDate + (startDate-TDEStartDate); // Move end date the same amount of days as start date\r\n            TDEStartDate = startDate; // set new start date\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    //////////////////////////////////////////////////////\r\n    //  @des Function to change multisig address.       //\r\n    //  @param newAddress Address of new multisig.      //\r\n    //////////////////////////////////////////////////////\r\n    function changeDNNHoldingMultisig(address newAddress)\r\n        onlyCofounders\r\n    {\r\n        dnnHoldingMultisig = newAddress;\r\n    }\r\n\r\n    //////////////////////////////////////////\r\n    // @des ETH balance of each contributor //\r\n    //////////////////////////////////////////\r\n    function contributorETHBalance(address _owner)\r\n      constant\r\n      returns (uint256 balance)\r\n    {\r\n        return ETHContributions[_owner];\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////////\r\n    // @des Determines if an address is a pre-TDE contributor //\r\n    ////////////////////////////////////////////////////////////\r\n    function isAwaitingPRETDETokens(address _contributorAddress)\r\n       internal\r\n       returns (bool)\r\n    {\r\n        return PRETDEContributorTokensPendingRelease[_contributorAddress] > 0;\r\n    }\r\n\r\n    /////////////////////////////////////////////////////////////\r\n    // @des Returns pending presale tokens for a given address //\r\n    /////////////////////////////////////////////////////////////\r\n    function getPendingPresaleTokens(address _contributor)\r\n        constant\r\n        returns (uint256)\r\n    {\r\n        return PRETDEContributorTokensPendingRelease[_contributor];\r\n    }\r\n\r\n    ////////////////////////////////\r\n    // @des Returns current bonus //\r\n    ////////////////////////////////\r\n    function getCurrentTDEBonus()\r\n        constant\r\n        returns (uint256)\r\n    {\r\n        return getTDETokenExchangeRate(now);\r\n    }\r\n\r\n\r\n    ////////////////////////////////\r\n    // @des Returns current bonus //\r\n    ////////////////////////////////\r\n    function getCurrentPRETDEBonus()\r\n        constant\r\n        returns (uint256)\r\n    {\r\n        return getPRETDETokenExchangeRate(now);\r\n    }\r\n\r\n    ///////////////////////////////////////////////////////////////////////\r\n    // @des Returns bonus (in atto-DNN) per wei for the specific moment //\r\n    // @param timestamp Time of purchase (in seconds)                    //\r\n    ///////////////////////////////////////////////////////////////////////\r\n    function getTDETokenExchangeRate(uint256 timestamp)\r\n        constant\r\n        returns (uint256)\r\n    {\r\n        // No bonus - TDE ended\r\n        if (timestamp > TDEEndDate) {\r\n            return uint256(0);\r\n        }\r\n\r\n        // No bonus - TDE has not started\r\n        if (TDEStartDate > timestamp) {\r\n            return uint256(0);\r\n        }\r\n\r\n        // 1 ETH = 3600 DNN (0 - 20% of funding goal) - 20% Bonus\r\n        if (fundsRaisedInWei <= maximumFundingGoalInETH.mul(20).div(100)) {\r\n            return tokenExchangeRateBase.mul(120).div(100);\r\n\r\n        // 1 ETH = 3450 DNN (>20% to 60% of funding goal) - 15% Bonus\r\n        } else if (fundsRaisedInWei > maximumFundingGoalInETH.mul(20).div(100) && fundsRaisedInWei <= maximumFundingGoalInETH.mul(60).div(100)) {\r\n            return tokenExchangeRateBase.mul(115).div(100);\r\n\r\n        // 1 ETH = 3300 DNN (>60% to Funding Goal) - 10% Bonus\r\n        } else if (fundsRaisedInWei > maximumFundingGoalInETH.mul(60).div(100) && fundsRaisedInWei <= maximumFundingGoalInETH) {\r\n            return tokenExchangeRateBase.mul(110).div(100);\r\n\r\n        // Default: 1 ETH = 3000 DNN\r\n        } else {\r\n            return tokenExchangeRateBase;\r\n        }\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////////////////////////////////\r\n    // @des Returns bonus (in atto-DNN) per wei for the specific contribution amount //\r\n    // @param weiamount The amount of wei being contributed                           //\r\n    ////////////////////////////////////////////////////////////////////////////////////\r\n    function getPRETDETokenExchangeRate(uint256 weiamount)\r\n        constant\r\n        returns (uint256)\r\n    {\r\n        // Presale will only accept contributions above minimum\r\n        if (weiamount < minimumPRETDEContributionInWei) {\r\n            return uint256(0);\r\n        }\r\n\r\n        // Minimum Contribution - 199 ETH (25% Bonus)\r\n        if (weiamount >= minimumPRETDEContributionInWei && weiamount <= 199 ether) {\r\n            return tokenExchangeRateBase + tokenExchangeRateBase.mul(25).div(100);\r\n\r\n        // 200 ETH - 300 ETH Bonus (30% Bonus)\r\n        } else if (weiamount >= 200 ether && weiamount <= 300 ether) {\r\n            return tokenExchangeRateBase + tokenExchangeRateBase.mul(30).div(100);\r\n\r\n        // 301 ETH - 2665 ETH Bonus (35% Bonus)\r\n        } else if (weiamount >= 301 ether && weiamount <= 2665 ether) {\r\n            return tokenExchangeRateBase + tokenExchangeRateBase.mul(35).div(100);\r\n\r\n        // 2666+ ETH Bonus (50% Bonus)\r\n        } else {\r\n            return tokenExchangeRateBase + tokenExchangeRateBase.mul(50).div(100);\r\n        }\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////////////\r\n    // @des Computes how many tokens a buyer is entitled to based on contribution and time. //\r\n    //////////////////////////////////////////////////////////////////////////////////////////\r\n    function calculateTokens(uint256 weiamount, uint256 timestamp)\r\n        constant\r\n        returns (uint256)\r\n    {\r\n\r\n        // Compute how many atto-DNN user is entitled to.\r\n        uint256 computedTokensForPurchase = weiamount.mul(timestamp >= TDEStartDate ? getTDETokenExchangeRate(timestamp) : getPRETDETokenExchangeRate(weiamount));\r\n\r\n        // Amount of atto-DNN to issue\r\n        return computedTokensForPurchase;\r\n     }\r\n\r\n\r\n    ///////////////////////////////////////////////////////////////\r\n    // @des Issues tokens for users who made purchase with ETH   //\r\n    // @param beneficiary Address the tokens will be issued to.  //\r\n    // @param weiamount ETH amount (in Wei)                      //\r\n    // @param timestamp Time of purchase (in seconds)            //\r\n    ///////////////////////////////////////////////////////////////\r\n    function buyTokens()\r\n        internal\r\n        ContributionIsAtLeastMinimum\r\n        ContributionDoesNotCauseGoalExceedance\r\n        returns (bool)\r\n    {\r\n\r\n        // Determine how many tokens should be issued\r\n        uint256 tokenCount = calculateTokens(msg.value, now);\r\n\r\n        // Update total amount of tokens distributed (in atto-DNN)\r\n        tokensDistributed = tokensDistributed.add(tokenCount);\r\n\r\n        // Keep track of contributions (in Wei)\r\n        ETHContributions[msg.sender] = ETHContributions[msg.sender].add(msg.value);\r\n\r\n        // Increase total funds raised by contribution\r\n        fundsRaisedInWei = fundsRaisedInWei.add(msg.value);\r\n\r\n        // Determine which token allocation we should be deducting from\r\n        DNNToken.DNNSupplyAllocations allocationType = DNNToken.DNNSupplyAllocations.TDESupplyAllocation;\r\n\r\n        // Attempt to issue tokens to contributor\r\n        if (!dnnToken.issueTokens(msg.sender, tokenCount, allocationType)) {\r\n            revert();\r\n        }\r\n\r\n        // Transfer funds to multisig\r\n        dnnHoldingMultisig.transfer(msg.value);\r\n\r\n        return true;\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////////////////////////////////////\r\n    // @des Issues tokens for users who made purchase without using ETH during presale.   //\r\n    // @param beneficiary Address the tokens will be issued to.                           //\r\n    // @param weiamount ETH amount (in Wei)                                               //\r\n    ////////////////////////////////////////////////////////////////////////////////////////\r\n    function buyPRETDETokensWithoutETH(address beneficiary, uint256 weiamount, uint256 tokenCount)\r\n        onlyCofounders\r\n        PRETDEHasNotEnded\r\n        IsNotAwaitingPRETDETokens(beneficiary)\r\n        returns (bool)\r\n    {\r\n          // Keep track of contributions (in Wei)\r\n          ETHContributions[beneficiary] = ETHContributions[beneficiary].add(weiamount);\r\n\r\n          // Increase total funds raised by contribution\r\n          fundsRaisedInWei = fundsRaisedInWei.add(weiamount);\r\n\r\n          // Keep track of presale funds in addition, separately\r\n          presaleFundsRaisedInWei = presaleFundsRaisedInWei.add(weiamount);\r\n\r\n          // Add these tokens to the total amount of tokens this contributor is entitled to\r\n          PRETDEContributorTokensPendingRelease[beneficiary] = PRETDEContributorTokensPendingRelease[beneficiary].add(tokenCount);\r\n\r\n          // Incrment number of pre-tde contributors waiting for tokens\r\n          PRETDEContributorsTokensPendingCount += 1;\r\n\r\n          // Send tokens to contibutor\r\n          return issuePRETDETokens(beneficiary);\r\n      }\r\n\r\n    ///////////////////////////////////////////////////////////////\r\n    // @des Issues pending tokens to pre-tde contributor         //\r\n    // @param beneficiary Address the tokens will be issued to.  //\r\n    ///////////////////////////////////////////////////////////////\r\n    function issuePRETDETokens(address beneficiary)\r\n        onlyCofounders\r\n        PRETDEContributorsAwaitingTokens\r\n        HasPendingPRETDETokens(beneficiary)\r\n        returns (bool)\r\n    {\r\n\r\n        // Amount of tokens to credit pre-tde contributor\r\n        uint256 tokenCount = PRETDEContributorTokensPendingRelease[beneficiary];\r\n\r\n        // Update total amount of tokens distributed (in atto-DNN)\r\n        tokensDistributed = tokensDistributed.add(tokenCount);\r\n\r\n        // Allocation type will be PRETDESupplyAllocation\r\n        DNNToken.DNNSupplyAllocations allocationType = DNNToken.DNNSupplyAllocations.PRETDESupplyAllocation;\r\n\r\n        // Attempt to issue tokens\r\n        if (!dnnToken.issueTokens(beneficiary, tokenCount, allocationType)) {\r\n            revert();\r\n        }\r\n\r\n        // Reduce number of pre-tde contributors waiting for tokens\r\n        PRETDEContributorsTokensPendingCount -= 1;\r\n\r\n        // Denote that tokens have been issued for this pre-tde contributor\r\n        PRETDEContributorTokensPendingRelease[beneficiary] = 0;\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    /////////////////////////////////\r\n    // @des Marks TDE as completed //\r\n    /////////////////////////////////\r\n    function finalizeTDE()\r\n       onlyCofounders\r\n       TDEHasEnded\r\n    {\r\n        // Check if the tokens are locked and all pre-sale tokens have been\r\n        // transferred to the TDE Supply before unlocking tokens.\r\n        require(dnnToken.tokensLocked() == true && dnnToken.PRETDESupplyRemaining() == 0);\r\n\r\n        // Unlock tokens\r\n        dnnToken.unlockTokens();\r\n\r\n        // Update tokens distributed\r\n        tokensDistributed += dnnToken.TDESupplyRemaining();\r\n\r\n        // Transfer unsold TDE tokens to platform\r\n        dnnToken.sendUnsoldTDETokensToPlatform();\r\n    }\r\n\r\n\r\n    ////////////////////////////////////////////////////////////////////////////////\r\n    // @des Marks pre-TDE as completed by moving remaining tokens into TDE supply //\r\n    ////////////////////////////////////////////////////////////////////////////////\r\n    function finalizePRETDE()\r\n       onlyCofounders\r\n       NoPRETDEContributorsAwaitingTokens\r\n    {\r\n        // Check if we have tokens to transfer to TDE\r\n        require(dnnToken.PRETDESupplyRemaining() > 0);\r\n\r\n        // Transfer unsold TDE tokens to platform\r\n        dnnToken.sendUnsoldPRETDETokensToTDE();\r\n    }\r\n\r\n\r\n    ///////////////////////////////\r\n    // @des Contract constructor //\r\n    ///////////////////////////////\r\n    function DNNTDE(address tokenAddress, address founderA, address founderB, address dnnHolding, uint256 hardCap, uint256 startDate, uint256 endDate)\r\n    {\r\n\r\n        // Set token address\r\n        dnnToken = DNNToken(tokenAddress);\r\n\r\n        // Set cofounder addresses\r\n        cofounderA = founderA;\r\n        cofounderB = founderB;\r\n\r\n        // Set DNN holding address\r\n        dnnHoldingMultisig = dnnHolding;\r\n\r\n        // Set Hard Cap\r\n        maximumFundingGoalInETH = hardCap * 1 ether;\r\n\r\n        // Set Start Date\r\n        TDEStartDate = startDate >= now ? startDate : now;\r\n\r\n        // Set End date (Make sure the end date is at least 30 days from start date)\r\n        // Will default to a date that is exactly 30 days from start date.\r\n        TDEEndDate = endDate > TDEStartDate && (endDate-TDEStartDate) >= 30 days ? endDate : (TDEStartDate + 30 days);\r\n    }\r\n\r\n    /////////////////////////////////////////////////////////\r\n    // @des Handle's ETH sent directly to contract address //\r\n    /////////////////////////////////////////////////////////\r\n    function () payable {\r\n\r\n        // Handle pre-sale contribution (tokens held, until tx confirmation from contributor)\r\n        // Makes sure the user sends minimum PRE-TDE contribution, and that  pre-tde contributors\r\n        // are unable to send subsequent ETH contributors before being issued tokens.\r\n        if (now < TDEStartDate && msg.value >= minimumPRETDEContributionInWei && PRETDEContributorTokensPendingRelease[msg.sender] == 0) {\r\n\r\n            // Keep track of contributions (in Wei)\r\n            ETHContributions[msg.sender] = ETHContributions[msg.sender].add(msg.value);\r\n\r\n            // Increase total funds raised by contribution\r\n            fundsRaisedInWei = fundsRaisedInWei.add(msg.value);\r\n\r\n            // Keep track of presale funds in addition, separately\r\n            presaleFundsRaisedInWei = presaleFundsRaisedInWei.add(msg.value);\r\n\r\n            /// Make a note of how many tokens this user should get for their contribution to the presale\r\n            PRETDEContributorTokensPendingRelease[msg.sender] = PRETDEContributorTokensPendingRelease[msg.sender].add(calculateTokens(msg.value, now));\r\n\r\n            // Keep track of pending tokens\r\n            TokensPurchasedDuringPRETDE += calculateTokens(msg.value, now);\r\n\r\n            // Increment number of pre-tde contributors waiting for tokens\r\n            PRETDEContributorsTokensPendingCount += 1;\r\n\r\n            // Prevent contributions that will cause us to have a shortage of tokens during the pre-sale\r\n            if (TokensPurchasedDuringPRETDE > dnnToken.TDESupplyRemaining()+dnnToken.PRETDESupplyRemaining()) {\r\n                revert();\r\n            }\r\n\r\n            // Transfer contribution directly to multisig\r\n            dnnHoldingMultisig.transfer(msg.value);\r\n        }\r\n\r\n        // Handle public-sale contribution (tokens issued immediately)\r\n        else if (now >= TDEStartDate && now < TDEEndDate) buyTokens();\r\n\r\n        // Otherwise, reject the contribution\r\n        else revert();\r\n    }\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) returns (bool);\r\n  function approve(address spender, uint256 value) returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) returns (bool) {\r\n    require(_to != address(0));\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n}\r\n\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\r\n    require(_to != address(0));\r\n\r\n    var _allowance = allowed[_from][msg.sender];\r\n\r\n    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n    // require (_value <= _allowance);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) returns (bool) {\r\n\r\n    // To change the approve amount you first have to reduce the addresses`\r\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n    //  already 0 to mitigate the race condition described here:\r\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   */\r\n  function increaseApproval (address _spender, uint _addedValue)\r\n    returns (bool success) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  function decreaseApproval (address _spender, uint _subtractedValue)\r\n    returns (bool success) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n}\r\n\r\ncontract DNNToken is StandardToken {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    ////////////////////////////////////////////////////////////\r\n    // Used to indicate which allocation we issue tokens from //\r\n    ////////////////////////////////////////////////////////////\r\n    enum DNNSupplyAllocations {\r\n        EarlyBackerSupplyAllocation,\r\n        PRETDESupplyAllocation,\r\n        TDESupplyAllocation,\r\n        BountySupplyAllocation,\r\n        WriterAccountSupplyAllocation,\r\n        AdvisorySupplyAllocation,\r\n        PlatformSupplyAllocation\r\n    }\r\n\r\n    /////////////////////////////////////////////////////////////////////\r\n    // Smart-Contract with permission to allocate tokens from supplies //\r\n    /////////////////////////////////////////////////////////////////////\r\n    address public allocatorAddress;\r\n    address public crowdfundContract;\r\n\r\n    /////////////////////\r\n    // Token Meta Data //\r\n    /////////////////////\r\n    string constant public name = \"DNN\";\r\n    string constant public symbol = \"DNN\";\r\n    uint8 constant public decimals = 18; // 1 DNN = 1 * 10^18 atto-DNN\r\n\r\n    /////////////////////////////////////////\r\n    // Addresses of the co-founders of DNN //\r\n    /////////////////////////////////////////\r\n    address public cofounderA;\r\n    address public cofounderB;\r\n\r\n    /////////////////////////\r\n    // Address of Platform //\r\n    /////////////////////////\r\n    address public platform;\r\n\r\n    /////////////////////////////////////////////\r\n    // Token Distributions (% of total supply) //\r\n    /////////////////////////////////////////////\r\n    uint256 public earlyBackerSupply; // 10%\r\n    uint256 public PRETDESupply; // 10%\r\n    uint256 public TDESupply; // 40%\r\n    uint256 public bountySupply; // 1%\r\n    uint256 public writerAccountSupply; // 4%\r\n    uint256 public advisorySupply; // 14%\r\n    uint256 public cofoundersSupply; // 10%\r\n    uint256 public platformSupply; // 11%\r\n\r\n    uint256 public earlyBackerSupplyRemaining; // 10%\r\n    uint256 public PRETDESupplyRemaining; // 10%\r\n    uint256 public TDESupplyRemaining; // 40%\r\n    uint256 public bountySupplyRemaining; // 1%\r\n    uint256 public writerAccountSupplyRemaining; // 4%\r\n    uint256 public advisorySupplyRemaining; // 14%\r\n    uint256 public cofoundersSupplyRemaining; // 10%\r\n    uint256 public platformSupplyRemaining; // 11%\r\n\r\n    ////////////////////////////////////////////////////////////////////////////////////\r\n    // Amount of CoFounder Supply that has been distributed based on vesting schedule //\r\n    ////////////////////////////////////////////////////////////////////////////////////\r\n    uint256 public cofoundersSupplyVestingTranches = 10;\r\n    uint256 public cofoundersSupplyVestingTranchesIssued = 0;\r\n    uint256 public cofoundersSupplyVestingStartDate; // Epoch\r\n    uint256 public cofoundersSupplyDistributed = 0;  // # of atto-DNN distributed to founders\r\n\r\n    //////////////////////////////////////////////\r\n    // Prevents tokens from being transferrable //\r\n    //////////////////////////////////////////////\r\n    bool public tokensLocked = true;\r\n\r\n    /////////////////////////////////////////////////////////////////////////////\r\n    // Event triggered when tokens are transferred from one address to another //\r\n    /////////////////////////////////////////////////////////////////////////////\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    ////////////////////////////////////////////////////////////\r\n    // Checks if tokens can be issued to founder at this time //\r\n    ////////////////////////////////////////////////////////////\r\n    modifier CofoundersTokensVested()\r\n    {\r\n        // Make sure that a starting vesting date has been set and 4 weeks have passed since vesting date\r\n        require (cofoundersSupplyVestingStartDate != 0 && (now-cofoundersSupplyVestingStartDate) >= 4 weeks);\r\n\r\n        // Get current tranche based on the amount of time that has passed since vesting start date\r\n        uint256 currentTranche = now.sub(cofoundersSupplyVestingStartDate) / 4 weeks;\r\n\r\n        // Amount of tranches that have been issued so far\r\n        uint256 issuedTranches = cofoundersSupplyVestingTranchesIssued;\r\n\r\n        // Amount of tranches that cofounders are entitled to\r\n        uint256 maxTranches = cofoundersSupplyVestingTranches;\r\n\r\n        // Make sure that we still have unvested tokens and that\r\n        // the tokens for the current tranche have not been issued.\r\n        require (issuedTranches != maxTranches && currentTranche > issuedTranches);\r\n\r\n        _;\r\n    }\r\n\r\n    ///////////////////////////////////\r\n    // Checks if tokens are unlocked //\r\n    ///////////////////////////////////\r\n    modifier TokensUnlocked()\r\n    {\r\n        require (tokensLocked == false);\r\n        _;\r\n    }\r\n\r\n    /////////////////////////////////\r\n    // Checks if tokens are locked //\r\n    /////////////////////////////////\r\n    modifier TokensLocked()\r\n    {\r\n       require (tokensLocked == true);\r\n       _;\r\n    }\r\n\r\n    ////////////////////////////////////////////////////\r\n    // Checks if CoFounders are performing the action //\r\n    ////////////////////////////////////////////////////\r\n    modifier onlyCofounders()\r\n    {\r\n        require (msg.sender == cofounderA || msg.sender == cofounderB);\r\n        _;\r\n    }\r\n\r\n    ////////////////////////////////////////////////////\r\n    // Checks if CoFounder A is performing the action //\r\n    ////////////////////////////////////////////////////\r\n    modifier onlyCofounderA()\r\n    {\r\n        require (msg.sender == cofounderA);\r\n        _;\r\n    }\r\n\r\n    ////////////////////////////////////////////////////\r\n    // Checks if CoFounder B is performing the action //\r\n    ////////////////////////////////////////////////////\r\n    modifier onlyCofounderB()\r\n    {\r\n        require (msg.sender == cofounderB);\r\n        _;\r\n    }\r\n\r\n    /////////////////////////////////////////////////////////////////////\r\n    // Checks to see if we are allowed to change the allocator address //\r\n    /////////////////////////////////////////////////////////////////////\r\n    modifier CanSetAllocator()\r\n    {\r\n       require (allocatorAddress == address(0x0) || tokensLocked == false);\r\n       _;\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////////////\r\n    // Checks to see if we are allowed to change the crowdfund contract //\r\n    //////////////////////////////////////////////////////////////////////\r\n    modifier CanSetCrowdfundContract()\r\n    {\r\n       require (crowdfundContract == address(0x0));\r\n       _;\r\n    }\r\n\r\n    //////////////////////////////////////////////////\r\n    // Checks if Allocator is performing the action //\r\n    //////////////////////////////////////////////////\r\n    modifier onlyAllocator()\r\n    {\r\n        require (msg.sender == allocatorAddress && tokensLocked == false);\r\n        _;\r\n    }\r\n\r\n    ///////////////////////////////////////////////////////////\r\n    // Checks if Crowdfund Contract is performing the action //\r\n    ///////////////////////////////////////////////////////////\r\n    modifier onlyCrowdfundContract()\r\n    {\r\n        require (msg.sender == crowdfundContract);\r\n        _;\r\n    }\r\n\r\n    ///////////////////////////////////////////////////////////////////////////////////\r\n    // Checks if Crowdfund Contract, Platform, or Allocator is performing the action //\r\n    ///////////////////////////////////////////////////////////////////////////////////\r\n    modifier onlyAllocatorOrCrowdfundContractOrPlatform()\r\n    {\r\n        require (msg.sender == allocatorAddress || msg.sender == crowdfundContract || msg.sender == platform);\r\n        _;\r\n    }\r\n\r\n    ///////////////////////////////////////////////////////////////////////\r\n    //  @des Function to change address that is manage platform holding  //\r\n    //  @param newAddress Address of new issuance contract.              //\r\n    ///////////////////////////////////////////////////////////////////////\r\n    function changePlatform(address newAddress)\r\n        onlyCofounders\r\n    {\r\n        platform = newAddress;\r\n    }\r\n\r\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    //  @des Function to change address that is allowed to do token issuance. Crowdfund contract can only be set once.   //\r\n    //  @param newAddress Address of new issuance contract.                                                              //\r\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    function changeCrowdfundContract(address newAddress)\r\n        onlyCofounders\r\n        CanSetCrowdfundContract\r\n    {\r\n        crowdfundContract = newAddress;\r\n    }\r\n\r\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    //  @des Function to change address that is allowed to do token issuance. Allocator can only be set once.  //\r\n    //  @param newAddress Address of new issuance contract.                                                    //\r\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    function changeAllocator(address newAddress)\r\n        onlyCofounders\r\n        CanSetAllocator\r\n    {\r\n        allocatorAddress = newAddress;\r\n    }\r\n\r\n    ///////////////////////////////////////////////////////\r\n    //  @des Function to change founder A address.       //\r\n    //  @param newAddress Address of new founder A.      //\r\n    ///////////////////////////////////////////////////////\r\n    function changeCofounderA(address newAddress)\r\n        onlyCofounderA\r\n    {\r\n        cofounderA = newAddress;\r\n    }\r\n\r\n    //////////////////////////////////////////////////////\r\n    //  @des Function to change founder B address.      //\r\n    //  @param newAddress Address of new founder B.     //\r\n    //////////////////////////////////////////////////////\r\n    function changeCofounderB(address newAddress)\r\n        onlyCofounderB\r\n    {\r\n        cofounderB = newAddress;\r\n    }\r\n\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    // Transfers tokens from senders address to another address //\r\n    //////////////////////////////////////////////////////////////\r\n    function transfer(address _to, uint256 _value)\r\n      TokensUnlocked\r\n      returns (bool)\r\n    {\r\n          Transfer(msg.sender, _to, _value);\r\n          return BasicToken.transfer(_to, _value);\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////\r\n    // Transfers tokens from one address to another address //\r\n    //////////////////////////////////////////////////////////\r\n    function transferFrom(address _from, address _to, uint256 _value)\r\n      TokensUnlocked\r\n      returns (bool)\r\n    {\r\n          Transfer(_from, _to, _value);\r\n          return StandardToken.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n\r\n    ///////////////////////////////////////////////////////////////////////////////////////////////\r\n    //  @des Cofounders issue tokens to themsleves if within vesting period. Returns success.    //\r\n    //  @param beneficiary Address of receiver.                                                  //\r\n    //  @param tokenCount Number of tokens to issue.                                             //\r\n    ///////////////////////////////////////////////////////////////////////////////////////////////\r\n    function issueCofoundersTokensIfPossible()\r\n        onlyCofounders\r\n        CofoundersTokensVested\r\n        returns (bool)\r\n    {\r\n        // Compute total amount of vested tokens to issue\r\n        uint256 tokenCount = cofoundersSupply.div(cofoundersSupplyVestingTranches);\r\n\r\n        // Make sure that there are cofounder tokens left\r\n        if (tokenCount > cofoundersSupplyRemaining) {\r\n           return false;\r\n        }\r\n\r\n        // Decrease cofounders supply\r\n        cofoundersSupplyRemaining = cofoundersSupplyRemaining.sub(tokenCount);\r\n\r\n        // Update how many tokens have been distributed to cofounders\r\n        cofoundersSupplyDistributed = cofoundersSupplyDistributed.add(tokenCount);\r\n\r\n        // Split tokens between both founders\r\n        balances[cofounderA] = balances[cofounderA].add(tokenCount.div(2));\r\n        balances[cofounderB] = balances[cofounderB].add(tokenCount.div(2));\r\n\r\n        // Update that a tranche has been issued\r\n        cofoundersSupplyVestingTranchesIssued += 1;\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    //////////////////\r\n    // Issue tokens //\r\n    //////////////////\r\n    function issueTokens(address beneficiary, uint256 tokenCount, DNNSupplyAllocations allocationType)\r\n      onlyAllocatorOrCrowdfundContractOrPlatform\r\n      returns (bool)\r\n    {\r\n        // We'll use the following to determine whether the allocator, platform,\r\n        // or the crowdfunding contract can allocate specified supply\r\n        bool canAllocatorPerform = msg.sender == allocatorAddress && tokensLocked == false;\r\n        bool canCrowdfundContractPerform = msg.sender == crowdfundContract;\r\n        bool canPlatformPerform = msg.sender == platform && tokensLocked == false;\r\n\r\n        // Early Backers\r\n        if (canAllocatorPerform && allocationType == DNNSupplyAllocations.EarlyBackerSupplyAllocation && tokenCount <= earlyBackerSupplyRemaining) {\r\n            earlyBackerSupplyRemaining = earlyBackerSupplyRemaining.sub(tokenCount);\r\n        }\r\n\r\n        // PRE-TDE\r\n        else if (canCrowdfundContractPerform && msg.sender == crowdfundContract && allocationType == DNNSupplyAllocations.PRETDESupplyAllocation) {\r\n\r\n              // Check to see if we have enough tokens to satisfy this purchase\r\n              // using just the pre-tde.\r\n              if (PRETDESupplyRemaining >= tokenCount) {\r\n\r\n                    // Decrease pre-tde supply\r\n                    PRETDESupplyRemaining = PRETDESupplyRemaining.sub(tokenCount);\r\n              }\r\n\r\n              // Check to see if we can satisfy this using pre-tde and tde supply combined\r\n              else if (PRETDESupplyRemaining+TDESupplyRemaining >= tokenCount) {\r\n\r\n                    // Decrease tde supply\r\n                    TDESupplyRemaining = TDESupplyRemaining.sub(tokenCount-PRETDESupplyRemaining);\r\n\r\n                    // Decrease pre-tde supply by its' remaining tokens\r\n                    PRETDESupplyRemaining = 0;\r\n              }\r\n\r\n              // Otherwise, we can't satisfy this sale because we don't have enough tokens.\r\n              else {\r\n                  return false;\r\n              }\r\n        }\r\n\r\n        // TDE\r\n        else if (canCrowdfundContractPerform && allocationType == DNNSupplyAllocations.TDESupplyAllocation && tokenCount <= TDESupplyRemaining) {\r\n            TDESupplyRemaining = TDESupplyRemaining.sub(tokenCount);\r\n        }\r\n\r\n        // Bounty\r\n        else if (canAllocatorPerform && allocationType == DNNSupplyAllocations.BountySupplyAllocation && tokenCount <= bountySupplyRemaining) {\r\n            bountySupplyRemaining = bountySupplyRemaining.sub(tokenCount);\r\n        }\r\n\r\n        // Writer Accounts\r\n        else if (canAllocatorPerform && allocationType == DNNSupplyAllocations.WriterAccountSupplyAllocation && tokenCount <= writerAccountSupplyRemaining) {\r\n            writerAccountSupplyRemaining = writerAccountSupplyRemaining.sub(tokenCount);\r\n        }\r\n\r\n        // Advisory\r\n        else if (canAllocatorPerform && allocationType == DNNSupplyAllocations.AdvisorySupplyAllocation && tokenCount <= advisorySupplyRemaining) {\r\n            advisorySupplyRemaining = advisorySupplyRemaining.sub(tokenCount);\r\n        }\r\n\r\n        // Platform (Also makes sure that the beneficiary is the platform address specified in this contract)\r\n        else if (canPlatformPerform && allocationType == DNNSupplyAllocations.PlatformSupplyAllocation && tokenCount <= platformSupplyRemaining) {\r\n            platformSupplyRemaining = platformSupplyRemaining.sub(tokenCount);\r\n        }\r\n\r\n        else {\r\n            return false;\r\n        }\r\n\r\n        // Credit tokens to the address specified\r\n        balances[beneficiary] = balances[beneficiary].add(tokenCount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /////////////////////////////////////////////////\r\n    // Transfer Unsold tokens from TDE to Platform //\r\n    /////////////////////////////////////////////////\r\n    function sendUnsoldTDETokensToPlatform()\r\n      external\r\n      onlyCrowdfundContract\r\n    {\r\n        // Make sure we have tokens to send from TDE\r\n        if (TDESupplyRemaining > 0) {\r\n\r\n            // Add remaining tde tokens to platform remaining tokens\r\n            platformSupplyRemaining = platformSupplyRemaining.add(TDESupplyRemaining);\r\n\r\n            // Clear remaining tde token count\r\n            TDESupplyRemaining = 0;\r\n        }\r\n    }\r\n\r\n    /////////////////////////////////////////////////////\r\n    // Transfer Unsold tokens from pre-TDE to Platform //\r\n    /////////////////////////////////////////////////////\r\n    function sendUnsoldPRETDETokensToTDE()\r\n      external\r\n      onlyCrowdfundContract\r\n    {\r\n          // Make sure we have tokens to send from pre-TDE\r\n          if (PRETDESupplyRemaining > 0) {\r\n\r\n              // Add remaining pre-tde tokens to tde remaining tokens\r\n              TDESupplyRemaining = TDESupplyRemaining.add(PRETDESupplyRemaining);\r\n\r\n              // Clear remaining pre-tde token count\r\n              PRETDESupplyRemaining = 0;\r\n        }\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////////////\r\n    // @des Allows tokens to be transferrable. Returns lock state //\r\n    ////////////////////////////////////////////////////////////////\r\n    function unlockTokens()\r\n        external\r\n        onlyCrowdfundContract\r\n    {\r\n        // Make sure tokens are currently locked before proceeding to unlock them\r\n        require(tokensLocked == true);\r\n\r\n        tokensLocked = false;\r\n    }\r\n\r\n    ///////////////////////////////////////////////////////////////////////\r\n    //  @des Contract constructor function sets initial token balances.  //\r\n    ///////////////////////////////////////////////////////////////////////\r\n    function DNNToken(address founderA, address founderB, address platformAddress, uint256 vestingStartDate)\r\n    {\r\n          // Set cofounder addresses\r\n          cofounderA = founderA;\r\n          cofounderB = founderB;\r\n\r\n          // Sets platform address\r\n          platform = platformAddress;\r\n\r\n          // Set total supply - 1 Billion DNN Tokens = (1,000,000,000 * 10^18) atto-DNN\r\n          // 1 DNN = 10^18 atto-DNN\r\n          totalSupply = uint256(1000000000).mul(uint256(10)**decimals);\r\n\r\n          // Set Token Distributions (% of total supply)\r\n          earlyBackerSupply = totalSupply.mul(10).div(100); // 10%\r\n          PRETDESupply = totalSupply.mul(10).div(100); // 10%\r\n          TDESupply = totalSupply.mul(40).div(100); // 40%\r\n          bountySupply = totalSupply.mul(1).div(100); // 1%\r\n          writerAccountSupply = totalSupply.mul(4).div(100); // 4%\r\n          advisorySupply = totalSupply.mul(14).div(100); // 14%\r\n          cofoundersSupply = totalSupply.mul(10).div(100); // 10%\r\n          platformSupply = totalSupply.mul(11).div(100); // 11%\r\n\r\n          // Set each remaining token count equal to its' respective supply\r\n          earlyBackerSupplyRemaining = earlyBackerSupply;\r\n          PRETDESupplyRemaining = PRETDESupply;\r\n          TDESupplyRemaining = TDESupply;\r\n          bountySupplyRemaining = bountySupply;\r\n          writerAccountSupplyRemaining = writerAccountSupply;\r\n          advisorySupplyRemaining = advisorySupply;\r\n          cofoundersSupplyRemaining = cofoundersSupply;\r\n          platformSupplyRemaining = platformSupply;\r\n\r\n          // Sets cofounder vesting start date (Ensures that it is a date in the future, otherwise it will default to now)\r\n          cofoundersSupplyVestingStartDate = vestingStartDate >= now ? vestingStartDate : now;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"finalizeTDE\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensDistributed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentPRETDEBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentTDEBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TDEEndDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cofounderB\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contributor\",\"type\":\"address\"}],\"name\":\"getPendingPresaleTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"weiamount\",\"type\":\"uint256\"},{\"name\":\"tokenCount\",\"type\":\"uint256\"}],\"name\":\"buyPRETDETokensWithoutETH\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"changeCofounderA\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalizePRETDE\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenExchangeRateBase\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"changeDNNHoldingMultisig\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"contributorETHBalance\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"weiamount\",\"type\":\"uint256\"}],\"name\":\"getPRETDETokenExchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"weiamount\",\"type\":\"uint256\"},{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"calculateTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dnnHoldingMultisig\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"changeCofounderB\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundsRaisedInWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"startDate\",\"type\":\"uint256\"}],\"name\":\"extendPRETDE\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TDEStartDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maximumFundingGoalInETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"issuePRETDETokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumTDEContributionInWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumPRETDEContributionInWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presaleFundsRaisedInWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cofounderA\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dnnToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getTDETokenExchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"founderA\",\"type\":\"address\"},{\"name\":\"founderB\",\"type\":\"address\"},{\"name\":\"dnnHolding\",\"type\":\"address\"},{\"name\":\"hardCap\",\"type\":\"uint256\"},{\"name\":\"startDate\",\"type\":\"uint256\"},{\"name\":\"endDate\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"}]","ContractName":"DNNTDE","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000034915679d8e7f6b5ec26c02ab18565af38e19fc20000000000000000000000003cf26a9fe33c219db87c2e50572e50803efb29810000000000000000000000009ffe2ad5d76954c7c25be0cee30795279c4cab9f0000000000000000000000005980a47514a0af79a8d2f6276f8673a006ec99290000000000000000000000000000000000000000000000000000000000011170000000000000000000000000000000000000000000000000000000005a73aa01000000000000000000000000000000000000000000000000000000005aa1ce81","Library":"","SwarmSource":"bzzr://f6a307da8ee524d77b9da7c999aa05b9189a748b218a7a6be3651d086ca0d97e"}]}