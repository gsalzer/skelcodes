{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.0;\r\n\r\n\r\n//Dapp at http://www.staticoin.com\r\n//https://github.com/genkifs/staticoin\r\n\r\n/** @title owned. */\r\ncontract owned  {\r\n  address owner;\r\n  function owned() {\r\n    owner = msg.sender;\r\n  }\r\n  function changeOwner(address newOwner) onlyOwner {\r\n    owner = newOwner;\r\n  }\r\n  modifier onlyOwner() {\r\n    require(msg.sender==owner); \r\n    _;\r\n  }\r\n}\r\n\r\n/** @title I_Pricer. */\r\ncontract I_Pricer {\r\n    uint128 public lastPrice;\r\n    I_minter public mint;\r\n    string public sURL;\r\n    mapping (bytes32 => uint) RevTransaction;\r\n    function __callback(bytes32 myid, string result) {}\r\n    function queryCost() constant returns (uint128 _value) {}\r\n    function QuickPrice() payable {}\r\n    function requestPrice(uint _actionID) payable returns (uint _TrasID) {}\r\n    function collectFee() returns(bool) {}\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        revert();\r\n    }\r\n}\r\n    \r\n\r\n/** @title I_coin. */\r\ncontract I_coin {\r\n\r\n    event EventClear();\r\n\r\n\tI_minter public mint;\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals=18;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = '';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\t\r\n    function mintCoin(address target, uint256 mintedAmount) returns (bool success) {}\r\n    function meltCoin(address target, uint256 meltedAmount) returns (bool success) {}\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData){}\r\n\r\n    function setMinter(address _minter) {}   \r\n\tfunction increaseApproval (address _spender, uint256 _addedValue) returns (bool success) {}    \r\n\tfunction decreaseApproval (address _spender, uint256 _subtractedValue) \treturns (bool success) {} \r\n\r\n    // @param _owner The address from which the balance will be retrieved\r\n    // @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}    \r\n\r\n\r\n    // @notice send `_value` token to `_to` from `msg.sender`\r\n    // @param _to The address of the recipient\r\n    // @param _value The amount of token to be transferred\r\n    // @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n\r\n    // @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    // @param _from The address of the sender\r\n    // @param _to The address of the recipient\r\n    // @param _value The amount of token to be transferred\r\n    // @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    // @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    // @param _spender The address of the account able to transfer the tokens\r\n    // @param _value The amount of wei to be approved for transfer\r\n    // @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\t\r\n\t// @param _owner The address of the account owning tokens\r\n    // @param _spender The address of the account able to transfer the tokens\r\n    // @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\t\r\n\tmapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n\t// @return total amount of tokens\r\n    uint256 public totalSupply;\r\n}\r\n\r\n/** @title I_minter. */\r\ncontract I_minter { \r\n    event EventCreateStatic(address indexed _from, uint128 _value, uint _transactionID, uint _Price); \r\n    event EventRedeemStatic(address indexed _from, uint128 _value, uint _transactionID, uint _Price); \r\n    event EventCreateRisk(address indexed _from, uint128 _value, uint _transactionID, uint _Price); \r\n    event EventRedeemRisk(address indexed _from, uint128 _value, uint _transactionID, uint _Price); \r\n    event EventBankrupt();\r\n    \r\n\tuint128 public PendingETH; \r\n    uint public TransCompleted;\r\n\t\r\n    function Leverage() constant returns (uint128)  {}\r\n    function RiskPrice(uint128 _currentPrice,uint128 _StaticTotal,uint128 _RiskTotal, uint128 _ETHTotal) constant returns (uint128 price)  {}\r\n    function RiskPrice(uint128 _currentPrice) constant returns (uint128 price)  {}     \r\n    function PriceReturn(uint _TransID,uint128 _Price) {}\r\n\tfunction StaticEthAvailable() public constant returns (uint128 StaticEthAvailable) {}\r\n    function NewStatic() external payable returns (uint _TransID)  {}\r\n    function NewStaticAdr(address _Risk) external payable returns (uint _TransID)  {}\r\n    function NewRisk() external payable returns (uint _TransID)  {}\r\n    function NewRiskAdr(address _Risk) external payable returns (uint _TransID)  {}\r\n    function RetRisk(uint128 _Quantity) external payable returns (uint _TransID)  {}\r\n    function RetStatic(uint128 _Quantity) external payable returns (uint _TransID)  {}\r\n    function Strike() constant returns (uint128)  {}\r\n}\r\n\r\ncontract StaticoinSummary is owned{\r\n\r\n    function StaticoinSummary(){}\r\n\r\n\taddress[] public mints;\r\n\taddress[] public staticoins; \r\n\taddress[] public riskcoins;\r\n\taddress[] public pricers;\r\n\r\n    function SetAddresses(address[] _mints, address[] _staticoins, address[] _riskcoins,  address[] _pricers) onlyOwner external {\r\n\t\trequire(_mints.length > 0);\r\n\t\trequire(_staticoins.length == _mints.length);\r\n        require(_riskcoins.length == _mints.length);\r\n\t\trequire(_pricers.length == _mints.length);\r\n\t\tmints=_mints;\r\n\t\tstaticoins=_staticoins;\r\n\t\triskcoins=_riskcoins;\r\n\t\tpricers=_pricers;\r\n\t}\r\n\r\n\tfunction balancesStaticoin() view public returns (uint[]) {\r\n\t\treturn balances(msg.sender, staticoins);\r\n\t}\r\n\r\n\tfunction balancesStaticoin(address user) view public returns (uint[]) {\r\n\t\treturn balances(user, staticoins);\r\n\t}\r\n\r\n\tfunction balancesRiskcoins() view public returns (uint[]) {\r\n\t\treturn balances(msg.sender, riskcoins);\r\n\t}\r\n\t\r\n\tfunction balancesRiskcoins(address user) view public returns (uint[]) {\r\n\t\treturn balances(user, riskcoins);\r\n\t}\r\n\t\r\n    function balances(address user,  address[] _coins) view public returns (uint[]) {\r\n        require(_coins.length > 0);\r\n        uint[] memory balances = new uint[](_coins.length);\r\n\r\n        //as this is a call() function, we don't really care about gas cost, just dont make the array too large\r\n        for(uint i = 0; i< _coins.length; i++){ \r\n            I_coin coin = I_coin(_coins[i]);\r\n            balances[i] = coin.balanceOf(user);\r\n        }    \r\n        return balances;\r\n    }\r\n  \r\n    function Totalbalance() view public returns (uint) {\r\n\t\treturn Totalbalance(mints);\r\n\t}  \r\n    \r\n    function Totalbalance(address[] _mints) view public returns (uint) {\r\n        require(_mints.length > 0);\r\n        uint balance;\r\n\r\n        //as this is a call() function, we don't really care about gas cost, just dont make the array too large\r\n        for(uint i = 0; i< _mints.length; i++){ \r\n            I_minter coin = I_minter(_mints[i]);\r\n            balance += coin.balance;\r\n        }    \r\n        return balance;\r\n    }\r\n\r\n\tfunction totalStaticoinSupplys() view public returns (uint[]) {\r\n\t\treturn totalSupplys(staticoins);\r\n\t}\r\n\t\r\n\tfunction totalriskcoinsSupplys() view public returns (uint[]) {\r\n\t\treturn totalSupplys(riskcoins);\r\n\t}\r\n\t\r\n    function totalSupplys(address[] _coins) view public returns (uint[]) {\r\n        require(_coins.length > 0);\r\n        uint[] memory totalSupplys = new uint[](_coins.length);\r\n\r\n        for(uint i = 0; i< _coins.length; i++){\r\n            I_coin coin = I_coin(_coins[i]);\r\n            totalSupplys[i] = coin.totalSupply();\r\n        }    \r\n        return totalSupplys;\r\n    }\r\n \r\n    function Leverages() view public returns (uint128[]) {\r\n\t\treturn Leverages(mints);\r\n\t}\r\n \r\n    function Leverages(address[] _mints) view public returns (uint128[]) {\r\n        require(_mints.length > 0);\r\n        uint128[] memory Leverages = new uint128[](_mints.length);\r\n\r\n        for(uint i = 0; i< _mints.length; i++){\r\n            I_minter mint = I_minter(_mints[i]);\r\n            Leverages[i] = mint.Leverage();\r\n        }    \r\n        return Leverages;\r\n    }\r\n\r\n    function Strikes() view public returns (uint128[]) {\r\n\t\treturn Strikes(mints);\r\n\t}\r\n\t\r\n    function Strikes(address[] _mints) view public returns (uint128[]) {\r\n        require(_mints.length > 0);\r\n        uint128[] memory Strikes = new uint128[](_mints.length);\r\n\r\n        for(uint i = 0; i< _mints.length; i++){\r\n            I_minter mint = I_minter(_mints[i]);\r\n            Strikes[i] = mint.Strike();\r\n        }    \r\n        return Strikes;\r\n    }   \r\n    \r\n\tfunction StaticEthAvailables() view public returns (uint128[]) {\r\n\t\treturn StaticEthAvailables(mints);\r\n\t}\r\n\t\r\n    function StaticEthAvailables(address[] _mints) view public returns (uint128[]) {\r\n        require(_mints.length > 0);\r\n        uint128[] memory StaticEthAvailables = new uint128[](_mints.length);\r\n\r\n        for(uint i = 0; i< _mints.length; i++){\r\n            I_minter mint = I_minter(_mints[i]);\r\n            StaticEthAvailables[i] = mint.StaticEthAvailable();\r\n        }    \r\n        return StaticEthAvailables;\r\n    }\r\n\r\n    function PendingETHs() view public returns (uint128[]) {\r\n\t\treturn PendingETHs(mints);\r\n\t}\r\n\t\r\n    function PendingETHs(address[] _mints) view public returns (uint128[]) {\r\n        require(_mints.length > 0);\r\n        uint128[] memory PendingETHs = new uint128[](_mints.length);\r\n\r\n        for(uint i = 0; i< _mints.length; i++){\r\n            I_minter mint = I_minter(_mints[i]);\r\n            PendingETHs[i] = mint.PendingETH();\r\n        }    \r\n        return PendingETHs;\r\n    }\r\n\r\n\tfunction RiskPrices(uint128[] prices) view public returns (uint[]) {\r\n\t\treturn RiskPrices(mints,prices);\r\n\t}\r\n\t\r\n    function RiskPrices(address[] _mints, uint128[] prices) view public returns (uint[]) {\r\n        require(_mints.length > 0);\r\n        require(_mints.length == prices.length);\r\n        uint[] memory RiskPrices = new uint[](_mints.length);\r\n\r\n        for(uint i = 0; i< _mints.length; i++){\r\n            I_minter mint = I_minter(_mints[i]);\r\n            RiskPrices[i] = mint.RiskPrice(prices[i]);\r\n        }    \r\n        return RiskPrices;\r\n    }\r\n \r\n    function TransCompleteds() view public returns (uint[]) {\r\n\t\treturn TransCompleteds(mints);\r\n\t}\r\n\r\n    function TransCompleteds(address[] _mints) view public returns (uint[]) {\r\n        require(_mints.length > 0);\r\n        uint[] memory TransCompleteds = new uint[](_mints.length);\r\n\r\n        for(uint i = 0; i< _mints.length; i++){\r\n            I_minter mint = I_minter(_mints[i]);\r\n            TransCompleteds[i] = mint.TransCompleted();\r\n        }    \r\n        return TransCompleteds;\r\n    }\r\n    \r\n    function queryCost() view public returns (uint[]) {\r\n        return queryCost(pricers);\r\n    }\r\n\r\n    function queryCost(address[] _pricers) view public returns (uint[]) {\r\n        require(_pricers.length > 0);\r\n        uint[] memory queryCosts = new uint[](_pricers.length);\r\n\r\n        for(uint i = 0; i< _pricers.length; i++){\r\n            I_Pricer Pricer = I_Pricer(_pricers[i]);\r\n            queryCosts[i] = Pricer.queryCost();\r\n        }    \r\n        return queryCosts;\r\n    }\r\n    \r\n    function TotalFee() view returns(uint) {\r\n        return TotalFee(pricers);\r\n    }\r\n\r\n\tfunction TotalFee(address[] _pricers) view returns(uint) {\r\n\t\tuint size = (_pricers.length);\r\n\t\tuint fee;\r\n\t\tfor(uint i = 0; i< size; i++){\r\n\t\t\tI_Pricer pricer = I_Pricer(_pricers[i]);\r\n\t\t\tfee += pricer.balance;\r\n\t\t}\r\n\t\treturn fee;\r\n\t}\r\n\r\n\tfunction collectFee() onlyOwner returns(bool) {\r\n\t\treturn collectFee(pricers);\r\n\t}\r\n\t\r\n\tfunction collectFee(address[] _pricers) onlyOwner returns(bool) {\r\n\t\tuint size = (_pricers.length);\r\n\t\tbool ans = true;\r\n\t\tfor(uint i = 0; i< size; i++){\r\n\t\t\tI_Pricer pricer = I_Pricer(_pricers[i]);\r\n\t\t\tans = ans && pricer.collectFee();\r\n\t\t}\r\n\t\treturn ans;\r\n\t}\r\n\r\n    function Summary(address user, uint128[] _prices) view public returns (uint[]){\r\n\t\treturn Summary(user, mints, staticoins, riskcoins, _prices);\r\n\t}\r\n    \r\n    function Summary(address user, address[] _mints, address[] _staticoins, address[] _riskcoins, uint128[] _prices) view public returns (uint[]) {\r\n        uint size = (_mints.length);\r\n\t\trequire(size > 0);\r\n        require(_staticoins.length == size);\r\n        require(_riskcoins.length == size);\r\n        require(_prices.length == size);\r\n        uint step = 11;\r\n        uint[] memory Summarys = new uint[](size*step+1);\r\n        I_Pricer pricer = I_Pricer(pricers[0]);\r\n\t\tSummarys[0] = pricer.queryCost(); //can only pass in 4 arrays to the function.  This now assumes that all pricers have the same query cost\r\n\r\n        for(uint i = 0; i< size; i++){\r\n            I_coin staticoin = I_coin(_staticoins[i]);\r\n            I_coin riskcoin = I_coin(_riskcoins[i]);\r\n            I_minter mint = I_minter(_mints[i]);\r\n            Summarys[i*step+1]  = staticoin.balanceOf(user);\r\n            Summarys[i*step+2]  = riskcoin.balanceOf(user);\r\n            Summarys[i*step+3]  = staticoin.totalSupply();\r\n            Summarys[i*step+4]  = riskcoin.totalSupply();\r\n            Summarys[i*step+5]  = mint.Leverage();\r\n            Summarys[i*step+6]  = mint.Strike();\r\n            Summarys[i*step+7]  = mint.StaticEthAvailable();\r\n            Summarys[i*step+8]  = mint.PendingETH();\r\n            Summarys[i*step+9]  = mint.RiskPrice(_prices[i]);\r\n            Summarys[i*step+10]  = mint.TransCompleted();\r\n            Summarys[i*step+11] = mint.balance;\r\n        }    \r\n        return Summarys;\r\n    }\r\n\t\r\n\tfunction () {\r\n        revert();\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pricers\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pricers\",\"type\":\"address[]\"}],\"name\":\"queryCost\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_mints\",\"type\":\"address[]\"}],\"name\":\"Totalbalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalriskcoinsSupplys\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_mints\",\"type\":\"address[]\"}],\"name\":\"StaticEthAvailables\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"staticoins\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TotalFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalStaticoinSupplys\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"StaticEthAvailables\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mints\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"riskcoins\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Leverages\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PendingETHs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balancesStaticoin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pricers\",\"type\":\"address[]\"}],\"name\":\"collectFee\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_mints\",\"type\":\"address[]\"}],\"name\":\"TransCompleteds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"_prices\",\"type\":\"uint128[]\"}],\"name\":\"Summary\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"prices\",\"type\":\"uint128[]\"}],\"name\":\"RiskPrices\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TransCompleteds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"_mints\",\"type\":\"address[]\"},{\"name\":\"_staticoins\",\"type\":\"address[]\"},{\"name\":\"_riskcoins\",\"type\":\"address[]\"},{\"name\":\"_prices\",\"type\":\"uint128[]\"}],\"name\":\"Summary\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"balancesStaticoin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pricers\",\"type\":\"address[]\"}],\"name\":\"TotalFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_mints\",\"type\":\"address[]\"},{\"name\":\"_staticoins\",\"type\":\"address[]\"},{\"name\":\"_riskcoins\",\"type\":\"address[]\"},{\"name\":\"_pricers\",\"type\":\"address[]\"}],\"name\":\"SetAddresses\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Strikes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"balancesRiskcoins\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balancesRiskcoins\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_mints\",\"type\":\"address[]\"}],\"name\":\"Leverages\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"_coins\",\"type\":\"address[]\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"collectFee\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_mints\",\"type\":\"address[]\"},{\"name\":\"prices\",\"type\":\"uint128[]\"}],\"name\":\"RiskPrices\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_mints\",\"type\":\"address[]\"}],\"name\":\"Strikes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_coins\",\"type\":\"address[]\"}],\"name\":\"totalSupplys\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_mints\",\"type\":\"address[]\"}],\"name\":\"PendingETHs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Totalbalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"queryCost\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"}]","ContractName":"StaticoinSummary","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://f9cbbc0f327608a3323cf1c85e4e4cd15f518707895f9a3427be035a0d408b3a"}]}