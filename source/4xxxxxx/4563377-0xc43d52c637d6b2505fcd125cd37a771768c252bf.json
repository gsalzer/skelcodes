{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.18;\r\n/**\r\n * @title Masterium Token [MTI]\r\n * @author primeRev\r\n * @notice masterium [mti] token contract (tokensale, (cummulated) interest payouts, masternodes\r\n */\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {uint256 c = a * b; assert(a == 0 || c / a == b); return c;}\r\n    //unused:: function div(uint256 a, uint256 b) internal pure returns (uint256) {uint256 c = a / b; return c;}\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {assert(b <= a); return a - b;}\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {uint256 c = a + b; assert(c >= a); return c;}\r\n}\r\n\r\n/**\r\n * @title ReentryProtected\r\n * @dev Mutex based reentry protection\r\n */\r\ncontract ReentryProtected {\r\n    /*\r\n    file:   ReentryProtection.sol (https://github.com/o0ragman0o/ReentryProtected)\r\n    ver:    0.3.0\r\n    updated:6-April-2016\r\n    author: Darryl Morris\r\n    email:  o0ragman0o AT gmail.com\r\n\r\n    Mutex based reentry protection protect.\r\n\r\n    This software is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU lesser General Public License for more details.\r\n    <http://www.gnu.org/licenses/>.\r\n    */\r\n    // The reentry protection state mutex.\r\n    bool __reMutex;\r\n\r\n    // This modifier can be used on functions with external calls to\r\n    // prevent reentry attacks.\r\n    // Constraints:\r\n    //   Protected functions must have only one point of exit.\r\n    //   Protected functions cannot use the `return` keyword\r\n    //   Protected functions return values must be through return parameters.\r\n    modifier preventReentry() {\r\n        require(!__reMutex);\r\n        __reMutex = true;\r\n        _;\r\n        delete __reMutex;\r\n        return;\r\n    }\r\n    /* unused::\r\n    // This modifier can be applied to public access state mutation functions\r\n    // to protect against reentry if a `preventReentry` function has already\r\n    // set the mutex. This prevents the contract from being reenter under a\r\n    // different memory context which can break state variable integrity.\r\n    modifier noReentry() {\r\n        require(!__reMutex);\r\n        _;\r\n    }\r\n    */\r\n}\r\n\r\n/**\r\n * @title Masterium Token [MTI]\r\n * @author primeRev\r\n * @notice masterium [mti] token contract (tokensale, (cummulated) interest payouts, masternodes\r\n * @dev code is heavily commented, feel free to check it\r\n */\r\ncontract MasteriumToken is ReentryProtected  {\r\n    using SafeMath for uint256;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8  public decimals;\r\n    string public version;\r\n\r\n    // used to scale token amounts to 18 decimals\r\n    uint256 internal constant TOKEN_MULTIPLIER = 1e18;\r\n\r\n    address internal contractOwner;\r\n\r\n    // DEBUG\r\n    bool    internal debug = false;\r\n\r\n    // in debugging mode\r\n    uint256 internal constant DEBUG_SALEFACTOR = 1; // 100 -> additional factor for ETH to Token calculation\r\n    uint256 internal constant DEBUG_STARTDELAY = 1 minutes;\r\n    uint256 internal constant DEBUG_INTERVAL   = 1 days;\r\n\r\n    // in production mode\r\n    uint256 internal constant PRODUCTION_SALEFACTOR = 1;           // additional tokensale exchange rate factor Tokens per ETH: production = 1\r\n    uint256 internal constant PRODUCTION_START      = 1511611200;  // tokensale starts at unittimestamp: 1511611200 = 11/25/2017 @ 12:00pm (UTC) (approx. +/-900 sec.)\r\n    uint256 internal constant PRODUCTION_INTERVAL   = 30 days;\r\n\r\n    event DebugValue(string text, uint256 value);\r\n\r\n\r\n\r\n    struct Account {\r\n        uint256 balance;                        // balance including already payed out interest\r\n        uint256 lastPayoutInterval;             // interval-index of last payout\r\n    }\r\n\r\n    mapping(address => Account)                      internal accounts;\r\n    mapping(address => mapping(address => uint256))  public allowed;\r\n\r\n\r\n    uint256 internal _supplyTotal;\r\n    uint256 internal _supplyLastPayoutInterval; // interval of last processed interest payout\r\n\r\n\r\n    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n    // +\r\n    // + interest stuff\r\n    // +\r\n    // + interest is payed out every 30 days (interval)\r\n    // + interest-rate is a function of interval-index % periodicity\r\n    // +\r\n    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n    struct InterestConfig {\r\n        uint256 interval;           // interest is paid every x seconds (default: 30 days)\r\n        uint256 periodicity;        // interest-rate change by time and restart after \"periodicity\"\r\n        uint256 stopAtInterval;     // no more interest after stop-index\r\n        uint256 startAtTimestamp;   // time the interval-index starts increasing\r\n    }\r\n\r\n    InterestConfig internal interestConfig; // set in constructor:: = InterestConfig(30 days,12,48,0);\r\n\r\n    uint256[12] internal interestRates;\r\n    uint256[4]  internal stageFactors;\r\n\r\n\r\n\r\n    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n    // +\r\n    // + masternode stuff\r\n    // +\r\n    // + every token-transaction costs a fee, payed in tokens (0.01)\r\n    // + Masternodes earn the fees\r\n    // + Masternodes get double interest\r\n    // +\r\n    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n    struct StructMasternode {\r\n        uint8   activeMasternodes;              // count of registered MN\r\n        uint256 totalBalanceWei;                // in the contract deposited ether (in wei)\r\n        uint256 rewardPool;                     // only used if no masternode is registered -> all transaction fees will be added to the rewardPool and payed out to the first masternode registering\r\n        uint256 rewardsPayedTotal;              // log all payouts for MN-statistics\r\n\r\n        uint256 miningRewardInTokens;           // masternodes can mine x tokens per interval\r\n        uint256 totalTokensMinedRaw1e18;        // logging: total tokens mined till now\r\n\r\n        uint256 transactionRewardInSubtokensRaw1e18;//fee, subtracted from token sender on every transaction\r\n\r\n        uint256 minBalanceRequiredInTokens;     // to register a masternode -> a balance of 100000 tokens is required\r\n        uint256 minBalanceRequiredInSubtokensRaw1e18;// (*1e18 for internal integer calculations)\r\n\r\n        uint256 minDepositRequiredInEther;      // to register a masternode a deposit in ether is required -> is a function of count: \"activeMasternodes\"\r\n        uint256 minDepositRequiredInWei;        // ... same in wei (for internal use)\r\n        uint8   maxMasternodesAllowed;          // no more than x masternodes allowed, default: 22\r\n    }\r\n\r\n    struct Masternode {\r\n        address addr;           // 160 bit      // wallet-addresses of masternode owner\r\n        uint256 balanceWei;     //  96 bit      // amount ether deposited in the contract\r\n        uint256 sinceInterval;                  // MN created at this interval-index\r\n        uint256 lastMiningInterval;             // last interval a MN mined new coins\r\n    }\r\n\r\n    StructMasternode public masternode; // = StructMasternode(0,0,0,0,100000 ether, 0.01 ether,1,1 ether,22);\r\n    Masternode[22]   public masternodes;\r\n    uint8 internal constant maxMasternodes = 22;\r\n    uint256 internal miningRewardInSubtokensRaw1e18; // (*1e18 for internal integer calculations)\r\n\r\n\r\n    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n    // +\r\n    // + tokensale stuff\r\n    // +\r\n    // + 20 Mio. Tokens created at contract start (admin wallet)\r\n    // + contributers can buy by \"Buy\"-function -> ETH send to adminWallet\r\n    // + contributers can buy by failsave-function -> ETH send to contract, admin can withdraw\r\n    // +\r\n    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n\r\n    struct Structtokensale { // compiler limit: max. 16 vars -> stack too deep\r\n        // 1 token = 1e18 subTokens (smallest token unit, used for internal integer processing)\r\n        uint256 initialTokenSupplyRAW1e18;      // Tokens internal resolution: 1e18 = 1 Ether = 1e18 Wei\r\n        uint256 initialTokenSupplyAmount;\r\n        uint256 initialTokenSupplyFraction;\r\n\r\n        uint256 minPaymentRequiredUnitWei;      // min. payment required for buying tokens, default: 0.0001 ETH\r\n        uint256 maxPaymentAllowedUnitWei;       // limit max. allowed payment per buy to 100 ETH\r\n\r\n        uint256 startAtTimestamp;               // unixtime the tokensale starts\r\n\r\n        bool    tokenSaleClosed;                // set to true by admin (manually) or contract (automatically if max. supply reached) if sale is closed\r\n        bool    tokenSalePaused;                // admin can temp. pause tokensale\r\n\r\n        uint256 totalWeiRaised;                 // by tokensale\r\n        uint256 totalWeiInFallback;       // if someone send ether directly to contract -> admin can withdraw this balance\r\n\r\n        uint256 totalTokensDistributedRAW1e18;\r\n        uint256 totalTokensDistributedAmount;\r\n        uint256 totalTokensDistributedFraction;\r\n    }\r\n\r\n    Structtokensale public tokensale;\r\n    address adminWallet;        // 160 bit\r\n    bool    sendFundsToWallet;  // 1 bit    // default:true -> transfer eth on buy; false -> admin must withdraw\r\n    uint256 internal contractCreationTimestamp;      // (approx.) creation time of contract -> base for interval-index calculation\r\n    uint256[20] tokensaleFactor;\r\n\r\n    /*  // debug only: log all contibuters */\r\n    struct Contributor {\r\n        address addr;\r\n        uint256 amountWei;\r\n        uint256 amountTokensUnit1e18;\r\n        uint256 sinceInterval;\r\n    }\r\n\r\n    Contributor[] public tokensaleContributors; // array of all contributors\r\n    /* */\r\n\r\n\r\n\r\n    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n    // +\r\n    // + contract constructor -> init default values\r\n    // +\r\n    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n    function MasteriumToken() payable public { // constructor\r\n        // contract creation: 3993317\r\n        name     = (debug) ? \"Masterium_Testnet\" : \"Masterium\";\r\n        symbol   = (debug) ? \"MTITestnet1\" : \"MTI\";\r\n        version  = (debug) ? \"1.00.01.Testnet\" : \"1.00.01\";\r\n        decimals = 18; // internal resolution = 1e18 = 1 Wei\r\n\r\n        contractOwner = msg.sender;\r\n\r\n        adminWallet = 0xAb942256b49F0c841D371DC3dFe78beFea447a27;\r\n\r\n        sendFundsToWallet = true;\r\n\r\n        contractCreationTimestamp = _getTimestamp();\r\n\r\n        // tokenSALE: 20 mio tokens created; all to sell;\r\n        tokensale.initialTokenSupplyRAW1e18 = 20000000 * TOKEN_MULTIPLIER; // 20 mio tokens == 20 mio * 10^18 subtokens (smallest unit for internal processing);\r\n        tokensale.initialTokenSupplyAmount  = tokensale.initialTokenSupplyRAW1e18 / TOKEN_MULTIPLIER;\r\n        tokensale.initialTokenSupplyFraction= tokensale.initialTokenSupplyRAW1e18 % TOKEN_MULTIPLIER;\r\n\r\n        // limit buy amount (per transaction) during tokensale to a range from 0.0001 to 100 ether per \"buytokens\"-command.\r\n        tokensale.minPaymentRequiredUnitWei = 0.0001 ether; // translates to 0.0001 * 1e18\r\n        tokensale.maxPaymentAllowedUnitWei  = 100 ether;    // translates to 100.00 * 1e18\r\n\r\n        require(adminWallet != address(0));\r\n        require(tokensale.initialTokenSupplyRAW1e18 > 0);\r\n        require(tokensale.minPaymentRequiredUnitWei > 0);\r\n        require(tokensale.maxPaymentAllowedUnitWei > tokensale.minPaymentRequiredUnitWei);\r\n\r\n        tokensale.tokenSalePaused = false;\r\n        tokensale.tokenSaleClosed = false;\r\n\r\n        tokensale.totalWeiRaised = 0;               // total amount of tokens buyed during tokensale\r\n        tokensale.totalWeiInFallback = 0;     // the faction of total amount which was done by failsafe = direct ether send to contract\r\n\r\n        tokensale.totalTokensDistributedRAW1e18 = 0;\r\n        tokensale.totalTokensDistributedAmount  = 0;\r\n        tokensale.totalTokensDistributedFraction= 0;\r\n\r\n        tokensale.startAtTimestamp = (debug) ? contractCreationTimestamp + _addTime(DEBUG_STARTDELAY) : PRODUCTION_START;// tokensale starts at x\r\n\r\n        tokensaleFactor[0] = 2000;\r\n        tokensaleFactor[1] = 1000;\r\n        tokensaleFactor[2] = 800;\r\n        tokensaleFactor[3] = 500;\r\n        tokensaleFactor[4] = 500;\r\n        tokensaleFactor[5] = 500;\r\n        tokensaleFactor[6] = 500;\r\n        tokensaleFactor[7] = 500;\r\n        tokensaleFactor[8] = 500;\r\n        tokensaleFactor[9] = 400;\r\n        tokensaleFactor[10] = 400;\r\n        tokensaleFactor[11] = 400;\r\n        tokensaleFactor[12] = 200;\r\n        tokensaleFactor[13] = 200;\r\n        tokensaleFactor[14] = 200;\r\n        tokensaleFactor[15] = 400;\r\n        tokensaleFactor[16] = 500;\r\n        tokensaleFactor[17] = 800;\r\n        tokensaleFactor[18] = 1000;\r\n        tokensaleFactor[19] = 2500;\r\n\r\n        _supplyTotal = tokensale.initialTokenSupplyRAW1e18;\r\n        _supplyLastPayoutInterval = 0;                                // interval (index) of last processed interest-payout (initiated by a gas operation)\r\n\r\n        accounts[contractOwner].balance = tokensale.initialTokenSupplyRAW1e18;\r\n        accounts[contractOwner].lastPayoutInterval = 0;\r\n        //accounts[contractOwner].lastAction = contractCreationTimestamp;\r\n\r\n        // MASTERNODE: masternodes earn all transaction fees from balance transfers and can mine new tokens\r\n        masternode.transactionRewardInSubtokensRaw1e18 = 0.01 * (1 ether); // 0.01 * 1e18 subtokens = 0.01 token\r\n\r\n        masternode.miningRewardInTokens = 50000; // 50'000 tokens to mine per masternode per interval\r\n        miningRewardInSubtokensRaw1e18 = masternode.miningRewardInTokens * TOKEN_MULTIPLIER; // used for internal integer calculation\r\n\r\n        masternode.totalTokensMinedRaw1e18 = 0; // logs the amount of tokens mined by masternodes\r\n\r\n        masternode.minBalanceRequiredInTokens = 100000; //to register a masternode -> a balance of 100000 tokens is required\r\n        masternode.minBalanceRequiredInSubtokensRaw1e18 = masternode.minBalanceRequiredInTokens * TOKEN_MULTIPLIER; // used for internal integer calculation\r\n\r\n        masternode.maxMasternodesAllowed = uint8(maxMasternodes);\r\n        masternode.activeMasternodes= 0;\r\n        masternode.totalBalanceWei  = 0;\r\n        masternode.rewardPool       = 0;\r\n        masternode.rewardsPayedTotal= 0;\r\n\r\n        masternode.minDepositRequiredInEther= requiredBalanceForMasternodeInEther();// to register a masternode -> a deposit of ether is required (a function of numMasternodes)\r\n        masternode.minDepositRequiredInWei  = requiredBalanceForMasternodeInWei(); // used for internal integer calculation\r\n\r\n\r\n        // INTEREST: every tokenholder earn interest (% of balance) at a fixed interval (once per 30 days)\r\n        interestConfig.interval = _addTime( (debug) ? DEBUG_INTERVAL : PRODUCTION_INTERVAL ); // interest payout interval in seconds, default: every 30 days\r\n        interestConfig.periodicity      = 12;    // interestIntervalCapped = intervalIDX % periodicity\r\n        interestConfig.stopAtInterval   = 4 * interestConfig.periodicity;  // stop paying interest after x intervals (performance reasons)\r\n        interestConfig.startAtTimestamp = tokensale.startAtTimestamp; // first payout is after one interval\r\n\r\n        // interest is reduced every 30 days and reset to 1st every stage (after 12 intervals)\r\n        interestRates[ 0] = 1000000000000; // interval 1 = 100%\r\n        interestRates[ 1] =  800000000000; // 80%\r\n        interestRates[ 2] =  600000000000;\r\n        interestRates[ 3] =  400000000000;\r\n        interestRates[ 4] =  200000000000;\r\n        interestRates[ 5] =  100000000000;\r\n        interestRates[ 6] =   50000000000;\r\n        interestRates[ 7] =   50000000000;\r\n        interestRates[ 8] =   30000000000;\r\n        interestRates[ 9] =   40000000000;\r\n        interestRates[10] =   20000000000;\r\n        interestRates[11] =   10000000000; //   1%\r\n\r\n        // interestRates are reduced by factor every 12 intervals = 1 stage\r\n        stageFactors[0] =  1000000000000; // interval  1..12 = factor 1\r\n        stageFactors[1] =  4000000000000; // interval 13..24 = factor 4\r\n        stageFactors[2] =  8000000000000;\r\n        stageFactors[3] = 16000000000000;\r\n    }\r\n\r\n\r\n\r\n\r\n    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n    // +\r\n    // + ERC20 stuff\r\n    // +\r\n    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    //event InterestPayed(address indexed owner, uint256 interestPayed);\r\n\r\n    // erc20: tramsferFrom:: Allow _spender to withdraw from your account, multiple times, up to the _value amount.\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n        allowed[msg.sender][_spender] = _value;\r\n\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    // erc20: tramsferFrom:: Returns the amount which _spender is still allowed to withdraw from _owner\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    // erc20: tramsferFrom\r\n    function increaseApproval (address _spender, uint256 _addedValue) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    // erc20: tramsferFrom\r\n    function decreaseApproval (address _spender, uint256 _subtractedValue) public returns (bool success) {\r\n        uint256 oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    // erc20: public (command): token transfer by owner to someone\r\n    // attn: total = _value + transactionFee !!! -> account-balance >= _value + transactionFee\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        _setBalances(msg.sender, _to, _value); // will fail if not enough balance\r\n        _sendFeesToMasternodes(masternode.transactionRewardInSubtokensRaw1e18);\r\n\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    // erc20: public (command): Send _value amount of tokens from address _from to address _to\r\n    // attn: total = _value + transactionFee !!! -> account-balance >= _value + transactionFee\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        var _allowance = allowed[_from][msg.sender];\r\n        allowed[_from][msg.sender] = _allowance.sub(_value); // will fail if no (not enough) allowance\r\n        _setBalances(_from, _to, _value);  // will fail if not enough balance\r\n        _sendFeesToMasternodes(masternode.transactionRewardInSubtokensRaw1e18);\r\n\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    // erc20: public (read only)\r\n    function totalSupply() public constant returns (uint256 /*totalSupply*/) {\r\n        return _calcBalance(_supplyTotal, _supplyLastPayoutInterval, intervalNow());\r\n    }\r\n\r\n    // erc20\r\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n        return _calcBalance(accounts[_owner].balance, accounts[_owner].lastPayoutInterval, intervalNow());\r\n    }\r\n\r\n    // public (read only): just to look pretty -> split 1e18 reolution to mainunits and the fraction part, just for direct enduser lookylooky at contract variables\r\n    function totalSupplyPretty() public constant returns (uint256 tokens, uint256 fraction) {\r\n        uint256 _raw = totalSupply();\r\n        tokens  = _raw / TOKEN_MULTIPLIER;\r\n        fraction= _raw % TOKEN_MULTIPLIER;\r\n    }\r\n\r\n    // public (read only): just to look pretty -> split 1e18 reolution to mainunits and the fraction part, just for direct enduser lookylooky at contract variables\r\n    function balanceOfPretty(address _owner) public constant returns (uint256 tokens, uint256 fraction) {\r\n        uint256 _raw = balanceOf(_owner);\r\n        tokens  = _raw / TOKEN_MULTIPLIER;\r\n        fraction= _raw % TOKEN_MULTIPLIER;\r\n    }\r\n\r\n\r\n    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n    // +\r\n    // + Interest stuff\r\n    // +\r\n    // + every token holder receives interest (based on token balance) at fixed intervals (by default: 30 days)\r\n    // +\r\n    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n\r\n    // public (read only): stage = how many interval cycles completed; increase every 12 intervals by 1; 1 stage = approx. 1 year\r\n    // stage is unsed in interest calculation -> yearly factor\r\n    // unnecessary -> just for enduser lookylooky\r\n    function stageNow() public constant returns (uint256) {\r\n        return intervalNow() / interestConfig.periodicity;\r\n    }\r\n\r\n    // public (read only): interval = index of the active interest interval. first interval = 0; increase every 30 days by 1; 1 interval = approx 1 month\r\n    // interval is used for interest payouts and validating masternode mining interval\r\n    function intervalNow() public constant returns (uint256) {\r\n        uint256 timestamp = _getTimestamp();\r\n        return (timestamp < interestConfig.startAtTimestamp) ? 0 : (timestamp - interestConfig.startAtTimestamp) / interestConfig.interval;\r\n    }\r\n\r\n    // public (read only): unixtime to next interest payout\r\n    // unnecessary -> just for enduser lookylooky\r\n    function secToNextInterestPayout() public constant returns (uint256) {\r\n        if (intervalNow() > interestConfig.stopAtInterval) return 0; // no interest after x intervals\r\n        //shortcutted to return:\r\n        //uint256 timestamp = _getTimestamp();\r\n        //uint256 intNow = intervalNow();\r\n        //uint256 nextPayoutTimestamp = interestConfig.startAtTimestamp + (intNow +1)* interestConfig.interval;\r\n        //return nextPayoutTimestamp - timestamp;\r\n        return (interestConfig.startAtTimestamp + (intervalNow() + 1) * interestConfig.interval) - _getTimestamp();\r\n    }\r\n\r\n    // public (read only): next interest payout rate in percent\r\n    // unnecessary -> just for enduser lookylooky\r\n    function interestNextInPercent() public constant returns (uint256 mainUnit, uint256 fraction) {\r\n        uint256 _now = intervalNow();\r\n        uint256 _raw = _calcBalance(100 * TOKEN_MULTIPLIER, _now, _now+1);\r\n        mainUnit = (_raw - 100 * TOKEN_MULTIPLIER) / TOKEN_MULTIPLIER;\r\n        fraction = (_raw - 100 * TOKEN_MULTIPLIER) % TOKEN_MULTIPLIER;\r\n        return;\r\n    }\r\n\r\n    // internal (gas operation): triggered before any (gas costy operation) balance transaction -> account interest to balance of address\r\n    // its for performance reasons: use a gas operation to add new (cumulated) interest to account-balance to reduce interest-calc-loop (balanceOf)\r\n    function _requestInterestPayoutToTotalSupply() internal {\r\n        // payout interest to balance and set new payout index\r\n        uint256 oldbal = _supplyTotal;   // read last known balance == balance at timeindex: \"_supplyLastPayoutInterval\"\r\n        uint256 newbal = totalSupply();                                 // do interest calculation loop from \"lastPayoutInterval\" to now\r\n        if (oldbal < newbal) {  // if balance changed because of new interest ...\r\n            _supplyTotal = newbal;\r\n        }\r\n        // set new lastPayoutInterval for use in calculation loop\r\n        _supplyLastPayoutInterval = intervalNow(); // interest already payed out to _supplyTotal until this index (now)\r\n    }\r\n\r\n    // internal (gas operation): triggered before any (gas costy operation) balance transaction -> account interest to balance of address\r\n    // its for performance reasons: use a gas operation to add new (cumulated) interest to account-balance to reduce interest-calc-loop (balanceOf)\r\n    function _requestInterestPayoutToAccountBalance(address _owner) internal {\r\n        // payout interest to balance and set new payout index\r\n        uint256 oldbal = accounts[_owner].balance;  // read last known balance == balance at timeindex: \"accounts[_owner].lastPayoutInterval\"\r\n        uint256 newbal = balanceOf(_owner);         // do interest calculation loop from \"lastPayoutInterval\" to now\r\n        if (oldbal < newbal) {  // if balance changed because of new interest ...\r\n            accounts[_owner].balance = newbal;\r\n\r\n            //no need for logging this:: InterestPayed(_owner, newbal - oldbal);\r\n        }\r\n        // set new lastPayoutInterval for use in calculation loop\r\n        accounts[_owner].lastPayoutInterval = intervalNow(); // interest already payed out to [owner].balance until this index (now)\r\n    }\r\n\r\n    // internal (gas operation): triggered by a transation-function -> pay interest to both addr; subtract transaction fee; do token-transfer\r\n    // every call triggers the interest payout loop and adds the new balance internaly -> next loop can save cpu-cycles\r\n    function _setBalances(address _from, address _to, uint256 _value) internal {\r\n        require(_from != _to);\r\n        require(_value > 0);\r\n\r\n        // set new balance (and new \"last payout index\") including interest for both parties before transfer\r\n        _requestInterestPayoutToAccountBalance(_from);   // set new balance including interest\r\n        _requestInterestPayoutToAccountBalance(_to);     // set new balance including interest\r\n        _requestInterestPayoutToTotalSupply();\r\n\r\n        // there must be enough balance for transfer AND transaction-fee\r\n        require(_value.add(masternode.transactionRewardInSubtokensRaw1e18) <= accounts[_from].balance);\r\n\r\n        // if sender is a masternode: freeze 100k of tokens balance -> to release the balance it is required to deregister the masternode first\r\n        if (masternodeIsValid(_from)) {\r\n            require(accounts[_from].balance >= masternode.minBalanceRequiredInSubtokensRaw1e18.add(_value)); // masternodes: 100k balance is freezed\r\n        }\r\n\r\n        // SafeMath.sub will throw if there is not enough balance.\r\n        accounts[_from].balance = accounts[_from].balance.sub(_value).sub(masternode.transactionRewardInSubtokensRaw1e18);\r\n        accounts[_to].balance   = accounts[_to].balance.add(_value);\r\n    }\r\n\r\n    // internal (no gas): calc interest as a function of interval-index (loop from-interval to to-interval)\r\n    function _calcBalance(uint256 _balance, uint256 _from, uint256 _to) internal constant returns (uint256) {\r\n        // attn.: significant integer capping for balances < 1e-16 -> acceptable limitation\r\n        uint256 _newbalance = _balance;\r\n        if (_to > interestConfig.stopAtInterval) _to = interestConfig.stopAtInterval; // no (more) interest after x intervals (default: 48)\r\n        if (_from < _to) { // interest index since last payout (storage operation in transfers) -> calc new balance\r\n            for (uint256 idx = _from; idx < _to; idx++) { // loop over unpayed intervals (since last payout-operation till now)\r\n                if (idx > 48) break; // hardcap: just for ... you know\r\n\r\n                _newbalance += (_newbalance * interestRates[idx % interestConfig.periodicity]) / stageFactors[(idx / interestConfig.periodicity) % 4];\r\n            }\r\n            if (_newbalance < _balance) { _newbalance = _balance; } // failsave if some math goes wrong (overflow). who knows...\r\n        }\r\n        return _newbalance;\r\n        /*  interest by time (1 interval == 30 days)\r\n            stagefactor\tinterval\tinterest\t total supply\t sum %\r\n            1           0             0.0000%    20'000'000.00   100.00%\r\n            after 30 days\r\n            1\t        1\t        100.0000%    40'000'000.00\t 200.00%\r\n            1\t        2\t         80.0000%\t 72'000'000.00\t 360.00%\r\n            1\t        3\t         60.0000%\t115'200'000.00\t 576.00%\r\n            1\t        4\t         40.0000%\t161'280'000.00\t 806.40%\r\n            1\t        5\t         20.0000%\t193'536'000.00\t 967.68%\r\n            1\t        6\t         10.0000%\t212'889'600.00\t1064.45%\r\n            1\t        7\t          5.0000%\t223'534'080.00\t1117.67%\r\n            1\t        8\t          5.0000%\t234'710'784.00\t1173.55%\r\n            1\t        9\t          3.0000%\t241'752'107.52\t1208.76%\r\n            1\t        10\t          3.0000%\t249'004'670.75\t1245.02%\r\n            1\t        11\t          2.0000%\t253'984'764.16\t1269.92%\r\n            1\t        12\t          1.0000%\t256'524'611.80\t1282.62%\r\n            after 1 year: 1282.62% pa in year 1\r\n            4\t        13\t         25.0000%\t320'655'764.75\t1603.28%\r\n            4\t        14\t         20.0000%\t384'786'917.70\t1923.93%\r\n            4\t        15\t         15.0000%\t442'504'955.36\t2212.52%\r\n            4\t        16\t         10.0000%\t486'755'450.89\t2433.78%\r\n            4\t        17\t          5.0000%\t511'093'223.44\t2555.47%\r\n            4\t        18\t          2.5000%\t523'870'554.03\t2619.35%\r\n            4\t        19\t          1.2500%\t530'418'935.95\t2652.09%\r\n            4\t        20\t          1.2500%\t537'049'172.65\t2685.25%\r\n            4\t        21\t          0.7500%\t541'077'041.44\t2705.39%\r\n            4\t        22\t          0.7500%\t545'135'119.26\t2725.68%\r\n            4\t        23\t          0.5000%\t547'860'794.85\t2739.30%\r\n            4\t        24\t          0.2500%\t549'230'446.84\t2746.15%\r\n            after 2 years: 214.10% pa in year 2\r\n            8\t        25\t         12.5000%\t617'884'252.69\t3089.42%\r\n            8\t        26\t         10.0000%\t679'672'677.96\t3398.36%\r\n            8\t        27\t          7.5000%\t730'648'128.81\t3653.24%\r\n            8\t        28\t          5.0000%\t767'180'535.25\t3835.90%\r\n            8\t        29\t          2.5000%\t786'360'048.63\t3931.80%\r\n            8\t        30\t          1.2500%\t796'189'549.24\t3980.95%\r\n            8\t        31\t          0.6250%\t801'165'733.92\t4005.83%\r\n            8\t        32\t          0.6250%\t806'173'019.76\t4030.87%\r\n            8\t        33\t          0.3750%\t809'196'168.58\t4045.98%\r\n            8\t        34\t          0.3750%\t812'230'654.22\t4061.15%\r\n            8\t        35\t          0.2500%\t814'261'230.85\t4071.31%\r\n            8\t        36\t          0.1250%\t815'279'057.39\t4076.40%\r\n            after 3 years: 148.44% pa in year 3\r\n            16\t        37\t          6.2500%\t866'233'998.48\t4331.17%\r\n            16\t        38\t          5.0000%\t909'545'698.40\t4547.73%\r\n            16\t        39\t          3.7500%\t943'653'662.09\t4718.27%\r\n            16\t        40\t          2.5000%\t967'245'003.64\t4836.23%\r\n            16\t        41\t          1.2500%\t979'335'566.19\t4896.68%\r\n            16\t        42\t          0.6250%\t985'456'413.48\t4927.28%\r\n            16\t        43\t          0.3125%\t988'535'964.77\t4942.68%\r\n            16\t        44\t          0.3125%\t991'625'139.66\t4958.13%\r\n            16\t        45\t          0.1875%\t993'484'436.80\t4967.42%\r\n            16\t        46\t          0.1875%\t995'347'220.12\t4976.74%\r\n            16\t        47\t          0.1250%\t996'591'404.14\t4982.96%\r\n            16\t        48\t          0.0625%\t997'214'273.77\t4986.07%\r\n            after 4 years: 122.32% pa in year 4\r\n            16\t        49 .. inf     0.0000%\t997'214'273.77\t4986.07%\r\n        */\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n    // +\r\n    // + Masternode stuff\r\n    // +\r\n    // + every registered masternodes receives a part of the transaction fee\r\n    // + every masternode can mine 50´000 once every interval (30 days)\r\n    // +\r\n    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n    event MasternodeRegistered(address indexed addr, uint256 amount);\r\n    event MasternodeDeregistered(address indexed addr, uint256 amount);\r\n    event MasternodeMinedTokens(address indexed addr, uint256 amount);\r\n    event MasternodeTransferred(address fromAddr, address toAddr);\r\n    event MasternodeRewardSend(uint256 amount);\r\n    event MasternodeRewardAddedToRewardPool(uint256 amount);\r\n    event MaxMasternodesAllowedChanged(uint8 newNumMaxMasternodesAllowed);\r\n    event TransactionFeeChanged(uint256 newTransactionFee);\r\n    event MinerRewardChanged(uint256 newMinerReward);\r\n\r\n    // public (read only): unixtime to next interest payout\r\n    // unnecessary -> just for enduser lookylooky\r\n    function secToNextMiningInterval() public constant returns (uint256) {\r\n        return secToNextInterestPayout();\r\n    }\r\n\r\n    // internal (read only):\r\n    // unnecessary -> just for enduser lookylooky\r\n    function requiredBalanceForMasternodeInEther() constant internal returns (uint256) {\r\n        // 1st masternode = 1 ether required to deposit in contract\r\n        // 2nd masternode = 4 ether\r\n        // 3rd masternode = 9 ether\r\n        // 4th masternode = 16 ether\r\n        // 5th masternode = 25 ether\r\n        // 6th masternode = 36 ether\r\n        // 22th           = 484 ether\r\n        return (masternode.activeMasternodes + 1) ** 2;\r\n    }\r\n\r\n    // internal (read only): used in masternodeRegister and Deregister\r\n    function requiredBalanceForMasternodeInWei() constant internal returns (uint256) {\r\n        return (1 ether) * (masternode.activeMasternodes + 1) ** 2;\r\n    }\r\n\r\n    // public (command): send ETH (requiredBalanceForMasternodeInEther) to contract to become a masternode\r\n    function masternodeRegister() payable public {\r\n        // gas: 104'000 / max: 140k\r\n        require(msg.sender != address(0));\r\n        require(masternode.activeMasternodes < masternode.maxMasternodesAllowed);       // max. masternodes allowed\r\n        require(msg.value == requiredBalanceForMasternodeInWei() );                     // eth deposit\r\n        require(_getMasternodeSlot(msg.sender) >= maxMasternodes);                      // only one masternode per address\r\n\r\n        _requestInterestPayoutToTotalSupply();\r\n        _requestInterestPayoutToAccountBalance(msg.sender); // do interest payout before checking balance\r\n        require(accounts[msg.sender].balance >= masternode.minBalanceRequiredInSubtokensRaw1e18); // required token balance of 100k at addr to register a masternode\r\n        //was: require(balanceOf(msg.sender) >= masternode.minBalanceRequiredInSubtokensRaw1e18); // required token balance of 100k at addr to register a masternode\r\n\r\n        uint8 slot = _findEmptyMasternodeSlot();\r\n        require(slot < maxMasternodes); // should never trigger\r\n\r\n        masternodes[slot].addr = msg.sender;\r\n        masternodes[slot].balanceWei = msg.value;\r\n        masternodes[slot].sinceInterval = intervalNow();\r\n        masternodes[slot].lastMiningInterval = intervalNow();\r\n\r\n        masternode.activeMasternodes++;\r\n\r\n        masternode.minDepositRequiredInEther= requiredBalanceForMasternodeInEther(); // attn: first inc activeMN\r\n        masternode.minDepositRequiredInWei  = requiredBalanceForMasternodeInWei(); // attn: first inc activeMN\r\n\r\n        masternode.totalBalanceWei = masternode.totalBalanceWei.add(msg.value);    // this balance could never be withdrawn by contract admin\r\n\r\n        MasternodeRegistered(msg.sender, msg.value);\r\n    }\r\n\r\n    // public (command): close masternode and send deposited ETH back to owner\r\n    function masternodeDeregister() public preventReentry returns (bool _success) {\r\n        require(msg.sender != address(0));\r\n        require(masternode.activeMasternodes > 0);\r\n        require(masternode.totalBalanceWei > 0);\r\n        require(this.balance >= masternode.totalBalanceWei + tokensale.totalWeiInFallback);\r\n\r\n        uint8 slot = _getMasternodeSlot(msg.sender);\r\n        require(slot < maxMasternodes); // masternode found in list?\r\n\r\n        uint256 balanceWei = masternodes[slot].balanceWei;\r\n        require(masternode.totalBalanceWei >= balanceWei);\r\n\r\n        _requestInterestPayoutToTotalSupply();\r\n        _requestInterestPayoutToAccountBalance(msg.sender); // do interest payout before checking balance\r\n\r\n        masternodes[slot].addr = address(0);\r\n        masternodes[slot].balanceWei = 0;\r\n        masternodes[slot].sinceInterval = 0;\r\n        masternodes[slot].lastMiningInterval = 0;\r\n\r\n        masternode.totalBalanceWei = masternode.totalBalanceWei.sub(balanceWei);\r\n\r\n        masternode.activeMasternodes--;\r\n\r\n        masternode.minDepositRequiredInEther = requiredBalanceForMasternodeInEther(); // attn: first dec activeMN\r\n        masternode.minDepositRequiredInWei   = requiredBalanceForMasternodeInWei(); // attn: first dec activeMN\r\n\r\n        //if (!addr.send(balanceWei)) revert(); // send back ether to wallet of sender\r\n        msg.sender.transfer(balanceWei); // send back ether to wallet of sender\r\n\r\n        MasternodeDeregistered(msg.sender, balanceWei);\r\n        _success = true;\r\n        }\r\n\r\n    // public (command): close masternode and send deposited ETH back to owner\r\n    function masternodeMineTokens() public {\r\n        // gas: up to 105000\r\n        require(msg.sender != address(0));\r\n        require(masternode.activeMasternodes > 0);\r\n\r\n        uint256 _inow = intervalNow();\r\n        require(_inow <= interestConfig.stopAtInterval); // mining stops after approx. 4 years (48 intervals by 30 days)\r\n\r\n        uint8 slot = _getMasternodeSlot(msg.sender);\r\n        require(slot < maxMasternodes); // masternode found in list?\r\n        require(masternodes[slot].lastMiningInterval < _inow); // masternode did not already mine this interval?\r\n\r\n        _requestInterestPayoutToTotalSupply();\r\n        _requestInterestPayoutToAccountBalance(msg.sender);   // set new balance including interest\r\n        require(accounts[msg.sender].balance >= masternode.minBalanceRequiredInSubtokensRaw1e18); // required token balance at addr to register a masternode\r\n        //was: require(balanceOf(msg.sender) >= masternode.minBalanceRequiredInSubtokensRaw1e18); // required token balance of 100k at addr to register a masternode\r\n\r\n        masternodes[slot].lastMiningInterval = _inow;\r\n\r\n        uint256 _minedTokens = miningRewardInSubtokensRaw1e18;\r\n\r\n        // SafeMath.sub will throw if there is not enough balance.\r\n        accounts[msg.sender].balance = accounts[msg.sender].balance.add(_minedTokens);\r\n\r\n        // attn.: _requestInterestPayoutToTotalSupply() must be called first to set lastPayoutInterval correctly\r\n        _supplyTotal = _supplyTotal.add(_minedTokens);\r\n        //_supplyMined = _supplyMined.add(_minedTokens);\r\n\r\n        masternode.totalTokensMinedRaw1e18 = masternode.totalTokensMinedRaw1e18.add(_minedTokens);\r\n\r\n        MasternodeMinedTokens(msg.sender, _minedTokens);\r\n    }\r\n\r\n    // public (command): owner of a masternode can transfer the mn (and the value in ETH) to another wallet address\r\n    function masternodeTransferOwnership(address newAddr) public {\r\n        require(masternode.activeMasternodes > 0);\r\n        require(msg.sender != address(0));\r\n        require(newAddr != address(0));\r\n        require(newAddr != msg.sender);\r\n\r\n        uint8 slot = _getMasternodeSlot(msg.sender);\r\n        require(slot < maxMasternodes); // masternode found in list? only the owner of a masternode can transfer a masternode to a new address\r\n\r\n        _requestInterestPayoutToTotalSupply();\r\n        _requestInterestPayoutToAccountBalance(msg.sender); // do interest payout before moving masternode\r\n        _requestInterestPayoutToAccountBalance(newAddr); // do interest payout before moving masternode\r\n        require(accounts[newAddr].balance >= masternode.minBalanceRequiredInSubtokensRaw1e18); // required token balance at addr to register a masternode\r\n        //was: require(balanceOf(newAddr) >= masternode.minBalanceRequiredInSubtokensRaw1e18); // required token balance at addr to register a masternode\r\n\r\n        masternodes[slot].addr = newAddr;\r\n\r\n        MasternodeTransferred(msg.sender, newAddr);\r\n    }\r\n\r\n    // public (read only): check if addr is a masternode\r\n    function masternodeIsValid(address addr) public constant returns (bool) {\r\n        return (_getMasternodeSlot(addr) < maxMasternodes) && (balanceOf(addr) >= masternode.minBalanceRequiredInSubtokensRaw1e18);\r\n    }\r\n\r\n    // internal (read only):\r\n    function _getMasternodeSlot(address addr) internal constant returns (uint8) {\r\n        uint8 idx = maxMasternodes; // masternode.maxMasternodesAllowed;\r\n        for (uint8 i = 0; i < maxMasternodes; i++) {\r\n            if (masternodes[i].addr == addr) { // if sender is a registered masternode\r\n                idx = i;\r\n                break;\r\n            }\r\n        }\r\n        return idx; // if idx == maxMasternodes (22) -> no entry found; valid masternode slots: 0 .. 21\r\n    }\r\n\r\n    // internal (read only): faster than push / pop operations on arrays\r\n    function _findEmptyMasternodeSlot() internal constant returns (uint8) {\r\n        uint8 idx = maxMasternodes; // masternode.maxMasternodesAllowed;\r\n\r\n        if (masternode.activeMasternodes < maxMasternodes)\r\n        for (uint8 i = 0; i < maxMasternodes; i++) {\r\n            if (masternodes[i].addr == address(0) && masternodes[i].sinceInterval == 0) { // if slot empty\r\n                idx = i;\r\n                break;\r\n            }\r\n        }\r\n        return idx; // if idx == maxMasternodes -> no entry found\r\n    }\r\n\r\n    // internal (command):\r\n    function _sendFeesToMasternodes(uint256 _fee) internal {\r\n        uint256 _pool = masternode.rewardPool;\r\n        if (_fee + _pool > 0 && masternode.activeMasternodes > 0) { // if min. 1 masternode exists\r\n            masternode.rewardPool = 0;\r\n            uint256 part = (_fee + _pool) / masternode.activeMasternodes;\r\n            uint256 sum = 0;\r\n            address addr;\r\n            for (uint8 i = 0; i < maxMasternodes; i++) {\r\n                addr = masternodes[i].addr;\r\n                if (addr != address(0)) {\r\n                    accounts[addr].balance = (accounts[addr].balance).add(part); // send fee as reward\r\n                    sum += part;\r\n                }\r\n            }\r\n            if (sum < part) masternode.rewardPool = part - sum; // do not loose integer-div-roundings\r\n            masternode.rewardsPayedTotal += sum;\r\n            MasternodeRewardSend(sum);\r\n        } else { // no masternodes -> collect fees for the first masternode registering\r\n            masternode.rewardPool = masternode.rewardPool.add(_fee);\r\n            MasternodeRewardAddedToRewardPool(_fee);\r\n        }\r\n    }\r\n\r\n\r\n\r\n    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n    // +\r\n    // + tokensale stuff\r\n    // +\r\n    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n    event TokensPurchased(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\r\n    event TokenSaleFinished();\r\n    event TokenSaleClosed();\r\n    event TokenSaleOpened();\r\n    event TokenSalePaused(bool paused);\r\n\r\n    // public (command): fallback function - can be used to buy tokens (attn.: can fail silently if not enough gas is provided)\r\n    /* deactivated for user-safety */\r\n    function () payable public {\r\n        // gas used: 170000 to 251371 gaslimit: provide 500000 or more!!!\r\n        _buyTokens(msg.sender, true); // triggers failsafe -> no direct transfer to contract-owner wallet to safe gas\r\n    }\r\n    /* */\r\n    \r\n    // public (command): official function to buy tokens during tokensale\r\n    function tokensaleBuyTokens() payable public {\r\n        _buyTokens(msg.sender, false); // direct transfer to contract-owner\r\n    }\r\n\r\n    // public (read only): calc the active sale stage as a function of already selled amount\r\n    function tokensaleStageNow() public constant returns (uint256) {\r\n        return tokensaleStageAt(tokensale.totalTokensDistributedRAW1e18);\r\n    }\r\n\r\n    // public (read only): calc the active sale stage as a function of any amount\r\n    function tokensaleStageAt(uint256 _tokensdistibutedRAW1e18) public pure returns (uint256) {\r\n        return _tokensdistibutedRAW1e18 / (1000000 * TOKEN_MULTIPLIER);\r\n    }\r\n\r\n    // public (read only): calc the active exchange factor (tokens per ETH) as a function of already selled amount\r\n    function tokensaleTokensPerEtherNow() public constant returns (uint256) {\r\n        return _tokensaleTokensPerEther(tokensale.totalTokensDistributedRAW1e18);\r\n    }\r\n\r\n    /*\r\n    // public (read only): calc the active exchange factor (tokens per ETH) as a function of any amount\r\n    function tokensaleTokensPerEtherAtAmount(uint256 _tokensdistibutedRAW1e18) public constant returns (uint256) {\r\n        return _tokensaleTokensPerEther(_tokensdistibutedRAW1e18);\r\n    }\r\n    */\r\n    /*\r\n    // public (read only): calc the active exchange factor (tokens per ETH) as a function of any stage\r\n    function tokensaleTokensPerEtherAtStage(uint256 _stage) public constant returns (uint256) {\r\n        return _tokensaleTokensPerEther(_stage * 1000000 * TOKEN_MULTIPLIER);\r\n    }\r\n    */\r\n\r\n    // internal (read only): calculate current exchange rate -> ether payed * factor = tokens distributed\r\n    function _tokensaleTokensPerEther(uint256 _tokensdistibuted) internal constant returns (uint256) {\r\n        uint256 factor = tokensaleFactor[tokensaleStageAt(_tokensdistibuted) % 20]; // % 20 == prevent array overflow on unexpected error\r\n        return factor * ( (debug) ? DEBUG_SALEFACTOR : PRODUCTION_SALEFACTOR ); // debug only stuff\r\n\r\n        // total tokens: 20 Mio\r\n        // total ETH to buy all tokens: approx. 44400 ETH (444 in debug mode)\r\n        /*\r\n        stage tokens   tokens     ether     1 token      usd per stage                  1 token\r\n            per stage per ether\tper stage\tin ether\t (300 usd/ETH)\tsum usd\t        in usd\r\n        1\t1'000'000\t2'000\t  500.00\t0.00050000\t  150'000.00\t  150'000.00\t0.1500\r\n        2\t1'000'000\t1'000\t1'000.00\t0.00100000\t  300'000.00\t  450'000.00\t0.3000\r\n        3\t1'000'000\t  800\t1'250.00\t0.00125000\t  375'000.00\t  825'000.00\t0.3750\r\n        4\t1'000'000\t  500\t2'000.00\t0.00200000\t  600'000.00\t1'425'000.00\t0.6000\r\n        5\t1'000'000\t  500\t2'000.00\t0.00200000\t  600'000.00\t2'025'000.00\t0.6000\r\n        6\t1'000'000\t  500\t2'000.00\t0.00200000\t  600'000.00\t2'625'000.00\t0.6000\r\n        7\t1'000'000\t  500\t2'000.00\t0.00200000\t  600'000.00\t3'225'000.00\t0.6000\r\n        8\t1'000'000\t  500\t2'000.00\t0.00200000\t  600'000.00\t3'825'000.00\t0.6000\r\n        9\t1'000'000\t  500\t2'000.00\t0.00200000\t  600'000.00\t4'425'000.00\t0.6000\r\n        10\t1'000'000\t  400\t2'500.00\t0.00250000\t  750'000.00\t5'175'000.00\t0.7500\r\n        11\t1'000'000\t  400\t2'500.00\t0.00250000\t  750'000.00\t5'925'000.00\t0.7500\r\n        12\t1'000'000\t  400\t2'500.00\t0.00250000\t  750'000.00\t6'675'000.00\t0.7500\r\n        13\t1'000'000\t  200\t5'000.00\t0.00500000\t1'500'000.00\t8'175'000.00\t1.5000\r\n        14\t1'000'000\t  200\t5'000.00\t0.00500000\t1'500'000.00\t9'675'000.00\t1.5000\r\n        15\t1'000'000\t  200\t5'000.00\t0.00500000\t1'500'000.00\t11'175'000.00\t1.5000\r\n        16\t1'000'000\t  400\t2'500.00\t0.00250000\t  750'000.00\t11'925'000.00\t0.7500\r\n        17\t1'000'000\t  500\t2'000.00\t0.00200000\t  600'000.00\t12'525'000.00\t0.6000\r\n        18\t1'000'000\t  800\t1'250.00\t0.00125000\t  375'000.00\t12'900'000.00\t0.3750\r\n        19\t1'000'000\t1'000\t1'000.00\t0.00100000\t  300'000.00\t13'200'000.00\t0.3000\r\n        20\t1'000'000\t2'500\t  400.00\t0.00040000\t  120'000.00\t13'320'000.00\t0.1200\r\n           20'000'000\t       44'400.00 ETH\t       13'320'000.00\t      average:\t0.6700\r\n\t    */\r\n    }\r\n\r\n    // internal: token purchase function\r\n    function _buyTokens(address addr, bool failsafe) internal {\r\n        require(addr != address(0));\r\n        require(msg.value > 0);\r\n        require(msg.value >= tokensale.minPaymentRequiredUnitWei); // min. payment required\r\n        require(msg.value <= tokensale.maxPaymentAllowedUnitWei); // max. payment allowed\r\n        require(tokensaleStarted() && !tokensaleFinished() && !tokensalePaused());\r\n\r\n        uint256 amountTokens;\r\n        uint256 actExchangeRate = _tokensaleTokensPerEther(tokensale.totalTokensDistributedRAW1e18);\r\n        uint256 amountTokensToBuyAtThisRate = msg.value * actExchangeRate;\r\n        uint256 availableAtThisRate = (1000000 * TOKEN_MULTIPLIER) - ((tokensale.totalTokensDistributedRAW1e18) % (1000000 * TOKEN_MULTIPLIER));\r\n\r\n        if (amountTokensToBuyAtThisRate <= availableAtThisRate) { // wei fits in this exchangerate-stage\r\n            amountTokens = amountTokensToBuyAtThisRate;\r\n        } else { // on border crossing (no more than 1 border crossing possible, because of max. buy limit of 100 ETH = 100 * 5000 = 0.5 mio)\r\n            amountTokens = availableAtThisRate;\r\n            //uint256 nextExchangeRate = _tokensaleTokensPerEther(tokensale.totalTokensDistributedRAW1e18 + amountTokens);\r\n            //uint256 amountTokensToBuyAtNextRate = (msg.value - availableAtThisRate / actExchangeRate) * nextExchangeRate;\r\n\r\n            amountTokens += (msg.value - availableAtThisRate / actExchangeRate) * _tokensaleTokensPerEther(tokensale.totalTokensDistributedRAW1e18 + amountTokens); //amountTokensToBuyAtNextRate;\r\n        }\r\n\r\n        require(amountTokens > 0);\r\n        require(tokensale.totalTokensDistributedRAW1e18.add(amountTokens) <= tokensale.initialTokenSupplyRAW1e18); // check limit\r\n\r\n        _requestInterestPayoutToTotalSupply();\r\n        _requestInterestPayoutToAccountBalance(contractOwner); // do interest payout before changing balances\r\n        _requestInterestPayoutToAccountBalance(addr); // do interest payout before changing balances\r\n\r\n        tokensale.totalWeiRaised = tokensale.totalWeiRaised.add(msg.value);\r\n        if (!sendFundsToWallet || failsafe) tokensale.totalWeiInFallback = tokensale.totalWeiInFallback.add(msg.value);\r\n\r\n        tokensale.totalTokensDistributedRAW1e18 = tokensale.totalTokensDistributedRAW1e18.add(amountTokens);\r\n        tokensale.totalTokensDistributedAmount = tokensale.totalTokensDistributedRAW1e18 / TOKEN_MULTIPLIER;\r\n        tokensale.totalTokensDistributedFraction = tokensale.totalTokensDistributedRAW1e18 % TOKEN_MULTIPLIER;\r\n\r\n        // SafeMath.sub will throw if there is not enough balance.\r\n        accounts[contractOwner].balance = accounts[contractOwner].balance.sub(amountTokens);\r\n        accounts[addr].balance = accounts[addr].balance.add(amountTokens);\r\n\r\n\r\n        /* debug only */\r\n        if (debug) {\r\n            // update list of all contributors\r\n            Contributor memory newcont;\r\n            newcont.addr = addr;\r\n            newcont.amountWei = msg.value;\r\n            newcont.amountTokensUnit1e18 = amountTokens;\r\n            newcont.sinceInterval = intervalNow();\r\n            tokensaleContributors.push( newcont );\r\n        }\r\n        /* */\r\n\r\n        // send tokens to wallet of sender from ether\r\n        if (sendFundsToWallet && !failsafe) adminWallet.transfer(msg.value); // req. more gas\r\n\r\n        TokensPurchased(contractOwner, addr, msg.value, amountTokens);\r\n    }\r\n\r\n    // public (read only): unixtime to next interest payout\r\n    function tokensaleSecondsToStart() public constant returns (uint256) {\r\n        //uint256 timestamp = _getTimestamp();\r\n        return (tokensale.startAtTimestamp <= _getTimestamp()) ? 0 : tokensale.startAtTimestamp - _getTimestamp();\r\n    }\r\n\r\n\r\n    // @return true if tokensale has started\r\n    function tokensaleStarted() internal constant returns (bool) {\r\n        return _getTimestamp() >= tokensale.startAtTimestamp;\r\n    }\r\n\r\n    // @return true if tokensale ended\r\n    function tokensaleFinished() internal constant returns (bool) {\r\n        return (tokensale.totalTokensDistributedRAW1e18 >= tokensale.initialTokenSupplyRAW1e18 || tokensale.tokenSaleClosed);\r\n    }\r\n\r\n    // @return true if tokensale is paused\r\n    function tokensalePaused() internal constant returns (bool) {\r\n        return tokensale.tokenSalePaused;\r\n    }\r\n\r\n\r\n    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n    // +\r\n    // + admin only stuff\r\n    // +\r\n    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n    event AdminTransferredOwnership(address indexed previousOwner, address indexed newOwner);\r\n    event AdminChangedFundingWallet(address oldAddr, address newAddr);\r\n\r\n    // public (admin only): contact control functions; contract creator only; all in one\r\n    function adminCommand(uint8 command, address addr, uint256 fee) onlyOwner public returns (bool) {\r\n        require(command >= 0 && command <= 255);\r\n        if (command == 1) { // (EnumAdminCommand(command) == EnumAdminCommand.SendAllFailsafeEtherToAdminWallet\r\n            // contract stores ETH:\r\n            // - masternode.totalBalanceWei == never withdrawable by contract owner (only by each MN owner)\r\n            // - tokensale.totalWeiInFallback\r\n            // - maybe: locked ether by unforseen errors\r\n\r\n            require(this.balance >= tokensale.totalWeiInFallback);\r\n\r\n            uint256 _withdrawBalance = this.balance.sub(masternode.totalBalanceWei);\r\n            require(_withdrawBalance > 0);\r\n\r\n            adminWallet.transfer(_withdrawBalance);\r\n            tokensale.totalWeiInFallback = 0;\r\n            return true;\r\n        } else\r\n\r\n        if (command == 15) { // (EnumAdminCommand(command) == EnumAdminCommand.RecalculateTotalSupply\r\n            // speed up realtime request to balance functions by periodic call this gas cost operation\r\n            _requestInterestPayoutToTotalSupply();\r\n            _requestInterestPayoutToAccountBalance(contractOwner); // do interest payout before changing balances\r\n        } else\r\n\r\n        if (command == 22) { // (EnumAdminCommand(command) == EnumAdminCommand.changeTransactionFee) {\r\n            require(fee >= 0 && fee <= (9999 * TOKEN_MULTIPLIER) && fee != masternode.transactionRewardInSubtokensRaw1e18);\r\n            masternode.transactionRewardInSubtokensRaw1e18 = fee;\r\n\r\n            TransactionFeeChanged(fee);\r\n            return true;\r\n        } else\r\n        if (command == 33) { // (EnumAdminCommand(command) == EnumAdminCommand.ChangeMinerReward) {\r\n            require(fee >= 0 && fee <= (999999) && fee != masternode.miningRewardInTokens);\r\n\r\n            masternode.miningRewardInTokens = fee;                              // 50'000 tokens to mine per masternode per interval\r\n            miningRewardInSubtokensRaw1e18 = fee * TOKEN_MULTIPLIER; // used for internal integer calculation\r\n\r\n            MinerRewardChanged(fee);\r\n            return true;\r\n        } else\r\n\r\n        if (command == 111) { // (EnumAdminCommand(command) == EnumAdminCommand.CloseTokensale) {\r\n            tokensale.tokenSaleClosed = true;\r\n\r\n            TokenSaleClosed();\r\n            return true;\r\n        } else\r\n        if (command == 112) { // (EnumAdminCommand(command) == EnumAdminCommand.OpenTokensale) {\r\n            tokensale.tokenSaleClosed = false;\r\n\r\n            TokenSaleOpened();\r\n            return true;\r\n        } else\r\n        if (command == 113) { // (EnumAdminCommand(command) == EnumAdminCommand.PauseTokensale) {\r\n            tokensale.tokenSalePaused = true;\r\n\r\n            TokenSalePaused(true);\r\n            return true;\r\n        } else\r\n        if (command == 114) { // (EnumAdminCommand(command) == EnumAdminCommand.UnpauseTokensale) {\r\n            tokensale.tokenSalePaused = false;\r\n\r\n            TokenSalePaused(false);\r\n            return true;\r\n        } else\r\n\r\n        if (command == 150) { // (EnumAdminCommand(command) == EnumAdminCommand.TransferOwnership) {\r\n            require(addr != address(0));\r\n            address oldOwner = contractOwner;\r\n            contractOwner = addr;\r\n\r\n            AdminTransferredOwnership(oldOwner, addr);\r\n            return true;\r\n        } else\r\n        if (command == 152) { // (EnumAdminCommand(command) == EnumAdminCommand.ChangeAdminWallet) {\r\n            require(addr != address(0));\r\n            require(addr != adminWallet);\r\n            address oldAddr = adminWallet;\r\n            adminWallet = addr;\r\n\r\n            AdminChangedFundingWallet(oldAddr, addr);\r\n            return true;\r\n        } else\r\n\r\n        if (command == 225) { // (EnumAdminCommand(command) == EnumAdminCommand.SelfDestuct) { // enabled during debug only!\r\n            require(debug || PRODUCTION_START>_getTimestamp()); // only allowed in debugging mode = during development and in production mode before sale starts\r\n\r\n            DebugValue(\"debug: suicide\", this.balance);\r\n            selfdestruct(contractOwner);\r\n            return true;\r\n        }\r\n        /*else\r\n\r\n        if (command == 236) { // (EnumAdminCommand(command) == EnumAdminCommand.SendAllEther) { // enabled during debug only!\r\n            require(debug); // only allowed in debugging mode = during development\r\n\r\n            DebugValue(\"debug: send all ether to admin\", this.balance);\r\n            contractOwner.transfer(this.balance);\r\n            return true;\r\n        } else\r\n        if (command == 247) { // (EnumAdminCommand(command) == EnumAdminCommand.DisableDebugMode) { // re-enabling is impossible\r\n            require(debug); // only allowed in debugging mode = during development\r\n\r\n            DebugValue(\"debug: debug mode disabled - unreverable operation\", this.balance);\r\n            debug = false;\r\n            return true;\r\n        }*/\r\n        return false;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == contractOwner);\r\n        _;\r\n    }\r\n\r\n    function _getTimestamp() internal constant returns (uint256) {\r\n        return now; // alias for block.timestamp;\r\n        // eth-miner manipulation of timestamp (possible in a range up to 900 seconds) is acceptable because interval-functions are in a range from 7 to 30 days.\r\n    }\r\n\r\n    function _addTime(uint256 _sec) internal pure returns (uint256) {\r\n        return _sec * (1 seconds); // in unittime\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokensdistibutedRAW1e18\",\"type\":\"uint256\"}],\"name\":\"tokensaleStageAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensaleStageNow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"masternodes\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"balanceWei\",\"type\":\"uint256\"},{\"name\":\"sinceInterval\",\"type\":\"uint256\"},{\"name\":\"lastMiningInterval\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secToNextMiningInterval\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOfPretty\",\"outputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"fraction\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAddr\",\"type\":\"address\"}],\"name\":\"masternodeTransferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"intervalNow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"masternodeDeregister\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"masternode\",\"outputs\":[{\"name\":\"activeMasternodes\",\"type\":\"uint8\"},{\"name\":\"totalBalanceWei\",\"type\":\"uint256\"},{\"name\":\"rewardPool\",\"type\":\"uint256\"},{\"name\":\"rewardsPayedTotal\",\"type\":\"uint256\"},{\"name\":\"miningRewardInTokens\",\"type\":\"uint256\"},{\"name\":\"totalTokensMinedRaw1e18\",\"type\":\"uint256\"},{\"name\":\"transactionRewardInSubtokensRaw1e18\",\"type\":\"uint256\"},{\"name\":\"minBalanceRequiredInTokens\",\"type\":\"uint256\"},{\"name\":\"minBalanceRequiredInSubtokensRaw1e18\",\"type\":\"uint256\"},{\"name\":\"minDepositRequiredInEther\",\"type\":\"uint256\"},{\"name\":\"minDepositRequiredInWei\",\"type\":\"uint256\"},{\"name\":\"maxMasternodesAllowed\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"tokensaleBuyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensale\",\"outputs\":[{\"name\":\"initialTokenSupplyRAW1e18\",\"type\":\"uint256\"},{\"name\":\"initialTokenSupplyAmount\",\"type\":\"uint256\"},{\"name\":\"initialTokenSupplyFraction\",\"type\":\"uint256\"},{\"name\":\"minPaymentRequiredUnitWei\",\"type\":\"uint256\"},{\"name\":\"maxPaymentAllowedUnitWei\",\"type\":\"uint256\"},{\"name\":\"startAtTimestamp\",\"type\":\"uint256\"},{\"name\":\"tokenSaleClosed\",\"type\":\"bool\"},{\"name\":\"tokenSalePaused\",\"type\":\"bool\"},{\"name\":\"totalWeiRaised\",\"type\":\"uint256\"},{\"name\":\"totalWeiInFallback\",\"type\":\"uint256\"},{\"name\":\"totalTokensDistributedRAW1e18\",\"type\":\"uint256\"},{\"name\":\"totalTokensDistributedAmount\",\"type\":\"uint256\"},{\"name\":\"totalTokensDistributedFraction\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"interestNextInPercent\",\"outputs\":[{\"name\":\"mainUnit\",\"type\":\"uint256\"},{\"name\":\"fraction\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensaleTokensPerEtherNow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"command\",\"type\":\"uint8\"},{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"adminCommand\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"masternodeRegister\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secToNextInterestPayout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"masternodeIsValid\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"masternodeMineTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokensaleContributors\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"amountWei\",\"type\":\"uint256\"},{\"name\":\"amountTokensUnit1e18\",\"type\":\"uint256\"},{\"name\":\"sinceInterval\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensaleSecondsToStart\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupplyPretty\",\"outputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"fraction\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stageNow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"text\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"DebugValue\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MasternodeRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MasternodeDeregistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MasternodeMinedTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fromAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"toAddr\",\"type\":\"address\"}],\"name\":\"MasternodeTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MasternodeRewardSend\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MasternodeRewardAddedToRewardPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newNumMaxMasternodesAllowed\",\"type\":\"uint8\"}],\"name\":\"MaxMasternodesAllowedChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newTransactionFee\",\"type\":\"uint256\"}],\"name\":\"TransactionFeeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newMinerReward\",\"type\":\"uint256\"}],\"name\":\"MinerRewardChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"TokenSaleFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"TokenSaleClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"TokenSaleOpened\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"paused\",\"type\":\"bool\"}],\"name\":\"TokenSalePaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"AdminTransferredOwnership\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newAddr\",\"type\":\"address\"}],\"name\":\"AdminChangedFundingWallet\",\"type\":\"event\"}]","ContractName":"MasteriumToken","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://7599c6bfca2cc307b4f7bdeb9212003777c7e5f4ad2f0a15cb9364f11bf0bf5f"}]}