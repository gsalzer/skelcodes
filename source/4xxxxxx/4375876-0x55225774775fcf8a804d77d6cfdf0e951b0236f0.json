{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal constant returns(uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal constant returns(uint256) {\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal constant returns(uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal constant returns(uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    modifier onlyOwner() { require(msg.sender == owner); _; }\r\n\r\n    function Ownable() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) onlyOwner {\r\n        require(newOwner != address(0));\r\n        OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract Pausable is Ownable {\r\n    bool public paused = false;\r\n\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    modifier whenNotPaused() { require(!paused); _; }\r\n    modifier whenPaused() { require(paused); _; }\r\n\r\n    function pause() onlyOwner whenNotPaused {\r\n        paused = true;\r\n        Pause();\r\n    }\r\n    \r\n    function unpause() onlyOwner whenPaused {\r\n        paused = false;\r\n        Unpause();\r\n    }\r\n}\r\n\r\ncontract ERC20 {\r\n    uint256 public totalSupply;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    function balanceOf(address who) constant returns (uint256);\r\n    function transfer(address to, uint256 value) returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) returns (bool);\r\n    function allowance(address owner, address spender) constant returns (uint256);\r\n    function approve(address spender, uint256 value) returns (bool);\r\n}\r\n\r\ncontract StandardToken is ERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => uint256) balances;\r\n    mapping(address => mapping(address => uint256)) allowed;\r\n\r\n    function balanceOf(address _owner) constant returns(uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) returns(bool success) {\r\n        require(_to != address(0));\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n\r\n        Transfer(msg.sender, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns(bool success) {\r\n        require(_to != address(0));\r\n\r\n        var _allowance = allowed[_from][msg.sender];\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = _allowance.sub(_value);\r\n\r\n        Transfer(_from, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns(uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns(bool success) {\r\n        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    function increaseApproval(address _spender, uint _addedValue) returns(bool success) {\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n\r\n        return true;\r\n    }\r\n\r\n    function decreaseApproval(address _spender, uint _subtractedValue) returns(bool success) {\r\n        uint oldValue = allowed[msg.sender][_spender];\r\n\r\n        if(_subtractedValue > oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        \r\n        return true;\r\n    }\r\n}\r\n\r\ncontract BurnableToken is StandardToken {\r\n    event Burn(address indexed burner, uint256 value);\r\n\r\n    function burn(uint256 _value) public {\r\n        require(_value > 0);\r\n\r\n        address burner = msg.sender;\r\n        balances[burner] = balances[burner].sub(_value);\r\n        totalSupply = totalSupply.sub(_value);\r\n        Burn(burner, _value);\r\n    }\r\n}\r\n\r\n/*\r\n    ICO Алтын\r\n    - Эмиссия токенов ограничена (всего 100 000 000 токенов)\r\n    - На Crowdsale продаются 22 000 000 токенов в 4 этапа, каждый этап ограничен по кол-ву токенов, цена токена на каждом этапе своя\r\n    - Нижная граница сборов 300 000 USD (граница никак не ограничивают контракт)\r\n    - Верхная граница сборов 5 500 000 USD (если граница достигнута токены больше не продаются, контракт дает сдачу если сумма больше)\r\n    - ICO ограничено по времени дата начала 17.10.2017 продолжительность 45 дней.\r\n    - Цена эфира 1 ETH = 300 USD, минимальная сумма инвестиций 0.03 USD\r\n    - Закрытие ICO происходит с помощью функции \"withdraw()\", управление токеном передаются бенефициару, не раскупленные токены сгорают, токены не участвующие в продаже отправляются бенефициару\r\n*/\r\n\r\ncontract ALTToken is BurnableToken, Ownable {\r\n    string public name = \"Altyn Token\";\r\n    string public symbol = \"ALT\";\r\n    uint256 public decimals = 18;\r\n    \r\n    uint256 public INITIAL_SUPPLY = 100000000 * 1 ether;                                        // Amount tokens\r\n\r\n    function ALTToken() {\r\n        totalSupply = INITIAL_SUPPLY;\r\n        balances[msg.sender] = INITIAL_SUPPLY;\r\n    }\r\n}\r\n\r\ncontract ALTCrowdsale is Pausable {\r\n    using SafeMath for uint;\r\n\r\n    struct Step {\r\n        uint priceUSD;\r\n        uint amountTokens;\r\n    }\r\n\r\n    ALTToken public token;\r\n    address public beneficiary = 0x9df0be686E12ccdbE46D4177442878bf8636E89f;                    // Beneficiary\r\n\r\n    uint public collected;\r\n    uint public collectedUSD;\r\n    uint public tokensSold;\r\n    uint public maxTokensSold = 22000000 * 1 ether;                                             // Tokens for sale\r\n\r\n    uint public priceETH = 300;                                                                 // Ether price USD\r\n    uint public softCapUSD = 300000;                                                            // Soft cap USD\r\n    uint public softCap = softCapUSD / priceETH * 1 ether;\r\n    uint public hardCapUSD = 5500000;                                                           // Hard cap USD\r\n    uint public hardCap = hardCapUSD / priceETH * 1 ether;\r\n\r\n    Step[] steps;\r\n\r\n    uint public startTime = 1508225824;                                                         // Date start 01.10.2017 00:00 +0\r\n    uint public endTime = startTime + 45 days;                                                  // Date end +45 days\r\n    bool public crowdsaleFinished = false;\r\n\r\n    event SoftCapReached(uint256 etherAmount);\r\n    event HardCapReached(uint256 etherAmount);\r\n    event NewContribution(address indexed holder, uint256 tokenAmount, uint256 etherAmount);\r\n    event Withdraw();\r\n\r\n    modifier onlyAfter(uint time) { require(now > time); _; }\r\n    modifier onlyBefore(uint time) {  require(now < time);  _; }\r\n\r\n    function ALTCrowdsale() {\r\n        token = new ALTToken();\r\n\r\n        steps.push(Step(15, 2000000));                                                          // Step 1: 0.15$; 2 000 000 ALT tokens\r\n        steps.push(Step(20, 5000000));                                                          // Step 2: 0.20$; +3 000 000 ALT tokens\r\n        steps.push(Step(25, 15000000));                                                         // Step 3: 0.25$; +10 000 000 ALT tokens\r\n        steps.push(Step(30, 22000000));                                                         // Step 4: 0.30$; +7 000 000 ALT tokens\r\n    }\r\n\r\n    function() payable {\r\n        purchase();\r\n    }\r\n    \r\n    function purchase() onlyAfter(startTime) onlyBefore(endTime) whenNotPaused payable {\r\n        require(!crowdsaleFinished);\r\n        require(msg.value >= 0.001 * 1 ether && msg.value <= 10000 * 1 ether);\r\n        require(tokensSold < maxTokensSold);\r\n\r\n        uint amount = 0;\r\n        uint sum = 0;\r\n        for(uint i = 0; i < steps.length; i++) {\r\n            if(tokensSold.add(amount) < steps[i].amountTokens * 1 ether) {\r\n                uint avail = (steps[i].amountTokens * 1 ether) - tokensSold.add(amount);\r\n                uint nece = (msg.value - sum) * priceETH / steps[i].priceUSD * 100;\r\n                uint buy = nece;\r\n\r\n                if(buy > avail) buy = avail;\r\n                \r\n                amount += buy;\r\n                sum += buy / (priceETH / steps[i].priceUSD * 100);\r\n\r\n                if(buy == nece) break;\r\n            }\r\n        }\r\n        \r\n        require(tokensSold.add(amount) <= maxTokensSold);\r\n\r\n        if(collected < softCap && collected.add(sum) >= softCap) {\r\n            SoftCapReached(collected.add(sum));\r\n        }\r\n\r\n        collected = collected.add(sum);\r\n        collectedUSD = collected * priceETH / 1 ether;\r\n        tokensSold = tokensSold.add(amount);\r\n        \r\n        require(token.transfer(msg.sender, amount));\r\n        if(sum < msg.value) require(msg.sender.send(msg.value - sum));\r\n\r\n        NewContribution(msg.sender, amount, sum);\r\n\r\n        if(collected >= hardCap) {\r\n            HardCapReached(collected);\r\n        }\r\n    }\r\n\r\n    function withdraw() onlyOwner {\r\n        require(!crowdsaleFinished);\r\n\r\n        beneficiary.transfer(collected);\r\n\r\n        if(tokensSold < maxTokensSold) token.burn(maxTokensSold - tokensSold);\r\n        token.transfer(beneficiary, token.balanceOf(this));\r\n        \r\n        token.transferOwnership(beneficiary);\r\n\r\n        crowdsaleFinished = true;\r\n\r\n        Withdraw();\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"maxTokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"collectedUSD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"purchase\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"collected\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"softCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardCapUSD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"softCapUSD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"etherAmount\",\"type\":\"uint256\"}],\"name\":\"SoftCapReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"etherAmount\",\"type\":\"uint256\"}],\"name\":\"HardCapReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"etherAmount\",\"type\":\"uint256\"}],\"name\":\"NewContribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"ALTCrowdsale","CompilerVersion":"v0.4.17+commit.bdeb9e52","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://a3612af56dc3cdb51850b01c86b8233c57f660b73ec9d33792f2c097de6af773"}]}