{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\ncontract UTEMIS{    \r\n    /******************** Public constants ********************/\r\n    \r\n    // Days of ico since it is deployed\r\n    uint                                            public constant ICO_DAYS             = 59;\r\n\r\n    // Minimum value accepted for investors. n wei / 10 ^ 18 = n Ethers\r\n    uint                                            public constant MIN_ACCEPTED_VALUE   = 50000000000000000 wei;\r\n\r\n    // Value for each UTS\r\n    uint                                            public constant VALUE_OF_UTS         = 666666599999 wei;\r\n\r\n    // Token name\r\n    string                                          public constant TOKEN_NAME           = \"UTEMIS\";\r\n    \r\n    // Symbol token\r\n    string                                          public constant TOKEN_SYMBOL         = \"UTS\";\r\n\r\n    // Total supply of tokens\r\n    uint256                                         public constant TOTAL_SUPPLY         = 1 * 10 ** 12;    \r\n\r\n    // The amount of tokens that will be offered during the ico\r\n    uint256                                         public constant ICO_SUPPLY           = 2 * 10 ** 11;\r\n\r\n    // Minimum objective\r\n    uint256                                         public constant SOFT_CAP             = 10000 ether; // 10000 ETH\r\n\r\n    // When the ico Starts - GMT Monday, January 8 , 2018 5:00:00 PM //1515430800;\r\n    uint                                            public constant START_ICO            = 1515430800;\r\n    \r\n    /******************** Public variables ********************/\r\n\r\n    //Owner of the contract\r\n    address                                         public owner;    \r\n\r\n    //Date of end ico\r\n    uint                                            public deadLine;        \r\n\r\n    //Date of start ico\r\n    uint                                            public startTime;\r\n\r\n    //Balances\r\n    mapping(address => uint256)                     public balance_;\r\n\r\n    //Remaining tokens to offer during the ico\r\n    uint                                            public remaining;    \r\n\r\n    //Time of bonus application, could be n minutes , n hours , n days , n weeks , n years \r\n    uint[4]                                         private bonusTime                  = [3 days    , 17 days    , 31 days   , 59 days];\r\n\r\n    //Amount of bonus applicated\r\n    uint8[4]                                        private bonusBenefit               = [uint8(40) , uint8(25)  , uint8(20) , uint8(15)];\r\n    uint8[4]                                        private bonusPerInvestion_5        = [uint8(0)  , uint8(5)   , uint8(3)  , uint8(2)];\r\n    uint8[4]                                        private bonusPerInvestion_10       = [uint8(0)  , uint8(10)  , uint8(5)  , uint8(3)];    \r\n\r\n    //The accound that receives the ether when the ico is succesful. If not defined, the beneficiary will be the owner\r\n    address                                         private beneficiary;    \r\n\r\n    //State of ico\r\n    bool                                            private ico_started;\r\n\r\n    //Ethers collected during the ico\r\n    uint256                                         public ethers_collected;\r\n    \r\n    //ETH Balance of contract\r\n    uint256                                         private ethers_balance;\r\n        \r\n\r\n    //Struct data for store investors\r\n    struct Investors{\r\n        uint256 amount;\r\n        uint when;        \r\n    }\r\n\r\n    //Array for investors\r\n    mapping(address => Investors) private investorsList;     \r\n    address[] private investorsAddress;\r\n\r\n    //Events\r\n    event Transfer(address indexed from , address indexed to , uint256 value);\r\n    event Burn(address indexed from, uint256 value);\r\n    event FundTransfer(address backer , uint amount , address investor);\r\n\r\n    //Safe math\r\n    function safeSub(uint a , uint b) internal pure returns (uint){assert(b <= a);return a - b;}  \r\n    function safeAdd(uint a , uint b) internal pure returns (uint){uint c = a + b;assert(c>=a && c>=b);return c;}\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    modifier icoStarted(){\r\n        require(ico_started == true);\r\n        require(now <= deadLine);\r\n        require(now >= START_ICO);\r\n        _;\r\n    }\r\n\r\n    modifier icoStopped(){\r\n        require(ico_started == false);\r\n        require(now > deadLine);\r\n        _;        \r\n    }\r\n\r\n    modifier minValue(){\r\n        require(msg.value >= MIN_ACCEPTED_VALUE);\r\n        _;\r\n    }\r\n\r\n    //Contract constructor\r\n    function UTEMIS() public{          \r\n        balance_[msg.sender] = TOTAL_SUPPLY;                                         //Transfer all tokens to main account        \r\n        owner               = msg.sender;                                           //Set the variable owner to creator of contract                \r\n        deadLine            = START_ICO + ICO_DAYS * 1 days;                        //Declare deadLine        \r\n        startTime           = now;                                                  //Declare startTime of contract\r\n        remaining           = ICO_SUPPLY;                                           //The remaining tokens to sell\r\n        ico_started         = false;                                                //State of ico            \r\n    }\r\n\r\n    /**\r\n     * For transfer tokens. Internal use, only can executed by this contract\r\n     *\r\n     * @param  _from         Source address\r\n     * @param  _to           Destination address\r\n     * @param  _value        Amount of tokens to send\r\n     */\r\n    function _transfer(address _from , address _to , uint _value) internal{        \r\n        require(_to != 0x0);                                                        //Prevent send tokens to 0x0 address        \r\n        require(balance_[_from] >= _value);                                          //Check if the sender have enough tokens        \r\n        require(balance_[_to] + _value > balance_[_to]);                              //Check for overflows        \r\n        balance_[_from]         = safeSub(balance_[_from] , _value);                 //Subtract from the source ( sender )        \r\n        balance_[_to]           = safeAdd(balance_[_to]   , _value);                 //Add tokens to destination        \r\n        uint previousBalance    = balance_[_from] + balance_[_to];                    //To make assert        \r\n        Transfer(_from , _to , _value);                                             //Fire event for clients        \r\n        assert(balance_[_from] + balance_[_to] == previousBalance);                   //Check the assert\r\n    }\r\n\r\n    /**\r\n     * For transfer tokens from owner of contract\r\n     *\r\n     * @param  _to           Destination address\r\n     * @param  _value        Amount of tokens to send\r\n     */\r\n    function transfer(address _to , uint _value) public onlyOwner{                                             \r\n        _transfer(msg.sender , _to , _value);                                       //Internal transfer\r\n    }\r\n    \r\n    /**\r\n     * ERC20 Function to know's the balances\r\n     *\r\n     * @param  _owner           Address to check\r\n     * @return uint             Returns the balance of indicated address\r\n     */\r\n    function balanceOf(address _owner) constant public returns(uint balances){\r\n        return balance_[_owner];\r\n    }    \r\n\r\n    /**\r\n     * Get investors info\r\n     *\r\n     * @return []                Returns an array with address of investors, amount invested and when invested\r\n     */\r\n    function getInvestors() constant public returns(address[] , uint[] , uint[]){\r\n        uint length = investorsAddress.length;                                             //Length of array\r\n        address[] memory addr = new address[](length);\r\n        uint[] memory amount  = new uint[](length);\r\n        uint[] memory when    = new uint[](length);\r\n        for(uint i = 0; i < length; i++){\r\n            address key = investorsAddress[i];\r\n            addr[i]     = key;\r\n            amount[i]   = investorsList[key].amount;\r\n            when[i]     = investorsList[key].when;\r\n        }\r\n        return (addr , amount , when);        \r\n    }\r\n\r\n    /**\r\n     * Get total tokens distributeds\r\n     *\r\n     * @return uint              Returns total tokens distributeds\r\n     */\r\n    function getTokensDistributeds() constant public returns(uint){\r\n        return ICO_SUPPLY - remaining;\r\n    }\r\n\r\n    /**\r\n     * Get amount of bonus to apply\r\n     *\r\n     * @param _ethers              Amount of ethers invested, for calculation the bonus     \r\n     * @return uint                Returns a % of bonification to apply\r\n     */\r\n    function getBonus(uint _ethers) public view returns(uint8){        \r\n        uint8 _bonus  = 0;                                                          //Assign bonus to \r\n        uint8 _bonusPerInvestion = 0;\r\n        uint  starter = now - START_ICO;                                            //To control end time of bonus\r\n        for(uint i = 0; i < bonusTime.length; i++){                                 //For loop\r\n            if(starter <= bonusTime[i]){                                            //If the starter are greater than bonusTime, the bonus will be 0                \r\n                if(_ethers >= 5 ether && _ethers < 10 ether){\r\n                    _bonusPerInvestion = bonusPerInvestion_5[i];\r\n                }\r\n                if(_ethers > 10 ether){\r\n                    _bonusPerInvestion = bonusPerInvestion_10[i];\r\n                }\r\n                _bonus = bonusBenefit[i];                                           //Asign amount of bonus to bonus_ variable                                \r\n                break;                                                              //Break the loop\r\n\r\n            }\r\n        }        \r\n        return _bonus + _bonusPerInvestion;\r\n    }\r\n    \r\n    /**\r\n     * Escale any value to n * 10 ^ 18\r\n     *\r\n     * @param  _value        Value to escale\r\n     * @return uint          Returns a escaled value\r\n     */\r\n    function escale(uint _value) private pure returns(uint){\r\n        return _value * 10 ** 18;\r\n    }\r\n\r\n    /**\r\n     * Calculate the amount of tokens to sends depeding on the amount of ethers received\r\n     *\r\n     * @param  _ethers              Amount of ethers for convert to tokens\r\n     * @return uint                 Returns the amount of tokens to send\r\n     */\r\n    function getTokensToSend(uint _ethers) public view returns (uint){\r\n        uint tokensToSend  = 0;                                                     //Assign tokens to send to 0                                            \r\n        uint8 bonus        = getBonus(_ethers);                                     //Get amount of bonification        \r\n        uint ethToTokens   = _ethers / VALUE_OF_UTS;                                //Make the conversion, divide amount of ethers by value of each UTS                \r\n        uint amountBonus   = escale(ethToTokens) / 100 * escale(bonus);\r\n        uint _amountBonus  = amountBonus / 10 ** 36;\r\n             tokensToSend  = ethToTokens + _amountBonus;\r\n        return tokensToSend;\r\n    }\r\n\r\n    /**\r\n     * Set the beneficiary of the contract, who receives Ethers\r\n     *\r\n     * @param _beneficiary          Address that will be who receives Ethers\r\n     */\r\n    function setBeneficiary(address _beneficiary) public onlyOwner{\r\n        require(msg.sender == owner);                                               //Prevents the execution of another than the owner\r\n        beneficiary = _beneficiary;                                                 //Set beneficiary\r\n    }\r\n\r\n\r\n    /**\r\n     * Start the ico manually\r\n     *     \r\n     */\r\n    function startIco() public onlyOwner{\r\n        ico_started = true;                                                         //Set the ico started\r\n    }\r\n\r\n    /**\r\n     * Stop the ico manually\r\n     *\r\n     */\r\n    function stopIco() public onlyOwner{\r\n        ico_started = false;                                                        //Set the ico stopped\r\n    }\r\n\r\n    /**\r\n     * Give back ethers to investors if soft cap is not reached\r\n     * \r\n     */\r\n    function giveBackEthers() public onlyOwner icoStopped{\r\n        require(this.balance >= ethers_collected);                                         //Require that the contract have ethers \r\n        uint length = investorsAddress.length;                                             //Length of array    \r\n        for(uint i = 0; i < length; i++){\r\n            address investorA = investorsAddress[i];            \r\n            uint amount       = investorsList[investorA].amount;\r\n            if(address(beneficiary) == 0){\r\n                beneficiary = owner;\r\n            }\r\n            _transfer(investorA , beneficiary , balanceOf(investorA));\r\n            investorA.transfer(amount);\r\n        }\r\n    }\r\n\r\n    \r\n    /**\r\n     * Fallback when the contract receives ethers\r\n     *\r\n     */\r\n    function () payable public icoStarted minValue{                              \r\n        uint amount_actually_invested = investorsList[msg.sender].amount;           //Get the actually amount invested\r\n        \r\n        if(amount_actually_invested == 0){                                          //If amount invested are equal to 0, will add like new investor\r\n            uint index                = investorsAddress.length++;\r\n            investorsAddress[index]   = msg.sender;\r\n            investorsList[msg.sender] = Investors(msg.value , now);                 //Store investors info        \r\n        }\r\n        \r\n        if(amount_actually_invested > 0){                                           //If amount invested are greater than 0\r\n            investorsList[msg.sender].amount += msg.value;                          //Increase the amount invested\r\n            investorsList[msg.sender].when    = now;                                //Change the last time invested\r\n        }\r\n\r\n        uint tokensToSend = getTokensToSend(msg.value);                             //Calc the tokens to send depending on ethers received\r\n        remaining -= tokensToSend;                                                  //Subtract the tokens to send to remaining tokens        \r\n        _transfer(owner , msg.sender , tokensToSend);                               //Transfer tokens to investor\r\n        \r\n        require(balance_[owner] >= (TOTAL_SUPPLY - ICO_SUPPLY));                     //Requires not selling more tokens than those proposed in the ico        \r\n        require(balance_[owner] >= tokensToSend);\r\n        \r\n        if(address(beneficiary) == 0){                                              //Check if beneficiary is not setted\r\n            beneficiary = owner;                                                    //If not, set the beneficiary to owner\r\n        }    \r\n        ethers_collected += msg.value;                                              //Increase ethers_collected   \r\n        ethers_balance   += msg.value;\r\n        if(!beneficiary.send(msg.value)){\r\n            revert();\r\n        }                                                //Send ethers to beneficiary\r\n\r\n        FundTransfer(owner , msg.value , msg.sender);                               //Fire events for clients\r\n    }\r\n\r\n    /**\r\n     * Extend ICO time\r\n     *\r\n     * @param  timetoextend  Time in miliseconds to extend ico     \r\n     */\r\n    function extendICO(uint timetoextend) onlyOwner external{\r\n        require(timetoextend > 0);\r\n        deadLine+= timetoextend;\r\n    }\r\n    \r\n    /**\r\n     * Destroy contract and send ethers to owner\r\n     * \r\n     */\r\n    function destroyContract() onlyOwner external{\r\n        selfdestruct(owner);\r\n    }\r\n\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"ICO_SUPPLY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroyContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_NAME\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"START_ICO\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"setBeneficiary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethers_collected\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_SYMBOL\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_ethers\",\"type\":\"uint256\"}],\"name\":\"getBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"remaining\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"giveBackEthers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokensDistributeds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balances\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stopIco\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startIco\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_ethers\",\"type\":\"uint256\"}],\"name\":\"getTokensToSend\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOTAL_SUPPLY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"timetoextend\",\"type\":\"uint256\"}],\"name\":\"extendICO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VALUE_OF_UTS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInvestors\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SOFT_CAP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deadLine\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balance_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_ACCEPTED_VALUE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ICO_DAYS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"backer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"FundTransfer\",\"type\":\"event\"}]","ContractName":"UTEMIS","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://6588923eead45109605ec5b64af84c05d01dde15c9dc874a7f4b7bb2c513ecff"}]}