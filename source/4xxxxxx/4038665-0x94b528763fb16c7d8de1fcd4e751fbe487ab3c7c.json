{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\ncontract owned {\r\n    address public owner;\r\n\r\n    function owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) onlyOwner {\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract DSMath {\r\n\r\n    function add(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        assert((z = x + y) >= x);\r\n    }\r\n\r\n    function sub(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        assert((z = x - y) <= x);\r\n    }\r\n\r\n    function mul(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        assert((z = x * y) >= x);\r\n    }\r\n\r\n    function div(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        z = x / y;\r\n    }\r\n\r\n    function min(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n\r\n    function max(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n}\r\n\r\n\r\ncontract queue {\r\n    Queue public q;\r\n\r\n    struct BuyTicket {\r\n        address account;\r\n        uint amount;\r\n        uint time;\r\n    }\r\n\r\n    struct Queue {\r\n        BuyTicket[] data;\r\n        uint front;\r\n        uint back;\r\n    }\r\n\r\n    function queueSize() constant returns (uint r) {\r\n        r = q.back - q.front;\r\n    }\r\n\r\n    function queue() {\r\n        q.data.length = 600000;\r\n    }\r\n\r\n    function pushQueue(BuyTicket ticket) internal {\r\n        require((q.back + 1) % q.data.length != q.front);\r\n\r\n        q.data[q.back] = ticket;\r\n        q.back = (q.back + 1) % q.data.length;\r\n    }\r\n\r\n    function peekQueue() internal returns (BuyTicket r) {\r\n        require(q.back != q.front);\r\n\r\n        r = q.data[q.front];\r\n    }\r\n\r\n    function popQueue() internal {\r\n        require(q.back != q.front);\r\n\r\n        delete q.data[q.front];\r\n        q.front = (q.front + 1) % q.data.length;\r\n    }\r\n}\r\n\r\ncontract DeCenterToken is owned, queue, DSMath {\r\n    string public standard = 'Token 0.1';\r\n    string public name = 'DeCenter';\r\n    string public symbol = 'DC';\r\n    uint8 public decimals = 8;\r\n\r\n    uint256 public totalSupply = 10000000000000000; // 100 million\r\n    uint256 public availableTokens = 6000000000000000; // 60 million\r\n    uint256 public teamAndExpertsTokens = 4000000000000000; // 40 million\r\n    uint256 public price = 0.0000000001 ether; // 0.01 ether per token\r\n\r\n    uint public startTime;\r\n    uint public refundStartTime;\r\n    uint public refundDuration = 3 days; // 3 years\r\n    uint public firstStageDuration = 3 days; // 31 days\r\n\r\n    uint public maxDailyCap = 3333300000000; // 33 333 DC\r\n    mapping (uint => uint) public dailyTotals;\r\n\r\n    uint public queuedAmount;\r\n\r\n    address public beneficiary;\r\n    address public expertsAccount;\r\n    address public teamAccount;\r\n\r\n    uint public lastScheduledTopUp;\r\n    uint public lastProcessedDay;\r\n\r\n    mapping (address => uint256) public balanceOf;\r\n\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    // for testing\r\n    uint public cTime = 0;\r\n    function setCTime(uint _cTime) onlyOwner {\r\n        cTime = _cTime;\r\n    }\r\n\r\n    function DeCenterToken(\r\n    address _beneficiary,\r\n    address _expertsAccount,\r\n    address _teamAccount,\r\n    uint _startTime,\r\n    uint _refundStartTime\r\n    ) {\r\n        beneficiary = _beneficiary;\r\n        expertsAccount = _expertsAccount;\r\n        teamAccount = _teamAccount;\r\n\r\n        startTime = _startTime;\r\n        refundStartTime = _refundStartTime;\r\n\r\n        balanceOf[this] = totalSupply;\r\n\r\n        lastProcessedDay = dayFor(startTime + firstStageDuration * 1 days);\r\n\r\n        scheduledTopUp();\r\n    }\r\n\r\n    function time() constant returns (uint) {\r\n        // for testing\r\n        if(cTime > 0) {\r\n            return cTime;\r\n        }\r\n\r\n        return block.timestamp;\r\n    }\r\n\r\n    function today() constant returns (uint) {\r\n        return dayFor(time());\r\n    }\r\n\r\n    function dayFor(uint timestamp) constant returns (uint) {\r\n        return sub(timestamp, startTime) / 24 hours;\r\n    }\r\n\r\n    function lowerLimitForToday() constant returns (uint) {\r\n        return today() * 1 ether;\r\n    }\r\n\r\n    function scheduledTopUp() onlyOwner {\r\n        uint payment = 400000000000000; // 4 million tokens\r\n\r\n        require(sub(time(), lastScheduledTopUp) >= 1 years);\r\n        require(teamAndExpertsTokens >= payment * 2);\r\n\r\n        lastScheduledTopUp = time();\r\n\r\n        teamAndExpertsTokens -= payment;\r\n        balanceOf[this] = sub(balanceOf[this], payment);\r\n        balanceOf[expertsAccount] = add(balanceOf[expertsAccount], payment);\r\n\r\n        teamAndExpertsTokens -= payment;\r\n        balanceOf[this] = sub(balanceOf[this], payment);\r\n        balanceOf[teamAccount] = add(balanceOf[teamAccount], payment);\r\n\r\n        Transfer(this, expertsAccount, payment); // execute an event reflecting the change\r\n        Transfer(this, teamAccount, payment); // execute an event reflecting the change\r\n    }\r\n\r\n    /* Allow another contract to spend some tokens in your behalf */\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n\r\n        return true;\r\n    }\r\n\r\n    function refund(uint256 _value) internal {\r\n        require(time() > refundStartTime);\r\n        require(this.balance >= _value * price);\r\n\r\n        balanceOf[msg.sender] = sub(balanceOf[msg.sender], _value);\r\n        balanceOf[this] = add(balanceOf[this], _value);\r\n        availableTokens = add(availableTokens, _value);\r\n\r\n        msg.sender.transfer(_value * price);\r\n\r\n        Transfer(msg.sender, this, _value); // Notify anyone listening that this transfer took place\r\n    }\r\n\r\n    /* Send tokens */\r\n    function transfer(address _to, uint256 _value) {\r\n        require(balanceOf[msg.sender] >= _value); // Check if the sender has enough\r\n\r\n        if (_to == address(this)) {\r\n            refund(_value);\r\n            return;\r\n        }\r\n\r\n        balanceOf[msg.sender] = sub(balanceOf[msg.sender], _value);\r\n        balanceOf[_to] = add(balanceOf[_to], _value);\r\n\r\n        Transfer(msg.sender, _to, _value); // Notify anyone listening that this transfer took place\r\n    }\r\n\r\n    /* A contract attempts to get the tokens */\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        require(balanceOf[_from] >= _value); // Check if the sender has enough\r\n        require(_value <= allowance[_from][msg.sender]); // Check allowance\r\n\r\n        allowance[_from][msg.sender] = sub(allowance[_from][msg.sender], _value); //  Subtract from the allowance\r\n        balanceOf[_from] = sub(balanceOf[_from], _value); // Subtract from the sender\r\n        balanceOf[_to] = add(balanceOf[_to], _value); // Add the same to the recipient\r\n\r\n        Transfer(_from, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    function closeRefund() onlyOwner {\r\n        require(time() - refundStartTime > refundDuration);\r\n\r\n        beneficiary.transfer(this.balance);\r\n    }\r\n\r\n    /*\r\n     *    Token purchasing has 2 stages:\r\n     *       - First stage holds 31 days. There is no limit of buying.\r\n     *       - Second stage holds ~5 years after. There will be limit of 333.33 ether per day.\r\n     */\r\n    function buy() payable {\r\n        require(startTime <= time()); // check if ICO is going\r\n\r\n        uint amount = div(msg.value, price);\r\n\r\n        if (time() - startTime > firstStageDuration) { // second stage\r\n            require(1 ether <= msg.value); // check min. limit\r\n            require(msg.value <= 300 ether); // check max. limit\r\n\r\n            // send 80% to beneficiary account, another 20% stays for refunding\r\n            beneficiary.transfer(mul(div(msg.value, 5), 4));\r\n\r\n            uint currentDay = lastProcessedDay + 1;\r\n            uint limit = maxDailyCap - dailyTotals[currentDay];\r\n\r\n            if (limit >= amount) {\r\n                availableTokens = sub(availableTokens, amount);\r\n                balanceOf[this] = sub(balanceOf[this], amount); // subtracts amount from seller's balance\r\n                dailyTotals[currentDay] = add(dailyTotals[currentDay], amount);\r\n                balanceOf[msg.sender] = add(balanceOf[msg.sender], amount); // adds the amount to buyer's balance\r\n\r\n                Transfer(this, msg.sender, amount); // execute an event reflecting the change\r\n            } else {\r\n                queuedAmount = add(queuedAmount, amount);\r\n                require(queuedAmount <= availableTokens);\r\n                BuyTicket memory ticket = BuyTicket({account: msg.sender, amount: amount, time: time()});\r\n                pushQueue(ticket);\r\n            }\r\n\r\n        } else { // first stage\r\n            require(lowerLimitForToday() <= msg.value); // check min. limit\r\n            require(amount <= availableTokens);\r\n\r\n            // send 80% to beneficiary account, another 20% stays for refunding\r\n            beneficiary.transfer(mul(div(msg.value, 5), 4));\r\n\r\n            availableTokens = sub(availableTokens, amount);\r\n            balanceOf[this] = sub(balanceOf[this], amount); // subtracts amount from seller's balance\r\n            balanceOf[msg.sender] = add(balanceOf[msg.sender], amount); // adds the amount to buyer's balance\r\n\r\n            Transfer(this, msg.sender, amount); // execute an event reflecting the change\r\n        }\r\n    }\r\n\r\n    function processPendingTickets() onlyOwner {\r\n\r\n        uint size = queueSize();\r\n        uint ptr = 0;\r\n        uint currentDay;\r\n        uint limit;\r\n        BuyTicket memory ticket;\r\n\r\n        while (ptr < size) {\r\n            currentDay = lastProcessedDay + 1;\r\n            limit = maxDailyCap - dailyTotals[currentDay];\r\n\r\n            // stop then trying to process future\r\n            if (startTime + (currentDay - 1) * 1 days > time()) {\r\n                return;\r\n            }\r\n\r\n            // limit to prevent out of gas error\r\n            if (ptr > 50) {\r\n                return;\r\n            }\r\n\r\n            ticket = peekQueue();\r\n\r\n            if (limit < ticket.amount || ticket.time - 1000 seconds > startTime + (currentDay - 1) * 1 days) {\r\n                lastProcessedDay += 1;\r\n                continue;\r\n            }\r\n\r\n            popQueue();\r\n            ptr += 1;\r\n\r\n            availableTokens = sub(availableTokens, ticket.amount);\r\n            queuedAmount = sub(queuedAmount, ticket.amount);\r\n            dailyTotals[currentDay] = add(dailyTotals[currentDay], ticket.amount);\r\n            balanceOf[this] = sub(balanceOf[this], ticket.amount);\r\n            balanceOf[ticket.account] = add(balanceOf[ticket.account], ticket.amount); // adds the amount to buyer's balance\r\n\r\n            Transfer(this, ticket.account, ticket.amount); // execute an event reflecting the change\r\n        }\r\n    }\r\n\r\n    function() payable {\r\n        buy();\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"time\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"refundDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastProcessedDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstStageDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"standard\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"availableTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"refundStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"queuedAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dailyTotals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"processPendingTickets\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamAndExpertsTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"expertsAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"scheduledTopUp\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastScheduledTopUp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"today\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"queueSize\",\"outputs\":[{\"name\":\"r\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeRefund\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"dayFor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cTime\",\"type\":\"uint256\"}],\"name\":\"setCTime\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxDailyCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lowerLimitForToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"q\",\"outputs\":[{\"name\":\"front\",\"type\":\"uint256\"},{\"name\":\"back\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_expertsAccount\",\"type\":\"address\"},{\"name\":\"_teamAccount\",\"type\":\"address\"},{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_refundStartTime\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"DeCenterToken","CompilerVersion":"v0.4.13+commit.fb4cb1a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000aa497f2151a40031c08d7f555410e596062d623f0000000000000000000000002aec4e278a317c82abe00c9e46a9911b7d1d50690000000000000000000000002464e4a93d6b61ba9962b42674eeb30c391fa4cd00000000000000000000000000000000000000000000000000000000596d4f8000000000000000000000000000000000000000000000000000000000596ff280","Library":"","SwarmSource":"bzzr://874234260b5ed5870686f70dfb6a3edbcad5f4914e884baf062ab6983e5c7d34"}]}