{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\ncontract helper {\r\n    \r\n    function derive_sha256(string key, uint rounds) \r\n        public pure returns(bytes32 hash){\r\n        if (rounds == 0) rounds = 1;\r\n        hash = sha256(key);  \r\n        for (uint i = 0; i < rounds-1; i++) {\r\n            hash = sha256(hash);  \r\n        }\r\n    }\r\n    \r\n    function blind_sha256(string key, address caller) \r\n        public pure returns(bytes32 challenge){\r\n        challenge = sha256(sha256(key),caller);\r\n    }\r\n    \r\n    function double_blind_sha256(string key, address caller, address receiver) \r\n        public pure returns(bytes32 challenge){\r\n        challenge = sha256(sha256(sha256(key),caller),receiver);\r\n    }\r\n    \r\n}\r\ncontract owned {\r\n    address public owner;\r\n    \r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    /* Constructor */\r\n    function owned() public {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n}\r\n\r\ncontract QuantumLocksmith is owned, helper {\r\n    uint public m_pending;\r\n\r\n    struct lock {\r\n        bool alive;\r\n        bool proven;\r\n        uint balance;\r\n        string protocol;\r\n        string key;\r\n        address owner;\r\n    }\r\n    \r\n    mapping(bytes32 => lock) public locks;\r\n\r\n    // challenge the original owner validity\r\n    function QuantumLocksmith(bytes32 ownerChallenge) public payable {\r\n        require(uint(ownerChallenge) > 0);\r\n        locks[ownerChallenge].alive = true;\r\n        locks[ownerChallenge].balance = msg.value;\r\n        m_pending++;\r\n    }\r\n    \r\n    function lockDeposit(bytes32 challenge, string _protocol) public payable {\r\n        require(uint(challenge) > 0);\r\n        require(msg.value > 0);\r\n        require(!locks[challenge].alive);\r\n        locks[challenge].alive = true;\r\n        locks[challenge].balance = msg.value;\r\n        locks[challenge].owner = msg.sender;\r\n        m_pending++;\r\n        if (bytes(_protocol).length > 0) locks[challenge].protocol = _protocol;\r\n    }\r\n    \r\n    function unlockDeposit(\r\n        string key, \r\n        address receiver\r\n    ) public {\r\n        require(bytes(key).length > 0);\r\n        // generate the challenge\r\n        bytes32 k = sha256(sha256(key),msg.sender);\r\n        address to = msg.sender;\r\n        if (uint(receiver) > 0) {\r\n            to = receiver;\r\n            k = sha256(k,receiver);\r\n        }\r\n        if (locks[k].alive && !locks[k].proven) \r\n        {\r\n            locks[k].proven = true;\r\n            locks[k].key = key;\r\n            m_pending--;\r\n            uint sendValue = locks[k].balance;\r\n            if (sendValue > 0) {\r\n                locks[k].balance = 0;\r\n                require(to.send(sendValue));\r\n            }\r\n        }\r\n    }\r\n    \r\n    function depositToLock(bytes32 challenge) public payable {\r\n        require(challenge != 0x0);\r\n        require(msg.value > 0);\r\n        require(locks[challenge].alive && !locks[challenge].proven);\r\n        locks[challenge].balance += msg.value;\r\n    }\r\n    \r\n    // do not allow this\r\n    function() public payable { \r\n        require(msg.value == 0);\r\n    }\r\n    \r\n    function kill(string key) public {\r\n        if (msg.sender == owner) {\r\n            bytes32 k = sha256(sha256(key),msg.sender);\r\n            if (locks[k].alive && !locks[k].proven) \r\n                selfdestruct(owner); \r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"challenge\",\"type\":\"bytes32\"}],\"name\":\"depositToLock\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"key\",\"type\":\"string\"},{\"name\":\"rounds\",\"type\":\"uint256\"}],\"name\":\"derive_sha256\",\"outputs\":[{\"name\":\"hash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"key\",\"type\":\"string\"},{\"name\":\"caller\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"double_blind_sha256\",\"outputs\":[{\"name\":\"challenge\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_pending\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"key\",\"type\":\"string\"},{\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"blind_sha256\",\"outputs\":[{\"name\":\"challenge\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"challenge\",\"type\":\"bytes32\"},{\"name\":\"_protocol\",\"type\":\"string\"}],\"name\":\"lockDeposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"key\",\"type\":\"string\"},{\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"unlockDeposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"key\",\"type\":\"string\"}],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"locks\",\"outputs\":[{\"name\":\"alive\",\"type\":\"bool\"},{\"name\":\"proven\",\"type\":\"bool\"},{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"protocol\",\"type\":\"string\"},{\"name\":\"key\",\"type\":\"string\"},{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"ownerChallenge\",\"type\":\"bytes32\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"QuantumLocksmith","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"5e9650243d58865fd0fbabad618918ea2ba455d4b5b615552bf2c0b27424679a","Library":"","SwarmSource":"bzzr://ee18f56f4072cca955d20dde3bf37802c488b0fa480bb9d30fc83c4fd58ad40a"}]}