{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n/*\r\nAuthor:     www.purplethrone.com\r\nEmail:      aziz@purplethrone.com\r\n\r\n\r\n*/\r\n// Math contract to avoid overflow and underflow of variables\r\ncontract SafeMath {\r\n\r\n    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\r\n      uint256 z = x + y;\r\n      assert((z >= x) && (z >= y));\r\n      return z;\r\n    }\r\n\r\n    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\r\n      assert(x >= y);\r\n      uint256 z = x - y;\r\n      return z;\r\n    }\r\n\r\n    function safeMult(uint256 x, uint256 y) internal returns(uint256) {\r\n      uint256 z = x * y;\r\n      assert((x == 0)||(z/x == y));\r\n      return z;\r\n    }\r\n\r\n}\r\n// Abstracct of ERC20 Token\r\ncontract Token {\r\n    uint256 public totalSupply;\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\n/*  Implementation of ERC20 token standard functions */\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n      if (balances[msg.sender] >= _value && _value > 0) {\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n      if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n/**\r\n* @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n* account.\r\n*/\r\nfunction Ownable() {\r\n  owner = msg.sender;\r\n}\r\n/**\r\n* @dev Throws if called by any account other than the owner.\r\n*/\r\nmodifier onlyOwner() {\r\n  require(msg.sender == owner);\r\n_;\r\n}\r\n/**\r\n* @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n* @param newOwner The address to transfer ownership to.\r\n*/\r\nfunction transferOwnership(address newOwner) onlyOwner {\r\n  if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n  }\r\n}\r\n\r\n}\r\n\r\n\r\ncontract PPCToken is StandardToken,Ownable, SafeMath {\r\n\r\n    // crowdsale parameters\r\n    string  public constant name = \"PPCCoin\";\r\n    string  public constant symbol = \"PPC\";\r\n    uint256 public constant decimals = 18;\r\n    string  public version = \"1.0\";\r\n    address public constant ethFundDeposit= 0x20D9053d3f7fccC069c9a8e7dDEf5374CD22b6C8;                         // Deposit address for ETH\r\n    bool public emergencyFlag;                                      //  Switched to true in  crownsale end  state\r\n    uint256 public fundingStartBlock;                              //   Starting blocknumber\r\n    uint256 public fundingEndBlock;                               //    Ending blocknumber\r\n    uint256 public constant minTokenPurchaseAmount= .008 ether;  //     Minimum purchase\r\n    uint256 public constant tokenPreSaleRate=800;    // PPCCoin per 1 ETH during presale\r\n    uint256 public constant tokenCrowdsaleRate=500; //  PPCCoin per 1 ETH during crowdsale\r\n    uint256 public constant tokenCreationPreSaleCap =  10 * (10**6) * 10**decimals;// 10 million token cap for presale\r\n    uint256 public constant tokenCreationCap =  100 * (10**6) * 10**decimals;      //  100 million token generated\r\n    uint256 public constant preSaleBlockNumber = 169457;\r\n    uint256 public finalBlockNumber =370711;\r\n\r\n\r\n    // events\r\n    event CreatePPC(address indexed _to, uint256 _value);// Return address of buyer and purchase token\r\n    event Mint(address indexed _to,uint256 _value);     //  Reutn address to which we send the mint token and token assigned.\r\n    // Constructor\r\n    function PPCToken(){\r\n      emergencyFlag = false;                             // False at initialization will be false during ICO\r\n      fundingStartBlock = block.number;                 //  Current deploying block number is the starting block number for ICO\r\n      fundingEndBlock=safeAdd(fundingStartBlock,finalBlockNumber);  //   Ending time depending upon the block number\r\n    }\r\n\r\n    /**\r\n    * @dev creates new PPC tokens\r\n    *      It is a internal function it will be called by fallback function or buyToken functions.\r\n    */\r\n    function createTokens() internal  {\r\n      if (emergencyFlag) revert();                     //  Revert when the sale is over before time and emergencyFlag is true.\r\n      if (block.number > fundingEndBlock) revert();   //   If the blocknumber exceed the ending block it will revert\r\n      if (msg.value<minTokenPurchaseAmount)revert();  //    If someone send 0.08 ether it will fail\r\n      uint256 tokenExchangeRate=tokenRate();        //     It will get value depending upon block number and presale cap\r\n      uint256 tokens = safeMult(msg.value, tokenExchangeRate);//  Calculating number of token for sender\r\n      totalSupply = safeAdd(totalSupply, tokens);            //   Add token to total supply\r\n      if(totalSupply>tokenCreationCap)revert();             //    Check the total supply if it is more then hardcap it will throw\r\n      balances[msg.sender] += tokens;                      //     Adding token to sender account\r\n      forwardfunds();                                     //      forwardfunds to the owner\r\n      CreatePPC(msg.sender, tokens);                      //      Logs sender address and  token creation\r\n    }\r\n\r\n    /**\r\n    * @dev people can access contract and choose buyToken function to get token\r\n    *It is used by using myetherwallet\r\n    *It is a payable function it will be called by sender.\r\n    */\r\n    function buyToken() payable external{\r\n      createTokens();   // This will call the internal createToken function to get token\r\n    }\r\n\r\n    /**\r\n    * @dev      it is a internal function called by create function to get the amount according to the blocknumber.\r\n    * @return   It will return the token price at a particular time.\r\n    */\r\n    function tokenRate() internal returns (uint256 _tokenPrice){\r\n      // It is a presale it will return price for presale\r\n      if(block.number<safeAdd(fundingStartBlock,preSaleBlockNumber)&&(totalSupply<tokenCreationPreSaleCap)){\r\n          return tokenPreSaleRate;\r\n        }else\r\n            return tokenCrowdsaleRate;\r\n    }\r\n\r\n    /**\r\n    * @dev     it will  assign token to a particular address by owner only\r\n    * @param   _to the address whom you want to send token to\r\n    * @param   _amount the amount you want to send\r\n    * @return  It will return true if success.\r\n    */\r\n    function mint(address _to, uint256 _amount) external onlyOwner returns (bool) {\r\n      if (emergencyFlag) revert();\r\n      totalSupply = safeAdd(totalSupply,_amount);// Add the minted token to total suppy\r\n      if(totalSupply>tokenCreationCap)revert();\r\n      balances[_to] +=_amount;                 //   Adding token to the input address\r\n      Mint(_to, _amount);                     //    Log the mint with address and token given to particular address\r\n      return true;\r\n    }\r\n\r\n    /**\r\n    * @dev     it will change the ending date of ico and access by owner only\r\n    * @param   _newBlock enter the future blocknumber\r\n    * @return  It will return the blocknumber\r\n    */\r\n    function changeEndBlock(uint256 _newBlock) external onlyOwner returns (uint256 _endblock )\r\n    {   // we are expecting that owner will input number greater than current block.\r\n        require(_newBlock > fundingStartBlock);\r\n        fundingEndBlock = _newBlock;         // New block is assigned to extend the Crowd Sale time\r\n        return fundingEndBlock;\r\n    }\r\n\r\n    /**\r\n    * @dev   it will let Owner withdrawn ether at any time during the ICO\r\n    **/\r\n    function drain() external onlyOwner {\r\n        if (!ethFundDeposit.send(this.balance)) revert();// It will revert if transfer fails.\r\n    }\r\n\r\n    \r\n    \r\n    // Automate the ETH drain\r\n    \r\n    function forwardfunds() internal {\r\n         if (!ethFundDeposit.send(this.balance)) revert(); // It will revert if transfer fails.\r\n        \r\n        \r\n    }\r\n    \r\n    /**\r\n    * @dev  it will let Owner Stop the crowdsale and mint function to work.\r\n    *\r\n    */\r\n    \r\n    function emergencyToggle() external onlyOwner{\r\n      emergencyFlag = !emergencyFlag;\r\n    }\r\n\r\n    // Fallback function let user send ether without calling the buy function.\r\n    function() payable {\r\n      createTokens();\r\n\r\n    }\r\n\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"emergencyToggle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenPreSaleRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenCreationPreSaleCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"preSaleBlockNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenCreationCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalBlockNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newBlock\",\"type\":\"uint256\"}],\"name\":\"changeEndBlock\",\"outputs\":[{\"name\":\"_endblock\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingEndBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minTokenPurchaseAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"drain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyToken\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethFundDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"emergencyFlag\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingStartBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenCrowdsaleRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"CreatePPC\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"PPCToken","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://808e6afce38f7c2784dcc7d2be8dee721d220a81ceb4f154ecea31aacba5bf55"}]}