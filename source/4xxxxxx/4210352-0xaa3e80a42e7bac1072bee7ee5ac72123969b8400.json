{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.15;\r\n\r\npragma solidity 0.4.15;\r\n\r\n/**\r\n * @title MultiOwnable\r\n * allows creating contracts with up to 16 owners with their shares\r\n */\r\ncontract MultiOwnable {\r\n    /** a single owner record */\r\n    struct Owner {\r\n        address recipient;\r\n        uint share;\r\n    }\r\n\r\n    /** contract owners */\r\n    Owner[] public owners;\r\n\r\n    /**\r\n     * Returns total owners count\r\n     * @return count - owners count\r\n     */\r\n    function ownersCount ()   constant   returns (uint count) {  \r\n        return owners.length;\r\n    }\r\n\r\n    /**\r\n     * Returns owner's info\r\n     * @param  idx - index of the owner\r\n     * @return owner - owner's info\r\n     */\r\n    function owner (uint idx)   constant   returns (address owner_dot_recipient, uint owner_dot_share) {  \r\nOwner memory owner;\r\n\r\n        owner = owners[idx];\r\n    owner_dot_recipient = address(owner.recipient);\r\nowner_dot_share = uint(owner.share);}\r\n\r\n    /** reverse lookup helper */\r\n    mapping (address => bool) ownersIdx;\r\n\r\n    /**\r\n     * Creates the contract with up to 16 owners\r\n     * shares must be > 0\r\n     */\r\n    function MultiOwnable (address[16] _owners_dot_recipient, uint[16] _owners_dot_share)   {  \r\nOwner[16] memory _owners;\r\n\r\nfor(uint __recipient_iterator__ = 0; __recipient_iterator__ < _owners_dot_recipient.length;__recipient_iterator__++)\r\n  _owners[__recipient_iterator__].recipient = address(_owners_dot_recipient[__recipient_iterator__]);\r\nfor(uint __share_iterator__ = 0; __share_iterator__ < _owners_dot_share.length;__share_iterator__++)\r\n  _owners[__share_iterator__].share = uint(_owners_dot_share[__share_iterator__]);\r\n        for(var idx = 0; idx < _owners_dot_recipient.length; idx++) {\r\n            if(_owners[idx].recipient != 0) {\r\n                owners.push(_owners[idx]);\r\n                assert(owners[idx].share > 0);\r\n                ownersIdx[_owners[idx].recipient] = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Function with this modifier can be called only by one of owners\r\n     */\r\n    modifier onlyOneOfOwners() {\r\n        require(ownersIdx[msg.sender]);\r\n        _;\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\npragma solidity 0.4.15;\r\n\r\npragma solidity 0.4.15;\r\n\r\n/**\r\n * Basic interface for contracts, following ERC20 standard\r\n */\r\ncontract ERC20Token {\r\n    \r\n\r\n    /**\r\n     * Triggered when tokens are transferred.\r\n     * @param from - address tokens were transfered from\r\n     * @param to - address tokens were transfered to\r\n     * @param value - amount of tokens transfered\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * Triggered whenever allowance status changes\r\n     * @param owner - tokens owner, allowance changed for\r\n     * @param spender - tokens spender, allowance changed for\r\n     * @param value - new allowance value (overwriting the old value)\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * Returns total supply of tokens ever emitted\r\n     * @return totalSupply - total supply of tokens ever emitted\r\n     */\r\n    function totalSupply() constant returns (uint256 totalSupply);\r\n\r\n    /**\r\n     * Returns `owner` balance of tokens\r\n     * @param owner address to request balance for\r\n     * @return balance - token balance of `owner`\r\n     */\r\n    function balanceOf(address owner) constant returns (uint256 balance);\r\n\r\n    /**\r\n     * Transfers `amount` of tokens to `to` address\r\n     * @param  to - address to transfer to\r\n     * @param  value - amount of tokens to transfer\r\n     * @return success - `true` if the transfer was succesful, `false` otherwise\r\n     */\r\n    function transfer(address to, uint256 value) returns (bool success);\r\n\r\n    /**\r\n     * Transfers `value` tokens from `from` address to `to`\r\n     * the sender needs to have allowance for this operation\r\n     * @param  from - address to take tokens from\r\n     * @param  to - address to send tokens to\r\n     * @param  value - amount of tokens to send\r\n     * @return success - `true` if the transfer was succesful, `false` otherwise\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) returns (bool success);\r\n\r\n    /**\r\n     * Allow spender to withdraw from your account, multiple times, up to the value amount.\r\n     * If this function is called again it overwrites the current allowance with `value`.\r\n     * this function is required for some DEX functionality\r\n     * @param spender - address to give allowance to\r\n     * @param value - the maximum amount of tokens allowed for spending\r\n     * @return success - `true` if the allowance was given, `false` otherwise\r\n     */\r\n    function approve(address spender, uint256 value) returns (bool success);\r\n\r\n    /**\r\n     * Returns the amount which `spender` is still allowed to withdraw from `owner`\r\n     * @param  owner - tokens owner\r\n     * @param  spender - addres to request allowance for\r\n     * @return remaining - remaining allowance (token count)\r\n     */\r\n    function allowance(address owner, address spender) constant returns (uint256 remaining);\r\n}\r\n\r\n\r\n/**\r\n * @title Blind Croupier Token\r\n * WIN fixed supply Token, used for Blind Croupier TokenDistribution\r\n */\r\n contract WIN is ERC20Token {\r\n    \r\n\r\n    string public constant symbol = \"WIN\";\r\n    string public constant name = \"WIN\";\r\n\r\n    uint8 public constant decimals = 7;\r\n    uint256 constant TOKEN = 10**7;\r\n    uint256 constant MILLION = 10**6;\r\n    uint256 public totalTokenSupply = 500 * MILLION * TOKEN;\r\n\r\n    /** balances of each accounts */\r\n    mapping(address => uint256) balances;\r\n\r\n    /** amount of tokens approved for transfer */\r\n    mapping(address => mapping (address => uint256)) allowed;\r\n\r\n    /** Triggered when `owner` destroys `amount` tokens */\r\n    event Destroyed(address indexed owner, uint256 amount);\r\n\r\n    /**\r\n     * Constucts the token, and supplies the creator with `totalTokenSupply` tokens\r\n     */\r\n    function WIN ()   { \r\n        balances[msg.sender] = totalTokenSupply;\r\n    }\r\n\r\n    /**\r\n     * Returns total supply of tokens ever emitted\r\n     * @return result - total supply of tokens ever emitted\r\n     */\r\n    function totalSupply ()  constant  returns (uint256 result) { \r\n        result = totalTokenSupply;\r\n    }\r\n\r\n    /**\r\n    * Returns `owner` balance of tokens\r\n    * @param owner address to request balance for\r\n    * @return balance - token balance of `owner`\r\n    */\r\n    function balanceOf (address owner)  constant  returns (uint256 balance) { \r\n        return balances[owner];\r\n    }\r\n\r\n    /**\r\n     * Transfers `amount` of tokens to `to` address\r\n     * @param  to - address to transfer to\r\n     * @param  amount - amount of tokens to transfer\r\n     * @return success - `true` if the transfer was succesful, `false` otherwise\r\n     */\r\n    function transfer (address to, uint256 amount)   returns (bool success) { \r\n        if(balances[msg.sender] < amount)\r\n            return false;\r\n\r\n        if(amount <= 0)\r\n            return false;\r\n\r\n        if(balances[to] + amount <= balances[to])\r\n            return false;\r\n\r\n        balances[msg.sender] -= amount;\r\n        balances[to] += amount;\r\n        Transfer(msg.sender, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Transfers `amount` tokens from `from` address to `to`\r\n     * the sender needs to have allowance for this operation\r\n     * @param  from - address to take tokens from\r\n     * @param  to - address to send tokens to\r\n     * @param  amount - amount of tokens to send\r\n     * @return success - `true` if the transfer was succesful, `false` otherwise\r\n     */\r\n    function transferFrom (address from, address to, uint256 amount)   returns (bool success) { \r\n        if (balances[from] < amount)\r\n            return false;\r\n\r\n        if(allowed[from][msg.sender] < amount)\r\n            return false;\r\n\r\n        if(amount == 0)\r\n            return false;\r\n\r\n        if(balances[to] + amount <= balances[to])\r\n            return false;\r\n\r\n        balances[from] -= amount;\r\n        allowed[from][msg.sender] -= amount;\r\n        balances[to] += amount;\r\n        Transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Allow spender to withdraw from your account, multiple times, up to the amount amount.\r\n     * If this function is called again it overwrites the current allowance with `amount`.\r\n     * this function is required for some DEX functionality\r\n     * @param spender - address to give allowance to\r\n     * @param amount - the maximum amount of tokens allowed for spending\r\n     * @return success - `true` if the allowance was given, `false` otherwise\r\n     */\r\n    function approve (address spender, uint256 amount)   returns (bool success) { \r\n       allowed[msg.sender][spender] = amount;\r\n       Approval(msg.sender, spender, amount);\r\n       return true;\r\n   }\r\n\r\n    /**\r\n     * Returns the amount which `spender` is still allowed to withdraw from `owner`\r\n     * @param  owner - tokens owner\r\n     * @param  spender - addres to request allowance for\r\n     * @return remaining - remaining allowance (token count)\r\n     */\r\n    function allowance (address owner, address spender)  constant  returns (uint256 remaining) { \r\n        return allowed[owner][spender];\r\n    }\r\n\r\n     /**\r\n      * Destroys `amount` of tokens permanently, they cannot be restored\r\n      * @return success - `true` if `amount` of tokens were destroyed, `false` otherwise\r\n      */\r\n    function destroy (uint256 amount)   returns (bool success) { \r\n        if(amount == 0) return false;\r\n        if(balances[msg.sender] < amount) return false;\r\n        balances[msg.sender] -= amount;\r\n        totalTokenSupply -= amount;\r\n        Destroyed(msg.sender, amount);\r\n    }\r\n}\r\n\r\npragma solidity 0.4.15;\r\n\r\n/**\r\n * @title Various Math utilities\r\n */\r\nlibrary Math {\r\n     /** 1/1000, 1000 uint = 1 */\r\n\r\n    /**\r\n     * Returns `promille` promille of `value`\r\n     * e.g. `takePromille(5000, 1) == 5`\r\n     * @param value - uint to take promille value\r\n     * @param promille - promille value\r\n     * @return result - `value * promille / 1000`\r\n     */\r\n    function takePromille (uint value, uint promille)  constant  returns (uint result) { \r\n        result = value * promille / 1000;\r\n    }\r\n\r\n    /**\r\n     * Returns `value` with added `promille` promille\r\n     * @param value - uint to add promille to\r\n     * @param promille - promille value to add\r\n     * @return result - `value + value * promille / 1000`\r\n     */\r\n    function addPromille (uint value, uint promille)  constant  returns (uint result) { \r\n        result = value + takePromille(value, promille);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Blind Croupier TokenDistribution\r\n * It possesses some `WIN` tokens.\r\n * The distribution is divided into many 'periods'.\r\n * The zero one is `Presale` with `TOKENS_FOR_PRESALE` tokens\r\n * It's ended when all tokens are sold or manually with `endPresale()` function\r\n * The length of first period is `FIRST_PERIOD_DURATION`.\r\n * The length of other periods is `PERIOD_DURATION`.\r\n * During each period, `TOKENS_PER_PERIOD` are offered for sale (`TOKENS_PER_FIRST_PERIOD` for the first one)\r\n * Investors send their money to the contract\r\n * and call `claimAllTokens()` function to get `WIN` tokens.\r\n * Period 0 Token price is `PRESALE_TOKEN_PRICE`\r\n * Period 1 Token price is `SALE_INITIAL_TOKEN_PRICE`\r\n * Period 2+ price is determined by the following rules:\r\n * If more than `TOKENS_TO_INCREASE_NEXT_PRICE * TOKENS_PER_PERIOD / 1000`\r\n * were sold during the period, the price of the Tokens for the next period\r\n * is increased by `PERIOD_PRICE_INCREASE` promille,\r\n * if ALL tokens were sold, price is increased by `FULLY_SOLD_PRICE_INCREASE` promille\r\n * Otherwise, the price remains the same.\r\n */\r\ncontract BlindCroupierTokenDistribution is MultiOwnable {\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\r\n    uint256 constant TOKEN = 10**7;\r\n    uint256 constant MILLION = 10**6;\r\n\r\n    uint256 constant MINIMUM_DEPOSIT = 100 finney; /** minimum deposit accepted to bank */\r\n    uint256 constant PRESALE_TOKEN_PRICE = 0.00035 ether / TOKEN;\r\n    uint256 constant SALE_INITIAL_TOKEN_PRICE = 0.0005 ether / TOKEN;\r\n\r\n    uint256 constant TOKENS_FOR_PRESALE = 5 * MILLION * TOKEN; /** 5M tokens */\r\n    uint256 constant TOKENS_PER_FIRST_PERIOD = 15 * MILLION * TOKEN; /** 15M tokens */\r\n    uint256 constant TOKENS_PER_PERIOD = 1 * MILLION * TOKEN; /** 1M tokens */\r\n    uint256 constant FIRST_PERIOD_DURATION = 161 hours; /** duration of 1st sale period */\r\n    uint256 constant PERIOD_DURATION = 23 hours; /** duration of all other sale periods */\r\n    uint256 constant PERIOD_PRICE_INCREASE = 5; /** `next_token_price = old_token_price + old_token_price * PERIOD_PRICE_INCREASE / 1000` */\r\n    uint256 constant FULLY_SOLD_PRICE_INCREASE = 10; /** to increase price if ALL tokens sold */\r\n    uint256 constant TOKENS_TO_INCREASE_NEXT_PRICE = 800; /** the price is increased if `sold_tokens > period_tokens * TOKENS_TO_INCREASE_NEXT_PRICE / 1000` */\r\n\r\n    uint256 constant NEVER = 0;\r\n    uint16 constant UNKNOWN_COUNTRY = 0;\r\n\r\n    /**\r\n     * State of Blind Croupier crowdsale\r\n     */\r\n    enum State {\r\n        NotStarted,\r\n        Presale,\r\n        Sale\r\n    }\r\n\r\n    uint256 public totalUnclaimedTokens; /** total amount of tokens, TokenDistribution owns to investors */\r\n    uint256 public totalTokensSold; /** total amount of Tokens sold during the TokenDistribution */\r\n    uint256 public totalTokensDestroyed; /** total amount of Tokens destroyed by this contract */\r\n\r\n    mapping(address => uint256) public unclaimedTokensForInvestor; /** unclaimed tokens for each investor */\r\n\r\n    /**\r\n     * One token sale period information\r\n     */\r\n    struct Period {\r\n        uint256 startTime;\r\n        uint256 endTime;\r\n        uint256 tokenPrice;\r\n        uint256 tokensSold;\r\n    }\r\n\r\n    /**\r\n     * Emited when `investor` sends `amount` of money to the Bank\r\n     * @param investor - address, sending the money\r\n     * @param amount - Wei sent\r\n     */\r\n    event Deposited(address indexed investor, uint256 amount, uint256 tokenCount);\r\n\r\n    /**\r\n     * Emited when a new period is opened\r\n     * @param periodIndex - index of new period\r\n     * @param tokenPrice - price of WIN Token in new period\r\n     */\r\n    event PeriodStarted(uint periodIndex, uint256 tokenPrice, uint256 tokensToSale, uint256 startTime, uint256 endTime, uint256 now);\r\n\r\n    /**\r\n     * Emited when `investor` claims `claimed` tokens\r\n     * @param investor - address getting the Tokens\r\n     * @param claimed - amount of Tokens claimed\r\n     */\r\n    event TokensClaimed(address indexed investor, uint256 claimed);\r\n\r\n    /** current Token sale period */\r\n    uint public currentPeriod = 0;\r\n\r\n    /** information about past and current periods, by periods index, starting from `0` */\r\n    mapping(uint => Period) periods;\r\n\r\n    /** WIN tokens contract  */\r\n    WIN public win;\r\n\r\n    /** The state of the crowdsale - `NotStarted`, `Presale`, `Sale` */\r\n    State public state;\r\n\r\n    /** the counter of investment by a country code (3-digit ISO 3166 code) */\r\n    mapping(uint16 => uint256) investmentsByCountries;\r\n\r\n    /**\r\n     * Returns amount of Wei invested by the specified country\r\n     * @param country - 3-digit country code\r\n     */\r\n    function getInvestmentsByCountry (uint16 country)   constant   returns (uint256 investment) {  \r\n        investment = investmentsByCountries[country];\r\n    }\r\n\r\n    /**\r\n     * Returns the Token price in the current period\r\n     * @return tokenPrice - current Token price\r\n     */\r\n    function getTokenPrice ()   constant   returns (uint256 tokenPrice) {  \r\n        tokenPrice = periods[currentPeriod].tokenPrice;\r\n    }\r\n\r\n    /**\r\n     * Returns the Token price for the period requested\r\n     * @param periodIndex - the period index\r\n     * @return tokenPrice - Token price for the period\r\n     */\r\n    function getTokenPriceForPeriod (uint periodIndex)   constant   returns (uint256 tokenPrice) {  \r\n        tokenPrice = periods[periodIndex].tokenPrice;\r\n    }\r\n\r\n    /**\r\n     * Returns the amount of Tokens sold\r\n     * @param period - period index to get tokens for\r\n     * @return tokensSold - amount of tokens sold\r\n     */\r\n    function getTokensSold (uint period)   constant   returns (uint256 tokensSold) {  \r\n        return periods[period].tokensSold;\r\n    }\r\n\r\n    /**\r\n     * Returns `true` if TokenDistribution has enough tokens for the current period\r\n     * and thus going on\r\n     * @return active - `true` if TokenDistribution is going on, `false` otherwise\r\n     */\r\n    function isActive ()   constant   returns (bool active) {  \r\n        return win.balanceOf(this) >= totalUnclaimedTokens + tokensForPeriod(currentPeriod) - periods[currentPeriod].tokensSold;\r\n    }\r\n\r\n    /**\r\n     * Accepts money deposit and makes record\r\n     * minimum deposit is MINIMUM_DEPOSIT\r\n     * @param beneficiar - the address to receive Tokens\r\n     * @param countryCode - 3-digit country code\r\n     * @dev if `msg.value < MINIMUM_DEPOSIT` throws\r\n     */\r\n    function deposit (address beneficiar, uint16 countryCode)   payable  {  \r\n        require(msg.value >= MINIMUM_DEPOSIT);\r\n        require(state == State.Sale || state == State.Presale);\r\n\r\n        /* this should end any finished period before starting any operations */\r\n        tick();\r\n\r\n        /* check if have enough tokens for the current period\r\n         * if not, the call fails until tokens are deposited to the contract\r\n         */\r\n        require(isActive());\r\n\r\n        uint256 tokensBought = msg.value / getTokenPrice();\r\n\r\n        if(periods[currentPeriod].tokensSold + tokensBought >= tokensForPeriod(currentPeriod)) {\r\n            tokensBought = tokensForPeriod(currentPeriod) - periods[currentPeriod].tokensSold;\r\n        }\r\n\r\n        uint256 moneySpent = getTokenPrice() * tokensBought;\r\n\r\n        investmentsByCountries[countryCode] += moneySpent;\r\n\r\n        if(tokensBought > 0) {\r\n            assert(moneySpent <= msg.value);\r\n\r\n            /* return the rest */\r\n            if(msg.value > moneySpent) {\r\n                msg.sender.transfer(msg.value - moneySpent);\r\n            }\r\n\r\n            periods[currentPeriod].tokensSold += tokensBought;\r\n            unclaimedTokensForInvestor[beneficiar] += tokensBought;\r\n            totalUnclaimedTokens += tokensBought;\r\n            totalTokensSold += tokensBought;\r\n            Deposited(msg.sender, moneySpent, tokensBought);\r\n        }\r\n\r\n        /* if all tokens are sold, get to the next period */\r\n        tick();\r\n    }\r\n\r\n    /**\r\n     * See `deposit` function\r\n     */\r\n    function() payable {\r\n        deposit(msg.sender, UNKNOWN_COUNTRY);\r\n    }\r\n\r\n    /**\r\n     * Creates the contract and sets the owners\r\n     * @param owners_dot_recipient - array of 16 owner records  (MultiOwnable.Owner.recipient fields)\r\n* @param owners_dot_share - array of 16 owner records  (MultiOwnable.Owner.share fields)\r\n     */\r\n    function BlindCroupierTokenDistribution (address[16] owners_dot_recipient, uint[16] owners_dot_share)   MultiOwnable(owners_dot_recipient, owners_dot_share)  {  \r\nMultiOwnable.Owner[16] memory owners;\r\n\r\nfor(uint __recipient_iterator__ = 0; __recipient_iterator__ < owners_dot_recipient.length;__recipient_iterator__++)\r\n  owners[__recipient_iterator__].recipient = address(owners_dot_recipient[__recipient_iterator__]);\r\nfor(uint __share_iterator__ = 0; __share_iterator__ < owners_dot_share.length;__share_iterator__++)\r\n  owners[__share_iterator__].share = uint(owners_dot_share[__share_iterator__]);\r\n        state = State.NotStarted;\r\n    }\r\n\r\n    /**\r\n     * Begins the crowdsale (presale period)\r\n     * @param tokenContractAddress - address of the `WIN` contract (token holder)\r\n     * @dev must be called by one of owners\r\n     */\r\n    function startPresale (address tokenContractAddress)   onlyOneOfOwners  {  \r\n        require(state == State.NotStarted);\r\n\r\n        win = WIN(tokenContractAddress);\r\n\r\n        assert(win.balanceOf(this) >= tokensForPeriod(0));\r\n\r\n        periods[0] = Period(now, NEVER, PRESALE_TOKEN_PRICE, 0);\r\n        PeriodStarted(0,\r\n            PRESALE_TOKEN_PRICE,\r\n            tokensForPeriod(currentPeriod),\r\n            now,\r\n            NEVER,\r\n            now);\r\n        state = State.Presale;\r\n    }\r\n\r\n    /**\r\n     * Ends the presale and begins period 1 of the crowdsale\r\n     * @dev must be called by one of owners\r\n     */\r\n    function endPresale ()   onlyOneOfOwners  {  \r\n        require(state == State.Presale);\r\n        state = State.Sale;\r\n        nextPeriod();\r\n    }\r\n\r\n    /**\r\n     * Returns a time interval for a specific `period`\r\n     * @param  period - period index to count interval for\r\n     * @return startTime - timestamp of period start time (INCLUSIVE)\r\n     * @return endTime - timestamp of period end time (INCLUSIVE)\r\n     */\r\n    function periodTimeFrame (uint period)   constant   returns (uint256 startTime, uint256 endTime) {  \r\n        require(period <= currentPeriod);\r\n\r\n        startTime = periods[period].startTime;\r\n        endTime = periods[period].endTime;\r\n    }\r\n\r\n    /**\r\n     * Returns `true` if the time for the `period` has already passed\r\n     */\r\n    function isPeriodTimePassed (uint period)   constant   returns (bool finished) {  \r\n        require(periods[period].startTime > 0);\r\n\r\n        uint256 endTime = periods[period].endTime;\r\n\r\n        if(endTime == NEVER) {\r\n            return false;\r\n        }\r\n\r\n        return (endTime < now);\r\n    }\r\n\r\n    /**\r\n     * Returns `true` if `period` has already finished (time passed or tokens sold)\r\n     */\r\n    function isPeriodClosed (uint period)   constant   returns (bool finished) {  \r\n        return period < currentPeriod;\r\n    }\r\n\r\n    /**\r\n     * Returns `true` if all tokens for the `period` has been sold\r\n     */\r\n    function isPeriodAllTokensSold (uint period)   constant   returns (bool finished) {  \r\n        return periods[period].tokensSold == tokensForPeriod(period);\r\n    }\r\n\r\n    /**\r\n     * Returns unclaimed Tokens count for the caller\r\n     * @return tokens - amount of unclaimed Tokens for the caller\r\n     */\r\n    function unclaimedTokens ()   constant   returns (uint256 tokens) {  \r\n        return unclaimedTokensForInvestor[msg.sender];\r\n    }\r\n\r\n    /**\r\n     * Transfers all the tokens stored for this `investor` to his address\r\n     * @param investor - investor to claim tokens for\r\n     */\r\n    function claimAllTokensForInvestor (address investor)   {  \r\n        assert(totalUnclaimedTokens >= unclaimedTokensForInvestor[investor]);\r\n        totalUnclaimedTokens -= unclaimedTokensForInvestor[investor];\r\n        win.transfer(investor, unclaimedTokensForInvestor[investor]);\r\n        TokensClaimed(investor, unclaimedTokensForInvestor[investor]);\r\n        unclaimedTokensForInvestor[investor] = 0;\r\n    }\r\n\r\n    /**\r\n     * Claims all the tokens for the sender\r\n     * @dev efficiently calling `claimAllForInvestor(msg.sender)`\r\n     */\r\n    function claimAllTokens ()   {  \r\n        claimAllTokensForInvestor(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * Returns the total token count for the period specified\r\n     * @param  period - period number\r\n     * @return tokens - total tokens count\r\n     */\r\n    function tokensForPeriod (uint period)   constant   returns (uint256 tokens) {  \r\n        if(period == 0) {\r\n            return TOKENS_FOR_PRESALE;\r\n        } else if(period == 1) {\r\n            return TOKENS_PER_FIRST_PERIOD;\r\n        } else {\r\n            return TOKENS_PER_PERIOD;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the duration of the sale (not presale) period\r\n     * @param  period - the period number\r\n     * @return duration - duration in seconds\r\n     */\r\n    function periodDuration (uint period)   constant   returns (uint256 duration) {  \r\n        require(period > 0);\r\n\r\n        if(period == 1) {\r\n            return FIRST_PERIOD_DURATION;\r\n        } else {\r\n            return PERIOD_DURATION;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Finishes the current period and starts a new one\r\n     */\r\n    function nextPeriod() internal {\r\n        uint256 oldPrice = periods[currentPeriod].tokenPrice;\r\n        uint256 newPrice;\r\n        if(currentPeriod == 0) {\r\n            newPrice = SALE_INITIAL_TOKEN_PRICE;\r\n        } else if(periods[currentPeriod].tokensSold  == tokensForPeriod(currentPeriod)) {\r\n            newPrice = Math.addPromille(oldPrice, FULLY_SOLD_PRICE_INCREASE);\r\n        } else if(periods[currentPeriod].tokensSold >= Math.takePromille(tokensForPeriod(currentPeriod), TOKENS_TO_INCREASE_NEXT_PRICE)) {\r\n            newPrice = Math.addPromille(oldPrice, PERIOD_PRICE_INCREASE);\r\n        } else {\r\n            newPrice = oldPrice;\r\n        }\r\n\r\n        /* destroy unsold tokens */\r\n        if(periods[currentPeriod].tokensSold < tokensForPeriod(currentPeriod)) {\r\n            uint256 toDestroy = tokensForPeriod(currentPeriod) - periods[currentPeriod].tokensSold;\r\n            /* do not destroy if we don't have enough to pay investors */\r\n            uint256 balance = win.balanceOf(this);\r\n            if(balance < toDestroy + totalUnclaimedTokens) {\r\n                toDestroy = (balance - totalUnclaimedTokens);\r\n            }\r\n            win.destroy(toDestroy);\r\n            totalTokensDestroyed += toDestroy;\r\n        }\r\n\r\n        /* if we are force ending the period set in the future or without end time,\r\n         * set end time to now\r\n         */\r\n        if(periods[currentPeriod].endTime > now ||\r\n            periods[currentPeriod].endTime == NEVER) {\r\n            periods[currentPeriod].endTime = now;\r\n        }\r\n\r\n        uint256 duration = periodDuration(currentPeriod + 1);\r\n\r\n        periods[currentPeriod + 1] = Period(\r\n            periods[currentPeriod].endTime,\r\n            periods[currentPeriod].endTime + duration,\r\n            newPrice,\r\n            0);\r\n\r\n        currentPeriod++;\r\n\r\n        PeriodStarted(currentPeriod,\r\n            newPrice,\r\n            tokensForPeriod(currentPeriod),\r\n            periods[currentPeriod].startTime,\r\n            periods[currentPeriod].endTime,\r\n            now);\r\n    }\r\n\r\n    /**\r\n     * To be called as frequently as required by any external party\r\n     * Will check if 1 or more periods have finished and move on to the next\r\n     */\r\n    function tick ()   {  \r\n        if(!isActive()) {\r\n            return;\r\n        }\r\n\r\n        while(state == State.Sale &&\r\n            (isPeriodTimePassed(currentPeriod) ||\r\n            isPeriodAllTokensSold(currentPeriod))) {\r\n            nextPeriod();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Withdraws the money to be spent to Blind Croupier Project needs\r\n     * @param  amount - amount of Wei to withdraw (total)\r\n     */\r\n    function withdraw (uint256 amount)   onlyOneOfOwners  {  \r\n        require(this.balance >= amount);\r\n\r\n        uint totalShares = 0;\r\n        for(var idx = 0; idx < owners.length; idx++) {\r\n            totalShares += owners[idx].share;\r\n        }\r\n\r\n        for(idx = 0; idx < owners.length; idx++) {\r\n            owners[idx].recipient.transfer(amount * owners[idx].share / totalShares);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"owners\",\"outputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"share\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalUnclaimedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimAllTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"tokensForPeriod\",\"outputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isActive\",\"outputs\":[{\"name\":\"active\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"tick\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"periodIndex\",\"type\":\"uint256\"}],\"name\":\"getTokenPriceForPeriod\",\"outputs\":[{\"name\":\"tokenPrice\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"win\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenPrice\",\"outputs\":[{\"name\":\"tokenPrice\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"periodTimeFrame\",\"outputs\":[{\"name\":\"startTime\",\"type\":\"uint256\"},{\"name\":\"endTime\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"getTokensSold\",\"outputs\":[{\"name\":\"tokensSold\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensDestroyed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"country\",\"type\":\"uint16\"}],\"name\":\"getInvestmentsByCountry\",\"outputs\":[{\"name\":\"investment\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"claimAllTokensForInvestor\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"owner\",\"outputs\":[{\"name\":\"owner_dot_recipient\",\"type\":\"address\"},{\"name\":\"owner_dot_share\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endPresale\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenContractAddress\",\"type\":\"address\"}],\"name\":\"startPresale\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"isPeriodAllTokensSold\",\"outputs\":[{\"name\":\"finished\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"isPeriodTimePassed\",\"outputs\":[{\"name\":\"finished\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownersCount\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"unclaimedTokensForInvestor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unclaimedTokens\",\"outputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiar\",\"type\":\"address\"},{\"name\":\"countryCode\",\"type\":\"uint16\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"isPeriodClosed\",\"outputs\":[{\"name\":\"finished\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"periodDuration\",\"outputs\":[{\"name\":\"duration\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"owners_dot_recipient\",\"type\":\"address[16]\"},{\"name\":\"owners_dot_share\",\"type\":\"uint256[16]\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenCount\",\"type\":\"uint256\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"periodIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensToSale\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"endTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"now\",\"type\":\"uint256\"}],\"name\":\"PeriodStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"claimed\",\"type\":\"uint256\"}],\"name\":\"TokensClaimed\",\"type\":\"event\"}]","ContractName":"BlindCroupierTokenDistribution","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000b38815581e26a1a4ddd87f6e852299579d3c966d000000000000000000000000069dba3ddf3dc1477c68431e5bd3982da49771770000000000000000000000000bfdc7b5c0e4cdb33741bbe5c54a9e02bb8fcd71000000000000000000000000b016d117670b106d4e9ece7389ce8cc551e35832000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","Library":"Math:4183ffb15d5e9a7efbf6f62f1970c053663ad435","SwarmSource":"bzzr://94d6199e534d0d3f0d69e96718dc286bc534036bc692154007374dcceee2014e"}]}