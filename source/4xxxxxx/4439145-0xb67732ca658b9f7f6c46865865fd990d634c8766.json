{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n\r\nlibrary SafeMath {\r\n    function mul(uint a, uint b) internal returns (uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint a, uint b) internal returns (uint) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint a, uint b) internal returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint a, uint b) internal returns (uint) {\r\n        uint c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n}\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    function Ownable() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) onlyOwner {\r\n        require(newOwner != address(0));\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\ncontract ERC20 {\r\n    uint256 public totalSupply;\r\n    function balanceOf(address who) public constant returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    function allowance(address owner, address spender) public constant returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Burn(address indexed from, uint256 value);\r\n}\r\ncontract ROKToken is ERC20, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    string public constant name = \"ROK Token\";\r\n    string public constant symbol = \"ROK\";\r\n    uint8 public constant decimals = 18;\r\n    uint256 public constant INITIAL_SUPPLY = 100000000000000000000000000;\r\n\r\n    mapping(address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n    /**\r\n  * @dev Contructor that gives msg.sender all of existing tokens.\r\n  */\r\n    function ROKToken() {\r\n        totalSupply = INITIAL_SUPPLY;\r\n        balances[msg.sender] = INITIAL_SUPPLY;\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev transfer token for a specified address\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[msg.sender]);\r\n\r\n        // SafeMath.sub will throw if there is not enough balance.\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param _owner The address to query the the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n    /**\r\n     * @dev Transfer tokens from one address to another\r\n     * @param _from address The address which you want to send tokens from\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[_from]);\r\n        require(_value <= allowed[_from][msg.sender]);\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     *\r\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _value The amount of tokens to be spent.\r\n     */\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function unlockTransfer(address _spender, uint256 _value) public returns (bool) {\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param _owner address The address which owns the funds.\r\n     * @param _spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n     * approve should be called when allowed[_spender] == 0. To increment\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     */\r\n    function increaseApproval (address _spender, uint _addedValue) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {\r\n        uint oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    function burn(uint256 _value) public returns (bool success){\r\n        require(_value > 0);\r\n        require(_value <= balances[msg.sender]);\r\n        // no need to require value <= totalSupply, since that would imply the\r\n        // sender's balance is greater than the totalSupply, which *should* be an assertion failure\r\n\r\n        address burner = msg.sender;\r\n        balances[burner] = balances[burner].sub(_value);\r\n        totalSupply = totalSupply.sub(_value);\r\n        Burn(burner, _value);\r\n        return true;\r\n    }\r\n}\r\ncontract Pausable is Ownable {\r\n    event Pause();\r\n\r\n    event Unpause();\r\n\r\n    bool public paused = false;\r\n\r\n\r\n    /**\r\n     * @dev modifier to allow actions only when the contract IS paused\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev modifier to allow actions only when the contract IS NOT paused\r\n     */\r\n    modifier whenPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to pause, triggers stopped state\r\n     */\r\n    function pause() onlyOwner whenNotPaused {\r\n        paused = true;\r\n        Pause();\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to unpause, returns to normal state\r\n     */\r\n    function unpause() onlyOwner whenPaused {\r\n        paused = false;\r\n        Unpause();\r\n    }\r\n}\r\ncontract PullPayment {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) public payments;\r\n\r\n    uint256 public totalPayments;\r\n\r\n    /**\r\n    * @dev Called by the payer to store the sent amount as credit to be pulled.\r\n    * @param dest The destination address of the funds.\r\n    * @param amount The amount to transfer.\r\n    */\r\n    function asyncSend(address dest, uint256 amount) internal {\r\n        payments[dest] = payments[dest].add(amount);\r\n        totalPayments = totalPayments.add(amount);\r\n    }\r\n\r\n    /**\r\n    * @dev withdraw accumulated balance, called by payee.\r\n    */\r\n    function withdrawPayments() {\r\n        address payee = msg.sender;\r\n        uint256 payment = payments[payee];\r\n\r\n        require(payment != 0);\r\n        require(this.balance >= payment);\r\n\r\n        totalPayments = totalPayments.sub(payment);\r\n        payments[payee] = 0;\r\n\r\n        assert(payee.send(payment));\r\n    }\r\n}\r\n\r\n/*\r\n*  Crowdsale Smart Contract for the Rockchain project\r\n*  Author: Yosra Helal yosra.helal@rockchain.org\r\n*  Contributor: Christophe Ozcan christophe.ozcan@crypto4all.com\r\n*\r\n*\r\n*  MultiSig advisors Keys (3/5)\r\n*\r\n*  Christophe OZCAN        0x75dcB0Ba77e5f99f8ce6F01338Cb235DFE94260c\r\n*  Jeff GUILBAULT          0x94ddC32c61BC9a799CdDea87e6a1D1316198b0Fa\r\n*  Mark HAHNEL             0xFaE39043B8698CaA4F1417659B00737fa19b8ECC\r\n*  Sébastien COLLIGNON     0xd70280108EaF321E100276F6D1b105Ee088CB016\r\n*  Sébastien JEHAN         0xE4b0A48D3b1adA17000Fd080cd42DB3e8231752c\r\n*\r\n*\r\n*/\r\n\r\ncontract Crowdsale is Pausable, PullPayment {\r\n    using SafeMath for uint256;\r\n\r\n    address public owner;\r\n    ROKToken public rok;\r\n    address public escrow;                                                             // Address of Escrow Provider Wallet\r\n    address public bounty ;                                                            // Address dedicated for bounty services\r\n    address public team;                                                               // Adress for ROK token allocated to the team\r\n    uint256 public rateETH_ROK;                                                        // Rate Ether per ROK token\r\n    uint256 public constant minimumPurchase = 0.1 ether;                               // Minimum purchase size of incoming ETH\r\n    uint256 public constant maxFundingGoal = 100000 ether;                             // Maximum goal in Ether raised\r\n    uint256 public constant minFundingGoal = 18000 ether;                              // Minimum funding goal in Ether raised\r\n    uint256 public constant startDate = 1509534000;                                    // epoch timestamp representing the start date (1st november 2017 11:00 gmt)\r\n    uint256 public constant deadline = 1512126000;                                     // epoch timestamp representing the end date (1st december 2017 11:00 gmt)\r\n    uint256 public constant refundeadline = 1515927600;                                // epoch timestamp representing the end date of refund period (14th january 2018 11:00 gmt)\r\n    uint256 public savedBalance = 0;                                                   // Total amount raised in ETH\r\n    uint256 public savedBalanceToken = 0;                                              // Total ROK Token allocated\r\n    bool public crowdsaleclosed = false;                                               // To finalize crowdsale\r\n    mapping (address => uint256) balances;                                             // Balances in incoming Ether\r\n    mapping (address => uint256) balancesRokToken;                                     // Balances in ROK\r\n    mapping (address => bool) KYClist;\r\n\r\n    // Events to record new contributions\r\n    event Contribution(address indexed _contributor, uint256 indexed _value, uint256 indexed _tokens);\r\n\r\n    // Event to record each time Ether is paid out\r\n    event PayEther(\r\n    address indexed _receiver,\r\n    uint256 indexed _value,\r\n    uint256 indexed _timestamp\r\n    );\r\n\r\n    // Event to record when tokens are burned.\r\n    event BurnTokens(\r\n    uint256 indexed _value,\r\n    uint256 indexed _timestamp\r\n    );\r\n\r\n    // Initialization\r\n    function Crowdsale(){\r\n        owner = msg.sender;\r\n        // add address of the specific contract\r\n        rok = ROKToken(0xc9de4b7f0c3d991e967158e4d4bfa4b51ec0b114);\r\n        escrow = 0x049ca649c977ec36368f31762ff7220db0aae79f;\r\n        bounty = 0x50Cc6F2D548F7ecc22c9e9F994E4C0F34c7fE8d0;\r\n        team = 0x33462171A814d4eDa97Cf3a112abE218D05c53C2;\r\n        rateETH_ROK = 1000;\r\n    }\r\n\r\n\r\n    // Default Function, delegates to contribute function (for ease of use)\r\n    // WARNING: Not compatible with smart contract invocation, will exceed gas stipend!\r\n    // Only use from external accounts\r\n    function() payable whenNotPaused{\r\n        if (msg.sender == escrow){\r\n            balances[this] = msg.value;\r\n        }\r\n        else{\r\n            contribute(msg.sender);\r\n        }\r\n    }\r\n\r\n    // Contribute Function, accepts incoming payments and tracks balances for each contributors\r\n    function contribute(address contributor) internal{\r\n        require(isStarted());\r\n        require(!isComplete());\r\n        assert((savedBalance.add(msg.value)) <= maxFundingGoal);\r\n        assert(msg.value >= minimumPurchase);\r\n        balances[contributor] = balances[contributor].add(msg.value);\r\n        savedBalance = savedBalance.add(msg.value);\r\n        uint256 Roktoken = rateETH_ROK.mul(msg.value) + getBonus(rateETH_ROK.mul(msg.value));\r\n        uint256 RokToSend = (Roktoken.mul(80)).div(100);\r\n        balancesRokToken[contributor] = balancesRokToken[contributor].add(RokToSend);\r\n        savedBalanceToken = savedBalanceToken.add(Roktoken);\r\n        escrow.transfer(msg.value);\r\n        PayEther(escrow, msg.value, now);\r\n    }\r\n\r\n\r\n    // Function to check if crowdsale has started yet\r\n    function isStarted() constant returns (bool) {\r\n        return now >= startDate;\r\n    }\r\n\r\n    // Function to check if crowdsale is complete (\r\n    function isComplete() constant returns (bool) {\r\n        return (savedBalance >= maxFundingGoal) || (now > deadline) || (savedBalanceToken >= rok.totalSupply()) || (crowdsaleclosed == true);\r\n    }\r\n\r\n    // Function to view current token balance of the crowdsale contract\r\n    function tokenBalance() constant returns (uint256 balance) {\r\n        return rok.balanceOf(address(this));\r\n    }\r\n\r\n    // Function to check if crowdsale has been successful (has incoming contribution balance met, or exceeded the minimum goal?)\r\n    function isSuccessful() constant returns (bool) {\r\n        return (savedBalance >= minFundingGoal);\r\n    }\r\n\r\n    // Function to check the Ether balance of a contributor\r\n    function checkEthBalance(address _contributor) constant returns (uint256 balance) {\r\n        return balances[_contributor];\r\n    }\r\n\r\n    // Function to check the current Tokens Sold in the ICO\r\n    function checkRokSold() constant returns (uint256 total) {\r\n        return (savedBalanceToken);\r\n        // Function to check the current Tokens Sold in the ICO\r\n    }\r\n\r\n    // Function to check the current Tokens affected to the team\r\n    function checkRokTeam() constant returns (uint256 totalteam) {\r\n        return (savedBalanceToken.mul(19).div(100));\r\n        // Function to check the current Tokens affected to the team\r\n    }\r\n\r\n    // Function to check the current Tokens affected to bounty\r\n    function checkRokBounty() constant returns (uint256 totalbounty) {\r\n        return (savedBalanceToken.div(100));\r\n    }\r\n\r\n    // Function to check the refund period is over\r\n    function refundPeriodOver() constant returns (bool){\r\n        return (now > refundeadline);\r\n    }\r\n\r\n    // Function to check the refund period is over\r\n    function refundPeriodStart() constant returns (bool){\r\n        return (now > deadline);\r\n    }\r\n\r\n    // function to check percentage of goal achieved\r\n    function percentOfGoal() constant returns (uint16 goalPercent) {\r\n        return uint16((savedBalance.mul(100)).div(minFundingGoal));\r\n    }\r\n\r\n    // Calcul the ROK bonus according to the investment period\r\n    function getBonus(uint256 amount) internal constant returns (uint256) {\r\n        uint bonus = 0;\r\n        //   5 November 2017 11:00:00 GMT\r\n        uint firstbonusdate = 1509879600;\r\n        //  10 November 2017 11:00:00 GMT\r\n        uint secondbonusdate = 1510311600;\r\n\r\n        //  if investment date is on the 10% bonus period then return bonus\r\n        if (now <= firstbonusdate) {bonus = amount.div(10);}\r\n        //  else if investment date is on the 5% bonus period then return bonus\r\n        else if (now <= secondbonusdate && now >= firstbonusdate) {bonus = amount.div(20);}\r\n        //  return amount without bonus\r\n        return bonus;\r\n    }\r\n\r\n    // Function to set the balance of a sender\r\n    function setBalance(address sender,uint256 value) internal{\r\n        balances[sender] = value;\r\n    }\r\n\r\n    // Only owner will finalize the crowdsale\r\n    function finalize() onlyOwner {\r\n        require(isStarted());\r\n        require(!isComplete());\r\n        crowdsaleclosed = true;\r\n    }\r\n\r\n    // Function to pay out\r\n    function payout() onlyOwner {\r\n        if (isSuccessful() && isComplete()) {\r\n            rok.transfer(bounty, checkRokBounty());\r\n            payTeam();\r\n        }\r\n        else {\r\n            if (refundPeriodOver()) {\r\n                escrow.transfer(savedBalance);\r\n                PayEther(escrow, savedBalance, now);\r\n                rok.transfer(bounty, checkRokBounty());\r\n                payTeam();\r\n            }\r\n        }\r\n    }\r\n\r\n    //Function to pay Team\r\n    function payTeam() internal {\r\n        assert(checkRokTeam() > 0);\r\n        rok.transfer(team, checkRokTeam());\r\n        if (checkRokSold() < rok.totalSupply()) {\r\n            // burn the rest of ROK\r\n            rok.burn(rok.totalSupply().sub(checkRokSold()));\r\n            //Log burn of tokens\r\n            BurnTokens(rok.totalSupply().sub(checkRokSold()), now);\r\n        }\r\n    }\r\n\r\n    //Function to update KYC list\r\n    function updateKYClist(address[] allowed) onlyOwner{\r\n        for (uint i = 0; i < allowed.length; i++) {\r\n            if (KYClist[allowed[i]] == false) {\r\n                KYClist[allowed[i]] = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    //Function to claim ROK tokens\r\n    function claim() public{\r\n        require(isComplete());\r\n        require(checkEthBalance(msg.sender) > 0);\r\n        if(checkEthBalance(msg.sender) <= (3 ether)){\r\n            rok.transfer(msg.sender,balancesRokToken[msg.sender]);\r\n            balancesRokToken[msg.sender] = 0;\r\n        }\r\n        else{\r\n            require(KYClist[msg.sender] == true);\r\n            rok.transfer(msg.sender,balancesRokToken[msg.sender]);\r\n            balancesRokToken[msg.sender] = 0;\r\n        }\r\n    }\r\n\r\n    /* When MIN_CAP is not reach the smart contract will be credited to make refund possible by backers\r\n     * 1) backer call the \"refund\" function of the Crowdsale contract\r\n     * 2) backer call the \"withdrawPayments\" function of the Crowdsale contract to get a refund in ETH\r\n     */\r\n    function refund() public {\r\n        require(!isSuccessful());\r\n        require(refundPeriodStart());\r\n        require(!refundPeriodOver());\r\n        require(checkEthBalance(msg.sender) > 0);\r\n        uint ETHToSend = checkEthBalance(msg.sender);\r\n        setBalance(msg.sender,0);\r\n        asyncSend(msg.sender, ETHToSend);\r\n    }\r\n\r\n    /* When MIN_CAP is not reach the smart contract will be credited to make refund possible by backers\r\n     * 1) backer call the \"partialRefund\" function of the Crowdsale contract with the partial amount of ETH to be refunded (value will be renseigned in WEI)\r\n     * 2) backer call the \"withdrawPayments\" function of the Crowdsale contract to get a refund in ETH\r\n     */\r\n    function partialRefund(uint256 value) public {\r\n        require(!isSuccessful());\r\n        require(refundPeriodStart());\r\n        require(!refundPeriodOver());\r\n        require(checkEthBalance(msg.sender) >= value);\r\n        setBalance(msg.sender,checkEthBalance(msg.sender).sub(value));\r\n        asyncSend(msg.sender, value);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"totalPayments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"savedBalanceToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minFundingGoal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkRokBounty\",\"outputs\":[{\"name\":\"totalbounty\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"refundPeriodStart\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deadline\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkRokSold\",\"outputs\":[{\"name\":\"total\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxFundingGoal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isStarted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawPayments\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rateETH_ROK\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"savedBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"team\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bounty\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contributor\",\"type\":\"address\"}],\"name\":\"checkEthBalance\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenBalance\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumPurchase\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"refundPeriodOver\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isComplete\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleclosed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"refundeadline\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkRokTeam\",\"outputs\":[{\"name\":\"totalteam\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"partialRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rok\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"allowed\",\"type\":\"address[]\"}],\"name\":\"updateKYClist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"payments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"escrow\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"percentOfGoal\",\"outputs\":[{\"name\":\"goalPercent\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isSuccessful\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_contributor\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"Contribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_receiver\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"PayEther\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"BurnTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"}]","ContractName":"Crowdsale","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://1e2ebb86c6f995de0cdc035cdb74e6d55f7b19f8e245eeeb35d0e39194146265"}]}