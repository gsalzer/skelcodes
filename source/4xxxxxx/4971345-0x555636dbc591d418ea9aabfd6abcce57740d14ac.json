{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.15;\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\ncontract Token {\r\n\r\n    //uint256 public totalSupply;\r\n    function totalSupply() constant returns (uint256 supply);\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n    \r\n    //function transfer(address to, uint value, bytes data) returns (bool ok);\r\n    \r\n    //function transferFrom(address from, address to, uint value, bytes data) returns (bool ok);\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract ERC223Receiver {\r\n  function tokenFallback(address _sender, address _origin, uint _value, bytes _data) returns (bool ok);\r\n}\r\n\r\ncontract StandardToken is Token {\r\n    uint256 _totalSupply;\r\n    \r\n    function totalSupply() constant returns (uint256 totalSupply) {\r\n        totalSupply = _totalSupply;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            last_seen[msg.sender] = now;\r\n            last_seen[_to] = now;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            last_seen[_from] = now;\r\n            last_seen[_to] = now;\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n    \r\n    function lastSeen(address _owner) constant internal returns (uint256 balance) {\r\n        return last_seen[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        last_seen[msg.sender] = now;\r\n        last_seen[_spender] = now;\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    mapping (address => uint256) last_seen;\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n  \r\n  function getOwner() view public returns (address){\r\n    return owner;\r\n  }\r\n  \r\n\r\n}\r\n\r\ncontract Standard223Receiver is ERC223Receiver {\r\n  Tkn tkn;\r\n\r\n  struct Tkn {\r\n    address addr;\r\n    address sender;\r\n    address origin;\r\n    uint256 value;\r\n    bytes data;\r\n    bytes4 sig;\r\n  }\r\n\r\n  function tokenFallback(address _sender, address _origin, uint _value, bytes _data) returns (bool ok) {\r\n    //if (!supportsToken(msg.sender)) return false;\r\n\r\n    // Problem: This will do a sstore which is expensive gas wise. Find a way to keep it in memory.\r\n    tkn = Tkn(msg.sender, _sender, _origin, _value, _data, getSig(_data));\r\n    __isTokenFallback = true;\r\n    if (!address(this).delegatecall(_data)) return false;\r\n\r\n    // avoid doing an overwrite to .token, which would be more expensive\r\n    // makes accessing .tkn values outside tokenPayable functions unsafe\r\n    __isTokenFallback = false;\r\n\r\n    return true;\r\n  }\r\n\r\n  function getSig(bytes _data) private returns (bytes4 sig) {\r\n    uint l = _data.length < 4 ? _data.length : 4;\r\n    for (uint i = 0; i < l; i++) {\r\n      sig = bytes4(uint(sig) + uint(_data[i]) * (2 ** (8 * (l - 1 - i))));\r\n    }\r\n  }\r\n\r\n  bool __isTokenFallback;\r\n\r\n  modifier tokenPayable {\r\n    if (!__isTokenFallback) throw;\r\n    _;\r\n  }\r\n\r\n  //function supportsToken(address token) returns (bool);\r\n}\r\n\r\ncontract Standard223Token is StandardToken {\r\n  //function that is called when a user or another contract wants to transfer funds\r\n  function transfer(address _to, uint _value, bytes _data) returns (bool success) {\r\n    //filtering if the target is a contract with bytecode inside it\r\n    if (!super.transfer(_to, _value)) throw; // do a normal token transfer\r\n    if (isContract(_to)) return contractFallback(msg.sender, _to, _value, _data);\r\n    last_seen[msg.sender] = now;\r\n    last_seen[_to] = now;\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value, bytes _data) returns (bool success) {\r\n    if (!super.transferFrom(_from, _to, _value)) throw; // do a normal token transfer\r\n    if (isContract(_to)) return contractFallback(_from, _to, _value, _data);\r\n    last_seen[_from] = now;\r\n    last_seen[_to] = now;\r\n    return true;\r\n  }\r\n\r\n  //function transfer(address _to, uint _value) returns (bool success) {\r\n    //return transfer(_to, _value, new bytes(0));\r\n  //}\r\n\r\n  function transferFrom(address _from, address _to, uint _value) returns (bool success) {\r\n    return transferFrom(_from, _to, _value, new bytes(0));\r\n    last_seen[_from] = now;\r\n    last_seen[_to] = now;\r\n  }\r\n\r\n  //function that is called when transaction target is a contract\r\n  function contractFallback(address _origin, address _to, uint _value, bytes _data) private returns (bool success) {\r\n    ERC223Receiver reciever = ERC223Receiver(_to);\r\n    return reciever.tokenFallback(msg.sender, _origin, _value, _data);\r\n  }\r\n\r\n  //assemble the given address bytecode. If bytecode exists then the _addr is a contract.\r\n  function isContract(address _addr) private returns (bool is_contract) {\r\n    // retrieve the size of the code on target address, this needs assembly\r\n    uint length;\r\n    assembly { length := extcodesize(_addr) }\r\n    return length > 0;\r\n  }\r\n}\r\n\r\ncontract Ciphs is Standard223Receiver, Standard223Token, Ownable {\r\n\r\n  using SafeMath for uint256;\r\n  \r\n  string public constant name = \"Ciphs\";\r\n  string public constant symbol = \"CIPHS\";\r\n  uint8 public constant decimals = 18;\r\n\r\n  uint256 public rate = 1000000;\r\n  bool propose = false;\r\n  uint256 prosposal_time = 0;\r\n  uint256 raisedAmount = 0;\r\n  uint256 public constant INITIAL_SUPPLY = 7000000e18;\r\n  uint256 public constant MAX_SUPPLY = 860000000000e18;\r\n  //uint256 public totalSupply;\r\n  address[] investors;\r\n  \r\n  uint256 up = 0;\r\n  uint256 down = 0;\r\n\r\n  mapping(address => uint256) votes;\r\n  mapping (address => mapping (address => uint256)) public trackable;\r\n  mapping (address => mapping (uint => uint256)) public trackable_record;\r\n  \r\n  mapping (address => uint256) public bannable;\r\n  mapping (address => uint256) internal support_ban;\r\n  mapping (address => uint256) internal against_ban;\r\n\r\n  //event Approval(address indexed owner, address indexed spender, uint256 value);\r\n  //event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event BoughtTokens(address indexed to, uint256 value);\r\n  event Votes(address indexed owner, uint256 value);\r\n  event Burn(address indexed burner, uint256 value);\r\n  event Mint(uint256 value);\r\n\r\n  \r\n  function Ciphs() public {\r\n    _totalSupply = INITIAL_SUPPLY;\r\n    balances[msg.sender] = INITIAL_SUPPLY;\r\n  }\r\n\r\n\r\n  function initialize_proposal() public {\r\n\r\n    if(propose) throw;\r\n    propose = true;\r\n    prosposal_time = now;\r\n\r\n  }\r\n  \r\n  function is_proposal_supported() public returns (bool) {\r\n    if(!propose) throw;\r\n    if(down.mul(4) < up)\r\n    {\r\n        return false;\r\n    }else{\r\n        return true;\r\n    }\r\n  }\r\n\r\n  modifier canMint() {\r\n    if(propose && is_proposal_supported() && now > prosposal_time.add(7 * 1 days))\r\n    _;\r\n    else\r\n    throw;\r\n  }\r\n  \r\n  function distribute_token()\r\n  {\r\n       uint256 investors_num = investors.length;\r\n       uint256 amount = (1000000e18-1000)/investors_num;\r\n       for(var i = 0; i < investors_num; i++)\r\n       {\r\n           if(last_seen[investors[i]].add(90 * 1 days) > now)\r\n           {\r\n                balances[investors[i]] += amount;\r\n                last_seen[investors[i]] = now;\r\n            }\r\n       }\r\n    }\r\n\r\n\r\n  function mint() /*canMint*/ public returns (bool) {\r\n    \r\n    if(propose && now >= prosposal_time.add(7 * 1 days)){\r\n        uint256 _amount = 1000000e18;\r\n        _totalSupply = _totalSupply.add(_amount);\r\n        if(_totalSupply <= MAX_SUPPLY && is_proposal_supported())\r\n        {\r\n            balances[owner] = balances[owner].add(1000);\r\n            //Transfer(address(0), _to, _amount);\r\n            propose = false;\r\n            prosposal_time = 0;\r\n            up = 0;\r\n            down = 0;\r\n            distribute_token();\r\n            Mint(_amount);\r\n            return true;\r\n        }else{\r\n            propose = false;\r\n            prosposal_time = 0;\r\n            up = 0;\r\n            down = 0;\r\n            //return true;\r\n        }\r\n        \r\n    }\r\n    last_seen[msg.sender] = now;\r\n    //return false;\r\n  }\r\n\r\n  function support_proposal() public returns (bool) {\r\n    if(!propose || votes[msg.sender] == 1) throw;\r\n    //first check balance to be more than 10 Ciphs\r\n    if(balances[msg.sender] > 100e18)\r\n    {\r\n        //only vote once\r\n        votes[msg.sender] = 1;\r\n        up++;\r\n        mint();\r\n        Votes(msg.sender, 1);\r\n        return true;\r\n\r\n    }else\r\n    {\r\n        //no sufficient funds to carry out voting consensus\r\n        return false;\r\n    }\r\n  }\r\n\r\n  function against_proposal() public returns (bool) {\r\n    if(!propose || votes[msg.sender] == 1) throw;\r\n    //first check balance to be more than 10 Ciphs\r\n    if(balances[msg.sender] > 100e18)\r\n    {\r\n        //only vote once\r\n        votes[msg.sender] = 1;\r\n        down++;\r\n        mint();\r\n        Votes(msg.sender, 1);\r\n        return true;\r\n\r\n    }else\r\n    {\r\n        //no sufficient funds to carry out voting consensus\r\n        return false;\r\n    }\r\n  }\r\n  \r\n  function ban_account(address _bannable_address) internal{\r\n        if(balances[_bannable_address] > 0)\r\n        {\r\n          transferFrom(_bannable_address, owner, balances[_bannable_address]);\r\n        }\r\n        delete balances[_bannable_address];\r\n        \r\n        uint256 investors_num = investors.length;\r\n        for(var i = 0; i < investors_num; i++)\r\n        {\r\n            if(investors[i] == _bannable_address){\r\n                delete investors[i];\r\n            }\r\n        }\r\n      //delete investors[];\r\n  }\r\n  \r\n  function ban_check(address _bannable_address) internal\r\n  {\r\n    last_seen[msg.sender] = now;\r\n    //uint256 time_diff = now.sub(bannable[_bannable_address]); \r\n    if(now.sub(bannable[_bannable_address]) > 0.5 * 1 days)\r\n    {\r\n        if(against_ban[_bannable_address].mul(4) < support_ban[_bannable_address])\r\n        {\r\n            ban_account(_bannable_address);\r\n        }\r\n    }\r\n  }\r\n  \r\n  function initialize_bannable(address _bannable_address) public {\r\n    bannable[_bannable_address] = now;\r\n    last_seen[msg.sender] = now;\r\n  }\r\n  \r\n  function support_ban_of(address _bannable_address) public\r\n  {\r\n    require(bannable[_bannable_address] > 0);\r\n    support_ban[_bannable_address] = support_ban[_bannable_address].add(1);\r\n    ban_check(_bannable_address);\r\n  }\r\n  \r\n  function against_ban_of(address _bannable_address) public\r\n  {\r\n    require(bannable[_bannable_address] > 0);\r\n    against_ban[_bannable_address] = against_ban[_bannable_address].add(1);\r\n    ban_check(_bannable_address);\r\n  }\r\n\r\n  function track(address _trackable) public returns (bool) {\r\n    // \"trackable added, vote like or dislike using the address registered with the trackable\";\r\n    trackable[_trackable][msg.sender] = 1;\r\n    last_seen[msg.sender] = now;\r\n    return true;\r\n  }\r\n\r\n  function like_trackable(address _trackable) public returns (bool) {\r\n    last_seen[msg.sender] = now;\r\n    if(trackable[_trackable][msg.sender] != 1)\r\n    {\r\n        trackable[_trackable][msg.sender] = 1;\r\n        trackable_record[_trackable][1] = trackable_record[_trackable][1] + 1;\r\n        return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  function dislike_trackable(address _trackable) public returns (bool) {\r\n    last_seen[msg.sender] = now;\r\n    if(trackable[_trackable][msg.sender] != 1)\r\n    {\r\n        trackable[_trackable][msg.sender] = 1;\r\n        trackable_record[_trackable][2] = trackable_record[_trackable][2] + 1;\r\n        return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  function trackable_likes(address _trackable) public returns (uint256) {\r\n    uint256 num = 0;\r\n    //if(trackable[_trackable])\r\n    //{\r\n\r\n        num = trackable_record[_trackable][1];\r\n\r\n    //}\r\n    return num;\r\n  }\r\n\r\n  function trackable_dislikes(address _trackable) public returns (uint256) {\r\n    uint256 num = 0;\r\n    num = trackable_record[_trackable][2];\r\n    return num;\r\n  }\r\n    \r\n  function () public payable {\r\n\r\n    buyTokens();\r\n\r\n  }\r\n  \r\n  \r\n  function buyTokens() public payable {\r\n      \r\n    //require(propose);\r\n    \r\n    uint256 weiAmount = msg.value;\r\n    uint256 tokens = weiAmount.mul(getRate());\r\n    \r\n    tokens = tokens.div(1 ether);\r\n    \r\n    BoughtTokens(msg.sender, tokens);\r\n\r\n    balances[msg.sender] = balances[msg.sender].add(tokens);\r\n    balances[owner] = balances[owner].sub(tokens);\r\n    _totalSupply.sub(tokens);\r\n\r\n    raisedAmount = raisedAmount.add(msg.value);\r\n    \r\n    investors.push(msg.sender) -1;\r\n    \r\n    last_seen[msg.sender] = now;\r\n    //owner.transfer(msg.value);\r\n  }\r\n  \r\n  function getInvestors() view public returns (address[]){\r\n      return investors;\r\n  }\r\n\r\n  \r\n  function setRate(uint256 _rate) public onlyOwner{\r\n      rate = _rate;\r\n  }\r\n  \r\n  function getRate() public constant returns (uint256){\r\n      \r\n      return rate;\r\n      \r\n  }\r\n\r\n  function burn(uint256 _value) public {\r\n        require(_value > 0);\r\n\r\n        address burner = msg.sender;\r\n        balances[burner] = balances[burner].sub(_value);\r\n        _totalSupply = _totalSupply.sub(_value);\r\n        Burn(msg.sender, _value);\r\n        last_seen[msg.sender] = now;\r\n  }\r\n  \r\n  function destroy() public onlyOwner {\r\n    selfdestruct(owner);\r\n  }\r\n\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_trackable\",\"type\":\"address\"}],\"name\":\"track\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"trackable\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INITIAL_SUPPLY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_SUPPLY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"setRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bannable_address\",\"type\":\"address\"}],\"name\":\"support_ban_of\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initialize_proposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bannable_address\",\"type\":\"address\"}],\"name\":\"against_ban_of\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_origin\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"against_proposal\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"bannable\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInvestors\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"support_proposal\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"distribute_token\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_trackable\",\"type\":\"address\"}],\"name\":\"dislike_trackable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_trackable\",\"type\":\"address\"}],\"name\":\"trackable_likes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"trackable_record\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_trackable\",\"type\":\"address\"}],\"name\":\"trackable_dislikes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_trackable\",\"type\":\"address\"}],\"name\":\"like_trackable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bannable_address\",\"type\":\"address\"}],\"name\":\"initialize_bannable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"is_proposal_supported\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"BoughtTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Votes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"Ciphs","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://3aea817ca76f9eaba71c4f1f5dca994597e41c5b7f2e81cf596854a77272ac70"}]}