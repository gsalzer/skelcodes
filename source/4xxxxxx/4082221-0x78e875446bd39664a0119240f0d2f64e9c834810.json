{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\nlibrary SafeMath {\r\n  function mul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n  function div(uint a, uint b) internal returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a / b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n  function sub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n  function add(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n \r\n}\r\n\r\n/*\r\n * Token - is a smart contract interface \r\n * for managing common functionality of \r\n * a token.\r\n *\r\n * ERC.20 Token standard: https://github.com/eth ereum/EIPs/issues/20\r\n */\r\ncontract TokenInterface {\r\n        // total amount of tokens\r\n        uint256 totalSupply;\r\n\r\n        /**\r\n         *\r\n         * balanceOf() - constant function check concrete tokens balance  \r\n         *\r\n         *  @param owner - account owner\r\n         *  \r\n         *  @return the value of balance \r\n         */\r\n        function balanceOf(address owner) constant returns(uint256 balance);\r\n        function transfer(address to, uint256 value) returns(bool success);\r\n        function transferFrom(address from, address to, uint256 value) returns(bool success);\r\n\r\n        /**\r\n         *\r\n         * approve() - function approves to a person to spend some tokens from \r\n         *           owner balance. \r\n         *\r\n         *  @param spender - person whom this right been granted.\r\n         *  @param value   - value to spend.\r\n         * \r\n         *  @return true in case of succes, otherwise failure\r\n         * \r\n         */\r\n        function approve(address spender, uint256 value) returns(bool success);\r\n\r\n        /**\r\n         *\r\n         * allowance() - constant function to check how much is \r\n         *               permitted to spend to 3rd person from owner balance\r\n         *\r\n         *  @param owner   - owner of the balance\r\n         *  @param spender - permitted to spend from this balance person \r\n         *  \r\n         *  @return - remaining right to spend \r\n         * \r\n         */\r\n        function allowance(address owner, address spender) constant returns(uint256 remaining);\r\n\r\n        // events notifications\r\n        event Transfer(address indexed from, address indexed to, uint256 value);\r\n        event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n/*\r\n * StandardToken - is a smart contract  \r\n * for managing common functionality of \r\n * a token.\r\n *\r\n * ERC.20 Token standard: \r\n *         https://github.com/eth ereum/EIPs/issues/20\r\n */\r\ncontract StandardToken is TokenInterface {\r\n        // token ownership\r\n        mapping(address => uint256) balances;\r\n\r\n        // spending permision management\r\n        mapping(address => mapping(address => uint256)) allowed;\r\n\r\n        address owner;\r\n        //best 10 owners\r\n        address[] best_wals;\r\n        uint[] best_count;\r\n\r\n        function StandardToken() {\r\n            for(uint8 i = 0; i < 10; i++) {\r\n                best_wals.push(address(0));\r\n                best_count.push(0);\r\n            }\r\n        }\r\n        \r\n        /**\r\n         * transfer() - transfer tokens from msg.sender balance \r\n         *              to requested account\r\n         *\r\n         *  @param to    - target address to transfer tokens\r\n         *  @param value - ammount of tokens to transfer\r\n         *\r\n         *  @return - success / failure of the transaction\r\n         */\r\n        function transfer(address to, uint256 value) returns(bool success) {\r\n\r\n                if (balances[msg.sender] >= value && value > 0) {\r\n                        // do actual tokens transfer       \r\n                        balances[msg.sender] -= value;\r\n                        balances[to] += value;\r\n\r\n                        CheckBest(balances[to], to);\r\n\r\n                        // rise the Transfer event\r\n                        Transfer(msg.sender, to, value);\r\n                        return true;\r\n                } else {\r\n\r\n                        return false;\r\n                }\r\n\r\n        }\r\n\r\n        function transferWithoutChangeBest(address to, uint256 value) returns(bool success) {\r\n\r\n                if (balances[msg.sender] >= value && value > 0) {\r\n                        // do actual tokens transfer       \r\n                        balances[msg.sender] -= value;\r\n                        balances[to] += value;\r\n\r\n                        // rise the Transfer event\r\n                        Transfer(msg.sender, to, value);\r\n                        return true;\r\n                } else {\r\n\r\n                        return false;\r\n                }\r\n\r\n        }\r\n\r\n        /**\r\n         * transferFrom() - \r\n         *\r\n         *  @param from  - \r\n         *  @param to    - \r\n         *  @param value - \r\n         *\r\n         *  @return \r\n         */\r\n        function transferFrom(address from, address to, uint256 value) returns(bool success) {\r\n\r\n                if (balances[from] >= value &&\r\n                        allowed[from][msg.sender] >= value &&\r\n                        value > 0) {\r\n\r\n\r\n                        // do the actual transfer\r\n                        balances[from] -= value;\r\n                        balances[to] += value;\r\n\r\n                        CheckBest(balances[to], to);\r\n\r\n                        // addjust the permision, after part of \r\n                        // permited to spend value was used\r\n                        allowed[from][msg.sender] -= value;\r\n\r\n                        // rise the Transfer event\r\n                        Transfer(from, to, value);\r\n                        return true;\r\n                } else {\r\n\r\n                        return false;\r\n                }\r\n        }\r\n\r\n        function CheckBest(uint _tokens, address _address) {\r\n            //дописать токен проверку лучших (перенести из краудсейла)\r\n            for(uint8 i = 0; i < 10; i++) {\r\n                            if(best_count[i] < _tokens) {\r\n                                for(uint8 j = 9; j > i; j--) {\r\n                                    best_count[j] = best_count[j-1];\r\n                                    best_wals[j] = best_wals[j-1];\r\n                                }\r\n\r\n                                best_count[i] = _tokens;\r\n                                best_wals[i] = _address;\r\n                                break;\r\n                            }\r\n                        }\r\n        }\r\n\r\n        /**\r\n         *\r\n         * balanceOf() - constant function check concrete tokens balance  \r\n         *\r\n         *  @param owner - account owner\r\n         *  \r\n         *  @return the value of balance \r\n         */\r\n        function balanceOf(address owner) constant returns(uint256 balance) {\r\n                return balances[owner];\r\n        }\r\n\r\n        /**\r\n         *\r\n         * approve() - function approves to a person to spend some tokens from \r\n         *           owner balance. \r\n         *\r\n         *  @param spender - person whom this right been granted.\r\n         *  @param value   - value to spend.\r\n         * \r\n         *  @return true in case of succes, otherwise failure\r\n         * \r\n         */\r\n        function approve(address spender, uint256 value) returns(bool success) {\r\n\r\n                // now spender can use balance in \r\n                // ammount of value from owner balance\r\n                allowed[msg.sender][spender] = value;\r\n\r\n                // rise event about the transaction\r\n                Approval(msg.sender, spender, value);\r\n\r\n                return true;\r\n        }\r\n\r\n        /**\r\n         *\r\n         * allowance() - constant function to check how mouch is \r\n         *               permited to spend to 3rd person from owner balance\r\n         *\r\n         *  @param owner   - owner of the balance\r\n         *  @param spender - permited to spend from this balance person \r\n         *  \r\n         *  @return - remaining right to spend \r\n         * \r\n         */\r\n        function allowance(address owner, address spender) constant returns(uint256 remaining) {\r\n                return allowed[owner][spender];\r\n        }\r\n\r\n}\r\n\r\ncontract LeviusDAO is StandardToken {\r\n\r\n    string public constant symbol = \"LeviusDAO\";\r\n    string public constant name = \"LeviusDAO\";\r\n\r\n    uint8 public constant decimals = 8;\r\n    uint DECIMAL_ZEROS = 10**8;\r\n\r\n    modifier onlyOwner { assert(msg.sender == owner); _; }\r\n\r\n    event BestCountTokens(uint _amount);\r\n    event BestWallet(address _address);\r\n\r\n    // Constructor\r\n    function LeviusDAO() {\r\n        totalSupply = 5000000000 * DECIMAL_ZEROS;\r\n        owner = msg.sender;\r\n        balances[msg.sender] = totalSupply;\r\n    }\r\n\r\n    function GetBestTokenCount(uint8 _num) returns (uint) {\r\n        assert(_num < 10);\r\n        BestCountTokens(best_count[_num]);\r\n        return best_count[_num];\r\n    }\r\n\r\n    function GetBestWalletAddress(uint8 _num) onlyOwner returns (address) {\r\n        assert(_num < 10);\r\n        BestWallet(best_wals[_num]);\r\n        return best_wals[_num];\r\n    }\r\n}\r\n\r\ncontract CrowdsaleLeviusDAO {\r\n    using SafeMath for uint;\r\n    uint public start_ico = 1503964800;//P2: GMT: 29-Aug-2017 00:00  => Start ico\r\n    uint public round1 = 1504224000;//P3: GMT: 1-Sep-2017 00:00  => End round1\r\n    uint public deadline = 1509148800;// GMT: 28-Oct-2017 00:00 => End ico\r\n\r\n    //uint public start_ico = now + 5 minutes;//P2: GMT: 18-Aug-2017 00:00  => Start ico\r\n    //uint public round1 = now + 10 minutes;//P3: GMT: 13-Aug-2017 00:00  => End round1\r\n    //uint public deadline = now + 15 minutes;\r\n\r\n    uint amountRaised;\r\n    LeviusDAO public tokenReward;\r\n    bool crowdsaleClosed = false;\r\n    bool public fundingGoalReached = false;\r\n    address owner;\r\n\r\n    // 1 ether = 300$\r\n    // 1 ether = 12,000 LeviusDAO (1 LeviusDAO = 0.03$) Bonus: 20%\r\n    uint PRICE_01 = 12000;\r\n\r\n    // 1 ether = 9,000 LeviusDAO (1 LeviusDAO = 0.04$) Bonus: 20%\r\n    uint PRICE_02 = 9000;\r\n\r\n    // 1 ether = 7,500 LeviusDAO (1 LeviusDAO = 0.04$) Bonus: 0%\r\n    uint PRICE_03 = 7500;\r\n\r\n    uint DECIMAL_ZEROS = 100000000;\r\n\r\n    //12,500,000 LeviusDAO * 0.04$ = 500,000$\r\n    //500,000 / 300 = 1,700 ethers\r\n    uint public constant MIN_CAP = 1700 ether;    \r\n\r\n    mapping(address => uint256) eth_balance;\r\n\r\n    //if (addr == address(0)) throw;\r\n\r\n    event FundTransfer(address backer, uint amount);\r\n    event SendTokens(uint amount);\r\n    \r\n    modifier afterDeadline() { if (now >= deadline) _; }\r\n    modifier onlyOwner { assert(msg.sender == owner); _; }\r\n\r\n    function CrowdsaleLeviusDAO(\r\n        address addressOfTokenUsedAsReward\r\n        ) {\r\n        \r\n        tokenReward = LeviusDAO(addressOfTokenUsedAsReward);\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function () payable {\r\n        assert(now <= deadline);\r\n\r\n        uint tokens = msg.value * getPrice() * DECIMAL_ZEROS / 1 ether;\r\n\r\n        assert(tokenReward.balanceOf(address(this)) >= tokens);\r\n\r\n        amountRaised += msg.value;\r\n        eth_balance[msg.sender] += msg.value;\r\n        tokenReward.transfer(msg.sender, tokens);        \r\n\r\n        if(!fundingGoalReached) {\r\n            if(amountRaised >= MIN_CAP) {\r\n                fundingGoalReached = true;\r\n            }\r\n        }\r\n\r\n        SendTokens(tokens);\r\n        FundTransfer(msg.sender, msg.value);\r\n    }\r\n\r\n    function getPrice() constant returns(uint result) {\r\n        if (now <= start_ico) {\r\n            result = PRICE_01;\r\n        }\r\n        else {\r\n            if(now <= round1) {\r\n                result = PRICE_02;\r\n            }\r\n            else {\r\n                result = PRICE_03;\r\n            }\r\n        }\r\n    }\r\n\r\n    function safeWithdrawal() afterDeadline {\r\n        if (!fundingGoalReached) {\r\n            uint amount = eth_balance[msg.sender];\r\n            eth_balance[msg.sender] = 0;\r\n\r\n            if (amount > 0) {\r\n                if (msg.sender.send(amount)) {\r\n                    FundTransfer(msg.sender, amount);\r\n                } else {\r\n                    eth_balance[msg.sender] = amount;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function WithdrawalTokensAfterDeadLine() onlyOwner {\r\n        assert(now > deadline);\r\n\r\n        tokenReward.transferWithoutChangeBest(msg.sender, tokenReward.balanceOf(address(this)));\r\n    }\r\n\r\n    function WithdrawalAfterGoalReached() {\r\n        assert(fundingGoalReached && owner == msg.sender);\r\n            \r\n            if (owner.send(amountRaised)) {\r\n                FundTransfer(owner, amountRaised);\r\n            } else {\r\n                //If we fail to send the funds to beneficiary, unlock funders balance\r\n                fundingGoalReached = false;\r\n            }\r\n        //}\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"WithdrawalTokensAfterDeadLine\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deadline\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"start_ico\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenReward\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_CAP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"round1\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPrice\",\"outputs\":[{\"name\":\"result\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingGoalReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"WithdrawalAfterGoalReached\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"safeWithdrawal\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"addressOfTokenUsedAsReward\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"backer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SendTokens\",\"type\":\"event\"}]","ContractName":"CrowdsaleLeviusDAO","CompilerVersion":"v0.4.13+commit.fb4cb1a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000e98a6257c1baf12bd03b236fc469dfe0f29e226d","Library":"","SwarmSource":"bzzr://d759ccf7e60ef50eac1e62beee422a818575b333f27acc1e72c5d8d1895c556c"}]}