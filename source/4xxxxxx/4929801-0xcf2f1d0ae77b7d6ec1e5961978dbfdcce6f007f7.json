{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n * ERC20 compatible token interface\r\n *\r\n * - Implements ERC 20 Token standard\r\n * - Implements short address attack fix\r\n *\r\n * #created 29/09/2017\r\n * #author Frank Bonnet\r\n */\r\ninterface IToken { \r\n\r\n    /** \r\n     * Get the total supply of tokens\r\n     * \r\n     * @return The total supply\r\n     */\r\n    function totalSupply() public view returns (uint);\r\n\r\n\r\n    /** \r\n     * Get balance of `_owner` \r\n     * \r\n     * @param _owner The address from which the balance will be retrieved\r\n     * @return The balance\r\n     */\r\n    function balanceOf(address _owner) public view returns (uint);\r\n\r\n\r\n    /** \r\n     * Send `_value` token to `_to` from `msg.sender`\r\n     * \r\n     * @param _to The address of the recipient\r\n     * @param _value The amount of token to be transferred\r\n     * @return Whether the transfer was successful or not\r\n     */\r\n    function transfer(address _to, uint _value) public returns (bool);\r\n\r\n\r\n    /** \r\n     * Send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n     * \r\n     * @param _from The address of the sender\r\n     * @param _to The address of the recipient\r\n     * @param _value The amount of token to be transferred\r\n     * @return Whether the transfer was successful or not\r\n     */\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool);\r\n\r\n\r\n    /** \r\n     * `msg.sender` approves `_spender` to spend `_value` tokens\r\n     * \r\n     * @param _spender The address of the account able to transfer the tokens\r\n     * @param _value The amount of tokens to be approved for transfer\r\n     * @return Whether the approval was successful or not\r\n     */\r\n    function approve(address _spender, uint _value) public returns (bool);\r\n\r\n\r\n    /** \r\n     * Get the amount of remaining tokens that `_spender` is allowed to spend from `_owner`\r\n     * \r\n     * @param _owner The address of the account owning tokens\r\n     * @param _spender The address of the account able to transfer the tokens\r\n     * @return Amount of remaining tokens allowed to spent\r\n     */\r\n    function allowance(address _owner, address _spender) public view returns (uint);\r\n}\r\n\r\n\r\n/**\r\n * ICrowdsale\r\n *\r\n * Base crowdsale interface to manage the sale of \r\n * an ERC20 token\r\n *\r\n * #created 09/09/2017\r\n * #author Frank Bonnet\r\n */\r\ninterface ICrowdsale {\r\n\r\n    /**\r\n     * Returns true if the contract is currently in the presale phase\r\n     *\r\n     * @return True if in presale phase\r\n     */\r\n    function isInPresalePhase() public view returns (bool);\r\n\r\n\r\n    /**\r\n     * Returns true if the contract is currently in the ended stage\r\n     *\r\n     * @return True if ended\r\n     */\r\n    function isEnded() public view returns (bool);\r\n\r\n\r\n    /**\r\n     * Returns true if `_beneficiary` has a balance allocated\r\n     *\r\n     * @param _beneficiary The account that the balance is allocated for\r\n     * @param _releaseDate The date after which the balance can be withdrawn\r\n     * @return True if there is a balance that belongs to `_beneficiary`\r\n     */\r\n    function hasBalance(address _beneficiary, uint _releaseDate) public view returns (bool);\r\n\r\n\r\n    /** \r\n     * Get the allocated token balance of `_owner`\r\n     * \r\n     * @param _owner The address from which the allocated token balance will be retrieved\r\n     * @return The allocated token balance\r\n     */\r\n    function balanceOf(address _owner) public view returns (uint);\r\n\r\n\r\n    /** \r\n     * Get the allocated eth balance of `_owner`\r\n     * \r\n     * @param _owner The address from which the allocated eth balance will be retrieved\r\n     * @return The allocated eth balance\r\n     */\r\n    function ethBalanceOf(address _owner) public view returns (uint);\r\n\r\n\r\n    /** \r\n     * Get invested and refundable balance of `_owner` (only contributions during the ICO phase are registered)\r\n     * \r\n     * @param _owner The address from which the refundable balance will be retrieved\r\n     * @return The invested refundable balance\r\n     */\r\n    function refundableEthBalanceOf(address _owner) public view returns (uint);\r\n\r\n\r\n    /**\r\n     * Returns the rate and bonus release date\r\n     *\r\n     * @param _phase The phase to use while determining the rate\r\n     * @param _volume The amount wei used to determine what volume multiplier to use\r\n     * @return The rate used in `_phase` multiplied by the corresponding volume multiplier\r\n     */\r\n    function getRate(uint _phase, uint _volume) public view returns (uint);\r\n\r\n\r\n    /**\r\n     * Convert `_wei` to an amount in tokens using \r\n     * the `_rate`\r\n     *\r\n     * @param _wei amount of wei to convert\r\n     * @param _rate rate to use for the conversion\r\n     * @return Amount in tokens\r\n     */\r\n    function toTokens(uint _wei, uint _rate) public view returns (uint);\r\n\r\n\r\n    /**\r\n     * Receive ether and issue tokens to the sender\r\n     * \r\n     * This function requires that msg.sender is not a contract. This is required because it's \r\n     * not possible for a contract to specify a gas amount when calling the (internal) send() \r\n     * function. Solidity imposes a maximum amount of gas (2300 gas at the time of writing)\r\n     * \r\n     * Contracts can call the contribute() function instead\r\n     */\r\n    function () public payable;\r\n\r\n\r\n    /**\r\n     * Receive ether and issue tokens to the sender\r\n     *\r\n     * @return The accepted ether amount\r\n     */\r\n    function contribute() public payable returns (uint);\r\n\r\n\r\n    /**\r\n     * Receive ether and issue tokens to `_beneficiary`\r\n     *\r\n     * @param _beneficiary The account that receives the tokens\r\n     * @return The accepted ether amount\r\n     */\r\n    function contributeFor(address _beneficiary) public payable returns (uint);\r\n\r\n\r\n    /**\r\n     * Withdraw allocated tokens\r\n     */\r\n    function withdrawTokens() public;\r\n\r\n\r\n     /**\r\n     * Withdraw allocated tokens\r\n     *\r\n     * @param _beneficiary Address to send to\r\n     */\r\n    function withdrawTokensTo(address _beneficiary) public;\r\n\r\n\r\n    /**\r\n     * Withdraw allocated ether\r\n     */\r\n    function withdrawEther() public;\r\n\r\n\r\n    /**\r\n     * Withdraw allocated ether\r\n     *\r\n     * @param _beneficiary Address to send to\r\n     */\r\n    function withdrawEtherTo(address _beneficiary) public;\r\n\r\n\r\n    /**\r\n     * Refund in the case of an unsuccessful crowdsale. The \r\n     * crowdsale is considered unsuccessful if minAmount was \r\n     * not raised before end of the crowdsale\r\n     */\r\n    function refund() public;\r\n\r\n\r\n    /**\r\n     * Refund in the case of an unsuccessful crowdsale. The \r\n     * crowdsale is considered unsuccessful if minAmount was \r\n     * not raised before end of the crowdsale\r\n     *\r\n     * @param _beneficiary Address to send to\r\n     */\r\n    function refundTo(address _beneficiary) public;\r\n}\r\n\r\n\r\n/**\r\n * Adds to the memory signature of the contract \r\n * that contains the code that is called by the \r\n * dispatcher\r\n */\r\ncontract Dispatchable {\r\n\r\n\r\n    /**\r\n     * Target contract that contains the code\r\n     */\r\n    address private target;\r\n}\r\n\r\n\r\n/**\r\n * The dispatcher is a minimal 'shim' that dispatches calls to a targeted\r\n * contract without returning any data. \r\n *\r\n * Calls are made using 'delegatecall', meaning all storage and value\r\n * is kept on the dispatcher.\r\n */\r\ncontract SimpleDispatcher {\r\n\r\n    /**\r\n     * Target contract that contains the code\r\n     */\r\n    address private target;\r\n\r\n\r\n    /**\r\n     * Initialize simple dispatcher\r\n     *\r\n     * @param _target Contract that holds the code\r\n     */\r\n    function SimpleDispatcher(address _target) public {\r\n        target = _target;\r\n    }\r\n\r\n\r\n    /**\r\n     * Execute target code in the context of the dispatcher\r\n     */\r\n    function () public payable {\r\n        var dest = target;\r\n        assembly {\r\n            calldatacopy(0x0, 0x0, calldatasize)\r\n            switch delegatecall(sub(gas, 10000), dest, 0x0, calldatasize, 0, 0)\r\n            case 0 { revert(0, 0) } // Throw\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * PersonalCrowdsaleProxy Dispatcher\r\n *\r\n * #created 31/12/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract PersonalCrowdsaleProxyDispatcher is SimpleDispatcher {\r\n\r\n    // Target\r\n    address public targetCrowdsale;\r\n    address public targetToken;\r\n\r\n    // Owner\r\n    address public beneficiary;\r\n    bytes32 private passphraseHash;\r\n\r\n\r\n    /**\r\n     * Deploy personal proxy\r\n     *\r\n     * @param _target Target contract to dispach calls to\r\n     * @param _targetCrowdsale Target crowdsale to invest in\r\n     * @param _targetToken Token that is bought\r\n     * @param _passphraseHash Hash of the passphrase \r\n     */\r\n    function PersonalCrowdsaleProxyDispatcher(address _target, address _targetCrowdsale, address _targetToken, bytes32 _passphraseHash) public \r\n        SimpleDispatcher(_target) {\r\n        targetCrowdsale = _targetCrowdsale;\r\n        targetToken = _targetToken;\r\n        passphraseHash = _passphraseHash;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * ICrowdsaleProxy\r\n *\r\n * #created 23/11/2017\r\n * #author Frank Bonnet\r\n */\r\ninterface ICrowdsaleProxy {\r\n\r\n    /**\r\n     * Receive ether and issue tokens to the sender\r\n     * \r\n     * This function requires that msg.sender is not a contract. This is required because it's \r\n     * not possible for a contract to specify a gas amount when calling the (internal) send() \r\n     * function. Solidity imposes a maximum amount of gas (2300 gas at the time of writing)\r\n     * \r\n     * Contracts can call the contribute() function instead\r\n     */\r\n    function () public payable;\r\n\r\n\r\n    /**\r\n     * Receive ether and issue tokens to the sender\r\n     *\r\n     * @return The accepted ether amount\r\n     */\r\n    function contribute() public payable returns (uint);\r\n\r\n\r\n    /**\r\n     * Receive ether and issue tokens to `_beneficiary`\r\n     *\r\n     * @param _beneficiary The account that receives the tokens\r\n     * @return The accepted ether amount\r\n     */\r\n    function contributeFor(address _beneficiary) public payable returns (uint);\r\n}\r\n\r\n\r\n/**\r\n * CrowdsaleProxy\r\n *\r\n * #created 22/11/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract CrowdsaleProxy is ICrowdsaleProxy {\r\n\r\n    address public owner;\r\n    ICrowdsale public target;\r\n    \r\n\r\n    /**\r\n     * Deploy proxy\r\n     *\r\n     * @param _owner Owner of the proxy\r\n     * @param _target Target crowdsale\r\n     */\r\n    function CrowdsaleProxy(address _owner, address _target) public {\r\n        target = ICrowdsale(_target);\r\n        owner = _owner;\r\n    }\r\n\r\n\r\n    /**\r\n     * Receive contribution and forward to the crowdsale\r\n     * \r\n     * This function requires that msg.sender is not a contract. This is required because it's \r\n     * not possible for a contract to specify a gas amount when calling the (internal) send() \r\n     * function. Solidity imposes a maximum amount of gas (2300 gas at the time of writing)\r\n     */\r\n    function () public payable {\r\n        target.contributeFor.value(msg.value)(msg.sender);\r\n    }\r\n\r\n\r\n    /**\r\n     * Receive ether and issue tokens to the sender\r\n     *\r\n     * @return The accepted ether amount\r\n     */\r\n    function contribute() public payable returns (uint) {\r\n        target.contributeFor.value(msg.value)(msg.sender);\r\n    }\r\n\r\n\r\n    /**\r\n     * Receive ether and issue tokens to `_beneficiary`\r\n     *\r\n     * @param _beneficiary The account that receives the tokens\r\n     * @return The accepted ether amount\r\n     */\r\n    function contributeFor(address _beneficiary) public payable returns (uint) {\r\n        target.contributeFor.value(msg.value)(_beneficiary);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * IPersonalCrowdsaleProxy\r\n *\r\n * #created 22/11/2017\r\n * #author Frank Bonnet\r\n */\r\ninterface IPersonalCrowdsaleProxy {\r\n\r\n\r\n    /**\r\n     * Receive ether to forward to the target crowdsale\r\n     */\r\n    function () public payable;\r\n\r\n\r\n    /**\r\n     * Invest received ether in target crowdsale\r\n     */\r\n    function invest() public;\r\n\r\n\r\n    /**\r\n     * Request a refund from the target crowdsale\r\n     */\r\n    function refund() public;\r\n\r\n\r\n    /**\r\n     * Request outstanding token balance from the \r\n     * target crowdsale\r\n     */\r\n    function updateTokenBalance() public;\r\n\r\n\r\n    /**\r\n     * Transfer token balance to beneficiary\r\n     */\r\n    function withdrawTokens() public;\r\n\r\n\r\n    /**\r\n     * Request outstanding ether balance from the \r\n     * target crowdsale\r\n     */\r\n    function updateEtherBalance() public;\r\n\r\n\r\n    /**\r\n     * Transfer ether balance to beneficiary\r\n     */\r\n    function withdrawEther() public;\r\n}\r\n\r\n\r\n/**\r\n * PersonalCrowdsaleProxy\r\n *\r\n * #created 31/12/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract PersonalCrowdsaleProxy is IPersonalCrowdsaleProxy, Dispatchable {\r\n\r\n    // Target\r\n    ICrowdsale public targetCrowdsale;\r\n    IToken public targetToken;\r\n\r\n    // Owner\r\n    address public beneficiary;\r\n    bytes32 private passphraseHash;\r\n\r\n\r\n    /**\r\n     * Restrict call access to when the beneficiary \r\n     * address is known\r\n     */\r\n    modifier when_beneficiary_is_known() {\r\n        require(beneficiary != address(0));\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * Restrict call access to when the beneficiary \r\n     * address is unknown\r\n     */\r\n    modifier when_beneficiary_is_unknown() {\r\n        require(beneficiary == address(0));\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * Set the beneficiary account. Tokens and ether will be send \r\n     * to this address\r\n     *\r\n     * @param _beneficiary The address to receive tokens and ether\r\n     * @param _passphrase The raw passphrasse\r\n     */\r\n    function setBeneficiary(address _beneficiary, bytes32 _passphrase) public when_beneficiary_is_unknown {\r\n        require(keccak256(_passphrase) == passphraseHash);\r\n        beneficiary = _beneficiary;\r\n    }\r\n\r\n\r\n    /**\r\n     * Receive ether to forward to the target crowdsale\r\n     */\r\n    function () public payable {\r\n        // Just receive ether\r\n    }\r\n\r\n\r\n    /**\r\n     * Invest received ether in target crowdsale\r\n     */\r\n    function invest() public {\r\n        targetCrowdsale.contribute.value(this.balance)();\r\n    }\r\n\r\n\r\n    /**\r\n     * Request a refund from the target crowdsale\r\n     */\r\n    function refund() public {\r\n        targetCrowdsale.refund();\r\n    }\r\n\r\n\r\n    /**\r\n     * Request outstanding token balance from the \r\n     * target crowdsale\r\n     */\r\n    function updateTokenBalance() public {\r\n        targetCrowdsale.withdrawTokens();\r\n    }\r\n\r\n\r\n    /**\r\n     * Transfer token balance to beneficiary\r\n     */\r\n    function withdrawTokens() public when_beneficiary_is_known {\r\n        uint balance = targetToken.balanceOf(this);\r\n        targetToken.transfer(beneficiary, balance);\r\n    }\r\n\r\n\r\n    /**\r\n     * Request outstanding ether balance from the \r\n     * target crowdsale\r\n     */\r\n    function updateEtherBalance() public {\r\n        targetCrowdsale.withdrawEther();\r\n    }\r\n\r\n\r\n    /**\r\n     * Transfer ether balance to beneficiary\r\n     */\r\n    function withdrawEther() public when_beneficiary_is_known {\r\n        beneficiary.transfer(this.balance);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * CrowdsaleProxyFactory\r\n *\r\n * #created 21/12/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract CrowdsaleProxyFactory {\r\n\r\n    // Target \r\n    address public targetCrowdsale;\r\n    address public targetToken;\r\n\r\n    // Dispatch target\r\n    address private personalCrowdsaleProxyTarget;\r\n\r\n\r\n    // Events\r\n    event ProxyCreated(address proxy, address beneficiary);\r\n\r\n\r\n    /**\r\n     * Deploy factory\r\n     *\r\n     * @param _targetCrowdsale Target crowdsale to invest in\r\n     * @param _targetToken Token that is bought\r\n     */\r\n    function CrowdsaleProxyFactory(address _targetCrowdsale, address _targetToken) public {\r\n        targetCrowdsale = _targetCrowdsale;\r\n        targetToken = _targetToken;\r\n        personalCrowdsaleProxyTarget = new PersonalCrowdsaleProxy();\r\n    }\r\n\r\n    \r\n    /**\r\n     * Deploy a contract that serves as a proxy to \r\n     * the target crowdsale\r\n     *\r\n     * @return The address of the deposit address\r\n     */\r\n    function createProxyAddress() public returns (address) {\r\n        address proxy = new CrowdsaleProxy(msg.sender, targetCrowdsale);\r\n        ProxyCreated(proxy, msg.sender);\r\n        return proxy;\r\n    }\r\n\r\n\r\n    /**\r\n     * Deploy a contract that serves as a proxy to \r\n     * the target crowdsale\r\n     *\r\n     * @param _beneficiary The owner of the proxy\r\n     * @return The address of the deposit address\r\n     */\r\n    function createProxyAddressFor(address _beneficiary) public returns (address) {\r\n        address proxy = new CrowdsaleProxy(_beneficiary, targetCrowdsale);\r\n        ProxyCreated(proxy, _beneficiary);\r\n        return proxy;\r\n    }\r\n\r\n\r\n    /**\r\n     * Deploy a contract that serves as a proxy to \r\n     * the target crowdsale\r\n     *\r\n     * Contributions through this address will be made \r\n     * for the person that knows the passphrase\r\n     *\r\n     * @param _passphraseHash Hash of the passphrase \r\n     * @return The address of the deposit address\r\n     */\r\n    function createPersonalDepositAddress(bytes32 _passphraseHash) public returns (address) {\r\n        address proxy = new PersonalCrowdsaleProxyDispatcher(\r\n            personalCrowdsaleProxyTarget, targetCrowdsale, targetToken, _passphraseHash);\r\n        ProxyCreated(proxy, msg.sender);\r\n        return proxy;\r\n    }\r\n\r\n\r\n    /**\r\n     * Deploy a contract that serves as a proxy to \r\n     * the target crowdsale\r\n     *\r\n     * Contributions through this address will be made \r\n     * for `_beneficiary`\r\n     *\r\n     * @param _beneficiary The owner of the proxy\r\n     * @return The address of the deposit address\r\n     */\r\n    function createPersonalDepositAddressFor(address _beneficiary) public returns (address) {\r\n        PersonalCrowdsaleProxy proxy = PersonalCrowdsaleProxy(new PersonalCrowdsaleProxyDispatcher(\r\n            personalCrowdsaleProxyTarget, targetCrowdsale, targetToken, keccak256(bytes32(_beneficiary))));\r\n        proxy.setBeneficiary(_beneficiary, bytes32(_beneficiary));\r\n        ProxyCreated(proxy, _beneficiary);\r\n        return proxy;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"targetCrowdsale\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"targetToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"createProxyAddressFor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"createPersonalDepositAddressFor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_passphraseHash\",\"type\":\"bytes32\"}],\"name\":\"createPersonalDepositAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"createProxyAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_targetCrowdsale\",\"type\":\"address\"},{\"name\":\"_targetToken\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"proxy\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"ProxyCreated\",\"type\":\"event\"}]","ContractName":"CrowdsaleProxyFactory","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000006b609d9095d069c805650234ab67595b3a6ab934000000000000000000000000fa9f699e5273864aace6ba20e1448e41c387aa00","Library":"","SwarmSource":"bzzr://f137bf0845a70507ab5d81e3f2d8a6e88103533c243e482708f06577e404057d"}]}