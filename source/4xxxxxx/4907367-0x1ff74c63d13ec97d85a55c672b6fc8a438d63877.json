{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.6;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract Owned {\r\n\r\n    // The address of the account that is the current owner\r\n    address public owner;\r\n\r\n    // Contract which manage issuing of new tokens (airdrop and referral tokens) \r\n    address public issuer;\r\n\r\n    // The publiser is the inital owner\r\n    function Owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * Restricted access to the current owner\r\n     */\r\n    modifier onlyOwner() {\r\n        if (msg.sender != owner) throw;\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Restricted access to the issuer and owner\r\n     */\r\n    modifier onlyIssuer() {\r\n        if (msg.sender != owner && msg.sender != issuer) throw;\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Transfer ownership to `_newOwner`\r\n     *\r\n     * @param _newOwner The address of the account that will become the new owner\r\n     */\r\n    function transferOwnership(address _newOwner) onlyOwner {\r\n        owner = _newOwner;\r\n    }\r\n}\r\n\r\n// Abstract contract for the full ERC 20 Token standard\r\n// https://github.com/ethereum/EIPs/issues/20\r\ncontract Token {\r\n    /// total amount of tokens\r\n    uint256 public totalSupply;\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of tokens to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n/**\r\n * @title Mail token\r\n *\r\n * Implements ERC 20 Token standard: https://github.com/ethereum/EIPs/issues/20 with the addition\r\n * of ownership, a lock and issuing.\r\n *\r\n */\r\ncontract Mail is Owned, Token {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    // Ethereum token standaard\r\n    string public standard = \"Token 0.2\";\r\n\r\n    // Full name\r\n    string public name = \"Ethereum Mail\";\r\n\r\n    // Symbol\r\n    string public symbol = \"MAIL\";\r\n\r\n    // No decimal points\r\n    uint8 public decimals = 0;\r\n    \r\n    // Token distribution\r\n    uint256 public freeToUseTokens = 10 * 10 ** 6; // 10 million tokens are free to use\r\n\r\n    // List of available tokens for attachment\r\n    mapping (bytes32 => Token) public tokens;\r\n    \r\n    // No decimal points\r\n    uint256 public maxTotalSupply = 10 ** 9; // 1 billion\r\n\r\n    // Token starts if the locked state restricting transfers\r\n    bool public locked;\r\n\r\n    mapping (address => uint256) public balances;\r\n    mapping (address => uint256) public usableBalances;\r\n    mapping (address => mapping (address => uint256)) public allowed;\r\n    \r\n    uint256 public currentMessageNumber;\r\n    \r\n    struct Message {\r\n        bytes32 content;\r\n        uint256 weight;\r\n        uint256 validUntil;\r\n        uint256 time;\r\n        bytes32 attachmentSymbol;\r\n        uint256 attachmentValue;\r\n        address from;\r\n        address[] to;\r\n        address[] read;\r\n    }\r\n    \r\n    mapping (uint256 => Message) messages;\r\n    \r\n    struct UnreadMessage {\r\n        uint256 id;\r\n        bool isOpened;\r\n        bool free;\r\n        address from;\r\n        uint256 time;\r\n        uint256 weight;\r\n    }\r\n    \r\n    mapping (address => UnreadMessage[]) public unreadMessages;\r\n    mapping (address => uint256) public unreadMessageCount;\r\n    uint[] indexesUnread;\r\n    uint[] indexesRead;\r\n    mapping (address => uint256) public lastReceivedMessage;\r\n\r\n    /**\r\n     * Set up issuer\r\n     *\r\n     * @param _issuer The address of the account that will become the new issuer\r\n     */\r\n    function setIssuer(address _issuer) onlyOwner {\r\n        issuer = _issuer;\r\n    }\r\n    \r\n    /**\r\n     * Unlocks the token irreversibly so that the transfering of value is enabled\r\n     *\r\n     * @return Whether the unlocking was successful or not\r\n     */\r\n    function unlock() onlyOwner returns (bool success)  {\r\n        locked = false;\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * Everyone can call this function to invalidate mail if its validation time is already in past  \r\n     *\r\n     * @param _number Number od unread messages\r\n     */\r\n    function invalidateMail(uint256 _number) {\r\n        if (messages[_number].validUntil >= now) {\r\n            throw;\r\n        }\r\n        \r\n        if (messages[_number].attachmentSymbol.length != 0x0 && messages[_number].attachmentValue > 0) {\r\n            Token token = tokens[messages[_number].attachmentSymbol];\r\n            token.transfer(messages[_number].from, messages[_number].attachmentValue.mul(messages[_number].to.length.sub(messages[_number].read.length)).div(messages[_number].to.length));\r\n        }\r\n        \r\n        uint256 i = 0;\r\n        while (i < messages[_number].to.length) {\r\n            address recipient = messages[_number].to[i];\r\n\r\n            for (uint a = 0; a < unreadMessages[recipient].length; ++a) {\r\n                if (unreadMessages[recipient][a].id == _number) {\r\n\r\n                    if (!unreadMessages[recipient][a].isOpened) {\r\n                        unreadMessages[recipient][a].weight = 0;\r\n                        unreadMessages[recipient][a].time = 0;\r\n\r\n                        uint256 value = messages[_number].weight.div(messages[_number].to.length);\r\n\r\n                        unreadMessageCount[recipient]--;\r\n                        balances[recipient] = balances[recipient].sub(value);\r\n\r\n                        if (!unreadMessages[recipient][a].free) {\r\n                            usableBalances[messages[_number].from] = usableBalances[messages[_number].from].add(value);\r\n                            balances[messages[_number].from] = balances[messages[_number].from].add(value);\r\n                        }\r\n                    }\r\n\r\n                    break;\r\n                }\r\n            }\r\n            \r\n            i++;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Returns number of unread messages for specific user\r\n     *\r\n     * @param _userAddress Address of user\r\n     * @return Number od unread messages\r\n     */\r\n    function getUnreadMessageCount(address _userAddress) constant returns (uint256 count)  {\r\n        uint256 unreadCount;\r\n        for (uint i = 0; i < unreadMessageCount[_userAddress]; ++i) {\r\n            if (unreadMessages[_userAddress][i].isOpened == false) {\r\n                unreadCount++;    \r\n            }\r\n        }\r\n        \r\n        return unreadCount;\r\n    }\r\n    \r\n\r\n    /**\r\n     * Returns unread messages for current user\r\n     * \r\n     * @param _userAddress Address of user\r\n     * @return Unread messages as array of message numbers\r\n     */\r\n    function getUnreadMessages(address _userAddress) constant returns (uint[] mmessages)  {\r\n        for (uint i = 0; i < unreadMessageCount[_userAddress]; ++i) {\r\n            if (unreadMessages[_userAddress][i].isOpened == false) {\r\n                indexesUnread.push(unreadMessages[_userAddress][i].id);\r\n            }\r\n        }\r\n        \r\n        return indexesUnread;\r\n    }\r\n\r\n\r\n    function getUnreadMessagesArrayContent(uint256 _number) public constant returns(uint256, bool, address, uint256, uint256) {\r\n        for (uint a = 0; a < unreadMessageCount[msg.sender]; ++a) {\r\n            if (unreadMessages[msg.sender][a].id == _number) {\r\n                return (unreadMessages[msg.sender][a].id,unreadMessages[msg.sender][a].isOpened,unreadMessages[msg.sender][a].from, unreadMessages[msg.sender][a].time,unreadMessages[msg.sender][a].weight);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns read messages for current user\r\n     * \r\n     * @param _userAddress Address of user\r\n     * @return Read messages as array of message numbers\r\n     */\r\n    function getReadMessages(address _userAddress) constant returns (uint[] mmessages)  {        \r\n        for (uint i = 0; i < unreadMessageCount[_userAddress]; ++i) {\r\n            if (unreadMessages[_userAddress][i].isOpened == true) {\r\n                indexesRead.push(unreadMessages[_userAddress][i].id);\r\n            }\r\n        }\r\n        \r\n        return indexesRead;\r\n    }\r\n    \r\n    /**\r\n     * Add token which will can be used as attachment\r\n     * \r\n     * @param _tokenAddress Address of token contract\r\n     * @param _symbol Symbol of token\r\n     * @return If action was successful\r\n     */\r\n    function addToken(address _tokenAddress, bytes32 _symbol) onlyOwner returns (bool success)  {\r\n        Token token = Token(_tokenAddress);\r\n        tokens[_symbol] = token;\r\n        \r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Locks the token irreversibly so that the transfering of value is not enabled\r\n     *\r\n     * @return Whether the locking was successful or not\r\n     */\r\n    function lock() onlyOwner returns (bool success)  {\r\n        locked = true;\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * Restricted access to the current owner\r\n     */\r\n    modifier onlyOwner() {\r\n        if (msg.sender != owner) throw;\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * Get balance of `_owner`\r\n     *\r\n     * @param _owner The address from which the balance will be retrieved\r\n     * @return The balance\r\n     */\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n    \r\n    /**\r\n     * Prevents accidental sending of ether\r\n     */\r\n    function () {\r\n        throw;\r\n    }\r\n\r\n    /**\r\n     * Send `_value` token to `_to` from `msg.sender`\r\n     *\r\n     * @param _to The address of the recipient\r\n     * @param _value The amount of token to be transferred\r\n     * @return Whether the transfer was successful or not\r\n     */\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n\r\n        // Unable to transfer while still locked\r\n        if (locked) {\r\n            throw;\r\n        }\r\n\r\n        // Check if the sender has enough tokens\r\n        if (balances[msg.sender] < _value || usableBalances[msg.sender] < _value) {\r\n            throw;\r\n        }\r\n\r\n        // Check for overflows\r\n        if (balances[_to] + _value < balances[_to])  {\r\n            throw;\r\n        }\r\n\r\n        // Transfer tokens\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        \r\n        usableBalances[msg.sender] -= _value;\r\n        usableBalances[_to] += _value;\r\n\r\n        // Notify listners\r\n        Transfer(msg.sender, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n     *\r\n     * @param _from The address of the sender\r\n     * @param _to The address of the recipient\r\n     * @param _value The amount of token to be transferred\r\n     * @return Whether the transfer was successful or not\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n\r\n         // Unable to transfer while still locked\r\n        if (locked) {\r\n            throw;\r\n        }\r\n\r\n        // Check if the sender has enough\r\n        if (balances[_from] < _value || usableBalances[_from] < _value) {\r\n            throw;\r\n        }\r\n\r\n        // Check for overflows\r\n        if (balances[_to] + _value < balances[_to]) {\r\n            throw;\r\n        }\r\n\r\n        // Check allowance\r\n        if (_value > allowed[_from][msg.sender]) {\r\n            throw;\r\n        }\r\n\r\n        // Transfer tokens\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        \r\n        usableBalances[_from] -= _value;\r\n        usableBalances[_to] += _value;\r\n\r\n        // Update allowance\r\n        allowed[_from][msg.sender] -= _value;\r\n\r\n        // Notify listners\r\n        Transfer(_from, _to, _value);\r\n        \r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * `msg.sender` approves `_spender` to spend `_value` tokens\r\n     *\r\n     * @param _spender The address of the account able to transfer the tokens\r\n     * @param _value The amount of tokens to be approved for transfer\r\n     * @return Whether the approval was successful or not\r\n     */\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n\r\n        // Unable to approve while still locked\r\n        if (locked) {\r\n            throw;\r\n        }\r\n\r\n        // Update allowance\r\n        allowed[msg.sender][_spender] = _value;\r\n\r\n        // Notify listners\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     * Get the amount of remaining tokens that `_spender` is allowed to spend from `_owner`\r\n     *\r\n     * @param _owner The address of the account owning tokens\r\n     * @param _spender The address of the account able to transfer the tokens\r\n     * @return Amount of remaining tokens allowed to spent\r\n     */\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n     * Sends an mail to the specific list of recipients with amount of MAIL tokens to spend on them, hash message, time unti when is \r\n     * message available and tokens\r\n     *\r\n     * @param _to List of recipients\r\n     * @param _weight Tokens to be spent on messages\r\n     * @param _hashedMessage Hashed content of mail\r\n     * @param _validUntil Mail is available until this specific time when will be returned to sender\r\n     * @param _attachmentToken Name of attached token\r\n     * @param _attachmentAmount Amount of attached token\r\n     */\r\n    function sendMail(address[] _to, uint256 _weight, bytes32 _hashedMessage, uint256 _validUntil, bytes32 _attachmentToken, uint256 _attachmentAmount) {\r\n        bool useFreeTokens = false;\r\n        if (_weight == 0 && freeToUseTokens > 0) {\r\n            _weight = _to.length;\r\n            useFreeTokens = true;\r\n        }\r\n\r\n        if ((!useFreeTokens && usableBalances[msg.sender] < _weight) || _weight < _to.length) {\r\n            throw;\r\n        }\r\n        \r\n        messages[currentMessageNumber].content = _hashedMessage;\r\n        messages[currentMessageNumber].validUntil = _validUntil;\r\n        messages[currentMessageNumber].time = now;\r\n        messages[currentMessageNumber].from = msg.sender;\r\n        messages[currentMessageNumber].to = _to;\r\n        \r\n        if (_attachmentToken != \"\") {\r\n            Token token = tokens[_attachmentToken];\r\n            \r\n            if (!token.transferFrom(msg.sender, address(this), _attachmentAmount)) {\r\n                throw;\r\n            }\r\n            \r\n            messages[currentMessageNumber].attachmentSymbol = _attachmentToken;\r\n            messages[currentMessageNumber].attachmentValue = _attachmentAmount;\r\n        }\r\n        \r\n        UnreadMessage memory currentUnreadMessage;\r\n        currentUnreadMessage.id = currentMessageNumber;\r\n        currentUnreadMessage.isOpened = false;\r\n        currentUnreadMessage.from = msg.sender;\r\n        currentUnreadMessage.time = now;\r\n        currentUnreadMessage.weight = _weight;\r\n        currentUnreadMessage.free = useFreeTokens;\r\n\r\n        uint256 i = 0;\r\n        uint256 duplicateWeight = 0;\r\n        \r\n        while (i < _to.length) {\r\n            if (lastReceivedMessage[_to[i]] == currentMessageNumber) {\r\n                i++;\r\n                duplicateWeight = duplicateWeight.add(_weight.div(_to.length));\r\n                continue;\r\n            }\r\n\r\n            lastReceivedMessage[_to[i]] = currentMessageNumber;\r\n        \r\n            unreadMessages[_to[i]].push(currentUnreadMessage);\r\n        \r\n            unreadMessageCount[_to[i]]++;\r\n            balances[_to[i]] = balances[_to[i]].add(_weight.div(_to.length));\r\n            i++;\r\n        }\r\n        \r\n        if (useFreeTokens) {\r\n            freeToUseTokens = freeToUseTokens.sub(_weight.sub(duplicateWeight));\r\n        } else {\r\n            usableBalances[msg.sender] = usableBalances[msg.sender].sub(_weight.sub(duplicateWeight));\r\n            balances[msg.sender] = balances[msg.sender].sub(_weight.sub(duplicateWeight));\r\n        }  \r\n\r\n        messages[currentMessageNumber].weight = _weight.sub(duplicateWeight);  \r\n\r\n        currentMessageNumber++;\r\n    }\r\n    \r\n    function getUnreadMessage(uint256 _number) constant returns (UnreadMessage unread) {\r\n        for (uint a = 0; a < unreadMessages[msg.sender].length; ++a) {\r\n            if (unreadMessages[msg.sender][a].id == _number) {\r\n                return unreadMessages[msg.sender][a];\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Open specific mail for current user who receives MAIL tokens and tokens attached to mail \r\n     *\r\n     * @param _number Number of message recipient is trying to open\r\n     * @return Success of opeining mail\r\n     */\r\n    function openMail(uint256 _number) returns (bool success) {\r\n        UnreadMessage memory currentUnreadMessage = getUnreadMessage(_number);\r\n\r\n        // throw error if it is already opened or invalidate \r\n        if (currentUnreadMessage.isOpened || currentUnreadMessage.weight == 0) {\r\n            throw;\r\n        }\r\n        \r\n        if (messages[_number].attachmentSymbol != 0x0 && messages[_number].attachmentValue > 0) {\r\n            Token token = tokens[messages[_number].attachmentSymbol];\r\n            token.transfer(msg.sender, messages[_number].attachmentValue.div(messages[_number].to.length));\r\n        }\r\n        \r\n        for (uint a = 0; a < unreadMessages[msg.sender].length; ++a) {\r\n            if (unreadMessages[msg.sender][a].id == _number) {\r\n                unreadMessages[msg.sender][a].isOpened = true;\r\n            }\r\n        }\r\n        \r\n        messages[_number].read.push(msg.sender);\r\n        \r\n        usableBalances[msg.sender] = usableBalances[msg.sender].add(messages[_number].weight.div(messages[_number].to.length));\r\n        \r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * Return opened mail with specific number \r\n     *\r\n     * @param _number Number of message \r\n     * @return Mail content\r\n     */\r\n    function getMail(uint256 _number) constant returns (bytes32 message) {\r\n        UnreadMessage memory currentUnreadMessage = getUnreadMessage(_number);\r\n        if (!currentUnreadMessage.isOpened || currentUnreadMessage.weight == 0) {\r\n            throw;\r\n        }\r\n        \r\n        return messages[_number].content;\r\n    }\r\n    \r\n    /**\r\n     * Issuing MAIL tokens  \r\n     *\r\n     * @param _recipient Recipient of tokens\r\n     * @param _value Amount of tokens\r\n     * @return Success of issuing\r\n     */\r\n    function issue(address _recipient, uint256 _value) onlyIssuer returns (bool success) {\r\n\r\n        if (totalSupply.add(_value) > maxTotalSupply) {\r\n            return;\r\n        }\r\n        \r\n        // Create tokens\r\n        balances[_recipient] = balances[_recipient].add(_value);\r\n        usableBalances[_recipient] = usableBalances[_recipient].add(_value);\r\n        totalSupply = totalSupply.add(_value);\r\n\r\n        return true;\r\n    }\r\n    \r\n    function Mail() {\r\n        balances[msg.sender] = 0;\r\n        totalSupply = 0;\r\n        locked = false;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"usableBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"unreadMessageCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"issuer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxTotalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"getReadMessages\",\"outputs\":[{\"name\":\"mmessages\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastReceivedMessage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_issuer\",\"type\":\"address\"}],\"name\":\"setIssuer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"standard\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_number\",\"type\":\"uint256\"}],\"name\":\"getUnreadMessagesArrayContent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"unreadMessages\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"isOpened\",\"type\":\"bool\"},{\"name\":\"free\",\"type\":\"bool\"},{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"time\",\"type\":\"uint256\"},{\"name\":\"weight\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address[]\"},{\"name\":\"_weight\",\"type\":\"uint256\"},{\"name\":\"_hashedMessage\",\"type\":\"bytes32\"},{\"name\":\"_validUntil\",\"type\":\"uint256\"},{\"name\":\"_attachmentToken\",\"type\":\"bytes32\"},{\"name\":\"_attachmentAmount\",\"type\":\"uint256\"}],\"name\":\"sendMail\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"issue\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"tokens\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_number\",\"type\":\"uint256\"}],\"name\":\"getUnreadMessage\",\"outputs\":[{\"components\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"isOpened\",\"type\":\"bool\"},{\"name\":\"free\",\"type\":\"bool\"},{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"time\",\"type\":\"uint256\"},{\"name\":\"weight\",\"type\":\"uint256\"}],\"name\":\"unread\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"getUnreadMessageCount\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unlock\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_number\",\"type\":\"uint256\"}],\"name\":\"openMail\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_symbol\",\"type\":\"bytes32\"}],\"name\":\"addToken\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"locked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentMessageNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_number\",\"type\":\"uint256\"}],\"name\":\"getMail\",\"outputs\":[{\"name\":\"message\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"getUnreadMessages\",\"outputs\":[{\"name\":\"mmessages\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"freeToUseTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lock\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_number\",\"type\":\"uint256\"}],\"name\":\"invalidateMail\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"Mail","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://16f7344a8bf7ae22a1eaea3265290161c620e795707d63c82712c65863d5b6d3"}]}