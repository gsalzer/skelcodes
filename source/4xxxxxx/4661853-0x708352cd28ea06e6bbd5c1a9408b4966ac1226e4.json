{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n * A referral tree is a diffusion graph of all nodes representing campaign participants.\r\n * Each invitee is assigned a referral tree after accepting an invitation. Following is\r\n * an example difussion graph.\r\n *\r\n *                                                                  +---+\r\n *                                                             +--> | 9 |\r\n *                                                             |    +---+\r\n *                                                             |\r\n *                                                             |    +---+\r\n *                                                 +---+       +--> |10 |\r\n *                                            +--> | 4 |       |    +---+\r\n *                                            |    +---+    +--+\r\n *                                            |  (inactive) |  |    +---+\r\n *                                            |             |  +--> |11 |\r\n *                                            |    +---+    |  |    +---+\r\n *                                       +-------> | 5 +----+  |\r\n *                                       |    |    +---+       |    +---+\r\n *                              +----    |    |                +--> |12 |\r\n *                        +-->  | 1 +----+    |                     +---+\r\n *                        |     +---+         |    +---+\r\n *                        |                   +--> | 6 | +------------------>\r\n *                        |                        +---+\r\n *               +---+    |     +---+\r\n *               | 0 | +----->  | 2 |\r\n *               +---+    |     +---+\r\n *                        |   (inactive)\r\n *                        |                        +---+\r\n *                        |     +---+         +--> | 7 |\r\n *                        +-->  | 3 +---------+    +---+\r\n *                              +---+         |\r\n *                                            |    +---+\r\n *                                            +--> | 8 |\r\n *                                                 +---+\r\n *\r\n */\r\nlibrary Referral {\r\n\r\n    /**\r\n     * @dev A user in a referral graph\r\n     */\r\n    struct Node {\r\n        /// This node was referred by...\r\n        address referrer;\r\n        /// Invitees (and their shares) of this node\r\n        mapping (address => uint) invitees;\r\n        /// Store keys separately\r\n        address[] inviteeIndex;\r\n        /// Reward accumulated\r\n        uint shares;\r\n        /// Used for membership check\r\n        bool exists;\r\n    }\r\n\r\n    /**\r\n     * @dev A referral tree is a collection of Nodes.\r\n     */\r\n    struct Tree {\r\n        /// Nodes\r\n        mapping (address => Referral.Node) nodes;\r\n        /// stores keys separately\r\n        address[] treeIndex;\r\n    }\r\n\r\n    /**\r\n     * @dev Find referrer of the given invitee.\r\n     */\r\n    function getReferrer (\r\n        Tree storage self,\r\n        address _invitee\r\n    )\r\n        public\r\n        constant\r\n        returns (address _referrer)\r\n    {\r\n        _referrer = self.nodes[_invitee].referrer;\r\n    }\r\n\r\n    /**\r\n     * @dev Number of entries in referral tree.\r\n     */\r\n    function getTreeSize (\r\n        Tree storage self\r\n    )\r\n        public\r\n        constant\r\n        returns (uint _size)\r\n    {\r\n        _size = self.treeIndex.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Creates a new node representing an invitee and adds to a node's list of invitees.\r\n     */\r\n    function addInvitee (\r\n        Tree storage self,\r\n        address _referrer,\r\n        address _invitee,\r\n        uint _shares\r\n    )\r\n        internal\r\n    {\r\n        Node memory inviteeNode;\r\n        inviteeNode.referrer = _referrer;\r\n        inviteeNode.shares = _shares;\r\n        inviteeNode.exists = true;\r\n        self.nodes[_invitee] = inviteeNode;\r\n        self.treeIndex.push(_invitee);\r\n\r\n        if (self.nodes[_referrer].exists == true) {\r\n            self.nodes[_referrer].invitees[_invitee] = _shares;\r\n            self.nodes[_referrer].inviteeIndex.push(_invitee);\r\n        }\r\n    }\r\n}\r\n\r\npragma solidity ^0.4.18;\r\n\r\n/**\r\n * Bonus tiers\r\n *  1 Vyral Referral - 7% bonus\r\n *  2 Vyral Referrals - 8% bonus\r\n *  3 Vyral Referrals - 9% bonus\r\n *  4 Vyral Referrals - 10% bonus\r\n *  5 Vyral Referrals - 11% bonus\r\n *  6 Vyral Referrals - 12% bonus\r\n *  7 Vyral Referrals - 13% bonus\r\n *  8 Vyral Referrals - 14% bonus\r\n *  9 Vyral Referrals - 15% bonus\r\n * 10 Vyral Referrals - 16% bonus\r\n * 11 Vyral Referrals - 17% bonus\r\n * 12 Vyral Referrals - 18% bonus\r\n * 13 Vyral Referrals - 19% bonus\r\n * 14 Vyral Referrals - 20% bonus\r\n * 15 Vyral Referrals - 21% bonus\r\n * 16 Vyral Referrals - 22% bonus\r\n * 17 Vyral Referrals - 23% bonus\r\n * 18 Vyral Referrals - 24% bonus\r\n * 19 Vyral Referrals - 25% bonus\r\n * 20 Vyral Referrals - 26% bonus\r\n * 21 Vyral Referrals - 27% bonus\r\n * 22 Vyral Referrals - 28% bonus\r\n * 23 Vyral Referrals - 29% bonus\r\n * 24 Vyral Referrals - 30% bonus\r\n * 25 Vyral Referrals - 31% bonus\r\n * 26 Vyral Referrals - 32% bonus\r\n * 27 Vyral Referrals - 33% bonus\r\n */\r\nlibrary TieredPayoff {\r\n    using SafeMath for uint;\r\n\r\n    /**\r\n     * Tiered payoff computes reward based on number of invitees a referrer has brought in.\r\n     * Returns the reward or the number of tokens referrer should be awarded.\r\n     *\r\n     * For degree == 1:\r\n     * tier% of shares of newly joined node\r\n     *\r\n     * For 2 <= degree < 27:\r\n     *   k-1\r\n     * (  âˆ‘  1% of shares(node_i) )  + tier% of shares of node_k\r\n     *   i=1\r\n     *\r\n     * For degree > 27:\r\n     * tier% of shares of newly joined node\r\n     */\r\n    function payoff(\r\n        Referral.Tree storage self,\r\n        address _referrer\r\n    )\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        Referral.Node node = self.nodes[_referrer];\r\n\r\n        if(!node.exists) {\r\n            return 0;\r\n        }\r\n\r\n        uint reward = 0;\r\n        uint shares = 0;\r\n        uint degree = node.inviteeIndex.length;\r\n        uint tierPercentage = getBonusPercentage(node.inviteeIndex.length);\r\n\r\n        // No bonus if there are no invitees\r\n        if(degree == 0) {\r\n            return 0;\r\n        }\r\n\r\n        assert(tierPercentage > 0);\r\n\r\n        if(degree == 1) {\r\n            shares = node.invitees[node.inviteeIndex[0]];\r\n            reward = reward.add(shares.mul(tierPercentage).div(100));\r\n            return reward;\r\n        }\r\n\r\n\r\n        // For 2 <= degree <= 27\r\n        //    add 1% from the first k-1 nodes\r\n        //    add tier% from the last node\r\n        if(degree >= 2 && degree <= 27) {\r\n            for (uint i = 0; i < (degree - 1); i++) {\r\n                shares = node.invitees[node.inviteeIndex[i]];\r\n                reward = reward.add(shares.mul(1).div(100));\r\n            }\r\n        }\r\n\r\n        // For degree > 27, referrer bonus remains constant at tier%\r\n        shares = node.invitees[node.inviteeIndex[degree - 1]];\r\n        reward = reward.add(shares.mul(tierPercentage).div(100));\r\n\r\n        return reward;\r\n    }\r\n\r\n    /**\r\n     * Returns bonus percentage for a given number of referrals\r\n     * based on comments above.\r\n     */\r\n    function getBonusPercentage(\r\n        uint _referrals\r\n    )\r\n        public\r\n        pure\r\n        returns (uint)\r\n    {\r\n        if (_referrals == 0) {\r\n            return 0;\r\n        }\r\n        if (_referrals >= 27) {\r\n            return 33;\r\n        }\r\n        return _referrals + 6;\r\n    }\r\n}\r\n\r\n\r\ncontract DateTimeAPI {\r\n        /*\r\n         *  Abstract contract for interfacing with the DateTime contract.\r\n         *\r\n         */\r\n        function isLeapYear(uint16 year) constant returns (bool);\r\n        function getYear(uint timestamp) constant returns (uint16);\r\n        function getMonth(uint timestamp) constant returns (uint8);\r\n        function getDay(uint timestamp) constant returns (uint8);\r\n        function getHour(uint timestamp) constant returns (uint8);\r\n        function getMinute(uint timestamp) constant returns (uint8);\r\n        function getSecond(uint timestamp) constant returns (uint8);\r\n        function getWeekday(uint timestamp) constant returns (uint8);\r\n        function toTimestamp(uint16 year, uint8 month, uint8 day) constant returns (uint timestamp);\r\n        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour) constant returns (uint timestamp);\r\n        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute) constant returns (uint timestamp);\r\n        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute, uint8 second) constant returns (uint timestamp);\r\n}\r\n\r\npragma solidity ^0.4.16;\r\n\r\ncontract DateTime {\r\n        /*\r\n         *  Date and Time utilities for ethereum contracts\r\n         *\r\n         */\r\n        struct _DateTime {\r\n                uint16 year;\r\n                uint8 month;\r\n                uint8 day;\r\n                uint8 hour;\r\n                uint8 minute;\r\n                uint8 second;\r\n                uint8 weekday;\r\n        }\r\n\r\n        uint constant DAY_IN_SECONDS = 86400;\r\n        uint constant YEAR_IN_SECONDS = 31536000;\r\n        uint constant LEAP_YEAR_IN_SECONDS = 31622400;\r\n\r\n        uint constant HOUR_IN_SECONDS = 3600;\r\n        uint constant MINUTE_IN_SECONDS = 60;\r\n\r\n        uint16 constant ORIGIN_YEAR = 1970;\r\n\r\n        function isLeapYear(uint16 year) public pure returns (bool) {\r\n                if (year % 4 != 0) {\r\n                        return false;\r\n                }\r\n                if (year % 100 != 0) {\r\n                        return true;\r\n                }\r\n                if (year % 400 != 0) {\r\n                        return false;\r\n                }\r\n                return true;\r\n        }\r\n\r\n        function leapYearsBefore(uint year) public pure returns (uint) {\r\n                year -= 1;\r\n                return year / 4 - year / 100 + year / 400;\r\n        }\r\n\r\n        function getDaysInMonth(uint8 month, uint16 year) public pure returns (uint8) {\r\n                if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\r\n                        return 31;\r\n                }\r\n                else if (month == 4 || month == 6 || month == 9 || month == 11) {\r\n                        return 30;\r\n                }\r\n                else if (isLeapYear(year)) {\r\n                        return 29;\r\n                }\r\n                else {\r\n                        return 28;\r\n                }\r\n        }\r\n\r\n        function parseTimestamp(uint timestamp) internal pure returns (_DateTime dt) {\r\n                uint secondsAccountedFor = 0;\r\n                uint buf;\r\n                uint8 i;\r\n\r\n                // Year\r\n                dt.year = getYear(timestamp);\r\n                buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\r\n                secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\r\n\r\n                // Month\r\n                uint secondsInMonth;\r\n                for (i = 1; i <= 12; i++) {\r\n                        secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\r\n                        if (secondsInMonth + secondsAccountedFor > timestamp) {\r\n                                dt.month = i;\r\n                                break;\r\n                        }\r\n                        secondsAccountedFor += secondsInMonth;\r\n                }\r\n\r\n                // Day\r\n                for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\r\n                        if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\r\n                                dt.day = i;\r\n                                break;\r\n                        }\r\n                        secondsAccountedFor += DAY_IN_SECONDS;\r\n                }\r\n\r\n                // Hour\r\n                dt.hour = getHour(timestamp);\r\n\r\n                // Minute\r\n                dt.minute = getMinute(timestamp);\r\n\r\n                // Second\r\n                dt.second = getSecond(timestamp);\r\n\r\n                // Day of week.\r\n                dt.weekday = getWeekday(timestamp);\r\n        }\r\n\r\n        function getYear(uint timestamp) public pure returns (uint16) {\r\n                uint secondsAccountedFor = 0;\r\n                uint16 year;\r\n                uint numLeapYears;\r\n\r\n                // Year\r\n                year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\r\n                numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\r\n                secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\r\n\r\n                while (secondsAccountedFor > timestamp) {\r\n                        if (isLeapYear(uint16(year - 1))) {\r\n                                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\r\n                        }\r\n                        else {\r\n                                secondsAccountedFor -= YEAR_IN_SECONDS;\r\n                        }\r\n                        year -= 1;\r\n                }\r\n                return year;\r\n        }\r\n\r\n        function getMonth(uint timestamp) public pure returns (uint8) {\r\n                return parseTimestamp(timestamp).month;\r\n        }\r\n\r\n        function getDay(uint timestamp) public pure returns (uint8) {\r\n                return parseTimestamp(timestamp).day;\r\n        }\r\n\r\n        function getHour(uint timestamp) public pure returns (uint8) {\r\n                return uint8((timestamp / 60 / 60) % 24);\r\n        }\r\n\r\n        function getMinute(uint timestamp) public pure returns (uint8) {\r\n                return uint8((timestamp / 60) % 60);\r\n        }\r\n\r\n        function getSecond(uint timestamp) public pure returns (uint8) {\r\n                return uint8(timestamp % 60);\r\n        }\r\n\r\n        function getWeekday(uint timestamp) public pure returns (uint8) {\r\n                return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);\r\n        }\r\n\r\n        function toTimestamp(uint16 year, uint8 month, uint8 day) public pure returns (uint timestamp) {\r\n                return toTimestamp(year, month, day, 0, 0, 0);\r\n        }\r\n\r\n        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour) public pure returns (uint timestamp) {\r\n                return toTimestamp(year, month, day, hour, 0, 0);\r\n        }\r\n\r\n        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute) public pure returns (uint timestamp) {\r\n                return toTimestamp(year, month, day, hour, minute, 0);\r\n        }\r\n\r\n        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute, uint8 second) public pure returns (uint timestamp) {\r\n                uint16 i;\r\n\r\n                // Year\r\n                for (i = ORIGIN_YEAR; i < year; i++) {\r\n                        if (isLeapYear(i)) {\r\n                                timestamp += LEAP_YEAR_IN_SECONDS;\r\n                        }\r\n                        else {\r\n                                timestamp += YEAR_IN_SECONDS;\r\n                        }\r\n                }\r\n\r\n                // Month\r\n                uint8[12] memory monthDayCounts;\r\n                monthDayCounts[0] = 31;\r\n                if (isLeapYear(year)) {\r\n                        monthDayCounts[1] = 29;\r\n                }\r\n                else {\r\n                        monthDayCounts[1] = 28;\r\n                }\r\n                monthDayCounts[2] = 31;\r\n                monthDayCounts[3] = 30;\r\n                monthDayCounts[4] = 31;\r\n                monthDayCounts[5] = 30;\r\n                monthDayCounts[6] = 31;\r\n                monthDayCounts[7] = 31;\r\n                monthDayCounts[8] = 30;\r\n                monthDayCounts[9] = 31;\r\n                monthDayCounts[10] = 30;\r\n                monthDayCounts[11] = 31;\r\n\r\n                for (i = 1; i < month; i++) {\r\n                        timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\r\n                }\r\n\r\n                // Day\r\n                timestamp += DAY_IN_SECONDS * (day - 1);\r\n\r\n                // Hour\r\n                timestamp += HOUR_IN_SECONDS * (hour);\r\n\r\n                // Minute\r\n                timestamp += MINUTE_IN_SECONDS * (minute);\r\n\r\n                // Second\r\n                timestamp += second;\r\n\r\n                return timestamp;\r\n        }\r\n}\r\n\r\n\r\npragma solidity ^0.4.18;\r\n\r\n/**\r\n * @author OpenZeppelin\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\npragma solidity ^0.4.18;\r\nlibrary PresaleBonuses {\r\n    using SafeMath for uint;\r\n\r\n    function presaleBonusApplicator(uint _purchased, address _dateTimeLib)\r\n        internal view returns (uint reward)\r\n    {\r\n        DateTimeAPI dateTime = DateTimeAPI(_dateTimeLib);\r\n        uint hour = dateTime.getHour(block.timestamp);\r\n        uint day = dateTime.getDay(block.timestamp);\r\n\r\n        /// First 4 hours bonus\r\n        if (day == 2 && hour >= 16 && hour < 20) {\r\n            return applyPercentage(_purchased, 70);\r\n        }\r\n\r\n        /// First day bonus\r\n        if ((day == 2 && hour >= 20) || (day == 3 && hour < 5)) {\r\n            return applyPercentage(_purchased, 50);\r\n        }\r\n\r\n        /// Second day bonus\r\n        if ((day == 3 && hour >= 5) || (day == 4 && hour < 5)) {\r\n            return applyPercentage(_purchased, 45);\r\n        } \r\n\r\n        /// Days 3 - 20 bonus\r\n        if (day < 22) {\r\n            uint numDays = day - 3;\r\n            if (hour < 5) {\r\n                numDays--;\r\n            }\r\n\r\n            return applyPercentage(_purchased, (45 - numDays));\r\n        }\r\n\r\n        /// Fill the gap\r\n        if (day == 22 && hour < 5) {\r\n            return applyPercentage(_purchased, 27);\r\n        }\r\n\r\n        /// Day 21 bonus\r\n        if ((day == 22 && hour >= 5) || (day == 23 && hour < 5)) {\r\n            return applyPercentage(_purchased, 25);\r\n        }\r\n\r\n        /// Day 22 bonus\r\n        if ((day == 23 && hour >= 5) || (day == 24 && hour < 5)) {\r\n            return applyPercentage(_purchased, 20);\r\n        }\r\n\r\n        /// Day 23 bonus\r\n        if ((day == 24 && hour >= 5) || (day == 25 && hour < 5)) {\r\n            return applyPercentage(_purchased, 15);\r\n        }\r\n\r\n        //else\r\n        revert();\r\n    }\r\n\r\n    /// Internal function to apply a specified percentage amount to an integer.\r\n    function applyPercentage(uint _base, uint _percentage)\r\n        internal pure returns (uint num)\r\n    {\r\n        num = _base.mul(_percentage).div(100);\r\n    }\r\n    \r\n}\r\n\r\npragma solidity ^0.4.11;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    function Ownable()\r\n        public\r\n    {\r\n        owner = msg.sender;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(\r\n        address newOwner\r\n    )\r\n        onlyOwner\r\n        public\r\n    {\r\n        require(newOwner != address(0));\r\n        OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\n\r\npragma solidity ^0.4.8;\r\ncontract Token {\r\n    /* This is a slight change to the ERC20 base standard.\r\n    function totalSupply() constant returns (uint256 supply);\r\n    is replaced with:\r\n    uint256 public totalSupply;\r\n    This automatically creates a getter function for the totalSupply.\r\n    This is moved to the base contract since public getter functions are not\r\n    currently recognised as an implementation of the matching abstract\r\n    function by the compiler.\r\n    */\r\n    /// total amount of tokens\r\n    uint256 public totalSupply;\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of tokens to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\npragma solidity ^0.4.8;\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\r\n        require(balances[msg.sender] >= _value);\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\r\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n}\r\n\r\npragma solidity ^0.4.8;\r\ncontract HumanStandardToken is StandardToken {\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n    function HumanStandardToken(\r\n        uint256 _initialAmount,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol\r\n        ) {\r\n        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\r\n        totalSupply = _initialAmount;                        // Update total supply\r\n        name = _tokenName;                                   // Set the name for display purposes\r\n        decimals = _decimalUnits;                            // Amount of decimals for display purposes\r\n        symbol = _tokenSymbol;                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\r\n        return true;\r\n    }\r\n}\r\n\r\npragma solidity ^0.4.17;\r\n/**\r\n * SHARE token is an ERC20 token.\r\n */\r\ncontract Share is HumanStandardToken, Ownable {\r\n    using SafeMath for uint;\r\n\r\n    string public constant TOKEN_NAME = \"Vyral Token\";\r\n\r\n    string public constant TOKEN_SYMBOL = \"SHARE\";\r\n\r\n    uint8 public constant TOKEN_DECIMALS = 18;\r\n\r\n    uint public constant TOTAL_SUPPLY = 777777777 * (10 ** uint(TOKEN_DECIMALS));\r\n\r\n    mapping (address => uint256) lockedBalances;\r\n\r\n    mapping (address => bool) public transferrers;\r\n\r\n    /**\r\n     * Init this contract with the same params as a HST.\r\n     */\r\n    function Share() HumanStandardToken(TOTAL_SUPPLY, TOKEN_NAME, TOKEN_DECIMALS, TOKEN_SYMBOL)\r\n        public\r\n    {\r\n        transferrers[msg.sender] = true;\r\n    }\r\n\r\n    ///-----------------\r\n    /// Overrides\r\n    ///-----------------\r\n\r\n    /// Off on deployment.\r\n    bool isTransferable = false;\r\n\r\n    /// Bonus tokens are locked on deployment\r\n    bool isBonusLocked = true;\r\n\r\n    /// Allows the owner to transfer tokens whenever, but others to only transfer after owner says so.\r\n    modifier canBeTransferred {\r\n        require(transferrers[msg.sender] || isTransferable);\r\n        _;\r\n    }\r\n\r\n    function transferReward(\r\n        address _to,\r\n        uint _value\r\n    )\r\n        canBeTransferred\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(balances[msg.sender] >= _value);\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n\r\n        lockedBalances[_to] = lockedBalances[_to].add(_value);\r\n\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transfer(\r\n        address _to,\r\n        uint _value\r\n    )\r\n        canBeTransferred\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(balances[msg.sender] >= _value);\r\n\r\n        /// Only transfer unlocked balance\r\n        if(isBonusLocked) {\r\n            require(balances[msg.sender].sub(lockedBalances[msg.sender]) >= _value);\r\n        }\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint _value\r\n    )\r\n        canBeTransferred\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(balances[_from] >= _value);\r\n        require(allowed[_from][msg.sender] >= _value);\r\n\r\n        /// Only transfer unlocked balance\r\n        if(isBonusLocked) {\r\n            require(balances[_from].sub(lockedBalances[_from]) >= _value);\r\n        }\r\n\r\n        allowed[_from][msg.sender] = allowed[_from][_to].sub(_value);\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function lockedBalanceOf(\r\n        address _owner\r\n    )\r\n        constant\r\n        returns (uint)\r\n    {\r\n        return lockedBalances[_owner];\r\n    }\r\n\r\n    ///-----------------\r\n    /// Admin\r\n    ///-----------------\r\n\r\n    function enableTransfers()\r\n        onlyOwner\r\n        external\r\n        returns (bool)\r\n    {\r\n        isTransferable = true;\r\n\r\n        return isTransferable;\r\n    }\r\n\r\n    function addTransferrer(\r\n        address _transferrer\r\n    )\r\n        public\r\n        onlyOwner\r\n    {\r\n        transferrers[_transferrer] = true;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Allow bonus tokens to be withdrawn\r\n     */\r\n    function releaseBonus()\r\n        public\r\n        onlyOwner\r\n    {\r\n        isBonusLocked = false;\r\n    }\r\n\r\n}\r\n\r\npragma solidity ^0.4.18;\r\n\r\n/**\r\n * A {Campaign} represents an advertising campaign.\r\n */\r\ncontract Campaign is Ownable {\r\n    using SafeMath for uint;\r\n    using Referral for Referral.Tree;\r\n    using TieredPayoff for Referral.Tree;\r\n\r\n    /// The referral tree (k-ary tree)\r\n    Referral.Tree vyralTree;\r\n\r\n    /// Token in use\r\n    Share public token;\r\n\r\n    /// Budget of the campaign\r\n    uint public budget;\r\n\r\n    /// Tokens spent\r\n    uint public cost;\r\n\r\n    /*\r\n     * Modifiers\r\n     */\r\n\r\n    modifier onlyNonZeroAddress(address _a) {\r\n        require(_a != 0);\r\n        _;\r\n    }\r\n\r\n    modifier onlyNonSelfReferral(address _referrer, address _invitee) {\r\n        require(_referrer != _invitee);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOnReferral(address _invitee) {\r\n        require(getReferrer(_invitee) != 0x0);\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfFundsAvailable() {\r\n        require(getAvailableBalance() >= 0);\r\n        _;\r\n    }\r\n\r\n\r\n    /*\r\n     * Events\r\n     */\r\n\r\n    /// A new campaign was created\r\n    event LogCampaignCreated(address campaign);\r\n\r\n    /// Reward allocated\r\n    event LogRewardAllocated(address referrer, uint inviteeShares, uint referralReward);\r\n\r\n\r\n    /**\r\n     * Create a new campaign.\r\n     */\r\n    function Campaign(\r\n        address _token,\r\n        uint256 _budgetAmount\r\n    )\r\n        public\r\n    {\r\n        token = Share(_token);\r\n        budget = _budgetAmount;\r\n    }\r\n\r\n    /**\r\n     * @dev Accept invitation and join contract. If referrer address is non-zero,\r\n     * calculate reward and transfer tokens to referrer. Referrer address will be\r\n     * zero if referrer is not found in the referral tree. Don't throw in such a\r\n     * scenario.\r\n     */\r\n    function join(\r\n        address _referrer,\r\n        address _invitee,\r\n        uint _shares\r\n    )\r\n        public\r\n        onlyOwner\r\n        onlyNonZeroAddress(_invitee)\r\n        onlyNonSelfReferral(_referrer, _invitee)\r\n        onlyIfFundsAvailable()\r\n        returns(uint reward)\r\n    {\r\n        Referral.Node memory referrerNode = vyralTree.nodes[_referrer];\r\n\r\n        // Referrer was not found, add referrer as a new node\r\n        if(referrerNode.exists == false) {\r\n            vyralTree.addInvitee(owner, _referrer, 0);\r\n        }\r\n\r\n        // Add invitee to the tree\r\n        vyralTree.addInvitee(_referrer, _invitee, _shares);\r\n\r\n        // Calculate referrer's reward\r\n        reward = vyralTree.payoff(_referrer);\r\n\r\n        // Log event\r\n        LogRewardAllocated(_referrer, _shares, reward);\r\n    }\r\n\r\n    /**\r\n     * VyralSale (owner) transfers rewards on behalf of this contract.\r\n     */\r\n    function sendReward(address _who, uint _amount)\r\n        onlyOwner //(ie, VyralSale)\r\n        external returns (bool)\r\n    {\r\n        if(getAvailableBalance() >= _amount) {\r\n            token.transferReward(_who, _amount);\r\n            cost = cost.add(_amount);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return referral key of caller.\r\n     */\r\n    function getReferrer(\r\n        address _invitee\r\n    )\r\n        public\r\n        constant\r\n        returns (address _referrer)\r\n    {\r\n        _referrer = vyralTree.getReferrer(_invitee);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the size of the Referral Tree.\r\n     */\r\n    function getTreeSize()\r\n        public\r\n        constant\r\n        returns (uint _size)\r\n    {\r\n        _size = vyralTree.getTreeSize();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the budget as a tuple, (token address, amount)\r\n     */\r\n    function getBudget()\r\n        public\r\n        constant\r\n        returns (address _token, uint _amount)\r\n    {\r\n        _token = token;\r\n        _amount = budget;\r\n    }\r\n\r\n    /**\r\n     * @dev Return (budget - cost)\r\n     */\r\n    function getAvailableBalance()\r\n        public\r\n        constant\r\n        returns (uint _balance)\r\n    {\r\n        _balance = (budget - cost);\r\n    }\r\n\r\n    /**\r\n     * Fallback. Don't send ETH to a campaign.\r\n     */\r\n    function() public {\r\n        revert();\r\n    }\r\n}\r\n\r\npragma solidity ^0.4.17;\r\ncontract Vesting is Ownable {\r\n    using SafeMath for uint;\r\n\r\n    Token public vestingToken;          // The address of the vesting token.\r\n\r\n    struct VestingSchedule {\r\n        uint startTimestamp;            // Timestamp of when vesting begins.\r\n        uint cliffTimestamp;            // Timestamp of when the cliff begins.\r\n        uint lockPeriod;                // Amount of time in seconds between withdrawal periods. (EG. 6 months or 1 month)\r\n        uint endTimestamp;              // Timestamp of when vesting ends and tokens are completely available.\r\n        uint totalAmount;               // Total amount of tokens to be vested.\r\n        uint amountWithdrawn;           // The amount that has been withdrawn.\r\n        address depositor;              // Address of the depositor of the tokens to be vested. (Crowdsale contract)\r\n        bool isConfirmed;               // True if the registered address has confirmed the vesting schedule.\r\n    }\r\n\r\n    // The vesting schedule attached to a specific address.\r\n    mapping (address => VestingSchedule) vestingSchedules;\r\n\r\n    /// @dev Assigns a token to be vested in this contract.\r\n    /// @param _token Address of the token to be vested.\r\n    function Vesting(address _token) public {\r\n        vestingToken = Token(_token);\r\n    }\r\n\r\n    function registerVestingSchedule(address _newAddress,\r\n                                    address _depositor,\r\n                                    uint _startTimestamp,\r\n                                    uint _cliffTimestamp,\r\n                                    uint _lockPeriod,\r\n                                    uint _endTimestamp,\r\n                                    uint _totalAmount)\r\n        public onlyOwner\r\n    {\r\n        // Check that we are registering a depositor and the address we register to vest to \r\n        //  does not already have a depositor.\r\n        require( _depositor != 0x0 );\r\n        require( vestingSchedules[_newAddress].depositor == 0x0 );\r\n\r\n        // Validate that the times make sense.\r\n        require( _cliffTimestamp >= _startTimestamp );\r\n        require( _endTimestamp > _cliffTimestamp );\r\n\r\n        // Some lock period sanity checks.\r\n        require( _lockPeriod != 0 ); \r\n        require( _endTimestamp.sub(_startTimestamp) > _lockPeriod );\r\n\r\n        // Register the new address.\r\n        vestingSchedules[_newAddress] = VestingSchedule({\r\n            startTimestamp: _startTimestamp,\r\n            cliffTimestamp: _cliffTimestamp,\r\n            lockPeriod: _lockPeriod,\r\n            endTimestamp: _endTimestamp,\r\n            totalAmount: _totalAmount,\r\n            amountWithdrawn: 0,\r\n            depositor: _depositor,\r\n            isConfirmed: false\r\n        });\r\n\r\n        // Log that we registered a new address.\r\n        VestingScheduleRegistered(\r\n            _newAddress,\r\n            _depositor,\r\n            _startTimestamp,\r\n            _lockPeriod,\r\n            _cliffTimestamp,\r\n            _endTimestamp,\r\n            _totalAmount\r\n        );\r\n    }\r\n\r\n    function confirmVestingSchedule(uint _startTimestamp,\r\n                                    uint _cliffTimestamp,\r\n                                    uint _lockPeriod,\r\n                                    uint _endTimestamp,\r\n                                    uint _totalAmount)\r\n        public\r\n    {\r\n        VestingSchedule storage vestingSchedule = vestingSchedules[msg.sender];\r\n\r\n        // Check that the msg.sender has been registered but not confirmed yet.\r\n        require( vestingSchedule.depositor != 0x0 );\r\n        require( vestingSchedule.isConfirmed == false );\r\n\r\n        // Validate the same information was registered that is being confirmed.\r\n        require( vestingSchedule.startTimestamp == _startTimestamp );\r\n        require( vestingSchedule.cliffTimestamp == _cliffTimestamp );\r\n        require( vestingSchedule.lockPeriod == _lockPeriod );\r\n        require( vestingSchedule.endTimestamp == _endTimestamp );\r\n        require( vestingSchedule.totalAmount == _totalAmount );\r\n\r\n        // Confirm the schedule and move the tokens here.\r\n        vestingSchedule.isConfirmed = true;\r\n        require(vestingToken.transferFrom(vestingSchedule.depositor, address(this), _totalAmount));\r\n\r\n        // Log that the vesting schedule was confirmed.\r\n        VestingScheduleConfirmed(\r\n            msg.sender,\r\n            vestingSchedule.depositor,\r\n            vestingSchedule.startTimestamp,\r\n            vestingSchedule.cliffTimestamp,\r\n            vestingSchedule.lockPeriod,\r\n            vestingSchedule.endTimestamp,\r\n            vestingSchedule.totalAmount\r\n        );\r\n    }\r\n\r\n    function withdrawVestedTokens()\r\n        public \r\n    {\r\n        VestingSchedule storage vestingSchedule = vestingSchedules[msg.sender];\r\n\r\n        // Check that the vesting schedule was registered and it's after cliff time.\r\n        require( vestingSchedule.isConfirmed == true );\r\n        require( vestingSchedule.cliffTimestamp <= now );\r\n\r\n        uint totalAmountVested = calculateTotalAmountVested(vestingSchedule);\r\n        uint amountWithdrawable = totalAmountVested.sub(vestingSchedule.amountWithdrawn);\r\n        vestingSchedule.amountWithdrawn = totalAmountVested;\r\n\r\n        if (amountWithdrawable > 0) {\r\n            canWithdraw(vestingSchedule, amountWithdrawable);\r\n            require( vestingToken.transfer(msg.sender, amountWithdrawable) );\r\n            Withdraw(msg.sender, amountWithdrawable);\r\n        }\r\n    }\r\n\r\n    function calculateTotalAmountVested(VestingSchedule _vestingSchedule)\r\n        internal view returns (uint _amountVested)\r\n    {\r\n        // If it's past the end time, the whole amount is available.\r\n        if (now >= _vestingSchedule.endTimestamp) {\r\n            return _vestingSchedule.totalAmount;\r\n        }\r\n\r\n        // Otherwise, math\r\n        uint durationSinceStart = now.sub(_vestingSchedule.startTimestamp);\r\n        uint totalVestingTime = SafeMath.sub(_vestingSchedule.endTimestamp, _vestingSchedule.startTimestamp);\r\n        uint vestedAmount = SafeMath.div(\r\n            SafeMath.mul(durationSinceStart, _vestingSchedule.totalAmount),\r\n            totalVestingTime\r\n        );\r\n\r\n        return vestedAmount;\r\n    }\r\n\r\n    /// @dev Checks to see if the amount is greater than the total amount divided by the lock periods.\r\n    function canWithdraw(VestingSchedule _vestingSchedule, uint _amountWithdrawable)\r\n        internal view\r\n    {\r\n        uint lockPeriods = (_vestingSchedule.endTimestamp.sub(_vestingSchedule.startTimestamp))\r\n                                                         .div(_vestingSchedule.lockPeriod);\r\n\r\n        if (now < _vestingSchedule.endTimestamp) {\r\n            require( _amountWithdrawable >= _vestingSchedule.totalAmount.div(lockPeriods) );\r\n        }\r\n    }\r\n\r\n    /** ADMIN FUNCTIONS */\r\n\r\n    function revokeSchedule(address _addressToRevoke, address _addressToRefund)\r\n        public onlyOwner\r\n    {\r\n        VestingSchedule storage vestingSchedule = vestingSchedules[_addressToRevoke];\r\n\r\n        require( vestingSchedule.isConfirmed == true );\r\n        require( _addressToRefund != 0x0 );\r\n\r\n        uint amountWithdrawable;\r\n        uint amountRefundable;\r\n\r\n        if (now < vestingSchedule.cliffTimestamp) {\r\n            // Vesting hasn't started yet, return the whole amount\r\n            amountRefundable = vestingSchedule.totalAmount;\r\n\r\n            delete vestingSchedules[_addressToRevoke];\r\n            require( vestingToken.transfer(_addressToRefund, amountRefundable) );\r\n        } else {\r\n            // Vesting has started, need to figure out how much hasn't been vested yet\r\n            uint totalAmountVested = calculateTotalAmountVested(vestingSchedule);\r\n            amountWithdrawable = totalAmountVested.sub(vestingSchedule.amountWithdrawn);\r\n            amountRefundable = totalAmountVested.sub(vestingSchedule.amountWithdrawn);\r\n\r\n            delete vestingSchedules[_addressToRevoke];\r\n            require( vestingToken.transfer(_addressToRevoke, amountWithdrawable) );\r\n            require( vestingToken.transfer(_addressToRefund, amountRefundable) );\r\n        }\r\n\r\n        VestingRevoked(_addressToRevoke, amountWithdrawable, amountRefundable);\r\n    }\r\n\r\n    /// @dev Changes the address for a schedule in the case of lost keys or other emergency events.\r\n    function changeVestingAddress(address _oldAddress, address _newAddress)\r\n        public onlyOwner\r\n    {\r\n        VestingSchedule storage vestingSchedule = vestingSchedules[_oldAddress];\r\n\r\n        require( vestingSchedule.isConfirmed == true );\r\n        require( _newAddress != 0x0 );\r\n        require( vestingSchedules[_newAddress].depositor == 0x0 );\r\n\r\n        VestingSchedule memory newVestingSchedule = vestingSchedule;\r\n        delete vestingSchedules[_oldAddress];\r\n        vestingSchedules[_newAddress] = newVestingSchedule;\r\n\r\n        VestingAddressChanged(_oldAddress, _newAddress);\r\n    }\r\n\r\n    event VestingScheduleRegistered(\r\n        address registeredAddress,\r\n        address depositor,\r\n        uint startTimestamp,\r\n        uint cliffTimestamp,\r\n        uint lockPeriod,\r\n        uint endTimestamp,\r\n        uint totalAmount\r\n    );\r\n    event VestingScheduleConfirmed(\r\n        address registeredAddress,\r\n        address depositor,\r\n        uint startTimestamp,\r\n        uint cliffTimestamp,\r\n        uint lockPeriod,\r\n        uint endTimestamp,\r\n        uint totalAmount\r\n    );\r\n    event Withdraw(address registeredAddress, uint amountWithdrawn);\r\n    event VestingRevoked(address revokedAddress, uint amountWithdrawn, uint amountRefunded);\r\n    event VestingAddressChanged(address oldAddress, address newAddress);\r\n}\r\n\r\n\r\n// Vesting Schedules\r\n// ...................\r\n// Team tokens will be vested over 18 months with a 1/3 vested after 6 months, 1/3 vested after 12 months and 1/3 vested \r\n// after 18 months. \r\n// Partnership and Development + Sharing Bounties + Reserves tokens will be vested over two years with 1/24 \r\n// available upfront and 1/24 available each month after\r\n\r\npragma solidity ^0.4.18;\r\ncontract VyralSale is Ownable {\r\n    using SafeMath for uint;\r\n\r\n    uint public constant MIN_CONTRIBUTION = 1 ether;\r\n\r\n    enum Phase {\r\n        Deployed,       //0\r\n        Initialized,    //1\r\n        Presale,        //2\r\n        Freeze,         //3\r\n        Ready,          //4\r\n        Crowdsale,      //5\r\n        Finalized,      //6\r\n        Decomissioned   //7\r\n    }\r\n\r\n    Phase public phase;\r\n\r\n    /**\r\n     * PRESALE PARAMS\r\n     */\r\n\r\n    uint public presaleStartTimestamp;\r\n\r\n    uint public presaleEndTimestamp;\r\n\r\n    uint public presaleRate;\r\n\r\n    uint public presaleCap;\r\n\r\n    bool public presaleCapReached;\r\n\r\n    uint public soldPresale;\r\n\r\n    /**\r\n     * CROWDSALE PARAMS\r\n     */\r\n\r\n    uint public saleStartTimestamp;\r\n\r\n    uint public saleEndTimestamp;\r\n\r\n    uint public saleRate;\r\n\r\n    uint public saleCap;\r\n\r\n    bool public saleCapReached;\r\n\r\n    uint public soldSale;\r\n\r\n    /**\r\n     * GLOBAL PARAMS\r\n     */\r\n    address public wallet;\r\n\r\n    address public vestingWallet;\r\n\r\n    Share public shareToken;\r\n\r\n    Campaign public campaign;\r\n\r\n    DateTime public dateTime;\r\n\r\n    bool public vestingRegistered;\r\n\r\n    /**\r\n     * Token and budget allocation constants\r\n     */\r\n    uint public constant TOTAL_SUPPLY = 777777777 * (10 ** uint(18));\r\n\r\n    uint public constant TEAM = TOTAL_SUPPLY.div(7);\r\n\r\n    uint public constant PARTNERS = TOTAL_SUPPLY.div(7);\r\n\r\n    uint public constant VYRAL_REWARDS = TOTAL_SUPPLY.div(7).mul(2);\r\n\r\n    uint public constant SALE_ALLOCATION = TOTAL_SUPPLY.div(7).mul(3);\r\n\r\n    /**\r\n     * MODIFIERS\r\n     */\r\n\r\n    modifier inPhase(Phase _phase) {\r\n        require(phase == _phase);\r\n        _;\r\n    }\r\n\r\n    modifier canBuy(Phase _phase) {\r\n        require(phase == Phase.Presale || phase == Phase.Crowdsale);\r\n\r\n        if (_phase == Phase.Presale) {\r\n            require(block.timestamp >= presaleStartTimestamp);\r\n        }\r\n        if (_phase == Phase.Crowdsale) {\r\n            require(block.timestamp >= saleStartTimestamp);\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier stopInEmergency {\r\n        require(!HALT);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * PHASES\r\n     */\r\n\r\n    /**\r\n     * Initialize Vyral sales.\r\n     */\r\n    function VyralSale(\r\n        address _share,\r\n        address _datetime\r\n    )\r\n        public\r\n    {\r\n        phase = Phase.Deployed;\r\n\r\n        shareToken = Share(_share);\r\n        dateTime = DateTime(_datetime);\r\n    }\r\n\r\n    function initPresale(\r\n        address _wallet,\r\n        uint _presaleStartTimestamp,\r\n        uint _presaleEndTimestamp,\r\n        uint _presaleCap,\r\n        uint _presaleRate\r\n    )\r\n        inPhase(Phase.Deployed)\r\n        onlyOwner\r\n        external returns (bool)\r\n    {\r\n        require(_wallet != 0x0);\r\n        require(_presaleStartTimestamp >= block.timestamp);\r\n        require(_presaleEndTimestamp > _presaleStartTimestamp);\r\n        require(_presaleCap < SALE_ALLOCATION.div(_presaleRate));\r\n\r\n        /// Campaign must be set first.\r\n        require(address(campaign) != 0x0);\r\n\r\n        wallet = _wallet;\r\n        presaleStartTimestamp = _presaleStartTimestamp;\r\n        presaleEndTimestamp = _presaleEndTimestamp;\r\n        presaleCap = _presaleCap;\r\n        presaleRate = _presaleRate;\r\n\r\n        shareToken.transfer(address(campaign), VYRAL_REWARDS);\r\n\r\n        phase = Phase.Initialized;\r\n        return true;\r\n    }\r\n\r\n    /// Step 1.5 - Register Vesting Schedules\r\n\r\n    function startPresale()\r\n        inPhase(Phase.Initialized)\r\n        onlyOwner\r\n        external returns (bool)\r\n    {\r\n        phase = Phase.Presale;\r\n        return true;\r\n    }\r\n\r\n    function endPresale()\r\n        inPhase(Phase.Presale)\r\n        onlyOwner\r\n        external returns (bool)\r\n    {\r\n        phase = Phase.Freeze;\r\n        return true;\r\n    }\r\n\r\n    function initSale(\r\n        uint _saleStartTimestamp,\r\n        uint _saleEndTimestamp,\r\n        uint _saleRate\r\n    )\r\n        inPhase(Phase.Freeze)\r\n        onlyOwner\r\n        external returns (bool)\r\n    {\r\n        require(_saleStartTimestamp >= block.timestamp);\r\n        require(_saleEndTimestamp > _saleStartTimestamp);\r\n\r\n        saleStartTimestamp = _saleStartTimestamp;\r\n        saleEndTimestamp = _saleEndTimestamp;\r\n        saleRate = _saleRate;\r\n        saleCap = (SALE_ALLOCATION.div(_saleRate)).sub(presaleCap);\r\n        phase = Phase.Ready;\r\n        return true;\r\n    }\r\n\r\n    function startSale()\r\n        inPhase(Phase.Ready)\r\n        onlyOwner\r\n        external returns (bool)\r\n    {\r\n        phase = Phase.Crowdsale;\r\n        return true;\r\n    }\r\n\r\n    function finalizeSale()\r\n        inPhase(Phase.Crowdsale)\r\n        onlyOwner\r\n        external returns (bool)\r\n    {\r\n        phase = Phase.Finalized;\r\n        return true;\r\n    }\r\n\r\n    function decomission()\r\n        onlyOwner\r\n        external returns (bool)\r\n    {\r\n        phase = Phase.Decomissioned;\r\n        return true;\r\n    }\r\n\r\n    /** BUY TOKENS */\r\n\r\n    function()\r\n        stopInEmergency\r\n        public payable\r\n    {\r\n        if (phase == Phase.Presale) {\r\n            buyPresale(0x0);\r\n        } else if (phase == Phase.Crowdsale) {\r\n            buySale(0x0);\r\n        } else {\r\n            revert();\r\n        }\r\n    }\r\n\r\n    function buyPresale(address _referrer)\r\n        inPhase(Phase.Presale)\r\n        canBuy(Phase.Presale)\r\n        stopInEmergency\r\n        public payable\r\n    {\r\n        require(msg.value >= MIN_CONTRIBUTION);\r\n        require(!presaleCapReached);\r\n\r\n        uint contribution = msg.value;\r\n        uint purchased = contribution.mul(presaleRate);\r\n        uint totalSold = soldPresale.add(contribution);\r\n\r\n        uint excess;\r\n\r\n        // extra ether sent\r\n        if (totalSold >= presaleCap) {\r\n            excess = totalSold.sub(presaleCap);\r\n            if (excess > 0) {\r\n                purchased = purchased.sub(excess.mul(presaleRate));\r\n                contribution = contribution.sub(excess);\r\n                msg.sender.transfer(excess);\r\n            }\r\n            presaleCapReached = true;\r\n        }\r\n\r\n        soldPresale = totalSold;\r\n        wallet.transfer(contribution);\r\n        shareToken.transfer(msg.sender, purchased);\r\n\r\n        /// Calculate reward and send it from campaign.\r\n        uint reward = PresaleBonuses.presaleBonusApplicator(purchased, address(dateTime));\r\n        campaign.sendReward(msg.sender, reward);\r\n\r\n        if (_referrer != address(0x0)) {\r\n            uint referralReward = campaign.join(_referrer, msg.sender, purchased);\r\n            campaign.sendReward(_referrer, referralReward);\r\n            LogReferral(_referrer, msg.sender, referralReward);\r\n        }\r\n\r\n        LogContribution(phase, msg.sender, contribution);\r\n    }\r\n\r\n    function buySale(address _referrer)\r\n        inPhase(Phase.Crowdsale)\r\n        canBuy(Phase.Crowdsale)\r\n        stopInEmergency\r\n        public payable\r\n    {\r\n        require(msg.value >= MIN_CONTRIBUTION);\r\n        require(!saleCapReached);\r\n\r\n        uint contribution = msg.value;\r\n        uint purchased = contribution.mul(saleRate);\r\n        uint totalSold = soldSale.add(contribution);\r\n\r\n        uint excess;\r\n\r\n        // extra ether sent\r\n        if (totalSold >= saleCap) {\r\n            excess = totalSold.sub(saleCap);\r\n            if (excess > 0) {\r\n                purchased = purchased.sub(excess.mul(saleRate));\r\n                contribution = contribution.sub(excess);\r\n                msg.sender.transfer(excess);\r\n            }\r\n            saleCapReached = true;\r\n        }\r\n\r\n        soldSale = totalSold;\r\n        wallet.transfer(contribution);\r\n        shareToken.transfer(msg.sender, purchased);\r\n\r\n        if (_referrer != address(0x0)) {\r\n            uint referralReward = campaign.join(_referrer, msg.sender, purchased);\r\n            campaign.sendReward(_referrer, referralReward);\r\n            LogReferral(_referrer, msg.sender, referralReward);\r\n        }\r\n\r\n        LogContribution(phase, msg.sender, contribution);\r\n    }\r\n\r\n    /**\r\n     * ADMIN SETTERS\r\n     */\r\n\r\n    function setPresaleParams(\r\n        uint _presaleStartTimestamp,\r\n        uint _presaleEndTimestamp,\r\n        uint _presaleRate,\r\n        uint _presaleCap\r\n    )\r\n        onlyOwner\r\n        inPhase(Phase.Initialized)\r\n        external returns (bool)\r\n    {\r\n        require(_presaleStartTimestamp >= block.timestamp);\r\n        require(_presaleEndTimestamp > _presaleStartTimestamp);\r\n        require(_presaleCap < SALE_ALLOCATION.div(_presaleRate));\r\n\r\n        presaleStartTimestamp = _presaleStartTimestamp;\r\n        presaleEndTimestamp = _presaleEndTimestamp;\r\n        presaleRate = _presaleRate;\r\n        presaleCap = _presaleCap;\r\n    }\r\n\r\n    function setCrowdsaleParams(\r\n        uint _saleStartTimestamp,\r\n        uint _saleEndTimestamp,\r\n        uint _saleRate\r\n    )\r\n        onlyOwner\r\n        inPhase(Phase.Ready)\r\n        external returns (bool)\r\n    {\r\n        require(_saleStartTimestamp >= block.timestamp);\r\n        require(_saleEndTimestamp > _saleStartTimestamp);\r\n\r\n        saleStartTimestamp = _saleStartTimestamp;\r\n        saleEndTimestamp = _saleEndTimestamp;\r\n        saleRate = _saleRate;\r\n        saleCap = (SALE_ALLOCATION.div(_saleRate)).sub(presaleCap);\r\n    }\r\n\r\n    function rewardBeneficiary(\r\n        address _beneficiary,\r\n        uint _tokens\r\n    )\r\n        onlyOwner\r\n        external returns (bool)\r\n    {\r\n        return campaign.sendReward(_beneficiary, _tokens);\r\n    }\r\n\r\n    function distributeTimelockedTokens(\r\n        address _beneficiary,\r\n        uint _tokens\r\n    )\r\n        onlyOwner\r\n        external returns (bool)\r\n    {\r\n        return shareToken.transfer(_beneficiary, _tokens);\r\n    }\r\n\r\n    function replaceDecomissioned(address _newAddress)\r\n        onlyOwner\r\n        inPhase(Phase.Decomissioned)\r\n        external returns (bool)\r\n    {\r\n        uint allTokens = shareToken.balanceOf(address(this));\r\n        shareToken.transfer(_newAddress, allTokens);\r\n        campaign.transferOwnership(_newAddress);\r\n\r\n        return true;\r\n    }\r\n\r\n    function setCampaign(\r\n        address _newCampaign\r\n    )\r\n        onlyOwner\r\n        external returns (bool)\r\n    {\r\n        require(address(campaign) != _newCampaign && _newCampaign != 0x0);\r\n        campaign = Campaign(_newCampaign);\r\n\r\n        return true;\r\n    }\r\n\r\n    function setVesting(\r\n        address _newVesting\r\n    )\r\n        onlyOwner\r\n        external returns (bool)\r\n    {\r\n        require(address(vestingWallet) != _newVesting && _newVesting != 0x0);\r\n        vestingWallet = Vesting(_newVesting);\r\n        shareToken.approve(address(vestingWallet), TEAM.add(PARTNERS));\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * EMERGENCY SWITCH\r\n     */\r\n    bool public HALT = false;\r\n\r\n    function toggleHALT(bool _on)\r\n        onlyOwner\r\n        external returns (bool)\r\n    {\r\n        HALT = _on;\r\n        return HALT;\r\n    }\r\n\r\n    /**\r\n     * LOGS\r\n     */\r\n    event LogContribution(Phase phase, address buyer, uint contribution);\r\n\r\n    event LogReferral(address referrer, address invitee, uint referralReward);\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"startPresale\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vestingWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"distributeTimelockedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleCapReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleStartTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"rewardBeneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_CONTRIBUTION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_saleStartTimestamp\",\"type\":\"uint256\"},{\"name\":\"_saleEndTimestamp\",\"type\":\"uint256\"},{\"name\":\"_saleRate\",\"type\":\"uint256\"}],\"name\":\"initSale\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_on\",\"type\":\"bool\"}],\"name\":\"toggleHALT\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presaleRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dateTime\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"HALT\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"soldPresale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presaleStartTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalizeSale\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presaleCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"shareToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCampaign\",\"type\":\"address\"}],\"name\":\"setCampaign\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newVesting\",\"type\":\"address\"}],\"name\":\"setVesting\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"buySale\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VYRAL_REWARDS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presaleEndTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"campaign\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vestingRegistered\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"buyPresale\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOTAL_SUPPLY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_presaleStartTimestamp\",\"type\":\"uint256\"},{\"name\":\"_presaleEndTimestamp\",\"type\":\"uint256\"},{\"name\":\"_presaleCap\",\"type\":\"uint256\"},{\"name\":\"_presaleRate\",\"type\":\"uint256\"}],\"name\":\"initPresale\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PARTNERS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presaleCapReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endPresale\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"phase\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startSale\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleEndTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TEAM\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"decomission\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_presaleStartTimestamp\",\"type\":\"uint256\"},{\"name\":\"_presaleEndTimestamp\",\"type\":\"uint256\"},{\"name\":\"_presaleRate\",\"type\":\"uint256\"},{\"name\":\"_presaleCap\",\"type\":\"uint256\"}],\"name\":\"setPresaleParams\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SALE_ALLOCATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"replaceDecomissioned\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_saleStartTimestamp\",\"type\":\"uint256\"},{\"name\":\"_saleEndTimestamp\",\"type\":\"uint256\"},{\"name\":\"_saleRate\",\"type\":\"uint256\"}],\"name\":\"setCrowdsaleParams\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"soldSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_share\",\"type\":\"address\"},{\"name\":\"_datetime\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"phase\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"contribution\",\"type\":\"uint256\"}],\"name\":\"LogContribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"invitee\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"referralReward\",\"type\":\"uint256\"}],\"name\":\"LogReferral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"VyralSale","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000006f69ef58ddec9cd6ee428253c607a0acd13da05f0000000000000000000000003bbc4826daf4ac26c4365e83299db54015341512","Library":"","SwarmSource":"bzzr://231925a15f4588ef8f134f2bff4549a46d9cbfdd499237b21270ea0f2cf79dc2"}]}