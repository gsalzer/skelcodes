{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\ncontract EInterface { \r\n   \t  \r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) { }\r\n    function transferFrom(address _from, address _to, uint256 _value)  {}\r\n}\r\n\r\n\r\ncontract BidAskX {  \r\n   \r\n    //--------------------------------------------------------------------------EInterface\r\n    function allow_spend(address _coin) private returns(uint){  \r\n        EInterface pixiu = EInterface(_coin);\r\n        uint allow = pixiu.allowance(msg.sender, this);\r\n        return allow;\r\n        \r\n    }\r\n             \r\n    function transferFromTx(address _coin, address _from, address _to, uint256 _value) private {\r\n        EInterface pixiu = EInterface(_coin); \r\n        pixiu.transferFrom(_from, _to, _value);\r\n    }     \r\n    \r\n    //--------------------------------------------------------------------------event\r\n    event Logs(string); \r\n    event Log(string data, uint value, uint value1); \r\n    event Println(address _address,uint32 number, uint price, uint qty, uint ex_qty, bool isClosed,uint32 n32);\r\n    event Paydata(address indexed payer, uint256 value, bytes data, uint256 balances);\r\n        \r\n    //--------------------------------------------------------------------------admin\r\n    mapping (address => AdminType) admins;  \r\n    address[] adminArray;   \r\n    enum AdminType { none, normal, agent, admin, widthdraw }\r\n\r\n    //--------------------------------------------------------------------------member\r\n    struct Member {\r\n        bool isExists;                                    \r\n        bool isWithdraw;                                  \r\n        uint deposit;\r\n        uint withdraw;\r\n        uint balances;\r\n        uint bid_amount;\r\n        uint tx_amount;\r\n        uint ask_qty;\r\n        uint tx_qty;\r\n        address agent;\r\n    }\r\n    mapping (address => Member) public members;  \r\n    address[] public memberArray;\r\n\r\n    //--------------------------------------------------------------------------order\r\n    uint32 public order_number=1;\r\n    struct OrderSheet {\r\n        bool isAsk;\r\n        uint32 number;\r\n        address owner;\r\n        uint price;\r\n        uint qty;\r\n        uint amount;\r\n        uint exFee;\r\n        uint ex_qty;\r\n        bool isClosed;\r\n    }\r\n    address[] public tokensArray; \r\n    mapping (address => bool) tokens; \r\n    mapping (address => uint32[]) public token_ask; \r\n    mapping (address => uint32[]) public token_bid; \r\n    mapping (address => mapping(address => uint32[])) public token_member_order;\r\n    mapping (address => mapping(uint32 => OrderSheet)) public token_orderSheet;  \r\n\r\n    //--------------------------------------------------------------------------public\r\n    bool public isPayable = true;\r\n    bool public isWithdrawable = true;\r\n    bool public isRequireData = false;\r\n\tuint public MinimalPayValue = 0;\r\n\tuint public exFeeRate = 1000;\r\n\tuint public exFeeTotal = 0;\r\n    \r\n\r\n    function BidAskX(){  \r\n        \r\n        adminArray.push(msg.sender); \r\n        admins[msg.sender]=AdminType.widthdraw;\r\n        //ask(this);\r\n        \r\n    }\r\n\r\n    function list_token_ask(address _token){\r\n        uint32[] storage numbers = token_ask[_token];\r\n        for(uint i=0;i<numbers.length;i++){\r\n            uint32 n32 = numbers[i];\r\n            OrderSheet storage oa = token_orderSheet[_token][n32];\r\n            Println(oa.owner, oa.number, oa.price, oa.qty, oa.ex_qty, oa.isClosed,n32);\r\n        }\r\n    }\r\n    \r\n    function list_token_bid(address _token){\r\n        uint32[] storage numbers = token_bid[_token];\r\n        for(uint i=0;i<numbers.length;i++){\r\n            uint32 n32 = numbers[i];\r\n            OrderSheet storage oa = token_orderSheet[_token][n32];\r\n            Println(oa.owner, oa.number, oa.price, oa.qty, oa.ex_qty, oa.isClosed,n32);\r\n        }\r\n    }\r\n     \r\n    function tokens_push(address _token) private {\r\n        if(tokens[_token]!=true){\r\n            tokensArray.push(_token);\r\n            tokens[_token]=true;\r\n        }\r\n    }\r\n    \r\n    function token_member_order_pop(address _token, address _sender, uint32 _number) private {\r\n        for(uint i=0;k<token_member_order[_token][_sender].length-1;i++){\r\n            if(token_member_order[_token][_sender][i]==_number){\r\n                for(uint k=i;k<token_member_order[_token][_sender].length-2;k++){\r\n                    token_bid[_token][k]=token_bid[_token][k+1];\r\n                }\r\n                token_member_order[_token][_sender].length-=1;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n \r\n    function members_push(address _address) private {\r\n        if (members[_address].isExists != true) {\r\n            members[_address].isExists = true;\r\n            members[_address].isWithdraw = true; \r\n            members[msg.sender].deposit=0;\r\n            members[msg.sender].withdraw=0;\r\n            members[msg.sender].balances =0;\r\n            members[msg.sender].tx_amount=0;\r\n            members[msg.sender].bid_amount=0;\r\n            members[msg.sender].ask_qty=0;\r\n            members[msg.sender].tx_qty=0;\r\n            members[msg.sender].agent=address(0);\r\n            memberArray.push(_address); \r\n        }\r\n    }\r\n        \r\n    function cancel( address _token,uint32 _number){ \r\n        OrderSheet storage od = token_orderSheet[_token][_number];\r\n        if(od.owner==msg.sender){\r\n            uint i;\r\n            uint k;\r\n            if(od.isAsk){\r\n                \r\n                for(i=0; i<token_ask[_token].length;i++){\r\n                    if(token_ask[_token][i]==_number){\r\n                        od.isClosed = true;\r\n                        members[msg.sender].ask_qty - od.qty + od.ex_qty;\r\n                        for(k=i;k<token_ask[_token].length-2;k++){\r\n                            token_ask[_token][k]=token_ask[_token][k+1];\r\n                        }\r\n                        token_ask[_token].length-=1;\r\n                        break;\r\n                    }\r\n                }\r\n                \r\n            } else {\r\n            \r\n                for(i=0; i<token_bid[_token].length;i++){\r\n                    if(token_bid[_token][i]==_number){\r\n                        od.isClosed = true;\r\n                        members[msg.sender].bid_amount - od.amount + od.price*od.ex_qty;\r\n                        for(k=i;k<token_bid[_token].length-2;k++){\r\n                            token_bid[_token][k]=token_bid[_token][k+1];\r\n                        }\r\n                        token_bid[_token].length-=1;\r\n                        break;\r\n                    }\r\n                }\r\n                \r\n            }\r\n            token_member_order_pop(_token, msg.sender, _number);\r\n        } else {\r\n            Logs(\"The order owner not match\");\r\n        }\r\n    }\r\n    \r\n    function bid( address _token, uint _qty, uint _priceEth, uint _priceWei){ \r\n        tokens_push(_token); \r\n        uint256 _price = _priceEth *10**18 + _priceWei;\r\n        uint exFee = (_qty * _price) / exFeeRate;\r\n        uint amount = (_qty * _price)+exFee;\r\n        \r\n        uint unclose = members[msg.sender].bid_amount - members[msg.sender].tx_amount;\r\n        uint remaining = members[msg.sender].balances - unclose;\r\n        if(remaining >= amount){\r\n            OrderSheet memory od;\r\n            od.isAsk = false;\r\n            od.number = order_number;\r\n            od.owner = msg.sender;\r\n            od.price = _price;\r\n            od.qty = _qty;\r\n            od.ex_qty=0;\r\n            od.exFee = (_price * _qty)/exFeeRate;\r\n            od.amount = (_price * _qty) + od.exFee;\r\n            od.isClosed=false; \r\n            token_orderSheet[_token][order_number]=od; \r\n            members[msg.sender].bid_amount+=amount;\r\n            token_member_order[_token][msg.sender].push(order_number);\r\n            bid_match(_token,token_orderSheet[_token][order_number],token_ask[_token]); \r\n            if(token_orderSheet[_token][order_number].isClosed==false){\r\n                token_bid[_token].push(order_number);   \r\n                Println(od.owner, od.number, od.price, od.qty, od.ex_qty, od.isClosed,777);\r\n            }\r\n            order_number++;\r\n        } else {\r\n            Log(\"You need more money for bid\", remaining, amount);\r\n        }\r\n    }\r\n    \r\n    function ask( address _token, uint _qty, uint _priceEth, uint _priceWei){ \r\n        tokens_push(_token); \r\n        uint256 _price = _priceEth *10**18 + _priceWei;\r\n        uint unclose = members[msg.sender].ask_qty - members[msg.sender].tx_qty;\r\n        uint remaining = allow_spend(_token) - unclose;\r\n        uint exFee = (_price * _qty)/exFeeRate;\r\n        if(members[msg.sender].balances < exFee){\r\n            Log(\"You need to deposit ether to acoount befor ask\", exFee, members[msg.sender].balances);\r\n        } else if(remaining >= _qty){\r\n            members_push(msg.sender);\r\n            OrderSheet memory od;\r\n            od.isAsk = true;\r\n            od.number = order_number;\r\n            od.owner = msg.sender;\r\n            od.price = _price;\r\n            od.qty = _qty;\r\n            od.ex_qty=0;\r\n            od.exFee = exFee;\r\n            od.amount = (_price * _qty) - exFee;\r\n            od.isClosed=false; \r\n            token_orderSheet[_token][order_number]=od; \r\n            members[msg.sender].ask_qty+=_qty;\r\n            token_member_order[_token][msg.sender].push(order_number);\r\n            ask_match(_token,token_orderSheet[_token][order_number],token_bid[_token]);\r\n            if(od.isClosed==false){\r\n                token_ask[_token].push(order_number);  \r\n                Log(\"Push order number to token_ask\",order_number,0);\r\n            }\r\n            order_number++;\r\n        } else {\r\n            Log(\"You need approve your token for transfer\",0,0);\r\n        }\r\n    }\r\n     \r\n    function ask_match(address _token, OrderSheet storage od, uint32[] storage token_match) private { \r\n        for(uint i=token_match.length;i>0 && od.qty>od.ex_qty;i--){\r\n            uint32 n32 = token_match[i-1];\r\n            OrderSheet storage oa = token_orderSheet[_token][n32];\r\n            uint qty = oa.qty-oa.ex_qty;\r\n            if(oa.isClosed==false && qty>0){\r\n                uint ex_qty = (qty>od.qty?od.qty:qty);\r\n                uint ex_price = oa.price;\r\n                uint exFee = (ex_qty * ex_price) / exFeeRate;\r\n                uint amount = (ex_qty * ex_price);\r\n                Println(oa.owner, oa.number, oa.price, oa.qty, oa.ex_qty, oa.isClosed,n32);\r\n                \r\n                if(members[oa.owner].balances >= amount && od.price <= oa.price){\r\n                    od.ex_qty += ex_qty;\r\n                    if(oa.ex_qty+ex_qty>=oa.qty){\r\n                        token_orderSheet[_token][n32].isClosed = true; \r\n                        for(uint k=i-1;k<token_match.length-2;k++){\r\n                            token_match[k]=token_match[k+1];\r\n                        }\r\n                    }\r\n                    token_orderSheet[_token][n32].ex_qty += ex_qty; \r\n                    transferFromTx(_token,  msg.sender, oa.owner, ex_qty); \r\n                    \r\n                    members[oa.owner].balances -= (amount+exFee);\r\n                    members[oa.owner].tx_amount += (amount+exFee);\r\n                    members[oa.owner].tx_qty += ex_qty;\r\n\r\n                    members[msg.sender].balances += (amount-exFee);\r\n                    members[msg.sender].tx_amount += (amount-exFee);\r\n                    members[msg.sender].tx_qty += ex_qty;\r\n                    \r\n                    if(od.ex_qty+ex_qty>=od.qty){\r\n                        od.isClosed = true; \r\n                    } \r\n                    exFeeTotal += exFee;\r\n                }\r\n            }\r\n        } \r\n    }\r\n    \r\n    function bid_match(address _token, OrderSheet storage od, uint32[] storage token_match) private { \r\n        for(uint i=token_match.length;i>0 && od.qty>od.ex_qty;i--){\r\n            uint32 n32 = token_match[i-1];\r\n            OrderSheet storage oa = token_orderSheet[_token][n32];\r\n            uint qty = oa.qty-oa.ex_qty;\r\n            if(oa.isClosed==false && qty>0){\r\n                uint ex_qty = (qty>od.qty?od.qty:qty);\r\n                uint ex_price = oa.price;\r\n                uint exFee = (ex_qty * ex_price) / exFeeRate;\r\n                uint amount = (ex_qty * ex_price);\r\n                Println(oa.owner, oa.number, oa.price, oa.qty, oa.ex_qty, oa.isClosed,222); \r\n                if(members[msg.sender].balances >= amount && oa.price <= od.price){\r\n                    od.ex_qty += ex_qty;\r\n                    if(oa.ex_qty+ex_qty>=oa.qty){\r\n                        token_orderSheet[_token][n32].isClosed = true; \r\n                        for(uint k=i-1;k<token_match.length-2;k++){\r\n                            token_match[k]=token_match[k+1];\r\n                        }\r\n                    }\r\n                    token_orderSheet[_token][n32].ex_qty += ex_qty; \r\n                    //transferFromTx(_token, oa.owner, msg.sender, ex_qty); \r\n                    members[od.owner].balances += (amount-exFee);\r\n                    members[od.owner].tx_amount += (amount-exFee); \r\n                    members[od.owner].tx_qty += ex_qty; \r\n\r\n                    members[msg.sender].balances -= (amount+exFee);\r\n                    members[msg.sender].tx_amount += (amount+exFee);\r\n                    members[msg.sender].tx_qty += ex_qty;\r\n                    \r\n                    if(od.ex_qty+ex_qty>=od.qty){\r\n                        od.isClosed = true; \r\n                    }\r\n                    exFeeTotal += exFee;\r\n                } \r\n            }\r\n        } \r\n    }\r\n    \r\n  \r\n    //--------------------------------------------------------------------------member function\r\n    function withdraw(uint _eth, uint _wei) {\r\n        \r\n        for(uint i=0;i<tokensArray.length-1;i++){\r\n            address token = tokensArray[i];\r\n            uint32[] storage order = token_member_order[token][msg.sender];\r\n            for(uint j=0;j<order.length-1;j++){\r\n                cancel( token,order[j]);\r\n            }\r\n        }\r\n        \r\n        uint balances = members[msg.sender].balances;\r\n        uint withdraws = _eth*10**18 + _wei;\r\n        require( balances >= withdraws);\r\n        require( this.balance >= withdraws);\r\n        require(isWithdrawable);\r\n        require(members[msg.sender].isWithdraw);\r\n        msg.sender.transfer(withdraws);\r\n        members[msg.sender].balances -= withdraws;\r\n        members[msg.sender].withdraw += withdraws;  \r\n\r\n    }\r\n            \r\n    function get_this_balance() constant returns(uint256 _eth,uint256 _wei){\r\n      \r\n        _eth = this.balance / 10**18 ;\r\n        _wei = this.balance - _eth * 10**18 ;\r\n      \r\n    }\r\n    \r\n    \r\n    function pay() public payable returns (bool) {\r\n        \r\n        require(msg.value > MinimalPayValue);\r\n        require(isPayable);\r\n        \r\n        \r\n        if(admins[msg.sender] == AdminType.widthdraw){\r\n\r\n        }else{\r\n            \r\n            if(isRequireData){\r\n                require(admins[address(msg.data[0])] > AdminType.none);   \r\n            }\r\n        \r\n            members_push(msg.sender);\r\n            members[msg.sender].balances += msg.value;\r\n            members[msg.sender].deposit += msg.value;\r\n            if(admins[address(msg.data[0])]>AdminType.none){\r\n                members[msg.sender].agent = address(msg.data[0]);\r\n            }\r\n\r\n    \t\tPaydata(msg.sender, msg.value, msg.data, members[msg.sender].balances);\r\n\t\t\r\n        }\r\n        \r\n        return true;\r\n    \r\n    }\r\n\r\n   \r\n  \r\n\r\n    //--------------------------------------------------------------------------admin function\r\n    \r\n    modifier onlyAdmin() {\r\n        require(admins[msg.sender] > AdminType.agent);\r\n        _;\r\n    }\r\n\r\n    function admin_list() onlyAdmin constant returns(address[] _adminArray){\r\n        \r\n        _adminArray = adminArray; \r\n        \r\n    }    \r\n    \r\n    function admin_typeOf(address admin) onlyAdmin constant returns(AdminType adminType){\r\n          \r\n        adminType= admins[admin];\r\n        \r\n    }\r\n    \r\n    function admin_add_modify(address admin, AdminType adminType) onlyAdmin {\r\n        \r\n        require(admins[admin] > AdminType.agent);\r\n        if(admins[admin] < AdminType.normal){\r\n            adminArray.push(admin);\r\n        }\r\n        admins[admin]=AdminType(adminType);\r\n        \r\n    }\r\n    \r\n    function admin_del(address admin) onlyAdmin {\r\n        \r\n        require(admin!=msg.sender);\r\n        require(admins[admin] > AdminType.agent);\r\n        if(admins[admin] > AdminType.none){\r\n            admins[admin] = AdminType.none;\r\n            for (uint i = 0; i < adminArray.length - 1; i++) {\r\n                if (adminArray[i] == admin) {\r\n                    adminArray[i] = adminArray[adminArray.length - 1];\r\n                    adminArray.length -= 1;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        \r\n    }\r\n\r\n    function admin_withdraw(uint _eth, uint _wei) onlyAdmin {\r\n\r\n        require(admins[msg.sender] > AdminType.admin);\r\n        uint256 amount = _eth * 10**18 + _wei;\r\n\t\trequire(this.balance >= amount);\r\n\t\tmsg.sender.transfer(amount); \r\n        \r\n    }\r\n        \r\n\r\n\tfunction admin_exFeeRate(uint _rate) onlyAdmin {\r\n\t    \r\n\t    exFeeRate = _rate;\r\n\t    \r\n\t}\r\n     \t\r\n    function admin_MinimalPayValue(uint _eth, uint _wei) onlyAdmin {\r\n\t    \r\n\t    MinimalPayValue = _eth*10*18 + _wei;\r\n\t    \r\n\t}\r\n     \r\n    function admin_isRequireData(bool _requireData) onlyAdmin{\r\n    \r\n        isRequireData = _requireData;\r\n        \r\n    }\r\n    \r\n    function admin_isPayable(bool _payable) onlyAdmin{\r\n    \r\n        isPayable = _payable;\r\n        \r\n    }\r\n    \r\n    function admin_isWithdrawable(bool _withdrawable) onlyAdmin{\r\n        \r\n        isWithdrawable = _withdrawable;\r\n        \r\n    }\r\n    \r\n    function admin_member_isWithdraw(address _member, bool _withdrawable) onlyAdmin {\r\n        if(members[_member].isExists == true) {\r\n            members[_member].isWithdraw = _withdrawable;\r\n        } else {\r\n            Logs(\"member not existes\");\r\n        }\r\n    }\r\n    \r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_qty\",\"type\":\"uint256\"},{\"name\":\"_priceEth\",\"type\":\"uint256\"},{\"name\":\"_priceWei\",\"type\":\"uint256\"}],\"name\":\"ask\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"members\",\"outputs\":[{\"name\":\"isExists\",\"type\":\"bool\"},{\"name\":\"isWithdraw\",\"type\":\"bool\"},{\"name\":\"deposit\",\"type\":\"uint256\"},{\"name\":\"withdraw\",\"type\":\"uint256\"},{\"name\":\"balances\",\"type\":\"uint256\"},{\"name\":\"bid_amount\",\"type\":\"uint256\"},{\"name\":\"tx_amount\",\"type\":\"uint256\"},{\"name\":\"ask_qty\",\"type\":\"uint256\"},{\"name\":\"tx_qty\",\"type\":\"uint256\"},{\"name\":\"agent\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"admin\",\"type\":\"address\"},{\"name\":\"adminType\",\"type\":\"uint8\"}],\"name\":\"admin_add_modify\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"admin_exFeeRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pay\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_eth\",\"type\":\"uint256\"},{\"name\":\"_wei\",\"type\":\"uint256\"}],\"name\":\"admin_withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_payable\",\"type\":\"bool\"}],\"name\":\"admin_isPayable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_eth\",\"type\":\"uint256\"},{\"name\":\"_wei\",\"type\":\"uint256\"}],\"name\":\"admin_MinimalPayValue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_requireData\",\"type\":\"bool\"}],\"name\":\"admin_isRequireData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isRequireData\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_eth\",\"type\":\"uint256\"},{\"name\":\"_wei\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isWithdrawable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"list_token_ask\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin_list\",\"outputs\":[{\"name\":\"_adminArray\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_withdrawable\",\"type\":\"bool\"}],\"name\":\"admin_isWithdrawable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"list_token_bid\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"order_number\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"token_member_order\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_qty\",\"type\":\"uint256\"},{\"name\":\"_priceEth\",\"type\":\"uint256\"},{\"name\":\"_priceWei\",\"type\":\"uint256\"}],\"name\":\"bid\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"token_ask\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"token_bid\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"get_this_balance\",\"outputs\":[{\"name\":\"_eth\",\"type\":\"uint256\"},{\"name\":\"_wei\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exFeeTotal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exFeeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_number\",\"type\":\"uint32\"}],\"name\":\"cancel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"admin_typeOf\",\"outputs\":[{\"name\":\"adminType\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"admin_del\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MinimalPayValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"memberArray\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPayable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"token_orderSheet\",\"outputs\":[{\"name\":\"isAsk\",\"type\":\"bool\"},{\"name\":\"number\",\"type\":\"uint32\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"qty\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"exFee\",\"type\":\"uint256\"},{\"name\":\"ex_qty\",\"type\":\"uint256\"},{\"name\":\"isClosed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokensArray\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_member\",\"type\":\"address\"},{\"name\":\"_withdrawable\",\"type\":\"bool\"}],\"name\":\"admin_member_isWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"\",\"type\":\"string\"}],\"name\":\"Logs\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"data\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value1\",\"type\":\"uint256\"}],\"name\":\"Log\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"number\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"qty\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ex_qty\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"isClosed\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"n32\",\"type\":\"uint32\"}],\"name\":\"Println\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"payer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"balances\",\"type\":\"uint256\"}],\"name\":\"Paydata\",\"type\":\"event\"}]","ContractName":"BidAskX","CompilerVersion":"v0.4.16+commit.d7661dd9","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://edff4d73503ab6a8cdca66f474158c791a8c092aba749c9cbf09f10dd630998c"}]}