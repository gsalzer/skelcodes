{"status":"1","message":"OK","result":[{"SourceCode":"library SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract IToken {\r\n  function totalSupply() constant returns (uint256 totalSupply);\r\n  function mintTokens(address _to, uint256 _amount) {}\r\n}\r\ncontract IMintableToken {\r\n  function mintTokens(address _to, uint256 _amount){}\r\n}\r\ncontract IERC20Token {\r\n  function totalSupply() constant returns (uint256 totalSupply);\r\n  function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n  function transfer(address _to, uint256 _value) returns (bool success) {}\r\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n  function approve(address _spender, uint256 _value) returns (bool success) {}\r\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract ItokenRecipient {\r\n  function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData);\r\n}\r\n\r\ncontract Owned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    function Owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != owner);\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = 0x0;\r\n    }\r\n\r\n    event OwnerUpdate(address _prevOwner, address _newOwner);\r\n}\r\ncontract ReentrnacyHandlingContract{\r\n\r\n    bool locked;\r\n\r\n    modifier noReentrancy() {\r\n        require(!locked);\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n}\r\n\r\ncontract Lockable is Owned{\r\n\r\n  uint256 public lockedUntilBlock;\r\n\r\n  event ContractLocked(uint256 _untilBlock, string _reason);\r\n\r\n  modifier lockAffected {\r\n      require(block.number > lockedUntilBlock);\r\n      _;\r\n  }\r\n\r\n  function lockFromSelf(uint256 _untilBlock, string _reason) internal {\r\n    lockedUntilBlock = _untilBlock;\r\n    ContractLocked(_untilBlock, _reason);\r\n  }\r\n\r\n\r\n  function lockUntil(uint256 _untilBlock, string _reason) onlyOwner {\r\n    lockedUntilBlock = _untilBlock;\r\n    ContractLocked(_untilBlock, _reason);\r\n  }\r\n}\r\n\r\ncontract Crowdsale is ReentrnacyHandlingContract, Owned{\r\n\r\n  struct ContributorData{\r\n    uint priorityPassAllowance;\r\n    bool isActive;\r\n    uint contributionAmount;\r\n    uint tokensIssued;\r\n  }\r\n\r\n  mapping(address => ContributorData) public contributorList;\r\n  uint nextContributorIndex;\r\n  mapping(uint => address) contributorIndexes;\r\n\r\n  state public crowdsaleState = state.pendingStart;\r\n  enum state { pendingStart, priorityPass, openedPriorityPass, crowdsale, crowdsaleEnded }\r\n\r\n  uint public presaleStartBlock;\r\n  uint public presaleUnlimitedStartBlock;\r\n  uint public crowdsaleStartBlock;\r\n  uint public crowdsaleEndedBlock;\r\n\r\n  event PresaleStarted(uint blockNumber);\r\n  event PresaleUnlimitedStarted(uint blockNumber);\r\n  event CrowdsaleStarted(uint blockNumber);\r\n  event CrowdsaleEnded(uint blockNumber);\r\n  event ErrorSendingETH(address to, uint amount);\r\n  event MinCapReached(uint blockNumber);\r\n  event MaxCapReached(uint blockNumber);\r\n\r\n  IToken token = IToken(0x0);\r\n  uint ethToTokenConversion;\r\n\r\n  uint public minCap;\r\n  uint public maxP1Cap;\r\n  uint public maxCap;\r\n  uint public ethRaised;\r\n\r\n  address public multisigAddress;\r\n\r\n  uint nextContributorToClaim;\r\n  mapping(address => bool) hasClaimedEthWhenFail;\r\n\r\n  uint maxTokenSupply;\r\n  bool ownerHasClaimedTokens;\r\n  uint cofounditReward;\r\n  address cofounditAddress;\r\n  bool cofounditHasClaimedTokens;\r\n\r\n  //\r\n  // Unnamed function that runs when eth is sent to the contract\r\n  //\r\n  function() noReentrancy payable{\r\n    require(msg.value != 0);                        // Throw if value is 0\r\n    require(crowdsaleState != state.crowdsaleEnded);// Check if crowdsale has ended\r\n\r\n    bool stateChanged = checkCrowdsaleState();      // Check blocks and calibrate crowdsale state\r\n\r\n    if (crowdsaleState == state.priorityPass){\r\n      if (contributorList[msg.sender].isActive){    // Check if contributor is in priorityPass\r\n        processTransaction(msg.sender, msg.value);  // Process transaction and issue tokens\r\n      }else{\r\n        refundTransaction(stateChanged);            // Set state and return funds or throw\r\n      }\r\n    }\r\n    else if(crowdsaleState == state.openedPriorityPass){\r\n      if (contributorList[msg.sender].isActive){    // Check if contributor is in priorityPass\r\n        processTransaction(msg.sender, msg.value);  // Process transaction and issue tokens\r\n      }else{\r\n        refundTransaction(stateChanged);            // Set state and return funds or throw\r\n      }\r\n    }\r\n    else if(crowdsaleState == state.crowdsale){\r\n      processTransaction(msg.sender, msg.value);    // Process transaction and issue tokens\r\n    }\r\n    else{\r\n      refundTransaction(stateChanged);              // Set state and return funds or throw\r\n    }\r\n  }\r\n\r\n  //\r\n  // Check crowdsale state and calibrate it\r\n  //\r\n  function checkCrowdsaleState() internal returns (bool){\r\n    if (ethRaised == maxCap && crowdsaleState != state.crowdsaleEnded){                         // Check if max cap is reached\r\n      crowdsaleState = state.crowdsaleEnded;\r\n      MaxCapReached(block.number);                                                              // Close the crowdsale\r\n      CrowdsaleEnded(block.number);                                                             // Raise event\r\n      return true;\r\n    }\r\n\r\n    if (block.number > presaleStartBlock && block.number <= presaleUnlimitedStartBlock){  // Check if we are in presale phase\r\n      if (crowdsaleState != state.priorityPass){                                          // Check if state needs to be changed\r\n        crowdsaleState = state.priorityPass;                                              // Set new state\r\n        PresaleStarted(block.number);                                                     // Raise event\r\n        return true;\r\n      }\r\n    }else if(block.number > presaleUnlimitedStartBlock && block.number <= crowdsaleStartBlock){ // Check if we are in presale unlimited phase\r\n      if (crowdsaleState != state.openedPriorityPass){                                          // Check if state needs to be changed\r\n        crowdsaleState = state.openedPriorityPass;                                              // Set new state\r\n        PresaleUnlimitedStarted(block.number);                                                  // Raise event\r\n        return true;\r\n      }\r\n    }else if(block.number > crowdsaleStartBlock && block.number <= crowdsaleEndedBlock){        // Check if we are in crowdsale state\r\n      if (crowdsaleState != state.crowdsale){                                                   // Check if state needs to be changed\r\n        crowdsaleState = state.crowdsale;                                                       // Set new state\r\n        CrowdsaleStarted(block.number);                                                         // Raise event\r\n        return true;\r\n      }\r\n    }else{\r\n      if (crowdsaleState != state.crowdsaleEnded && block.number > crowdsaleEndedBlock){        // Check if crowdsale is over\r\n        crowdsaleState = state.crowdsaleEnded;                                                  // Set new state\r\n        CrowdsaleEnded(block.number);                                                           // Raise event\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  //\r\n  // Decide if throw or only return ether\r\n  //\r\n  function refundTransaction(bool _stateChanged) internal{\r\n    if (_stateChanged){\r\n      msg.sender.transfer(msg.value);\r\n    }else{\r\n      revert();\r\n    }\r\n  }\r\n\r\n  //\r\n  // Calculate how much user can contribute\r\n  //\r\n  function calculateMaxContribution(address _contributor) constant returns (uint maxContribution){\r\n    uint maxContrib;\r\n    if (crowdsaleState == state.priorityPass){    // Check if we are in priority pass\r\n      maxContrib = contributorList[_contributor].priorityPassAllowance - contributorList[_contributor].contributionAmount;\r\n      if (maxContrib > (maxP1Cap - ethRaised)){   // Check if max contribution is more that max cap\r\n        maxContrib = maxP1Cap - ethRaised;        // Alter max cap\r\n      }\r\n    }\r\n    else{\r\n      maxContrib = maxCap - ethRaised;            // Alter max cap\r\n    }\r\n    return maxContrib;\r\n  }\r\n\r\n  //\r\n  // Issue tokens and return if there is overflow\r\n  //\r\n  function processTransaction(address _contributor, uint _amount) internal{\r\n    uint maxContribution = calculateMaxContribution(_contributor);              // Calculate max users contribution\r\n    uint contributionAmount = _amount;\r\n    uint returnAmount = 0;\r\n    if (maxContribution < _amount){                                             // Check if max contribution is lower than _amount sent\r\n      contributionAmount = maxContribution;                                     // Set that user contibutes his maximum alowed contribution\r\n      returnAmount = _amount - maxContribution;                                 // Calculate howmuch he must get back\r\n    }\r\n\r\n    if (ethRaised + contributionAmount > minCap && minCap > ethRaised) MinCapReached(block.number);\r\n\r\n    if (contributorList[_contributor].isActive == false){                       // Check if contributor has already contributed\r\n      contributorList[_contributor].isActive = true;                            // Set his activity to true\r\n      contributorList[_contributor].contributionAmount = contributionAmount;    // Set his contribution\r\n      contributorIndexes[nextContributorIndex] = _contributor;                  // Set contributors index\r\n      nextContributorIndex++;\r\n    }\r\n    else{\r\n      contributorList[_contributor].contributionAmount += contributionAmount;   // Add contribution amount to existing contributor\r\n    }\r\n    ethRaised += contributionAmount;                                            // Add to eth raised\r\n\r\n    uint tokenAmount = contributionAmount * ethToTokenConversion;               // Calculate how much tokens must contributor get\r\n    if (tokenAmount > 0){\r\n      token.mintTokens(_contributor, tokenAmount);                                // Issue new tokens\r\n      contributorList[_contributor].tokensIssued += tokenAmount;                  // log token issuance\r\n    }\r\n    if (returnAmount != 0) _contributor.transfer(returnAmount);                 // Return overflow of ether\r\n  }\r\n\r\n  //\r\n  // Push contributor data to the contract before the crowdsale so that they are eligible for priorit pass\r\n  //\r\n  function editContributors(address[] _contributorAddresses, uint[] _contributorPPAllowances) onlyOwner{\r\n    require(_contributorAddresses.length == _contributorPPAllowances.length); // Check if input data is correct\r\n\r\n    for(uint cnt = 0; cnt < _contributorAddresses.length; cnt++){\r\n      if (contributorList[_contributorAddresses[cnt]].isActive){\r\n        contributorList[_contributorAddresses[cnt]].priorityPassAllowance = _contributorPPAllowances[cnt];\r\n      }\r\n      else{\r\n        contributorList[_contributorAddresses[cnt]].isActive = true;\r\n        contributorList[_contributorAddresses[cnt]].priorityPassAllowance = _contributorPPAllowances[cnt];\r\n        contributorIndexes[nextContributorIndex] = _contributorAddresses[cnt];\r\n        nextContributorIndex++;\r\n      }\r\n    }\r\n  }\r\n\r\n  //\r\n  // Method is needed for recovering tokens accedentaly sent to token address\r\n  //\r\n  function salvageTokensFromContract(address _tokenAddress, address _to, uint _amount) onlyOwner{\r\n    IERC20Token(_tokenAddress).transfer(_to, _amount);\r\n  }\r\n\r\n  //\r\n  // withdrawEth when minimum cap is reached\r\n  //\r\n  function withdrawEth() onlyOwner{\r\n    require(this.balance != 0);\r\n    require(ethRaised >= minCap);\r\n\r\n    pendingEthWithdrawal = this.balance;\r\n  }\r\n  uint pendingEthWithdrawal;\r\n  function sanityCheck(){\r\n    require(msg.sender == multisigAddress);\r\n    require(pendingEthWithdrawal > 0);\r\n\r\n    multisigAddress.transfer(pendingEthWithdrawal);\r\n    pendingEthWithdrawal = 0;\r\n  }\r\n\r\n  //\r\n  // Users can claim their contribution if min cap is not raised\r\n  //\r\n  function claimEthIfFailed(){\r\n    require(block.number > crowdsaleEndedBlock && ethRaised < minCap);    // Check if crowdsale has failed\r\n    require(contributorList[msg.sender].contributionAmount > 0);          // Check if contributor has contributed to crowdsaleEndedBlock\r\n    require(!hasClaimedEthWhenFail[msg.sender]);                          // Check if contributor has already claimed his eth\r\n\r\n    uint ethContributed = contributorList[msg.sender].contributionAmount; // Get contributors contribution\r\n    hasClaimedEthWhenFail[msg.sender] = true;                             // Set that he has claimed\r\n    if (!msg.sender.send(ethContributed)){                                // Refund eth\r\n      ErrorSendingETH(msg.sender, ethContributed);                        // If there is an issue raise event for manual recovery\r\n    }\r\n  }\r\n\r\n  //\r\n  // Owner can batch return contributors contributions(eth)\r\n  //\r\n  function batchReturnEthIfFailed(uint _numberOfReturns) onlyOwner{\r\n    require(block.number > crowdsaleEndedBlock && ethRaised < minCap);                // Check if crowdsale has failed\r\n    address currentParticipantAddress;\r\n    uint contribution;\r\n    for (uint cnt = 0; cnt < _numberOfReturns; cnt++){\r\n      currentParticipantAddress = contributorIndexes[nextContributorToClaim];         // Get next unclaimed participant\r\n      if (currentParticipantAddress == 0x0) return;                                   // Check if all the participants were compensated\r\n      if (!hasClaimedEthWhenFail[currentParticipantAddress]) {                        // Check if participant has already claimed\r\n        contribution = contributorList[currentParticipantAddress].contributionAmount; // Get contribution of participant\r\n        hasClaimedEthWhenFail[currentParticipantAddress] = true;                      // Set that he has claimed\r\n        if (!currentParticipantAddress.send(contribution)){                           // Refund eth\r\n          ErrorSendingETH(currentParticipantAddress, contribution);                   // If there is an issue raise event for manual recovery\r\n        }\r\n      }\r\n      nextContributorToClaim += 1;                                                    // Repeat\r\n    }\r\n  }\r\n\r\n  //\r\n  // If there were any issue/attach with refund owner can withraw eth at the end for manual recovery\r\n  //\r\n  function withdrawRemainingBalanceForManualRecovery() onlyOwner{\r\n    require(this.balance != 0);                                  // Check if there are any eth to claim\r\n    require(block.number > crowdsaleEndedBlock);                 // Check if crowdsale is over\r\n    require(contributorIndexes[nextContributorToClaim] == 0x0);  // Check if all the users were refunded\r\n    multisigAddress.transfer(this.balance);                      // Withdraw to multisig\r\n  }\r\n\r\n  //\r\n  // Owner can set multisig address for crowdsale\r\n  //\r\n  function setMultisigAddress(address _newAddress) onlyOwner{\r\n    multisigAddress = _newAddress;\r\n  }\r\n\r\n  //\r\n  // Owner can set token address where mints will happen\r\n  //\r\n  function setToken(address _newAddress) onlyOwner{\r\n    token = IToken(_newAddress);\r\n  }\r\n\r\n  //\r\n  // Owner can claim teams tokens when crowdsale has successfully ended\r\n  //\r\n  function claimCoreTeamsTokens(address _to) onlyOwner{\r\n    require(crowdsaleState == state.crowdsaleEnded);              // Check if crowdsale has ended\r\n    require(!ownerHasClaimedTokens);                              // Check if owner has allready claimed tokens\r\n\r\n    uint devReward = maxTokenSupply - token.totalSupply();\r\n    if (!cofounditHasClaimedTokens) devReward -= cofounditReward; // If cofoundit has claimed tokens its ok if not set aside cofounditReward\r\n    token.mintTokens(_to, devReward);                             // Issue Teams tokens\r\n    ownerHasClaimedTokens = true;                                 // Block further mints from this method\r\n  }\r\n\r\n  //\r\n  // Cofoundit can claim their tokens\r\n  //\r\n  function claimCofounditTokens(address _to){\r\n    require(msg.sender == cofounditAddress);            // Check if sender is cofoundit\r\n    require(crowdsaleState == state.crowdsaleEnded);    // Check if crowdsale has ended\r\n    require(!cofounditHasClaimedTokens);                // Check if cofoundit has allready claimed tokens\r\n\r\n    token.mintTokens(_to, cofounditReward);             // Issue cofoundit tokens\r\n    cofounditHasClaimedTokens = true;                   // Block further mints from this method\r\n  }\r\n\r\n  function getTokenAddress() constant returns(address){\r\n    return address(token);\r\n  }\r\n}\r\n\r\n\r\n\r\ncontract MaecenasCrowdsale is Crowdsale {\r\n  function MaecenasCrowdsale(){\r\n    presaleStartBlock = 4241483;\r\n    presaleUnlimitedStartBlock = 4245055;\r\n    crowdsaleStartBlock = 4248627;\r\n    crowdsaleEndedBlock = 4348635;\r\n\r\n    minCap = 9375 * 10**18;\r\n    maxP1Cap = 31250 * 10**18;\r\n    maxCap = 62500 * 10**18;\r\n\r\n    ethToTokenConversion = 480;\r\n\r\n    maxTokenSupply = 100000000 * 10**18;\r\n    cofounditReward = 4000000 * 10**18;\r\n    cofounditAddress = 0x988c3eA5554f3D2fB5ECB4dC5c35126eEf3B8a5D;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"setMultisigAddress\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contributorAddresses\",\"type\":\"address[]\"},{\"name\":\"_contributorPPAllowances\",\"type\":\"uint256[]\"}],\"name\":\"editContributors\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleEndedBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawRemainingBalanceForManualRecovery\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxP1Cap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presaleStartBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multisigAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contributor\",\"type\":\"address\"}],\"name\":\"calculateMaxContribution\",\"outputs\":[{\"name\":\"maxContribution\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"claimCofounditTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sanityCheck\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimEthIfFailed\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_numberOfReturns\",\"type\":\"uint256\"}],\"name\":\"batchReturnEthIfFailed\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presaleUnlimitedStartBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"claimCoreTeamsTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"contributorList\",\"outputs\":[{\"name\":\"priorityPassAllowance\",\"type\":\"uint256\"},{\"name\":\"isActive\",\"type\":\"bool\"},{\"name\":\"contributionAmount\",\"type\":\"uint256\"},{\"name\":\"tokensIssued\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"salvageTokensFromContract\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEth\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleStartBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"PresaleStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"PresaleUnlimitedStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"CrowdsaleStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"CrowdsaleEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ErrorSendingETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"MinCapReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"MaxCapReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_prevOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdate\",\"type\":\"event\"}]","ContractName":"MaecenasCrowdsale","CompilerVersion":"v0.4.13+commit.fb4cb1a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://9a21872f41e268e243ce64b90dd32930139fd04f8cdcf33055f5390b70e72673"}]}