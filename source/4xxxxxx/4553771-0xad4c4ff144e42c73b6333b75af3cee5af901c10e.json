{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n *\r\n * @author  <newtwist@protonmail.com>\r\n *\r\n * Version F\r\n *\r\n * Overview:\r\n * This contract implements a blind auction for burnable tokens. Each secret bid consists\r\n * of a hashed bid-tuple, (`price`, `quantity`, `salt`), where price is the maximum amount\r\n * of ether (in szabo) a user is willing to pay per token, quantity is the number of tokens\r\n * the user wants to buy, and salt is an arbitrary value. Together with the hashed bid-tuple,\r\n * the user includes an encrypted bid tuple, using the public key of the party running the\r\n * auction, and of course a deposit sufficient to pay for the bid.\r\n *\r\n * At the end of the bidding period, the party running the auction sets a 'strike price',\r\n * thereby signaling the start of the sale period. During this period all bidders must\r\n * execute their bids. To execute a bid a user reveals their bid-tuple. All bids with a\r\n * price at least as high as the strike price are filled, and all bids under the strike\r\n * price are returned. Bids that are exactly equal to the strike price are partially filled,\r\n * so that the maximum number of tokens generated does not exceed the total supply.\r\n *\r\n * Strike Price:\r\n * The strike price is calculated offchain by the party running the auction. When each\r\n * secret bid is submitted an event is generated, which includes the sender address, hashed\r\n * bid-tuple, encrypted bid-tuple and deposit amount. the party running the auction decrypts\r\n * the encrypted bid-tuple, and regenerates the hash. If the regenerated hash does not match\r\n * the hash that was submitted with the secret bid, or if the desposited funds are not\r\n * sufficient to cover the bid, then the bid is disqualified. (presumably disqualifying\r\n * invalid bids will be cheaper than validating all the valid bids).\r\n *\r\n * The auction is structured with a fixed maximum number of tokens. So to raise the maximum\r\n * funds the bids are sorted, highest to lowest. Starting the strike-price at the highest\r\n * bid, it is reduced, bid by bid, to include more bids. The quantity of tokens sold increases\r\n * each time a new bid is included; but the token price is reduced. At each step the total\r\n * raise (token-price times quantity-of-tokens-sold) is computed. And the process ends\r\n * whenever the total raise decreases, or when the total number of tokens exceeds the total\r\n * supply.\r\n *\r\n * Notes:\r\n * The `salt` is included in the bid-tuple to discourage brute-force attacks on the inputs\r\n * to the secret bid.\r\n *\r\n * A user cannot submit multiple bids from the same Ether account.\r\n *\r\n * Users are required to execute their bids. If a user fails to execute their bid before the\r\n * end of the sale period, then they forfeit half of their deposit, and receive no tokens.\r\n * This rule was adopted (as opposed to refunding un-revealed bids) to prevent users from placing\r\n * several bids, and only revealing one of them. With this rule, all bids must be executed.\r\n *\r\n */\r\n\r\n\r\npragma solidity ^0.4.15;\r\n\r\n//Burnable Token interface\r\n\r\npragma solidity ^0.4.15;\r\n\r\n// Token standard API\r\n// https://github.com/ethereum/EIPs/issues/20\r\n\r\ncontract iERC20Token {\r\n  function totalSupply() public constant returns (uint supply);\r\n  function balanceOf( address who ) public constant returns (uint value);\r\n  function allowance( address owner, address spender ) public constant returns (uint remaining);\r\n\r\n  function transfer( address to, uint value) public returns (bool ok);\r\n  function transferFrom( address from, address to, uint value) public returns (bool ok);\r\n  function approve( address spender, uint value ) public returns (bool ok);\r\n\r\n  event Transfer( address indexed from, address indexed to, uint value);\r\n  event Approval( address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract iBurnableToken is iERC20Token {\r\n  function burnTokens(uint _burnCount) public;\r\n  function unPaidBurnTokens(uint _burnCount) public;\r\n}\r\n\r\n//import './SafeMath.sol';\r\npragma solidity ^0.4.11;\r\n\r\n/*\r\n    Overflow protected math functions\r\n*/\r\ncontract SafeMath {\r\n    /**\r\n        constructor\r\n    */\r\n    function SafeMath() public {\r\n    }\r\n\r\n    /**\r\n        @dev returns the sum of _x and _y, asserts if the calculation overflows\r\n\r\n        @param _x   value 1\r\n        @param _y   value 2\r\n\r\n        @return sum\r\n    */\r\n    function safeAdd(uint256 _x, uint256 _y) pure internal returns (uint256) {\r\n        uint256 z = _x + _y;\r\n        assert(z >= _x);\r\n        return z;\r\n    }\r\n\r\n    /**\r\n        @dev returns the difference of _x minus _y, asserts if the subtraction results in a negative number\r\n\r\n        @param _x   minuend\r\n        @param _y   subtrahend\r\n\r\n        @return difference\r\n    */\r\n    function safeSub(uint256 _x, uint256 _y) pure internal returns (uint256) {\r\n        assert(_x >= _y);\r\n        return _x - _y;\r\n    }\r\n\r\n    /**\r\n        @dev returns the product of multiplying _x by _y, asserts if the calculation overflows\r\n\r\n        @param _x   factor 1\r\n        @param _y   factor 2\r\n\r\n        @return product\r\n    */\r\n    function safeMul(uint256 _x, uint256 _y) pure internal returns (uint256) {\r\n        uint256 z = _x * _y;\r\n        assert(_x == 0 || z / _x == _y);\r\n        return z;\r\n    }\r\n}\r\n\r\n\r\ncontract TokenAuction is SafeMath {\r\n\r\n  struct SecretBid {\r\n    bool disqualified;     // flag set if hash does not match encrypted bid\r\n    uint deposit;          // funds deposited by bidder\r\n    uint refund;           // funds to be returned to bidder\r\n    uint tokens;           // structure has been allocated\r\n    bytes32 hash;          // hash of price, quantity, secret\r\n  }\r\n  uint constant  AUCTION_START_EVENT = 0x01;\r\n  uint constant  AUCTION_END_EVENT   = 0x02;\r\n  uint constant  SALE_START_EVENT    = 0x04;\r\n  uint constant  SALE_END_EVENT      = 0x08;\r\n\r\n  event SecretBidEvent(uint indexed batch, address indexed bidder, uint deposit, bytes32 hash, bytes message);\r\n  event ExecuteEvent(uint indexed batch, address indexed bidder, uint cost, uint refund);\r\n  event ExpireEvent(uint indexed batch, address indexed bidder, uint cost, uint refund);\r\n  event BizarreEvent(address indexed addr, string message, uint val);\r\n  event StateChangeEvent(uint mask);\r\n  //\r\n  //event MessageEvent(string message);\r\n  //event MessageUintEvent(string message, uint val);\r\n  //event MessageAddrEvent(string message, address val);\r\n  //event MessageBytes32Event(string message, bytes32 val);\r\n\r\n  bool public isLocked;\r\n  uint public stateMask;\r\n  address public owner;\r\n  address public developers;\r\n  address public underwriter;\r\n  iBurnableToken public token;\r\n  uint public proceeds;\r\n  uint public strikePrice;\r\n  uint public strikePricePctX10;\r\n  uint public decimalMultiplier;\r\n  uint public developerReserve;\r\n  uint public developerPctX10K;\r\n  uint public purchasedCount;\r\n  uint public secretBidCount;\r\n  uint public executedCount;\r\n  uint public expiredCount;\r\n  uint public saleDuration;\r\n  uint public auctionStart;\r\n  uint public auctionEnd;\r\n  uint public saleEnd;\r\n  mapping (address => SecretBid) public secretBids;\r\n\r\n  //\r\n  //tunables\r\n  uint batchSize = 4;\r\n  uint contractSendGas = 100000;\r\n\r\n  modifier ownerOnly {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  modifier unlockedOnly {\r\n    require(!isLocked);\r\n    _;\r\n  }\r\n\r\n  modifier duringAuction {\r\n    require((stateMask & (AUCTION_START_EVENT | AUCTION_END_EVENT)) == AUCTION_START_EVENT);\r\n    _;\r\n  }\r\n\r\n  modifier afterAuction {\r\n    require((stateMask & AUCTION_END_EVENT) != 0);\r\n    _;\r\n  }\r\n\r\n  modifier duringSale {\r\n    require((stateMask & (SALE_START_EVENT | SALE_END_EVENT)) == SALE_START_EVENT);\r\n    _;\r\n  }\r\n\r\n  modifier afterSale {\r\n    require((stateMask & SALE_END_EVENT) != 0);\r\n    _;\r\n  }\r\n\r\n\r\n  //\r\n  //constructor\r\n  //\r\n  function TokenAuction() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  function lock() public ownerOnly {\r\n    isLocked = true;\r\n  }\r\n\r\n  function setToken(iBurnableToken _token, uint _decimalMultiplier, address _underwriter) public ownerOnly unlockedOnly {\r\n    token = _token;\r\n    decimalMultiplier = _decimalMultiplier;\r\n    underwriter = _underwriter;\r\n  }\r\n\r\n  function setAuctionParms(uint _auctionStart, uint _auctionDuration, uint _saleDuration) public ownerOnly unlockedOnly {\r\n    auctionStart = _auctionStart;\r\n    auctionEnd = safeAdd(_auctionStart, _auctionDuration);\r\n    saleDuration = _saleDuration;\r\n    if (stateMask != 0) {\r\n      //handy for debug\r\n      stateMask = 0;\r\n      strikePrice = 0;\r\n      executedCount = 0;\r\n      houseKeep();\r\n    }\r\n  }\r\n\r\n\r\n  function reserveDeveloperTokens(address _developers, uint _developerPctX10K) public ownerOnly unlockedOnly {\r\n    developers = _developers;\r\n    developerPctX10K = _developerPctX10K;\r\n    uint _tokenCount = token.balanceOf(this);\r\n    developerReserve = safeMul(_tokenCount, developerPctX10K) / 1000000;\r\n  }\r\n\r\n  function tune(uint _batchSize, uint _contractSendGas) public ownerOnly {\r\n    batchSize = _batchSize;\r\n    contractSendGas = _contractSendGas;\r\n  }\r\n\r\n\r\n  //\r\n  //called by owner (or any other concerned party) to generate a SatateChangeEvent\r\n  //\r\n  function houseKeep() public {\r\n    uint _oldMask = stateMask;\r\n    if (now >= auctionStart) {\r\n      stateMask |= AUCTION_START_EVENT;\r\n      if (now >= auctionEnd) {\r\n        stateMask |= AUCTION_END_EVENT;\r\n        if (strikePrice > 0) {\r\n          stateMask |= SALE_START_EVENT;\r\n          if (now >= saleEnd)\r\n            stateMask |= SALE_END_EVENT;\r\n        }\r\n      }\r\n    }\r\n    if (stateMask != _oldMask)\r\n      StateChangeEvent(stateMask);\r\n  }\r\n\r\n\r\n\r\n  //\r\n  // setting the strike price starts the sale period, during which bidders must call executeBid.\r\n  // the strike price should only be set once.... at any rate it cannot be changed once anyone has executed a bid.\r\n  // strikePricePctX10 specifies what percentage (x10) of requested tokens should be awarded to each bidder that\r\n  // bid exactly equal to the strike price.\r\n  //\r\n  // note: strikePrice is the price of whole tokens (in wei)\r\n  //\r\n  function setStrikePrice(uint _strikePrice, uint _strikePricePctX10) public ownerOnly afterAuction {\r\n    require(executedCount == 0);\r\n    strikePrice = _strikePrice;\r\n    strikePricePctX10 = _strikePricePctX10;\r\n    saleEnd = safeAdd(now, saleDuration);\r\n    houseKeep();\r\n  }\r\n\r\n\r\n  //\r\n  // nobody should be sending funds via this function.... bizarre...\r\n  // the fact that we adjust proceeds here means that this fcn will OOG if called with a send or transfer. that's\r\n  // probably good, cuz it prevents the caller from losing their funds.\r\n  //\r\n  function () public payable {\r\n    proceeds = safeAdd(proceeds, msg.value);\r\n    BizarreEvent(msg.sender, \"bizarre payment\", msg.value);\r\n  }\r\n\r\n\r\n  function depositSecretBid(bytes32 _hash, bytes _message) public duringAuction payable {\r\n    //each address can only submit one bid -- and once a bid is submitted it is imutable\r\n    //for testing, an exception is made for the owner -- but only while the contract is unlocked\r\n    if (!(msg.sender == owner && !isLocked) &&\r\n         (_hash == 0 || secretBids[msg.sender].hash != 0) )\r\n        revert();\r\n    secretBids[msg.sender].hash = _hash;\r\n    secretBids[msg.sender].deposit = msg.value;\r\n    secretBidCount += 1;\r\n    uint _batch = secretBidCount / batchSize;\r\n    SecretBidEvent(_batch, msg.sender, msg.value, _hash, _message);\r\n  }\r\n\r\n\r\n  //\r\n  // the owner may disqualify a bid if it is bogus. for example if the hash does not correspond\r\n  // to the hash that is generated from the encyrpted bid tuple. when a disqualified bid is\r\n  // executed all the deposited funds will be returned to the bidder, as if the bid was below\r\n  // the strike-price.\r\n  //\r\n  function disqualifyBid(address _from) public ownerOnly duringAuction {\r\n    secretBids[_from].disqualified = true;\r\n  }\r\n\r\n\r\n  //\r\n  // execute a bid.\r\n  // * purchases tokens if the specified price is above the strike price\r\n  // * refunds whatever remains of the deposit\r\n  //\r\n  // call only during the sale period (strikePrice > 0)\r\n  // note: _quantity is the number of whole tokens; that is low-level-tokens * decimalMultiplier\r\n  // similarly _price is the price of whole tokens; that is low-level-token price / decimalMultiplier\r\n  //\r\n  function executeBid(uint256 _secret, uint256 _price, uint256 _quantity) public duringSale {\r\n    executeBidFor(msg.sender, _secret, _price, _quantity);\r\n  }\r\n  function executeBidFor(address _addr, uint256 _secret, uint256 _price, uint256 _quantity) public duringSale {\r\n    bytes32 computedHash = keccak256(_secret, _price, _quantity);\r\n    //MessageBytes32Event(\"computedHash\", computedHash);\r\n    require(secretBids[_addr].hash == computedHash);\r\n    //\r\n    if (secretBids[_addr].deposit > 0) {\r\n      uint _cost = 0;\r\n      uint _refund = 0;\r\n      uint _priceWei = safeMul(_price, 1 szabo);\r\n      if (_priceWei >= strikePrice && !secretBids[_addr].disqualified) {\r\n         //up till now all prices and quantities and referred to whole tokens (including strike price); now that we are about\r\n         //to actually do the transfer, convert to low-level tokens\r\n         uint _lowLevelQuantity = safeMul(_quantity, decimalMultiplier);\r\n         uint _lowLevelPrice = strikePrice / decimalMultiplier;\r\n         uint256 _purchaseCount = (_priceWei > strikePrice) ? _lowLevelQuantity : (safeMul(strikePricePctX10, _lowLevelQuantity) / 1000);\r\n         var _maxPurchase = token.balanceOf(this) - developerReserve;\r\n         if (_purchaseCount > _maxPurchase)\r\n           _purchaseCount = _maxPurchase;\r\n         _cost = safeMul(_purchaseCount, _lowLevelPrice);\r\n         if (secretBids[_addr].deposit >= _cost) {\r\n           secretBids[_addr].deposit -= _cost;\r\n           proceeds = safeAdd(proceeds, _cost);\r\n           secretBids[_addr].tokens += _purchaseCount;\r\n           purchasedCount += _purchaseCount;\r\n           //transfer tokens to this bidder\r\n           if (!token.transfer(_addr, _purchaseCount))\r\n             revert();\r\n         }\r\n      }\r\n      //refund whatever remains\r\n      //use pull here, to prevent any bidder from reverting their purchase\r\n      if (secretBids[_addr].deposit > 0) {\r\n        _refund = secretBids[_addr].deposit;\r\n        secretBids[_addr].refund += _refund;\r\n        secretBids[_addr].deposit = 0;\r\n      }\r\n      executedCount += 1;\r\n      uint _batch = executedCount / batchSize;\r\n      ExecuteEvent(_batch, _addr, _cost, _refund);\r\n    }\r\n  }\r\n\r\n\r\n  //\r\n  // expireBid\r\n  // if a bid is not executed during the sale period, then the owner can mark the bid as expired. in this case:\r\n  // * the bidder gets a refund of half of his deposit\r\n  // * the bidder forfeits the other half of his deposit\r\n  // * the bidder does not receive an tokens\r\n  //\r\n  function expireBid(address _addr) public ownerOnly afterSale {\r\n    if (secretBids[_addr].deposit > 0) {\r\n      uint _forfeit = secretBids[_addr].deposit / 2;\r\n      proceeds = safeAdd(proceeds, _forfeit);\r\n      //refund whatever remains\r\n      uint _refund = safeSub(secretBids[_addr].deposit, _forfeit);\r\n      //use pull here, to prevent any bidder from reverting the expire\r\n      secretBids[msg.sender].refund += _refund;\r\n      secretBids[_addr].deposit = 0;\r\n      expiredCount += 1;\r\n      uint _batch = expiredCount / batchSize;\r\n      ExpireEvent(_batch, _addr, _forfeit, _refund);\r\n    }\r\n  }\r\n\r\n\r\n  //\r\n  // bidder withdraw excess funds (or all funds if bid was too low)\r\n  //\r\n  function withdrawRefund() public {\r\n    uint _amount = secretBids[msg.sender].refund;\r\n    secretBids[msg.sender].refund = 0;\r\n    msg.sender.transfer(_amount);\r\n  }\r\n\r\n\r\n  //\r\n  // grant developer tokens, equal to a percentage of purchased tokens.\r\n  // once called, any remaining tokens will be burned.\r\n  //\r\n  function doDeveloperGrant() public afterSale {\r\n    uint _quantity = safeMul(purchasedCount, developerPctX10K) / 1000000;\r\n    uint _tokensLeft = token.balanceOf(this);\r\n    if (_quantity > _tokensLeft)\r\n      _quantity = _tokensLeft;\r\n    if (_quantity > 0) {\r\n      //transfer pct tokens to developers\r\n      _tokensLeft -= _quantity;\r\n      if (!token.transfer(developers, _quantity))\r\n        revert();\r\n    }\r\n    //and burn everthing that remains\r\n    token.unPaidBurnTokens(_tokensLeft);\r\n  }\r\n\r\n\r\n  //\r\n  // pay auction proceeds to the underwriter\r\n  // may be called by underwriter or owner (fbo underwriter)\r\n  //\r\n  function payUnderwriter() public {\r\n    require(msg.sender == owner || msg.sender == underwriter);\r\n    uint _amount = proceeds;\r\n    proceeds = 0;\r\n    if (!underwriter.call.gas(contractSendGas).value(_amount)())\r\n      revert();\r\n  }\r\n\r\n\r\n  //for debug\r\n  //only available before the contract is locked\r\n  function haraKiri() public ownerOnly unlockedOnly {\r\n    selfdestruct(owner);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"purchasedCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_secret\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_quantity\",\"type\":\"uint256\"}],\"name\":\"executeBid\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"disqualifyBid\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stateMask\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_developers\",\"type\":\"address\"},{\"name\":\"_developerPctX10K\",\"type\":\"uint256\"}],\"name\":\"reserveDeveloperTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_auctionStart\",\"type\":\"uint256\"},{\"name\":\"_auctionDuration\",\"type\":\"uint256\"},{\"name\":\"_saleDuration\",\"type\":\"uint256\"}],\"name\":\"setAuctionParms\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hash\",\"type\":\"bytes32\"},{\"name\":\"_message\",\"type\":\"bytes\"}],\"name\":\"depositSecretBid\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"auctionEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"developers\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimalMultiplier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payUnderwriter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"doDeveloperGrant\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"auctionStart\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proceeds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_batchSize\",\"type\":\"uint256\"},{\"name\":\"_contractSendGas\",\"type\":\"uint256\"}],\"name\":\"tune\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"strikePricePctX10\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"developerPctX10K\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_strikePrice\",\"type\":\"uint256\"},{\"name\":\"_strikePricePctX10\",\"type\":\"uint256\"}],\"name\":\"setStrikePrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_secret\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_quantity\",\"type\":\"uint256\"}],\"name\":\"executeBidFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"executedCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"haraKiri\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"strikePrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"expireBid\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"secretBids\",\"outputs\":[{\"name\":\"disqualified\",\"type\":\"bool\"},{\"name\":\"deposit\",\"type\":\"uint256\"},{\"name\":\"refund\",\"type\":\"uint256\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"hash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"houseKeep\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secretBidCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_decimalMultiplier\",\"type\":\"uint256\"},{\"name\":\"_underwriter\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"expiredCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"underwriter\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"developerReserve\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"batch\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"deposit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"SecretBidEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"batch\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"cost\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"refund\",\"type\":\"uint256\"}],\"name\":\"ExecuteEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"batch\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"cost\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"refund\",\"type\":\"uint256\"}],\"name\":\"ExpireEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"message\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"BizarreEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"mask\",\"type\":\"uint256\"}],\"name\":\"StateChangeEvent\",\"type\":\"event\"}]","ContractName":"TokenAuction","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://ba15d56caa83a7fdcf5bbf832c3979beed00ff4b9888ffae9636d8b02d39ac4c"}]}