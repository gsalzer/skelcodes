{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.17;\r\n\r\ncontract Ownable {\r\n\taddress owner;\r\n\taddress potentialOwner;\r\n\t\r\n\tmodifier onlyOwner() {\r\n\t\trequire(owner == msg.sender);\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction Ownable() public {\r\n\t\towner = msg.sender;\r\n\t}\r\n\r\n\t/*\r\n\t * PUBLIC\r\n\t * Check whether you `own` this Lottery\r\n\t */\r\n\tfunction amIOwner() public view returns (bool) {\r\n\t\treturn msg.sender == owner;\r\n\t}\r\n\r\n\t/*\r\n\t * RESTRICTED\r\n\t * Transfer ownership to another address (goes into effect when other address accepts)\r\n\t */\r\n\tfunction transferOwnership(address _newOwner) public onlyOwner {\r\n\t\tpotentialOwner = _newOwner;\r\n\t}\r\n\r\n\t/*\r\n\t * RESTRICTED\r\n\t * Accept ownership of the Lottery (if a transfer has been initiated with your address)\r\n\t */\r\n\tfunction acceptOwnership() public {\r\n\t\trequire(msg.sender == potentialOwner);\r\n\t\towner = msg.sender;\r\n\t\tpotentialOwner = address(0);\r\n\t}\r\n}\r\n\r\ncontract Linkable is Ownable {\r\n\taddress[] linked;\r\n\r\n\tmodifier onlyLinked() {\r\n\t\trequire(checkPermissions() == true);\r\n\t\t_;\r\n\t}\r\n\t\r\n\t/*\r\n\t * RESTRICTED\r\n\t * Link an address to this contract. This address has access to\r\n\t * any `onlyLinked` function\r\n\t */\r\n\tfunction link(address _address) public onlyOwner {\r\n\t\tlinked.push(_address);\r\n\t}\r\n\r\n\t/* \r\n\t * PUBLIC\r\n\t * Check if you have been linked to this contract\r\n\t */\r\n\tfunction checkPermissions() public view returns (bool) {\r\n\t\tfor (uint i = 0; i < linked.length; i++)\r\n\t\t\tif (linked[i] == msg.sender) return true;\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\ncontract Activity is Ownable, Linkable {\r\n  \r\n  struct Event {\r\n    uint id;\r\n    uint gameId;\r\n    address source;\r\n    address[] winners;\r\n    uint winningNumber;\r\n    uint amount;\r\n    uint timestamp;\r\n  }\r\n\r\n  /*\r\n   * Get an event by it's id (index)\r\n   */\r\n  Event[] public events;\r\n\r\n  /*\r\n   * Add a new event\r\n   */\r\n  function newEvent(uint _gameId, address[] _winners, uint _winningNumber, uint _amount) public onlyLinked {\r\n    require(_gameId > 0);\r\n    events.push(Event(events.length, _gameId, msg.sender, _winners, _winningNumber, _amount, now));\r\n  }\r\n\r\n  /*\r\n   * Get the activity feed for all games\r\n   *\r\n   * NOTE: set gameId to 0 for a feed of all games\r\n   *\r\n   * RETURNS:\r\n   * (ids[], gameIds[], sources[], winners[] (index 0 OR msg.sender if they won), numWinners[], winningNums[], jackpots[], timestamps[])\r\n   */\r\n  function getFeed(uint _gameId, uint _page, uint _pageSize) public view\r\n    returns (uint[], uint[], address[], uint[], uint[], uint[], uint[]) {\r\n    \r\n    return constructResponse(getFiltered(_gameId, _page - 1, _pageSize));\r\n  }\r\n\r\n  // ------------------------------------------------------------\r\n  // Private Helpers\r\n\r\n  function constructResponse(Event[] _events) private view\r\n    returns (uint[], uint[], address[], uint[], uint[], uint[], uint[]) {\r\n    \r\n    uint[] memory _ids = new uint[](_events.length);\r\n    uint[] memory _gameIds = new uint[](_events.length);\r\n    uint[] memory _amounts = new uint[](_events.length);\r\n    uint[] memory _timestamps = new uint[](_events.length);\r\n\r\n    for (uint i = 0; i < _events.length; i++) {\r\n      _ids[i] = _events[i].id;\r\n      _gameIds[i] = _events[i].gameId;\r\n      _amounts[i] = _events[i].amount;\r\n      _timestamps[i] = _events[i].timestamp;\r\n    }\r\n\r\n    WinData memory _win = contructWinData(_events);\r\n\r\n    return (_ids, _gameIds, _win.winners, _win.numWinners, _win.winningNumbers, _amounts, _timestamps);\r\n  }\r\n\r\n  struct WinData {\r\n    address[] winners;\r\n    uint[] numWinners;\r\n    uint[] winningNumbers;\r\n  }\r\n\r\n  function contructWinData(Event[] _events) private view returns (WinData) {\r\n    address[] memory _winners = new address[](_events.length);\r\n    uint[] memory _numWinners = new uint[](_events.length);\r\n    uint[] memory _winningNumbers = new uint[](_events.length);\r\n\r\n    for (uint i = 0; i < _events.length; i++) {\r\n      _winners[i] = chooseWinnerToDisplay(_events[i].winners, msg.sender);\r\n      _numWinners[i] = _events[i].winners.length;\r\n      _winningNumbers[i] = _events[i].winningNumber;\r\n    }\r\n\r\n    return WinData(_winners, _numWinners, _winningNumbers);\r\n  }\r\n\r\n  function chooseWinnerToDisplay(address[] _winners, address _user) private pure returns (address) {\r\n    if (_winners.length < 1) return address(0);\r\n    address _picked = _winners[0];\r\n    if (_winners.length == 1) return _picked;\r\n    for (uint i = 1; i < _winners.length; i++)\r\n      if (_winners[i] == _user) _picked = _user;\r\n    return _picked;\r\n  }\r\n\r\n  function getFiltered(uint _gameId, uint _page, uint _pageSize) private view returns (Event[]) {\r\n    Event[] memory _filtered = new Event[](_pageSize);\r\n    uint _filteredIndex;\r\n    uint _minIndex = _page * _pageSize;\r\n    uint _maxIndex = _minIndex + _pageSize;\r\n    uint _count;\r\n\r\n    for (uint i = events.length; i > 0; i--) {\r\n      if (_gameId == 0 || events[i - 1].gameId == _gameId) {\r\n        if (_filteredIndex >= _minIndex && _filteredIndex < _maxIndex) {\r\n          _filtered[_count] = events[i - 1];\r\n          _count++;\r\n        }\r\n        _filteredIndex++;\r\n      }\r\n    }\r\n\r\n    Event[] memory _events = new Event[](_count);\r\n    for (uint b = 0; b < _count; b++)\r\n      _events[b] = _filtered[b];\r\n\r\n    return _events;\r\n  }\r\n\r\n}\r\n\r\ncontract Affiliates is Ownable, Linkable {\r\n\tbool open = true;\r\n\tbool promoted = true;\r\n\r\n\t/*\r\n\t * Open/Close registration of new affiliates\r\n\t */\r\n\tfunction setRegistrationOpen(bool _open) public onlyOwner {\r\n\t\topen = _open;\r\n\t}\r\n\r\n\tfunction isRegistrationOpen() public view returns (bool) {\r\n\t\treturn open;\r\n\t}\r\n\r\n\t/*\r\n\t * Should promote registration of new affiliates\r\n\t */\r\n\tfunction setPromoted(bool _promoted) public onlyOwner {\r\n\t\tpromoted = _promoted;\r\n\t}\r\n\r\n\tfunction isPromoted() public view returns (bool) {\r\n\t\treturn promoted;\r\n\t}\r\n\r\n\t// -----------------------------------------------------------\r\n\r\n\tmapping(uint => uint) balances; // (affiliateCode => balance)\r\n\tmapping(address => uint) links; // (buyer => affiliateCode)\r\n\tmapping(uint => bool) living; // whether a code has been used before (used for open/closing of program)\r\n\t\r\n\t/*\r\n\t * PUBLIC\r\n\t * Get the code for an affiliate\r\n\t */\r\n\tfunction getCode() public view returns (uint) {\r\n\t\treturn code(msg.sender);\r\n\t}\r\n\r\n\t// Convert an affiliate's address into a code\r\n\tfunction code(address _affiliate) private pure returns (uint) {\r\n\t\tuint num = uint(uint256(keccak256(_affiliate)));\r\n\t\treturn num / 10000000000000000000000000000000000000000000000000000000000000000000000;\r\n\t}\r\n\r\n\t/*\r\n\t * PUBLIC\r\n\t * Get the address who originally referred the given user. Returns 0 if not referred\r\n\t */\r\n\tfunction getAffiliation(address _user) public view onlyLinked returns (uint) {\r\n\t\treturn links[_user];\r\n\t}\r\n\r\n\t/*\r\n\t * PUBLIC\r\n\t * Set the affiliation of a user to a given code. Returns the address of the referrer\r\n\t * linked to that code OR, if a user has already been linked to a referer, returns the\r\n\t * address of their original referer\r\n\t */\r\n\tfunction setAffiliation(address _user, uint _code) public onlyLinked returns (uint) {\r\n\t\tuint _affiliateCode = links[_user];\r\n\t\tif (_affiliateCode != 0) return _affiliateCode;\r\n\t\tlinks[_user] = _code;\r\n\t\treturn _code;\r\n\t}\r\n\r\n\t/*\r\n\t * RESTRICTED\r\n\t * Add Wei to multiple affiliates, be sure to send an amount of ether \r\n\t * equivalent to the sum of the _amounts array\r\n\t */\r\n\tfunction deposit(uint[] _affiliateCodes, uint[] _amounts) public payable onlyLinked {\r\n\t\trequire(_affiliateCodes.length == _amounts.length && _affiliateCodes.length > 0);\r\n\r\n\t\tuint _total;\r\n\t\tfor (uint i = 0; i < _affiliateCodes.length; i++) {\r\n\t\t\tbalances[_affiliateCodes[i]] += _amounts[i];\r\n\t\t\t_total += _amounts[i];\r\n\t\t}\r\n\r\n\t\trequire(_total == msg.value && _total > 0);\r\n\t}\r\n\r\n\tevent Withdrawn(address affiliate, uint amount);\r\n\r\n\t/* \r\n\t * PUBLIC\r\n\t * Withdraw Wei into your wallet (will revert if you have no balance)\r\n\t */\r\n\tfunction withdraw() public returns (uint) {\r\n\t\tuint _code = code(msg.sender);\r\n\t\tuint _amount = balances[_code];\r\n\t\trequire(_amount > 0);\r\n\t\tbalances[_code] = 0;\r\n\t\tmsg.sender.transfer(_amount);\t\r\n\t\tWithdrawn(msg.sender, _amount);\r\n\t\treturn _amount;\t\r\n\t}\r\n\r\n\t/* \r\n\t * PUBLIC\r\n\t * Get the amount of Wei you can withdraw\r\n\t */\r\n\tfunction getBalance() public view returns (uint) {\r\n\t\treturn balances[code(msg.sender)];\r\n\t}\r\n}\r\n\r\ncontract Lottery is Ownable {\r\n\tfunction Lottery() public {\r\n\t\towner = msg.sender;\r\n\t}\r\n\r\n\t// ---------------------------------------------------------------------\r\n\t// Lottery Identification - mainly used for Activity events\r\n\t\r\n\tuint id;\r\n\r\n\tfunction setId(uint _id) public onlyOwner {\r\n\t\trequire(_id > 0);\r\n\t\tid = _id;\r\n\t}\r\n\r\n\t// ---------------------------------------------------------------------\r\n\t// Linking\r\n\r\n\t/*\r\n\t * id: a unique non-zero id for this instance. Used for Activity events\r\n\t * activity: address pointing to the Activity instance\r\n\t */\r\n\tfunction link(uint _id, address _activity, address _affiliates) public onlyOwner {\r\n\t\trequire(_id > 0);\r\n\t\tid = _id;\r\n\t\tlinkActivity(_activity);\r\n\t\tlinkAffiliates(_affiliates);\r\n\t\tinitialized();\r\n\t}\r\n\r\n\t// Implement this\r\n\tfunction initialized() internal;\r\n\r\n\t// ---------------------------------------------------------------------\r\n\t// Activity Integration\r\n\r\n\taddress public activityAddress;\r\n\tActivity activity;\r\n\r\n\tfunction linkActivity(address _address) internal onlyOwner {\r\n\t\tactivity = Activity(_address);\r\n\t\trequire(activity.checkPermissions() == true);\r\n\t\tactivityAddress = _address;\r\n\t}\r\n\r\n\tfunction postEvent(address[] _winners, uint _winningNumber, uint _jackpot) internal {\r\n\t\tactivity.newEvent(id, _winners, _winningNumber, _jackpot);\r\n\t}\r\n\r\n\tfunction postEvent(address _winner, uint _winningNumber, uint _jackpot) internal {\r\n\t\taddress[] memory _winners = new address[](1);\r\n\t\t_winners[0] = _winner;\r\n\t\tpostEvent(_winners, _winningNumber, _jackpot);\r\n\t}\r\n\r\n\t// ---------------------------------------------------------------------\r\n\t// Payment transfers\r\n\r\n\taddress public affiliatesAddress;\r\n\tAffiliates affiliates;\r\n\r\n\tfunction linkAffiliates(address _address) internal onlyOwner {\r\n\t\trequire(affiliatesAddress == address(0));\r\n\t\taffiliates = Affiliates(_address);\r\n\t\trequire(affiliates.checkPermissions() == true);\r\n\t\taffiliatesAddress = _address;\r\n\t}\r\n\r\n\tfunction setUserAffiliate(uint _code) internal returns (uint) {\r\n\t\treturn affiliates.setAffiliation(msg.sender, _code);\r\n\t}\r\n\r\n\tfunction userAffiliate() internal view returns (uint) {\r\n\t\treturn affiliates.getAffiliation(msg.sender);\r\n\t}\r\n\r\n\tfunction payoutToAffiliates(uint[] _addresses, uint[] _amounts, uint _total) internal {\r\n\t\taffiliates.deposit.value(_total)(_addresses, _amounts);\r\n\t}\r\n\r\n\t// ---------------------------------------------------------------------\r\n\t// Randomness\r\n\r\n\tfunction getRandomNumber(uint _max) internal returns (uint) {\r\n\t\treturn uint(block.blockhash(block.number-1)) % _max + 1;\r\n\t}\r\n}\r\n\r\n\r\ncontract SlotLottery is Lottery {\r\n\t\r\n\tfunction SlotLottery() Lottery() public {\r\n\t\tstate = State.Uninitialized;\r\n\t}\r\n\r\n\t// ---------------------------------------------------------------------\r\n\t// Linking\r\n\r\n\tfunction initialized() internal {\r\n\t\tstate = State.NotRunning;\r\n\t}\r\n\r\n\t// ---------------------------------------------------------------------\r\n\t// State\r\n\r\n\tState state;\r\n\r\n\tenum State { Uninitialized, Running, Pending, GameOver, NotRunning }\r\n\r\n\tmodifier only(State _state) {\r\n\t\trequire(state == _state);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier not(State _state) {\r\n\t\trequire(state != _state);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier oneOf(State[2] memory _states) {\r\n\t\tbool _valid = false;\r\n\t\tfor (uint i = 0; i < _states.length; i++)\r\n\t\t\tif (state == _states[i]) _valid = true;\r\n\t\trequire(_valid);\r\n\t\t_;\r\n\t}\r\n\r\n\t/*\r\n\t * PUBLIC\r\n\t * Get the current state of the Lottery\r\n\t */\r\n\tfunction getState() public view returns (State) {\r\n\t\treturn state;\r\n\t}\r\n\r\n\t// ---------------------------------------------------------------------\r\n\t// Administrative\r\n\r\n\t/*\r\n\t * RESTRICTED\r\n\t * Start up a new game with the given game rules\r\n\t */\r\n\tfunction startGame(uint _jackpot, uint _slots, uint _price, uint _max) public only(State.NotRunning) onlyOwner {\r\n\t\trequire(_price * _slots > _jackpot);\r\n\t\tnextGame(verifiedGameRules(_jackpot, _slots, _price, _max));\r\n\t}\r\n\r\n\t/*\r\n\t * RESTRICTED\r\n\t * When the currently running game ends, a new game won't be automatically started\r\n\t */\r\n\tfunction suspendGame() public onlyOwner {\r\n\t\tgame.loop = false;\r\n\t}\r\n\r\n\t/*\r\n\t * RESTRICTED\r\n\t * When the currently running game ends, a new game will be automatically started (this is the default behavior)\r\n\t */\r\n\tfunction gameShouldRestart() public onlyOwner {\r\n\t\tgame.loop = true;\r\n\t}\r\n\r\n\t/*\r\n\t * RESTRICTED\r\n\t * In the event that some error occurs and the contract never gets the random callback\r\n\t * the owner of the Lottery can trigger another random number to be retrieved\r\n\t */\r\n\tfunction triggerFindWinner() public only(State.Pending) payable onlyOwner {\r\n\t\tstate = State.Running;\r\n\t\tfindWinner();\r\n\t}\r\n\r\n\t/*\r\n\t * RESTRICTED\r\n\t * Set new rules for the next game\r\n\t */\r\n\tfunction setNextRules(uint _jackpot, uint _slots, uint _price, uint _max) public not(State.NotRunning) onlyOwner {\r\n\t\trequire(game.loop == true);\r\n\t\tgame.nextGameRules = verifiedGameRules(_jackpot, _slots, _price, _max);\r\n\t}\r\n\r\n\t/*\r\n\t * RESTRICTED\r\n\t * Get the rules for the upcoming game (if there even is one)\r\n\t * (jackpot, numberOfTickets, ticketPrice, maxTicketsPer, willStartNewGameUponCompletion)\r\n\t */\r\n\tfunction getNextRules() public view onlyOwner returns (uint, uint, uint, uint, bool) {\r\n\t\treturn (game.nextGameRules.jackpot, game.nextGameRules.slots, game.nextGameRules.ticketPrice, game.nextGameRules.maxTicketsPer, game.loop);\r\n\t}\r\n\r\n\t// ---------------------------------------------------------------------\r\n\t// Lifecycle\r\n\r\n\tfunction nextGame(GameRules _rules) internal oneOf([State.GameOver, State.NotRunning]) {\r\n\t\tuint _newId = lastGame.id + 1;\r\n\t\tgame = Game({\r\n\t\t\tid: _newId, rules: _rules, nextGameRules: _rules, loop: true, startedAt: block.timestamp, \r\n\t\t\tticketsSold: 0, winner: address(0), winningNumber: 0, finishedAt: 0\r\n\t\t});\r\n\t\tfor(uint i = 1; i <= game.rules.slots; i++)\r\n\t\t\tgame.tickets[i] = address(0);\r\n\t\tstate = State.Running;\r\n\t}\r\n\r\n\tfunction findWinner() internal only(State.Running) {\r\n\t\trequire(game.ticketsSold >= game.rules.slots);\r\n\t\trequire(this.balance >= game.rules.jackpot);\r\n\r\n\t\tstate = State.Pending;\r\n\t\tuint _winningNumber = getRandomNumber(game.rules.slots);\r\n\t\twinnerChosen(_winningNumber);\r\n\t}\r\n\r\n\tfunction winnerChosen(uint _winningNumber) internal only(State.Pending) {\r\n\t\tstate = State.GameOver;\r\n\r\n\t\taddress _winner = game.tickets[_winningNumber];\r\n\t\tbool _startNew = game.loop;\r\n\t\tGameRules memory _nextRules = game.nextGameRules;\r\n\r\n\t\tgame.finishedAt = block.timestamp;\r\n\t\tgame.winner = _winner;\r\n\t\tgame.winningNumber = _winningNumber;\r\n\t\tlastGame = game;\r\n\r\n\t\t// Pay winner, affiliates, and owner\r\n\t\t_winner.transfer(game.rules.jackpot);\r\n\t\tpayAffiliates();\r\n\t\towner.transfer(this.balance);\r\n\r\n\t\t// Post new event to Activity contract\r\n\t\tpostEvent(_winner, _winningNumber, game.rules.jackpot);\r\n\r\n\t\tif (!_startNew) {\r\n\t\t\tstate = State.NotRunning;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tnextGame(_nextRules);\r\n\t}\r\n\r\n\t// ---------------------------------------------------------------------\r\n\t// Lottery\r\n\r\n\tGame game;\r\n\tGame lastGame;\t\r\n\r\n\tenum PurchaseError { InvalidTicket, OutOfTickets, NotEnoughFunds, LotteryClosed, TooManyTickets, TicketUnavailable, Unknown }\r\n\tevent TicketsPurchased(address buyer, uint[] tickets, uint[] failedTickets, PurchaseError[] errors);\r\n\tevent PurchaseFailed(address buyer, PurchaseError error);\r\n\r\n\t/*\r\n\t * PUBLIC\r\n\t * Buy tickets for the Lottery by passing in an array of ticket numbers (starting at 1 not 0)\r\n\t * This function doesn't revert when tickets fail to be purchased, it triggers events and\r\n\t * refunds you for the tickets that failed to be purchased.\r\n\t *\r\n\t * Events:\r\n\t * TicketsPurchased: One or more tickets were successfully purchased\r\n\t * PurchaseFailed: Failed to purchase all of the tickets\r\n\t */\r\n\tfunction purchaseTickets(uint[] _tickets) public payable {\r\n\t\tpurchaseTicketsWithReferral(_tickets, 0);\r\n\t}\r\n\r\n\t/*\r\n\t * PUBLIC\r\n\t * Buy tickets with a referral code\r\n\t */\r\n\tfunction purchaseTicketsWithReferral(uint[] _tickets, uint _affiliateCode) public payable {\r\n\t\t\r\n\t\t// Check game state\r\n\t\tif (state != State.Running) {\r\n\t\t\tif (state == State.NotRunning) return failPurchase(PurchaseError.LotteryClosed);\r\n\t\t\treturn failPurchase(PurchaseError.OutOfTickets);\r\n\t\t}\r\n\r\n\t\t// Check sent funds\r\n\t\tif (msg.value < _tickets.length * game.rules.ticketPrice) \r\n\t\t\treturn failPurchase(PurchaseError.NotEnoughFunds);\r\n\r\n\t\tuint[] memory _userTickets = getMyTickets();\r\n\r\n\t\t// Check max tickets (checked again in the loop below)\r\n\t\tif (_userTickets.length >= game.rules.maxTicketsPer)\r\n\t\t\treturn failPurchase(PurchaseError.TooManyTickets);\r\n\r\n\t\t// Some tickets may fail while others succeed, lets keep track of all of that so it\r\n\t\t// can be returned to the frontend user\r\n\t\tuint[] memory _successful = new uint[](_tickets.length);\r\n\t\tuint[] memory _failed = new uint[](_tickets.length);\r\n\t\tPurchaseError[] memory _errors = new PurchaseError[](_tickets.length);\r\n\t\tuint _successCount;\r\n\t\tuint _errorCount;\r\n\r\n\t\tfor(uint i = 0; i < _tickets.length; i++) {\r\n\t\t\tuint _ticket = _tickets[i];\r\n\r\n\t\t\t// Check that the ticket is a valid number\r\n\t\t\tif (_ticket <= 0 || _ticket > game.rules.slots) {\r\n\t\t\t\t_failed[_errorCount] = _ticket;\r\n\t\t\t\t_errors[_errorCount] = PurchaseError.InvalidTicket;\r\n\t\t\t\t_errorCount++;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t// Check that the ticket is available for purchase\r\n\t\t\tif (game.tickets[_ticket] != address(0)) {\r\n\t\t\t\t_failed[_errorCount] = _ticket;\r\n\t\t\t\t_errors[_errorCount] = PurchaseError.TicketUnavailable;\r\n\t\t\t\t_errorCount++;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t// Check that the user hasn't reached their max tickets\r\n\t\t\tif (_userTickets.length + _successCount >= game.rules.maxTicketsPer) {\r\n\t\t\t\t_failed[_errorCount] = _ticket;\r\n\t\t\t\t_errors[_errorCount] = PurchaseError.TooManyTickets;\r\n\t\t\t\t_errorCount++;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tgame.tickets[_ticket] = msg.sender;\r\n\t\t\tgame.ticketsSold++;\r\n\r\n\t\t\t_successful[_successCount] = _ticket;\r\n\t\t\t_successCount++;\r\n\t\t}\r\n\r\n\t\t// Refund for failed tickets\r\n\t\t// Cannot refund more than received, will send what was given if refunding the free ticket\r\n\t\tif (_errorCount > 0) refund(_errorCount * game.rules.ticketPrice);\r\n\t\t\r\n\t\t// Affiliates\r\n\t\tuint _userAffiliateCode = userAffiliate();\r\n\t\tif (_affiliateCode != 0 && _userAffiliateCode == 0)\r\n\t\t\t_userAffiliateCode = setUserAffiliate(_affiliateCode);\r\n\t\tif (_userAffiliateCode != 0) addAffiliate(_userAffiliateCode, _successCount);\r\n\r\n\t\t// TicketsPurchased(msg.sender, _normalizedSuccessful, _normalizedFailures, _normalizedErrors);\r\n\t\tTicketsPurchased(msg.sender, _successful, _failed, _errors);\r\n\r\n\t\t// If the last ticket was sold, signal to find a winner\r\n\t\tif (game.ticketsSold >= game.rules.slots) findWinner();\r\n\t}\r\n\r\n\t/*\r\n\t * PUBLIC\r\n\t * Get the tickets you have purchased for the current game\r\n\t */\r\n\tfunction getMyTickets() public view returns (uint[]) {\r\n\t\tuint _userTicketCount;\r\n\t\tfor(uint i = 0; i < game.rules.slots; i++)\r\n\t\t\tif (game.tickets[i + 1] == msg.sender) _userTicketCount += 1;\r\n\r\n\t\tuint[] memory _tickets = new uint[](_userTicketCount);\r\n\t\tuint _index;\r\n\t\tfor(uint b = 0; b < game.rules.slots; b++) {\r\n\t\t\tif (game.tickets[b + 1] == msg.sender) {\r\n\t\t\t\t_tickets[_index] = b + 1;\r\n\t\t\t\t_index++;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn _tickets;\r\n\t}\r\n\r\n\t// ---------------------------------------------------------------------\r\n\t// Game\r\n\r\n\tstruct GameRules {\r\n\t\tuint jackpot;\r\n\t\tuint slots;\r\n\t\tuint ticketPrice;\r\n\t\tuint maxTicketsPer;\r\n\t}\r\n\r\n\tfunction verifiedGameRules(uint _jackpot, uint _slots, uint _price, uint _max) internal pure returns (GameRules) {\r\n\t\trequire((_price * _slots) - _jackpot > 100000000000000000); // margin is greater than 0.1 ETH (for callback fees)\r\n\t\trequire(_max <= _slots);\r\n\t\treturn GameRules(_jackpot, _slots, _price, _max);\r\n\t}\r\n\r\n\tstruct Game {\r\n\t\tuint id;\r\n\t\tGameRules rules;\r\n\t\tmapping(uint => address) tickets; // (ticketNumber => buyerAddress)\r\n\t\tuint ticketsSold;\r\n\t\tGameRules nextGameRules; // These rules will be used if the game recreates itself\r\n\t\taddress winner;\r\n\t\tuint winningNumber;\r\n\t\tbool loop;\r\n\t\tuint startedAt;\r\n\t\tuint finishedAt;\r\n\t}\r\n\r\n\t/*\r\n\t * PUBLIC\r\n\t * Get information pertaining to the current game\r\n\t *\r\n\t * returns: (id, jackpot, totalTickets, ticketsRemaining, ticketPrice, maxTickets, state,\r\n\t \t\t\t\t\t\ttickets[], yourTickets[])\r\n\t * NOTE: tickets[] is an array of booleans, true = available and false = sold\r\n\t */\r\n\tfunction getCurrentGame() public view \r\n\t\treturns (uint, uint, uint, uint, uint, uint, State, bool[], uint[]) {\r\n\t\t\r\n\t\tuint _remainingTickets = game.rules.slots - game.ticketsSold;\r\n\t\tbool[] memory _tickets = new bool[](game.rules.slots);\r\n\t\tuint[] memory _userTickets = getMyTickets();\r\n\r\n\t\tfor (uint i = 0; i < game.rules.slots; i++)\r\n\t\t\t_tickets[i] = game.tickets[i + 1] == address(0);\r\n\r\n\t\treturn (game.id, game.rules.jackpot, game.rules.slots, _remainingTickets, \r\n\t\t\tgame.rules.ticketPrice, game.rules.maxTicketsPer, state, _tickets, _userTickets);\r\n\t}\r\n\r\n\t/*\r\n\t * PUBLIC\r\n\t * Get information pertaining to the last game\r\n\t *\r\n\t * returns: (id, jackpot, totalTickets, ticketPrice, winner, finishedAt)\r\n\t * NOTE: tickets[] is an array of booleans, true = available and false = sold\r\n\t */\r\n\tfunction getLastGame() public view returns(uint, uint, uint, uint, address, uint) {\r\n\t\treturn (lastGame.id, lastGame.rules.jackpot, lastGame.rules.slots, \r\n\t\t\tlastGame.rules.ticketPrice, lastGame.winner, lastGame.finishedAt);\r\n\t}\r\n\r\n\t// ---------------------------------------------------------------------\r\n\t// Affiliates\r\n\r\n\tuint[] currentGameAffiliates;\r\n\tuint numAffiliates;\r\n\tuint affiliateCut = 2; // Example: 2 = 1/2 (50%), 3 = 1/3 (33%), etc.\r\n\r\n\tfunction addAffiliate(uint _affiliate, uint _ticketCount) internal {\r\n\t\tfor (uint i = 0; i < _ticketCount; i++) {\r\n\t\t\tif (numAffiliates >= currentGameAffiliates.length) currentGameAffiliates.length += 1;\r\n\t\t\tcurrentGameAffiliates[numAffiliates++] = _affiliate;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction payAffiliates() internal {\r\n\t\tuint profit = (game.rules.slots * game.rules.ticketPrice) - game.rules.jackpot;\r\n\t\tif (profit > this.balance) profit = this.balance;\r\n\r\n\t\tuint _payment = (profit / game.rules.slots) / affiliateCut;\r\n\t\tuint _pool = _payment * numAffiliates;\r\n\t\t\r\n\t\tuint[] memory _affiliates = new uint[](numAffiliates);\r\n\t\tuint[] memory _amounts = new uint[](numAffiliates);\r\n\r\n\t\tfor (uint i = 0; i < numAffiliates; i++) {\r\n\t\t\t_affiliates[i] = currentGameAffiliates[i];\r\n\t\t\t_amounts[i] = _payment;\r\n\t\t}\r\n\r\n\t\t// payout to given affiliates with given amounts\r\n\t\tif (numAffiliates > 0)\r\n\t\t\tpayoutToAffiliates(_affiliates, _amounts, _pool);\r\n\r\n\t\t// Clear the affiliates\r\n\t\tnumAffiliates = 0;\r\n\t}\r\n\r\n\t// ---------------------------------------------------------------------\r\n\t// Utilities\r\n\r\n\tfunction randomNumberFound(uint _number, uint _secret) internal {\r\n\t\trequire(state == State.Pending);\r\n\t\trequire(game.id == _secret);\r\n\t\trequire(_number >= 1 && _number <= game.rules.slots);\r\n\t\twinnerChosen(_number);\r\n\t}\r\n\r\n\tfunction failPurchase(PurchaseError _error) internal {\r\n\t\tPurchaseFailed(msg.sender, _error);\r\n\t\trefund(msg.value);\r\n\t}\r\n\r\n\tfunction refund(uint _amount) internal {\r\n\t\tif (_amount > 0 && _amount <= msg.value) {\r\n\t\t\tmsg.sender.transfer(_amount);\r\n\t\t} else if (_amount > msg.value) {\r\n\t\t\tmsg.sender.transfer(msg.value);\r\n\t\t}\r\n\t}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"activityAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"suspendGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tickets\",\"type\":\"uint256[]\"},{\"name\":\"_affiliateCode\",\"type\":\"uint256\"}],\"name\":\"purchaseTicketsWithReferral\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tickets\",\"type\":\"uint256[]\"}],\"name\":\"purchaseTickets\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amIOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"gameShouldRestart\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLastGame\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentGame\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"bool[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_jackpot\",\"type\":\"uint256\"},{\"name\":\"_slots\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_max\",\"type\":\"uint256\"}],\"name\":\"startGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"triggerFindWinner\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNextRules\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"setId\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"affiliatesAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMyTickets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_activity\",\"type\":\"address\"},{\"name\":\"_affiliates\",\"type\":\"address\"}],\"name\":\"link\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_jackpot\",\"type\":\"uint256\"},{\"name\":\"_slots\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_max\",\"type\":\"uint256\"}],\"name\":\"setNextRules\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tickets\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"failedTickets\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"errors\",\"type\":\"uint8[]\"}],\"name\":\"TicketsPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"error\",\"type\":\"uint8\"}],\"name\":\"PurchaseFailed\",\"type\":\"event\"}]","ContractName":"SlotLottery","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://23a4d436bed8e2675e93d0d48cbdf94e40669bc9b5e413dc74ae722b12f02ed2"}]}