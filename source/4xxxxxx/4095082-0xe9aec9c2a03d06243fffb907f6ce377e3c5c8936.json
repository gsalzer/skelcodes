{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n    \r\n   // ----------------------------------------------------------------------------------------------\r\n   // Developer Nechesov Andrey: Facebook.com/Nechesov   \r\n   // Enjoy. (c) PRCR.org ICO Platform 2017. The PRCR Licence.\r\n   // ----------------------------------------------------------------------------------------------\r\n    \r\n   // ERC Token Standard #20 Interface\r\n   // https://github.com/ethereum/EIPs/issues/20\r\n  contract ERC20Interface {\r\n      // Get the total token supply\r\n      function totalSupply() constant returns (uint256 totalSupply);\r\n   \r\n      // Get the account balance of another account with address _owner\r\n      function balanceOf(address _owner) constant returns (uint256 balance);\r\n   \r\n      // Send _value amount of tokens to address _to\r\n      function transfer(address _to, uint256 _value) returns (bool success);\r\n   \r\n      // Send _value amount of tokens from address _from to address _to\r\n      function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n   \r\n      // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\r\n      // If this function is called again it overwrites the current allowance with _value.\r\n      // this function is required for some DEX functionality\r\n      function approve(address _spender, uint256 _value) returns (bool success);\r\n   \r\n      // Returns the amount which _spender is still allowed to withdraw from _owner\r\n      function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n   \r\n      // Triggered when tokens are transferred.\r\n      event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n   \r\n      // Triggered whenever approve(address _spender, uint256 _value) is called.\r\n      event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n  }  \r\n   \r\n  contract CentraToken is ERC20Interface {\r\n\r\n      string public constant symbol = \"Centra\";\r\n      string public constant name = \"Centra token\";\r\n      uint8 public constant decimals = 18; \r\n           \r\n      uint256 public constant maxTokens = 100000000*10**18; \r\n      uint256 public constant ownerSupply = maxTokens*32/100;\r\n      uint256 _totalSupply = ownerSupply;  \r\n\r\n      uint256 public constant token_price = 1/400*10**18; \r\n      uint public constant ico_start = 1501891200;\r\n      uint public constant ico_finish = 1507248000; \r\n      uint public constant minValuePre = 100*10**18; \r\n      uint public constant minValue = 1*10**18; \r\n      uint public constant maxValue = 3000*10**18;       \r\n\r\n      uint public constant card_gold_minamount  = 30*10**18;\r\n      uint public constant card_gold_first = 1000;\r\n      mapping(address => uint) cards_gold_check; \r\n      address[] public cards_gold;\r\n\r\n      uint public constant card_black_minamount = 100*10**18;\r\n      uint public constant card_black_first = 500;\r\n      mapping(address => uint) public cards_black_check; \r\n      address[] public cards_black;\r\n\r\n      uint public constant card_titanium_minamount  = 500*10**18;\r\n      uint public constant card_titanium_first = 200;\r\n      mapping(address => uint) cards_titanium_check; \r\n      address[] public cards_titanium;\r\n\r\n      uint public constant card_blue_minamount  = 5/10*10**18;\r\n      uint public constant card_blue_first = 100000000;\r\n      mapping(address => uint) cards_blue_check; \r\n      address[] public cards_blue;\r\n\r\n      uint public constant card_start_minamount  = 1/10*10**18;\r\n      uint public constant card_start_first = 100000000;\r\n      mapping(address => uint) cards_start_check; \r\n      address[] public cards_start;\r\n\r\n      using SafeMath for uint;      \r\n      \r\n      // Owner of this contract\r\n      address public owner;\r\n   \r\n      // Balances for each account\r\n      mapping(address => uint256) balances;\r\n   \r\n      // Owner of account approves the transfer of an amount to another account\r\n      mapping(address => mapping (address => uint256)) allowed;\r\n   \r\n      // Functions with this modifier can only be executed by the owner\r\n      modifier onlyOwner() {\r\n          if (msg.sender != owner) {\r\n              throw;\r\n          }\r\n          _;\r\n      }      \r\n   \r\n      // Constructor\r\n      function CentraToken() {\r\n          owner = msg.sender;\r\n          balances[owner] = ownerSupply;\r\n      }\r\n      \r\n      //default function for buy tokens      \r\n      function() payable {        \r\n          tokens_buy();        \r\n      }\r\n      \r\n      function totalSupply() constant returns (uint256 totalSupply) {\r\n          totalSupply = _totalSupply;\r\n      }\r\n\r\n      //Withdraw money from contract balance to owner\r\n      function withdraw() onlyOwner returns (bool result) {\r\n          owner.send(this.balance);\r\n          return true;\r\n      }\r\n   \r\n      // What is the balance of a particular account?\r\n      function balanceOf(address _owner) constant returns (uint256 balance) {\r\n          return balances[_owner];\r\n      }\r\n   \r\n      // Transfer the balance from owner's account to another account\r\n      function transfer(address _to, uint256 _amount) returns (bool success) {\r\n\r\n          if(now < ico_start) throw;\r\n\r\n          if (balances[msg.sender] >= _amount \r\n              && _amount > 0\r\n              && balances[_to] + _amount > balances[_to]) {\r\n              balances[msg.sender] -= _amount;\r\n              balances[_to] += _amount;\r\n              Transfer(msg.sender, _to, _amount);\r\n              return true;\r\n          } else {\r\n              return false;\r\n          }\r\n      }\r\n   \r\n      // Send _value amount of tokens from address _from to address _to\r\n      // The transferFrom method is used for a withdraw workflow, allowing contracts to send\r\n      // tokens on your behalf, for example to \"deposit\" to a contract address and/or to charge\r\n      // fees in sub-currencies; the command should fail unless the _from account has\r\n      // deliberately authorized the sender of the message via some mechanism; we propose\r\n      // these standardized APIs for approval:\r\n      function transferFrom(\r\n          address _from,\r\n          address _to,\r\n          uint256 _amount\r\n     ) returns (bool success) {\r\n\r\n         if(now < ico_start) throw;\r\n\r\n         if (balances[_from] >= _amount\r\n             && allowed[_from][msg.sender] >= _amount\r\n             && _amount > 0\r\n             && balances[_to] + _amount > balances[_to]) {\r\n             balances[_from] -= _amount;\r\n             allowed[_from][msg.sender] -= _amount;\r\n             balances[_to] += _amount;\r\n             Transfer(_from, _to, _amount);\r\n             return true;\r\n         } else {\r\n             return false;\r\n         }\r\n     }\r\n  \r\n     // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\r\n     // If this function is called again it overwrites the current allowance with _value.\r\n     function approve(address _spender, uint256 _amount) returns (bool success) {\r\n         allowed[msg.sender][_spender] = _amount;\r\n         Approval(msg.sender, _spender, _amount);\r\n         return true;\r\n     }\r\n  \r\n     function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n         return allowed[_owner][_spender];\r\n     }\r\n     //get total black cards\r\n    function cards_black_total() constant returns (uint) { \r\n      return cards_black.length;\r\n    }\r\n    //get total gold cards\r\n    function cards_gold_total() constant returns (uint) { \r\n      return cards_gold.length;\r\n    }    \r\n    //get total titanium cards\r\n    function cards_titanium_total() constant returns (uint) { \r\n      return cards_titanium.length;\r\n    }\r\n    //get total blue cards\r\n    function cards_blue_total() constant returns (uint) { \r\n      return cards_blue.length;\r\n    }\r\n\r\n    //get total start cards\r\n    function cards_start_total() constant returns (uint) { \r\n      return cards_start.length;\r\n    }\r\n\r\n      /**\r\n      * Buy tokens pre-sale and sale \r\n      */\r\n      function tokens_buy() payable returns (bool) { \r\n\r\n        uint tnow = now;\r\n        \r\n        if(tnow > ico_finish) throw;        \r\n        if(_totalSupply >= maxTokens) throw;\r\n        if(!(msg.value >= token_price)) throw;\r\n        if(!(msg.value >= minValue)) throw;\r\n        if(msg.value > maxValue) throw;\r\n\r\n        uint tokens_buy = msg.value/token_price*10**18;\r\n\r\n        if(!(tokens_buy > 0)) throw;   \r\n\r\n        if(tnow < ico_start){\r\n          if(!(msg.value >= minValuePre)) throw;\r\n          tokens_buy = tokens_buy*125/100;\r\n        } \r\n        if((ico_start + 86400*0 <= tnow)&&(tnow < ico_start + 86400*2)){\r\n          tokens_buy = tokens_buy*120/100;\r\n        } \r\n        if((ico_start + 86400*2 <= tnow)&&(tnow < ico_start + 86400*7)){\r\n          tokens_buy = tokens_buy*110/100;        \r\n        } \r\n        if((ico_start + 86400*7 <= tnow)&&(tnow < ico_start + 86400*14)){\r\n          tokens_buy = tokens_buy*105/100;        \r\n        }         \r\n\r\n        if(_totalSupply.add(tokens_buy) > maxTokens) throw;\r\n        _totalSupply = _totalSupply.add(tokens_buy);\r\n        balances[msg.sender] = balances[msg.sender].add(tokens_buy); \r\n\r\n        if((msg.value >= card_gold_minamount)\r\n          &&(msg.value < card_black_minamount)\r\n          &&(cards_gold.length < card_gold_first)\r\n          &&(cards_gold_check[msg.sender] != 1)\r\n          ) {\r\n          cards_gold.push(msg.sender);\r\n          cards_gold_check[msg.sender] = 1;\r\n        }       \r\n\r\n        if((msg.value >= card_black_minamount)\r\n          &&(msg.value < card_titanium_minamount)\r\n          &&(cards_black.length < card_black_first)\r\n          &&(cards_black_check[msg.sender] != 1)\r\n          ) {\r\n          cards_black.push(msg.sender);\r\n          cards_black_check[msg.sender] = 1;\r\n        }        \r\n\r\n        if((msg.value >= card_titanium_minamount)\r\n          &&(cards_titanium.length < card_titanium_first)\r\n          &&(cards_titanium_check[msg.sender] != 1)\r\n          ) {\r\n          cards_titanium.push(msg.sender);\r\n          cards_titanium_check[msg.sender] = 1;\r\n        }\r\n\r\n        if((msg.value >= card_blue_minamount)\r\n          &&(msg.value < card_gold_minamount)\r\n          &&(cards_blue.length < card_blue_first)\r\n          &&(cards_blue_check[msg.sender] != 1)\r\n          ) {\r\n          cards_blue.push(msg.sender);\r\n          cards_blue_check[msg.sender] = 1;\r\n        }\r\n\r\n        if((msg.value >= card_start_minamount)\r\n          &&(msg.value < card_blue_minamount)\r\n          &&(cards_start.length < card_start_first)\r\n          &&(cards_start_check[msg.sender] != 1)\r\n          ) {\r\n          cards_start.push(msg.sender);\r\n          cards_start_check[msg.sender] = 1;\r\n        }\r\n\r\n        return true;\r\n      }\r\n      \r\n }\r\n\r\n /**\r\n   * Math operations with safety checks\r\n   */\r\n  library SafeMath {\r\n    function mul(uint a, uint b) internal returns (uint) {\r\n      uint c = a * b;\r\n      assert(a == 0 || c / a == b);\r\n      return c;\r\n    }\r\n\r\n    function div(uint a, uint b) internal returns (uint) {\r\n      // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n      uint c = a / b;\r\n      // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n      return c;\r\n    }\r\n\r\n    function sub(uint a, uint b) internal returns (uint) {\r\n      assert(b <= a);\r\n      return a - b;\r\n    }\r\n\r\n    function add(uint a, uint b) internal returns (uint) {\r\n      uint c = a + b;\r\n      assert(c >= a);\r\n      return c;\r\n    }\r\n\r\n    function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n      return a >= b ? a : b;\r\n    }\r\n\r\n    function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n      return a < b ? a : b;\r\n    }\r\n\r\n    function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n      return a >= b ? a : b;\r\n    }\r\n\r\n    function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n      return a < b ? a : b;\r\n    }\r\n\r\n    function assert(bool assertion) internal {\r\n      if (!assertion) {\r\n        throw;\r\n      }\r\n    }\r\n  }","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"card_blue_first\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"cards_gold\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"card_black_first\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ico_finish\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"card_start_minamount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"result\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"card_gold_minamount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"card_black_minamount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"card_gold_first\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"tokens_buy\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cards_black_total\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cards_titanium_total\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ico_start\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token_price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"card_titanium_first\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"cards_start\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"card_titanium_minamount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minValuePre\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"cards_titanium\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"cards_blue\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"cards_black\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cards_start_total\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"cards_black_check\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cards_blue_total\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"card_start_first\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cards_gold_total\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"card_blue_minamount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"CentraToken","CompilerVersion":"v0.4.13+commit.fb4cb1a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://75ea8a995da55feaf89183de7279af1670516c70705c2ade9bd8039a962c61e5"}]}