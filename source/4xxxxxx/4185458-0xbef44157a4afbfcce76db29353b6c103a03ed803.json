{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.9;\r\n\r\n/**\r\n * Math operations with safety checks\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n\t * @title ERC20Basic\r\n\t * @dev Simpler version of ERC20 interface\r\n\t * @dev see https://github.com/ethereum/EIPs/issues/20\r\n\t */\r\ncontract ERC20Basic {\r\n\t  uint256 public totalSupply;\r\n\t  function balanceOf(address who) constant returns (uint256);\r\n\t  function transfer(address to, uint256 value);\r\n\t  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value);\r\n  function approve(address spender, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  /**\r\n   * @dev Fix for the ERC20 short address attack.\r\n   */\r\n  modifier onlyPayloadSize(uint256 size) {\r\n     require(!(msg.data.length < size + 4));\r\n     _;\r\n  }\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) {\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of. \r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implemantation of the basic standart token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is BasicToken, ERC20 {\r\n\r\n  mapping (address => mapping (address => uint256)) allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amout of tokens to be transfered\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) {\r\n    var _allowance = allowed[_from][msg.sender];\r\n\r\n    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n    // if (_value > _allowance) throw;\r\n\r\n    balances[_to] = balances[_to].add(_value);\r\n    balances[_from] = balances[_from].sub(_value);\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\n    Transfer(_from, _to, _value);\r\n  }\r\n\r\n  /**\r\n   * @dev Aprove the passed address to spend the specified amount of tokens on beahlf of msg.sender.\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) {\r\n\r\n    // To change the approve amount you first have to reduce the addresses`\r\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n    //  already 0 to mitigate the race condition described here:\r\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    require(!((_value != 0) && (allowed[msg.sender][_spender] != 0)) );\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens than an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifing the amount of tokens still avaible for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n}\r\n\r\ncontract Pixiu_Beta is StandardToken {\r\n\r\n    uint public decimals = 6;\r\n    bool public isPayable = true;\r\n    bool public isWithdrawable = true;\r\n\t\r\n    struct exchangeRate {\r\n        \r\n        uint time1;                                      \r\n        uint time2;                                     \r\n        uint value;\r\n        \r\n    }\r\n    \r\n    struct Member {\r\n         \r\n        bool isExists;                                      \r\n        bool isDividend;                                    \r\n        bool isWithdraw;                                     \r\n        uint256 dividend;                                   \r\n        uint256 withdraw;\r\n        \r\n    }\r\n    \r\n    exchangeRate[] private exchangeRateArray;  \r\n\r\n\tmapping (address => Member) private members; \r\n    address[] private adminArray;   \r\n    address[] private memberArray;\r\n\t\r\n    address private deposit_address;\r\n    uint256 private INITIAL_SUPPLY = 21000000000000;\r\n    uint256 private tokenExchangeRateInWei = 0;\r\n\r\n\t//不歸零\r\n\tuint256 private total_tokenwei = 0; \r\n\r\n\t// drawall 歸零\r\n\tuint256 private total_devidend = 0; //member\r\n\tuint256 private total_withdraw = 0; //member\r\n    uint256 private deposit_amount = 0;  //deposit\r\n    uint256 private withdraw_amount = 0; //deposit\r\n    uint256 private dividend_amount = 0; //admin   \r\n    \r\n    function Pixiu_Beta() {\r\n     \r\n        totalSupply = INITIAL_SUPPLY; \r\n        adminArray.push(msg.sender);\r\n        set_deposit_address(msg.sender);\r\n        set_exchange_rate_in_eth(300);\r\n         \r\n    }\r\n\r\n    modifier onlyDeposit() {\r\n        \r\n        require(msg.sender == deposit_address);\r\n        _;\r\n        \r\n    }\r\n    \r\n    modifier onlyAdmin() {\r\n        \r\n        bool ok = admin_check(msg.sender);\r\n        require(ok);\r\n        _;\r\n        \r\n    }\r\n    \r\n    modifier adminExists(address admin) {\r\n\r\n        bool ok = false;\r\n        if(admin != msg.sender){\r\n            \r\n            ok = admin_check(admin);\r\n        \r\n        }\r\n        require(ok);\r\n        _; \r\n        \r\n    }\r\n    \r\n    modifier adminDoesNotExist(address admin) {\r\n\r\n        bool ok = admin_check(admin);\r\n        require(!ok);\r\n        _;\r\n        \r\n    }\r\n    \r\n    function admin_check(address admin) private constant returns(bool){\r\n        \r\n        bool ok = false;\r\n        \r\n        for (uint i = 0; i < adminArray.length; i++) {\r\n            if (admin == adminArray[i]) {\r\n                ok = true;\r\n                break;\r\n            }\r\n        }\r\n        \r\n        return ok;\r\n        \r\n    }\r\n    \r\n    modifier memberExists(address member) {\r\n\r\n        bool ok = false;\r\n        if (members[member].isExists == true) {\r\n            \r\n            ok = true;\r\n            \r\n        }\r\n        require(ok);\r\n        _;\r\n        \r\n    }\r\n    \r\n    modifier isMember() {\r\n\r\n        bool ok = false;\r\n        if (members[msg.sender].isExists == true) {            \r\n            ok = true;            \r\n        }\r\n        require(ok);\r\n        _;\r\n        \r\n    }\r\n    \r\n    function admin_deposit(uint xEth) onlyAdmin{\r\n        \r\n        uint256 xwei = xEth * 10**18;\r\n        deposit_amount += xwei;\r\n        \r\n    }\r\n    \r\n    /**\t*\t管理員發放股息\t*\t每個會員股息依 \t*\t*/\r\n    function admin_dividend(uint xEth) onlyAdmin{\r\n        \r\n\t\tuint256 xwei = xEth * 10**18;\r\n\t\trequire(xwei <= (deposit_amount-dividend_amount) ); \r\n\r\n\t\tdividend_amount += xwei;\r\n        uint256 len = memberArray.length;\t\r\n        uint i = 0;\r\n        address _member;\r\n        \r\n\t\tuint total_balance_dividened=0;\r\n        for( i = 0; i < len; i++){            \r\n            _member = memberArray[i];\r\n\t\t\tif(members[_member].isDividend){\r\n\t\t\t\ttotal_balance_dividened = balances[_member]; \r\n\t\t\t}            \r\n        }\r\n\t\tuint256 perTokenWei = xwei / (total_balance_dividened / 10 ** 6);\r\n            \r\n        for( i = 0; i < len; i++){            \r\n            _member = memberArray[i];\r\n\t\t\tif(members[_member].isDividend){\r\n\t\t\t\tuint256 thisWei = (balances[_member] / 10 ** 6) * perTokenWei;\r\n\t\t\t\tmembers[_member].dividend += thisWei; \r\n\t\t\t\ttotal_devidend += thisWei;\r\n\t\t\t}            \r\n        }\r\n    \r\n    }\r\n    \r\n    function set_exchange_rate(uint[] exchangeRates) onlyAdmin{\r\n         \r\n        uint len = exchangeRates.length;\r\n        exchangeRateArray.length = 0;\r\n        \r\n        for(uint i = 0; i < len; i += 3){\r\n            \r\n            uint time1 = exchangeRates[i];\r\n            uint time2 = exchangeRates[i + 1];\r\n            uint value = exchangeRates[i + 2]*1000;\r\n            exchangeRateArray.push(exchangeRate(time1, time2, value));      \r\n            \r\n        }\r\n        \r\n    }\r\n\r\n\tfunction get_exchange_wei() returns(uint256){\r\n\r\n        \r\n\t\tuint len = exchangeRateArray.length;  \r\n\t\tuint nowTime = block.timestamp;\r\n        for(uint i = 0; i < len; i += 3){\r\n            \r\n\t\t\texchangeRate memory rate = exchangeRateArray[i];\r\n            uint time1 = rate.time1;\r\n            uint time2 = rate.time2;\r\n            uint value = rate.value;\r\n\t\t\tif (nowTime>= time1 && nowTime<=time2) {\r\n\t\t\t\ttokenExchangeRateInWei = value;\r\n\t\t\t\treturn value;\r\n\t\t\t}\r\n            \r\n        }\r\n\t\treturn tokenExchangeRateInWei;\r\n\t}\r\n    \r\n    function get_admin_list() constant onlyAdmin returns(address[]){\r\n        \r\n        return adminArray;\r\n        \r\n    }\r\n    \r\n    function add_admin(address admin) onlyAdmin adminDoesNotExist(admin){\r\n        \r\n        adminArray.push(admin);\r\n        \r\n    }\r\n    \r\n    function del_admin(address admin) onlyAdmin adminExists(admin){\r\n        \r\n        for (uint i = 0; i < adminArray.length - 1; i++)\r\n            if (adminArray[i] == admin) {\r\n                adminArray[i] = adminArray[adminArray.length - 1];\r\n                break;\r\n            }\r\n            \r\n        adminArray.length -= 1;\r\n        \r\n    }\r\n    \r\n    function set_deposit_address(address addr) onlyAdmin{\r\n        \r\n        deposit_address = addr;\r\n        \r\n    }\r\n    \r\n    function set_exchange_rate_in_eth(uint256 _exchangeRateInEth) onlyAdmin {\r\n        \r\n        require(_exchangeRateInEth > 0);\r\n        tokenExchangeRateInWei = _exchangeRateInEth * 10**6;\r\n        \r\n    }\r\n    \r\n    function active_payable() onlyAdmin{\r\n    \r\n        isPayable = true;\r\n        \r\n    }\r\n    \r\n    function inactive_payable() onlyAdmin{\r\n        \r\n        isPayable = false;\r\n        \r\n    }\r\n    \r\n    function active_withdrawable() onlyAdmin{\r\n        \r\n        isWithdrawable = true;\r\n        \r\n    }\r\n    \r\n    function inactive_withdrawable() onlyAdmin{\r\n        \r\n        isWithdrawable = false;\r\n        \r\n    }\r\n    \r\n    function active_dividend(address _member) onlyAdmin memberExists(_member){\r\n        \r\n        members[_member].isDividend = true;\r\n        \r\n    }\r\n    \r\n    function inactive_dividend(address _member) onlyAdmin memberExists(_member){\r\n        \r\n        members[_member].isDividend = false;\r\n        \r\n    }\r\n    \r\n    function active_withdraw(address _member) onlyAdmin memberExists(_member){\r\n        \r\n        members[_member].isWithdraw = true;\r\n        \r\n    }\r\n    \r\n    function inactive_withdraw(address _member) onlyAdmin memberExists(_member){\r\n        \r\n        members[_member].isWithdraw = false;\r\n        \r\n    }\r\n    \r\n    function get_total_info() onlyAdmin returns(uint256[]){\r\n\r\n        uint256 total_remain = total_devidend - total_withdraw;\r\n        uint256[] memory info = new uint256[](6);\r\n        info[0] = deposit_amount;\r\n        info[1] = total_devidend;\r\n        info[2] = total_remain;\r\n        info[3] = total_withdraw;\r\n        \r\n        return info;\r\n        \r\n    }\r\n    \r\n    function get_member_info(address _member) onlyAdmin memberExists(_member) returns(uint256[]){\r\n        \r\n        return get_info(_member);\r\n        \r\n    }\r\n    \r\n    function get_my_info() returns(uint256[]){\r\n        \r\n        return get_info(msg.sender);\r\n        \r\n    }\r\n    \r\n    function get_info(address _member) private returns (uint256[]){\r\n        \r\n        uint256 _devidend = members[_member].dividend;\r\n        uint256 _withdraw = members[_member].withdraw;\r\n        uint256 _remain = _devidend - _withdraw;\r\n        uint256 _balance = balances[_member];\r\n        \r\n        uint256[] memory _info = new uint256[](4);\r\n        _info[0] = _balance;\r\n        _info[1] = _devidend;\r\n        _info[2] = _remain;\r\n        _info[3] = _withdraw;\r\n        \r\n        return _info;\r\n        \r\n    }\r\n    \r\n    function withdraw() isMember {\r\n        \r\n        uint256 _remain = members[msg.sender].dividend - members[msg.sender].withdraw;\r\n        require(_remain > 0);\r\n        require(isWithdrawable);\r\n        require(members[msg.sender].isWithdraw);\r\n        msg.sender.transfer(_remain);\r\n        members[msg.sender].withdraw += _remain; \r\n        total_withdraw += _remain;          \r\n\r\n    }\r\n\r\n    function withdraw_admin(uint xEth) onlyDeposit{\r\n\r\n        uint256 _withdraw = xEth * 10**18;\r\n\t\trequire( msg.sender == deposit_address );\r\n\r\n\t\trequire(this.balance > _withdraw);\r\n\t\tmsg.sender.transfer(_withdraw);\r\n\r\n        withdraw_amount += _withdraw;  \r\n        \r\n    }\r\n    \r\n    function withdraw_all_admin(address _deposit) onlyAdmin {\r\n        \r\n\t\trequire( _deposit == deposit_address ); \r\n\r\n\t\t_deposit.transfer(this.balance);\r\n\r\n\t\ttotal_devidend = 0; //member\r\n\t\ttotal_withdraw = 0; //member\r\n\t\tdeposit_amount = 0;  //deposit\r\n\t\twithdraw_amount = 0; //deposit\r\n\t\tdividend_amount = 0; //admin   \r\n        \r\n    }\r\n \r\n\t \r\n\tfunction transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32)     {\r\n\t\trequire(_to != deposit_address);\r\n        require(isPayable);\r\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\r\n\t\tbalances[_to] = balances[_to].add(_value);\r\n\r\n\t\tif (members[_to].isExists != true) {\t\t\r\n\t\t\tmembers[_to].isExists = true;\r\n\t\t\tmembers[_to].isDividend = true;\r\n\t\t\tmembers[_to].isWithdraw = true; \r\n\t\t\tmemberArray.push(_to);\t\t\r\n\t\t}  \r\n\r\n\t\tTransfer(msg.sender, _to, _value);\r\n\t}\r\n \r\n\tfunction transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32)     {\r\n\t\trequire(_to != deposit_address);\r\n\t\trequire(_from != deposit_address);\r\n        require(isPayable);\r\n\t\tvar _allowance = allowed[_from][msg.sender]; \r\n\t\trequire(_allowance >= _value);\r\n\r\n\t\tbalances[_to] = balances[_to].add(_value);\r\n\t\tbalances[_from] = balances[_from].sub(_value);\r\n\t\tallowed[_from][msg.sender] = _allowance.sub(_value);\r\n\t\t\r\n\t\tif (members[_to].isExists != true) {\t\t\r\n\t\t\tmembers[_to].isExists = true;\r\n\t\t\tmembers[_to].isDividend = true;\r\n\t\t\tmembers[_to].isWithdraw = true; \r\n\t\t\tmemberArray.push(_to);\t\t\r\n\t\t}  \r\n\r\n\t\tTransfer(_from, _to, _value);\r\n\t}\r\n\r\n    \r\n    function () payable {\r\n        \r\n        pay();\r\n        \r\n    }\r\n  \r\n    function pay() public payable returns (bool) {\r\n        \r\n      \r\n        require(msg.value > 0);\r\n        require(isPayable);\r\n        \r\n        /*\r\n        uint256 amount = msg.value;\r\n        uint256 refund = amount % tokenExchangeRateInWei;\r\n        uint256 tokens = (amount - refund) / tokenExchangeRateInWei;\r\n        balances[msg.sender] = balances[msg.sender].add(tokens);*/\r\n        \r\n        if(msg.sender == deposit_address){\r\n             deposit_amount += msg.value;\r\n        }else{\r\n        \r\n    \t\tuint256 exchangeWei = get_exchange_wei();\r\n    \t\tuint256 thisTokenWei =  exchangeWei * msg.value / 10**18 ;\r\n        \r\n            if (members[msg.sender].isExists != true) {\r\n                \r\n                members[msg.sender].isExists = true;\r\n                members[msg.sender].isDividend = true;\r\n                members[msg.sender].isWithdraw = true; \r\n                memberArray.push(msg.sender);\r\n                \r\n            }  \r\n    \t\tbalances[msg.sender] += thisTokenWei;\r\n    \t\ttotal_tokenwei += thisTokenWei;\r\n\t\t\r\n        }\r\n        \r\n        return true;\r\n    \r\n    }\r\n  \r\n    function get_balance(address a) public returns(uint256){\r\n      \r\n        return balances[a];\r\n      \r\n    }\r\n        \r\n    function get_balance() public returns(uint256){\r\n      \r\n        return balances[msg.sender];\r\n      \r\n    }\r\n            \r\n    function get_this_balance() public returns(uint256){\r\n      \r\n        return this.balance;\r\n      \r\n    }\r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_exchangeRateInEth\",\"type\":\"uint256\"}],\"name\":\"set_exchange_rate_in_eth\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"get_admin_list\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"add_admin\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pay\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"address\"}],\"name\":\"get_balance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"get_my_info\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_deposit\",\"type\":\"address\"}],\"name\":\"withdraw_all_admin\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"active_dividend\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"inactive_payable\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"get_total_info\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"get_exchange_wei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"inactive_withdraw\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isWithdrawable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"exchangeRates\",\"type\":\"uint256[]\"}],\"name\":\"set_exchange_rate\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"xEth\",\"type\":\"uint256\"}],\"name\":\"admin_deposit\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"inactive_withdrawable\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"xEth\",\"type\":\"uint256\"}],\"name\":\"withdraw_admin\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"del_admin\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"set_deposit_address\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"get_this_balance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"get_member_info\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"get_balance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"active_withdrawable\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPayable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"active_withdraw\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"xEth\",\"type\":\"uint256\"}],\"name\":\"admin_dividend\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"inactive_dividend\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"active_payable\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"Pixiu_Beta","CompilerVersion":"v0.4.13+commit.fb4cb1a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://8a017a13368b05dc9ce7d92c5931428ab31361f87507a286b456dd8593788a6c"}]}