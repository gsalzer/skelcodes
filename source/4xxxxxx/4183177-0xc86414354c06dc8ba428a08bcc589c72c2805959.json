{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.2;\r\n\r\ncontract owned \r\n{\r\n\taddress public owner;\r\n\r\n\tfunction owned() \r\n\t{\r\n\t\towner = msg.sender;\r\n\t}\r\n\r\n\tmodifier onlyOwner \r\n\t{\r\n\t\trequire(msg.sender == owner);\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction transferOwnership(address newOwner) onlyOwner \r\n\t{\r\n\t\towner = newOwner;\r\n\t}\r\n}\r\n\r\ncontract tokenRecipient \r\n{ \r\n\tfunction receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); \r\n}\r\n\r\nlibrary MathFunction \r\n{\r\n    // standard uint256 functions\r\n\r\n    function plus(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        assert((z = x + y) >= x);\r\n    }\r\n\r\n    function minus(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        assert((z = x - y) <= x);\r\n    }\r\n\r\n    function multiply(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        z = x * y;\r\n        assert(x == 0 || z / x == y);\r\n    }\r\n\r\n    function divide(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        z = x / y;\r\n    }\r\n    \r\n    // uint256 function\r\n\r\n    function hplus(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        assert((z = x + y) >= x);\r\n    }\r\n\r\n    function hminus(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        assert((z = x - y) <= x);\r\n    }\r\n\r\n    function hmultiply(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        z = x * y;\r\n        assert(x == 0 || z / x == y);\r\n    }\r\n\r\n    function hdivide(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        z = x / y;\r\n    }\r\n\r\n    // BIG math\r\n\r\n    uint256 constant BIG = 10 ** 18;\r\n\r\n    function wplus(uint256 x, uint256 y) constant internal returns (uint256) {\r\n        return hplus(x, y);\r\n    }\r\n\r\n    function wminus(uint256 x, uint256 y) constant internal returns (uint256) {\r\n        return hminus(x, y);\r\n    }\r\n\r\n    function wmultiply(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        z = cast((uint256(x) * y + BIG / 2) / BIG);\r\n    }\r\n\r\n    function wdivide(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        z = cast((uint256(x) * BIG + y / 2) / y);\r\n    }\r\n\r\n    function cast(uint256 x) constant internal returns (uint256 z) {\r\n        assert((z = uint256(x)) == x);\r\n    }\r\n}\r\n\r\ncontract ERC20 \r\n{\r\n    function totalSupply() constant returns (uint _totalSupply);\r\n    function balanceOf(address _owner) constant returns (uint balance);\r\n    function transfer(address _to, uint _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool success);\r\n    function approve(address _spender, uint _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\ncontract token is owned, ERC20\r\n{\r\n\tusing MathFunction for uint256;\r\n\t\r\n\t// Public variables\r\n\tstring public name;\r\n\tstring public symbol;\r\n\tuint8 public decimals;\r\n\tuint256 public totalSupply;\r\n\t\r\n\tmapping (address => uint256) public contrubutedAmount;\r\n\tmapping (address => uint256) public balanceOf;\t\t\t\t\t\t\t\t\t\t\t\t\t// This creates an array with all balances\r\n\tmapping (address => mapping (address => uint256)) public allowance;\t\t\t\t\t\t\t\t// Creates an array with allowed amount of tokens for sender\r\n\t\r\n\tmodifier onlyContributer\r\n\t{\r\n\t\trequire(balanceOf[msg.sender] > 0);\r\n\t\t_;\r\n\t}\r\n\t\r\n\t// Initializes contract with name, symbol, decimal and total supply\r\n\tfunction token() \r\n\t{\t\t\r\n\t\ttotalSupply = 166000;  \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Update total supply\r\n\t\ttotalSupply = totalSupply.multiply(10 ** 18);\r\n\t\tbalanceOf[msg.sender] = totalSupply;              \t\t\t\t\t\t\t\t\t\t\t// Give the creator all initial tokens\r\n\t\tname = \"Global Academy Place\";               \t\t\t\t\t\t\t\t\t\t// Set the name for display purposes\r\n\t\tsymbol = \"GAP\";                                \t\t\t\t\t\t\t\t\t\t\t// Set the symbol for display purposes\r\n\t\tdecimals = 18;                            \t\t\t\t\t\t\t\t\t\t\t\t\t// Amount of decimals for display purposes\r\n\t}\r\n\t\r\n\tfunction balanceOf(address _owner) constant returns (uint256 balance) \r\n\t{\r\n\t\treturn balanceOf[_owner];\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Get the balance\r\n\t}\r\n\t\r\n\tfunction totalSupply() constant returns (uint256 _totalSupply)\r\n\t{\r\n\t    return totalSupply;\r\n\t}\r\n  \r\n\tfunction transfer(address _to, uint256 _value) returns (bool success) \r\n\t{\r\n\t\trequire(balanceOf[msg.sender] >= _value);\t\t\t\t\t\t\t\t\t\t\t\t\t// Check if the sender has enough    \r\n\t\trequire(balanceOf[_to] <= balanceOf[_to].plus(_value));\t\t\t\t\t\t\t\t\t\t// Check for overflows\r\n\t\t\t\t\t\t\t\t\r\n\t\tbalanceOf[msg.sender] = balanceOf[msg.sender].minus(_value);                     \t\t\t// Subtract from the sender\r\n\t\tbalanceOf[_to] = balanceOf[_to].plus(_value);                            \t\t\t\t\t// Add the same to the recipient\r\n\t\t\r\n\t\tTransfer(msg.sender, _to, _value);                   \t\t\t\t\t\t\t\t\t\t// Notify anyone listening that this transfer took place\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\t// A contract attempts to get the coins\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success)\t\t\t\r\n\t{\r\n\t\trequire(_value <= balanceOf[_from]);\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Check if the sender has enough\r\n\t\trequire(balanceOf[_to] <= balanceOf[_to].plus(_value));\t\t\t\t\t\t\t\t\t\t// Check for overflows\r\n\t\trequire(_value <= allowance[_from][msg.sender]);\t\t\t\t\t\t\t\t\t\t\t// Check allowance\r\n  \t\t\t\t\t\t\t\t\t\r\n\t\tbalanceOf[_from] = balanceOf[_from].minus(_value);                          \t\t\t\t// Subtract from the sender\r\n\t\tbalanceOf[_to] = balanceOf[_to].plus(_value);                            \t\t\t\t\t// Add the same to the recipient\r\n\t\tallowance[_from][msg.sender] = allowance[_from][msg.sender].minus(_value);\t\t\t\t\t// Decrease the allowence of sender\r\n\t\t\r\n\t\tTransfer(_from, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// Allow another contract to spend some tokens in your behalf \r\n\tfunction approve(address _spender, uint256 _value)\treturns (bool success) \t\t\t\t\t\t\r\n\t{\r\n\t\trequire((_value == 0) || (allowance[msg.sender][_spender] == 0));\r\n\t\t\r\n\t\tallowance[msg.sender][_spender] = _value;\r\n\t\tApproval(msg.sender, _spender, _value);\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\t// Approve and then communicate the approved contract in a single tx\r\n\tfunction approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) \r\n\t{    \r\n\t\ttokenRecipient spender = tokenRecipient(_spender);\r\n\t\tif (approve(_spender, _value)) \r\n\t\t{\r\n\t\t\tspender.receiveApproval(msg.sender, _value, this, _extraData);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\t\r\n\t\r\n\t// Function to check the amount of tokens that an owner allowed to a spender\r\n\tfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) \r\n\t{\r\n\t\treturn allowance[_owner][_spender];\r\n\t}\r\n}\r\n\r\ncontract ICOToken is token\r\n{\r\n\t// Public variables\r\n\tstring public firstLevelPrice = \"Token 0.0100 ETH per Token\";\r\n\tstring public secondLevelPrice = \"Token 0.0125 ETH per Token\";\r\n\tstring public thirdLevelPrice = \"Token 0.0166 ETH per Token\";\r\n\tstring public CapLevelPrice = \"Token 0.0250 ETH per Token\";\r\n\tuint256 public _firstLevelEth;\r\n\tuint256 public _secondLevelEth;\r\n\tuint256 public _thirdLevelEth;\r\n\tuint256 public _capLevelEth;\r\n\tuint256 public buyPrice;\r\n\tuint256 public fundingGoal;\r\n\tuint256 public amountRaisedEth; \r\n\tuint256 public deadline;\r\n\tuint256 public maximumBuyBackPriceInCents;\r\n\tuint256 public maximumBuyBackAmountInCents;\r\n\tuint256 public maximumBuyBackAmountInWEI;\r\n\taddress public beneficiary;\t\r\n\t\r\n\tmapping (address => uint256) public KilledTokens;\t\t\t\t\t\t\t\t\t\t\t\t// This creates an array with all killed tokens\r\n\t\r\n\t// Private variables\r\n\tuint256 _currentLevelEth;\r\n\tuint256 _currentLevelPrice;\r\n\tuint256 _nextLevelEth;\r\n\tuint256 _nextLevelPrice;\r\n\tuint256 _firstLevelPrice;\r\n\tuint256 _secondLevelPrice;\r\n\tuint256 _thirdLevelPrice;\r\n\tuint256 _capLevelPrice;\r\n\tuint256 _currentSupply;\r\n\tuint256 remainig;\r\n\tuint256 amount;\r\n\tuint256 TokensAmount;\r\n\tbool fundingGoalReached;\r\n\tbool crowdsaleClosed;\r\n\r\n\tevent GoalReached(address _beneficiary, uint amountRaised);\r\n\t\r\n\tmodifier afterDeadline() \r\n\t{\r\n\t\trequire(crowdsaleClosed);\r\n\t\t_;\r\n\t}\r\n\t \r\n\t// Initializes contract \r\n\t\r\n\tfunction ICOToken() token() \r\n\t{          \r\n\t\tbalanceOf[msg.sender] = totalSupply;              \t\t\t\t\t\t\t\t\t\t\t// Give the creator all initial tokens\r\n\t\t\r\n\t\tbeneficiary = owner;\r\n\t\tfundingGoal = 1600 ether;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Funding Goal in Eth\r\n\t\tdeadline = 1506549600;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 54 720 minutes = 38 days\r\n\t\t\r\n\t\tfundingGoalReached = false;\r\n\t\tcrowdsaleClosed = false;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t_firstLevelEth = 600 ether;\t\t\t\t\t\t\t\t\t\t\r\n\t\t_firstLevelPrice = 10000000000000000;\t\t\t\t\t\t\t\t\t\t\r\n\t\t_secondLevelEth = 1100 ether;\t\t\t\t\t\t\t\t\t\t\r\n\t\t_secondLevelPrice = 12500000000000000;\t\t\t\t\t\t\t\t\t\t\r\n\t\t_thirdLevelEth = 1600 ether;\t\t\t\t\t\t\t\t\t\t\r\n\t\t_thirdLevelPrice = 16666666666666666;\t\t\t\t\t\t\t\t\t\t\r\n\t\t_capLevelEth = 2501 ether;\t\t\t\t\t\t\t\t\t\t\r\n\t\t_capLevelPrice = 25000000000000000;\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t_currentLevelEth = _firstLevelEth;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// In the beggining the current level is first level\r\n\t\t_currentLevelPrice = _firstLevelPrice;\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Next level is the second one \r\n\t\t_nextLevelEth = _secondLevelEth;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t_nextLevelPrice = _secondLevelPrice;\t\t\t\t\t\t\t\t\t\t\r\n\t\t\r\n\t\tamountRaisedEth = 0;\r\n\t\tmaximumBuyBackAmountInWEI = 50000000000000000;\r\n\t}\r\n\t\r\n\t// Changes the level price when the current one is reached\r\n\t// Makes the current to be next \r\n\t// And next to be the following one\r\n\tfunction levelChanger() internal\t\t\t\t\t\t\r\n\t{\r\n\t\tif(_nextLevelPrice == _secondLevelPrice)\r\n\t\t{\r\n\t\t\t_currentLevelEth = _secondLevelEth;\r\n\t\t\t_currentLevelPrice = _secondLevelPrice;\r\n\t\t\t_nextLevelEth = _thirdLevelEth;\r\n\t\t\t_nextLevelPrice = _thirdLevelPrice;\r\n\t\t}\r\n\t\telse if(_nextLevelPrice == _thirdLevelPrice)\r\n\t\t{\r\n\t\t\t_currentLevelEth = _thirdLevelEth;\r\n\t\t\t_currentLevelPrice = _thirdLevelPrice;\r\n\t\t\t_nextLevelEth = _capLevelEth;\r\n\t\t\t_nextLevelPrice = _capLevelPrice;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t_currentLevelEth = _capLevelEth;\r\n\t\t\t_currentLevelPrice = _capLevelPrice;\r\n\t\t\t_nextLevelEth = _capLevelEth;\r\n\t\t\t_nextLevelPrice = _capLevelPrice;\r\n\t\t}\r\n\t}\r\n\t\r\n\t// Check if the tokens amount is bigger than total supply\r\n\tfunction safeCheck (uint256 _TokensAmount) internal\r\n\t{\r\n\t\trequire(_TokensAmount <= totalSupply);\r\n\t}\r\n\t\r\n\t// Calculates the tokens amount\r\n\tfunction tokensAmount() internal returns (uint256 _tokensAmount) \t\t\t\r\n\t{   \r\n\t\tamountRaisedEth = amountRaisedEth.wplus(amount);\r\n\t\tuint256 raisedForNextLevel = amountRaisedEth.wminus(_currentLevelEth);\r\n\t\tremainig = amount.minus(raisedForNextLevel);\r\n\t\tTokensAmount = (raisedForNextLevel.wdivide(_nextLevelPrice)).wplus(remainig.wdivide(_currentLevelPrice));\r\n\t\tbuyPrice = _nextLevelPrice;\r\n\t\tlevelChanger();\t\t\t\r\n\t\t\r\n\t\treturn TokensAmount;\r\n\t}\r\n\t\r\n\tfunction manualBuyPrice (uint256 _NewPrice) onlyOwner\r\n\t{\r\n\t\t_currentLevelPrice = _NewPrice;\r\n\t\tbuyPrice = _currentLevelPrice;\r\n\t}\r\n\t\r\n\t// The function without name is the default function that is called whenever anyone sends funds to a contract\r\n\tfunction buyTokens () payable         \t\t\t\t\t\t\t\t\r\n\t{\r\n\t\tassert(!crowdsaleClosed);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Checks if the crowdsale is closed\r\n\t\r\n\t\tamount = msg.value;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Amount in ether\r\n\t\tassert(amountRaisedEth.plus(amount) <= _nextLevelEth);\t\t\t\t\t\t\t\t\t\t// Check if you are going to jump over one level (e.g. from first to third - not allowed)\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\r\n\t\tif(amountRaisedEth.plus(amount) > _currentLevelEth)\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t{\t\t\t\t\t\t\t\t\r\n\t\t\tTokensAmount = tokensAmount();\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// The current level is passed and calculate new buy price and change level\r\n\t\t\tsafeCheck(TokensAmount);\t\t\t\t\t\t\r\n\t\t}\t\t\t\t\t\t\r\n\t\telse\t\t\t\t\t\t\r\n\t\t{\t\t\t\t\t\t\r\n\t\t\tbuyPrice = _currentLevelPrice;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Use the current level buy price\r\n\t\t\tTokensAmount = amount.wdivide(buyPrice);\r\n\t\t\tsafeCheck(TokensAmount);\t\t\t\t\t\t\r\n\t\t\tamountRaisedEth = amountRaisedEth.plus(amount);\t\t\t\t\t\t\r\n\t\t}\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\r\n\t\t_currentSupply = _currentSupply.plus(TokensAmount);\r\n\t\tcontrubutedAmount[msg.sender] = contrubutedAmount[msg.sender].plus(msg.value);\t\t\r\n\t\tbalanceOf[this] = balanceOf[this].minus(TokensAmount);\t\t\t\t\t\t\r\n\t\tbalanceOf[msg.sender] = balanceOf[msg.sender].plus(TokensAmount);                   \t\t// Adds tokens amount to buyer's balance\r\n\t\tTransfer(this, msg.sender, TokensAmount);                \t\t\t\t\t\t\t\t\t// Execute an event reflecting the change\t\t\t\t\t\r\n\t\treturn;                                     \t            \t\t\t\t\t\t\t\t// Ends function and returns\r\n\t}\t\t\t\t\t\t\r\n\tfunction () payable   \r\n\t{\r\n\t\tbuyTokens();\r\n\t}\r\n\t// Checks if the goal or time limit has been reached and ends the campaign \r\n\tfunction CloseCrowdSale(uint256 _maximumBuyBackAmountInCents) internal \t\t\t\t\t\t\t\t\r\n\t{\r\n\t\tif (amountRaisedEth >= fundingGoal)\r\n\t\t{\r\n\t\t\tfundingGoalReached = true;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Checks if the funding goal is reached\r\n\t\t\tGoalReached(beneficiary, amountRaisedEth);\r\n\t\t}\r\n\t\tcrowdsaleClosed = true;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Close the crowdsale\r\n\t\tmaximumBuyBackPriceInCents = _maximumBuyBackAmountInCents;            \t\t\t\t\t\t// Calculates the maximum buy back price\r\n\t\ttotalSupply = _currentSupply;\r\n\t\tbalanceOf[this] = 0;\r\n\t\tmaximumBuyBackAmountInCents = maximumBuyBackPriceInCents.multiply(totalSupply);\t\t\t\t// Calculates the max buy back amount in cents\r\n\t\tmaximumBuyBackAmountInWEI = maximumBuyBackAmountInWEI.multiply(totalSupply);\r\n\t}\r\n}\r\n\r\ncontract GAP is ICOToken\r\n{\t\r\n\t// Public variables\r\n\tstring public maximumBuyBack = \"Token 0.05 ETH per Token\";\t\t\t\t\t\t\t\t\t\t// Max price in ETH for buy back\r\n\tuint256 public KilledTillNow;\r\n\tuint256 public sellPrice;\r\n\tuint256 public mustToSellCourses;\r\n\tuint public depositsTillNow;\r\n\tuint public actualPriceInCents;\r\n\taddress public Killer;\t\r\n\t\r\n\tevent FundTransfer(address backer, uint amount, bool isContribution);\r\n\t\r\n\tfunction GAP() ICOToken()\r\n\t{\r\n\t\tKiller = 0;\r\n\t\tKilledTillNow = 0;\r\n\t\tsellPrice = 0;\r\n\t\tmustToSellCourses = 0;\r\n\t\tdepositsTillNow = 0;\r\n\t}\r\n\t\r\n\t// The contributers can check the actual price in wei before selling \r\n\tfunction checkActualPrice() returns (uint256 _sellPrice)\r\n\t{\r\n\t\treturn sellPrice;\r\n\t}\r\n\t\t\t\t\r\n\t// End the crowdsale and start buying back\t\t\t\r\n\t// Only owner can execute this function\t\t\t\r\n\tfunction BuyBackStart(uint256 actualSellPriceInWei, uint256 _mustToSellCourses, uint256 maxBuyBackPriceCents) onlyOwner\t\t\t\r\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\tCloseCrowdSale(maxBuyBackPriceCents);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\tsellPrice = actualSellPriceInWei;\r\n\t\tmustToSellCourses = _mustToSellCourses;\r\n\t}\t\t\t\r\n\t\r\n\tfunction deposit (uint _deposits, uint256 actualSellPriceInWei, uint _actualPriceInCents) onlyOwner payable\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t{\r\n\t\tassert(_deposits < 100);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Check if the deposits are less than 10\t\r\n\t\tdepositsTillNow = depositsTillNow.plus(_deposits);          \t\t\t\t\t\t\t\t// Increase the deposit counter\r\n\t\tassert(mustToSellCourses > 0);\r\n\t\tif(mustToSellCourses < _deposits)\r\n\t\t{\r\n\t\t\t_deposits = mustToSellCourses;\t\t\r\n\t\t}\r\n\t\tmustToSellCourses = mustToSellCourses.minus(_deposits);\t\t\t\t\t\t\t\t\t\t// Calculate the remaining amount of courses to sell\t\t\t\t\t\r\n\t\tsellPrice = actualSellPriceInWei;\r\n\t\tactualPriceInCents = _actualPriceInCents;\r\n\t}\t\r\n\t\t\t\t\r\n\tfunction sell(uint256 amount) onlyContributer returns (uint256 revenue)\t\t\t\r\n\t{\t\r\n\t    require(this.balance >= amount * sellPrice);                                                 // checks if the contract has enough ether to buy\r\n\t\trevenue = amount.multiply(sellPrice);\t\t\t\t\t\t\t\t\t\t\t\t\t\t// The revenue you receive when you sell your tokens\r\n\t\tamount = amount.multiply(10 ** 18);\r\n\t\tbalanceOf[msg.sender] = balanceOf[msg.sender].minus(amount);                   \t\t\t\t// Subtracts the amount from seller's balance\r\n\t\tbalanceOf[Killer] = balanceOf[Killer].plus(amount);                         \t\t\t\t// Adds the amount to owner's balance\r\n\t\tKilledTokens[msg.sender] = KilledTokens[msg.sender].plus(amount);\t\t\t\t\t\t\t// Calculates the killed tokens of the contibuter\r\n\t\tKilledTillNow = KilledTillNow.plus(amount);\t\t\t\t\t\t\t\t\t\t\t\t\t// Calculates all the killed tokens until now\r\n\t\t\t\r\n\t\tmsg.sender.transfer(revenue);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Sends ether to the seller: it's important // To do this last to prevent recursion attacks\r\n\t\t\r\n\t\tTransfer(msg.sender, Killer, amount);             \t\t\t\t\t\t\t\t\t\t\t// Executes an event reflecting on the change\r\n\t\treturn revenue;                                 \t\t\t\t\t\t\t\t\t\t\t// Ends function and returns the revenue\t\r\n\t}\r\n\t\r\n\tfunction ownerWithdrawal(uint256 amountInWei, address _to) onlyOwner\r\n\t{\t\t\t\t\t\t\r\n\t\tuint256 _value = amountInWei;\t\t\t\t\t\t\r\n\t\t_to.transfer(_value);\t\t\t\t\t\t\r\n\t}\r\n\t\r\n\tfunction safeWithdrawal() afterDeadline \t\t\t\r\n\t{\t\t\t\r\n\t\tif (!fundingGoalReached) \t\t\t\r\n\t\t{\t\t\t\r\n\t\t\tuint256 tokensAmount = balanceOf[msg.sender];\r\n\t\t\tuint256 amountForReturn = contrubutedAmount[msg.sender];\r\n\t\t\tbalanceOf[msg.sender] = 0;\r\n\t\t\tKilledTillNow = KilledTillNow.plus(tokensAmount);\r\n\t\t\tKilledTokens[msg.sender] = KilledTokens[msg.sender].plus(tokensAmount);\r\n\t\t\trequire(tokensAmount > 0);\r\n\t\t\tcontrubutedAmount[msg.sender] = contrubutedAmount[msg.sender].minus(amountForReturn);\r\n            msg.sender.transfer(amountForReturn);\r\n\t\t}\r\n\t\t\r\n\t\tif(fundingGoalReached && beneficiary == msg.sender)\r\n\t\t{\r\n\t\t\trequire(fundingGoalReached && beneficiary == msg.sender);\r\n\t\t\tbeneficiary.transfer(amountRaisedEth); \r\n\t\t}\r\n\t}\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_deposits\",\"type\":\"uint256\"},{\"name\":\"actualSellPriceInWei\",\"type\":\"uint256\"},{\"name\":\"_actualPriceInCents\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maximumBuyBackPriceInCents\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secondLevelPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Killer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"_totalSupply\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deadline\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"depositsTillNow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"checkActualPrice\",\"outputs\":[{\"name\":\"_sellPrice\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_thirdLevelEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amountRaisedEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maximumBuyBackAmountInWEI\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"actualPriceInCents\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maximumBuyBack\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"thirdLevelPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingGoal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_secondLevelEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_NewPrice\",\"type\":\"uint256\"}],\"name\":\"manualBuyPrice\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"contrubutedAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_firstLevelEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maximumBuyBackAmountInCents\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amountInWei\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"ownerWithdrawal\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"KilledTillNow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CapLevelPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"actualSellPriceInWei\",\"type\":\"uint256\"},{\"name\":\"_mustToSellCourses\",\"type\":\"uint256\"},{\"name\":\"maxBuyBackPriceCents\",\"type\":\"uint256\"}],\"name\":\"BuyBackStart\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[{\"name\":\"revenue\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstLevelPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mustToSellCourses\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_capLevelEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"safeWithdrawal\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"KilledTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"backer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"isContribution\",\"type\":\"bool\"}],\"name\":\"FundTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountRaised\",\"type\":\"uint256\"}],\"name\":\"GoalReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"GAP","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://e180d4d42a72ce2b5070040c44adc7da48bbe048e86c8e2dea2918519974fbc0"}]}