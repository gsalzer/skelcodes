{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.17;\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////////\r\n//                                           pyramide type game                                                  //\r\n//                  0xc8d40dd5f0967d7de1e65f358c5c7f546b1c09ec                       //\r\n//                        https://godstep.ru/ethereum/Circleramide                             //\r\n///////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nlibrary SafeMath {\r\n      function mul(uint a, uint b) internal returns (uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n      }\r\n      function div(uint a, uint b) internal returns (uint) {\r\n        assert(b > 0);\r\n        uint c = a / b;\r\n        assert(a == b * c + a % b);\r\n        return c;\r\n      }\r\n      function sub(uint a, uint b) internal returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n      }\r\n      function add(uint a, uint b) internal returns (uint) {\r\n        uint c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n      }\r\n      function assert(bool assertion) internal {\r\n        if (!assertion) {\r\n          throw;\r\n        }\r\n      }\r\n    }\r\n\r\n\r\ncontract Circleramide {\r\n    using SafeMath for uint;\r\n    \r\n    // events\r\n    event SendMessage(uint id, string message, address sender);\r\n    event NewBlock(uint id);\r\n    event Reward(uint blockID, address player, uint reward);\r\n    event Withdraw(address player);\r\n    \r\n     modifier onlyOwner() {\r\n        require(msg.sender == owner); _;\r\n    }\r\n    \r\n    // contract owner \r\n    address owner;\r\n\r\n    uint public totalBlocks = 0;\r\n    uint public rewardBalance;\r\n\r\n \r\n    uint private constant FIRST_ROW_BLOCKS_COUNT = 128;\r\n    uint private constant MAXIMUM_ROWS_COUNT = FIRST_ROW_BLOCKS_COUNT - 1;\r\n    uint private constant FIRST_BLOCK_PRICE = .005 ether;\r\n\r\n\r\n    bool public isLive;\r\n\r\n    // jackpot \r\n    uint public rewardsCount;\r\n    \r\n    uint private constant REWARDED_BLOCK = 100;\r\n    uint private constant REWARDS_TOTAL = 49; // only 49 rewards (50 reward == 5000 block == jackpot);\r\n    uint private constant REWARD_DIV = 120; \r\n    \r\n    // jackpot \r\n    uint private constant REWARD_FEE_TOP = 70;\r\n    uint private constant REWARD_FEE_DIV = 100; // 70/100 = 70% goes to rewards;\r\n    \r\n    // comission = (2% of each block) = (70% goes of comission to REWARDS and 30% goes owner)\r\n    uint private constant FEE_TOP = 2;\r\n    uint private constant FEE_DIV = 100; // 100/2 = 0.2% fee\r\n    \r\n     // block price = bottomRowBlockPrice +  0.1% * bottomRowBlockPrice\r\n    uint private constant NEXT_ROW_PROPORTION_TOP = 25; // 25/100 = 25%\r\n    uint private constant NEXT_ROW_PROPORTION_DIV = 100;  \r\n \r\n    \r\n    struct Block {\r\n        uint x;\r\n        uint y;\r\n        string message;\r\n    }\r\n    \r\n    mapping(address => uint) public balances;\r\n    mapping (uint => mapping(uint => uint)) public blocksCoordinates;\r\n    mapping (uint => address) public blocksOwners;\r\n    mapping (uint => uint) public prices;\r\n    mapping (uint => address) public rewards_id;\r\n    mapping (uint => uint) public rewards_amount;\r\n    mapping (uint => Block) public blocks;\r\n    \r\n\r\n    function Circleramide() {\r\n        isLive = true;\r\n        owner = msg.sender;\r\n        prices[0] = FIRST_BLOCK_PRICE;\r\n        \r\n        totalBlocks = 1;\r\n        calculatePrice(0);\r\n        placeBlock(owner, 0, 0, 'First Block :)');\r\n        sendMessage('Welcome to the Circleramide!');\r\n    }\r\n\r\n    // public function\r\n    function setBlock(uint x, uint y, string message) external payable {\r\n        if(isLive) {\r\n            address sender = msg.sender;\r\n            \r\n            uint bet = calculatePrice(y);\r\n            uint senderBalance = balances[sender] + msg.value;\r\n            \r\n            require(bet <= senderBalance);\r\n            \r\n            if(checkBlockEmpty(x, y)) {\r\n                uint fee = (bet * FEE_TOP)/FEE_DIV;\r\n                uint jackpotFee = (fee * REWARD_FEE_TOP)/REWARD_FEE_DIV;\r\n                uint amountForOwner = fee - jackpotFee;\r\n                uint amountForBlock = bet - fee;\r\n                \r\n    \r\n                if(x < FIRST_ROW_BLOCKS_COUNT - y) {\r\n                   balances[owner] += amountForOwner;\r\n                   rewardBalance += jackpotFee;\r\n                   balances[sender] = senderBalance - bet;\r\n                   \r\n                   if(y == 0) {\r\n                        uint firstBlockReward = (amountForBlock * REWARD_FEE_TOP)/REWARD_FEE_DIV;\r\n                        rewardBalance += firstBlockReward;\r\n                        balances[owner] += amountForBlock - firstBlockReward; \r\n                        placeBlock(sender, x, y, message);\r\n                   } else {\r\n                        placeToRow(sender, x, y, message, amountForBlock);\r\n                   }\r\n                } else {\r\n                    throw;  // outside the blocks field\r\n                }\r\n            } else {\r\n                throw;  // block[x, y] is not empty\r\n            }\r\n        } else {\r\n            throw;  // game is over\r\n        }\r\n     }\r\n    \r\n\r\n    \r\n    // private funtions\r\n    function placeBlock(address sender, uint x, uint y, string message) private {\r\n        blocksCoordinates[y][x] = totalBlocks; \r\n     \r\n        blocks[totalBlocks] = Block(x, y, message);\r\n        blocksOwners[totalBlocks] = sender;\r\n\r\n        NewBlock(totalBlocks);\r\n    \r\n\r\n        // reward every 100 blocks\r\n        if(totalBlocks % REWARDED_BLOCK == 0) {\r\n            uint reward;\r\n            // block id == 5000 - JACKPOT!!!! GameOVER;\r\n            if(rewardsCount == REWARDS_TOTAL) {\r\n                isLive = false; // GAME IS OVER\r\n                rewardsCount++;\r\n                reward = rewardBalance; // JACKPOT!\r\n                rewardBalance = 0;\r\n            } else {\r\n                rewardsCount++;\r\n                reward = calculateReward();\r\n                rewardBalance = rewardBalance.sub(reward);\r\n            }\r\n            \r\n            balances[sender] += reward;\r\n            Reward(rewardsCount, sender, reward);\r\n            rewards_id[rewardsCount-1] = sender;\r\n            rewards_amount[rewardsCount-1] = reward;\r\n        }\r\n        totalBlocks++;\r\n    }\r\n    function placeToRow(address sender, uint x, uint y, string message, uint bet) private {\r\n       uint parentY = y - 1;\r\n                        \r\n       uint parent1_id = blocksCoordinates[parentY][x];\r\n       uint parent2_id = blocksCoordinates[parentY][x + 1];\r\n       \r\n       if(parent1_id != 0 && parent2_id != 0) {\r\n            address owner_of_block1 = blocksOwners[parent1_id];\r\n            address owner_of_block2 = blocksOwners[parent2_id];\r\n            \r\n            uint reward1 = bet/2;\r\n            uint reward2 = bet - reward1;\r\n            balances[owner_of_block1] += reward1;\r\n            balances[owner_of_block2] += reward2;\r\n            \r\n            placeBlock(sender, x, y, message);\r\n\r\n       } else {\r\n           throw;\r\n       }\r\n    }\r\n    \r\n    function calculatePrice(uint y) private returns (uint) {\r\n        uint nextY = y + 1;\r\n        uint currentPrice = prices[y];\r\n        if(prices[nextY] == 0) {\r\n            prices[nextY] = currentPrice + (currentPrice * NEXT_ROW_PROPORTION_TOP)/NEXT_ROW_PROPORTION_DIV;\r\n            return currentPrice;\r\n        } else {\r\n            return currentPrice;\r\n        }\r\n    }\r\n    function withdrawBalance(uint amount) external {\r\n        require(amount != 0);\r\n        \r\n        // The user must have enough balance to withdraw\r\n        require(balances[msg.sender] >= amount);\r\n        \r\n        // Subtract the withdrawn amount from the user's balance\r\n        balances[msg.sender] = balances[msg.sender].sub(amount);\r\n        \r\n        // Transfer the amount to the user's address\r\n        // If the transfer() call fails an exception will be thrown,\r\n        // and therefore the user's balance will be automatically restored\r\n        msg.sender.transfer(amount);\r\n        \r\n        Withdraw(msg.sender);\r\n    }\r\n    \r\n    \r\n    // constants\r\n    function calculateReward() public constant returns (uint) {\r\n        return (rewardBalance * rewardsCount) / REWARD_DIV;\r\n    }\r\n    function getBlockPrice(uint y)  constant returns (uint) {\r\n        return prices[y];\r\n    }\r\n    function checkBlockEmpty(uint x, uint y) constant returns (bool) {\r\n        return blocksCoordinates[y][x] == 0;\r\n    }\r\n    function Info() constant returns (uint tb, uint bc, uint fbp, uint rc, uint rb, uint rt, uint rf, uint rd, uint mc, uint rew) {\r\n        tb = totalBlocks;\r\n        bc = FIRST_ROW_BLOCKS_COUNT;\r\n        fbp = FIRST_BLOCK_PRICE;\r\n        rc = rewardsCount;\r\n        rb = rewardBalance;\r\n        rt = REWARDS_TOTAL;\r\n        rf = REWARD_FEE_TOP;\r\n        rd = REWARD_DIV;\r\n        mc = messagesCount;\r\n        rew = REWARDED_BLOCK;\r\n    }\r\n    function getBlock(uint id) public constant returns (uint i, uint x, uint y, address owmer, string message) {\r\n        Block storage block = blocks[id];\r\n        i = id;\r\n        x = block.x;\r\n        y = block.y;\r\n        owner = blocksOwners[id];\r\n        message = block.message;\r\n    }\r\n    function getRewards(uint c, uint o) public constant returns (uint cursor, uint offset, uint[] array) {\r\n        uint n;\r\n        uint[] memory arr = new uint[](o * 2);\r\n        offset = o; cursor = c;\r\n        uint l = offset + cursor;\r\n        for(uint i = cursor; i<l; i++) {\r\n            arr[n] = uint(rewards_id[i]);\r\n            arr[n + 1] = rewards_amount[i];\r\n            n += 2;\r\n        }\r\n        array = arr;\r\n    }\r\n    function getBlocks(uint c, uint o) public constant returns (uint cursor, uint offset, uint[] array) {\r\n        uint n;\r\n        uint[] memory arr = new uint[](o * 3);\r\n        offset = o; cursor = c;\r\n        uint l = offset + cursor;\r\n        for(uint i = cursor; i<l; i++) {\r\n            Block storage b = blocks[i+1];\r\n            arr[n] = (b.x);\r\n            arr[n + 1] = (b.y);\r\n            arr[n + 2] = uint(blocksOwners[i+1]);\r\n            n += 3;\r\n        }\r\n        array = arr;\r\n    }\r\n    function getPrices(uint c, uint o) public constant returns (uint cursor, uint offset, uint[] array) {\r\n        uint n;\r\n        uint[] memory arr = new uint[](o);\r\n        offset = o;  cursor = c;\r\n        uint l = offset + cursor;\r\n        for(uint i = cursor; i<l; i++) {\r\n            arr[n] = prices[i];\r\n            n++;\r\n        }\r\n        array = arr;\r\n    }\r\n    \r\n    \r\n    //////////\r\n    // CHAT //\r\n    //////////\r\n    \r\n    struct Message {\r\n        address sender;\r\n        string message;\r\n    }\r\n    uint private messagesCount;\r\n    mapping(address => string) public usernames;\r\n    mapping(uint => Message) public messages;\r\n    \r\n    function sendMessage(string message) public returns (uint) {\r\n        messages[messagesCount] = Message(msg.sender, message);\r\n        SendMessage(messagesCount, message, msg.sender);\r\n        messagesCount = messagesCount.add(1);\r\n        return messagesCount;\r\n    }\r\n    function setUserName(string name) public returns (bool) {\r\n        address sender = msg.sender;\r\n        \r\n        bytes memory username = bytes(usernames[sender]);\r\n        if(username.length == 0) {\r\n            usernames[sender] = name;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getBlock\",\"outputs\":[{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"x\",\"type\":\"uint256\"},{\"name\":\"y\",\"type\":\"uint256\"},{\"name\":\"owmer\",\"type\":\"address\"},{\"name\":\"message\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"messages\",\"outputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"message\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewards_id\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"}],\"name\":\"setUserName\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Info\",\"outputs\":[{\"name\":\"tb\",\"type\":\"uint256\"},{\"name\":\"bc\",\"type\":\"uint256\"},{\"name\":\"fbp\",\"type\":\"uint256\"},{\"name\":\"rc\",\"type\":\"uint256\"},{\"name\":\"rb\",\"type\":\"uint256\"},{\"name\":\"rt\",\"type\":\"uint256\"},{\"name\":\"rf\",\"type\":\"uint256\"},{\"name\":\"rd\",\"type\":\"uint256\"},{\"name\":\"mc\",\"type\":\"uint256\"},{\"name\":\"rew\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"message\",\"type\":\"string\"}],\"name\":\"sendMessage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"calculateReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"blocksCoordinates\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewards_amount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"x\",\"type\":\"uint256\"},{\"name\":\"y\",\"type\":\"uint256\"},{\"name\":\"message\",\"type\":\"string\"}],\"name\":\"setBlock\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"c\",\"type\":\"uint256\"},{\"name\":\"o\",\"type\":\"uint256\"}],\"name\":\"getPrices\",\"outputs\":[{\"name\":\"cursor\",\"type\":\"uint256\"},{\"name\":\"offset\",\"type\":\"uint256\"},{\"name\":\"array\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isLive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"prices\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"c\",\"type\":\"uint256\"},{\"name\":\"o\",\"type\":\"uint256\"}],\"name\":\"getRewards\",\"outputs\":[{\"name\":\"cursor\",\"type\":\"uint256\"},{\"name\":\"offset\",\"type\":\"uint256\"},{\"name\":\"array\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"c\",\"type\":\"uint256\"},{\"name\":\"o\",\"type\":\"uint256\"}],\"name\":\"getBlocks\",\"outputs\":[{\"name\":\"cursor\",\"type\":\"uint256\"},{\"name\":\"offset\",\"type\":\"uint256\"},{\"name\":\"array\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"blocksOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"usernames\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"uint256\"},{\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"checkBlockEmpty\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"blocks\",\"outputs\":[{\"name\":\"x\",\"type\":\"uint256\"},{\"name\":\"y\",\"type\":\"uint256\"},{\"name\":\"message\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBlocks\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"getBlockPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"message\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"SendMessage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"NewBlock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"blockID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"Reward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"}],\"name\":\"Withdraw\",\"type\":\"event\"}]","ContractName":"Circleramide","CompilerVersion":"v0.4.17+commit.bdeb9e52","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://d010a17072dbbf23e96524ae0f72d3ce8d0ce2e464dd9218c0217eb8f6ab7c78"}]}