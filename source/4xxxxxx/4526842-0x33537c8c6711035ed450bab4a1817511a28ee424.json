{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.15;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    //Variables\r\n    address public owner;\r\n\r\n    address public newOwner;\r\n\r\n    //    Modifiers\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param _newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != address(0));\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() public {\r\n        if (msg.sender == newOwner) {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract TokenRecipient {\r\n    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public;\r\n}\r\n\r\n\r\ncontract ERC20 is Ownable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    /* Public variables of the token */\r\n    string public standard;\r\n\r\n    string public name;\r\n\r\n    string public symbol;\r\n\r\n    uint8 public decimals;\r\n\r\n    uint256 public initialSupply;\r\n\r\n    bool public locked;\r\n\r\n    uint256 public creationBlock;\r\n\r\n    mapping (address => uint256) public balances;\r\n\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n    /* This generates a public event on the blockchain that will notify clients */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n\r\n    modifier onlyPayloadSize(uint numwords) {\r\n        assert(msg.data.length == numwords.mul(32).add(4));\r\n        _;\r\n    }\r\n\r\n    /* Initializes contract with initial supply tokens to the creator of the contract */\r\n    function ERC20(\r\n        uint256 _initialSupply,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol,\r\n        bool _transferAllSupplyToOwner,\r\n        bool _locked\r\n    ) {\r\n        standard = \"ERC20 0.1\";\r\n\r\n        initialSupply = _initialSupply;\r\n\r\n        if (_transferAllSupplyToOwner) {\r\n            setBalance(msg.sender, initialSupply);\r\n        } else {\r\n            setBalance(this, initialSupply);\r\n        }\r\n\r\n        name = _tokenName;\r\n        // Set the name for display purposes\r\n        symbol = _tokenSymbol;\r\n        // Set the symbol for display purposes\r\n        decimals = _decimalUnits;\r\n        // Amount of decimals for display purposes\r\n        locked = _locked;\r\n        creationBlock = block.number;\r\n    }\r\n\r\n    /* public methods */\r\n    function totalSupply() public constant returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n\r\n    function balanceOf(address _address) public constant returns (uint256) {\r\n        return balances[_address];\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public onlyPayloadSize(2) returns (bool) {\r\n        require(locked == false);\r\n\r\n        bool status = transferInternal(msg.sender, _to, _value);\r\n\r\n        require(status == true);\r\n\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        if (locked) {\r\n            return false;\r\n        }\r\n\r\n        allowance[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\r\n        if (locked) {\r\n            return false;\r\n        }\r\n\r\n        TokenRecipient spender = TokenRecipient(_spender);\r\n\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        if (locked) {\r\n            return false;\r\n        }\r\n\r\n        if (allowance[_from][msg.sender] < _value) {\r\n            return false;\r\n        }\r\n\r\n        bool _success = transferInternal(_from, _to, _value);\r\n\r\n        if (_success) {\r\n            allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\r\n        }\r\n\r\n        return _success;\r\n    }\r\n\r\n    /* internal balances */\r\n    function setBalance(address _holder, uint256 _amount) internal {\r\n        balances[_holder] = _amount;\r\n    }\r\n\r\n    function transferInternal(address _from, address _to, uint256 _value) internal returns (bool success) {\r\n        if (_value == 0) {\r\n            Transfer(_from, _to, 0);\r\n            return true;\r\n        }\r\n\r\n        if (balances[_from] < _value) {\r\n            return false;\r\n        }\r\n\r\n        setBalance(_from, balances[_from].sub(_value));\r\n        setBalance(_to, balances[_to].add(_value));\r\n\r\n        Transfer(_from, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\n/*\r\nThis contract manages the minters and the modifier to allow mint to happen only if called by minters\r\nThis contract contains basic minting functionality though\r\n*/\r\ncontract MintingERC20 is ERC20 {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public maxSupply;\r\n\r\n    mapping (address => bool) public minters;\r\n\r\n    modifier onlyMinters () {\r\n        require(true == minters[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    function MintingERC20(\r\n        uint256 _initialSupply,\r\n        uint256 _maxSupply,\r\n        string _tokenName,\r\n        uint8 _decimals,\r\n        string _symbol,\r\n        bool _transferAllSupplyToOwner,\r\n        bool _locked\r\n    )\r\n        ERC20(_initialSupply, _tokenName, _decimals, _symbol, _transferAllSupplyToOwner, _locked)\r\n    {\r\n        minters[msg.sender] = true;\r\n        maxSupply = _maxSupply;\r\n    }\r\n\r\n    function addMinter(address _newMinter) public onlyOwner {\r\n        minters[_newMinter] = true;\r\n    }\r\n\r\n    function removeMinter(address _minter) public onlyOwner {\r\n        minters[_minter] = false;\r\n    }\r\n\r\n    function mint(address _addr, uint256 _amount) public onlyMinters returns (uint256) {\r\n        if (_amount == uint256(0)) {\r\n            return uint256(0);\r\n        }\r\n\r\n        if (totalSupply().add(_amount) > maxSupply) {\r\n            return uint256(0);\r\n        }\r\n\r\n        initialSupply = initialSupply.add(_amount);\r\n        balances[_addr] = balances[_addr].add(_amount);\r\n        Transfer(0, _addr, _amount);\r\n\r\n        return _amount;\r\n    }\r\n}\r\n\r\ncontract Totum is MintingERC20 {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    TotumPhases public totumPhases;\r\n\r\n    // Block token transfers till ICO end.\r\n    bool public transferFrozen = true;\r\n\r\n    function Totum(\r\n    uint256 _maxSupply,\r\n    string _tokenName,\r\n    string _tokenSymbol,\r\n    uint8 _precision,\r\n    bool _locked\r\n    )\r\n    MintingERC20(0, _maxSupply, _tokenName, _precision, _tokenSymbol, false, _locked)\r\n    {\r\n        standard = \"Totum 0.1\";\r\n    }\r\n\r\n    function setLocked(bool _locked) public onlyOwner {\r\n        locked = _locked;\r\n    }\r\n\r\n    function setTotumPhases(address _totumPhases) public onlyOwner {\r\n        totumPhases = TotumPhases(_totumPhases);\r\n    }\r\n\r\n    function unfreeze() public onlyOwner {\r\n        if (totumPhases != address(0) && totumPhases.isFinished(1)) {\r\n            transferFrozen = false;\r\n        }\r\n    }\r\n\r\n    function buyBack(address _address) public onlyMinters returns (uint256) {\r\n        require(address(_address) != 0x0);\r\n\r\n        uint256 balance = balanceOf(_address);\r\n        setBalance(_address, 0);\r\n        setBalance(this, balanceOf(this).add(balance));\r\n        Transfer(_address, this, balance);\r\n\r\n        return balance;\r\n    }\r\n\r\n    function transfer(address _to, uint _value) public returns (bool) {\r\n        require(!transferFrozen);\r\n\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\r\n        require(!transferFrozen);\r\n\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n}\r\n\r\ncontract TotumAllocation is Ownable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    address public bountyAddress;\r\n\r\n    address public teamAddress;\r\n\r\n    address public preICOAddress;\r\n\r\n    address public icoAddress;\r\n\r\n    address public icoAddress1;\r\n\r\n    function TotumAllocation(\r\n    address _bountyAddress, //5%\r\n    address _teamAddress, //7%\r\n    address _preICOAddress,\r\n    address _icoAddress, //50%\r\n    address _icoAddress1 //50%\r\n    ) {\r\n        require((address(_bountyAddress) != 0x0) && (address(_teamAddress) != 0x0));\r\n        require((address(_preICOAddress) != 0x0) && (address(_icoAddress) != 0x0) && (address(_icoAddress1) != 0x0));\r\n\r\n        bountyAddress = _bountyAddress;\r\n        teamAddress = _teamAddress;\r\n        preICOAddress = _preICOAddress;\r\n        icoAddress = _icoAddress;\r\n        icoAddress1 = _icoAddress1;\r\n    }\r\n\r\n}\r\n\r\ncontract TotumPhases is Ownable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    Totum public totum;\r\n\r\n    TotumAllocation public totumAllocation;\r\n\r\n    Phase[] public phases;\r\n\r\n    uint256 public constant DAY = 86400;\r\n\r\n    uint256 public collectedEthers;\r\n\r\n    uint256 public soldTokens;\r\n\r\n    uint256 public investorsCount;\r\n\r\n    mapping (address => uint256) public icoEtherBalances;\r\n\r\n    mapping (address => bool) private investors;\r\n\r\n    event Refund(address holder, uint256 ethers, uint256 tokens);\r\n\r\n    struct Phase {\r\n    uint256 price;\r\n    uint256 minInvest;\r\n    uint256 softCap;\r\n    uint256 hardCap;\r\n    uint256 since;\r\n    uint256 till;\r\n    bool isSucceed;\r\n    }\r\n\r\n    function TotumPhases(\r\n    address _totum,\r\n    uint256 _minInvest,\r\n    uint256 _tokenPrice, //0.0033 ethers\r\n    uint256 _preIcoMaxCap,\r\n    uint256 _preIcoSince,\r\n    uint256 _preIcoTill,\r\n    uint256 _icoMinCap,\r\n    uint256 _icoMaxCap,\r\n    uint256 _icoSince,\r\n    uint256 _icoTill\r\n    ) {\r\n        require(address(_totum) != 0x0);\r\n        totum = Totum(address(_totum));\r\n\r\n        require((_preIcoSince < _preIcoTill) && (_icoSince < _icoTill) && (_preIcoTill <= _icoSince));\r\n        require((_preIcoMaxCap < _icoMaxCap) && (_icoMaxCap < totum.maxSupply()));\r\n\r\n        phases.push(Phase(_tokenPrice, _minInvest, 0, _preIcoMaxCap, _preIcoSince, _preIcoTill, false));\r\n        phases.push(Phase(_tokenPrice, _minInvest, _icoMinCap, _icoMaxCap, _icoSince, _icoTill, false));\r\n    }\r\n\r\n    function() public payable {\r\n        require(buy(msg.sender, msg.value) == true);\r\n    }\r\n\r\n    function setCurrentRate(uint256 _rate) public onlyOwner {\r\n        require(_rate > 0);\r\n        for (uint i = 0; i < phases.length; i++) {\r\n            Phase storage phase = phases[i];\r\n            phase.price = _rate;\r\n        }\r\n    }\r\n\r\n    function setTotum(address _totum) public onlyOwner {\r\n        totum = Totum(_totum);\r\n    }\r\n\r\n    function setTotumAllocation(address _totumAllocation) public onlyOwner {\r\n        totumAllocation = TotumAllocation(_totumAllocation);\r\n    }\r\n\r\n    function setPhase(\r\n    uint8 _phaseId,\r\n    uint256 _since,\r\n    uint256 _till,\r\n    uint256 _price,\r\n    uint256 _softCap,\r\n    uint256 _hardCap\r\n    ) public onlyOwner returns (bool) {\r\n        require((phases.length > _phaseId) && (_price > 0));\r\n        require((_till > _since) && (_since > 0));\r\n        require((totum.maxSupply() > _hardCap) && (_hardCap > _softCap) && (_softCap >= 0));\r\n\r\n        Phase storage phase = phases[_phaseId];\r\n\r\n        if (phase.isSucceed == true) {\r\n            return false;\r\n        }\r\n        phase.since = _since;\r\n        phase.till = _till;\r\n        phase.price = _price;\r\n        phase.softCap = _softCap;\r\n        phase.hardCap = _hardCap;\r\n\r\n        return true;\r\n    }\r\n\r\n    function sendToAddress(address _address, uint256 _tokens) public onlyOwner returns (bool) {\r\n        if (_tokens == 0 || address(_address) == 0x0) {\r\n            return false;\r\n        }\r\n        uint256 totalAmount = _tokens.add(getBonusAmount(_tokens, now));\r\n        if (getTokens().add(totalAmount) > totum.maxSupply()) {\r\n            return false;\r\n        }\r\n\r\n        bool status = (totalAmount != totum.mint(_address, totalAmount));\r\n        if (status) {\r\n            soldTokens = soldTokens.add(totalAmount);\r\n            increaseInvestorsCount(_address);\r\n        }\r\n\r\n        return status;\r\n    }\r\n\r\n    function sendToAddressWithTime(address _address, uint256 _tokens, uint256 _time) public onlyOwner returns (bool) {\r\n        if (_tokens == 0 || address(_address) == 0x0 || _time == 0) {\r\n            return false;\r\n        }\r\n\r\n        uint256 totalAmount = _tokens.add(getBonusAmount(_tokens, _time));\r\n\r\n        if (getTokens().add(totalAmount) > totum.maxSupply()) {\r\n            return false;\r\n        }\r\n\r\n        bool status = (totalAmount != totum.mint(_address, totalAmount));\r\n\r\n        if (status) {\r\n            soldTokens = soldTokens.add(totalAmount);\r\n            increaseInvestorsCount(_address);\r\n        }\r\n\r\n        return status;\r\n    }\r\n\r\n    function sendToAddressWithBonus(\r\n    address _address,\r\n    uint256 _tokens,\r\n    uint256 _bonus\r\n    ) public onlyOwner returns (bool) {\r\n        if (_tokens == 0 || address(_address) == 0x0 || _bonus == 0) {\r\n            return false;\r\n        }\r\n\r\n        uint256 totalAmount = _tokens.add(_bonus);\r\n\r\n        if (getTokens().add(totalAmount) > totum.maxSupply()) {\r\n            return false;\r\n        }\r\n\r\n        bool status = (totalAmount != totum.mint(_address, totalAmount));\r\n\r\n        if (status) {\r\n            soldTokens = soldTokens.add(totalAmount);\r\n            increaseInvestorsCount(_address);\r\n        }\r\n\r\n        return status;\r\n    }\r\n\r\n    function getCurrentPhase(uint256 _time) public constant returns (uint8) {\r\n        if (_time == 0) {\r\n            return uint8(phases.length);\r\n        }\r\n        for (uint8 i = 0; i < phases.length; i++) {\r\n            Phase storage phase = phases[i];\r\n            if (phase.since > _time) {\r\n                continue;\r\n            }\r\n\r\n            if (phase.till < _time) {\r\n                continue;\r\n            }\r\n\r\n            return i;\r\n        }\r\n\r\n        return uint8(phases.length);\r\n    }\r\n\r\n    function getTokens() public constant returns (uint256) {\r\n        return totum.totalSupply();\r\n    }\r\n\r\n    function getSoldToken() public constant returns (uint256) {\r\n        return soldTokens;\r\n    }\r\n\r\n    function getAllInvestors() public constant returns (uint256) {\r\n        return investorsCount;\r\n    }\r\n\r\n    function getBalanceContract() public constant returns (uint256) {\r\n        return collectedEthers;\r\n    }\r\n\r\n    function isSucceed(uint8 _phaseId) public returns (bool) {\r\n        if (phases.length <= _phaseId) {\r\n            return false;\r\n        }\r\n        Phase storage phase = phases[_phaseId];\r\n        if (phase.isSucceed == true) {\r\n            return true;\r\n        }\r\n        if (phase.till > now) {\r\n            return false;\r\n        }\r\n        if (phase.softCap != 0 && phase.softCap > getTokens()) {\r\n            return false;\r\n        }\r\n        phase.isSucceed = true;\r\n        if (_phaseId == 1) {\r\n            allocateBounty();\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function refund() public returns (bool) {\r\n        Phase storage icoPhase = phases[1];\r\n        if (icoPhase.till > now) {\r\n            return false;\r\n        }\r\n        if (icoPhase.softCap < getTokens()) {\r\n            return false;\r\n        }\r\n        if (icoEtherBalances[msg.sender] == 0) {\r\n            return false;\r\n        }\r\n        uint256 refundAmount = icoEtherBalances[msg.sender];\r\n        uint256 tokens = totum.buyBack(msg.sender);\r\n        icoEtherBalances[msg.sender] = 0;\r\n        msg.sender.transfer(refundAmount);\r\n        Refund(msg.sender, refundAmount, tokens);\r\n\r\n        return true;\r\n    }\r\n\r\n    function isFinished(uint8 _phaseId) public constant returns (bool) {\r\n        if (phases.length <= _phaseId) {\r\n            return false;\r\n        }\r\n        Phase storage phase = phases[_phaseId];\r\n\r\n        return (phase.isSucceed || now > phase.till);\r\n    }\r\n\r\n    function buy(address _address, uint256 _value) internal returns (bool) {\r\n        if (_value == 0) {\r\n            return false;\r\n        }\r\n\r\n        uint8 currentPhase = getCurrentPhase(now);\r\n\r\n        if (phases.length <= currentPhase) {\r\n            return false;\r\n        }\r\n\r\n        uint256 amount = getTokensAmount(_value, currentPhase);\r\n\r\n        if (amount == 0) {\r\n            return false;\r\n        }\r\n\r\n        uint256 bonus = getBonusAmount(amount, now);\r\n\r\n        if (currentPhase == 1) {\r\n            bonus = bonus.add(getVolumeBasedBonusAmount(_value, amount));\r\n        }\r\n\r\n        amount = amount.add(bonus);\r\n\r\n        bool status = (amount == totum.mint(_address, amount));\r\n\r\n        if (status) {\r\n            onSuccessfulBuy(_address, _value, amount, currentPhase);\r\n            allocate(currentPhase);\r\n        }\r\n\r\n        return status;\r\n    }\r\n\r\n    function onSuccessfulBuy(address _address, uint256 _value, uint256 _amount, uint8 _currentPhase) internal {\r\n        collectedEthers = collectedEthers.add(_value);\r\n        soldTokens = soldTokens.add(_amount);\r\n        increaseInvestorsCount(_address);\r\n\r\n        if (_currentPhase == 1) {\r\n            icoEtherBalances[_address] = icoEtherBalances[_address].add(_value);\r\n        }\r\n    }\r\n\r\n    function increaseInvestorsCount(address _address) internal {\r\n        if (address(_address) != 0x0 && investors[_address] == false) {\r\n            investors[_address] = true;\r\n            investorsCount = investorsCount.add(1);\r\n        }\r\n    }\r\n\r\n    function getVolumeBasedBonusAmount(uint256 _value, uint256 _amount) internal returns (uint256) {\r\n        if (_amount == 0) {\r\n            return 0;\r\n        }\r\n        if (_value < 3 ether) {\r\n            return 0;\r\n        } else if (_value < 15 ether) {\r\n            return _amount.mul(3).div(100);\r\n        } else if (_value < 30 ether) {\r\n            return _amount.mul(5).div(100);\r\n        } else {\r\n            return _amount.mul(7).div(100);\r\n        }\r\n    }\r\n\r\n    function getTokensAmount(uint256 _value, uint8 _currentPhase) internal returns (uint256) {\r\n        if (_value == 0 || phases.length <= _currentPhase) {\r\n            return uint256(0);\r\n        }\r\n\r\n        Phase storage phase = phases[_currentPhase];\r\n\r\n        uint256 amount = _value.mul(uint256(10) ** totum.decimals()).div(phase.price);\r\n\r\n        if (amount < phase.minInvest) {\r\n            return uint256(0);\r\n        }\r\n\r\n        if (getTokens().add(amount) > phase.hardCap) {\r\n            return uint256(0);\r\n        }\r\n\r\n        return amount;\r\n    }\r\n\r\n    function getBonusAmount(uint256 _amount, uint256 _time) internal returns (uint256) {\r\n        uint8 currentPhase = getCurrentPhase(_time);\r\n        if (_amount == 0 || _time == 0 || phases.length <= currentPhase) {\r\n            return uint256(0);\r\n        }\r\n\r\n        if (currentPhase == 0) {\r\n            return _amount.mul(50).div(100);\r\n        }\r\n        if (currentPhase == 1) {\r\n            return getICOBonusAmount(_amount, _time);\r\n        }\r\n\r\n        return uint256(0);\r\n    }\r\n\r\n    function getICOBonusAmount(uint256 _amount, uint256 _time) internal returns (uint256) {\r\n        Phase storage ico = phases[1];\r\n        if (_time.sub(ico.since) < 11 * DAY) {// 11d since ico => reward 20%;\r\n            return _amount.mul(20).div(100);\r\n        }\r\n        if (_time.sub(ico.since) < 21 * DAY) {// 21d since ico => reward 15%\r\n            return _amount.mul(15).div(100);\r\n        }\r\n        if (_time.sub(ico.since) < 31 * DAY) {// 31d since ico => reward 10%\r\n            return _amount.mul(10).div(100);\r\n        }\r\n        if (_time.sub(ico.since) < 41 * DAY) {// 41d since ico => reward 5%\r\n            return _amount.mul(5).div(100);\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    function allocate(uint8 _currentPhase) internal {\r\n        if (this.balance > 0 && phases.length > _currentPhase) {\r\n            Phase storage phase = phases[_currentPhase];\r\n\r\n            if (_currentPhase == 0) {\r\n                totumAllocation.preICOAddress().transfer(this.balance);\r\n            } else if (_currentPhase == 1 && soldTokens >= phase.softCap) {\r\n                totumAllocation.icoAddress().transfer(this.balance.mul(5).div(10));\r\n                totumAllocation.icoAddress1().transfer(this.balance);\r\n            }\r\n        }\r\n    }\r\n\r\n    function allocateBounty() internal {\r\n        if (isFinished(1)) {\r\n            uint256 amount = totum.maxSupply().mul(5).div(100);\r\n            uint256 mintedAmount = totum.mint(totumAllocation.bountyAddress(), amount);\r\n\r\n            require(mintedAmount == amount);\r\n\r\n            amount = totum.maxSupply().mul(7).div(100);\r\n            mintedAmount = totum.mint(totumAllocation.teamAddress(), amount);\r\n\r\n            require(mintedAmount == amount);\r\n        }\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"creationBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_locked\",\"type\":\"bool\"}],\"name\":\"setLocked\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minter\",\"type\":\"address\"}],\"name\":\"removeMinter\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"standard\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unfreeze\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totumPhases\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newMinter\",\"type\":\"address\"}],\"name\":\"addMinter\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"buyBack\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferFrozen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_totumPhases\",\"type\":\"address\"}],\"name\":\"setTotumPhases\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"locked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"minters\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_maxSupply\",\"type\":\"uint256\"},{\"name\":\"_tokenName\",\"type\":\"string\"},{\"name\":\"_tokenSymbol\",\"type\":\"string\"},{\"name\":\"_precision\",\"type\":\"uint8\"},{\"name\":\"_locked\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"Totum","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000059682f0000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005544f54554d0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005544f54554d000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://31ec90b9dcfcf1a4c12f4cf0d7d5d9df3072c65457853d04cdb15dcbde718671"}]}