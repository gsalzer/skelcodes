{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.2;\r\n\r\ncontract owned {\r\n\taddress public owner;\r\n\r\n\tfunction owned() {\r\n\t\towner = msg.sender;\r\n\t}\r\n\r\n\tfunction changeOwner(address newOwner) onlyOwner {\r\n\t\towner = newOwner;\r\n\t}\r\n\r\n\tmodifier onlyOwner {\r\n\t\trequire(msg.sender == owner);\r\n\t\t_;\r\n\t}\r\n}\r\n\r\ncontract tokenRecipient {function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData);}\r\n\r\ncontract CSToken is owned {\r\n\tstruct Dividend {\r\n\t\tuint time;\r\n\t\tuint tenThousandth;\r\n\t\tbool isComplete;\r\n\t}\r\n\r\n\t/* Public variables of the token */\r\n\tstring public standard = 'Token 0.1';\r\n\r\n\tstring public name = 'KickCoin';\r\n\r\n\tstring public symbol = 'KC';\r\n\r\n\tuint8 public decimals = 8;\r\n\r\n\tuint256 public totalSupply = 0;\r\n\r\n\t/* This creates an array with all balances */\r\n\tmapping (address => uint256) public balanceOf;\r\n\tmapping (address => uint256) public matureBalanceOf;\r\n\r\n\tmapping (address => mapping (uint => uint256)) public agingBalanceOf;\r\n\r\n\tuint[] agingTimes;\r\n\r\n\tDividend[] dividends;\r\n\r\n\tmapping (address => mapping (address => uint256)) public allowance;\r\n\t/* This generates a public event on the blockchain that will notify clients */\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\tevent AgingTransfer(address indexed from, address indexed to, uint256 value, uint agingTime);\r\n\r\n\tuint countAddressIndexes = 0;\r\n\r\n\tmapping (uint => address) addressByIndex;\r\n\r\n\tmapping (address => uint) indexByAddress;\r\n\r\n\tmapping (address => uint) agingTimesForPools;\r\n\r\n\t/* Initializes contract with initial supply tokens to the creator of the contract */\r\n\tfunction CSToken() {\r\n\t\towner = msg.sender;\r\n\t\tdividends.push(Dividend(1509454800, 300, false));\r\n\t\tdividends.push(Dividend(1512046800, 200, false));\r\n\t\tdividends.push(Dividend(1514725200, 100, false));\r\n\t\tdividends.push(Dividend(1517403600, 50, false));\r\n\t\tdividends.push(Dividend(1519822800, 100, false));\r\n\t\tdividends.push(Dividend(1522501200, 200, false));\r\n\t\tdividends.push(Dividend(1525093200, 300, false));\r\n\t\tdividends.push(Dividend(1527771600, 500, false));\r\n\t\tdividends.push(Dividend(1530363600, 300, false));\r\n\t\tdividends.push(Dividend(1533042000, 200, false));\r\n\t\tdividends.push(Dividend(1535720400, 100, false));\r\n\t\tdividends.push(Dividend(1538312400, 50, false));\r\n\t\tdividends.push(Dividend(1540990800, 100, false));\r\n\t\tdividends.push(Dividend(1543582800, 200, false));\r\n\t\tdividends.push(Dividend(1546261200, 300, false));\r\n\t\tdividends.push(Dividend(1548939600, 600, false));\r\n\t\tdividends.push(Dividend(1551358800, 300, false));\r\n\t\tdividends.push(Dividend(1554037200, 200, false));\r\n\t\tdividends.push(Dividend(1556629200, 100, false));\r\n\t\tdividends.push(Dividend(1559307600, 200, false));\r\n\t\tdividends.push(Dividend(1561899600, 300, false));\r\n\t\tdividends.push(Dividend(1564578000, 200, false));\r\n\t\tdividends.push(Dividend(1567256400, 100, false));\r\n\t\tdividends.push(Dividend(1569848400, 50, false));\r\n\r\n\t}\r\n\r\n\tfunction calculateDividends(uint which) {\r\n\t\trequire(now >= dividends[which].time && !dividends[which].isComplete);\r\n\r\n\t\tfor (uint i = 1; i <= countAddressIndexes; i++) {\r\n\t\t\tbalanceOf[addressByIndex[i]] += balanceOf[addressByIndex[i]] * dividends[which].tenThousandth / 10000;\r\n\t\t\tmatureBalanceOf[addressByIndex[i]] += matureBalanceOf[addressByIndex[i]] * dividends[which].tenThousandth / 10000;\r\n\t\t}\r\n\t}\r\n\r\n\t/* Send coins */\r\n\tfunction transfer(address _to, uint256 _value) {\r\n\t\tcheckMyAging(msg.sender);\r\n\t\trequire(matureBalanceOf[msg.sender] >= _value);\r\n\r\n\t\trequire(balanceOf[_to] + _value > balanceOf[_to]);\r\n\t\trequire(matureBalanceOf[_to] + _value > matureBalanceOf[_to]);\r\n\t\t// Check for overflows\r\n\r\n\t\tbalanceOf[msg.sender] -= _value;\r\n\t\tmatureBalanceOf[msg.sender] -= _value;\r\n\t\t// Subtract from the sender\r\n\r\n\t\tif (agingTimesForPools[msg.sender] > 0 && agingTimesForPools[msg.sender] > now) {\r\n\t\t\taddToAging(msg.sender, _to, agingTimesForPools[msg.sender], _value);\r\n\t\t} else {\r\n\t\t\tmatureBalanceOf[_to] += _value;\r\n\t\t}\r\n\t\tbalanceOf[_to] += _value;\r\n\t\tTransfer(msg.sender, _to, _value);\r\n\t}\r\n\r\n\tfunction mintToken(address target, uint256 mintedAmount, uint agingTime) onlyOwner {\r\n\t\tif (agingTime > now) {\r\n\t\t\taddToAging(owner, target, agingTime, mintedAmount);\r\n\t\t} else {\r\n\t\t\tmatureBalanceOf[target] += mintedAmount;\r\n\t\t}\r\n\r\n\t\tbalanceOf[target] += mintedAmount;\r\n\r\n\t\ttotalSupply += mintedAmount;\r\n\t\tTransfer(0, owner, mintedAmount);\r\n\t\tTransfer(owner, target, mintedAmount);\r\n\t}\r\n\r\n\tfunction addToAging(address from, address target, uint agingTime, uint256 amount) internal {\r\n\t\tif (indexByAddress[target] == 0) {\r\n\t\t\tindexByAddress[target] = 1;\r\n\t\t\tcountAddressIndexes++;\r\n\t\t\taddressByIndex[countAddressIndexes] = target;\r\n\t\t}\r\n\t\tbool existTime = false;\r\n\t\tfor (uint i = 0; i < agingTimes.length; i++) {\r\n\t\t\tif (agingTimes[i] == agingTime)\r\n\t\t\texistTime = true;\r\n\t\t}\r\n\t\tif (!existTime) agingTimes.push(agingTime);\r\n\t\tagingBalanceOf[target][agingTime] += amount;\r\n\t\tAgingTransfer(from, target, amount, agingTime);\r\n\t}\r\n\r\n\t/* Allow another contract to spend some tokens in your behalf */\r\n\tfunction approve(address _spender, uint256 _value) returns (bool success) {\r\n\t\tallowance[msg.sender][_spender] = _value;\r\n\t\treturn true;\r\n\t}\r\n\t/* Approve and then communicate the approved contract in a single tx */\r\n\tfunction approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n\t\ttokenRecipient spender = tokenRecipient(_spender);\r\n\t\tif (approve(_spender, _value)) {\r\n\t\t\tspender.receiveApproval(msg.sender, _value, this, _extraData);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\t/* A contract attempts to get the coins */\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n\t\tcheckMyAging(_from);\r\n\t\trequire(matureBalanceOf[_from] >= _value);\r\n\t\t// Check if the sender has enough\r\n\t\tassert(balanceOf[_to] + _value > balanceOf[_to]);\r\n\t\tassert(matureBalanceOf[_to] + _value > matureBalanceOf[_to]);\r\n\t\t// Check for overflows\r\n\t\trequire(_value <= allowance[_from][msg.sender]);\r\n\t\t// Check allowance\r\n\t\tbalanceOf[_from] -= _value;\r\n\t\tmatureBalanceOf[_from] -= _value;\r\n\t\t// Subtract from the sender\r\n\t\tbalanceOf[_to] += _value;\r\n\t\t// Add the same to the recipient\r\n\t\tallowance[_from][msg.sender] -= _value;\r\n\r\n\t\tif (agingTimesForPools[_from] > 0 && agingTimesForPools[_from] > now) {\r\n\t\t\taddToAging(_from, _to, agingTimesForPools[_from], _value);\r\n\t\t} else {\r\n\t\t\tmatureBalanceOf[_to] += _value;\r\n\t\t}\r\n\r\n\t\tTransfer(_from, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/* This unnamed function is called whenever someone tries to send ether to it */\r\n\tfunction() {\r\n\t\trevert();\r\n\t\t// Prevents accidental sending of ether\r\n\t}\r\n\r\n\tfunction checkMyAging(address sender) internal {\r\n\t\tfor (uint k = 0; k < agingTimes.length; k++) {\r\n\t\t\tif (agingTimes[k] < now && agingBalanceOf[sender][agingTimes[k]] > 0) {\r\n\t\t\t\tfor(uint256 i = 0; i < 24; i++) {\r\n\t\t\t\t\tif(now < dividends[i].time) break;\r\n\t\t\t\t\tif(!dividends[i].isComplete) break;\r\n\t\t\t\t\tagingBalanceOf[sender][agingTimes[k]] += agingBalanceOf[sender][agingTimes[k]] * dividends[i].tenThousandth / 10000;\r\n\t\t\t\t}\r\n\t\t\t\tmatureBalanceOf[sender] += agingBalanceOf[sender][agingTimes[k]];\r\n\t\t\t\tagingBalanceOf[sender][agingTimes[k]] = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction addAgingTimesForPool(address poolAddress, uint agingTime) onlyOwner {\r\n\t\tagingTimesForPools[poolAddress] = agingTime;\r\n\t}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"matureBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"mintedAmount\",\"type\":\"uint256\"},{\"name\":\"agingTime\",\"type\":\"uint256\"}],\"name\":\"mintToken\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"which\",\"type\":\"uint256\"}],\"name\":\"calculateDividends\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"standard\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"agingBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"poolAddress\",\"type\":\"address\"},{\"name\":\"agingTime\",\"type\":\"uint256\"}],\"name\":\"addAgingTimesForPool\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":false,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"agingTime\",\"type\":\"uint256\"}],\"name\":\"AgingTransfer\",\"type\":\"event\"}]","ContractName":"CSToken","CompilerVersion":"v0.4.13+commit.fb4cb1a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://3781556c32ccbf0cdc1a9798233ac2c7922cfca666dbd7acc7b75276e890734b"}]}