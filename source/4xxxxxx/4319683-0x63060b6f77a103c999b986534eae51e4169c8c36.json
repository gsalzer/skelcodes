{"status":"1","message":"OK","result":[{"SourceCode":"// Copyright New Alchemy Limited, 2017. All rights reserved.\r\npragma solidity >=0.4.10;\r\n\r\n// Just the bits of ERC20 that we need.\r\ncontract Token {\r\n    function balanceOf(address addr) returns(uint);\r\n    function transfer(address to, uint amount) returns(bool);\r\n}\r\n\r\n// Receiver is the contract that takes contributions\r\ncontract Receiver {\r\n    event StartSale();\r\n    event EndSale();\r\n    event EtherIn(address from, uint amount);\r\n\r\n    address public owner;    // contract owner\r\n    address public newOwner; // new contract owner for two-way ownership handshake\r\n    string public notice;    // arbitrary public notice text\r\n\r\n    Sale public sale;\r\n\r\n    function Receiver() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlySale() {\r\n        require(msg.sender == address(sale));\r\n        _;\r\n    }\r\n\r\n    function live() constant returns(bool) {\r\n        return sale.live();\r\n    }\r\n\r\n    // callback from sale contract when the sale begins\r\n    function start() onlySale {\r\n        StartSale();\r\n    }\r\n\r\n    // callback from sale contract when sale ends\r\n    function end() onlySale {\r\n        EndSale();\r\n    }\r\n\r\n    function () payable {\r\n        // forward everything to the sale contract\r\n        EtherIn(msg.sender, msg.value);\r\n        require(sale.call.value(msg.value)());\r\n    }\r\n\r\n    // 1st half of ownership change\r\n    function changeOwner(address next) onlyOwner {\r\n        newOwner = next;\r\n    }\r\n\r\n    // 2nd half of ownership change\r\n    function acceptOwnership() {\r\n        require(msg.sender == newOwner);\r\n        owner = msg.sender;\r\n        newOwner = 0;\r\n    }\r\n\r\n    // put some text in the contract\r\n    function setNotice(string note) onlyOwner {\r\n        notice = note;\r\n    }\r\n\r\n    // set the target sale address\r\n    function setSale(address s) onlyOwner {\r\n        sale = Sale(s);\r\n    }\r\n\r\n    // Ether gets sent to the main sale contract,\r\n    // but tokens get sent here, so we still need\r\n    // withdrawal methods.\r\n\r\n    // withdraw tokens to owner\r\n    function withdrawToken(address token) onlyOwner {\r\n        Token t = Token(token);\r\n        require(t.transfer(msg.sender, t.balanceOf(this)));\r\n    }\r\n\r\n    // refund early/late tokens\r\n    function refundToken(address token, address sender, uint amount) onlyOwner {\r\n        Token t = Token(token);\r\n        require(t.transfer(sender, amount));\r\n    }\r\n}\r\n\r\ncontract Sale {\r\n    // once the balance of this contract exceeds the\r\n    // soft-cap, the sale should stay open for no more\r\n    // than this amount of time\r\n    uint public constant SOFTCAP_TIME = 4 hours;\r\n\r\n    address public owner;    // contract owner\r\n    address public newOwner; // new contract owner for two-way ownership handshake\r\n    string public notice;    // arbitrary public notice text\r\n    uint public start;       // start time of sale\r\n    uint public end;         // end time of sale\r\n    uint public cap;         // Ether hard cap\r\n    uint public softcap;     // Ether soft cap\r\n    bool public live;        // sale is live right now\r\n\r\n    Receiver public r0;\r\n    Receiver public r1;\r\n    Receiver public r2;\r\n\r\n    function Sale() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    // tell the receivers that the sale has begun\r\n    function emitBegin() internal {\r\n        r0.start();\r\n        r1.start();\r\n        r2.start();\r\n    }\r\n\r\n    // tell the receivers that the sale is over\r\n    function emitEnd() internal {\r\n        r0.end();\r\n        r1.end();\r\n        r2.end();\r\n    }\r\n\r\n    function () payable {\r\n        // only accept contributions from receiver contracts\r\n        require(msg.sender == address(r0) || msg.sender == address(r1) || msg.sender == address(r2));\r\n        require(block.timestamp >= start);\r\n\r\n        // if we've gone past the softcap, make sure the sale\r\n        // stays open for no longer than SOFTCAP_TIME past the current block\r\n        if (this.balance > softcap && block.timestamp < end && (end - block.timestamp) > SOFTCAP_TIME)\r\n            end = block.timestamp + SOFTCAP_TIME;\r\n\r\n        // If we've reached end-of-sale conditions, accept\r\n        // this as the last contribution and emit the EndSale event.\r\n        // (Technically this means we allow exactly one contribution\r\n        // after the end of the sale.)\r\n        // Conversely, if we haven't started the sale yet, emit\r\n        // the StartSale event.\r\n        if (block.timestamp > end || this.balance > cap) {\r\n            require(live);\r\n            live = false;\r\n            emitEnd();\r\n        } else if (!live) {\r\n            live = true;\r\n            emitBegin();\r\n        }\r\n    }\r\n\r\n    function init(uint _start, uint _end, uint _cap, uint _softcap) onlyOwner {\r\n        start = _start;\r\n        end = _end;\r\n        cap = _cap;\r\n        softcap = _softcap;\r\n    }\r\n\r\n    function setReceivers(address a, address b, address c) onlyOwner {\r\n        r0 = Receiver(a);\r\n        r1 = Receiver(b);\r\n        r2 = Receiver(c);\r\n    }\r\n\r\n    // 1st half of ownership change\r\n    function changeOwner(address next) onlyOwner {\r\n        newOwner = next;\r\n    }\r\n\r\n    // 2nd half of ownership change\r\n    function acceptOwnership() {\r\n        require(msg.sender == newOwner);\r\n        owner = msg.sender;\r\n        newOwner = 0;\r\n    }\r\n\r\n    // put some text in the contract\r\n    function setNotice(string note) onlyOwner {\r\n        notice = note;\r\n    }\r\n\r\n    // withdraw all of the Ether\r\n    function withdraw() onlyOwner {\r\n        msg.sender.transfer(this.balance);\r\n    }\r\n\r\n    // withdraw some of the Ether\r\n    function withdrawSome(uint value) onlyOwner {\r\n        require(value <= this.balance);\r\n        msg.sender.transfer(value);\r\n    }\r\n\r\n    // withdraw tokens to owner\r\n    function withdrawToken(address token) onlyOwner {\r\n        Token t = Token(token);\r\n        require(t.transfer(msg.sender, t.balanceOf(this)));\r\n    }\r\n\r\n    // refund early/late tokens\r\n    function refundToken(address token, address sender, uint amount) onlyOwner {\r\n        Token t = Token(token);\r\n        require(t.transfer(sender, amount));\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"s\",\"type\":\"address\"}],\"name\":\"setSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"note\",\"type\":\"string\"}],\"name\":\"setNotice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sale\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"refundToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"live\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"notice\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"next\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"start\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"end\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"StartSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"EndSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EtherIn\",\"type\":\"event\"}]","ContractName":"Receiver","CompilerVersion":"v0.4.17+commit.bdeb9e52","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://b1471574b3fd4667f1f3ef04d6f7ea3749e3f9e6e359d5000f2fac5b6b1d5339"}]}