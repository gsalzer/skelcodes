{"status":"1","message":"OK","result":[{"SourceCode":"contract ERC20Basic {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) constant returns (uint);\r\n  function transfer(address to, uint value);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) constant returns (uint);\r\n  function transferFrom(address from, address to, uint value);\r\n  function approve(address spender, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract Own {\r\n    address public owner;\r\n\r\n    function Own() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        if (msg.sender != owner) throw;\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) onlyOwner {\r\n        if (newOwner != address(0)) {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n}\r\n\r\ncontract Pause is Own {\r\n  bool public stopped;\r\n\r\n  modifier stopInEmergency {\r\n    if (stopped) {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n  \r\n  modifier onlyInEmergency {\r\n    if (!stopped) {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n  // owner call to trigger a stop state\r\n  function emergencyStop() external onlyOwner {\r\n    stopped = true;\r\n  }\r\n\r\n  // owner call to restart from the stop state\r\n  function release() external onlyOwner onlyInEmergency {\r\n    stopped = false;\r\n  }\r\n\r\n}\r\n\r\ncontract Puller {\r\n\r\n  using SafeMath for uint;\r\n  \r\n  mapping(address => uint) public payments;\r\n\r\n  event LogRefundETH(address to, uint value);\r\n\r\n  function asyncSend(address dest, uint amount) internal {\r\n    payments[dest] = payments[dest].add(amount);\r\n  }\r\n\r\n  // withdrwaw call for refunding balance acumilated by payee\r\n  function withdrawPayments() {\r\n    address payee = msg.sender;\r\n    uint payment = payments[payee];\r\n    \r\n    if (payment == 0) {\r\n      throw;\r\n    }\r\n\r\n    if (this.balance < payment) {\r\n      throw;\r\n    }\r\n\r\n    payments[payee] = 0;\r\n\r\n    if (!payee.send(payment)) {\r\n      throw;\r\n    }\r\n    LogRefundETH(payee,payment);\r\n  }\r\n}\r\n\r\ncontract BasicToken is ERC20Basic {\r\n  \r\n  using SafeMath for uint;\r\n  \r\n  mapping(address => uint) balances;\r\n  \r\n  modifier onlyPayloadSize(uint size) {\r\n     if(msg.data.length < size + 4) {\r\n       throw;\r\n     }\r\n     _;\r\n  }\r\n\r\n  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) {\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n  }\r\n\r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n}\r\n\r\ncontract StandardToken is BasicToken, ERC20 {\r\n  mapping (address => mapping (address => uint)) allowed;\r\n\r\n  function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) {\r\n    var _allowance = allowed[_from][msg.sender];\r\n    balances[_to] = balances[_to].add(_value);\r\n    balances[_from] = balances[_from].sub(_value);\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\n    Transfer(_from, _to, _value);\r\n  }\r\n\r\n  function approve(address _spender, uint _value) {\r\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n}\r\n\r\ncontract Token is StandardToken, Own {\r\n  string public constant name = \"TribeToken\";\r\n  string public constant symbol = \"TRIBE\";\r\n  uint public constant decimals = 6;\r\n\r\n  // Token constructor\r\n  function Token() {\r\n      totalSupply = 200000000000000;\r\n      balances[msg.sender] = totalSupply; // send all created tokens to the owner/creator\r\n  }\r\n\r\n  // Burn function to burn a set amount of tokens\r\n  function burner(uint _value) onlyOwner returns (bool) {\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    totalSupply = totalSupply.sub(_value);\r\n    Transfer(msg.sender, 0x0, _value);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\ncontract Crowdsale is Pause, Puller {\r\n    \r\n    using SafeMath for uint;\r\n\r\n  \tstruct Backer {\r\n\t\tuint weiReceived; // Amount of Ether given\r\n\t\tuint coinSent;\r\n\t}\r\n    \r\n\t//CONSTANTS\r\n\t// Maximum number of TRIBE to sell\r\n\tuint public constant MAX_CAP = 160000000000000; // 160 000 000 TRIBE\r\n\t// Minimum amount to invest\r\n\tuint public constant MIN_INVEST_ETHER = 100 finney; // 0.1ETH\r\n\t// Crowdsale period\r\n\tuint private constant CROWDSALE_PERIOD = 22 days; // 22 days crowdsale run\r\n\t// Number of TRIBE per Ether\r\n\tuint public constant COIN_PER_ETHER = 3000000000; // 3 000 TRIBE\r\n\r\n\r\n\t//VARIABLES\r\n\t// TRIBE contract reference\r\n\tToken public coin;\r\n    // Multisig contract that will receive the Ether\r\n\taddress public multisigEther;\r\n\t// Number of Ether received\r\n\tuint public etherReceived;\r\n\t// Number of TRIBE sent to Ether contributors\r\n\tuint public coinSentToEther;\r\n  // Number of TRIBE to burn\r\n  uint public coinToBurn;\r\n\t// Crowdsale start time\r\n\tuint public startTime;\r\n\t// Crowdsale end time\r\n\tuint public endTime;\r\n \t// Is crowdsale still on going\r\n\tbool public crowdsaleClosed;\r\n\t// Refund open variable\r\n\tbool public refundsOpen;\r\n\r\n\t// Backers Ether indexed by their Ethereum address\r\n\tmapping(address => Backer) public backers;\r\n\r\n\r\n\t//MODIFIERS\r\n\tmodifier respectTimeFrame() {\r\n\t\tif ((now < startTime) || (now > endTime )) throw;\r\n\t\t_;\r\n\t}\r\n\t\r\n\tmodifier refundStatus() {\r\n\t\tif ((refundsOpen != true )) throw;\r\n\t\t_;\r\n\t}\r\n\r\n\t//EVENTS\r\n\tevent LogReceivedETH(address addr, uint value);\r\n\tevent LogCoinsEmited(address indexed from, uint amount);\r\n\r\n\t//Crowdsale Constructor\r\n\tfunction Crowdsale(address _TRIBEAddress, address _to) {\r\n\t\tcoin = Token(_TRIBEAddress);\r\n\t\tmultisigEther = _to;\r\n\t}\r\n\t\r\n\t// Default function to receive ether\r\n\tfunction() stopInEmergency respectTimeFrame payable {\r\n\t\treceiveETH(msg.sender);\r\n\t}\r\n\r\n\t \r\n\t// To call to start the crowdsale\r\n\tfunction start() onlyOwner {\r\n\t\tif (startTime != 0) throw; // Crowdsale was already started\r\n\r\n\t\tstartTime = now ;            \r\n\t\tendTime =  now + CROWDSALE_PERIOD;    \r\n\t}\r\n\r\n\t// Main function on ETH receive\r\n\tfunction receiveETH(address beneficiary) internal {\r\n\t\tif (msg.value < MIN_INVEST_ETHER) throw; // Do not accept investment if the amount is lower than the minimum allowed investment\r\n\t\t\r\n\t\tuint coinToSend = bonus(msg.value.mul(COIN_PER_ETHER).div(1 ether)); // Calculate the amount of tokens to send\r\n\t\tif (coinToSend.add(coinSentToEther) > MAX_CAP) throw;\t\r\n\r\n\t\tBacker backer = backers[beneficiary];\r\n\t\tcoin.transfer(beneficiary, coinToSend); // Transfer TRIBE\r\n\r\n\t\tbacker.coinSent = backer.coinSent.add(coinToSend);\r\n\t\tbacker.weiReceived = backer.weiReceived.add(msg.value); // Update the total wei collected during the crowdfunding for this backer    \r\n\r\n\t\tetherReceived = etherReceived.add(msg.value); // Update the total wei collected during the crowdfunding\r\n\t\tcoinSentToEther = coinSentToEther.add(coinToSend);\r\n\r\n\t\t// Send events\r\n\t\tLogCoinsEmited(msg.sender ,coinToSend);\r\n\t\tLogReceivedETH(beneficiary, etherReceived); \r\n\t}\r\n\t\r\n\r\n\t// Bonus function for the first week\r\n\tfunction bonus(uint amount) internal constant returns (uint) {\r\n\t\tif (now < startTime.add(7 days)) return amount.add(amount.div(5));   // bonus 20%\r\n\t\treturn amount;\r\n\t}\r\n\r\n\t// Finalize function\r\n\tfunction finalize() onlyOwner public {\r\n\r\n        // Check if the crowdsale has ended or if the old tokens have been sold\r\n    if(coinSentToEther != MAX_CAP){\r\n        if (now < endTime)  throw; // If Crowdsale still running\r\n    }\r\n\t\t\r\n\t\tif (!multisigEther.send(this.balance)) throw; // Move the remaining Ether to the multisig address\r\n\t\t\r\n\t\tuint remains = coin.balanceOf(this);\r\n\t\tif (remains > 0) {\r\n      coinToBurn = coinToBurn.add(remains);\r\n      // Transfer remains to owner to burn\r\n      coin.transfer(owner, remains);\r\n\t\t}\r\n\t\tcrowdsaleClosed = true;\r\n\t}\r\n\r\n\t// Drain functions in case of unexpected issues with the smart contract.\r\n  // ETH drain\r\n\tfunction drain() onlyOwner {\r\n    if (!multisigEther.send(this.balance)) throw; //Transfer to team multisig wallet\r\n\t}\r\n  // TOKEN drain\r\n  function coinDrain() onlyOwner {\r\n    uint remains = coin.balanceOf(this);\r\n    coin.transfer(owner, remains); // Transfer to owner wallet\r\n\t}\r\n\r\n\t// Change multisig wallet in case its needed\r\n\tfunction changeMultisig(address addr) onlyOwner public {\r\n\t\tif (addr == address(0)) throw;\r\n\t\tmultisigEther = addr;\r\n\t}\r\n\r\n\t// Change contract ownership\r\n\tfunction changeTribeOwner() onlyOwner public {\r\n\t\tcoin.transferOwnership(owner);\r\n\t}\r\n\r\n\t// Toggle refund state on and off\r\n\tfunction setRefundState() onlyOwner public {\r\n\t\tif(refundsOpen == false){\r\n\t\t\trefundsOpen = true;\r\n\t\t}else{\r\n\t\t\trefundsOpen = false;\r\n\t\t}\r\n\t}\r\n\r\n\t//Refund function when minimum cap isnt reached, this is step is step 2, THIS FUNCTION ONLY AVAILABLE AFTER BEING ENABLED.\r\n\t//STEP1: From TRIBE token contract use \"approve\" function with the amount of TRIBE you got in total.\r\n\t//STEP2: From TRIBE crowdsale contract use \"refund\" function with the amount of TRIBE you got in total.\r\n\t//STEP3: From TRIBE crowdsale contract use \"withdrawPayement\" function to recieve the ETH.\r\n\tfunction refund(uint _value) refundStatus public {\r\n\t\t\r\n\t\tif (_value != backers[msg.sender].coinSent) throw; // compare value from backer balance\r\n\r\n\t\tcoin.transferFrom(msg.sender, address(this), _value); // get the token back to the crowdsale contract\r\n\r\n\t\tuint ETHToSend = backers[msg.sender].weiReceived;\r\n\t\tbackers[msg.sender].weiReceived=0;\r\n\r\n\t\tif (ETHToSend > 0) {\r\n\t\t\tasyncSend(msg.sender, ETHToSend); // pull payment to get refund in ETH\r\n\t\t}\r\n\t}\r\n\r\n}\r\n\r\nlibrary SafeMath {\r\n  function mul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n  function div(uint a, uint b) internal returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a / b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n  function sub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n  function add(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) {\r\n      throw;\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"refundsOpen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"coin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setRefundState\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"changeMultisig\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"etherReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawPayments\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"emergencyStop\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_INVEST_ETHER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"changeTribeOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stopped\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"release\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"coinSentToEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"coinToBurn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"drain\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COIN_PER_ETHER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"coinDrain\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"backers\",\"outputs\":[{\"name\":\"weiReceived\",\"type\":\"uint256\"},{\"name\":\"coinSent\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"start\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleClosed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multisigEther\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_CAP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"payments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_TRIBEAddress\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogReceivedETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogCoinsEmited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogRefundETH\",\"type\":\"event\"}]","ContractName":"Crowdsale","CompilerVersion":"v0.4.11-nightly.2017.5.2+commit.5aeb6352","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000a1a85a763b252ff7253b8829d4fb60d526e517ca000000000000000000000000ae80d3d8fd2cb3cb106abf2dd4a95f634cc4e409","Library":"","SwarmSource":"bzzr://f911f5ac420875a5b530dcd6eadc0c4f196a92cc225869be1a8af718b7644e83"}]}