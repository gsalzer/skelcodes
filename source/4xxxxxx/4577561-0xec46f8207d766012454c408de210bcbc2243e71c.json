{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\ncontract Ownable {\r\n\r\n  address public owner = msg.sender;\r\n  address private newOwner = address(0);\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    require(_newOwner != address(0));      \r\n    newOwner = _newOwner;\r\n  }\r\n\r\n  function acceptOwnership() public {\r\n    require(msg.sender != address(0));\r\n    require(msg.sender == newOwner);\r\n\r\n    owner = newOwner;\r\n    newOwner = address(0);\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 {\r\n\r\n  /**\r\n   * the total token supply.\r\n   */\r\n  uint256 public totalSupply;\r\n\r\n  /**\r\n   * @param _owner The address from which the balance will be retrieved\r\n   * @return The balance\r\n   */\r\n  function balanceOf(address _owner) public constant returns (uint256 balance);\r\n\r\n  /**\r\n   * @notice send `_value` token to `_to` from `msg.sender`\r\n   * @param _to The address of the recipient\r\n   * @param _value The amount of token to be transferred\r\n   * @return Whether the transfer was successful or not\r\n   */\r\n  function transfer(address _to, uint256 _value) public returns (bool success);\r\n\r\n  /**\r\n   * @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n   * @param _from The address of the sender\r\n   * @param _to The address of the recipient\r\n   * @param _value The amount of token to be transferred\r\n   * @return Whether the transfer was successful or not\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n  /**\r\n   * @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n   * @param _spender The address of the account able to transfer the tokens\r\n   * @param _value The amount of tokens to be approved for transfer\r\n   * @return Whether the approval was successful or not\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n  /**\r\n   * @param _owner The address of the account owning tokens\r\n   * @param _spender The address of the account able to transfer the tokens\r\n   * @return Amount of remaining tokens allowed to spent\r\n   */\r\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\r\n\r\n  /**\r\n   * MUST trigger when tokens are transferred, including zero value transfers.\r\n   */\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n  /**\r\n   * MUST trigger on any successful call to approve(address _spender, uint256 _value)\r\n   */\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n}\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n * @dev Based on code by OpenZeppelin: https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/StandardToken.sol\r\n */\r\ncontract ERC20Token is ERC20 {\r\n\r\n  using SafeMath for uint256;\r\n\r\n  mapping (address => uint256) balances;\r\n  \r\n  mapping (address => mapping (address => uint256)) allowed;\r\n\r\n  /**\r\n   * @dev Gets the balance of the specified address.\r\n   * @param _owner The address to query the the balance of.\r\n   * @return An uint256 representing the amount owned by the passed address.\r\n   */\r\n  function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n  \r\n  /**\r\n   * @dev transfer token for a specified address\r\n   * @param _to The address to transfer to.\r\n   * @param _value The amount to be transferred.\r\n   */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] +=_value;\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value > 0);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    \r\n    balances[_to] += _value;\r\n    \r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\ncontract NitroToken is ERC20Token, Ownable {\r\n    \r\n  string public constant name = \"Nitro\";\r\n  string public constant symbol = \"NOX\";\r\n  uint8 public constant decimals = 18;\r\n\r\n  function NitroToken(uint256 _totalSupply) public {\r\n    totalSupply = _totalSupply;\r\n    balances[owner] = _totalSupply;\r\n    Transfer(address(0), owner, _totalSupply);\r\n  }\r\n  \r\n  function acceptOwnership() public {\r\n    address oldOwner = owner;\r\n    super.acceptOwnership();\r\n    balances[owner] = balances[oldOwner];\r\n    balances[oldOwner] = 0;\r\n    Transfer(oldOwner, owner, balances[owner]);\r\n  }\r\n\r\n}\r\n\r\ncontract Declaration {\r\n  \r\n  enum TokenTypes { crowdsale, interactive, icandy, consultant, team, reserve }\r\n  mapping(uint => uint256) public balances;\r\n  \r\n  uint256 public preSaleStart = 1511020800;\r\n  uint256 public preSaleEnd = 1511452800;\r\n    \r\n  uint256 public saleStart = 1512057600;\r\n  uint256 public saleStartFirstDayEnd = saleStart + 1 days;\r\n  uint256 public saleStartSecondDayEnd = saleStart + 3 days;\r\n  uint256 public saleEnd = 1514304000;\r\n  \r\n  uint256 public teamFrozenTokens = 4800000 * 1 ether;\r\n  uint256 public teamUnfreezeDate = saleEnd + 182 days;\r\n\r\n  uint256 public presaleMinValue = 5 ether;\r\n \r\n  uint256 public preSaleRate = 1040;\r\n  uint256 public saleRate = 800;\r\n  uint256 public saleRateFirstDay = 1000;\r\n  uint256 public saleRateSecondDay = 920;\r\n\r\n  NitroToken public token;\r\n\r\n  function Declaration() public {\r\n    balances[uint8(TokenTypes.crowdsale)] = 60000000 * 1 ether;\r\n    balances[uint8(TokenTypes.interactive)] = 6000000 * 1 ether;\r\n    balances[uint8(TokenTypes.icandy)] = 3000000 * 1 ether;\r\n    balances[uint8(TokenTypes.consultant)] = 1200000 * 1 ether;\r\n    balances[uint8(TokenTypes.team)] = 7200000 * 1 ether;\r\n    balances[uint8(TokenTypes.reserve)] = 42600000 * 1 ether;\r\n    token = new NitroToken(120000000 * 1 ether);\r\n  }\r\n  \r\n  modifier withinPeriod(){\r\n    require(isPresale() || isSale());\r\n    _;\r\n  }\r\n  \r\n  function isPresale() public constant returns (bool){\r\n    return now>=preSaleStart && now<=preSaleEnd;\r\n  }\r\n\r\n  function isSale()  public constant returns (bool){\r\n    return now >= saleStart && now <= saleEnd;\r\n  }\r\n  \r\n  function rate() public constant returns (uint256) {\r\n    if (isPresale()) {\r\n      return preSaleRate;\r\n    } else if (now>=saleStart && now<=(saleStartFirstDayEnd)){\r\n      return saleRateFirstDay;\r\n    } else if (now>(saleStartFirstDayEnd) && now<=(saleStartSecondDayEnd)){\r\n      return saleRateSecondDay;\r\n    }\r\n    return saleRate;\r\n  }\r\n  \r\n}\r\n\r\ncontract Crowdsale is Declaration, Ownable{\r\n    \r\n    using SafeMath for uint256;\r\n\r\n    address public wallet;\r\n    \r\n    uint256 public weiLimit = 6 ether;\r\n    uint256 public satLimit = 30000000;\r\n\r\n    mapping(address => bool) users;\r\n    mapping(address => uint256) weiOwed;\r\n    mapping(address => uint256) satOwed;\r\n    mapping(address => uint256) weiTokensOwed;\r\n    mapping(address => uint256) satTokensOwed;\r\n    \r\n    uint256 public weiRaised;\r\n    uint256 public satRaised;\r\n\r\n    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\r\n    \r\n    function Crowdsale(address _wallet) Declaration public {\r\n        wallet = _wallet;    \r\n    }\r\n    \r\n    function () public payable {\r\n        buy();\r\n    }\r\n\r\n    function weiFreeze(address _addr, uint256 _value) internal {\r\n        uint256 amount = _value * rate();\r\n        balances[0] = balances[0].sub(amount);\r\n        weiOwed[_addr] += _value;\r\n        weiTokensOwed[_addr] += amount;\r\n    }\r\n\r\n    function weiTransfer(address _addr, uint256 _value) internal {\r\n        uint256 amount = _value * rate();\r\n        balances[0] = balances[0].sub(amount);\r\n        token.transfer(_addr, amount);\r\n        weiRaised += _value;\r\n        TokenPurchase(_addr, _addr, _value, amount);\r\n    }\r\n\r\n    function buy() withinPeriod public payable returns (bool){\r\n        if (isPresale()) {\r\n          require(msg.value >= presaleMinValue);\r\n        }else{\r\n          require(msg.value > 0);\r\n        }\r\n        if (weiOwed[msg.sender]>0) {\r\n          weiFreeze(msg.sender, msg.value);\r\n        } else if (msg.value>weiLimit && !users[msg.sender]) {\r\n          weiFreeze(msg.sender, msg.value.sub(weiLimit));\r\n          weiTransfer(msg.sender, weiLimit);\r\n        } else {\r\n          weiTransfer(msg.sender, msg.value);\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    function _verify(address _addr) onlyOwner internal {\r\n        users[_addr] = true;\r\n        \r\n        weiRaised += weiOwed[_addr];\r\n        satRaised += satOwed[_addr];\r\n\r\n        token.transfer(_addr, weiTokensOwed[_addr] + satTokensOwed[_addr]);\r\n        \r\n        TokenPurchase(_addr, _addr, 0, weiTokensOwed[_addr] + satTokensOwed[_addr]);\r\n\r\n        weiOwed[_addr]=0;\r\n        satOwed[_addr]=0;\r\n        weiTokensOwed[_addr]=0;\r\n        satTokensOwed[_addr]=0;\r\n    }\r\n\r\n    function verify(address _addr) public returns(bool){\r\n        _verify(_addr);\r\n        return true;\r\n    }\r\n    \r\n    function isVerified(address _addr) public constant returns(bool){\r\n      return users[_addr];\r\n    }\r\n    \r\n    function getWeiTokensOwed(address _addr) public constant returns (uint256){\r\n        return weiTokensOwed[_addr];\r\n    }\r\n\r\n    function getSatTokensOwed(address _addr) public constant returns (uint256){\r\n        return satTokensOwed[_addr];\r\n    }\r\n\r\n    function owedTokens(address _addr) public constant returns (uint256){\r\n        return weiTokensOwed[_addr] + satTokensOwed[_addr];\r\n    }\r\n    \r\n    function getSatOwed(address _addr) public constant returns (uint256){\r\n        return satOwed[_addr];\r\n    }\r\n    \r\n    function getWeiOwed(address _addr) public constant returns (uint256){\r\n        return weiOwed[_addr];\r\n    }\r\n    \r\n    function satFreeze(address _addr, uint256 _wei, uint _sat) private {\r\n        uint256 amount = _wei * rate();\r\n        balances[0] = balances[0].sub(amount);\r\n        \r\n        satOwed[_addr] += _sat;\r\n        satTokensOwed[_addr] += amount;    \r\n    }\r\n\r\n    function satTransfer(address _addr, uint256 _wei, uint _sat) private {\r\n        uint256 amount = _wei * rate();\r\n        balances[0] = balances[0].sub(amount);\r\n        \r\n        token.transfer(_addr, amount);\r\n        TokenPurchase(_addr, _addr, _wei, amount);\r\n        satRaised += _sat;\r\n    }\r\n\r\n    function buyForBtc(\r\n        address _addr,\r\n        uint256 _sat,\r\n        uint256 _satOwed,\r\n        uint256 _wei,\r\n        uint256 _weiOwed\r\n    ) onlyOwner withinPeriod public {\r\n        require(_addr != address(0));\r\n        \r\n        satFreeze(_addr, _weiOwed, _satOwed);\r\n        satTransfer(_addr, _wei, _sat);\r\n    }\r\n    \r\n    function refundWei(address _addr, uint256 _amount) onlyOwner public returns (bool){\r\n        _addr.transfer(_amount);\r\n        balances[0] += weiTokensOwed[_addr];\r\n        weiTokensOwed[_addr] = 0;\r\n        weiOwed[_addr] = 0;\r\n        return true;\r\n    }\r\n  \r\n    function refundedSat(address _addr) onlyOwner public returns (bool){\r\n        balances[0] += satTokensOwed[_addr];\r\n        satTokensOwed[_addr] = 0;\r\n        satOwed[_addr] = 0;\r\n        return true;\r\n    }\r\n    \r\n    function sendOtherTokens(\r\n        uint8 _index,\r\n        address _addr,\r\n        uint256 _amount\r\n    ) onlyOwner public {\r\n        require(_addr!=address(0));\r\n\r\n        if (_index==uint8(TokenTypes.team) && now<teamUnfreezeDate) {\r\n            uint256 limit = balances[uint8(TokenTypes.team)].sub(teamFrozenTokens);\r\n            require(_amount<=limit);\r\n        }\r\n        \r\n        token.transfer(_addr, _amount);\r\n        balances[_index] = balances[_index].sub(_amount);\r\n        TokenPurchase(owner, _addr, 0, _amount);\r\n    }\r\n    \r\n    function rsrvToSale(uint256 _amount) onlyOwner public {\r\n        balances[uint8(TokenTypes.reserve)] = balances[uint8(TokenTypes.reserve)].sub(_amount);\r\n        balances[0] += _amount;\r\n    }\r\n    \r\n    function forwardFunds(uint256 amount) onlyOwner public {\r\n        wallet.transfer(amount);\r\n    }\r\n    \r\n    function setTokenOwner(address _addr) onlyOwner public {\r\n        token.transferOwnership(_addr);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_totalSupply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"NitroToken","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000006342fd08f00f6378000000","Library":"","SwarmSource":"bzzr://7809176de79107567cfefd6120fcbdccecb97d64f357519c8c4300200093f811"}]}