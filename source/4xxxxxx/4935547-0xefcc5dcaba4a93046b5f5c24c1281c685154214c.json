{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.0;\r\n\r\ncontract CrypteloERC20{\r\n  function transfer(address to, uint amount);\r\n}\r\n\r\ncontract CrypteloPreSale {\r\n    using SafeMath for uint256;\r\n    mapping (address => bool) private owners;\r\n    mapping (address => uint) private WhiteListed; \r\n    //if 1 its the first group, if 2 second group\r\n    //1st group minimum = 0.1 Ether\r\n    //2st group minimum = 40 Ether\r\n    \r\n    mapping (address => uint256) private vestedTokens;\r\n    mapping (address => uint256) private dateInvested;\r\n    mapping (address => uint256) private firstDeadline;\r\n\r\n    uint private firstGminimumWeiAmount =  100000000000000000; //0.1 ether\r\n    uint private secondGminimumWeiAmount = 40000000000000000000; //40 ether\r\n    uint public weiHardCap = 3625000000000000000000; //3625 ether\r\n    uint public weiRaised = 0;\r\n    uint private weiLeft = weiHardCap;\r\n    uint private CRLTotal = 9062500000000000;\r\n    uint private CRLToSell = CRLTotal.div(2);\r\n    uint private totalVesting = 0;\r\n    uint private totalCRLDistributed = 0;\r\n    uint private CRLLeft = CRLTotal;\r\n    uint public CRLperEther = 1250000000000; //with full decimals\r\n    uint public CRLperMicroEther = CRLperEther.div(1000000);\r\n    \r\n    \r\n    address public CrypteloERC20Address = 0x7123027d76a5135e66b3a365efaba2b55de18a62;\r\n    address private forwardFundsWallet = 0xd6c56d07665D44159246517Bb4B2aC9bBeb040cf;\r\n    \r\n    \r\n    uint firstTimeOffset = 1 years;\r\n\r\n    //events\r\n    event eRefund(address _addr, uint _weiAmount, string where);\r\n    event eTokensToSend(address _addr, uint _CRLTokens);\r\n    event eSendTokens(address _addr, uint _amount);\r\n\r\n    \r\n    \r\n    function CrypteloPreSale(){\r\n        owners[msg.sender] = true;\r\n    }\r\n\r\n    function () payable {\r\n        uint amountEthWei = msg.value;\r\n        address sender = msg.sender;\r\n        uint totalAmountWei;\r\n        uint tokensToSend = 0;\r\n        uint limit = 0;\r\n\r\n        if ( WhiteListed[sender] == 0 || amountEthWei > weiLeft){\r\n            refund(sender, amountEthWei);\r\n            eRefund(sender, amountEthWei, \"L 58\");\r\n        }else{\r\n            if(WhiteListed[sender] == 1){ //sender is first group\r\n                limit = firstGminimumWeiAmount;\r\n            }else{\r\n                limit = secondGminimumWeiAmount;\r\n            }\r\n            if(amountEthWei >= limit){\r\n                uint amountMicroEther = amountEthWei.div(1000000000000);\r\n                tokensToSend = amountMicroEther.mul(CRLperMicroEther);\r\n                eTokensToSend(sender, tokensToSend);\r\n                if (totalCRLDistributed.add(tokensToSend) <= CRLToSell){\r\n                    sendTokens(sender, tokensToSend);\r\n                    totalCRLDistributed = totalCRLDistributed.add(tokensToSend);\r\n                    vestTokens(sender, tokensToSend); //vest the same amount\r\n                    forwardFunds(amountEthWei);\r\n                    weiRaised = weiRaised.add(amountEthWei);\r\n                    assert(weiLeft >= amountEthWei);\r\n                    weiLeft = weiLeft.sub(amountEthWei);\r\n                }else{\r\n                    refund(sender, amountEthWei);\r\n                    eRefund(sender, amountEthWei, \"L 84\");\r\n                }\r\n                \r\n            }else{\r\n                refund(sender, amountEthWei);\r\n                eRefund(sender, amountEthWei, \"L 75\");\r\n            }\r\n        }\r\n    }\r\n    \r\n    \r\n    function forwardFunds(uint _amountEthWei) private{\r\n        forwardFundsWallet.send(_amountEthWei);  //find balance\r\n    }\r\n    \r\n    function getTotalVesting() public returns (uint _totalvesting){\r\n        return totalVesting;\r\n    }\r\n    \r\n    function getTotalDistributed() public returns (uint _totalvesting){\r\n        return totalCRLDistributed;\r\n    }\r\n    \r\n    function vestTokens(address _addr, uint _amountCRL) private returns (bool _success){\r\n        totalVesting = totalVesting.add(_amountCRL);\r\n        vestedTokens[_addr] = _amountCRL;  \r\n        dateInvested[_addr] = now;\r\n        firstDeadline[_addr] = now.add(firstTimeOffset);\r\n    }\r\n    function sendTokens(address _to, uint _amountCRL) private returns (address _addr, uint _amount){\r\n        //invoke call on token address\r\n       CrypteloERC20 _crypteloerc20;\r\n        _crypteloerc20 = CrypteloERC20(CrypteloERC20Address);\r\n        _crypteloerc20.transfer(_to, _amountCRL);\r\n        eSendTokens(_to, _amountCRL);\r\n    }\r\n    \r\n    function checkMyTokens() public returns (uint256 _CRLtokens) {\r\n        return vestedTokens[msg.sender];\r\n    }\r\n    \r\n    function checkMyVestingPeriod() public returns (uint256 _first){\r\n        return (firstDeadline[msg.sender]);\r\n    }\r\n    \r\n    function claimTokens(address _addr){ //add wallet here\r\n        uint amount = 0;\r\n\r\n        if (dateInvested[_addr] > 0 && vestedTokens[_addr] > 0 && now > firstDeadline[_addr]){\r\n            amount = amount.add(vestedTokens[_addr]); //allow half of the tokens to be transferred\r\n            vestedTokens[_addr] = 0;\r\n            if (amount > 0){\r\n                //transfer amount to owner\r\n                sendTokens(msg.sender, amount); \r\n                totalVesting = totalVesting.sub(amount);\r\n            }\r\n        }\r\n    }\r\n     \r\n    function refund(address _sender, uint _amountWei) private{\r\n        //refund ether to sender minus transaction fees\r\n        _sender.send(_amountWei);\r\n    }\r\n    function addWhiteList(address _addr, uint group){\r\n        if (owners[msg.sender] && group <= 2){\r\n            WhiteListed[_addr] = group; \r\n        }\r\n    }\r\n    \r\n    function removeWhiteList(address _addr){\r\n        if (owners[msg.sender]){\r\n            WhiteListed[_addr] = 0; \r\n        }\r\n    }\r\n    \r\n    function isWhiteList(address _addr) public returns (uint _group){\r\n        return WhiteListed[_addr];\r\n    }\r\n    \r\n    function withdrawDistributionCRL(){\r\n        if (owners[msg.sender]){\r\n            uint amount = CRLTotal.sub(totalCRLDistributed).sub(totalCRLDistributed);\r\n            sendTokens(msg.sender, amount);\r\n        }\r\n    }\r\n    \r\n    function withdrawAllEther(){\r\n        if (owners[msg.sender]){\r\n            msg.sender.send(this.balance);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"weiHardCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"removeWhiteList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CrypteloERC20Address\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawAllEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawDistributionCRL\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getTotalDistributed\",\"outputs\":[{\"name\":\"_totalvesting\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"checkMyTokens\",\"outputs\":[{\"name\":\"_CRLtokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"group\",\"type\":\"uint256\"}],\"name\":\"addWhiteList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CRLperMicroEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"checkMyVestingPeriod\",\"outputs\":[{\"name\":\"_first\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CRLperEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"claimTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getTotalVesting\",\"outputs\":[{\"name\":\"_totalvesting\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isWhiteList\",\"outputs\":[{\"name\":\"_group\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_weiAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"where\",\"type\":\"string\"}],\"name\":\"eRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_CRLTokens\",\"type\":\"uint256\"}],\"name\":\"eTokensToSend\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"eSendTokens\",\"type\":\"event\"}]","ContractName":"CrypteloPreSale","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://bd93925f7cd91036248319572dede6c1f86b1abc2bbc64f75f75d2cb0721fdab"}]}