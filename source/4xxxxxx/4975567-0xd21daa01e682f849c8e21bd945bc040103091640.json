{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf( address _owner ) public view returns (uint balance);\r\n    function allowance( address _owner, address _spender ) public view returns (uint allowance_);\r\n\r\n    function transfer( address _to, uint _value)public returns (bool success);\r\n    function transferFrom( address _from, address _to, uint _value)public returns (bool success);\r\n    function approve( address _spender, uint _value )public returns (bool success);\r\n\r\n    event Transfer( address indexed from, address indexed to, uint value);\r\n    event Approval( address indexed _owner, address indexed _spender, uint value);\r\n}\r\n\r\n\r\ncontract UTEMIS is ERC20{            \r\n\r\n        uint8 public constant TOKEN_DECIMAL     = 18;        \r\n        uint256 public constant TOKEN_ESCALE    = 1 * 10 ** uint256(TOKEN_DECIMAL); \r\n                                              \r\n        uint256 public constant TOTAL_SUPPLY    = 1000000000000 * TOKEN_ESCALE; // 1000000000000000000000000 Smart contract UNITS | 1.000.000.000.000,000000000000 Ethereum representation\r\n        uint256 public constant ICO_SUPPLY      = 250000000000 * TOKEN_ESCALE;  // 250000000000000000000000 Smart contract UNITS  | 200.000.000.000,000000000000 Ethereum representation\r\n\r\n        uint public constant MIN_ACCEPTED_VALUE = 50000000000000000 wei;\r\n        uint public constant VALUE_OF_UTS       = 666666599999 wei;\r\n\r\n        uint public constant START_ICO          = 1518714000; // 15 Feb 2018 17:00:00 GMT | 15 Feb 2018 18:00:00 GMT+1\r\n\r\n        string public constant TOKEN_NAME       = \"UTEMIS\";\r\n        string public constant TOKEN_SYMBOL     = \"UTS\";\r\n\r\n    /*------------------- Finish public constants -------------------*/\r\n\r\n\r\n    /******************** Start private NO-Constants variables ********************/\r\n    \r\n        uint[4]  private bonusTime             = [14 days , 45 days , 74 days];        \r\n        uint8[4] private bonusBenefit          = [uint8(50)  , uint8(30)   , uint8(10)];\r\n        uint8[4] private bonusPerInvestion_10  = [uint8(25)  , uint8(15)   , uint8(5)];\r\n        uint8[4] private bonusPerInvestion_50  = [uint8(50)  , uint8(30)   , uint8(20)];\r\n    \r\n    /*------------------- Finish private NO-Constants variables -------------------*/\r\n\r\n\r\n    /******************** Start public NO-Constants variables ********************/        \r\n       \r\n        address public owner;\r\n        address public beneficiary;            \r\n        uint public ethersCollecteds;\r\n        uint public tokensSold;\r\n        uint256 public totalSupply = TOTAL_SUPPLY;\r\n        bool public icoStarted;            \r\n        mapping(address => uint256) public balances;    \r\n        mapping(address => Investors) public investorsList;\r\n        mapping(address => mapping (address => uint256)) public allowed;\r\n        address[] public investorsAddress;    \r\n        string public name     = TOKEN_NAME;\r\n        uint8 public decimals  = TOKEN_DECIMAL;\r\n        string public symbol   = TOKEN_SYMBOL;\r\n   \r\n    /*------------------- Finish public NO-Constants variables -------------------*/    \r\n\r\n    struct Investors{\r\n        uint256 amount;\r\n        uint when;\r\n    }\r\n\r\n    event Transfer(address indexed from , address indexed to , uint256 value);\r\n    event Approval(address indexed _owner , address indexed _spender , uint256 _value);\r\n    event Burn(address indexed from, uint256 value);\r\n    event FundTransfer(address backer , uint amount , address investor);\r\n\r\n    //Safe math\r\n    function safeSub(uint a , uint b) internal pure returns (uint){assert(b <= a);return a - b;}  \r\n    function safeAdd(uint a , uint b) internal pure returns (uint){uint c = a + b;assert(c>=a && c>=b);return c;}\r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    modifier icoIsStarted(){\r\n        require(icoStarted == true);        \r\n        require(now >= START_ICO);      \r\n        _;\r\n    }\r\n\r\n    modifier icoIsStopped(){\r\n        require(icoStarted == false); \r\n        _;\r\n    }\r\n\r\n    modifier minValue(){\r\n        require(msg.value >= MIN_ACCEPTED_VALUE);\r\n        _;\r\n    }\r\n\r\n    function UTEMIS() public{\r\n        balances[msg.sender] = totalSupply;\r\n        owner               = msg.sender;        \r\n    }\r\n\r\n\r\n    /**\r\n     * ERC20\r\n     */\r\n    function balanceOf(address _owner) public view returns(uint256 balance){\r\n        return balances[_owner];\r\n    }\r\n\r\n    /**\r\n     * ERC20\r\n     */\r\n    function totalSupply() constant public returns(uint256 supply){\r\n        return totalSupply;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * For transfer tokens. Internal use, only can executed by this contract ERC20\r\n     * ERC20\r\n     * @param  _from         Source address\r\n     * @param  _to           Destination address\r\n     * @param  _value        Amount of tokens to send\r\n     */\r\n    function _transfer(address _from , address _to , uint _value) internal{        \r\n        require(_to != 0x0);                                                          //Prevent send tokens to 0x0 address        \r\n        require(balances[_from] >= _value);                                           //Check if the sender have enough tokens        \r\n        require(balances[_to] + _value > balances[_to]);                              //Check for overflows        \r\n        balances[_from]         = safeSub(balances[_from] , _value);                  //Subtract from the source ( sender )        \r\n        balances[_to]           = safeAdd(balances[_to]   , _value);                  //Add tokens to destination        \r\n        uint previousBalance    = balances[_from] + balances[_to];                    //To make assert        \r\n        Transfer(_from , _to , _value);                                               //Fire event for clients        \r\n        assert(balances[_from] + balances[_to] == previousBalance);                   //Check the assert\r\n    }\r\n\r\n\r\n    /**\r\n     * Commonly transfer tokens \r\n     * ERC20\r\n     * @param  _to           Destination address\r\n     * @param  _value        Amount of tokens to send\r\n     */\r\n    function transfer(address _to , uint _value) public returns (bool success){        \r\n        _transfer(msg.sender , _to , _value);\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     * Transfer token from address to another address that's allowed to. \r\n     * ERC20\r\n     * @param _from          Source address\r\n     * @param _to            Destination address\r\n     * @param _value         Amount of tokens to send\r\n     */   \r\n    function transferFrom(address _from , address _to , uint256 _value) public returns (bool success){\r\n        if(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            _transfer(_from , _to , _value);\r\n            allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender] , _value);\r\n            return true;\r\n        }else{\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Approve spender to transfer amount of tokens from your address ERC20\r\n     * ERC20\r\n     * @param _spender       Address that can transfer tokens from your address\r\n     * @param _value         Amount of tokens that can be sended by spender\r\n     */   \r\n    function approve(address _spender , uint256 _value) public returns (bool success){\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender , _spender , _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns the amount of tokens allowed by owner to spender ERC20\r\n     * ERC20\r\n     * @param _owner         Source address that allow's spend tokens\r\n     * @param _spender       Address that can transfer tokens form allowed     \r\n     */   \r\n    function allowance(address _owner , address _spender) public view returns(uint256 allowance_){\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n\r\n    /**\r\n     * Get investors info\r\n     *\r\n     * @return []                Returns an array with address of investors, amount invested and when invested\r\n     */\r\n    function getInvestors() constant public returns(address[] , uint[] , uint[]){\r\n        uint length = investorsAddress.length;                                             //Length of array\r\n        address[] memory addr = new address[](length);\r\n        uint[] memory amount  = new uint[](length);\r\n        uint[] memory when    = new uint[](length);\r\n        for(uint i = 0; i < length; i++){\r\n            address key = investorsAddress[i];\r\n            addr[i]     = key;\r\n            amount[i]   = investorsList[key].amount;\r\n            when[i]     = investorsList[key].when;\r\n        }\r\n        return (addr , amount , when);        \r\n    }\r\n\r\n\r\n    /**\r\n     * Get amount of bonus to apply\r\n     *\r\n     * @param _ethers              Amount of ethers invested, for calculation the bonus     \r\n     * @return uint                Returns a % of bonification to apply\r\n     */\r\n    function getBonus(uint _ethers) public view returns(uint8){        \r\n        uint8 _bonus  = 0;                                                          //Assign bonus to \r\n        uint8 _bonusPerInvestion = 0;\r\n        uint  starter = now - START_ICO;                                            //To control end time of bonus\r\n        for(uint i = 0; i < bonusTime.length; i++){                                 //For loop\r\n            if(starter <= bonusTime[i]){                                            //If the starter are greater than bonusTime, the bonus will be 0                \r\n                if(_ethers > 10 ether && _ethers <= 50 ether){\r\n                    _bonusPerInvestion = bonusPerInvestion_10[i];\r\n                }\r\n                if(_ethers > 50 ether){\r\n                    _bonusPerInvestion = bonusPerInvestion_50[i];\r\n                }\r\n                _bonus = bonusBenefit[i];                                           //Asign amount of bonus to bonus_ variable                                \r\n                break;                                                              //Break the loop\r\n\r\n            }\r\n        }        \r\n        return _bonus + _bonusPerInvestion;\r\n    }\r\n\r\n    /**\r\n     * Calculate the amount of tokens to sends depeding on the amount of ethers received\r\n     *\r\n     * @param  _ethers              Amount of ethers for convert to tokens\r\n     * @return uint                 Returns the amount of tokens to send\r\n     */\r\n    function getTokensToSend(uint _ethers) public view returns (uint){\r\n        uint tokensToSend  = 0;                                                     //Assign tokens to send to 0                                            \r\n        uint8 bonus        = getBonus(_ethers);                                     //Get amount of bonification                                    \r\n        uint ethToTokens   = (_ethers * 10 ** uint256(TOKEN_DECIMAL)) / VALUE_OF_UTS;                                //Make the conversion, divide amount of ethers by value of each UTS                \r\n        uint amountBonus   = ethToTokens / 100 * bonus;\r\n             tokensToSend  = ethToTokens + amountBonus;\r\n        return tokensToSend;\r\n    }\r\n\r\n    /**\r\n     * Fallback when the contract receives ethers\r\n     *\r\n     */\r\n    function () payable public icoIsStarted minValue{                              \r\n        uint amount_actually_invested = investorsList[msg.sender].amount;           //Get the actually amount invested\r\n        \r\n        if(amount_actually_invested == 0){                                          //If amount invested are equal to 0, will add like new investor\r\n            uint index                = investorsAddress.length++;\r\n            investorsAddress[index]   = msg.sender;\r\n            investorsList[msg.sender] = Investors(msg.value , now);                 //Store investors info        \r\n        }\r\n        \r\n        if(amount_actually_invested > 0){                                           //If amount invested are greater than 0\r\n            investorsList[msg.sender].amount += msg.value;                          //Increase the amount invested\r\n            investorsList[msg.sender].when    = now;                                //Change the last time invested\r\n        }\r\n\r\n        \r\n        uint tokensToSend = getTokensToSend(msg.value);                             //Calc the tokens to send depending on ethers received\r\n        tokensSold += tokensToSend;        \r\n        require(balances[owner] >= tokensToSend);\r\n        \r\n        _transfer(owner , msg.sender , tokensToSend);                               //Transfer tokens to investor                                \r\n        ethersCollecteds   += msg.value;\r\n\r\n        if(beneficiary == address(0)){\r\n            beneficiary = owner;\r\n        }\r\n        beneficiary.transfer(msg.value);\r\n        FundTransfer(owner , msg.value , msg.sender);                               //Fire events for clients\r\n    }\r\n\r\n\r\n    /**\r\n     * Start the ico manually\r\n     *     \r\n     */\r\n    function startIco() public onlyOwner{\r\n        icoStarted = true;                                                         //Set the ico started\r\n    }\r\n\r\n    /**\r\n     * Stop the ico manually\r\n     *\r\n     */\r\n    function stopIco() public onlyOwner{\r\n        icoStarted = false;                                                        //Set the ico stopped\r\n    }\r\n\r\n\r\n    function setBeneficiary(address _beneficiary) public onlyOwner{\r\n        beneficiary = _beneficiary;\r\n    }\r\n    \r\n    function destroyContract()external onlyOwner{\r\n        selfdestruct(owner);\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"ICO_SUPPLY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroyContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoStarted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_DECIMAL\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"supply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_NAME\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"START_ICO\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"setBeneficiary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_SYMBOL\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_ethers\",\"type\":\"uint256\"}],\"name\":\"getBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_ESCALE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stopIco\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startIco\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_ethers\",\"type\":\"uint256\"}],\"name\":\"getTokensToSend\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOTAL_SUPPLY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VALUE_OF_UTS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInvestors\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethersCollecteds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_ACCEPTED_VALUE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"investorsAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"allowance_\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"investorsList\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"when\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"backer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"FundTransfer\",\"type\":\"event\"}]","ContractName":"UTEMIS","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://d4b1bc447572732d3cbf198eda3f7813b26e20433170c3a23c90970206fb698f"}]}