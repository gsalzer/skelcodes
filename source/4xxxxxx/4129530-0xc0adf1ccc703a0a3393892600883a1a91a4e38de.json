{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\ncontract BTCRelay {\r\n    function getLastBlockHeight() returns (int);\r\n    function getBlockchainHead() returns (int);\r\n    function getFeeAmount(int blockHash) returns (int);\r\n    function getBlockHeader(int blockHash) returns (bytes32[3]);\r\n}\r\n\r\ncontract PoissonData {\r\n    function lookup(int blocks) constant returns (uint);\r\n}\r\n\r\ncontract Escrow {\r\n    function deposit(address recipient) payable;\r\n}\r\n\r\ncontract EthereumLottery {\r\n    uint constant INACTIVITY_TIMEOUT = 2 weeks;\r\n    uint constant GAS_LIMIT = 300000;\r\n\r\n    struct Lottery {\r\n        uint jackpot;\r\n        int decidingBlock;\r\n        uint numTickets;\r\n        uint numTicketsSold;\r\n        uint ticketPrice;\r\n        uint cutoffTimestamp;\r\n        int winningTicket;\r\n        address winner;\r\n        uint finalizationBlock;\r\n        address finalizer;\r\n        string message;\r\n        mapping (uint => address) tickets;\r\n        int nearestKnownBlock;\r\n        int nearestKnownBlockHash;\r\n    }\r\n\r\n    address public owner;\r\n    address public admin;\r\n    address public proposedOwner;\r\n\r\n    int public id = -1;\r\n    uint public lastInitTimestamp;\r\n    uint public lastSaleTimestamp;\r\n\r\n    uint public recentActivityIdx;\r\n    uint[1000] public recentActivity;\r\n\r\n    mapping (int => Lottery) public lotteries;\r\n\r\n    address public btcRelay;\r\n    address public poissonData;\r\n    address public escrow;\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdminOrOwner {\r\n        require(msg.sender == owner || msg.sender == admin);\r\n        _;\r\n    }\r\n\r\n    modifier afterInitialization {\r\n        require(id >= 0);\r\n        _;\r\n    }\r\n\r\n    function EthereumLottery(address _btcRelay,\r\n                             address _poissonData,\r\n                             address _escrow) {\r\n        owner = msg.sender;\r\n        admin = msg.sender;\r\n        btcRelay = _btcRelay;\r\n        poissonData = _poissonData;\r\n        escrow = _escrow;\r\n    }\r\n\r\n    function needsInitialization() constant returns (bool) {\r\n        return id == -1 || lotteries[id].finalizationBlock > 0;\r\n    }\r\n\r\n    function initLottery(uint _jackpot, uint _numTickets,\r\n                         uint _ticketPrice, int _durationInBlocks)\r\n             payable onlyAdminOrOwner {\r\n        require(needsInitialization());\r\n        require(msg.value > 0);\r\n        require(msg.value == _jackpot);\r\n        require(_numTickets * _ticketPrice > _jackpot);\r\n\r\n        // Look up precomputed timespan in seconds where the\r\n        // probability for n or more blocks occuring within\r\n        // that timespan is just 1 %. This is based on\r\n        // assuming an actual block time of 9 minutes. We\r\n        // can use this data to figure out for how long it\r\n        // is safe to keep selling tickets.\r\n        uint ticketSaleDuration =\r\n            PoissonData(poissonData).lookup(_durationInBlocks - 1);\r\n        require(ticketSaleDuration > 0);\r\n\r\n        id += 1;\r\n        lotteries[id].jackpot = _jackpot;\r\n        lotteries[id].decidingBlock =\r\n            BTCRelay(btcRelay).getLastBlockHeight() + _durationInBlocks;\r\n        lotteries[id].numTickets = _numTickets;\r\n        lotteries[id].ticketPrice = _ticketPrice;\r\n        lotteries[id].cutoffTimestamp = now + ticketSaleDuration;\r\n        lotteries[id].winningTicket = -1;\r\n\r\n        lastInitTimestamp = now;\r\n    }\r\n\r\n    function buyTickets(uint[] _tickets)\r\n             payable afterInitialization {\r\n        int blockHeight = BTCRelay(btcRelay).getLastBlockHeight();\r\n        require(blockHeight + 1 < lotteries[id].decidingBlock);\r\n        require(now < lotteries[id].cutoffTimestamp);\r\n\r\n        require(_tickets.length > 0);\r\n        require(msg.value == _tickets.length * lotteries[id].ticketPrice);\r\n\r\n        for (uint i = 0; i < _tickets.length; i++) {\r\n            uint ticket = _tickets[i];\r\n            require(ticket >= 0);\r\n            require(ticket < lotteries[id].numTickets);\r\n            require(lotteries[id].tickets[ticket] == 0);\r\n\r\n            lotteries[id].tickets[ticket] = msg.sender;\r\n            recentActivity[recentActivityIdx] = ticket;\r\n\r\n            recentActivityIdx += 1;\r\n            if (recentActivityIdx >= recentActivity.length) {\r\n                recentActivityIdx = 0;\r\n            }\r\n        }\r\n        lotteries[id].numTicketsSold += _tickets.length;\r\n        lastSaleTimestamp = now;\r\n\r\n        // Maybe shorten ticket sale timespan if we are running ahead.\r\n        int remainingDurationInBlocks =\r\n            lotteries[id].decidingBlock - blockHeight;\r\n        uint ticketSaleDuration =\r\n            PoissonData(poissonData).lookup(remainingDurationInBlocks - 1);\r\n        if (now + ticketSaleDuration < lotteries[id].cutoffTimestamp) {\r\n            lotteries[id].cutoffTimestamp = now + ticketSaleDuration;\r\n        }\r\n    }\r\n\r\n    function needsFinalization()\r\n             afterInitialization constant returns (bool) {\r\n        int blockHeight = BTCRelay(btcRelay).getLastBlockHeight();\r\n        return blockHeight >= lotteries[id].decidingBlock + 6 &&\r\n               lotteries[id].finalizationBlock == 0;\r\n    }\r\n\r\n    function finalizeLottery(uint _steps)\r\n             afterInitialization {\r\n        require(needsFinalization());\r\n\r\n        if (lotteries[id].nearestKnownBlock != lotteries[id].decidingBlock) {\r\n            walkTowardsBlock(_steps);\r\n        } else {\r\n            int winningTicket = lotteries[id].nearestKnownBlockHash %\r\n                                int(lotteries[id].numTickets);\r\n            address winner = lotteries[id].tickets[uint(winningTicket)];\r\n\r\n            lotteries[id].winningTicket = winningTicket;\r\n            lotteries[id].winner = winner;\r\n            lotteries[id].finalizationBlock = block.number;\r\n            lotteries[id].finalizer = tx.origin;\r\n\r\n            if (winner != 0) {\r\n                uint value = lotteries[id].jackpot;\r\n                bool successful = winner.call.gas(GAS_LIMIT).value(value)();\r\n                if (!successful) {\r\n                    Escrow(escrow).deposit.value(value)(winner);\r\n                }\r\n            }\r\n\r\n            var _ = admin.call.gas(GAS_LIMIT).value(this.balance)();\r\n        }\r\n    }\r\n\r\n    function walkTowardsBlock(uint _steps) internal {\r\n        int blockHeight;\r\n        int blockHash;\r\n        if (lotteries[id].nearestKnownBlock == 0) {\r\n            blockHeight = BTCRelay(btcRelay).getLastBlockHeight();\r\n            blockHash = BTCRelay(btcRelay).getBlockchainHead();\r\n        } else {\r\n            blockHeight = lotteries[id].nearestKnownBlock;\r\n            blockHash = lotteries[id].nearestKnownBlockHash;\r\n        }\r\n\r\n        // Walk only a few steps to keep an upper limit on gas costs.\r\n        for (uint step = 0; step < _steps; step++) {\r\n            // We expect free access to BTCRelay.\r\n            int fee = BTCRelay(btcRelay).getFeeAmount(blockHash);\r\n            require(fee == 0);\r\n\r\n            bytes32 blockHeader =\r\n                BTCRelay(btcRelay).getBlockHeader(blockHash)[2];\r\n            bytes32 temp;\r\n\r\n            assembly {\r\n                let x := mload(0x40)\r\n                mstore(x, blockHeader)\r\n                temp := mload(add(x, 0x04))\r\n            }\r\n\r\n            blockHeight -= 1;\r\n            blockHash = 0;\r\n            for (uint i = 0; i < 32; i++) {\r\n                blockHash = blockHash | int(temp[uint(i)]) * int(256 ** i);\r\n            }\r\n\r\n            if (blockHeight == lotteries[id].decidingBlock) { break; }\r\n        }\r\n\r\n        // Store the progress to pick up from there next time.\r\n        lotteries[id].nearestKnownBlock = blockHeight;\r\n        lotteries[id].nearestKnownBlockHash = blockHash;\r\n    }\r\n\r\n    function getMessageLength(string _message) constant returns (uint) {\r\n        return bytes(_message).length;\r\n    }\r\n\r\n    function setMessage(int _id, string _message)\r\n             afterInitialization {\r\n        require(lotteries[_id].winner != 0);\r\n        require(lotteries[_id].winner == msg.sender);\r\n        require(getMessageLength(_message) <= 500);\r\n        lotteries[_id].message = _message;\r\n    }\r\n\r\n    function getLotteryDetailsA(int _id)\r\n             constant returns (int _actualId, uint _jackpot,\r\n                               int _decidingBlock,\r\n                               uint _numTickets, uint _numTicketsSold,\r\n                               uint _lastSaleTimestamp, uint _ticketPrice,\r\n                               uint _cutoffTimestamp) {\r\n        if (_id == -1) {\r\n            _actualId = id;\r\n        } else {\r\n            _actualId = _id;\r\n        }\r\n        _jackpot = lotteries[_actualId].jackpot;\r\n        _decidingBlock = lotteries[_actualId].decidingBlock;\r\n        _numTickets = lotteries[_actualId].numTickets;\r\n        _numTicketsSold = lotteries[_actualId].numTicketsSold;\r\n        _lastSaleTimestamp = lastSaleTimestamp;\r\n        _ticketPrice = lotteries[_actualId].ticketPrice;\r\n        _cutoffTimestamp = lotteries[_actualId].cutoffTimestamp;\r\n    }\r\n\r\n    function getLotteryDetailsB(int _id)\r\n             constant returns (int _actualId,\r\n                               int _winningTicket, address _winner,\r\n                               uint _finalizationBlock, address _finalizer,\r\n                               string _message,\r\n                               int _prevLottery, int _nextLottery,\r\n                               int _blockHeight) {\r\n        if (_id == -1) {\r\n            _actualId = id;\r\n        } else {\r\n            _actualId = _id;\r\n        }\r\n        _winningTicket = lotteries[_actualId].winningTicket;\r\n        _winner = lotteries[_actualId].winner;\r\n        _finalizationBlock = lotteries[_actualId].finalizationBlock;\r\n        _finalizer = lotteries[_actualId].finalizer;\r\n        _message = lotteries[_actualId].message;\r\n\r\n        if (_actualId == 0) {\r\n            _prevLottery = -1;\r\n        } else {\r\n            _prevLottery = _actualId - 1;\r\n        }\r\n        if (_actualId == id) {\r\n            _nextLottery = -1;\r\n        } else {\r\n            _nextLottery = _actualId + 1;\r\n        }\r\n\r\n        _blockHeight = BTCRelay(btcRelay).getLastBlockHeight();\r\n    }\r\n\r\n    function getTicketDetails(int _id, uint _offset, uint _n, address _addr)\r\n             constant returns (uint8[] details) {\r\n        require(_offset + _n <= lotteries[_id].numTickets);\r\n\r\n        details = new uint8[](_n);\r\n        for (uint i = 0; i < _n; i++) {\r\n            address addr = lotteries[_id].tickets[_offset + i];\r\n            if (addr == _addr && _addr != 0) {\r\n                details[i] = 2;\r\n            } else if (addr != 0) {\r\n                details[i] = 1;\r\n            } else {\r\n                details[i] = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    function getTicketOwner(int _id, uint _ticket) constant returns (address) {\r\n        require(_id >= 0);\r\n        return lotteries[_id].tickets[_ticket];\r\n    }\r\n\r\n    function getRecentActivity()\r\n             constant returns (int _id, uint _idx, uint[1000] _recentActivity) {\r\n        _id = id;\r\n        _idx = recentActivityIdx;\r\n        for (uint i = 0; i < recentActivity.length; i++) {\r\n            _recentActivity[i] = recentActivity[i];\r\n        }\r\n    }\r\n\r\n    function setAdmin(address _admin) onlyOwner {\r\n        admin = _admin;\r\n    }\r\n\r\n    function proposeOwner(address _owner) onlyOwner {\r\n        proposedOwner = _owner;\r\n    }\r\n\r\n    function acceptOwnership() {\r\n        require(proposedOwner != 0);\r\n        require(msg.sender == proposedOwner);\r\n        owner = proposedOwner;\r\n    }\r\n\r\n    function destruct() onlyOwner {\r\n        require(now - lastInitTimestamp > INACTIVITY_TIMEOUT);\r\n        selfdestruct(owner);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"lastInitTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"poissonData\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"name\":\"lotteries\",\"outputs\":[{\"name\":\"jackpot\",\"type\":\"uint256\"},{\"name\":\"decidingBlock\",\"type\":\"int256\"},{\"name\":\"numTickets\",\"type\":\"uint256\"},{\"name\":\"numTicketsSold\",\"type\":\"uint256\"},{\"name\":\"ticketPrice\",\"type\":\"uint256\"},{\"name\":\"cutoffTimestamp\",\"type\":\"uint256\"},{\"name\":\"winningTicket\",\"type\":\"int256\"},{\"name\":\"winner\",\"type\":\"address\"},{\"name\":\"finalizationBlock\",\"type\":\"uint256\"},{\"name\":\"finalizer\",\"type\":\"address\"},{\"name\":\"message\",\"type\":\"string\"},{\"name\":\"nearestKnownBlock\",\"type\":\"int256\"},{\"name\":\"nearestKnownBlockHash\",\"type\":\"int256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"recentActivity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destruct\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"int256\"},{\"name\":\"_offset\",\"type\":\"uint256\"},{\"name\":\"_n\",\"type\":\"uint256\"},{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getTicketDetails\",\"outputs\":[{\"name\":\"details\",\"type\":\"uint8[]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_message\",\"type\":\"string\"}],\"name\":\"getMessageLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"int256\"}],\"name\":\"getLotteryDetailsB\",\"outputs\":[{\"name\":\"_actualId\",\"type\":\"int256\"},{\"name\":\"_winningTicket\",\"type\":\"int256\"},{\"name\":\"_winner\",\"type\":\"address\"},{\"name\":\"_finalizationBlock\",\"type\":\"uint256\"},{\"name\":\"_finalizer\",\"type\":\"address\"},{\"name\":\"_message\",\"type\":\"string\"},{\"name\":\"_prevLottery\",\"type\":\"int256\"},{\"name\":\"_nextLottery\",\"type\":\"int256\"},{\"name\":\"_blockHeight\",\"type\":\"int256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRecentActivity\",\"outputs\":[{\"name\":\"_id\",\"type\":\"int256\"},{\"name\":\"_idx\",\"type\":\"uint256\"},{\"name\":\"_recentActivity\",\"type\":\"uint256[1000]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"recentActivityIdx\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"id\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_jackpot\",\"type\":\"uint256\"},{\"name\":\"_numTickets\",\"type\":\"uint256\"},{\"name\":\"_ticketPrice\",\"type\":\"uint256\"},{\"name\":\"_durationInBlocks\",\"type\":\"int256\"}],\"name\":\"initLottery\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"int256\"},{\"name\":\"_message\",\"type\":\"string\"}],\"name\":\"setMessage\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"proposeOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"needsInitialization\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"needsFinalization\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tickets\",\"type\":\"uint256[]\"}],\"name\":\"buyTickets\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proposedOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"btcRelay\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"int256\"}],\"name\":\"getLotteryDetailsA\",\"outputs\":[{\"name\":\"_actualId\",\"type\":\"int256\"},{\"name\":\"_jackpot\",\"type\":\"uint256\"},{\"name\":\"_decidingBlock\",\"type\":\"int256\"},{\"name\":\"_numTickets\",\"type\":\"uint256\"},{\"name\":\"_numTicketsSold\",\"type\":\"uint256\"},{\"name\":\"_lastSaleTimestamp\",\"type\":\"uint256\"},{\"name\":\"_ticketPrice\",\"type\":\"uint256\"},{\"name\":\"_cutoffTimestamp\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"escrow\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"int256\"},{\"name\":\"_ticket\",\"type\":\"uint256\"}],\"name\":\"getTicketOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_steps\",\"type\":\"uint256\"}],\"name\":\"finalizeLottery\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastSaleTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_btcRelay\",\"type\":\"address\"},{\"name\":\"_poissonData\",\"type\":\"address\"},{\"name\":\"_escrow\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"}]","ContractName":"EthereumLottery","CompilerVersion":"v0.4.14+commit.c2215d46","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000041f274c0023f83391de4e0733c609df5a124c3d4000000000000000000000000af34a44ebf712ab571730bd0768dcb93572e246e000000000000000000000000e28942df3b9502193a3547e6f6bad16ce63b1e2d","Library":"","SwarmSource":"bzzr://c9080d3aa280bbe7c6468341f0e034801223f91400f46316baa2280ff5fd6aee"}]}