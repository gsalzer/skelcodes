{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.17;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n// NOTE: BasicToken only has partial ERC20 support\r\ncontract Ico is BasicToken {\r\n  address owner;\r\n  uint256 public teamNum;\r\n  mapping(address => bool) team;\r\n\r\n  // expose these for ERC20 tools\r\n  string public constant name = \"LUNA\";\r\n  string public constant symbol = \"LUNA\";\r\n  uint8 public constant decimals = 18;\r\n\r\n  // Significant digits tokenPrecision\r\n  uint256 private constant tokenPrecision = 10e17;\r\n\r\n  // TODO: set this final, this equates to an amount\r\n  // in dollars.\r\n  uint256 public constant hardCap = 32000 * tokenPrecision;\r\n\r\n  // Tokens frozen supply\r\n  uint256 public tokensFrozen = 0;\r\n\r\n  uint256 public tokenValue = 1 * tokenPrecision;\r\n\r\n  // struct representing a dividends snapshot\r\n  struct DividendSnapshot {\r\n    uint256 totalSupply;\r\n    uint256 dividendsIssued;\r\n    uint256 managementDividends;\r\n  }\r\n  // An array of all the DividendSnapshot so far\r\n  DividendSnapshot[] dividendSnapshots;\r\n\r\n  // Mapping of user to the index of the last dividend that was awarded to zhie\r\n  mapping(address => uint256) lastDividend;\r\n\r\n  // Management fees share express as 100/%: eg. 20% => 100/20 = 5\r\n  uint256 public constant managementFees = 10;\r\n\r\n  // Assets under management in USD\r\n  uint256 public aum = 0;\r\n\r\n  // number of tokens investors will receive per eth invested\r\n  uint256 public tokensPerEth;\r\n\r\n  // Ico start/end timestamps, between which (inclusively) investments are accepted\r\n  uint public icoStart;\r\n  uint public icoEnd;\r\n\r\n  // drip percent in 100 / percentage\r\n  uint256 public dripRate = 50;\r\n\r\n  // current registred change address\r\n  address public currentSaleAddress;\r\n\r\n  // custom events\r\n  event Freeze(address indexed from, uint256 value);\r\n  event Participate(address indexed from, uint256 value);\r\n  event Reconcile(address indexed from, uint256 period, uint256 value);\r\n\r\n  /**\r\n   * ICO constructor\r\n   * Define ICO details and contribution period\r\n   */\r\n  function Ico(uint256 _icoStart, uint256 _icoEnd, address[] _team, uint256 _tokensPerEth) public {\r\n    // require (_icoStart >= now);\r\n    require (_icoEnd >= _icoStart);\r\n    require (_tokensPerEth > 0);\r\n\r\n    owner = msg.sender;\r\n\r\n    icoStart = _icoStart;\r\n    icoEnd = _icoEnd;\r\n    tokensPerEth = _tokensPerEth;\r\n\r\n    // initialize the team mapping with true when part of the team\r\n    teamNum = _team.length;\r\n    for (uint256 i = 0; i < teamNum; i++) {\r\n      team[_team[i]] = true;\r\n    }\r\n\r\n    // as a safety measure tempory set the sale address to something else than 0x0\r\n    currentSaleAddress = owner;\r\n  }\r\n\r\n  /**\r\n   * Modifiers\r\n   */\r\n  modifier onlyOwner() {\r\n    require (msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  modifier onlyTeam() {\r\n    require (team[msg.sender] == true);\r\n    _;\r\n  }\r\n\r\n  modifier onlySaleAddress() {\r\n    require (msg.sender == currentSaleAddress);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * Function allowing investors to participate in the ICO.\r\n   * Specifying the beneficiary will change who will receive the tokens.\r\n   * Fund tokens will be distributed based on amount of ETH sent by investor, and calculated\r\n   * using tokensPerEth value.\r\n   */\r\n  function participate(address beneficiary) public payable {\r\n    require (beneficiary != address(0));\r\n    require (now >= icoStart && now <= icoEnd);\r\n    require (msg.value > 0);\r\n\r\n    uint256 ethAmount = msg.value;\r\n    uint256 numTokens = ethAmount.mul(tokensPerEth);\r\n\r\n    require(totalSupply.add(numTokens) <= hardCap);\r\n\r\n    balances[beneficiary] = balances[beneficiary].add(numTokens);\r\n    totalSupply = totalSupply.add(numTokens);\r\n    tokensFrozen = totalSupply * 2;\r\n    aum = totalSupply;\r\n\r\n    owner.transfer(ethAmount);\r\n    // Our own custom event to monitor ICO participation\r\n    Participate(beneficiary, numTokens);\r\n    // Let ERC20 tools know of token hodlers\r\n    Transfer(0x0, beneficiary, numTokens);\r\n  }\r\n\r\n  /**\r\n   *\r\n   * We fallback to the partcipate function\r\n   */\r\n  function () external payable {\r\n     participate(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * Internal burn function, only callable by team\r\n   *\r\n   * @param _amount is the amount of tokens to burn.\r\n   */\r\n  function freeze(uint256 _amount) public onlySaleAddress returns (bool) {\r\n    reconcileDividend(msg.sender);\r\n    require(_amount <= balances[msg.sender]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_amount);\r\n    totalSupply = totalSupply.sub(_amount);\r\n    tokensFrozen = tokensFrozen.add(_amount);\r\n\r\n    aum = aum.sub(tokenValue.mul(_amount).div(tokenPrecision));\r\n\r\n    Freeze(msg.sender, _amount);\r\n    Transfer(msg.sender, 0x0, _amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Calculate the divends for the current period given the AUM profit\r\n   *\r\n   * @param totalProfit is the amount of total profit in USD.\r\n   */\r\n  function reportProfit(int256 totalProfit, address saleAddress) public onlyTeam returns (bool) {\r\n    // first we new dividends if this period was profitable\r\n    if (totalProfit > 0) {\r\n      // We only care about 50% of this, as the rest is reinvested right away\r\n      uint256 profit = uint256(totalProfit).mul(tokenPrecision).div(2);\r\n\r\n      // this will throw if there are not enough tokens\r\n      addNewDividends(profit);\r\n    }\r\n\r\n    // then we drip\r\n    drip(saleAddress);\r\n\r\n    // adjust AUM\r\n    aum = aum.add(uint256(totalProfit).mul(tokenPrecision));\r\n\r\n    // register the sale address\r\n    currentSaleAddress = saleAddress;\r\n\r\n    return true;\r\n  }\r\n\r\n\r\n  function drip(address saleAddress) internal {\r\n    uint256 dripTokens = tokensFrozen.div(dripRate);\r\n\r\n    tokensFrozen = tokensFrozen.sub(dripTokens);\r\n    totalSupply = totalSupply.add(dripTokens);\r\n    aum = aum.add(tokenValue.mul(dripTokens).div(tokenPrecision));\r\n\r\n    reconcileDividend(saleAddress);\r\n    balances[saleAddress] = balances[saleAddress].add(dripTokens);\r\n    Transfer(0x0, saleAddress, dripTokens);\r\n  }\r\n\r\n  /**\r\n   * Calculate the divends for the current period given the dividend\r\n   * amounts (USD * tokenPrecision).\r\n   */\r\n  function addNewDividends(uint256 profit) internal {\r\n    uint256 newAum = aum.add(profit); // 18 sig digits\r\n    tokenValue = newAum.mul(tokenPrecision).div(totalSupply); // 18 sig digits\r\n    uint256 totalDividends = profit.mul(tokenPrecision).div(tokenValue); // 18 sig digits\r\n    uint256 managementDividends = totalDividends.div(managementFees); // 17 sig digits\r\n    uint256 dividendsIssued = totalDividends.sub(managementDividends); // 18 sig digits\r\n\r\n    // make sure we have enough in the frozen fund\r\n    require(tokensFrozen >= totalDividends);\r\n\r\n    dividendSnapshots.push(DividendSnapshot(totalSupply, dividendsIssued, managementDividends));\r\n\r\n    // add the previous amount of given dividends to the totalSupply\r\n    totalSupply = totalSupply.add(totalDividends);\r\n    tokensFrozen = tokensFrozen.sub(totalDividends);\r\n  }\r\n\r\n  /**\r\n   * Withdraw all funds and kill fund smart contract\r\n   */\r\n  function liquidate() public onlyTeam returns (bool) {\r\n    selfdestruct(owner);\r\n  }\r\n\r\n\r\n  // getter to retrieve divident owed\r\n  function getOwedDividend(address _owner) public view returns (uint256 total, uint256[]) {\r\n    uint256[] memory noDividends = new uint256[](0);\r\n    // And the address' current balance\r\n    uint256 balance = BasicToken.balanceOf(_owner);\r\n    // retrieve index of last dividend this address received\r\n    // NOTE: the default return value of a mapping is 0 in this case\r\n    uint idx = lastDividend[_owner];\r\n    if (idx == dividendSnapshots.length) return (total, noDividends);\r\n    if (balance == 0 && team[_owner] != true) return (total, noDividends);\r\n\r\n    uint256[] memory dividends = new uint256[](dividendSnapshots.length - idx - i);\r\n    uint256 currBalance = balance;\r\n    for (uint i = idx; i < dividendSnapshots.length; i++) {\r\n      // We should be able to remove the .mul(tokenPrecision) and .div(tokenPrecision) and apply them once\r\n      // at the beginning and once at the end, but we need to math it out\r\n      uint256 dividend = currBalance.mul(tokenPrecision).div(dividendSnapshots[i].totalSupply).mul(dividendSnapshots[i].dividendsIssued).div(tokenPrecision);\r\n\r\n      // Add the management dividends in equal parts if the current address is part of the team\r\n      if (team[_owner] == true) {\r\n        dividend = dividend.add(dividendSnapshots[i].managementDividends.div(teamNum));\r\n      }\r\n\r\n      total = total.add(dividend);\r\n\r\n      dividends[i - idx] = dividend;\r\n\r\n      currBalance = currBalance.add(dividend);\r\n    }\r\n\r\n    return (total, dividends);\r\n  }\r\n\r\n  // monkey patches\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    var (owedDividend, /* dividends */) = getOwedDividend(_owner);\r\n    return BasicToken.balanceOf(_owner).add(owedDividend);\r\n  }\r\n\r\n\r\n  // Reconcile all outstanding dividends for an address\r\n  // into its balance.\r\n  function reconcileDividend(address _owner) internal {\r\n    var (owedDividend, dividends) = getOwedDividend(_owner);\r\n\r\n    for (uint i = 0; i < dividends.length; i++) {\r\n      if (dividends[i] > 0) {\r\n        Reconcile(_owner, lastDividend[_owner] + i, dividends[i]);\r\n        Transfer(0x0, _owner, dividends[i]);\r\n      }\r\n    }\r\n\r\n    if(owedDividend > 0) {\r\n      balances[_owner] = balances[_owner].add(owedDividend);\r\n    }\r\n\r\n    // register this user as being owed no further dividends\r\n    lastDividend[_owner] = dividendSnapshots.length;\r\n  }\r\n\r\n  function transfer(address _to, uint256 _amount) public returns (bool) {\r\n    reconcileDividend(msg.sender);\r\n    reconcileDividend(_to);\r\n    return BasicToken.transfer(_to, _amount);\r\n  }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"icoEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"aum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamNum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"liquidate\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensFrozen\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"managementFees\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoStart\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentSaleAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"totalProfit\",\"type\":\"int256\"},{\"name\":\"saleAddress\",\"type\":\"address\"}],\"name\":\"reportProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"participate\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensPerEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dripRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"freeze\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getOwedDividend\",\"outputs\":[{\"name\":\"total\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_icoStart\",\"type\":\"uint256\"},{\"name\":\"_icoEnd\",\"type\":\"uint256\"},{\"name\":\"_team\",\"type\":\"address[]\"},{\"name\":\"_tokensPerEth\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Freeze\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Participate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"period\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Reconcile\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"Ico","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"000000000000000000000000000000000000000000000000000000005a38aae0000000000000000000000000000000000000000000000000000000005a3b4de0000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000003200000000000000000000000000000000000000000000000000000000000000004000000000000000000000000fe01b3b2e5693eda712104555620742c87d6ca90000000000000000000000000f80f44febc9ee496ad5c8266f1b567148cd00f19000000000000000000000000be2c2fa2347340298783ea69ad03eb4e70c1e970000000000000000000000000ff56d7fdecd8baf89518cb83492ff8257b0f50b2","Library":"","SwarmSource":"bzzr://9905724fd342af9bbc20f69fca2672221cfa2033abdc7644988980bd8a5fea65"}]}