{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.15;\r\n\r\n/// @title provides subject to role checking logic\r\ncontract IAccessPolicy {\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    /// @notice We don't make this function constant to allow for state-updating access controls such as rate limiting.\r\n    /// @dev checks if subject belongs to requested role for particular object\r\n    /// @param subject address to be checked against role, typically msg.sender\r\n    /// @param role identifier of required role\r\n    /// @param object contract instance context for role checking, typically contract requesting the check\r\n    /// @param verb additional data, in current AccessControll implementation msg.sig\r\n    /// @return if subject belongs to a role\r\n    function allowed(\r\n        address subject,\r\n        bytes32 role,\r\n        address object,\r\n        bytes4 verb\r\n    )\r\n        public\r\n        returns (bool);\r\n}\r\n\r\n/// @title enables access control in implementing contract\r\n/// @dev see AccessControlled for implementation\r\ncontract IAccessControlled {\r\n\r\n    ////////////////////////\r\n    // Events\r\n    ////////////////////////\r\n\r\n    /// @dev must log on access policy change\r\n    event LogAccessPolicyChanged(\r\n        address controller,\r\n        IAccessPolicy oldPolicy,\r\n        IAccessPolicy newPolicy\r\n    );\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    /// @dev allows to change access control mechanism for this contract\r\n    ///     this method must be itself access controlled, see AccessControlled implementation and notice below\r\n    /// @notice it is a huge issue for Solidity that modifiers are not part of function signature\r\n    ///     then interfaces could be used for example to control access semantics\r\n    /// @param newPolicy new access policy to controll this contract\r\n    /// @param newAccessController address of ROLE_ACCESS_CONTROLLER of new policy that can set access to this contract\r\n    function setAccessPolicy(IAccessPolicy newPolicy, address newAccessController)\r\n        public;\r\n\r\n    function accessPolicy()\r\n        public\r\n        constant\r\n        returns (IAccessPolicy);\r\n\r\n}\r\n\r\ncontract StandardRoles {\r\n\r\n    ////////////////////////\r\n    // Constants\r\n    ////////////////////////\r\n\r\n    // @notice Soldity somehow doesn't evaluate this compile time\r\n    // @dev role which has rights to change permissions and set new policy in contract, keccak256(\"AccessController\")\r\n    bytes32 internal constant ROLE_ACCESS_CONTROLLER = 0xac42f8beb17975ed062dcb80c63e6d203ef1c2c335ced149dc5664cc671cb7da;\r\n}\r\n\r\n/// @title Granular code execution permissions\r\n/// @notice Intended to replace existing Ownable pattern with more granular permissions set to execute smart contract functions\r\n///     for each function where 'only' modifier is applied, IAccessPolicy implementation is called to evaluate if msg.sender belongs to required role for contract being called.\r\n///     Access evaluation specific belong to IAccessPolicy implementation, see RoleBasedAccessPolicy for details.\r\n/// @dev Should be inherited by a contract requiring such permissions controll. IAccessPolicy must be provided in constructor. Access policy may be replaced to a different one\r\n///     by msg.sender with ROLE_ACCESS_CONTROLLER role\r\ncontract AccessControlled is IAccessControlled, StandardRoles {\r\n\r\n    ////////////////////////\r\n    // Mutable state\r\n    ////////////////////////\r\n\r\n    IAccessPolicy private _accessPolicy;\r\n\r\n    ////////////////////////\r\n    // Modifiers\r\n    ////////////////////////\r\n\r\n    /// @dev limits function execution only to senders assigned to required 'role'\r\n    modifier only(bytes32 role) {\r\n        require(_accessPolicy.allowed(msg.sender, role, this, msg.sig));\r\n        _;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Constructor\r\n    ////////////////////////\r\n\r\n    function AccessControlled(IAccessPolicy policy) internal {\r\n        require(address(policy) != 0x0);\r\n        _accessPolicy = policy;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    //\r\n    // Implements IAccessControlled\r\n    //\r\n\r\n    function setAccessPolicy(IAccessPolicy newPolicy, address newAccessController)\r\n        public\r\n        only(ROLE_ACCESS_CONTROLLER)\r\n    {\r\n        // ROLE_ACCESS_CONTROLLER must be present\r\n        // under the new policy. This provides some\r\n        // protection against locking yourself out.\r\n        require(newPolicy.allowed(newAccessController, ROLE_ACCESS_CONTROLLER, this, msg.sig));\r\n\r\n        // We can now safely set the new policy without foot shooting.\r\n        IAccessPolicy oldPolicy = _accessPolicy;\r\n        _accessPolicy = newPolicy;\r\n\r\n        // Log event\r\n        LogAccessPolicyChanged(msg.sender, oldPolicy, newPolicy);\r\n    }\r\n\r\n    function accessPolicy()\r\n        public\r\n        constant\r\n        returns (IAccessPolicy)\r\n    {\r\n        return _accessPolicy;\r\n    }\r\n}\r\n\r\n/// @notice implemented in the contract that is the target of state migration\r\n/// @dev implementation must provide actual function that will be called by source to migrate state\r\ncontract IMigrationTarget {\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    // should return migration source address\r\n    function currentMigrationSource()\r\n        public\r\n        constant\r\n        returns (address);\r\n}\r\n\r\n/// @notice mixin that enables contract to receive migration\r\n/// @dev when derived from\r\ncontract MigrationTarget is\r\n    IMigrationTarget\r\n{\r\n    ////////////////////////\r\n    // Modifiers\r\n    ////////////////////////\r\n\r\n    // intended to be applied on migration receiving function\r\n    modifier onlyMigrationSource() {\r\n        require(msg.sender == currentMigrationSource());\r\n        _;\r\n    }\r\n}\r\n\r\ncontract EuroTokenMigrationTarget is\r\n    MigrationTarget\r\n{\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    /// @notice accepts migration of single eur-t token holder\r\n    /// @dev allowed to be called only from migration source, do not forget to add accessor modifier in implementation\r\n    function migrateEuroTokenOwner(address owner, uint256 amount)\r\n        public\r\n        onlyMigrationSource();\r\n}\r\n\r\n/// @notice implemented in the contract that stores state to be migrated\r\n/// @notice contract is called migration source\r\n/// @dev migration target implements IMigrationTarget interface, when it is passed in 'enableMigration' function\r\n/// @dev 'migrate' function may be called to migrate part of state owned by msg.sender\r\n/// @dev in legal terms this corresponds to amending/changing agreement terms by co-signature of parties\r\ncontract IMigrationSource {\r\n\r\n    ////////////////////////\r\n    // Events\r\n    ////////////////////////\r\n\r\n    event LogMigrationEnabled(\r\n        address target\r\n    );\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    /// @notice should migrate state owned by msg.sender\r\n    /// @dev intended flow is to: read source state, clear source state, call migrate function on target, log success event\r\n    function migrate()\r\n        public;\r\n\r\n    /// @notice should enable migration to migration target\r\n    /// @dev should limit access to specific role in implementation\r\n    function enableMigration(IMigrationTarget migration)\r\n        public;\r\n\r\n    /// @notice returns current migration target\r\n    function currentMigrationTarget()\r\n        public\r\n        constant\r\n        returns (IMigrationTarget);\r\n}\r\n\r\n/// @notice mixin that enables migration pattern for a contract\r\n/// @dev when derived from\r\ncontract MigrationSource is\r\n    IMigrationSource,\r\n    AccessControlled\r\n{\r\n    ////////////////////////\r\n    // Immutable state\r\n    ////////////////////////\r\n\r\n    /// stores role hash that can enable migration\r\n    bytes32 private MIGRATION_ADMIN;\r\n\r\n    ////////////////////////\r\n    // Mutable state\r\n    ////////////////////////\r\n\r\n    // migration target contract\r\n    IMigrationTarget internal _migration;\r\n\r\n    ////////////////////////\r\n    // Modifiers\r\n    ////////////////////////\r\n\r\n    /// @notice add to enableMigration function to prevent changing of migration\r\n    ///     target once set\r\n    modifier onlyMigrationEnabledOnce() {\r\n        require(address(_migration) == 0);\r\n        _;\r\n    }\r\n\r\n    modifier onlyMigrationEnabled() {\r\n        require(address(_migration) != 0);\r\n        _;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Constructor\r\n    ////////////////////////\r\n\r\n    function MigrationSource(\r\n        IAccessPolicy policy,\r\n        bytes32 migrationAdminRole\r\n    )\r\n        AccessControlled(policy)\r\n        internal\r\n    {\r\n        MIGRATION_ADMIN = migrationAdminRole;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    /// @notice should migrate state that belongs to msg.sender\r\n    /// @dev do not forget to add accessor modifier in implementation\r\n    function migrate()\r\n        onlyMigrationEnabled()\r\n        public;\r\n\r\n    /// @notice should enable migration to migration target\r\n    /// @dev do not forget to add accessor modifier in override\r\n    function enableMigration(IMigrationTarget migration)\r\n        public\r\n        onlyMigrationEnabledOnce()\r\n        only(MIGRATION_ADMIN)\r\n    {\r\n        // this must be the source\r\n        require(migration.currentMigrationSource() == address(this));\r\n        _migration = migration;\r\n        LogMigrationEnabled(_migration);\r\n    }\r\n\r\n    /// @notice returns current migration target\r\n    function currentMigrationTarget()\r\n        public\r\n        constant\r\n        returns (IMigrationTarget)\r\n    {\r\n        return _migration;\r\n    }\r\n}\r\n\r\ncontract AccessRoles {\r\n\r\n    ////////////////////////\r\n    // Constants\r\n    ////////////////////////\r\n\r\n    // NOTE: All roles are set to the keccak256 hash of the\r\n    // CamelCased role name, i.e.\r\n    // ROLE_LOCKED_ACCOUNT_ADMIN = keccak256(\"LockedAccountAdmin\")\r\n\r\n    // may setup LockedAccount, change disbursal mechanism and set migration\r\n    bytes32 internal constant ROLE_LOCKED_ACCOUNT_ADMIN = 0x4675da546d2d92c5b86c4f726a9e61010dce91cccc2491ce6019e78b09d2572e;\r\n\r\n    // may setup whitelists and abort whitelisting contract with curve rollback\r\n    bytes32 internal constant ROLE_WHITELIST_ADMIN = 0xaef456e7c864418e1d2a40d996ca4febf3a7e317fe3af5a7ea4dda59033bbe5c;\r\n\r\n    // May issue (generate) Neumarks\r\n    bytes32 internal constant ROLE_NEUMARK_ISSUER = 0x921c3afa1f1fff707a785f953a1e197bd28c9c50e300424e015953cbf120c06c;\r\n\r\n    // May burn Neumarks it owns\r\n    bytes32 internal constant ROLE_NEUMARK_BURNER = 0x19ce331285f41739cd3362a3ec176edffe014311c0f8075834fdd19d6718e69f;\r\n\r\n    // May create new snapshots on Neumark\r\n    bytes32 internal constant ROLE_SNAPSHOT_CREATOR = 0x08c1785afc57f933523bc52583a72ce9e19b2241354e04dd86f41f887e3d8174;\r\n\r\n    // May enable/disable transfers on Neumark\r\n    bytes32 internal constant ROLE_TRANSFER_ADMIN = 0xb6527e944caca3d151b1f94e49ac5e223142694860743e66164720e034ec9b19;\r\n\r\n    // may reclaim tokens/ether from contracts supporting IReclaimable interface\r\n    bytes32 internal constant ROLE_RECLAIMER = 0x0542bbd0c672578966dcc525b30aa16723bb042675554ac5b0362f86b6e97dc5;\r\n\r\n    // represents legally platform operator in case of forks and contracts with legal agreement attached. keccak256(\"PlatformOperatorRepresentative\")\r\n    bytes32 internal constant ROLE_PLATFORM_OPERATOR_REPRESENTATIVE = 0xb2b321377653f655206f71514ff9f150d0822d062a5abcf220d549e1da7999f0;\r\n\r\n    // allows to deposit EUR-T and allow addresses to send and receive EUR-T. keccak256(\"EurtDepositManager\")\r\n    bytes32 internal constant ROLE_EURT_DEPOSIT_MANAGER = 0x7c8ecdcba80ce87848d16ad77ef57cc196c208fc95c5638e4a48c681a34d4fe7;\r\n}\r\n\r\ncontract IBasicToken {\r\n\r\n    ////////////////////////\r\n    // Events\r\n    ////////////////////////\r\n\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 amount);\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    /// @dev This function makes it easy to get the total number of tokens\r\n    /// @return The total number of tokens\r\n    function totalSupply()\r\n        public\r\n        constant\r\n        returns (uint256);\r\n\r\n    /// @param owner The address that's balance is being requested\r\n    /// @return The balance of `owner` at the current block\r\n    function balanceOf(address owner)\r\n        public\r\n        constant\r\n        returns (uint256 balance);\r\n\r\n    /// @notice Send `amount` tokens to `to` from `msg.sender`\r\n    /// @param to The address of the recipient\r\n    /// @param amount The amount of tokens to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address to, uint256 amount)\r\n        public\r\n        returns (bool success);\r\n\r\n}\r\n\r\n/// @title allows deriving contract to recover any token or ether that it has balance of\r\n/// @notice note that this opens your contracts to claims from various people saying they lost tokens and they want them back\r\n///     be ready to handle such claims\r\n/// @dev use with care!\r\n///     1. ROLE_RECLAIMER is allowed to claim tokens, it's not returning tokens to original owner\r\n///     2. in derived contract that holds any token by design you must override `reclaim` and block such possibility.\r\n///         see LockedAccount as an example\r\ncontract Reclaimable is AccessControlled, AccessRoles {\r\n\r\n    ////////////////////////\r\n    // Constants\r\n    ////////////////////////\r\n\r\n    IBasicToken constant internal RECLAIM_ETHER = IBasicToken(0x0);\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    function reclaim(IBasicToken token)\r\n        public\r\n        only(ROLE_RECLAIMER)\r\n    {\r\n        address reclaimer = msg.sender;\r\n        if(token == RECLAIM_ETHER) {\r\n            reclaimer.transfer(this.balance);\r\n        } else {\r\n            uint256 balance = token.balanceOf(this);\r\n            require(token.transfer(reclaimer, balance));\r\n        }\r\n    }\r\n}\r\n\r\ncontract ITokenMetadata {\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    function symbol()\r\n        public\r\n        constant\r\n        returns (string);\r\n\r\n    function name()\r\n        public\r\n        constant\r\n        returns (string);\r\n\r\n    function decimals()\r\n        public\r\n        constant\r\n        returns (uint8);\r\n}\r\n\r\n/// @title adds token metadata to token contract\r\n/// @dev see Neumark for example implementation\r\ncontract TokenMetadata is ITokenMetadata {\r\n\r\n    ////////////////////////\r\n    // Immutable state\r\n    ////////////////////////\r\n\r\n    // The Token's name: e.g. DigixDAO Tokens\r\n    string private NAME;\r\n\r\n    // An identifier: e.g. REP\r\n    string private SYMBOL;\r\n\r\n    // Number of decimals of the smallest unit\r\n    uint8 private DECIMALS;\r\n\r\n    // An arbitrary versioning scheme\r\n    string private VERSION;\r\n\r\n    ////////////////////////\r\n    // Constructor\r\n    ////////////////////////\r\n\r\n    /// @notice Constructor to set metadata\r\n    /// @param tokenName Name of the new token\r\n    /// @param decimalUnits Number of decimals of the new token\r\n    /// @param tokenSymbol Token Symbol for the new token\r\n    /// @param version Token version ie. when cloning is used\r\n    function TokenMetadata(\r\n        string tokenName,\r\n        uint8 decimalUnits,\r\n        string tokenSymbol,\r\n        string version\r\n    )\r\n        public\r\n    {\r\n        NAME = tokenName;                                 // Set the name\r\n        SYMBOL = tokenSymbol;                             // Set the symbol\r\n        DECIMALS = decimalUnits;                          // Set the decimals\r\n        VERSION = version;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    function name()\r\n        public\r\n        constant\r\n        returns (string)\r\n    {\r\n        return NAME;\r\n    }\r\n\r\n    function symbol()\r\n        public\r\n        constant\r\n        returns (string)\r\n    {\r\n        return SYMBOL;\r\n    }\r\n\r\n    function decimals()\r\n        public\r\n        constant\r\n        returns (uint8)\r\n    {\r\n        return DECIMALS;\r\n    }\r\n\r\n    function version()\r\n        public\r\n        constant\r\n        returns (string)\r\n    {\r\n        return VERSION;\r\n    }\r\n}\r\n\r\ncontract IERC20Allowance {\r\n\r\n    ////////////////////////\r\n    // Events\r\n    ////////////////////////\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 amount);\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    /// @dev This function makes it easy to read the `allowed[]` map\r\n    /// @param owner The address of the account that owns the token\r\n    /// @param spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens of owner that spender is allowed\r\n    ///  to spend\r\n    function allowance(address owner, address spender)\r\n        public\r\n        constant\r\n        returns (uint256 remaining);\r\n\r\n    /// @notice `msg.sender` approves `spender` to spend `amount` tokens on\r\n    ///  its behalf. This is a modified version of the ERC20 approve function\r\n    ///  to be a little bit safer\r\n    /// @param spender The address of the account able to transfer the tokens\r\n    /// @param amount The amount of tokens to be approved for transfer\r\n    /// @return True if the approval was successful\r\n    function approve(address spender, uint256 amount)\r\n        public\r\n        returns (bool success);\r\n\r\n    /// @notice Send `amount` tokens to `to` from `from` on the condition it\r\n    ///  is approved by `from`\r\n    /// @param from The address holding the tokens being transferred\r\n    /// @param to The address of the recipient\r\n    /// @param amount The amount of tokens to be transferred\r\n    /// @return True if the transfer was successful\r\n    function transferFrom(address from, address to, uint256 amount)\r\n        public\r\n        returns (bool success);\r\n\r\n}\r\n\r\ncontract IERC20Token is IBasicToken, IERC20Allowance {\r\n\r\n}\r\n\r\ncontract IERC677Callback {\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    // NOTE: This call can be initiated by anyone. You need to make sure that\r\n    // it is send by the token (`require(msg.sender == token)`) or make sure\r\n    // amount is valid (`require(token.allowance(this) >= amount)`).\r\n    function receiveApproval(\r\n        address from,\r\n        uint256 amount,\r\n        address token, // IERC667Token\r\n        bytes data\r\n    )\r\n        public\r\n        returns (bool success);\r\n\r\n}\r\n\r\ncontract IERC677Allowance is IERC20Allowance {\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    /// @notice `msg.sender` approves `spender` to send `amount` tokens on\r\n    ///  its behalf, and then a function is triggered in the contract that is\r\n    ///  being approved, `spender`. This allows users to use their tokens to\r\n    ///  interact with contracts in one function call instead of two\r\n    /// @param spender The address of the contract able to transfer the tokens\r\n    /// @param amount The amount of tokens to be approved for transfer\r\n    /// @return True if the function call was successful\r\n    function approveAndCall(address spender, uint256 amount, bytes extraData)\r\n        public\r\n        returns (bool success);\r\n\r\n}\r\n\r\ncontract IERC677Token is IERC20Token, IERC677Allowance {\r\n}\r\n\r\ncontract Math {\r\n\r\n    ////////////////////////\r\n    // Internal functions\r\n    ////////////////////////\r\n\r\n    // absolute difference: |v1 - v2|\r\n    function absDiff(uint256 v1, uint256 v2)\r\n        internal\r\n        constant\r\n        returns(uint256)\r\n    {\r\n        return v1 > v2 ? v1 - v2 : v2 - v1;\r\n    }\r\n\r\n    // divide v by d, round up if remainder is 0.5 or more\r\n    function divRound(uint256 v, uint256 d)\r\n        internal\r\n        constant\r\n        returns(uint256)\r\n    {\r\n        return add(v, d/2) / d;\r\n    }\r\n\r\n    // computes decimal decimalFraction 'frac' of 'amount' with maximum precision (multiplication first)\r\n    // both amount and decimalFraction must have 18 decimals precision, frac 10**18 represents a whole (100% of) amount\r\n    // mind loss of precision as decimal fractions do not have finite binary expansion\r\n    // do not use instead of division\r\n    function decimalFraction(uint256 amount, uint256 frac)\r\n        internal\r\n        constant\r\n        returns(uint256)\r\n    {\r\n        // it's like 1 ether is 100% proportion\r\n        return proportion(amount, frac, 10**18);\r\n    }\r\n\r\n    // computes part/total of amount with maximum precision (multiplication first)\r\n    // part and total must have the same units\r\n    function proportion(uint256 amount, uint256 part, uint256 total)\r\n        internal\r\n        constant\r\n        returns(uint256)\r\n    {\r\n        return divRound(mul(amount, part), total);\r\n    }\r\n\r\n    //\r\n    // Open Zeppelin Math library below\r\n    //\r\n\r\n    function mul(uint256 a, uint256 b)\r\n        internal\r\n        constant\r\n        returns (uint256)\r\n    {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        constant\r\n        returns (uint256)\r\n    {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        constant\r\n        returns (uint256)\r\n    {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b)\r\n        internal\r\n        constant\r\n        returns (uint256)\r\n    {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function max(uint256 a, uint256 b)\r\n        internal\r\n        constant\r\n        returns (uint256)\r\n    {\r\n        return a > b ? a : b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is IBasicToken, Math {\r\n\r\n    ////////////////////////\r\n    // Mutable state\r\n    ////////////////////////\r\n\r\n    mapping(address => uint256) internal _balances;\r\n\r\n    uint256 internal _totalSupply;\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    /**\r\n    * @dev transfer token for a specified address\r\n    * @param to The address to transfer to.\r\n    * @param amount The amount to be transferred.\r\n    */\r\n    function transfer(address to, uint256 amount)\r\n        public\r\n        returns (bool)\r\n    {\r\n        transferInternal(msg.sender, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /// @dev This function makes it easy to get the total number of tokens\r\n    /// @return The total number of tokens\r\n    function totalSupply()\r\n        public\r\n        constant\r\n        returns (uint256)\r\n    {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param owner The address to query the the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address owner)\r\n        public\r\n        constant\r\n        returns (uint256 balance)\r\n    {\r\n        return _balances[owner];\r\n    }\r\n\r\n    ////////////////////////\r\n    // Internal functions\r\n    ////////////////////////\r\n\r\n    // actual transfer function called by all public variants\r\n    function transferInternal(address from, address to, uint256 amount)\r\n        internal\r\n    {\r\n        require(to != address(0));\r\n\r\n        _balances[from] = sub(_balances[from], amount);\r\n        _balances[to] = add(_balances[to], amount);\r\n        Transfer(from, to, amount);\r\n    }\r\n}\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is\r\n    IERC20Token,\r\n    BasicToken,\r\n    IERC677Token\r\n{\r\n\r\n    ////////////////////////\r\n    // Mutable state\r\n    ////////////////////////\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowed;\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    //\r\n    // Implements ERC20\r\n    //\r\n\r\n    /**\r\n    * @dev Transfer tokens from one address to another\r\n    * @param from address The address which you want to send tokens from\r\n    * @param to address The address which you want to transfer to\r\n    * @param amount uint256 the amount of tokens to be transferred\r\n    */\r\n    function transferFrom(address from, address to, uint256 amount)\r\n        public\r\n        returns (bool)\r\n    {\r\n        // check and reset allowance\r\n        var allowance = _allowed[from][msg.sender];\r\n        _allowed[from][msg.sender] = sub(allowance, amount);\r\n        // do the transfer\r\n        transferInternal(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n    * @param spender The address which will spend the funds.\r\n    * @param amount The amount of tokens to be spent.\r\n    */\r\n    function approve(address spender, uint256 amount)\r\n        public\r\n        returns (bool)\r\n    {\r\n\r\n        // To change the approve amount you first have to reduce the addresses`\r\n        //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n        //  already 0 to mitigate the race condition described here:\r\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        require((amount == 0) || (_allowed[msg.sender][spender] == 0));\r\n\r\n        _allowed[msg.sender][spender] = amount;\r\n        Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n    * @param owner address The address which owns the funds.\r\n    * @param spender address The address which will spend the funds.\r\n    * @return A uint256 specifing the amount of tokens still avaible for the spender.\r\n    */\r\n    function allowance(address owner, address spender)\r\n        public\r\n        constant\r\n        returns (uint256 remaining)\r\n    {\r\n        return _allowed[owner][spender];\r\n    }\r\n\r\n    //\r\n    // Implements IERC677Token\r\n    //\r\n\r\n    function approveAndCall(\r\n        address spender,\r\n        uint256 amount,\r\n        bytes extraData\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(approve(spender, amount));\r\n\r\n        // in case of re-entry 1. approval is done 2. msg.sender is different\r\n        bool success = IERC677Callback(spender).receiveApproval(\r\n            msg.sender,\r\n            amount,\r\n            this,\r\n            extraData\r\n        );\r\n        require(success);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n/// Simple implementation of EuroToken which is pegged 1:1 to certain off-chain\r\n/// pool of Euro. Balances of this token are intended to be migrated to final\r\n/// implementation that will be available later\r\ncontract EuroToken is\r\n    IERC677Token,\r\n    AccessControlled,\r\n    StandardToken,\r\n    TokenMetadata,\r\n    MigrationSource,\r\n    Reclaimable\r\n{\r\n    ////////////////////////\r\n    // Constants\r\n    ////////////////////////\r\n\r\n    string private constant NAME = \"Euro Token\";\r\n\r\n    string private constant SYMBOL = \"EUR-T\";\r\n\r\n    uint8 private constant DECIMALS = 18;\r\n\r\n    ////////////////////////\r\n    // Mutable state\r\n    ////////////////////////\r\n\r\n    // a list of addresses that are allowed to receive EUR-T\r\n    mapping(address => bool) private _allowedTransferTo;\r\n\r\n    // a list of of addresses that are allowed to send EUR-T\r\n    mapping(address => bool) private _allowedTransferFrom;\r\n\r\n    ////////////////////////\r\n    // Events\r\n    ////////////////////////\r\n\r\n    event LogDeposit(\r\n        address indexed to,\r\n        uint256 amount\r\n    );\r\n\r\n    event LogWithdrawal(\r\n        address indexed from,\r\n        uint256 amount\r\n    );\r\n\r\n    event LogAllowedFromAddress(\r\n        address indexed from,\r\n        bool allowed\r\n    );\r\n\r\n    event LogAllowedToAddress(\r\n        address indexed to,\r\n        bool allowed\r\n    );\r\n\r\n    /// @notice migration was successful\r\n    event LogEuroTokenOwnerMigrated(\r\n        address indexed owner,\r\n        uint256 amount\r\n    );\r\n\r\n    ////////////////////////\r\n    // Modifiers\r\n    ////////////////////////\r\n\r\n    modifier onlyAllowedTransferFrom(address from) {\r\n        require(_allowedTransferFrom[from]);\r\n        _;\r\n    }\r\n\r\n    modifier onlyAllowedTransferTo(address to) {\r\n        require(_allowedTransferTo[to]);\r\n        _;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Constructor\r\n    ////////////////////////\r\n\r\n    function EuroToken(IAccessPolicy accessPolicy)\r\n        AccessControlled(accessPolicy)\r\n        StandardToken()\r\n        TokenMetadata(NAME, DECIMALS, SYMBOL, \"\")\r\n        MigrationSource(accessPolicy, ROLE_EURT_DEPOSIT_MANAGER)\r\n        Reclaimable()\r\n        public\r\n    {\r\n    }\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    /// @notice deposit 'amount' of EUR-T to address 'to'\r\n    /// @dev address 'to' is whitelisted as recipient of future transfers\r\n    /// @dev deposit may happen only in case of succesful KYC of recipient and validation of banking data\r\n    /// @dev which in this implementation is an off-chain responsibility of EURT_DEPOSIT_MANAGER\r\n    function deposit(address to, uint256 amount)\r\n        public\r\n        only(ROLE_EURT_DEPOSIT_MANAGER)\r\n        returns (bool)\r\n    {\r\n        require(to != address(0));\r\n        _balances[to] = add(_balances[to], amount);\r\n        _totalSupply = add(_totalSupply, amount);\r\n        setAllowedTransferTo(to, true);\r\n        LogDeposit(to, amount);\r\n        Transfer(address(0), to, amount);\r\n        return true;\r\n    }\r\n\r\n    /// @notice withdraws 'amount' of EUR-T by burning required amount and providing a proof of whithdrawal\r\n    /// @dev proof is provided in form of log entry on which EURT_DEPOSIT_MANAGER\r\n    /// @dev will act off-chain to return required Euro amount to EUR-T holder\r\n    function withdraw(uint256 amount)\r\n        public\r\n    {\r\n        require(_balances[msg.sender] >= amount);\r\n        _balances[msg.sender] = sub(_balances[msg.sender], amount);\r\n        _totalSupply = sub(_totalSupply, amount);\r\n        LogWithdrawal(msg.sender, amount);\r\n        Transfer(msg.sender, address(0), amount);\r\n    }\r\n\r\n    /// @notice enables or disables address to be receipient of EUR-T\r\n    function setAllowedTransferTo(address to, bool allowed)\r\n        public\r\n        only(ROLE_EURT_DEPOSIT_MANAGER)\r\n    {\r\n        _allowedTransferTo[to] = allowed;\r\n        LogAllowedToAddress(to, allowed);\r\n    }\r\n\r\n    /// @notice enables or disables address to be sender of EUR-T\r\n    function setAllowedTransferFrom(address from, bool allowed)\r\n        public\r\n        only(ROLE_EURT_DEPOSIT_MANAGER)\r\n    {\r\n        _allowedTransferFrom[from] = allowed;\r\n        LogAllowedFromAddress(from, allowed);\r\n    }\r\n\r\n    function allowedTransferTo(address to)\r\n        public\r\n        constant\r\n        returns (bool)\r\n    {\r\n        return _allowedTransferTo[to];\r\n    }\r\n\r\n    function allowedTransferFrom(address from)\r\n        public\r\n        constant\r\n        returns (bool)\r\n    {\r\n        return _allowedTransferFrom[from];\r\n    }\r\n\r\n    //\r\n    // Overrides ERC20 Interface to allow transfer from/to allowed addresses\r\n    //\r\n\r\n    function transfer(address to, uint256 amount)\r\n        public\r\n        onlyAllowedTransferFrom(msg.sender)\r\n        onlyAllowedTransferTo(to)\r\n        returns (bool success)\r\n    {\r\n        return BasicToken.transfer(to, amount);\r\n    }\r\n\r\n    /// @dev broker acts in the name of 'from' address so broker needs to have permission to transfer from\r\n    ///  this way we may give permissions to brokering smart contracts while investors do not have permissions\r\n    ///  to transfer. 'to' address requires standard transfer to permission\r\n    function transferFrom(address from, address to, uint256 amount)\r\n        public\r\n        onlyAllowedTransferFrom(msg.sender)\r\n        onlyAllowedTransferTo(to)\r\n        returns (bool success)\r\n    {\r\n        return StandardToken.transferFrom(from, to, amount);\r\n    }\r\n\r\n    //\r\n    // Overrides migration source\r\n    //\r\n\r\n    function migrate()\r\n        public\r\n        onlyMigrationEnabled()\r\n        onlyAllowedTransferTo(msg.sender)\r\n    {\r\n        // burn deposit\r\n        uint256 amount = _balances[msg.sender];\r\n        if (amount > 0) {\r\n            _balances[msg.sender] = 0;\r\n            _totalSupply = sub(_totalSupply, amount);\r\n        }\r\n        // remove all transfer permissions\r\n        _allowedTransferTo[msg.sender] = false;\r\n        _allowedTransferFrom[msg.sender] = false;\r\n        // migrate to\r\n        EuroTokenMigrationTarget(_migration).migrateEuroTokenOwner(msg.sender, amount);\r\n        // set event\r\n        LogEuroTokenOwnerMigrated(msg.sender, amount);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"setAllowedTransferFrom\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"}],\"name\":\"allowedTransferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentMigrationTarget\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newPolicy\",\"type\":\"address\"},{\"name\":\"newAccessController\",\"type\":\"address\"}],\"name\":\"setAccessPolicy\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"migrate\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"migration\",\"type\":\"address\"}],\"name\":\"enableMigration\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"}],\"name\":\"allowedTransferTo\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"setAllowedTransferTo\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"accessPolicy\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"reclaim\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"accessPolicy\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"LogAllowedFromAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"LogAllowedToAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogEuroTokenOwnerMigrated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"controller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"oldPolicy\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newPolicy\",\"type\":\"address\"}],\"name\":\"LogAccessPolicyChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"}],\"name\":\"LogMigrationEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"EuroToken","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000ae38c27e646959735ec70d77ed4ecc03a3eff490","Library":"","SwarmSource":"bzzr://65cd2d42e46f61a1c824d153a9f8bda42490e65f6a4bfa9f7071e5bf5f737ea8"}]}