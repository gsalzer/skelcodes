{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.15;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public constant returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n\r\n    uint256 _allowance = allowed[_from][msg.sender];\r\n\r\n    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n    // require (_value <= _allowance);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   */\r\n  function increaseApproval (address _spender, uint _addedValue)\r\n    returns (bool success) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  function decreaseApproval (address _spender, uint _subtractedValue)\r\n    returns (bool success) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Math\r\n * @dev Assorted math operations\r\n */\r\n\r\nlibrary Math {\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n /*\r\n * Contract that is working with ERC223 tokens\r\n * This is an implementation of ContractReceiver provided here:\r\n * https://github.com/Dexaran/ERC223-token-standard/blob/Recommended/Receiver_Interface.sol\r\n */\r\n\r\n contract ContractReceiver {\r\n\r\n    function tokenFallback(address _from, uint _value, bytes _data);\r\n\r\n}\r\n/*\r\n    Copyright 2016, Jordi Baylina\r\n\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\n\r\n/// @title MiniMeToken Contract\r\n/// @author Jordi Baylina\r\n/// @dev This token contract's goal is to make it easy for anyone to clone this\r\n///  token using the token distribution at a given block, this will allow DAO's\r\n///  and DApps to upgrade their features in a decentralized manner without\r\n///  affecting the original token\r\n/// @dev It is ERC20 compliant, but still needs to under go further testing.\r\n\r\n\r\n/// @dev The token controller contract must implement these functions\r\ncontract TokenController {\r\n    /// @notice Called when `_owner` sends ether to the MiniMe Token contract\r\n    /// @param _owner The address that sent the ether to create tokens\r\n    /// @return True if the ether is accepted, false if it throws\r\n    function proxyPayment(address _owner) payable returns(bool);\r\n\r\n    /// @notice Notifies the controller about a token transfer allowing the\r\n    ///  controller to react if desired\r\n    /// @param _from The origin of the transfer\r\n    /// @param _to The destination of the transfer\r\n    /// @param _amount The amount of the transfer\r\n    /// @return False if the controller does not authorize the transfer\r\n    function onTransfer(address _from, address _to, uint _amount) returns(bool);\r\n\r\n    /// @notice Notifies the controller about an approval allowing the\r\n    ///  controller to react if desired\r\n    /// @param _owner The address that calls `approve()`\r\n    /// @param _spender The spender in the `approve()` call\r\n    /// @param _amount The amount in the `approve()` call\r\n    /// @return False if the controller does not authorize the approval\r\n    function onApprove(address _owner, address _spender, uint _amount)\r\n        returns(bool);\r\n}\r\n\r\ncontract Controlled {\r\n    /// @notice The address of the controller is the only address that can call\r\n    ///  a function with this modifier\r\n    modifier onlyController { require(msg.sender == controller); _; }\r\n\r\n    address public controller;\r\n\r\n    function Controlled() { controller = msg.sender;}\r\n\r\n    /// @notice Changes the controller of the contract\r\n    /// @param _newController The new controller of the contract\r\n    function changeController(address _newController) onlyController {\r\n        controller = _newController;\r\n    }\r\n}\r\n\r\n/// @title SpecToken - Crowdfunding code for the Spectre.ai Token Sale\r\n/// @author Parthasarathy Ramanujam\r\ncontract SpectreSubscriberToken is StandardToken, Pausable, TokenController {\r\n  using SafeMath for uint;\r\n\r\n  string public constant name = \"SPECTRE SUBSCRIBER TOKEN\";\r\n  string public constant symbol = \"SXS\";\r\n  uint256 public constant decimals = 18;\r\n\r\n  uint256 constant public TOKENS_AVAILABLE             = 240000000 * 10**decimals;\r\n  uint256 constant public BONUS_SLAB                   = 100000000 * 10**decimals;\r\n  uint256 constant public MIN_CAP                      = 5000000 * 10**decimals;\r\n  uint256 constant public MIN_FUND_AMOUNT              = 1 ether;\r\n  uint256 constant public TOKEN_PRICE                  = 0.0005 ether;\r\n  uint256 constant public WHITELIST_PERIOD             = 3 days;\r\n\r\n  address public specWallet;\r\n  address public specDWallet;\r\n  address public specUWallet;\r\n\r\n  bool public refundable = false;\r\n  bool public configured = false;\r\n  bool public tokenAddressesSet = false;\r\n  //presale start and end blocks\r\n  uint256 public presaleStart;\r\n  uint256 public presaleEnd;\r\n  //main sale start and end blocks\r\n  uint256 public saleStart;\r\n  uint256 public saleEnd;\r\n  //discount end block for main sale\r\n  uint256 public discountSaleEnd;\r\n\r\n  //whitelisting\r\n  mapping(address => uint256) public whitelist;\r\n  uint256 constant D160 = 0x0010000000000000000000000000000000000000000;\r\n\r\n  //bonus earned\r\n  mapping(address => uint256) public bonus;\r\n\r\n  event Refund(address indexed _to, uint256 _value);\r\n  event ContractFunded(address indexed _from, uint256 _value, uint256 _total);\r\n  event Refundable();\r\n  event WhiteListSet(address indexed _subscriber, uint256 _value);\r\n  event OwnerTransfer(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n  modifier isRefundable() {\r\n    require(refundable);\r\n    _;\r\n  }\r\n\r\n  modifier isNotRefundable() {\r\n    require(!refundable);\r\n    _;\r\n  }\r\n\r\n  modifier isTransferable() {\r\n    require(tokenAddressesSet);\r\n    require(getNow() > saleEnd);\r\n    require(totalSupply >= MIN_CAP);\r\n    _;\r\n  }\r\n\r\n  modifier onlyWalletOrOwner() {\r\n    require(msg.sender == owner || msg.sender == specWallet);\r\n    _;\r\n  }\r\n\r\n  //@notice function to initilaize the token contract\r\n  //@notice _specWallet - The wallet that receives the proceeds from the token sale\r\n  //@notice _specDWallet - Wallet that would receive tokens chosen for dividend\r\n  //@notice _specUWallet - Wallet that would receive tokens chosen for utility\r\n  function SpectreSubscriberToken(address _specWallet) {\r\n    require(_specWallet != address(0));\r\n    specWallet = _specWallet;\r\n    pause();\r\n  }\r\n\r\n  //@notice Fallback function that accepts the ether and allocates tokens to\r\n  //the msg.sender corresponding to msg.value\r\n  function() payable whenNotPaused public {\r\n    require(msg.value >= MIN_FUND_AMOUNT);\r\n    if(getNow() >= presaleStart && getNow() <= presaleEnd) {\r\n      purchasePresale();\r\n    } else if (getNow() >= saleStart && getNow() <= saleEnd) {\r\n      purchase();\r\n    } else {\r\n      revert();\r\n    }\r\n  }\r\n\r\n  //@notice function to be used for presale purchase\r\n  function purchasePresale() internal {\r\n    //Only check whitelist for the first 3 days of presale\r\n    if (getNow() < (presaleStart + WHITELIST_PERIOD)) {\r\n      require(whitelist[msg.sender] > 0);\r\n      //Accept if the subsciber 95% to 120% of whitelisted amount\r\n      uint256 minAllowed = whitelist[msg.sender].mul(95).div(100);\r\n      uint256 maxAllowed = whitelist[msg.sender].mul(120).div(100);\r\n      require(msg.value >= minAllowed && msg.value <= maxAllowed);\r\n      //remove the address from whitelist\r\n      whitelist[msg.sender] = 0;\r\n    }\r\n\r\n    uint256 numTokens = msg.value.mul(10**decimals).div(TOKEN_PRICE);\r\n    uint256 bonusTokens = 0;\r\n\r\n    if(totalSupply < BONUS_SLAB) {\r\n      //Any portion of tokens less than BONUS_SLAB are eligable for 33% bonus, otherwise 22% bonus\r\n      uint256 remainingBonusSlabTokens = SafeMath.sub(BONUS_SLAB, totalSupply);\r\n      uint256 bonusSlabTokens = Math.min256(remainingBonusSlabTokens, numTokens);\r\n      uint256 nonBonusSlabTokens = SafeMath.sub(numTokens, bonusSlabTokens);\r\n      bonusTokens = bonusSlabTokens.mul(33).div(100);\r\n      bonusTokens = bonusTokens.add(nonBonusSlabTokens.mul(22).div(100));\r\n    } else {\r\n      //calculate 22% bonus for tokens purchased on presale\r\n      bonusTokens = numTokens.mul(22).div(100);\r\n    }\r\n    //\r\n    numTokens = numTokens.add(bonusTokens);\r\n    bonus[msg.sender] = bonus[msg.sender].add(bonusTokens);\r\n\r\n    //transfer money to Spectre MultisigWallet (could be msg.value)\r\n    specWallet.transfer(msg.value);\r\n\r\n    totalSupply = totalSupply.add(numTokens);\r\n    require(totalSupply <= TOKENS_AVAILABLE);\r\n\r\n    balances[msg.sender] = balances[msg.sender].add(numTokens);\r\n    //fire the event notifying the transfer of tokens\r\n    Transfer(0, msg.sender, numTokens);\r\n\r\n  }\r\n\r\n  //@notice function to be used for mainsale purchase\r\n  function purchase() internal {\r\n\r\n    uint256 numTokens = msg.value.mul(10**decimals).div(TOKEN_PRICE);\r\n    uint256 bonusTokens = 0;\r\n\r\n    if(getNow() <= discountSaleEnd) {\r\n      //calculate 11% bonus for tokens purchased on discount period\r\n      bonusTokens = numTokens.mul(11).div(100);\r\n    }\r\n\r\n    numTokens = numTokens.add(bonusTokens);\r\n    bonus[msg.sender] = bonus[msg.sender].add(bonusTokens);\r\n\r\n    //transfer money to Spectre MultisigWallet\r\n    specWallet.transfer(msg.value);\r\n\r\n    totalSupply = totalSupply.add(numTokens);\r\n\r\n    require(totalSupply <= TOKENS_AVAILABLE);\r\n    balances[msg.sender] = balances[msg.sender].add(numTokens);\r\n    //fire the event notifying the transfer of tokens\r\n    Transfer(0, msg.sender, numTokens);\r\n  }\r\n\r\n  //@notice Function reports the number of tokens available for sale\r\n  function numberOfTokensLeft() constant returns (uint256) {\r\n    return TOKENS_AVAILABLE.sub(totalSupply);\r\n  }\r\n\r\n  //Override unpause function to only allow once configured\r\n  function unpause() onlyOwner whenPaused public {\r\n    require(configured);\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n\r\n  //@notice Function to configure contract addresses\r\n  //@param `_specUWallet` - address of Utility contract\r\n  //@param `_specDWallet` - address of Dividend contract\r\n  function setTokenAddresses(address _specUWallet, address _specDWallet) onlyOwner public {\r\n    require(!tokenAddressesSet);\r\n    require(_specDWallet != address(0));\r\n    require(_specUWallet != address(0));\r\n    require(isContract(_specDWallet));\r\n    require(isContract(_specUWallet));\r\n    specUWallet = _specUWallet;\r\n    specDWallet = _specDWallet;\r\n    tokenAddressesSet = true;\r\n    if (configured) {\r\n      unpause();\r\n    }\r\n  }\r\n\r\n  //@notice Function to configure contract parameters\r\n  //@param `_startPresaleBlock` - block from when presale begins.\r\n  //@param `_endPresaleBlock` - block from when presale ends.\r\n  //@param `_saleStart` - block from when main sale begins.\r\n  //@param `_saleEnd` - block from when main sale ends.\r\n  //@param `_discountEnd` - block from when the discounts would end.\r\n  //@notice Can be called only when funding is not active and only by the owner\r\n  function configure(uint256 _presaleStart, uint256 _presaleEnd, uint256 _saleStart, uint256 _saleEnd, uint256 _discountSaleEnd) onlyOwner public {\r\n    require(!configured);\r\n    require(_presaleStart > getNow());\r\n    require(_presaleEnd > _presaleStart);\r\n    require(_saleStart > _presaleEnd);\r\n    require(_saleEnd > _saleStart);\r\n    require(_discountSaleEnd > _saleStart && _discountSaleEnd <= _saleEnd);\r\n    presaleStart = _presaleStart;\r\n    presaleEnd = _presaleEnd;\r\n    saleStart = _saleStart;\r\n    saleEnd = _saleEnd;\r\n    discountSaleEnd = _discountSaleEnd;\r\n    configured = true;\r\n    if (tokenAddressesSet) {\r\n      unpause();\r\n    }\r\n  }\r\n\r\n  //@notice Function that can be called by purchasers to refund\r\n  //@notice Used only in case the ICO isn't successful.\r\n  function refund() isRefundable public {\r\n    require(balances[msg.sender] > 0);\r\n\r\n    uint256 tokenValue = balances[msg.sender].sub(bonus[msg.sender]);\r\n    balances[msg.sender] = 0;\r\n    tokenValue = tokenValue.mul(TOKEN_PRICE).div(10**decimals);\r\n\r\n    //transfer to the requesters wallet\r\n    msg.sender.transfer(tokenValue);\r\n    Refund(msg.sender, tokenValue);\r\n  }\r\n\r\n  function withdrawEther() public isNotRefundable onlyOwner {\r\n    //In case ether is sent, even though not refundable\r\n    msg.sender.transfer(this.balance);\r\n  }\r\n\r\n  //@notice Function used for funding in case of refund.\r\n  //@notice Can be called only by the Owner or Wallet\r\n  function fundContract() public payable onlyWalletOrOwner {\r\n    //does nothing just accepts and stores the ether\r\n    ContractFunded(msg.sender, msg.value, this.balance);\r\n  }\r\n\r\n  function setRefundable() onlyOwner {\r\n    require(this.balance > 0);\r\n    require(getNow() > saleEnd);\r\n    require(totalSupply < MIN_CAP);\r\n    Refundable();\r\n    refundable = true;\r\n  }\r\n\r\n  //@notice Standard function transfer similar to ERC20 transfer with no _data .\r\n  //@notice Added due to backwards compatibility reasons .\r\n  function transfer(address _to, uint256 _value) isTransferable returns (bool success) {\r\n    //standard function transfer similar to ERC20 transfer with no _data\r\n    //added due to backwards compatibility reasons\r\n    require(_to == specDWallet || _to == specUWallet);\r\n    require(isContract(_to));\r\n    bytes memory empty;\r\n    return transferToContract(msg.sender, _to, _value, empty);\r\n  }\r\n\r\n  //@notice assemble the given address bytecode. If bytecode exists then the _addr is a contract.\r\n  function isContract(address _addr) private returns (bool is_contract) {\r\n    uint256 length;\r\n    assembly {\r\n      //retrieve the size of the code on target address, this needs assembly\r\n      length := extcodesize(_addr)\r\n    }\r\n    return (length>0);\r\n  }\r\n\r\n  //@notice function that is called when transaction target is a contract\r\n  function transferToContract(address _from, address _to, uint256 _value, bytes _data) internal returns (bool success) {\r\n    require(balanceOf(_from) >= _value);\r\n    balances[_from] = balanceOf(_from).sub(_value);\r\n    balances[_to] = balanceOf(_to).add(_value);\r\n    ContractReceiver receiver = ContractReceiver(_to);\r\n    receiver.tokenFallback(_from, _value, _data);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another - needed for owner transfers\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public isTransferable returns (bool) {\r\n    require(_to == specDWallet || _to == specUWallet);\r\n    require(isContract(_to));\r\n    //owner can transfer tokens on behalf of users after 28 days\r\n    if (msg.sender == owner && getNow() > saleEnd + 28 days) {\r\n      OwnerTransfer(_from, _to, _value);\r\n    } else {\r\n      uint256 _allowance = allowed[_from][msg.sender];\r\n      allowed[_from][msg.sender] = _allowance.sub(_value);\r\n    }\r\n\r\n    //Now make the transfer\r\n    bytes memory empty;\r\n    return transferToContract(_from, _to, _value, empty);\r\n\r\n  }\r\n\r\n  //@notice function that is used for whitelisting an address\r\n  function setWhiteList(address _subscriber, uint256 _amount) public onlyOwner {\r\n    require(_subscriber != address(0));\r\n    require(_amount != 0);\r\n    whitelist[_subscriber] = _amount;\r\n    WhiteListSet(_subscriber, _amount);\r\n  }\r\n\r\n  // data is an array of uint256s. Each uint256 represents a address and amount.\r\n  // The 160 LSB is the address that wants to be added\r\n  // The 96 MSB is the amount of to be set for the whitelist for that address\r\n  function multiSetWhiteList(uint256[] data) public onlyOwner {\r\n    for (uint256 i = 0; i < data.length; i++) {\r\n      address addr = address(data[i] & (D160 - 1));\r\n      uint256 amount = data[i] / D160;\r\n      setWhiteList(addr, amount);\r\n    }\r\n  }\r\n\r\n  /////////////////\r\n  // TokenController interface\r\n  /////////////////\r\n\r\n  /// @notice `proxyPayment()` returns false, meaning ether is not accepted at\r\n  ///  the token address, only the address of FiinuCrowdSale\r\n  /// @param _owner The address that will hold the newly created tokens\r\n\r\n  function proxyPayment(address _owner) payable returns(bool) {\r\n      return false;\r\n  }\r\n\r\n  /// @notice Notifies the controller about a transfer, for this Campaign all\r\n  ///  transfers are allowed by default and no extra notifications are needed\r\n  /// @param _from The origin of the transfer\r\n  /// @param _to The destination of the transfer\r\n  /// @param _amount The amount of the transfer\r\n  /// @return False if the controller does not authorize the transfer\r\n  function onTransfer(address _from, address _to, uint _amount) returns(bool) {\r\n      return true;\r\n  }\r\n\r\n  /// @notice Notifies the controller about an approval, for this Campaign all\r\n  ///  approvals are allowed by default and no extra notifications are needed\r\n  /// @param _owner The address that calls `approve()`\r\n  /// @param _spender The spender in the `approve()` call\r\n  /// @param _amount The amount in the `approve()` call\r\n  /// @return False if the controller does not authorize the approval\r\n  function onApprove(address _owner, address _spender, uint _amount)\r\n      returns(bool)\r\n  {\r\n      return true;\r\n  }\r\n\r\n  function getNow() constant internal returns (uint256) {\r\n    return now;\r\n  }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"TOKENS_AVAILABLE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WHITELIST_PERIOD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presaleEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfTokensLeft\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"data\",\"type\":\"uint256[]\"}],\"name\":\"multiSetWhiteList\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BONUS_SLAB\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"onTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"discountSaleEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"specUWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_presaleStart\",\"type\":\"uint256\"},{\"name\":\"_presaleEnd\",\"type\":\"uint256\"},{\"name\":\"_saleStart\",\"type\":\"uint256\"},{\"name\":\"_saleEnd\",\"type\":\"uint256\"},{\"name\":\"_discountSaleEnd\",\"type\":\"uint256\"}],\"name\":\"configure\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setRefundable\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_CAP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenAddressesSet\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"configured\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_FUND_AMOUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_specUWallet\",\"type\":\"address\"},{\"name\":\"_specDWallet\",\"type\":\"address\"}],\"name\":\"setTokenAddresses\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleStart\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"fundContract\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"refundable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"specWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_subscriber\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setWhiteList\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_PRICE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"bonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"onApprove\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presaleStart\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"specDWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"proxyPayment\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_specWallet\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_total\",\"type\":\"uint256\"}],\"name\":\"ContractFunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Refundable\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_subscriber\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"WhiteListSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"OwnerTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"SpectreSubscriberToken","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000670e095e92aff090fb8475131f7a8a5d98bd0155","Library":"","SwarmSource":"bzzr://304c7d9a428024148f6ae3fdb9e78a61797e4740e90818f5e6ec8f8644d2998e"}]}