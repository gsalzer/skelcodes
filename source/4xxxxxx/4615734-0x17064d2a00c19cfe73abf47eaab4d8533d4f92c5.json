{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity 0.4.18;\r\n/// @title Utility Functions for uint8\r\n/// @author Kongliang Zhong - <kongliang@loopring.org>,\r\n/// @author Daniel Wang - <daniel@loopring.org>.\r\nlibrary MathUint8 {\r\n    function xorReduce(\r\n        uint8[] arr,\r\n        uint    len\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint8 res)\r\n    {\r\n        res = arr[0];\r\n        for (uint i = 1; i < len; i++) {\r\n            res ^= arr[i];\r\n        }\r\n    }\r\n}\r\n/*\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n/// @title Utility Functions for byte32\r\n/// @author Kongliang Zhong - <kongliang@loopring.org>,\r\n/// @author Daniel Wang - <daniel@loopring.org>.\r\nlibrary MathBytes32 {\r\n    function xorReduce(\r\n        bytes32[]   arr,\r\n        uint        len\r\n        )\r\n        internal\r\n        pure\r\n        returns (bytes32 res)\r\n    {\r\n        res = arr[0];\r\n        for (uint i = 1; i < len; i++) {\r\n            res ^= arr[i];\r\n        }\r\n    }\r\n}\r\n/*\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n/// @title Ring Hash Registry Contract\r\n/// @dev This contracts help reserve ringhashes for miners.\r\n/// @author Kongliang Zhong - <kongliang@loopring.org>,\r\n/// @author Daniel Wang - <daniel@loopring.org>.\r\ncontract RinghashRegistry {\r\n    using MathBytes32   for bytes32[];\r\n    using MathUint8     for uint8[];\r\n    uint public blocksToLive;\r\n    struct Submission {\r\n        address ringminer;\r\n        uint block;\r\n    }\r\n    mapping (bytes32 => Submission) submissions;\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    /// Events                                                               ///\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    event RinghashSubmitted(\r\n        address indexed _ringminer,\r\n        bytes32 indexed _ringhash\r\n    );\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    /// Constructor                                                          ///\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    function RinghashRegistry(uint _blocksToLive)\r\n        public\r\n    {\r\n        require(_blocksToLive > 0);\r\n        blocksToLive = _blocksToLive;\r\n    }\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    /// Public Functions                                                     ///\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    function submitRinghash(\r\n        address     ringminer,\r\n        bytes32     ringhash\r\n        )\r\n        public\r\n    {\r\n        require(canSubmit(ringhash, ringminer)); //, \"Ringhash submitted\");\r\n        submissions[ringhash] = Submission(ringminer, block.number);\r\n        RinghashSubmitted(ringminer, ringhash);\r\n    }\r\n    function batchSubmitRinghash(\r\n        address[]     ringminerList,\r\n        bytes32[]     ringhashList\r\n        )\r\n        external\r\n    {\r\n        uint size = ringminerList.length;\r\n        require(size > 0);\r\n        require(size == ringhashList.length);\r\n        for (uint i = 0; i < size; i++) {\r\n            submitRinghash(ringminerList[i], ringhashList[i]);\r\n        }\r\n    }\r\n    /// @dev Calculate the hash of a ring.\r\n    function calculateRinghash(\r\n        uint        ringSize,\r\n        uint8[]     vList,\r\n        bytes32[]   rList,\r\n        bytes32[]   sList\r\n        )\r\n        private\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        require(\r\n            ringSize == vList.length - 1 && (\r\n            ringSize == rList.length - 1 && (\r\n            ringSize == sList.length - 1))\r\n        ); //, \"invalid ring data\");\r\n        return keccak256(\r\n            vList.xorReduce(ringSize),\r\n            rList.xorReduce(ringSize),\r\n            sList.xorReduce(ringSize)\r\n        );\r\n    }\r\n     /// return value attributes[2] contains the following values in this order:\r\n     /// canSubmit, isReserved.\r\n    function computeAndGetRinghashInfo(\r\n        uint        ringSize,\r\n        address     ringminer,\r\n        uint8[]     vList,\r\n        bytes32[]   rList,\r\n        bytes32[]   sList\r\n        )\r\n        external\r\n        view\r\n        returns (bytes32 ringhash, bool[2] attributes)\r\n    {\r\n        ringhash = calculateRinghash(\r\n            ringSize,\r\n            vList,\r\n            rList,\r\n            sList\r\n        );\r\n        attributes[0] = canSubmit(ringhash, ringminer);\r\n        attributes[1] = isReserved(ringhash, ringminer);\r\n    }\r\n    /// @return true if a ring's hash can be submitted;\r\n    /// false otherwise.\r\n    function canSubmit(\r\n        bytes32 ringhash,\r\n        address ringminer)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        require(ringminer != 0x0);\r\n        var submission = submissions[ringhash];\r\n        address miner = submission.ringminer;\r\n        return (\r\n            miner == 0x0 || (\r\n            submission.block + blocksToLive < block.number) || (\r\n            miner == ringminer)\r\n        );\r\n    }\r\n    /// @return true if a ring's hash was submitted and still valid;\r\n    /// false otherwise.\r\n    function isReserved(\r\n        bytes32 ringhash,\r\n        address ringminer)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        var submission = submissions[ringhash];\r\n        return (\r\n            submission.block + blocksToLive >= block.number && (\r\n            submission.ringminer == ringminer)\r\n        );\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"ringminerList\",\"type\":\"address[]\"},{\"name\":\"ringhashList\",\"type\":\"bytes32[]\"}],\"name\":\"batchSubmitRinghash\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ringSize\",\"type\":\"uint256\"},{\"name\":\"ringminer\",\"type\":\"address\"},{\"name\":\"vList\",\"type\":\"uint8[]\"},{\"name\":\"rList\",\"type\":\"bytes32[]\"},{\"name\":\"sList\",\"type\":\"bytes32[]\"}],\"name\":\"computeAndGetRinghashInfo\",\"outputs\":[{\"name\":\"ringhash\",\"type\":\"bytes32\"},{\"name\":\"attributes\",\"type\":\"bool[2]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ringhash\",\"type\":\"bytes32\"},{\"name\":\"ringminer\",\"type\":\"address\"}],\"name\":\"isReserved\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ringminer\",\"type\":\"address\"},{\"name\":\"ringhash\",\"type\":\"bytes32\"}],\"name\":\"submitRinghash\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blocksToLive\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ringhash\",\"type\":\"bytes32\"},{\"name\":\"ringminer\",\"type\":\"address\"}],\"name\":\"canSubmit\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_blocksToLive\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_ringminer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_ringhash\",\"type\":\"bytes32\"}],\"name\":\"RinghashSubmitted\",\"type\":\"event\"}]","ContractName":"RinghashRegistry","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000064","Library":"","SwarmSource":"bzzr://4e1c6cacbd25d2b83306eca545af57f91d56df3453a89ff79965197c0e62bc42"}]}