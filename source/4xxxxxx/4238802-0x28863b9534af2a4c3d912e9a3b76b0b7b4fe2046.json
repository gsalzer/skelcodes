{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\n// Viberate ICO buyer\r\n// Avtor: Janez\r\n\r\n// ERC20 Interface: https://github.com/ethereum/EIPs/issues/20\r\ncontract ERC20 {\r\n  function transfer(address _to, uint256 _value) returns (bool success);\r\n  function balanceOf(address _owner) constant returns (uint256 balance);\r\n}\r\n\r\ncontract ViberateBuyer {\r\n  // Koliko ETH je vlozil vsak racun.\r\n  mapping (address => uint256) public balances;\r\n  // Nagrada za izvedbo nakupa.\r\n  uint256 public buy_bounty;\r\n  // Nagrada za dvig.\r\n  uint256 public withdraw_bounty;\r\n  // Podatek ali smo tokene uspesno kupili.\r\n  bool public bought_tokens;\r\n  // Vrednost tokenov v pogodbi.\r\n  uint256 public contract_eth_value;\r\n  // Varnostni kill switch v primeru da se najde kriticen hrosc in zelimo pogodbo prekiniti in vsem vrniti ETH.\r\n  bool public kill_switch;\r\n  \r\n  // SHA3 izvlecek gesla.\r\n  bytes32 password_hash = 0xfac0a99293c75e2f2ed76d4eb06030f4f3458f419a67ca0feac3dbe9791275b4;\r\n  // Kdaj najbolj zgodaj lahko kupimo.\r\n  uint256 public earliest_buy_time = 1504612800;\r\n  // Nas interni cap. Zato da ne gremo cez hard cap.\r\n  uint256 public eth_cap = 10000 ether;\r\n  // Naslov razvijalca.\r\n  address public developer = 0x0639C169D9265Ca4B4DEce693764CdA8ea5F3882;\r\n  // Crowdsale naslov.  To lahko nastavi le razvijalec.\r\n  address public sale;\r\n  // Naslov tokena.  To lahko nastavi le razvijalec.\r\n  ERC20 public token;\r\n  \r\n  // Razvijalec s klicom te funkcije nastavi naslov crowdsale-a\r\n  function set_addresses(address _sale, address _token) {\r\n    // Samo razvijalec lahko nastavi naslov in token.\r\n    require(msg.sender == developer);\r\n    // Naslov se lahko nastavi le 1x.\r\n    require(sale == 0x0);\r\n    // Nastavljanje naslova in tokena.\r\n    sale = _sale;\r\n    token = ERC20(_token);\r\n  }\r\n  \r\n  // V skrajni sili lahko razvijalec ali pa kdorkoli s posebnim geslom aktivira 'kill switch'. Po aktivaciji je mozen le se dvig sredstev.\r\n  function activate_kill_switch(string password) {\r\n    // Aktiviraj kill switch samo ce ga aktivira razvijalec, ali pa je geslo pravilno.\r\n    require(msg.sender == developer || sha3(password) == password_hash);\r\n    // Nagrado shranimo v zacasno spremenljivko.\r\n    uint256 claimed_bounty = buy_bounty;\r\n    // Nagrado nastavimo na 0.\r\n    buy_bounty = 0;\r\n    // Aktiviramo kill switch.\r\n    kill_switch = true;\r\n    // Klicatelju posljemo nagrado.\r\n    msg.sender.transfer(claimed_bounty);\r\n  }\r\n  \r\n  // Poslje ETHje ali tokene klicatelju.\r\n  function personal_withdraw(){\r\n    // Ce uporabnik nima denarja koncamo.\r\n    if (balances[msg.sender] == 0) return;\r\n    // Ce pogodbi ni uspelo kupiti, potem vrnemo ETH.\r\n    if (!bought_tokens) {\r\n      // Pred dvigom shranimo uporabnikov vlozek v zacasno spremenljivko.\r\n      uint256 eth_to_withdraw = balances[msg.sender];\r\n      // Uporabnik sedaj nima vec ETH.\r\n      balances[msg.sender] = 0;\r\n      // ETH vrnemo uporabniku.\r\n      msg.sender.transfer(eth_to_withdraw);\r\n    }\r\n    // Ce je pogodba uspesno kupila tokene, jih nakazemo uporabniku.\r\n    else {\r\n      // Preverimo koliko tokenov ima pogodba.\r\n      uint256 contract_token_balance = token.balanceOf(address(this));\r\n      // Ce se nimamo tokenov, potem ne dvigujemo.\r\n      require(contract_token_balance != 0);\r\n      // Shranimo stevilo uporabnikovih tokenov v zacasno spremenljivko.\r\n      uint256 tokens_to_withdraw = (balances[msg.sender] * contract_token_balance) / contract_eth_value;\r\n      // Odstejemo uporabnikovo vrednost od vrednosti pogodbe.\r\n      contract_eth_value -= balances[msg.sender];\r\n      // Odstejemo uporabnikovo vrednost.\r\n      balances[msg.sender] = 0;\r\n      // 1% strosek za pogodbo ce smo tokene kupili.\r\n      uint256 fee = tokens_to_withdraw / 100;\r\n      // Poslji strosek razvijalcu.\r\n      require(token.transfer(developer, fee));\r\n      // Posljemo tokene uporabniku.\r\n      require(token.transfer(msg.sender, tokens_to_withdraw - fee));\r\n    }\r\n  }\r\n\r\n  // Poslje ETHje uporabniku ali pa tokene in nagradi klicatelja funkcije.\r\n  function withdraw(address user){\r\n    // Dvig dovoljen ce smo kupili tokene ali pa cez eno uro po crowdsalu (ce nismo), ali pa ce je aktiviran kill switch.\r\n    require(bought_tokens || now > earliest_buy_time + 1 hours || kill_switch);\r\n    // Ce uporabnik nima denarja koncamo.\r\n    if (balances[user] == 0) return;\r\n    // Ce pogodbi ni uspelo kupiti, potem vrnemo ETH.\r\n    if (!bought_tokens) {\r\n      // Pred dvigom shranimo uporabnikov vlozek v zacasno spremenljivko.\r\n      uint256 eth_to_withdraw = balances[user];\r\n      // Uporabnik sedaj nima vec ETH.\r\n      balances[user] = 0;\r\n      // ETH vrnemo uporabniku.\r\n      user.transfer(eth_to_withdraw);\r\n    }\r\n    // Ce je pogodba uspesno kupila tokene, jih nakazemo uporabniku.\r\n    else {\r\n      // Preverimo koliko tokenov ima pogodba.\r\n      uint256 contract_token_balance = token.balanceOf(address(this));\r\n      // Ce se nimamo tokenov, potem ne dvigujemo.\r\n      require(contract_token_balance != 0);\r\n      // Shranimo stevilo uporabnikovih tokenov v zacasno spremenljivko.\r\n      uint256 tokens_to_withdraw = (balances[user] * contract_token_balance) / contract_eth_value;\r\n      // Odstejemo uporabnikovo vrednost od vrednosti pogodbe.\r\n      contract_eth_value -= balances[user];\r\n      // Odstejemo uporabnikovo vrednost.\r\n      balances[user] = 0;\r\n      // 1% strosek za pogodbo ce smo tokene kupili.\r\n      uint256 fee = tokens_to_withdraw / 100;\r\n      // Poslji strosek razvijalcu.\r\n      require(token.transfer(developer, fee));\r\n      // Posljemo tokene uporabniku.\r\n      require(token.transfer(user, tokens_to_withdraw - fee));\r\n    }\r\n    // Vsak klic za dvig dobi 1% nagrade za dvig.\r\n    uint256 claimed_bounty = withdraw_bounty / 100;\r\n    // Zmanjsamo nagrado za dvig.\r\n    withdraw_bounty -= claimed_bounty;\r\n    // Klicatelju posljemo nagrado.\r\n    msg.sender.transfer(claimed_bounty);\r\n  }\r\n  \r\n  // Razvijalec lahko doda ETH v nagrado za vplacilo.\r\n  function add_to_buy_bounty() payable {\r\n    // Samo razvijalec lahko doda nagrado.\r\n    require(msg.sender == developer);\r\n    // Povecaj nagrado.\r\n    buy_bounty += msg.value;\r\n  }\r\n  \r\n  // Razvijalec lahko doda nagrado za dvig.\r\n  function add_to_withdraw_bounty() payable {\r\n    // Samo razvijalec lahko doda nagrado za dvig.\r\n    require(msg.sender == developer);\r\n    // Povecaj nagrado za dvig.\r\n    withdraw_bounty += msg.value;\r\n  }\r\n  \r\n  // Kupi tokene v crowdsalu, nagradi klicatelja. To funkcijo lahko poklice kdorkoli.\r\n  function claim_bounty(){\r\n    // Ce smo ze kupili koncamo.\r\n    if (bought_tokens) return;\r\n    // Ce cas se ni dosezen, koncamo.\r\n    if (now < earliest_buy_time) return;\r\n    // Ce je aktiviran 'kill switch', koncamo.\r\n    if (kill_switch) return;\r\n    // Ce razvijalec se ni dodal naslova, potem ne kupujemo.\r\n    require(sale != 0x0);\r\n    // Zapomnimo si da smo kupili tokene.\r\n    bought_tokens = true;\r\n    // Nagrado shranemo v zacasno spremenljivko.\r\n    uint256 claimed_bounty = buy_bounty;\r\n    // Nagrade zdaj ni vec.\r\n    buy_bounty = 0;\r\n    // Zapomnimo si koliko ETH smo poslali na crowdsale (vse razen nagrad)\r\n    contract_eth_value = this.balance - (claimed_bounty + withdraw_bounty);\r\n    // Poslje celoten znesek ETH (brez nagrad) na crowdsale naslov.\r\n    require(sale.call.value(contract_eth_value)());\r\n    // Klicatelju posljemo nagrado.\r\n    msg.sender.transfer(claimed_bounty);\r\n  }\r\n  \r\n  // Ta funkcija se poklice ko kdorkoli poslje ETH na pogodbo.\r\n  function () payable {\r\n    // Zavrnemo transakcijo, ce je kill switch aktiviran.\r\n    require(!kill_switch);\r\n    // Vplacila so dovoljena dokler se nismo kupili tokenov.\r\n    require(!bought_tokens);\r\n    // Vplacila so dovoljena dokler nismo dosegli nasega capa.\r\n    require(this.balance < eth_cap);\r\n    // Shranimo uporabnikov vlozek.\r\n    balances[msg.sender] += msg.value;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"claim_bounty\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buy_bounty\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"add_to_withdraw_bounty\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sale\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"set_addresses\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bought_tokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sale\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"add_to_buy_bounty\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kill_switch\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdraw_bounty\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"personal_withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contract_eth_value\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"developer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"password\",\"type\":\"string\"}],\"name\":\"activate_kill_switch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"eth_cap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"earliest_buy_time\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"ViberateBuyer","CompilerVersion":"v0.4.16+commit.d7661dd9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://37856eb836993db0d04b2ed5354896172c7ea245160d965ae84864184253a691"}]}