{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.15;\r\n\r\n\r\n/**\r\n * Math operations with safety checks\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint a, uint b) internal returns (uint) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n}\r\n\r\n\r\n/// @dev `Owned` is a base level contract that assigns an `owner` that can be\r\n///  later changed\r\ncontract Owned {\r\n\r\n    /// @dev `owner` is the only address that can call a function with this\r\n    /// modifier\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    address public owner;\r\n\r\n    /// @notice The Constructor assigns the message sender to be `owner`\r\n    function Owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    address public newOwner;\r\n\r\n    /// @notice `owner` can step down and assign some other address to this role\r\n    /// @param _newOwner The address of the new owner. 0x0 can be used to create\r\n    function changeOwner(address _newOwner) onlyOwner {\r\n        if(msg.sender == owner) {\r\n            owner = _newOwner;\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract DynamicCeiling is Owned {\r\n    using SafeMath for uint256;\r\n\r\n    struct Ceiling {\r\n        bytes32 hash;\r\n        uint256 limit;\r\n        uint256 slopeFactor;\r\n        uint256 collectMinimum;\r\n    }\r\n\r\n    address public saleAddress;\r\n\r\n    Ceiling[] public ceilings;\r\n    \r\n    uint256 public currentIndex;\r\n    uint256 public revealedCeilings;\r\n    bool public allRevealed;\r\n\r\n    modifier onlySaleAddress {\r\n        require(msg.sender == saleAddress);\r\n        _;\r\n    }\r\n\r\n    function DynamicCeiling(address _owner, address _saleAddress) {\r\n        owner = _owner;\r\n        saleAddress = _saleAddress;\r\n    }\r\n\r\n    /// @notice This should be called by the creator of the contract to commit\r\n    ///  all the ceilings.\r\n    /// @param _ceilingHashes Array of hashes of each ceiling. Each hash is calculated\r\n    ///  by the `calculateHash` method. More hashes than actual ceilings can be\r\n    ///  committed in order to hide also the number of ceilings.\r\n    ///  The remaining hashes can be just random numbers.\r\n    function setHiddenCeilings(bytes32[] _ceilingHashes) public onlyOwner {\r\n        require(ceilings.length == 0);\r\n\r\n        ceilings.length = _ceilingHashes.length;\r\n        for (uint256 i = 0; i < _ceilingHashes.length; i = i.add(1)) {\r\n            ceilings[i].hash = _ceilingHashes[i];\r\n        }\r\n    }\r\n\r\n    /// @notice Anybody can reveal the next ceiling if he knows it.\r\n    /// @param _limit Ceiling cap.\r\n    ///  (must be greater or equal to the previous one).\r\n    /// @param _last `true` if it's the last ceiling.\r\n    /// @param _salt Random number used to commit the ceiling\r\n    function revealCeiling(\r\n        uint256 _limit, \r\n        uint256 _slopeFactor, \r\n        uint256 _collectMinimum,\r\n        bool _last, \r\n        bytes32 _salt) \r\n        public \r\n        {\r\n        require(!allRevealed);\r\n        require(\r\n            ceilings[revealedCeilings].hash == \r\n            calculateHash(\r\n                _limit, \r\n                _slopeFactor, \r\n                _collectMinimum, \r\n                _last, \r\n                _salt\r\n            )\r\n        );\r\n\r\n        require(_limit != 0 && _slopeFactor != 0 && _collectMinimum != 0);\r\n        if (revealedCeilings > 0) {\r\n            require(_limit >= ceilings[revealedCeilings.sub(1)].limit);\r\n        }\r\n\r\n        ceilings[revealedCeilings].limit = _limit;\r\n        ceilings[revealedCeilings].slopeFactor = _slopeFactor;\r\n        ceilings[revealedCeilings].collectMinimum = _collectMinimum;\r\n        revealedCeilings = revealedCeilings.add(1);\r\n\r\n        if (_last) {\r\n            allRevealed = true;\r\n        }\r\n    }\r\n\r\n    /// @notice Reveal multiple ceilings at once\r\n    function revealMulti(\r\n        uint256[] _limits,\r\n        uint256[] _slopeFactors,\r\n        uint256[] _collectMinimums,\r\n        bool[] _lasts, \r\n        bytes32[] _salts) \r\n        public \r\n        {\r\n        // Do not allow none and needs to be same length for all parameters\r\n        require(\r\n            _limits.length != 0 &&\r\n            _limits.length == _slopeFactors.length &&\r\n            _limits.length == _collectMinimums.length &&\r\n            _limits.length == _lasts.length &&\r\n            _limits.length == _salts.length\r\n        );\r\n\r\n        for (uint256 i = 0; i < _limits.length; i = i.add(1)) {\r\n            \r\n            revealCeiling(\r\n                _limits[i],\r\n                _slopeFactors[i],\r\n                _collectMinimums[i],\r\n                _lasts[i],\r\n                _salts[i]\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @notice Move to ceiling, used as a failsafe\r\n    function moveToNextCeiling() public onlyOwner {\r\n\r\n        currentIndex = currentIndex.add(1);\r\n    }\r\n\r\n    /// @return Return the funds to collect for the current point on the ceiling\r\n    ///  (or 0 if no ceilings revealed yet)\r\n    function availableAmountToCollect(uint256  totallCollected) public onlySaleAddress returns (uint256) {\r\n    \r\n        if (revealedCeilings == 0) {\r\n            return 0;\r\n        }\r\n\r\n        if (totallCollected >= ceilings[currentIndex].limit) {  \r\n            uint256 nextIndex = currentIndex.add(1);\r\n\r\n            if (nextIndex >= revealedCeilings) {\r\n                return 0; \r\n            }\r\n            currentIndex = nextIndex;\r\n            if (totallCollected >= ceilings[currentIndex].limit) {\r\n                return 0;  \r\n            }\r\n        }        \r\n        uint256 remainedFromCurrentCeiling = ceilings[currentIndex].limit.sub(totallCollected);\r\n        uint256 reminderWithSlopeFactor = remainedFromCurrentCeiling.div(ceilings[currentIndex].slopeFactor);\r\n\r\n        if (reminderWithSlopeFactor > ceilings[currentIndex].collectMinimum) {\r\n            return reminderWithSlopeFactor;\r\n        }\r\n        \r\n        if (remainedFromCurrentCeiling > ceilings[currentIndex].collectMinimum) {\r\n            return ceilings[currentIndex].collectMinimum;\r\n        } else {\r\n            return remainedFromCurrentCeiling;\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates the hash of a ceiling.\r\n    /// @param _limit Ceiling cap.\r\n    /// @param _last `true` if it's the last ceiling.\r\n    /// @param _collectMinimum the minimum amount to collect\r\n    /// @param _salt Random number that will be needed to reveal this ceiling.\r\n    /// @return The calculated hash of this ceiling to be used in the `setHiddenCurves` method\r\n    function calculateHash(\r\n        uint256 _limit, \r\n        uint256 _slopeFactor, \r\n        uint256 _collectMinimum,\r\n        bool _last, \r\n        bytes32 _salt) \r\n        public \r\n        constant \r\n        returns (bytes32) \r\n        {\r\n        return keccak256(\r\n            _limit,\r\n            _slopeFactor, \r\n            _collectMinimum,\r\n            _last,\r\n            _salt\r\n        );\r\n    }\r\n\r\n    /// @return Return the total number of ceilings committed\r\n    ///  (can be larger than the number of actual ceilings on the ceiling to hide\r\n    ///  the real number of ceilings)\r\n    function nCeilings() public constant returns (uint256) {\r\n        return ceilings.length;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"currentIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"moveToNextCeiling\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allRevealed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"revealedCeilings\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_limits\",\"type\":\"uint256[]\"},{\"name\":\"_slopeFactors\",\"type\":\"uint256[]\"},{\"name\":\"_collectMinimums\",\"type\":\"uint256[]\"},{\"name\":\"_lasts\",\"type\":\"bool[]\"},{\"name\":\"_salts\",\"type\":\"bytes32[]\"}],\"name\":\"revealMulti\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ceilingHashes\",\"type\":\"bytes32[]\"}],\"name\":\"setHiddenCeilings\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_limit\",\"type\":\"uint256\"},{\"name\":\"_slopeFactor\",\"type\":\"uint256\"},{\"name\":\"_collectMinimum\",\"type\":\"uint256\"},{\"name\":\"_last\",\"type\":\"bool\"},{\"name\":\"_salt\",\"type\":\"bytes32\"}],\"name\":\"calculateHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_limit\",\"type\":\"uint256\"},{\"name\":\"_slopeFactor\",\"type\":\"uint256\"},{\"name\":\"_collectMinimum\",\"type\":\"uint256\"},{\"name\":\"_last\",\"type\":\"bool\"},{\"name\":\"_salt\",\"type\":\"bytes32\"}],\"name\":\"revealCeiling\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ceilings\",\"outputs\":[{\"name\":\"hash\",\"type\":\"bytes32\"},{\"name\":\"limit\",\"type\":\"uint256\"},{\"name\":\"slopeFactor\",\"type\":\"uint256\"},{\"name\":\"collectMinimum\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nCeilings\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"totallCollected\",\"type\":\"uint256\"}],\"name\":\"availableAmountToCollect\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_saleAddress\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"}]","ContractName":"DynamicCeiling","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000ab7802165732d11fa921863e6868eb03f33eda540000000000000000000000004a22459eabe46fbf2fd992f11487b6beda44673e","Library":"","SwarmSource":"bzzr://7b94d8b78cbf1a7a2247b695317134c95344b0f8baa1c64c1d41792cf40969f2"}]}