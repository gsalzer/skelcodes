{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * The Edgeless blackjack contract only allows calls from the authorized casino proxy contracts. \r\n * The proxy contract only forward moves if called by an authorized wallet owned by the Edgeless casino, but the game\r\n * data has to be signed by the player to show his approval. This way, Edgeless can provide a fluid game experience\r\n * without having to wait for transaction confirmations.\r\n * author: Julia Altenried\r\n **/\r\npragma solidity ^0.4.17;\r\n\r\ncontract owned {\r\n  address public owner;\r\n  modifier onlyOwner {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  function owned() public{\r\n    owner = msg.sender;\r\n  }\r\n\r\n  function changeOwner(address newOwner) onlyOwner public {\r\n    owner = newOwner;\r\n  }\r\n}\r\n\r\ncontract mortal is owned {\r\n  function close() onlyOwner public{\r\n    selfdestruct(owner);\r\n  }\r\n}\r\n\r\ncontract casino is mortal{\r\n  /** the minimum bet**/\r\n  uint public minimumBet;\r\n  /** the maximum bet **/\r\n  uint public maximumBet;\r\n  /** tells if an address is authorized to call game functions **/\r\n  mapping(address => bool) public authorized;\r\n  \r\n  /** \r\n   * constructur. initialize the contract with initial values. \r\n   * @param minBet         the minimum bet\r\n   *        maxBet         the maximum bet\r\n   **/\r\n  function casino(uint minBet, uint maxBet) public{\r\n    minimumBet = minBet;\r\n    maximumBet = maxBet;\r\n  }\r\n\r\n  /** \r\n   * allows the owner to change the minimum bet\r\n   * @param newMin the new minimum bet\r\n   **/\r\n  function setMinimumBet(uint newMin) onlyOwner public{\r\n    minimumBet = newMin;\r\n  }\r\n\r\n  /** \r\n   * allows the owner to change the maximum bet\r\n   * @param newMax the new maximum bet\r\n   **/\r\n  function setMaximumBet(uint newMax) onlyOwner public{\r\n    maximumBet = newMax;\r\n  }\r\n\r\n  \r\n  /**\r\n  * authorize a address to call game functions.\r\n  * @param addr the address to be authorized\r\n  **/\r\n  function authorize(address addr) onlyOwner public{\r\n    authorized[addr] = true;\r\n  }\r\n  \r\n  /**\r\n  * deauthorize a address to call game functions.\r\n  * @param addr the address to be deauthorized\r\n  **/\r\n  function deauthorize(address addr) onlyOwner public{\r\n    authorized[addr] = false;\r\n  }\r\n  \r\n  \r\n  /**\r\n  * checks if an address is authorized to call game functionality\r\n  **/\r\n  modifier onlyAuthorized{\r\n    require(authorized[msg.sender]);\r\n    _;\r\n  }\r\n}\r\n\r\ncontract blackjack is casino {\r\n\r\n  /** the value of the cards: Ace, 2, 3, 4, 5, 6, 7, 8, 9, 10, J, Q, K . Ace can be 1 or 11, of course. \r\n   *   the value of a card can be determined by looking up cardValues[cardId%13]**/\r\n  uint8[13] cardValues = [11, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 10];\r\n  /** tells if the player already claimed his win **/\r\n  mapping(bytes32 => bool) public over;\r\n  /** the bets of the games in case they have been initialized before stand **/\r\n  mapping(bytes32 => uint) bets;\r\n   /** list of splits per game - length 0 in most cases **/\r\n  mapping(bytes32 => uint8[]) splits;\r\n  /** tells if a hand of a given game has been doubled **/\r\n  mapping(bytes32 => mapping(uint8 => bool)) doubled;\r\n  \r\n  /** notify listeners that a new round of blackjack started **/\r\n  event NewGame(bytes32 indexed id, bytes32 deck, bytes32 cSeed, address player, uint bet);\r\n  /** notify listeners of the game outcome **/\r\n  event Result(bytes32 indexed id, address player, uint value, bool isWin);\r\n  /** notify listeners that the player doubled **/\r\n  event Double(bytes32 indexed id, uint8 hand);\r\n  /** notify listeners that the player split **/\r\n  event Split(bytes32 indexed id, uint8 hand);\r\n\r\n  /** \r\n   * constructur. initialize the contract with a minimum bet. \r\n   * @param minBet         the minimum bet\r\n   *        maxBet         the maximum bet\r\n   **/\r\n  function blackjack(uint minBet, uint maxBet) casino(minBet, maxBet) public{\r\n\r\n  }\r\n\r\n  /** \r\n   *   initializes a round of blackjack. \r\n   *   accepts the bet.\r\n   *   throws an exception if the bet is too low or a game with the given id has already been played or the bet was already paid.\r\n   *   @param player  the address of the player\r\n   *          value   the value of the bet in tokens\r\n   *          deck    the hash of the deck\r\n   *          srvSeed the hash of the server seed\r\n   *          cSeed   the plain client seed\r\n   **/\r\n  function initGame(address player, uint value, bytes32 deck, bytes32 srvSeed, bytes32 cSeed) onlyAuthorized  public{\r\n    //throw if game with id already exists. later maybe throw only if game with id is still running\r\n    assert(value >= minimumBet && value <= maximumBet);\r\n    assert(!over[srvSeed]&&bets[srvSeed]==0);//make sure the game hasn't been payed already\r\n    bets[srvSeed] = value;\r\n    assert(msg.sender.call(bytes4(keccak256(\"shift(address,uint256,bool)\")),player, value, false));\r\n    NewGame(srvSeed, deck, cSeed, player, value);\r\n  }\r\n\r\n  /**\r\n   *   doubles the bet of the game with the given id if the correct amount is sent and the player did not double the hand yet.\r\n   *   @param player the player address\r\n   *          id     the game id\r\n   *          hand   the index of the hand being doubled\r\n   *          value  the number of tokens sent by the player\r\n   **/\r\n  function double(address player, bytes32 id, uint8 hand, uint value) onlyAuthorized public {\r\n    require(!over[id]);\r\n    require(checkBet(id, value));//make sure the game has been initialized and the transfered value is correct\r\n    require(hand <= splits[id].length && !doubled[id][hand]);//make sure the hand has not been doubled yet\r\n    doubled[id][hand] = true;\r\n    bets[id] += value;\r\n    assert(msg.sender.call(bytes4(keccak256(\"shift(address,uint256,bool)\")),player, value, false));\r\n    Double(id, hand);\r\n  }\r\n\r\n  /**\r\n   *   splits the hands of the game with the given id if the correct amount is sent from the player address and the player\r\n   *   did not split yet.\r\n   *   @param player the player address\r\n   *          id     the game id\r\n   *          hand   the index of the hand being split\r\n   *          value  the number of tokens sent by the player\r\n   **/\r\n  function split(address player, bytes32 id, uint8 hand, uint value) onlyAuthorized public  {\r\n    require(!over[id]);\r\n    require(checkBet(id, value));//make sure the game has been initialized and the transfered value is correct\r\n    require(splits[id].length < 3);\r\n    splits[id].push(hand);\r\n    bets[id] += value;\r\n    assert(msg.sender.call(bytes4(keccak256(\"shift(address,uint256,bool)\")),player, value, false));\r\n    Split(id,hand);\r\n  }\r\n  \r\n  /**\r\n   * by surrendering half the bet is returned to the player.\r\n   * send the plain server seed to check if it's correct\r\n   * @param player the player address\r\n   *        seed   the server seed\r\n   *        bet    the original bet\r\n   **/\r\n  function surrender(address player, bytes32 seed, uint bet) onlyAuthorized public {\r\n    var id = keccak256(seed);\r\n    require(!over[id]);\r\n    over[id] = true;\r\n    if(bets[id]>0){\r\n      assert(bets[id]==bet);\r\n      assert(msg.sender.call(bytes4(keccak256(\"shift(address,uint256,bool)\")),player,bet / 2, true));\r\n      Result(id, player, bet / 2, true);\r\n    }\r\n    else{\r\n      assert(msg.sender.call(bytes4(keccak256(\"shift(address,uint256,bool)\")),player,bet / 2, false));\r\n      Result(id, player, bet / 2, false);\r\n    }\r\n  }\r\n\r\n  /** \r\n   * first checks if deck and the player's number of cards are correct, then checks if the player won and if so, sends the win.\r\n   * @param player the player address\r\n   *        deck      the partial deck\r\n   *        seed      the plain server seed\r\n   *        numCards  the number of cards per hand\r\n   *        splits    the array of splits\r\n   *        doubled   the array indicating if a hand was doubled\r\n   *        bet       the original bet\r\n   *        deckHash  the hash of the deck (for verification and logging)\r\n   *        cSeed     the client seed (for logging)\r\n   **/\r\n  function stand(address player, uint8[] deck, bytes32 seed, uint8[] numCards, uint8[] splits, bool[] doubled,uint bet, bytes32 deckHash, bytes32 cSeed) onlyAuthorized public {\r\n    bytes32 gameId;\r\n    gameId = keccak256(seed);\r\n    assert(!over[gameId]);\r\n    assert(splits.length == numCards.length - 1);\r\n    over[gameId] = true;\r\n    assert(checkDeck(deck, seed, deckHash));//plausibility check\r\n    \r\n    var (win,loss) = determineOutcome(deck, numCards, splits, doubled, bet);\r\n    \r\n    if(bets[gameId] > 0){//initGame method called before\r\n      assert(checkBet(gameId, bet));\r\n      win += bets[gameId];//pay back the bet\r\n    }\r\n    else\r\n      NewGame(gameId, deckHash, cSeed, player, bet);\r\n    \r\n    if (win > loss){\r\n      assert(msg.sender.call(bytes4(keccak256(\"shift(address,uint256,bool)\")),player, win-loss, true));\r\n      Result(gameId, player, win-loss, true); \r\n    }  \r\n    else if(loss > win){//shift balance from the player to the casino\r\n      assert(msg.sender.call(bytes4(keccak256(\"shift(address,uint256,bool)\")),player, loss-win, false));\r\n      Result(gameId, player, loss-win, false); \r\n    }\r\n    else\r\n      Result(gameId, player, 0, false);\r\n     \r\n  }\r\n\r\n  /**\r\n   * check if deck and casino seed are correct.\r\n   * @param deck      the partial deck\r\n   *        seed      the server seed\r\n   *        deckHash  the hash of the deck\r\n   * @return true if correct\r\n   **/\r\n  function checkDeck(uint8[] deck, bytes32 seed, bytes32 deckHash) constant public returns(bool correct) {\r\n    if (keccak256(convertToBytes(deck), seed) != deckHash) return false;\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * converts an uint8 array to bytes\r\n   * @param byteArray the uint8 array to be converted\r\n   * @return the bytes\r\n   **/\r\n  function convertToBytes(uint8[] byteArray) internal constant returns(bytes b) {\r\n    b = new bytes(byteArray.length);\r\n    for (uint8 i = 0; i < byteArray.length; i++)\r\n      b[i] = byte(byteArray[i]);\r\n  }\r\n  \r\n  /**\r\n   * checks if the correct amount was paid for the initial bet + splits and doubles.\r\n   * @param gameId the game id\r\n   *        bet    the bet\r\n   * @return true if correct\r\n   * */\r\n  function checkBet(bytes32 gameId, uint bet) internal constant returns (bool correct){\r\n    uint factor = splits[gameId].length + 1;\r\n    for(uint8 i = 0; i < splits[gameId].length+1; i++){\r\n      if(doubled[gameId][i]) factor++;\r\n    }\r\n    return bets[gameId] == bet * factor;\r\n  }\r\n\r\n  /**\r\n   * determines the outcome of a game and returns the win. \r\n   * in case of a loss, win is 0.\r\n   * @param cards     the cards / partial deck\r\n   *        numCards  the number of cards per hand\r\n   *        splits    the array of splits\r\n   *        doubled   the array indicating if a hand was doubled\r\n   *        bet       the original bet\r\n   * @return the total win of all hands\r\n   **/\r\n  function determineOutcome(uint8[] cards, uint8[] numCards, uint8[] splits, bool[] doubled, uint bet) constant public returns(uint totalWin, uint totalLoss) {\r\n\r\n    var playerValues = getPlayerValues(cards, numCards, splits);\r\n    var (dealerValue, dealerBJ) = getDealerValue(cards, sum(numCards));\r\n    uint win;\r\n    uint loss;\r\n    for (uint8 h = 0; h < numCards.length; h++) {\r\n      uint8 playerValue = playerValues[h];\r\n      //bust if value > 21\r\n      if (playerValue > 21){\r\n        win = 0;\r\n        loss = bet;\r\n      } \r\n      //player blackjack but no dealer blackjack\r\n      else if (numCards.length == 1 && playerValue == 21 && numCards[h] == 2 && !dealerBJ) {\r\n        win = bet * 3 / 2; //pay 3 to 2\r\n        loss = 0;\r\n      }\r\n      //player wins regularly\r\n      else if (playerValue > dealerValue || dealerValue > 21){\r\n        win = bet;\r\n        loss = 0;\r\n      }\r\n      //tie\r\n      else if (playerValue == dealerValue){\r\n        win = 0;\r\n        loss = 0;\r\n      }\r\n      //player looses\r\n      else{\r\n        win = 0;\r\n        loss = bet;\r\n      }\r\n\r\n      if (doubled[h]){\r\n        win *= 2;\r\n        loss *= 2;\r\n      } \r\n      totalWin += win;\r\n      totalLoss += loss;\r\n    }\r\n  }\r\n\r\n  /**\r\n   *   calculates the value of the player's hands.\r\n   *   @param cards     holds the (partial) deck.\r\n   *          numCards  the number of cards per player hand\r\n   *          pSplits   the player's splits (hand index)\r\n   *   @return the values of the player's hands\r\n   **/\r\n  function getPlayerValues(uint8[] cards, uint8[] numCards, uint8[] pSplits) constant internal returns(uint8[5] playerValues) {\r\n    uint8 cardIndex;\r\n    uint8 splitIndex;\r\n    (cardIndex, splitIndex, playerValues) = playHand(0, 0, 0, playerValues, cards, numCards, pSplits);\r\n  }\r\n\r\n  /**\r\n   *   recursively plays the player's hands.\r\n   *   @param hIndex        the hand index\r\n   *          cIndex        the index of the next card to draw\r\n   *          sIndex        the index of the next split, if there is any\r\n   *          playerValues  the values of the player's hands (not yet complete)\r\n   *          cards         holds the (partial) deck.\r\n   *          numCards      the number of cards per player hand\r\n   *          pSplits        the array of splits\r\n   *   @return the values of the player's hands and the current card index\r\n   **/\r\n  function playHand(uint8 hIndex, uint8 cIndex, uint8 sIndex, uint8[5] playerValues, uint8[] cards, uint8[] numCards, uint8[] pSplits) constant internal returns(uint8, uint8, uint8[5]) {\r\n    playerValues[hIndex] = cardValues[cards[cIndex] % 13];\r\n    cIndex = cIndex < 4 ? cIndex + 2 : cIndex + 1;\r\n    while (sIndex < pSplits.length && pSplits[sIndex] == hIndex) {\r\n      sIndex++;\r\n      (cIndex, sIndex, playerValues) = playHand(sIndex, cIndex, sIndex, playerValues, cards, numCards, pSplits);\r\n    }\r\n    uint8 numAces = playerValues[hIndex] == 11 ? 1 : 0;\r\n    uint8 card;\r\n    for (uint8 i = 1; i < numCards[hIndex]; i++) {\r\n      card = cards[cIndex] % 13;\r\n      playerValues[hIndex] += cardValues[card];\r\n      if (card == 0) numAces++;\r\n      cIndex = cIndex < 4 ? cIndex + 2 : cIndex + 1;\r\n    }\r\n    while (numAces > 0 && playerValues[hIndex] > 21) {\r\n      playerValues[hIndex] -= 10;\r\n      numAces--;\r\n    }\r\n    return (cIndex, sIndex, playerValues);\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   *   calculates the value of a dealer's hand.\r\n   *   @param cards     holds the (partial) deck.\r\n   *          numCards  the number of cards the player holds\r\n   *   @return the value of the dealer's hand and a flag indicating if the dealer has got a blackjack\r\n   **/\r\n  function getDealerValue(uint8[] cards, uint8 numCards) constant internal returns(uint8 dealerValue, bool bj) {\r\n\r\n    //dealer always receives second and forth card\r\n    uint8 card = cards[1] % 13;\r\n    uint8 card2 = cards[3] % 13;\r\n    dealerValue = cardValues[card] + cardValues[card2];\r\n    uint8 numAces;\r\n    if (card == 0) numAces++;\r\n    if (card2 == 0) numAces++;\r\n    if (dealerValue > 21) { //2 aces,count as 12\r\n      dealerValue -= 10;\r\n      numAces--;\r\n    } else if (dealerValue == 21) {\r\n      return (21, true);\r\n    }\r\n    //take cards until value reaches 17 or more. \r\n    uint8 i;\r\n    while (dealerValue < 17) {\r\n      card = cards[numCards + i + 2] % 13;\r\n      dealerValue += cardValues[card];\r\n      if (card == 0) numAces++;\r\n      if (dealerValue > 21 && numAces > 0) {\r\n        dealerValue -= 10;\r\n        numAces--;\r\n      }\r\n      i++;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * sums up the given numbers\r\n   * note: no overflow possible as player will always hold less than 100 cards\r\n   * @param numbers   the numbers to sum up\r\n   * @return the sum of the numbers\r\n   **/\r\n  function sum(uint8[] numbers) constant internal returns(uint8 s) {\r\n    for (uint i = 0; i < numbers.length; i++) {\r\n      s += numbers[i];\r\n    }\r\n  }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"cards\",\"type\":\"uint8[]\"},{\"name\":\"numCards\",\"type\":\"uint8[]\"},{\"name\":\"splits\",\"type\":\"uint8[]\"},{\"name\":\"doubled\",\"type\":\"bool[]\"},{\"name\":\"bet\",\"type\":\"uint256\"}],\"name\":\"determineOutcome\",\"outputs\":[{\"name\":\"totalWin\",\"type\":\"uint256\"},{\"name\":\"totalLoss\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMax\",\"type\":\"uint256\"}],\"name\":\"setMaximumBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"hand\",\"type\":\"uint8\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"double\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maximumBet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"deauthorize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"close\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"deck\",\"type\":\"uint8[]\"},{\"name\":\"seed\",\"type\":\"bytes32\"},{\"name\":\"deckHash\",\"type\":\"bytes32\"}],\"name\":\"checkDeck\",\"outputs\":[{\"name\":\"correct\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMin\",\"type\":\"uint256\"}],\"name\":\"setMinimumBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"deck\",\"type\":\"bytes32\"},{\"name\":\"srvSeed\",\"type\":\"bytes32\"},{\"name\":\"cSeed\",\"type\":\"bytes32\"}],\"name\":\"initGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"deck\",\"type\":\"uint8[]\"},{\"name\":\"seed\",\"type\":\"bytes32\"},{\"name\":\"numCards\",\"type\":\"uint8[]\"},{\"name\":\"splits\",\"type\":\"uint8[]\"},{\"name\":\"doubled\",\"type\":\"bool[]\"},{\"name\":\"bet\",\"type\":\"uint256\"},{\"name\":\"deckHash\",\"type\":\"bytes32\"},{\"name\":\"cSeed\",\"type\":\"bytes32\"}],\"name\":\"stand\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"over\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"authorize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumBet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"hand\",\"type\":\"uint8\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"split\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"seed\",\"type\":\"bytes32\"},{\"name\":\"bet\",\"type\":\"uint256\"}],\"name\":\"surrender\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"minBet\",\"type\":\"uint256\"},{\"name\":\"maxBet\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"deck\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"cSeed\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"bet\",\"type\":\"uint256\"}],\"name\":\"NewGame\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"isWin\",\"type\":\"bool\"}],\"name\":\"Result\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"hand\",\"type\":\"uint8\"}],\"name\":\"Double\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"hand\",\"type\":\"uint8\"}],\"name\":\"Split\",\"type\":\"event\"}]","ContractName":"blackjack","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000c800000000000000000000000000000000000000000000000000000000000007d0","Library":"","SwarmSource":"bzzr://7b6d1bfec9714850bd4f702f18fb2223ae1475bb21d1a0b507240438446a401d"}]}